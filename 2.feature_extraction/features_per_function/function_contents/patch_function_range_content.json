{
  "patch/patch-2.7.6/lib/alloca.in.h": {},
  "patch/patch-2.7.6/lib/arg-nonnull.h": {},
  "patch/patch-2.7.6/lib/argmatch.c": {
    "__argmatch_die": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static void\n__argmatch_die (void)\n{\n  ARGMATCH_DIE;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argmatch": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "ptrdiff_t\nargmatch (const char *arg, const char *const *arglist,\n          const char *vallist, size_t valsize)\n{\n  size_t i;                     /* Temporary index in ARGLIST.  */\n  size_t arglen;                /* Length of ARG.  */\n  ptrdiff_t matchind = -1;      /* Index of first nonexact match.  */\n  bool ambiguous = false;       /* If true, multiple nonexact match(es).  */\n\n  arglen = strlen (arg);\n\n  /* Test all elements for either exact match or abbreviated matches.  */\n  for (i = 0; arglist[i]; i++)\n    {\n      if (!strncmp (arglist[i], arg, arglen))\n        {\n          if (strlen (arglist[i]) == arglen)\n            /* Exact match found.  */\n            return i;\n          else if (matchind == -1)\n            /* First nonexact match found.  */\n            matchind = i;\n          else\n            {\n              /* Second nonexact match found.  */\n              if (vallist == NULL\n                  || memcmp (vallist + valsize * matchind,\n                             vallist + valsize * i, valsize))\n                {\n                  /* There is a real ambiguity, or we could not\n                     disambiguate. */\n                  ambiguous = true;\n                }\n            }\n        }\n    }\n  if (ambiguous)\n    return -2;\n  else\n    return matchind;\n}",
      "lines": 41,
      "depth": 17,
      "decorators": [
        "ptrdiff_t"
      ]
    },
    "argmatch_invalid": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\nargmatch_invalid (const char *context, const char *value, ptrdiff_t problem)\n{\n  char const *format = (problem == -1\n                        ? _(\"invalid argument %s for %s\")\n                        : _(\"ambiguous argument %s for %s\"));\n\n  error (0, 0, format, quotearg_n_style (0, ARGMATCH_QUOTING_STYLE, value),\n         quote_n (1, context));\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "argmatch_valid": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\nargmatch_valid (const char *const *arglist,\n                const char *vallist, size_t valsize)\n{\n  size_t i;\n  const char *last_val = NULL;\n\n  /* We try to put synonyms on the same line.  The assumption is that\n     synonyms follow each other */\n  fputs (_(\"Valid arguments are:\"), stderr);\n  for (i = 0; arglist[i]; i++)\n    if ((i == 0)\n        || memcmp (last_val, vallist + valsize * i, valsize))\n      {\n        fprintf (stderr, \"\\n  - %s\", quote (arglist[i]));\n        last_val = vallist + valsize * i;\n      }\n    else\n      {\n        fprintf (stderr, \", %s\", quote (arglist[i]));\n      }\n  putc ('\\n', stderr);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "__xargmatch_internal": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "ptrdiff_t\n__xargmatch_internal (const char *context,\n                      const char *arg, const char *const *arglist,\n                      const char *vallist, size_t valsize,\n                      argmatch_exit_fn exit_fn)\n{\n  ptrdiff_t res = argmatch (arg, arglist, vallist, valsize);\n  if (res >= 0)\n    /* Success. */\n    return res;\n\n  /* We failed.  Explain why. */\n  argmatch_invalid (context, arg, res);\n  argmatch_valid (arglist, vallist, valsize);\n  (*exit_fn) ();\n\n  return -1; /* To please the compilers. */\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "ptrdiff_t"
      ]
    },
    "argmatch_to_argument": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "const char *\nargmatch_to_argument (const char *value,\n                      const char *const *arglist,\n                      const char *vallist, size_t valsize)\n{\n  size_t i;\n\n  for (i = 0; arglist[i]; i++)\n    if (!memcmp (value, vallist + valsize * i, valsize))\n      return arglist[i];\n  return NULL;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nargmatch_to_argument (const char *value,\n                      const char *const *arglist,\n                      const char *vallist, size_t valsize)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "int\nmain (int argc, const char *const *argv)\n{\n  const char *cp;\n  enum backup_type backup_type = no_backups;\n\n  if (argc > 2)\n    {\n      fprintf (stderr, \"Usage: %s [VERSION_CONTROL]\\n\", getprogname ());\n      exit (1);\n    }\n\n  if ((cp = getenv (\"VERSION_CONTROL\")))\n    backup_type = XARGMATCH (\"$VERSION_CONTROL\", cp,\n                             backup_args, backup_vals);\n\n  if (argc == 2)\n    backup_type = XARGMATCH (getprogname (), argv[1],\n                             backup_args, backup_vals);\n\n  printf (\"The version control is '%s'\\n\",\n          ARGMATCH_TO_ARGUMENT (backup_type, backup_args, backup_vals));\n\n  return 0;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/argmatch.h": {},
  "patch/patch-2.7.6/lib/asnprintf.c": {
    "asnprintf": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "char",
        "*\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/asprintf.c": {
    "asprintf": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nasprintf (char **resultp, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = vasprintf (resultp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/assure.h": {},
  "patch/patch-2.7.6/lib/at-func.c": {
    "AT_FUNC_NAME": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "FUNC_RESULT\nAT_FUNC_NAME (int fd, char const *file AT_FUNC_POST_FILE_PARAM_DECLS)\n{\n  VALIDATE_FLAG (flag);\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return CALL_FUNC (file);\n\n#ifdef GNULIB_SUPPORT_ONLY_AT_FDCWD\n  errno = ENOTSUP;\n  return FUNC_FAIL;\n#else\n  {\n  /* Be careful to choose names unlikely to conflict with\n     AT_FUNC_POST_FILE_PARAM_DECLS.  */\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  FUNC_RESULT err;\n\n  {\n    char proc_buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (proc_buf, fd, file);\n    if (proc_file)\n      {\n        FUNC_RESULT proc_result = CALL_FUNC (proc_file);\n        int proc_errno = errno;\n        if (proc_file != proc_buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (FUNC_FAIL != proc_result)\n          return proc_result;\n        if (! EXPECTED_ERRNO (proc_errno))\n          {\n            errno = proc_errno;\n            return proc_result;\n          }\n      }\n  }\n\n  if (save_cwd (&saved_cwd) != 0)\n    openat_save_fail (errno);\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return FUNC_FAIL;\n    }\n\n  if (fchdir (fd) != 0)\n    {\n      saved_errno = errno;\n      free_cwd (&saved_cwd);\n      errno = saved_errno;\n      return FUNC_FAIL;\n    }\n\n  err = CALL_FUNC (file);\n  saved_errno = (err == FUNC_FAIL ? errno : 0);\n\n  if (restore_cwd (&saved_cwd) != 0)\n    openat_restore_fail (errno);\n\n  free_cwd (&saved_cwd);\n\n  if (saved_errno)\n    errno = saved_errno;\n  return err;\n  }\n#endif\n}",
      "lines": 75,
      "depth": 14,
      "decorators": [
        "FUNC_RESULT"
      ]
    }
  },
  "patch/patch-2.7.6/lib/at-func2.c": {
    "at_func2": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "int\nat_func2 (int fd1, char const *file1,\n          int fd2, char const *file2,\n          int (*func) (char const *file1, char const *file2))\n{\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  int err;\n  char *file1_alt;\n  char *file2_alt;\n  struct stat st1;\n  struct stat st2;\n\n  /* There are 16 possible scenarios, based on whether an fd is\n     AT_FDCWD or real, and whether a file is absolute or relative:\n\n         fd1  file1 fd2  file2  action\n     0   cwd  abs   cwd  abs    direct call\n     1   cwd  abs   cwd  rel    direct call\n     2   cwd  abs   fd   abs    direct call\n     3   cwd  abs   fd   rel    chdir to fd2\n     4   cwd  rel   cwd  abs    direct call\n     5   cwd  rel   cwd  rel    direct call\n     6   cwd  rel   fd   abs    direct call\n     7   cwd  rel   fd   rel    convert file1 to abs, then case 3\n     8   fd   abs   cwd  abs    direct call\n     9   fd   abs   cwd  rel    direct call\n     10  fd   abs   fd   abs    direct call\n     11  fd   abs   fd   rel    chdir to fd2\n     12  fd   rel   cwd  abs    chdir to fd1\n     13  fd   rel   cwd  rel    convert file2 to abs, then case 12\n     14  fd   rel   fd   abs    chdir to fd1\n     15a fd1  rel   fd1  rel    chdir to fd1\n     15b fd1  rel   fd2  rel    chdir to fd1, then case 7\n\n     Try some optimizations to reduce fd to AT_FDCWD, or to at least\n     avoid converting an absolute name or doing a double chdir.  */\n\n  if ((fd1 == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file1))\n      && (fd2 == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file2)))\n    return func (file1, file2); /* Case 0-2, 4-6, 8-10.  */\n\n  /* If /proc/self/fd works, we don't need any stat or chdir.  */\n  {\n    char proc_buf1[OPENAT_BUFFER_SIZE];\n    char *proc_file1 = ((fd1 == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file1))\n                        ? (char *) file1\n                        : openat_proc_name (proc_buf1, fd1, file1));\n    if (proc_file1)\n      {\n        char proc_buf2[OPENAT_BUFFER_SIZE];\n        char *proc_file2 = ((fd2 == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file2))\n                            ? (char *) file2\n                            : openat_proc_name (proc_buf2, fd2, file2));\n        if (proc_file2)\n          {\n            int proc_result = func (proc_file1, proc_file2);\n            int proc_errno = errno;\n            if (proc_file1 != proc_buf1 && proc_file1 != file1)\n              free (proc_file1);\n            if (proc_file2 != proc_buf2 && proc_file2 != file2)\n              free (proc_file2);\n            /* If the syscall succeeds, or if it fails with an unexpected\n               errno value, then return right away.  Otherwise, fall through\n               and resort to using save_cwd/restore_cwd.  */\n            if (0 <= proc_result)\n              return proc_result;\n            if (! EXPECTED_ERRNO (proc_errno))\n              {\n                errno = proc_errno;\n                return proc_result;\n              }\n          }\n        else if (proc_file1 != proc_buf1 && proc_file1 != file1)\n          free (proc_file1);\n      }\n  }\n\n  /* Cases 3, 7, 11-15 remain.  Time to normalize directory fds, if\n     possible.  */\n  if (IS_ABSOLUTE_FILE_NAME (file1))\n    fd1 = AT_FDCWD; /* Case 11 reduced to 3.  */\n  else if (IS_ABSOLUTE_FILE_NAME (file2))\n    fd2 = AT_FDCWD; /* Case 14 reduced to 12.  */\n\n  /* Cases 3, 7, 12, 13, 15 remain.  */\n\n  if (fd1 == AT_FDCWD) /* Cases 3, 7.  */\n    {\n      if (stat (\".\", &st1) == -1 || fstat (fd2, &st2) == -1)\n        return -1;\n      if (!S_ISDIR (st2.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      if (SAME_INODE (st1, st2)) /* Reduced to cases 1, 5.  */\n        return func (file1, file2);\n    }\n  else if (fd2 == AT_FDCWD) /* Cases 12, 13.  */\n    {\n      if (stat (\".\", &st2) == -1 || fstat (fd1, &st1) == -1)\n        return -1;\n      if (!S_ISDIR (st1.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      if (SAME_INODE (st1, st2)) /* Reduced to cases 4, 5.  */\n        return func (file1, file2);\n    }\n  else if (fd1 != fd2) /* Case 15b.  */\n    {\n      if (fstat (fd1, &st1) == -1 || fstat (fd2, &st2) == -1)\n        return -1;\n      if (!S_ISDIR (st1.st_mode) || !S_ISDIR (st2.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      if (SAME_INODE (st1, st2)) /* Reduced to case 15a.  */\n        {\n          fd2 = fd1;\n          if (stat (\".\", &st1) == 0 && SAME_INODE (st1, st2))\n            return func (file1, file2); /* Further reduced to case 5.  */\n        }\n    }\n  else /* Case 15a.  */\n    {\n      if (fstat (fd1, &st1) == -1)\n        return -1;\n      if (!S_ISDIR (st1.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      if (stat (\".\", &st2) == 0 && SAME_INODE (st1, st2))\n        return func (file1, file2); /* Reduced to case 5.  */\n    }\n\n  /* Cases 3, 7, 12, 13, 15a, 15b remain.  With all reductions in\n     place, it is time to start changing directories.  */\n\n  if (save_cwd (&saved_cwd) != 0)\n    openat_save_fail (errno);\n\n  if (fd1 != AT_FDCWD && fd2 != AT_FDCWD && fd1 != fd2) /* Case 15b.  */\n    {\n      if (fchdir (fd1) != 0)\n        {\n          saved_errno = errno;\n          free_cwd (&saved_cwd);\n          errno = saved_errno;\n          return -1;\n        }\n      fd1 = AT_FDCWD; /* Reduced to case 7.  */\n    }\n\n  /* Cases 3, 7, 12, 13, 15a remain.  Convert one relative name to\n     absolute, if necessary.  */\n\n  file1_alt = (char *) file1;\n  file2_alt = (char *) file2;\n\n  if (fd1 == AT_FDCWD && !IS_ABSOLUTE_FILE_NAME (file1)) /* Case 7.  */\n    {\n      /* It would be nicer to use:\n         file1_alt = file_name_concat (xgetcwd (), file1, NULL);\n         but libraries should not call xalloc_die.  */\n      char *cwd = getcwd (NULL, 0);\n      if (!cwd)\n        {\n          saved_errno = errno;\n          free_cwd (&saved_cwd);\n          errno = saved_errno;\n          return -1;\n        }\n      file1_alt = mfile_name_concat (cwd, file1, NULL);\n      if (!file1_alt)\n        {\n          saved_errno = errno;\n          free (cwd);\n          free_cwd (&saved_cwd);\n          errno = saved_errno;\n          return -1;\n        }\n      free (cwd); /* Reduced to case 3.  */\n    }\n  else if (fd2 == AT_FDCWD && !IS_ABSOLUTE_FILE_NAME (file2)) /* Case 13.  */\n    {\n      char *cwd = getcwd (NULL, 0);\n      if (!cwd)\n        {\n          saved_errno = errno;\n          free_cwd (&saved_cwd);\n          errno = saved_errno;\n          return -1;\n        }\n      file2_alt = mfile_name_concat (cwd, file2, NULL);\n      if (!file2_alt)\n        {\n          saved_errno = errno;\n          free (cwd);\n          free_cwd (&saved_cwd);\n          errno = saved_errno;\n          return -1;\n        }\n      free (cwd); /* Reduced to case 12.  */\n    }\n\n  /* Cases 3, 12, 15a remain.  Change to the correct directory.  */\n  if (fchdir (fd1 == AT_FDCWD ? fd2 : fd1) != 0)\n    {\n      saved_errno = errno;\n      free_cwd (&saved_cwd);\n      if (file1 != file1_alt)\n        free (file1_alt);\n      else if (file2 != file2_alt)\n        free (file2_alt);\n      errno = saved_errno;\n      return -1;\n    }\n\n  /* Finally safe to perform the user's function, then clean up.  */\n\n  err = func (file1_alt, file2_alt);\n  saved_errno = (err < 0 ? errno : 0);\n\n  if (file1 != file1_alt)\n    free (file1_alt);\n  else if (file2 != file2_alt)\n    free (file2_alt);\n\n  if (restore_cwd (&saved_cwd) != 0)\n    openat_restore_fail (errno);\n\n  free_cwd (&saved_cwd);\n\n  if (saved_errno)\n    errno = saved_errno;\n  return err;\n}",
      "lines": 242,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/backup-find.c": {
    "find_backup_file_name": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\nfind_backup_file_name (char const *file, enum backup_type backup_type)\n{\n  char *result = backupfile_internal (file, backup_type, false);\n  if (!result)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nfind_backup_file_name (char const *file, enum backup_type backup_type)",
        "*"
      ]
    },
    "get_version": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "enum backup_type\nget_version (char const *context, char const *version)\n{\n  if (version == 0 || *version == 0)\n    return numbered_existing_backups;\n  else\n    return XARGMATCH (context, version, backup_args, backup_types);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "enum backup_type",
        "enum",
        "backup_type"
      ]
    },
    "xget_version": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "enum backup_type\nxget_version (char const *context, char const *version)\n{\n  if (version && *version)\n    return get_version (context, version);\n  else\n    return get_version (\"$VERSION_CONTROL\", getenv (\"VERSION_CONTROL\"));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "enum backup_type",
        "enum",
        "backup_type"
      ]
    }
  },
  "patch/patch-2.7.6/lib/backup-internal.h": {},
  "patch/patch-2.7.6/lib/backupfile.c": {
    "set_simple_backup_suffix": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nset_simple_backup_suffix (char const *s)\n{\n  if (!s)\n    s = getenv (\"SIMPLE_BACKUP_SUFFIX\");\n  simple_backup_suffix = s && *s && s == last_component (s) ? s : \"~\";\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_extension": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static void\ncheck_extension (char *file, size_t filelen, char e)\n{\n  char *base = last_component (file);\n  size_t baselen = base_len (base);\n  size_t baselen_max = HAVE_LONG_FILE_NAMES ? 255 : NAME_MAX_MINIMUM;\n\n  if (HAVE_DOS_FILE_NAMES || NAME_MAX_MINIMUM < baselen)\n    {\n      /* The new base name is long enough to require a pathconf check.  */\n      long name_max;\n\n      /* Temporarily modify the buffer into its parent directory name,\n         invoke pathconf on the directory, and then restore the buffer.  */\n      char tmp[sizeof \".\"];\n      memcpy (tmp, base, sizeof \".\");\n      strcpy (base, \".\");\n      errno = 0;\n      name_max = pathconf (file, _PC_NAME_MAX);\n      if (0 <= name_max || errno == 0)\n        {\n          long size = baselen_max = name_max;\n          if (name_max != size)\n            baselen_max = SIZE_MAX;\n        }\n      memcpy (base, tmp, sizeof \".\");\n    }\n\n  if (HAVE_DOS_FILE_NAMES && baselen_max <= 12)\n    {\n      /* Live within DOS's 8.3 limit.  */\n      char *dot = strchr (base, '.');\n      if (!dot)\n        baselen_max = 8;\n      else\n        {\n          char const *second_dot = strchr (dot + 1, '.');\n          baselen_max = (second_dot\n                         ? second_dot - base\n                         : dot + 1 - base + 3);\n        }\n    }\n\n  if (baselen_max < baselen)\n    {\n      baselen = file + filelen - base;\n      if (baselen_max <= baselen)\n        baselen = baselen_max - 1;\n      base[baselen] = e;\n      base[baselen + 1] = '\\0';\n    }\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "numbered_backup": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static enum numbered_backup_result\nnumbered_backup (char **buffer, size_t buffer_size, size_t filelen,\n                 ptrdiff_t base_offset, DIR **dirpp)\n{\n  enum numbered_backup_result result = BACKUP_IS_NEW;\n  DIR *dirp = *dirpp;\n  struct dirent *dp;\n  char *buf = *buffer;\n  size_t versionlenmax = 1;\n  char *base = buf + base_offset;\n  size_t baselen = base_len (base);\n\n  if (dirp)\n    rewinddir (dirp);\n  else\n    {\n      /* Temporarily modify the buffer into its parent directory name,\n         open the directory, and then restore the buffer.  */\n      char tmp[sizeof \".\"];\n      memcpy (tmp, base, sizeof \".\");\n      strcpy (base, \".\");\n      dirp = opendir (buf);\n      if (!dirp && errno == ENOMEM)\n        result = BACKUP_NOMEM;\n      memcpy (base, tmp, sizeof \".\");\n      strcpy (base + baselen, \".~1~\");\n      if (!dirp)\n        return result;\n      *dirpp = dirp;\n    }\n\n  while ((dp = readdir (dirp)) != NULL)\n    {\n      char const *p;\n      char *q;\n      bool all_9s;\n      size_t versionlen;\n\n      if (_D_EXACT_NAMLEN (dp) < baselen + 4)\n        continue;\n\n      if (memcmp (buf + base_offset, dp->d_name, baselen + 2) != 0)\n        continue;\n\n      p = dp->d_name + baselen + 2;\n\n      /* Check whether this file has a version number and if so,\n         whether it is larger.  Use string operations rather than\n         integer arithmetic, to avoid problems with integer overflow.  */\n\n      if (! ('1' <= *p && *p <= '9'))\n        continue;\n      all_9s = (*p == '9');\n      for (versionlen = 1; ISDIGIT (p[versionlen]); versionlen++)\n        all_9s &= (p[versionlen] == '9');\n\n      if (! (p[versionlen] == '~' && !p[versionlen + 1]\n             && (versionlenmax < versionlen\n                 || (versionlenmax == versionlen\n                     && memcmp (buf + filelen + 2, p, versionlen) <= 0))))\n        continue;\n\n      /* This entry has the largest version number seen so far.\n         Append this highest numbered extension to the file name,\n         prepending '0' to the number if it is all 9s.  */\n\n      versionlenmax = all_9s + versionlen;\n      result = (all_9s ? BACKUP_IS_LONGER : BACKUP_IS_SAME_LENGTH);\n      size_t new_buffer_size = filelen + 2 + versionlenmax + 2;\n      if (buffer_size < new_buffer_size)\n        {\n          if (! xalloc_oversized (new_buffer_size, 2))\n            new_buffer_size *= 2;\n          char *new_buf = realloc (buf, new_buffer_size);\n          if (!new_buf)\n            {\n              *buffer = buf;\n              return BACKUP_NOMEM;\n            }\n          buf = new_buf;\n          buffer_size = new_buffer_size;\n        }\n      q = buf + filelen;\n      *q++ = '.';\n      *q++ = '~';\n      *q = '0';\n      q += all_9s;\n      memcpy (q, p, versionlen + 2);\n\n      /* Add 1 to the version number.  */\n\n      q += versionlen;\n      while (*--q == '9')\n        *q = '0';\n      ++*q;\n    }\n\n  *buffer = buf;\n  return result;\n}",
      "lines": 100,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "enum numbered_backup_result",
        "enum",
        "numbered_backup_result"
      ]
    },
    "backupfile_internal": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "char *\nbackupfile_internal (char const *file, enum backup_type backup_type, bool rename)\n{\n  ptrdiff_t base_offset = last_component (file) - file;\n  size_t filelen = base_offset + strlen (file + base_offset);\n\n  if (! simple_backup_suffix)\n    set_simple_backup_suffix (NULL);\n\n  /* Allow room for simple or \".~N~\" backups.  The guess must be at\n     least sizeof \".~1~\", but otherwise will be adjusted as needed.  */\n  size_t simple_backup_suffix_size = strlen (simple_backup_suffix) + 1;\n  size_t backup_suffix_size_guess = simple_backup_suffix_size;\n  enum { GUESS = sizeof \".~12345~\" };\n  if (backup_suffix_size_guess < GUESS)\n    backup_suffix_size_guess = GUESS;\n\n  ssize_t ssize = filelen + backup_suffix_size_guess + 1;\n  char *s = malloc (ssize);\n  if (!s)\n    return s;\n\n  DIR *dirp = NULL;\n  while (true)\n    {\n      memcpy (s, file, filelen + 1);\n\n      if (backup_type == simple_backups)\n        memcpy (s + filelen, simple_backup_suffix, simple_backup_suffix_size);\n      else\n        switch (numbered_backup (&s, ssize, filelen, base_offset, &dirp))\n          {\n          case BACKUP_IS_SAME_LENGTH:\n            break;\n\n          case BACKUP_IS_NEW:\n            if (backup_type == numbered_existing_backups)\n              {\n                backup_type = simple_backups;\n                memcpy (s + filelen, simple_backup_suffix,\n                        simple_backup_suffix_size);\n              }\n            check_extension (s, filelen, '~');\n            break;\n\n          case BACKUP_IS_LONGER:\n            check_extension (s, filelen, '~');\n            break;\n\n          case BACKUP_NOMEM:\n            free (s);\n            errno = ENOMEM;\n            return NULL;\n          }\n\n      if (! rename)\n        break;\n\n      int sdir = dirp ? dirfd (dirp) : -1;\n      if (sdir < 0)\n        {\n          sdir = AT_FDCWD;\n          base_offset = 0;\n        }\n      unsigned flags = backup_type == simple_backups ? 0 : RENAME_NOREPLACE;\n      if (renameat2 (AT_FDCWD, file, sdir, s + base_offset, flags) == 0)\n        break;\n      int e = errno;\n      if (e != EEXIST)\n        {\n          if (dirp)\n            closedir (dirp);\n          free (s);\n          errno = e;\n          return NULL;\n        }\n    }\n\n  if (dirp)\n    closedir (dirp);\n  return s;\n}",
      "lines": 82,
      "depth": 15,
      "decorators": [
        "char",
        "*\nbackupfile_internal (char const *file, enum backup_type backup_type, bool rename)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/backupfile.h": {},
  "patch/patch-2.7.6/lib/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/basename.c": {
    "base_name": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char *\nbase_name (char const *name)\n{\n  char const *base = last_component (name);\n  size_t length;\n\n  /* If there is no last component, then name is a file system root or the\n     empty string.  */\n  if (! *base)\n    return xstrndup (name, base_len (name));\n\n  /* Collapse a sequence of trailing slashes into one.  */\n  length = base_len (base);\n  if (ISSLASH (base[length]))\n    length++;\n\n  /* On systems with drive letters, \"a/b:c\" must return \"./b:c\" rather\n     than \"b:c\" to avoid confusion with a drive letter.  On systems\n     with pure POSIX semantics, this is not an issue.  */\n  if (FILE_SYSTEM_PREFIX_LEN (base))\n    {\n      char *p = xmalloc (length + 3);\n      p[0] = '.';\n      p[1] = '/';\n      memcpy (p + 2, base, length);\n      p[length + 2] = '\\0';\n      return p;\n    }\n\n  /* Finally, copy the basename.  */\n  return xstrndup (base, length);\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "char",
        "*\nbase_name (char const *name)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/bitrotate.c": {},
  "patch/patch-2.7.6/lib/bitrotate.h": {
    "uint64_t": [
      {
        "start_point": [
          37,
          0
        ],
        "end_point": [
          41,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotl64 (uint64_t x, int n)\n{\n  return ((x << n) | (x >> (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotr64 (uint64_t x, int n)\n{\n  return ((x >> n) | (x << (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint32_t": [
      {
        "start_point": [
          56,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotl32 (uint32_t x, int n)\n{\n  return ((x << n) | (x >> (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          65,
          0
        ],
        "end_point": [
          69,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotr32 (uint32_t x, int n)\n{\n  return ((x >> n) | (x << (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "rotl_sz": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotl_sz (size_t x, int n)\n{\n  return ((x << n) | (x >> ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "rotr_sz": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotr_sz (size_t x, int n)\n{\n  return ((x >> n) | (x << ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "uint16_t": [
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          98,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotl16 (uint16_t x, int n)\n{\n  return ((x << n) | (x >> (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          105,
          0
        ],
        "end_point": [
          109,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotr16 (uint16_t x, int n)\n{\n  return ((x >> n) | (x << (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint8_t": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotl8 (uint8_t x, int n)\n{\n  return ((x << n) | (x >> (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          127,
          0
        ],
        "end_point": [
          131,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotr8 (uint8_t x, int n)\n{\n  return ((x >> n) | (x << (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ]
  },
  "patch/patch-2.7.6/lib/c++defs.h": {},
  "patch/patch-2.7.6/lib/c-ctype.c": {},
  "patch/patch-2.7.6/lib/c-ctype.h": {
    "c_isalnum": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalnum (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalpha (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isascii": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isascii (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_CNTRL:\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isblank (int c)\n{\n  return c == ' ' || c == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_iscntrl (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_CNTRL:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isgraph (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_islower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isprint (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_ispunct (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_PUNCT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isspace (int c)\n{\n  switch (c)\n    {\n    case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isxdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_A_THRU_F:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_tolower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return c - 'A' + 'a';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_toupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return c - 'a' + 'A';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/c-strcase.h": {},
  "patch/patch-2.7.6/lib/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/canonicalize-lgpl.c": {
    "alloc_failed": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static void\nalloc_failed (void)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Avoid errno problem without using the malloc or realloc modules; see:\n     https://lists.gnu.org/r/bug-gnulib/2016-08/msg00025.html  */\n  errno = ENOMEM;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__realpath": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "char *\n__realpath (const char *name, char *resolved)\n{\n  char *rpath, *dest, *extra_buf = NULL;\n  const char *start, *end, *rpath_limit;\n  long int path_max;\n  int num_links = 0;\n  size_t prefix_len;\n\n  if (name == NULL)\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n         either parameter is a null pointer.  We extend this to allow\n         the RESOLVED parameter to be NULL in case the we are expected to\n         allocate the room for the return value.  */\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  if (name[0] == '\\0')\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n         the name argument points to an empty string.  */\n      __set_errno (ENOENT);\n      return NULL;\n    }\n\n#ifdef PATH_MAX\n  path_max = PATH_MAX;\n#else\n  path_max = pathconf (name, _PC_PATH_MAX);\n  if (path_max <= 0)\n    path_max = 8192;\n#endif\n\n  if (resolved == NULL)\n    {\n      rpath = malloc (path_max);\n      if (rpath == NULL)\n        {\n          alloc_failed ();\n          return NULL;\n        }\n    }\n  else\n    rpath = resolved;\n  rpath_limit = rpath + path_max;\n\n  /* This is always zero for Posix hosts, but can be 2 for MS-Windows\n     and MS-DOS X:/foo/bar file names.  */\n  prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  if (!IS_ABSOLUTE_FILE_NAME (name))\n    {\n      if (!__getcwd (rpath, path_max))\n        {\n          rpath[0] = '\\0';\n          goto error;\n        }\n      dest = strchr (rpath, '\\0');\n      start = name;\n      prefix_len = FILE_SYSTEM_PREFIX_LEN (rpath);\n    }\n  else\n    {\n      dest = rpath;\n      if (prefix_len)\n        {\n          memcpy (rpath, name, prefix_len);\n          dest += prefix_len;\n        }\n      *dest++ = '/';\n      if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n        {\n          if (ISSLASH (name[1]) && !ISSLASH (name[2]) && !prefix_len)\n            *dest++ = '/';\n          *dest = '\\0';\n        }\n      start = name + prefix_len;\n    }\n\n  for (end = start; *start; start = end)\n    {\n#ifdef _LIBC\n      struct stat64 st;\n#else\n      struct stat st;\n#endif\n\n      /* Skip sequence of multiple path-separators.  */\n      while (ISSLASH (*start))\n        ++start;\n\n      /* Find end of path component.  */\n      for (end = start; *end && !ISSLASH (*end); ++end)\n        /* Nothing.  */;\n\n      if (end - start == 0)\n        break;\n      else if (end - start == 1 && start[0] == '.')\n        /* nothing */;\n      else if (end - start == 2 && start[0] == '.' && start[1] == '.')\n        {\n          /* Back up to previous component, ignore if at root already.  */\n          if (dest > rpath + prefix_len + 1)\n            for (--dest; dest > rpath && !ISSLASH (dest[-1]); --dest)\n              continue;\n          if (DOUBLE_SLASH_IS_DISTINCT_ROOT\n              && dest == rpath + 1 && !prefix_len\n              && ISSLASH (*dest) && !ISSLASH (dest[1]))\n            dest++;\n        }\n      else\n        {\n          size_t new_size;\n\n          if (!ISSLASH (dest[-1]))\n            *dest++ = '/';\n\n          if (dest + (end - start) >= rpath_limit)\n            {\n              ptrdiff_t dest_offset = dest - rpath;\n              char *new_rpath;\n\n              if (resolved)\n                {\n                  __set_errno (ENAMETOOLONG);\n                  if (dest > rpath + prefix_len + 1)\n                    dest--;\n                  *dest = '\\0';\n                  goto error;\n                }\n              new_size = rpath_limit - rpath;\n              if (end - start + 1 > path_max)\n                new_size += end - start + 1;\n              else\n                new_size += path_max;\n              new_rpath = (char *) realloc (rpath, new_size);\n              if (new_rpath == NULL)\n                {\n                  alloc_failed ();\n                  goto error;\n                }\n              rpath = new_rpath;\n              rpath_limit = rpath + new_size;\n\n              dest = rpath + dest_offset;\n            }\n\n#ifdef _LIBC\n          dest = __mempcpy (dest, start, end - start);\n#else\n          memcpy (dest, start, end - start);\n          dest += end - start;\n#endif\n          *dest = '\\0';\n\n          /* FIXME: if lstat fails with errno == EOVERFLOW,\n             the entry exists.  */\n#ifdef _LIBC\n          if (__lxstat64 (_STAT_VER, rpath, &st) < 0)\n#else\n          if (lstat (rpath, &st) < 0)\n#endif\n            goto error;\n\n          if (S_ISLNK (st.st_mode))\n            {\n              char *buf;\n              size_t len;\n              ssize_t n;\n\n              if (++num_links > MAXSYMLINKS)\n                {\n                  __set_errno (ELOOP);\n                  goto error;\n                }\n\n              buf = malloca (path_max);\n              if (!buf)\n                {\n                  __set_errno (ENOMEM);\n                  goto error;\n                }\n\n              n = __readlink (rpath, buf, path_max - 1);\n              if (n < 0)\n                {\n                  int saved_errno = errno;\n                  freea (buf);\n                  __set_errno (saved_errno);\n                  goto error;\n                }\n              buf[n] = '\\0';\n\n              if (!extra_buf)\n                {\n                  extra_buf = malloca (path_max);\n                  if (!extra_buf)\n                    {\n                      freea (buf);\n                      __set_errno (ENOMEM);\n                      goto error;\n                    }\n                }\n\n              len = strlen (end);\n              /* Check that n + len + 1 doesn't overflow and is <= path_max. */\n              if (n >= SIZE_MAX - len || n + len >= path_max)\n                {\n                  freea (buf);\n                  __set_errno (ENAMETOOLONG);\n                  goto error;\n                }\n\n              /* Careful here, end may be a pointer into extra_buf... */\n              memmove (&extra_buf[n], end, len + 1);\n              name = end = memcpy (extra_buf, buf, n);\n\n              if (IS_ABSOLUTE_FILE_NAME (buf))\n                {\n                  size_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);\n\n                  if (pfxlen)\n                    memcpy (rpath, buf, pfxlen);\n                  dest = rpath + pfxlen;\n                  *dest++ = '/'; /* It's an absolute symlink */\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n                    {\n                      if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)\n                        *dest++ = '/';\n                      *dest = '\\0';\n                    }\n                  /* Install the new prefix to be in effect hereafter.  */\n                  prefix_len = pfxlen;\n                }\n              else\n                {\n                  /* Back up to previous component, ignore if at root\n                     already: */\n                  if (dest > rpath + prefix_len + 1)\n                    for (--dest; dest > rpath && !ISSLASH (dest[-1]); --dest)\n                      continue;\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rpath + 1\n                      && ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)\n                    dest++;\n                }\n            }\n          else if (!S_ISDIR (st.st_mode) && *end != '\\0')\n            {\n              __set_errno (ENOTDIR);\n              goto error;\n            }\n        }\n    }\n  if (dest > rpath + prefix_len + 1 && ISSLASH (dest[-1]))\n    --dest;\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rpath + 1 && !prefix_len\n      && ISSLASH (*dest) && !ISSLASH (dest[1]))\n    dest++;\n  *dest = '\\0';\n\n  if (extra_buf)\n    freea (extra_buf);\n\n  return rpath;\n\nerror:\n  {\n    int saved_errno = errno;\n    if (extra_buf)\n      freea (extra_buf);\n    if (resolved == NULL)\n      free (rpath);\n    __set_errno (saved_errno);\n  }\n  return NULL;\n}",
      "lines": 278,
      "depth": 24,
      "decorators": [
        "char",
        "*\n__realpath (const char *name, char *resolved)",
        "*"
      ]
    },
    "__old_realpath": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "char *\nattribute_compat_text_section\n__old_realpath (const char *name, char *resolved)\n{\n  if (resolved == NULL)\n    {\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  return __realpath (name, resolved);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nattribute_compat_text_section\n__old_realpath (const char *name, char *resolved)",
        "*",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "__canonicalize_file_name": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "char *\n__canonicalize_file_name (const char *name)\n{\n  return __realpath (name, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__canonicalize_file_name (const char *name)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/chdir-long.c": {
    "cdb_init": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static void\ncdb_init (struct cd_buf *cdb)\n{\n  cdb->fd = AT_FDCWD;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_fchdir": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static int\ncdb_fchdir (struct cd_buf const *cdb)\n{\n  return fchdir (cdb->fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cdb_free": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static void\ncdb_free (struct cd_buf const *cdb)\n{\n  if (0 <= cdb->fd)\n    {\n      bool close_fail = close (cdb->fd);\n      assure (! close_fail);\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_advance_fd": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\ncdb_advance_fd (struct cd_buf *cdb, char const *dir)\n{\n  int new_fd = openat (cdb->fd, dir,\n                       O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n  if (new_fd < 0)\n    return -1;\n\n  cdb_free (cdb);\n  cdb->fd = new_fd;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_non_slash": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static char * _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)\n{\n  size_t n_slash = strspn (s, \"/\");\n  return (char *) s + n_slash;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "* _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "chdir_long": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nchdir_long (char *dir)\n{\n  int e = chdir (dir);\n  if (e == 0 || errno != ENAMETOOLONG)\n    return e;\n\n  {\n    size_t len = strlen (dir);\n    char *dir_end = dir + len;\n    struct cd_buf cdb;\n    size_t n_leading_slash;\n\n    cdb_init (&cdb);\n\n    /* If DIR is the empty string, then the chdir above\n       must have failed and set errno to ENOENT.  */\n    assure (0 < len);\n    assure (PATH_MAX <= len);\n\n    /* Count leading slashes.  */\n    n_leading_slash = strspn (dir, \"/\");\n\n    /* Handle any leading slashes as well as any name that matches\n       the regular expression, m!^//hostname[/]*! .  Handling this\n       prefix separately usually results in a single additional\n       cdb_advance_fd call, but it's worthwhile, since it makes the\n       code in the following loop cleaner.  */\n    if (n_leading_slash == 2)\n      {\n        int err;\n        /* Find next slash.\n           We already know that dir[2] is neither a slash nor '\\0'.  */\n        char *slash = memchr (dir + 3, '/', dir_end - (dir + 3));\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n        *slash = '\\0';\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n        dir = find_non_slash (slash + 1);\n      }\n    else if (n_leading_slash)\n      {\n        if (cdb_advance_fd (&cdb, \"/\") != 0)\n          goto Fail;\n        dir += n_leading_slash;\n      }\n\n    assure (*dir != '/');\n    assure (dir <= dir_end);\n\n    while (PATH_MAX <= dir_end - dir)\n      {\n        int err;\n        /* Find a slash that is PATH_MAX or fewer bytes away from dir.\n           I.e. see if there is a slash that will give us a name of\n           length PATH_MAX-1 or less.  */\n        char *slash = memrchr (dir, '/', PATH_MAX);\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n\n        *slash = '\\0';\n        assure (slash - dir < PATH_MAX);\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n\n        dir = find_non_slash (slash + 1);\n      }\n\n    if (dir < dir_end)\n      {\n        if (cdb_advance_fd (&cdb, dir) != 0)\n          goto Fail;\n      }\n\n    if (cdb_fchdir (&cdb) != 0)\n      goto Fail;\n\n    cdb_free (&cdb);\n    return 0;\n\n   Fail:\n    {\n      int saved_errno = errno;\n      cdb_free (&cdb);\n      errno = saved_errno;\n      return -1;\n    }\n  }\n}",
      "lines": 100,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *line = NULL;\n  size_t n = 0;\n  int len;\n\n  atexit (close_stdout);\n\n  len = getline (&line, &n, stdin);\n  if (len < 0)\n    {\n      int saved_errno = errno;\n      if (feof (stdin))\n        exit (0);\n\n      error (EXIT_FAILURE, saved_errno,\n             \"reading standard input\");\n    }\n  else if (len == 0)\n    exit (0);\n\n  if (line[len-1] == '\\n')\n    line[len-1] = '\\0';\n\n  if (chdir_long (line) != 0)\n    error (EXIT_FAILURE, errno,\n           \"chdir_long failed: %s\", line);\n\n  if (argc <= 1)\n    {\n      /* Using 'pwd' here makes sense only if it is a robust implementation,\n         like the one in coreutils after the 2004-04-19 changes.  */\n      char const *cmd = \"pwd\";\n      execlp (cmd, (char *) NULL);\n      error (EXIT_FAILURE, errno, \"%s\", cmd);\n    }\n\n  fclose (stdin);\n  fclose (stderr);\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/chdir-long.h": {},
  "patch/patch-2.7.6/lib/chmodat.c": {},
  "patch/patch-2.7.6/lib/chown.c": {
    "chown": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nchown (const char *file _GL_UNUSED, uid_t uid _GL_UNUSED,\n       gid_t gid _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_chown": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\nrpl_chown (const char *file, uid_t uid, gid_t gid)\n{\n  struct stat st;\n  bool stat_valid = false;\n  int result;\n\n# if CHOWN_CHANGE_TIME_BUG\n  if (gid != (gid_t) -1 || uid != (uid_t) -1)\n    {\n      if (stat (file, &st))\n        return -1;\n      stat_valid = true;\n    }\n# endif\n\n# if CHOWN_FAILS_TO_HONOR_ID_OF_NEGATIVE_ONE\n  if (gid == (gid_t) -1 || uid == (uid_t) -1)\n    {\n      /* Stat file to get id(s) that should remain unchanged.  */\n      if (!stat_valid && stat (file, &st))\n        return -1;\n      if (gid == (gid_t) -1)\n        gid = st.st_gid;\n      if (uid == (uid_t) -1)\n        uid = st.st_uid;\n    }\n# endif\n\n# if CHOWN_MODIFIES_SYMLINK\n  {\n    /* Handle the case in which the system-supplied chown function\n       does *not* follow symlinks.  Instead, it changes permissions\n       on the symlink itself.  To work around that, we open the\n       file (but this can fail due to lack of read or write permission) and\n       use fchown on the resulting descriptor.  */\n    int open_flags = O_NONBLOCK | O_NOCTTY;\n    int fd = open (file, O_RDONLY | open_flags);\n    if (0 <= fd\n        || (errno == EACCES\n            && 0 <= (fd = open (file, O_WRONLY | open_flags))))\n      {\n        int saved_errno;\n        bool fchown_socket_failure;\n\n        result = fchown (fd, uid, gid);\n        saved_errno = errno;\n\n        /* POSIX says fchown can fail with errno == EINVAL on sockets\n           and pipes, so fall back on chown in that case.  */\n        fchown_socket_failure =\n          (result != 0 && saved_errno == EINVAL\n           && fstat (fd, &st) == 0\n           && (S_ISFIFO (st.st_mode) || S_ISSOCK (st.st_mode)));\n\n        close (fd);\n\n        if (! fchown_socket_failure)\n          {\n            errno = saved_errno;\n            return result;\n          }\n      }\n    else if (errno != EACCES)\n      return -1;\n  }\n# endif\n\n# if CHOWN_TRAILING_SLASH_BUG\n  if (!stat_valid)\n    {\n      size_t len = strlen (file);\n      if (len && file[len - 1] == '/' && stat (file, &st))\n        return -1;\n    }\n# endif\n\n  result = chown (file, uid, gid);\n\n# if CHOWN_CHANGE_TIME_BUG\n  if (result == 0 && stat_valid\n      && (uid == st.st_uid || uid == (uid_t) -1)\n      && (gid == st.st_gid || gid == (gid_t) -1))\n    {\n      /* No change in ownership, but at least one argument was not -1,\n         so we are required to update ctime.  Since chown succeeded,\n         we assume that chmod will do likewise.  Fortunately, on all\n         known systems where a 'no-op' chown skips the ctime update, a\n         'no-op' chmod still does the trick.  */\n      result = chmod (file, st.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO\n                                          | S_ISUID | S_ISGID | S_ISVTX));\n    }\n# endif\n\n  return result;\n}",
      "lines": 96,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/chownat.c": {},
  "patch/patch-2.7.6/lib/cloexec.c": {
    "set_cloexec_flag": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nset_cloexec_flag (int desc, bool value)\n{\n#ifdef F_SETFD\n\n  int flags = fcntl (desc, F_GETFD, 0);\n\n  if (0 <= flags)\n    {\n      int newflags = (value ? flags | FD_CLOEXEC : flags & ~FD_CLOEXEC);\n\n      if (flags == newflags\n          || fcntl (desc, F_SETFD, newflags) != -1)\n        return 0;\n    }\n\n  return -1;\n\n#else /* !F_SETFD */\n\n  /* Use dup2 to reject invalid file descriptors; the cloexec flag\n     will be unaffected.  */\n  if (desc < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (dup2 (desc, desc) < 0)\n    /* errno is EBADF here.  */\n    return -1;\n\n  /* There is nothing we can do on this kind of platform.  Punt.  */\n  return 0;\n#endif /* !F_SETFD */\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "dup_cloexec": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\ndup_cloexec (int fd)\n{\n  return fcntl (fd, F_DUPFD_CLOEXEC, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/cloexec.h": {},
  "patch/patch-2.7.6/lib/close.c": {
    "close_nothrow": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "static int\nclose_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = close (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_close": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nrpl_close (int fd)\n{\n#if WINDOWS_SOCKETS\n  int retval = execute_all_close_hooks (close_nothrow, fd);\n#else\n  int retval = close_nothrow (fd);\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n\n  return retval;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/closedir.c": {
    "closedir": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nclosedir (DIR *dirp)\n{\n# if REPLACE_FCHDIR || REPLACE_DIRFD\n  int fd = dirfd (dirp);\n# endif\n  int retval;\n\n#if HAVE_CLOSEDIR\n# undef closedir\n\n  retval = closedir (dirp);\n\n# ifdef __KLIBC__\n  if (!retval)\n    _gl_unregister_dirp_fd (fd);\n# endif\n#else\n\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n  free (dirp);\n\n  retval = 0;\n\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n  return retval;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/diffseq.h": {
    "diag": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "static void\ndiag (OFFSET xoff, OFFSET xlim, OFFSET yoff, OFFSET ylim, bool find_minimal,\n      struct partition *part, struct context *ctxt)\n{\n  OFFSET *const fd = ctxt->fdiag;       /* Give the compiler a chance. */\n  OFFSET *const bd = ctxt->bdiag;       /* Additional help for the compiler. */\n#ifdef ELEMENT\n  ELEMENT const *const xv = ctxt->xvec; /* Still more help for the compiler. */\n  ELEMENT const *const yv = ctxt->yvec; /* And more and more . . . */\n  #define XREF_YREF_EQUAL(x,y)  EQUAL (xv[x], yv[y])\n#else\n  #define XREF_YREF_EQUAL(x,y)  XVECREF_YVECREF_EQUAL (ctxt, x, y)\n#endif\n  const OFFSET dmin = xoff - ylim;      /* Minimum valid diagonal. */\n  const OFFSET dmax = xlim - yoff;      /* Maximum valid diagonal. */\n  const OFFSET fmid = xoff - yoff;      /* Center diagonal of top-down search. */\n  const OFFSET bmid = xlim - ylim;      /* Center diagonal of bottom-up search. */\n  OFFSET fmin = fmid;\n  OFFSET fmax = fmid;           /* Limits of top-down search. */\n  OFFSET bmin = bmid;\n  OFFSET bmax = bmid;           /* Limits of bottom-up search. */\n  OFFSET c;                     /* Cost. */\n  bool odd = (fmid - bmid) & 1; /* True if southeast corner is on an odd\n                                   diagonal with respect to the northwest. */\n\n  fd[fmid] = xoff;\n  bd[bmid] = xlim;\n\n  for (c = 1;; ++c)\n    {\n      OFFSET d;                 /* Active diagonal. */\n      bool big_snake = false;\n\n      /* Extend the top-down search by an edit step in each diagonal. */\n      if (fmin > dmin)\n        fd[--fmin - 1] = -1;\n      else\n        ++fmin;\n      if (fmax < dmax)\n        fd[++fmax + 1] = -1;\n      else\n        --fmax;\n      for (d = fmax; d >= fmin; d -= 2)\n        {\n          OFFSET x;\n          OFFSET y;\n          OFFSET tlo = fd[d - 1];\n          OFFSET thi = fd[d + 1];\n          OFFSET x0 = tlo < thi ? thi : tlo + 1;\n\n          for (x = x0, y = x0 - d;\n               x < xlim && y < ylim && XREF_YREF_EQUAL (x, y);\n               x++, y++)\n            continue;\n          if (x - x0 > SNAKE_LIMIT)\n            big_snake = true;\n          fd[d] = x;\n          if (odd && bmin <= d && d <= bmax && bd[d] <= x)\n            {\n              part->xmid = x;\n              part->ymid = y;\n              part->lo_minimal = part->hi_minimal = true;\n              return;\n            }\n        }\n\n      /* Similarly extend the bottom-up search.  */\n      if (bmin > dmin)\n        bd[--bmin - 1] = OFFSET_MAX;\n      else\n        ++bmin;\n      if (bmax < dmax)\n        bd[++bmax + 1] = OFFSET_MAX;\n      else\n        --bmax;\n      for (d = bmax; d >= bmin; d -= 2)\n        {\n          OFFSET x;\n          OFFSET y;\n          OFFSET tlo = bd[d - 1];\n          OFFSET thi = bd[d + 1];\n          OFFSET x0 = tlo < thi ? tlo : thi - 1;\n\n          for (x = x0, y = x0 - d;\n               xoff < x && yoff < y && XREF_YREF_EQUAL (x - 1, y - 1);\n               x--, y--)\n            continue;\n          if (x0 - x > SNAKE_LIMIT)\n            big_snake = true;\n          bd[d] = x;\n          if (!odd && fmin <= d && d <= fmax && x <= fd[d])\n            {\n              part->xmid = x;\n              part->ymid = y;\n              part->lo_minimal = part->hi_minimal = true;\n              return;\n            }\n        }\n\n      if (find_minimal)\n        continue;\n\n#ifdef USE_HEURISTIC\n      bool heuristic = ctxt->heuristic;\n#else\n      bool heuristic = false;\n#endif\n\n      /* Heuristic: check occasionally for a diagonal that has made lots\n         of progress compared with the edit distance.  If we have any\n         such, find the one that has made the most progress and return it\n         as if it had succeeded.\n\n         With this heuristic, for vectors with a constant small density\n         of changes, the algorithm is linear in the vector size.  */\n\n      if (200 < c && big_snake && heuristic)\n        {\n          {\n            OFFSET best = 0;\n\n            for (d = fmax; d >= fmin; d -= 2)\n              {\n                OFFSET dd = d - fmid;\n                OFFSET x = fd[d];\n                OFFSET y = x - d;\n                OFFSET v = (x - xoff) * 2 - dd;\n\n                if (v > 12 * (c + (dd < 0 ? -dd : dd)))\n                  {\n                    if (v > best\n                        && xoff + SNAKE_LIMIT <= x && x < xlim\n                        && yoff + SNAKE_LIMIT <= y && y < ylim)\n                      {\n                        /* We have a good enough best diagonal; now insist\n                           that it end with a significant snake.  */\n                        int k;\n\n                        for (k = 1; XREF_YREF_EQUAL (x - k, y - k); k++)\n                          if (k == SNAKE_LIMIT)\n                            {\n                              best = v;\n                              part->xmid = x;\n                              part->ymid = y;\n                              break;\n                            }\n                      }\n                  }\n              }\n            if (best > 0)\n              {\n                part->lo_minimal = true;\n                part->hi_minimal = false;\n                return;\n              }\n          }\n\n          {\n            OFFSET best = 0;\n\n            for (d = bmax; d >= bmin; d -= 2)\n              {\n                OFFSET dd = d - bmid;\n                OFFSET x = bd[d];\n                OFFSET y = x - d;\n                OFFSET v = (xlim - x) * 2 + dd;\n\n                if (v > 12 * (c + (dd < 0 ? -dd : dd)))\n                  {\n                    if (v > best\n                        && xoff < x && x <= xlim - SNAKE_LIMIT\n                        && yoff < y && y <= ylim - SNAKE_LIMIT)\n                      {\n                        /* We have a good enough best diagonal; now insist\n                           that it end with a significant snake.  */\n                        int k;\n\n                        for (k = 0; XREF_YREF_EQUAL (x + k, y + k); k++)\n                          if (k == SNAKE_LIMIT - 1)\n                            {\n                              best = v;\n                              part->xmid = x;\n                              part->ymid = y;\n                              break;\n                            }\n                      }\n                  }\n              }\n            if (best > 0)\n              {\n                part->lo_minimal = false;\n                part->hi_minimal = true;\n                return;\n              }\n          }\n        }\n\n      /* Heuristic: if we've gone well beyond the call of duty, give up\n         and report halfway between our best results so far.  */\n      if (c >= ctxt->too_expensive)\n        {\n          OFFSET fxybest;\n          OFFSET fxbest IF_LINT (= 0);\n          OFFSET bxybest;\n          OFFSET bxbest IF_LINT (= 0);\n\n          /* Find forward diagonal that maximizes X + Y.  */\n          fxybest = -1;\n          for (d = fmax; d >= fmin; d -= 2)\n            {\n              OFFSET x = MIN (fd[d], xlim);\n              OFFSET y = x - d;\n              if (ylim < y)\n                {\n                  x = ylim + d;\n                  y = ylim;\n                }\n              if (fxybest < x + y)\n                {\n                  fxybest = x + y;\n                  fxbest = x;\n                }\n            }\n\n          /* Find backward diagonal that minimizes X + Y.  */\n          bxybest = OFFSET_MAX;\n          for (d = bmax; d >= bmin; d -= 2)\n            {\n              OFFSET x = MAX (xoff, bd[d]);\n              OFFSET y = x - d;\n              if (y < yoff)\n                {\n                  x = yoff + d;\n                  y = yoff;\n                }\n              if (x + y < bxybest)\n                {\n                  bxybest = x + y;\n                  bxbest = x;\n                }\n            }\n\n          /* Use the better of the two diagonals.  */\n          if ((xlim + ylim) - bxybest < fxybest - (xoff + yoff))\n            {\n              part->xmid = fxbest;\n              part->ymid = fxybest - fxbest;\n              part->lo_minimal = true;\n              part->hi_minimal = false;\n            }\n          else\n            {\n              part->xmid = bxbest;\n              part->ymid = bxybest - bxbest;\n              part->lo_minimal = false;\n              part->hi_minimal = true;\n            }\n          return;\n        }\n    }\n  #undef XREF_YREF_EQUAL\n}",
      "lines": 262,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compareseq": {
      "start_point": [
        458,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "static bool\ncompareseq (OFFSET xoff, OFFSET xlim, OFFSET yoff, OFFSET ylim,\n            bool find_minimal, struct context *ctxt)\n{\n#ifdef ELEMENT\n  ELEMENT const *xv = ctxt->xvec; /* Help the compiler.  */\n  ELEMENT const *yv = ctxt->yvec;\n  #define XREF_YREF_EQUAL(x,y)  EQUAL (xv[x], yv[y])\n#else\n  #define XREF_YREF_EQUAL(x,y)  XVECREF_YVECREF_EQUAL (ctxt, x, y)\n#endif\n\n  /* Slide down the bottom initial diagonal.  */\n  while (xoff < xlim && yoff < ylim && XREF_YREF_EQUAL (xoff, yoff))\n    {\n      xoff++;\n      yoff++;\n    }\n\n  /* Slide up the top initial diagonal. */\n  while (xoff < xlim && yoff < ylim && XREF_YREF_EQUAL (xlim - 1, ylim - 1))\n    {\n      xlim--;\n      ylim--;\n    }\n\n  /* Handle simple cases. */\n  if (xoff == xlim)\n    while (yoff < ylim)\n      {\n        NOTE_INSERT (ctxt, yoff);\n        if (EARLY_ABORT (ctxt))\n          return true;\n        yoff++;\n      }\n  else if (yoff == ylim)\n    while (xoff < xlim)\n      {\n        NOTE_DELETE (ctxt, xoff);\n        if (EARLY_ABORT (ctxt))\n          return true;\n        xoff++;\n      }\n  else\n    {\n      struct partition part IF_LINT2 (= { .xmid = 0, .ymid = 0 });\n\n      /* Find a point of correspondence in the middle of the vectors.  */\n      diag (xoff, xlim, yoff, ylim, find_minimal, &part, ctxt);\n\n      /* Use the partitions to split this problem into subproblems.  */\n      if (compareseq (xoff, part.xmid, yoff, part.ymid, part.lo_minimal, ctxt))\n        return true;\n      if (compareseq (part.xmid, xlim, part.ymid, ylim, part.hi_minimal, ctxt))\n        return true;\n    }\n\n  return false;\n  #undef XREF_YREF_EQUAL\n}",
      "lines": 60,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "patch/patch-2.7.6/lib/dirent--.h": {},
  "patch/patch-2.7.6/lib/dirent-private.h": {},
  "patch/patch-2.7.6/lib/dirent-safer.h": {},
  "patch/patch-2.7.6/lib/dirent.in.h": {
    "dirfd": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        171,
        58
      ],
      "content": "static inline int (dirfd) (DIR *dp) { return dirfd (dp); }",
      "lines": 1,
      "depth": 6,
      "decorators": null
    }
  },
  "patch/patch-2.7.6/lib/dirfd.c": {
    "_gl_register_dirp_fd": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\n_gl_register_dirp_fd (int fd, DIR *dirp)\n{\n  struct dirp_fd_list *new_dirp_fd = malloc (sizeof *new_dirp_fd);\n  if (!new_dirp_fd)\n    return -1;\n\n  new_dirp_fd->dirp = dirp;\n  new_dirp_fd->fd = fd;\n  new_dirp_fd->next = dirp_fd_start;\n\n  dirp_fd_start = new_dirp_fd;\n\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_gl_unregister_dirp_fd": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\n_gl_unregister_dirp_fd (int fd)\n{\n  struct dirp_fd_list *dirp_fd;\n  struct dirp_fd_list *dirp_fd_prev;\n\n  for (dirp_fd_prev = NULL, dirp_fd = dirp_fd_start; dirp_fd;\n       dirp_fd_prev = dirp_fd, dirp_fd = dirp_fd->next)\n    {\n      if (dirp_fd->fd == fd)\n        {\n          if (dirp_fd_prev)\n            dirp_fd_prev->next = dirp_fd->next;\n          else  /* dirp_fd == dirp_fd_start */\n            dirp_fd_start = dirp_fd_start->next;\n\n          close (fd);\n          free (dirp_fd);\n          break;\n        }\n    }\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "dirfd": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\ndirfd (DIR *dir_p)\n{\n  int fd = DIR_TO_FD (dir_p);\n  if (fd == -1)\n#ifndef __KLIBC__\n    errno = ENOTSUP;\n#else\n    {\n      struct dirp_fd_list *dirp_fd;\n\n      for (dirp_fd = dirp_fd_start; dirp_fd; dirp_fd = dirp_fd->next)\n        if (dirp_fd->dirp == dir_p)\n          return dirp_fd->fd;\n\n      errno = EINVAL;\n    }\n#endif\n\n  return fd;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/dirname.c": {
    "dir_name": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\ndir_name (char const *file)\n{\n  char *result = mdir_name (file);\n  if (!result)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\ndir_name (char const *file)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/dirname.h": {},
  "patch/patch-2.7.6/lib/dosname.h": {},
  "patch/patch-2.7.6/lib/dup-safer-flag.c": {
    "dup_safer_flag": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\ndup_safer_flag (int fd, int flag)\n{\n  return fcntl (fd, (flag & O_CLOEXEC) ? F_DUPFD_CLOEXEC : F_DUPFD,\n                STDERR_FILENO + 1);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/dup-safer.c": {
    "dup_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\ndup_safer (int fd)\n{\n  return fcntl (fd, F_DUPFD, STDERR_FILENO + 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/dup2.c": {
    "dup2_nothrow": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        57,
        5
      ],
      "content": "static int\ndup2_nothrow (int fd, int desired_fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = dup2 (fd, desired_fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ms_windows_dup2": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nms_windows_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n  /* If fd is closed, mingw hangs on dup2 (fd, fd).  If fd is open,\n     dup2 (fd, fd) returns 0, but all further attempts to use fd in\n     future dup2 calls will hang.  */\n  if (fd == desired_fd)\n    {\n      if ((HANDLE) _get_osfhandle (fd) == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n      return fd;\n    }\n\n  /* Wine 1.0.1 return 0 when desired_fd is negative but not -1:\n     https://bugs.winehq.org/show_bug.cgi?id=21289 */\n  if (desired_fd < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  result = dup2_nothrow (fd, desired_fd);\n\n  if (result == 0)\n    result = desired_fd;\n\n  return result;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_dup2dirfd": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static int\nklibc_dup2dirfd (int fd, int desired_fd)\n{\n  int tempfd;\n  int dupfd;\n\n  tempfd = open (\"NUL\", O_RDONLY);\n  if (tempfd == -1)\n    return -1;\n\n  if (tempfd == desired_fd)\n    {\n      close (tempfd);\n\n      char path[_MAX_PATH];\n      if (__libc_Back_ioFHToPath (fd, path, sizeof (path)))\n        return -1;\n\n      return open(path, O_RDONLY);\n    }\n\n  dupfd = klibc_dup2dirfd (fd, desired_fd);\n\n  close (tempfd);\n\n  return dupfd;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_dup2": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static int\nklibc_dup2 (int fd, int desired_fd)\n{\n  int dupfd;\n  struct stat sbuf;\n\n  dupfd = dup2 (fd, desired_fd);\n  if (dupfd == -1 && errno == ENOTSUP \\\n      && !fstat (fd, &sbuf) && S_ISDIR (sbuf.st_mode))\n    {\n      close (desired_fd);\n\n      return klibc_dup2dirfd (fd, desired_fd);\n    }\n\n  return dupfd;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup2": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nrpl_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n# ifdef F_GETFL\n  /* On Linux kernels 2.6.26-2.6.29, dup2 (fd, fd) returns -EBADF.\n     On Cygwin 1.5.x, dup2 (1, 1) returns 0.\n     On Cygwin 1.7.17, dup2 (1, -1) dumps core.\n     On Cygwin 1.7.25, dup2 (1, 256) can dump core.\n     On Haiku, dup2 (fd, fd) mistakenly clears FD_CLOEXEC.  */\n#  if HAVE_SETDTABLESIZE\n  setdtablesize (desired_fd + 1);\n#  endif\n  if (desired_fd < 0)\n    fd = desired_fd;\n  if (fd == desired_fd)\n    return fcntl (fd, F_GETFL) == -1 ? -1 : fd;\n# endif\n\n  result = dup2 (fd, desired_fd);\n\n  /* Correct an errno value on FreeBSD 6.1 and Cygwin 1.5.x.  */\n  if (result == -1 && errno == EMFILE)\n    errno = EBADF;\n# if REPLACE_FCHDIR\n  if (fd != desired_fd && result != -1)\n    result = _gl_register_dup (fd, result);\n# endif\n  return result;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dupfd": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static int\ndupfd (int fd, int desired_fd)\n{\n  int duplicated_fd = dup (fd);\n  if (duplicated_fd < 0 || duplicated_fd == desired_fd)\n    return duplicated_fd;\n  else\n    {\n      int r = dupfd (fd, desired_fd);\n      int e = errno;\n      close (duplicated_fd);\n      errno = e;\n      return r;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup2": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "int\ndup2 (int fd, int desired_fd)\n{\n  int result = fcntl (fd, F_GETFL) < 0 ? -1 : fd;\n  if (result == -1 || fd == desired_fd)\n    return result;\n  close (desired_fd);\n# ifdef F_DUPFD\n  result = fcntl (fd, F_DUPFD, desired_fd);\n#  if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (fd, result);\n#  endif\n# else\n  result = dupfd (fd, desired_fd);\n# endif\n  if (result == -1 && (errno == EMFILE || errno == EINVAL))\n    errno = EBADF;\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/errno.in.h": {},
  "patch/patch-2.7.6/lib/error.c": {
    "is_open": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if _LIBC || GNULIB_STRERROR_R_POSIX || defined HAVE_STRERROR_R\n  char errbuf[1024];\n# if _LIBC || (!GNULIB_STRERROR_R_POSIX && STRERROR_R_CHAR_P)\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        205,
        42
      ],
      "end_point": [
        286,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 82,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/error.h": {},
  "patch/patch-2.7.6/lib/euidaccess.c": {
    "euidaccess": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int\neuidaccess (const char *file, int mode)\n{\n#if HAVE_FACCESSAT                   /* glibc, AIX 7, Solaris 11, Cygwin 1.7 */\n  return faccessat (AT_FDCWD, file, mode, AT_EACCESS);\n#elif defined EFF_ONLY_OK               /* IRIX, OSF/1, Interix */\n  return access (file, mode | EFF_ONLY_OK);\n#elif defined ACC_SELF                  /* AIX */\n  return accessx (file, mode, ACC_SELF);\n#elif HAVE_EACCESS                      /* FreeBSD */\n  return eaccess (file, mode);\n#else       /* Mac OS X, NetBSD, OpenBSD, HP-UX, Solaris, Cygwin, mingw, BeOS */\n\n  uid_t uid = getuid ();\n  gid_t gid = getgid ();\n  uid_t euid = geteuid ();\n  gid_t egid = getegid ();\n  struct stat stats;\n\n# if HAVE_DECL_SETREGID && PREFER_NONREENTRANT_EUIDACCESS\n\n  /* Define PREFER_NONREENTRANT_EUIDACCESS if you prefer euidaccess to\n     return the correct result even if this would make it\n     nonreentrant.  Define this only if your entire application is\n     safe even if the uid or gid might temporarily change.  If your\n     application uses signal handlers or threads it is probably not\n     safe.  */\n\n  if (mode == F_OK)\n    return stat (file, &stats);\n  else\n    {\n      int result;\n      int saved_errno;\n\n      if (uid != euid)\n        setreuid (euid, uid);\n      if (gid != egid)\n        setregid (egid, gid);\n\n      result = access (file, mode);\n      saved_errno = errno;\n\n      /* Restore them.  */\n      if (uid != euid)\n        setreuid (uid, euid);\n      if (gid != egid)\n        setregid (gid, egid);\n\n      errno = saved_errno;\n      return result;\n    }\n\n# else\n\n  /* The following code assumes the traditional Unix model, and is not\n     correct on systems that have ACLs or the like.  However, it's\n     better than nothing, and it is reentrant.  */\n\n  unsigned int granted;\n  if (uid == euid && gid == egid)\n    /* If we are not set-uid or set-gid, access does the same.  */\n    return access (file, mode);\n\n  if (stat (file, &stats) != 0)\n    return -1;\n\n  /* The super-user can read and write any file, and execute any file\n     that anyone can execute.  */\n  if (euid == ROOT_UID\n      && ((mode & X_OK) == 0\n          || (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))\n    return 0;\n\n  /* Convert the mode to traditional form, clearing any bogus bits.  */\n  if (R_OK == 4 && W_OK == 2 && X_OK == 1 && F_OK == 0)\n    mode &= 7;\n  else\n    mode = ((mode & R_OK ? 4 : 0)\n            + (mode & W_OK ? 2 : 0)\n            + (mode & X_OK ? 1 : 0));\n\n  if (mode == 0)\n    return 0;                   /* The file exists.  */\n\n  /* Convert the file's permission bits to traditional form.  */\n  if (S_IRUSR == (4 << 6) && S_IWUSR == (2 << 6) && S_IXUSR == (1 << 6)\n      && S_IRGRP == (4 << 3) && S_IWGRP == (2 << 3) && S_IXGRP == (1 << 3)\n      && S_IROTH == (4 << 0) && S_IWOTH == (2 << 0) && S_IXOTH == (1 << 0))\n    granted = stats.st_mode;\n  else\n    granted = ((stats.st_mode & S_IRUSR ? 4 << 6 : 0)\n               + (stats.st_mode & S_IWUSR ? 2 << 6 : 0)\n               + (stats.st_mode & S_IXUSR ? 1 << 6 : 0)\n               + (stats.st_mode & S_IRGRP ? 4 << 3 : 0)\n               + (stats.st_mode & S_IWGRP ? 2 << 3 : 0)\n               + (stats.st_mode & S_IXGRP ? 1 << 3 : 0)\n               + (stats.st_mode & S_IROTH ? 4 << 0 : 0)\n               + (stats.st_mode & S_IWOTH ? 2 << 0 : 0)\n               + (stats.st_mode & S_IXOTH ? 1 << 0 : 0));\n\n  if (euid == stats.st_uid)\n    granted >>= 6;\n  else if (egid == stats.st_gid || group_member (stats.st_gid))\n    granted >>= 3;\n\n  if ((mode & ~granted) == 0)\n    return 0;\n  __set_errno (EACCESS);\n  return -1;\n\n# endif\n#endif\n}",
      "lines": 114,
      "depth": 26,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *file;\n  int mode;\n  int err;\n\n  if (argc < 3)\n    abort ();\n  file = argv[1];\n  mode = atoi (argv[2]);\n\n  err = euidaccess (file, mode);\n  printf (\"%d\\n\", err);\n  if (err != 0)\n    error (0, errno, \"%s\", file);\n  exit (0);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/exitfail.c": {},
  "patch/patch-2.7.6/lib/exitfail.h": {},
  "patch/patch-2.7.6/lib/faccessat.c": {
    "orig_faccessat": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\norig_faccessat (int fd, char const *name, int mode, int flag)\n{\n  return faccessat (fd, name, mode, flag);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_faccessat": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nrpl_faccessat (int fd, char const *file, int mode, int flag)\n{\n  int result = orig_faccessat (fd, file, mode, flag);\n\n  if (result == 0 && file[strlen (file) - 1] == '/')\n    {\n      struct stat st;\n      result = fstatat (fd, file, &st, 0);\n      if (result == 0 && !S_ISDIR (st.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n\n  return result;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/fchdir.c": {
    "ensure_dirs_slot": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static bool\nensure_dirs_slot (size_t fd)\n{\n  if (fd < dirs_allocated)\n    free (dirs[fd].name);\n  else\n    {\n      size_t new_allocated;\n      dir_info_t *new_dirs;\n\n      new_allocated = 2 * dirs_allocated + 1;\n      if (new_allocated <= fd)\n        new_allocated = fd + 1;\n      new_dirs =\n        (dirs != NULL\n         ? (dir_info_t *) realloc (dirs, new_allocated * sizeof *dirs)\n         : (dir_info_t *) malloc (new_allocated * sizeof *dirs));\n      if (new_dirs == NULL)\n        return false;\n      memset (new_dirs + dirs_allocated, 0,\n              (new_allocated - dirs_allocated) * sizeof *dirs);\n      dirs = new_dirs;\n      dirs_allocated = new_allocated;\n    }\n  return true;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_name": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static char *\nget_name (char const *dir)\n{\n  char *cwd;\n  char *result;\n  int saved_errno;\n\n  if (IS_ABSOLUTE_FILE_NAME (dir))\n    return strdup (dir);\n\n  /* We often encounter \".\"; treat it as a special case.  */\n  cwd = getcwd (NULL, 0);\n  if (!cwd || (dir[0] == '.' && dir[1] == '\\0'))\n    return cwd;\n\n  result = mfile_name_concat (cwd, dir, NULL);\n  saved_errno = errno;\n  free (cwd);\n  errno = saved_errno;\n  return result;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_name (char const *dir)",
        "*"
      ]
    },
    "_gl_unregister_fd": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\n_gl_unregister_fd (int fd)\n{\n  if (fd >= 0 && fd < dirs_allocated)\n    {\n      free (dirs[fd].name);\n      dirs[fd].name = NULL;\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_gl_register_fd": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\n_gl_register_fd (int fd, const char *filename)\n{\n  struct stat statbuf;\n\n  assure (0 <= fd);\n  if (REPLACE_OPEN_DIRECTORY\n      || (fstat (fd, &statbuf) == 0 && S_ISDIR (statbuf.st_mode)))\n    {\n      if (!ensure_dirs_slot (fd)\n          || (dirs[fd].name = get_name (filename)) == NULL)\n        {\n          int saved_errno = errno;\n          close (fd);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n  return fd;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gl_register_dup": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "int\n_gl_register_dup (int oldfd, int newfd)\n{\n  assure (0 <= oldfd && 0 <= newfd && oldfd != newfd);\n  if (oldfd < dirs_allocated && dirs[oldfd].name)\n    {\n      /* Duplicated a directory; must ensure newfd is allocated.  */\n      if (!ensure_dirs_slot (newfd)\n          || (dirs[newfd].name = strdup (dirs[oldfd].name)) == NULL)\n        {\n          int saved_errno = errno;\n          close (newfd);\n          errno = saved_errno;\n          newfd = -1;\n        }\n    }\n  else if (newfd < dirs_allocated)\n    {\n      /* Duplicated a non-directory; ensure newfd is cleared.  */\n      free (dirs[newfd].name);\n      dirs[newfd].name = NULL;\n    }\n  return newfd;\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_gl_directory_name": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "const char *\n_gl_directory_name (int fd)\n{\n  if (0 <= fd && fd < dirs_allocated && dirs[fd].name != NULL)\n    return dirs[fd].name;\n  /* At this point, fd is either invalid, or open but not a directory.\n     If dup2 fails, errno is correctly EBADF.  */\n  if (0 <= fd)\n    {\n      if (dup2 (fd, fd) == fd)\n        errno = ENOTDIR;\n    }\n  else\n    errno = EBADF;\n  return NULL;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_gl_directory_name (int fd)",
        "*"
      ]
    },
    "fchdir": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nfchdir (int fd)\n{\n  const char *name = _gl_directory_name (fd);\n  return name ? chdir (name) : -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/fchmodat.c": {
    "lchmod": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static int\nlchmod (char const *f _GL_UNUSED, mode_t m _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/fchown-stub.c": {
    "fchown": {
      "start_point": [
        10,
        0
      ],
      "end_point": [
        15,
        1
      ],
      "content": "int\nfchown (int fd, uid_t uid, gid_t gid)\n{\n  errno = EPERM;\n  return -1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/fchownat.c": {
    "rpl_fchownat": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "int\nrpl_fchownat (int fd, char const *file, uid_t owner, gid_t group, int flag)\n{\n# if FCHOWNAT_NOFOLLOW_BUG\n  if (flag == AT_SYMLINK_NOFOLLOW)\n    return local_lchownat (fd, file, owner, group);\n# endif\n# if FCHOWNAT_EMPTY_FILENAME_BUG\n  if (file[0] == '\\0')\n    {\n      errno = ENOENT;\n      return -1;\n    }\n# endif\n# if CHOWN_TRAILING_SLASH_BUG\n  {\n    size_t len = strlen (file);\n    struct stat st;\n    if (len && file[len - 1] == '/')\n      {\n        if (statat (fd, file, &st))\n          return -1;\n        if (flag == AT_SYMLINK_NOFOLLOW)\n          return fchownat (fd, file, owner, group, 0);\n      }\n  }\n# endif\n  return fchownat (fd, file, owner, group, flag);\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/fcntl.c": {
    "dupfd": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static int\ndupfd (int oldfd, int newfd, int flags)\n{\n  /* Mingw has no way to create an arbitrary fd.  Iterate until all\n     file descriptors less than newfd are filled up.  */\n  HANDLE curr_process = GetCurrentProcess ();\n  HANDLE old_handle = (HANDLE) _get_osfhandle (oldfd);\n  unsigned char fds_to_close[OPEN_MAX_MAX / CHAR_BIT];\n  unsigned int fds_to_close_bound = 0;\n  int result;\n  BOOL inherit = flags & O_CLOEXEC ? FALSE : TRUE;\n  int mode;\n\n  if (newfd < 0 || getdtablesize () <= newfd)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (old_handle == INVALID_HANDLE_VALUE\n      || (mode = setmode (oldfd, O_BINARY)) == -1)\n    {\n      /* oldfd is not open, or is an unassigned standard file\n         descriptor.  */\n      errno = EBADF;\n      return -1;\n    }\n  setmode (oldfd, mode);\n  flags |= mode;\n\n  for (;;)\n    {\n      HANDLE new_handle;\n      int duplicated_fd;\n      unsigned int index;\n\n      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */\n                            old_handle,             /* SourceHandle */\n                            curr_process,           /* TargetProcessHandle */\n                            (PHANDLE) &new_handle,  /* TargetHandle */\n                            (DWORD) 0,              /* DesiredAccess */\n                            inherit,                /* InheritHandle */\n                            DUPLICATE_SAME_ACCESS)) /* Options */\n        {\n          switch (GetLastError ())\n            {\n              case ERROR_TOO_MANY_OPEN_FILES:\n                errno = EMFILE;\n                break;\n              case ERROR_INVALID_HANDLE:\n              case ERROR_INVALID_TARGET_HANDLE:\n              case ERROR_DIRECT_ACCESS_HANDLE:\n                errno = EBADF;\n                break;\n              case ERROR_INVALID_PARAMETER:\n              case ERROR_INVALID_FUNCTION:\n              case ERROR_INVALID_ACCESS:\n                errno = EINVAL;\n                break;\n              default:\n                errno = EACCES;\n                break;\n            }\n          result = -1;\n          break;\n        }\n      duplicated_fd = _open_osfhandle ((intptr_t) new_handle, flags);\n      if (duplicated_fd < 0)\n        {\n          CloseHandle (new_handle);\n          result = -1;\n          break;\n        }\n      if (newfd <= duplicated_fd)\n        {\n          result = duplicated_fd;\n          break;\n        }\n\n      /* Set the bit duplicated_fd in fds_to_close[].  */\n      index = (unsigned int) duplicated_fd / CHAR_BIT;\n      if (fds_to_close_bound <= index)\n        {\n          if (sizeof fds_to_close <= index)\n            /* Need to increase OPEN_MAX_MAX.  */\n            abort ();\n          memset (fds_to_close + fds_to_close_bound, '\\0',\n                  index + 1 - fds_to_close_bound);\n          fds_to_close_bound = index + 1;\n        }\n      fds_to_close[index] |= 1 << ((unsigned int) duplicated_fd % CHAR_BIT);\n    }\n\n  /* Close the previous fds that turned out to be too small.  */\n  {\n    int saved_errno = errno;\n    unsigned int duplicated_fd;\n\n    for (duplicated_fd = 0;\n         duplicated_fd < fds_to_close_bound * CHAR_BIT;\n         duplicated_fd++)\n      if ((fds_to_close[duplicated_fd / CHAR_BIT]\n           >> (duplicated_fd % CHAR_BIT))\n          & 1)\n        close (duplicated_fd);\n\n    errno = saved_errno;\n  }\n\n# if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (oldfd, result);\n# endif\n  return result;\n}",
      "lines": 114,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_fcntl": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "static int\nklibc_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg_ptr;\n  int arg;\n  struct stat sbuf;\n  int result = -1;\n\n  va_start (arg_ptr, action);\n  arg = va_arg (arg_ptr, int);\n  result = fcntl (fd, action, arg);\n  /* EPERM for F_DUPFD, ENOTSUP for others */\n  if (result == -1 && (errno == EPERM || errno == ENOTSUP)\n      && !fstat (fd, &sbuf) && S_ISDIR (sbuf.st_mode))\n  {\n    ULONG ulMode;\n\n    switch (action)\n      {\n      case F_DUPFD:\n        /* Find available fd */\n        while (fcntl (arg, F_GETFL) != -1 || errno != EBADF)\n          arg++;\n\n        result = dup2 (fd, arg);\n        break;\n\n      /* Using underlying APIs is right ? */\n      case F_GETFD:\n        if (DosQueryFHState (fd, &ulMode))\n          break;\n\n        result = (ulMode & OPEN_FLAGS_NOINHERIT) ? FD_CLOEXEC : 0;\n        break;\n\n      case F_SETFD:\n        if (arg & ~FD_CLOEXEC)\n          break;\n\n        if (DosQueryFHState (fd, &ulMode))\n          break;\n\n        if (arg & FD_CLOEXEC)\n          ulMode |= OPEN_FLAGS_NOINHERIT;\n        else\n          ulMode &= ~OPEN_FLAGS_NOINHERIT;\n\n        /* Filter supported flags.  */\n        ulMode &= (OPEN_FLAGS_WRITE_THROUGH | OPEN_FLAGS_FAIL_ON_ERROR\n                   | OPEN_FLAGS_NO_CACHE | OPEN_FLAGS_NOINHERIT);\n\n        if (DosSetFHState (fd, ulMode))\n          break;\n\n        result = 0;\n        break;\n\n      case F_GETFL:\n        result = 0;\n        break;\n\n      case F_SETFL:\n        if (arg != 0)\n          break;\n\n        result = 0;\n        break;\n\n      default :\n        errno = EINVAL;\n        break;\n      }\n  }\n\n  va_end (arg_ptr);\n\n  return result;\n}",
      "lines": 78,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fcntl": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "int\nrpl_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg;\n  int result = -1;\n  va_start (arg, action);\n  switch (action)\n    {\n\n#if !HAVE_FCNTL\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        result = dupfd (fd, target, 0);\n        break;\n      }\n#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        /* Detect invalid target; needed for cygwin 1.5.x.  */\n        if (target < 0 || getdtablesize () <= target)\n          errno = EINVAL;\n        else\n          {\n            /* Haiku alpha 2 loses fd flags on original.  */\n            int flags = fcntl (fd, F_GETFD);\n            if (flags < 0)\n              {\n                result = -1;\n                break;\n              }\n            result = fcntl (fd, action, target);\n            if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                result = -1;\n                errno = saved_errno;\n              }\n# if REPLACE_FCHDIR\n            if (0 <= result)\n              result = _gl_register_dup (fd, result);\n# endif\n          }\n        break;\n      } /* F_DUPFD */\n#endif /* FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR */\n\n    case F_DUPFD_CLOEXEC:\n      {\n        int target = va_arg (arg, int);\n\n#if !HAVE_FCNTL\n        result = dupfd (fd, target, O_CLOEXEC);\n        break;\n#else /* HAVE_FCNTL */\n        /* Try the system call first, if the headers claim it exists\n           (that is, if GNULIB_defined_F_DUPFD_CLOEXEC is 0), since we\n           may be running with a glibc that has the macro but with an\n           older kernel that does not support it.  Cache the\n           information on whether the system call really works, but\n           avoid caching failure if the corresponding F_DUPFD fails\n           for any reason.  0 = unknown, 1 = yes, -1 = no.  */\n        static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;\n        if (0 <= have_dupfd_cloexec)\n          {\n            result = fcntl (fd, action, target);\n            if (0 <= result || errno != EINVAL)\n              {\n                have_dupfd_cloexec = 1;\n# if REPLACE_FCHDIR\n                if (0 <= result)\n                  result = _gl_register_dup (fd, result);\n# endif\n              }\n            else\n              {\n                result = rpl_fcntl (fd, F_DUPFD, target);\n                if (result < 0)\n                  break;\n                have_dupfd_cloexec = -1;\n              }\n          }\n        else\n          result = rpl_fcntl (fd, F_DUPFD, target);\n        if (0 <= result && have_dupfd_cloexec == -1)\n          {\n            int flags = fcntl (result, F_GETFD);\n            if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                errno = saved_errno;\n                result = -1;\n              }\n          }\n        break;\n#endif /* HAVE_FCNTL */\n      } /* F_DUPFD_CLOEXEC */\n\n#if !HAVE_FCNTL\n    case F_GETFD:\n      {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n        HANDLE handle = (HANDLE) _get_osfhandle (fd);\n        DWORD flags;\n        if (handle == INVALID_HANDLE_VALUE\n            || GetHandleInformation (handle, &flags) == 0)\n          errno = EBADF;\n        else\n          result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;\n# else /* !W32 */\n        /* Use dup2 to reject invalid file descriptors.  No way to\n           access this information, so punt.  */\n        if (0 <= dup2 (fd, fd))\n          result = 0;\n# endif /* !W32 */\n        break;\n      } /* F_GETFD */\n#endif /* !HAVE_FCNTL */\n\n      /* Implementing F_SETFD on mingw is not trivial - there is no\n         API for changing the O_NOINHERIT bit on an fd, and merely\n         changing the HANDLE_FLAG_INHERIT bit on the underlying handle\n         can lead to odd state.  It may be possible by duplicating the\n         handle, using _open_osfhandle with the right flags, then\n         using dup2 to move the duplicate onto the original, but that\n         is not supported for now.  */\n\n    default:\n      {\n#if HAVE_FCNTL\n        void *p = va_arg (arg, void *);\n        result = fcntl (fd, action, p);\n#else\n        errno = EINVAL;\n#endif\n        break;\n      }\n    }\n  va_end (arg);\n  return result;\n}",
      "lines": 144,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/fcntl.in.h": {},
  "patch/patch-2.7.6/lib/fd-hook.c": {
    "execute_close_hooks": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nexecute_close_hooks (const struct fd_hook *remaining_list, gl_close_fn primary,\n                     int fd)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd);\n  else\n    return remaining_list->private_close_fn (remaining_list->private_next,\n                                             primary, fd);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_close_hooks": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nexecute_all_close_hooks (gl_close_fn primary, int fd)\n{\n  return execute_close_hooks (anchor.private_next, primary, fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "execute_ioctl_hooks": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nexecute_ioctl_hooks (const struct fd_hook *remaining_list, gl_ioctl_fn primary,\n                     int fd, int request, void *arg)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd, request, arg);\n  else\n    return remaining_list->private_ioctl_fn (remaining_list->private_next,\n                                             primary, fd, request, arg);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_ioctl_hooks": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nexecute_all_ioctl_hooks (gl_ioctl_fn primary,\n                         int fd, int request, void *arg)\n{\n  return execute_ioctl_hooks (anchor.private_next, primary, fd, request, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "register_fd_hook": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nregister_fd_hook (close_hook_fn close_hook, ioctl_hook_fn ioctl_hook, struct fd_hook *link)\n{\n  if (close_hook == NULL)\n    close_hook = execute_close_hooks;\n  if (ioctl_hook == NULL)\n    ioctl_hook = execute_ioctl_hooks;\n\n  if (link->private_next == NULL && link->private_prev == NULL)\n    {\n      /* Add the link to the doubly linked list.  */\n      link->private_next = anchor.private_next;\n      link->private_prev = &anchor;\n      link->private_close_fn = close_hook;\n      link->private_ioctl_fn = ioctl_hook;\n      anchor.private_next->private_prev = link;\n      anchor.private_next = link;\n    }\n  else\n    {\n      /* The link is already in use.  */\n      if (link->private_close_fn != close_hook\n          || link->private_ioctl_fn != ioctl_hook)\n        abort ();\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "unregister_fd_hook": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nunregister_fd_hook (struct fd_hook *link)\n{\n  struct fd_hook *next = link->private_next;\n  struct fd_hook *prev = link->private_prev;\n\n  if (next != NULL && prev != NULL)\n    {\n      /* The link is in use.  Remove it from the doubly linked list.  */\n      prev->private_next = next;\n      next->private_prev = prev;\n      /* Clear the link, to mark it unused.  */\n      link->private_next = NULL;\n      link->private_prev = NULL;\n      link->private_close_fn = NULL;\n      link->private_ioctl_fn = NULL;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/fd-hook.h": {},
  "patch/patch-2.7.6/lib/fd-safer-flag.c": {
    "fd_safer_flag": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nfd_safer_flag (int fd, int flag)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer_flag (fd, flag);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/fd-safer.c": {
    "fd_safer": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nfd_safer (int fd)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer (fd);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/filename.h": {},
  "patch/patch-2.7.6/lib/filenamecat-lgpl.c": {
    "mfile_name_concat": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "char *\nmfile_name_concat (char const *dir, char const *base, char **base_in_result)\n{\n  char const *dirbase = last_component (dir);\n  size_t dirbaselen = base_len (dirbase);\n  size_t dirlen = dirbase - dir + dirbaselen;\n  size_t baselen = strlen (base);\n  char sep = '\\0';\n  if (dirbaselen)\n    {\n      /* DIR is not a file system root, so separate with / if needed.  */\n      if (! ISSLASH (dir[dirlen - 1]) && ! ISSLASH (*base))\n        sep = '/';\n    }\n  else if (ISSLASH (*base))\n    {\n      /* DIR is a file system root and BASE begins with a slash, so\n         separate with \".\".  For example, if DIR is \"/\" and BASE is\n         \"/foo\" then return \"/./foo\", as \"//foo\" would be wrong on\n         some POSIX systems.  A fancier algorithm could omit \".\" in\n         some cases but is not worth the trouble.  */\n      sep = '.';\n    }\n\n  char *p_concat = malloc (dirlen + (sep != '\\0')  + baselen + 1);\n  char *p;\n\n  if (p_concat == NULL)\n    return NULL;\n\n  p = mempcpy (p_concat, dir, dirlen);\n  *p = sep;\n  p += sep != '\\0';\n\n  if (base_in_result)\n    *base_in_result = p;\n\n  p = mempcpy (p, base, baselen);\n  *p = '\\0';\n\n  return p_concat;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "char",
        "*\nmfile_name_concat (char const *dir, char const *base, char **base_in_result)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/filenamecat.h": {},
  "patch/patch-2.7.6/lib/flexmember.h": {},
  "patch/patch-2.7.6/lib/float+.h": {},
  "patch/patch-2.7.6/lib/float.c": {},
  "patch/patch-2.7.6/lib/float.in.h": {},
  "patch/patch-2.7.6/lib/fstat.c": {
    "orig_fstat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\norig_fstat (int fd, struct stat *buf)\n{\n  return fstat (fd, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstat": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nrpl_fstat (int fd, struct stat *buf)\n{\n#if REPLACE_FCHDIR && REPLACE_OPEN_DIRECTORY\n  /* Handle the case when rpl_open() used a dummy file descriptor to work\n     around an open() that can't normally visit directories.  */\n  const char *name = _gl_directory_name (fd);\n  if (name != NULL)\n    return stat (name, buf);\n#endif\n\n#ifdef WINDOWS_NATIVE\n  /* Fill the fields ourselves, because the original fstat function returns\n     values for st_atime, st_mtime, st_ctime that depend on the current time\n     zone.  See\n     <https://lists.gnu.org/r/bug-gnulib/2017-04/msg00134.html>  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  return _gl_fstat_by_handle (h, NULL, buf);\n#else\n  return stat_time_normalize (orig_fstat (fd, buf), buf);\n#endif\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/fstatat.c": {
    "orig_fstatat": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static int\norig_fstatat (int fd, char const *filename, struct stat *buf, int flags)\n{\n  return fstatat (fd, filename, buf, flags);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "normal_fstatat": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\nnormal_fstatat (int fd, char const *file, struct stat *st, int flag)\n{\n  return stat_time_normalize (orig_fstatat (fd, file, st, flag), st);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstatat": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\nrpl_fstatat (int fd, char const *file, struct stat *st, int flag)\n{\n  int result = normal_fstatat (fd, file, st, flag);\n  size_t len;\n\n  if (LSTAT_FOLLOWS_SLASHED_SYMLINK || result != 0)\n    return result;\n  len = strlen (file);\n  if (flag & AT_SYMLINK_NOFOLLOW)\n    {\n      /* Fix lstat behavior.  */\n      if (file[len - 1] != '/' || S_ISDIR (st->st_mode))\n        return 0;\n      if (!S_ISLNK (st->st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      result = normal_fstatat (fd, file, st, flag & ~AT_SYMLINK_NOFOLLOW);\n    }\n  /* Fix stat behavior.  */\n  if (result == 0 && !S_ISDIR (st->st_mode) && file[len - 1] == '/')\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return result;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "stat_func": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "static int\nstat_func (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/full-write.c": {
    "full_rw": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "size_t\nfull_rw (int fd, const void *buf, size_t count)\n{\n  size_t total = 0;\n  const char *ptr = (const char *) buf;\n\n  while (count > 0)\n    {\n      size_t n_rw = safe_rw (fd, ptr, count);\n      if (n_rw == (size_t) -1)\n        break;\n      if (n_rw == 0)\n        {\n          errno = ZERO_BYTE_TRANSFER_ERRNO;\n          break;\n        }\n      total += n_rw;\n      ptr += n_rw;\n      count -= n_rw;\n    }\n\n  return total;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/full-write.h": {},
  "patch/patch-2.7.6/lib/getcwd-lgpl.c": {
    "rpl_getcwd": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "char *\nrpl_getcwd (char *buf, size_t size)\n{\n  char *ptr;\n  char *result;\n\n  /* Handle single size operations.  */\n  if (buf)\n    {\n      if (!size)\n        {\n          errno = EINVAL;\n          return NULL;\n        }\n      return getcwd (buf, size);\n    }\n\n  if (size)\n    {\n      buf = malloc (size);\n      if (!buf)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n      result = getcwd (buf, size);\n      if (!result)\n        {\n          int saved_errno = errno;\n          free (buf);\n          errno = saved_errno;\n        }\n      return result;\n    }\n\n  /* Flexible sizing requested.  Avoid over-allocation for the common\n     case of a name that fits within a 4k page, minus some space for\n     local variables, to be sure we don't skip over a guard page.  */\n  {\n    char tmp[4032];\n    size = sizeof tmp;\n    ptr = getcwd (tmp, size);\n    if (ptr)\n      {\n        result = strdup (ptr);\n        if (!result)\n          errno = ENOMEM;\n        return result;\n      }\n    if (errno != ERANGE)\n      return NULL;\n  }\n\n  /* My what a large directory name we have.  */\n  do\n    {\n      size <<= 1;\n      ptr = realloc (buf, size);\n      if (ptr == NULL)\n        {\n          free (buf);\n          errno = ENOMEM;\n          return NULL;\n        }\n      buf = ptr;\n      result = getcwd (buf, size);\n    }\n  while (!result && errno == ERANGE);\n\n  if (!result)\n    {\n      int saved_errno = errno;\n      free (buf);\n      errno = saved_errno;\n    }\n  else\n    {\n      /* Trim to fit, if possible.  */\n      result = realloc (buf, strlen (buf) + 1);\n      if (!result)\n        result = buf;\n    }\n  return result;\n}",
      "lines": 84,
      "depth": 12,
      "decorators": [
        "char",
        "*\nrpl_getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/getdate.h": {},
  "patch/patch-2.7.6/lib/getdtablesize.c": {
    "_setmaxstdio_nothrow": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "static int\n_setmaxstdio_nothrow (int newmax)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _setmaxstdio (newmax);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getdtablesize": [
      {
        "start_point": [
          56,
          0
        ],
        "end_point": [
          87,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  if (dtablesize == 0)\n    {\n      /* We are looking for the number N such that the valid file descriptors\n         are 0..N-1.  It can be obtained through a loop as follows:\n           {\n             int fd;\n             for (fd = 3; fd < 65536; fd++)\n               if (dup2 (0, fd) == -1)\n                 break;\n             return fd;\n           }\n         On Windows XP, the result is 2048.\n         The drawback of this loop is that it allocates memory for a libc\n         internal array that is never freed.\n\n         The number N can also be obtained as the upper bound for\n         _getmaxstdio ().  _getmaxstdio () returns the maximum number of open\n         FILE objects.  The sanity check in _setmaxstdio reveals the maximum\n         number of file descriptors.  This too allocates memory, but it is\n         freed when we call _setmaxstdio with the original value.  */\n      int orig_max_stdio = _getmaxstdio ();\n      unsigned int bound;\n      for (bound = 0x10000; _setmaxstdio_nothrow (bound) < 0; bound = bound / 2)\n        ;\n      _setmaxstdio_nothrow (orig_max_stdio);\n      dtablesize = bound;\n    }\n  return dtablesize;\n}",
        "lines": 32,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          108,
          0
        ],
        "end_point": [
          121,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  struct rlimit lim;\n\n  if (getrlimit (RLIMIT_NOFILE, &lim) == 0\n      && 0 <= lim.rlim_cur && lim.rlim_cur <= INT_MAX\n      && lim.rlim_cur != RLIM_INFINITY\n      && lim.rlim_cur != RLIM_SAVED_CUR\n      && lim.rlim_cur != RLIM_SAVED_MAX)\n    return lim.rlim_cur;\n\n  return INT_MAX;\n}",
        "lines": 14,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "patch/patch-2.7.6/lib/getgroups.c": {
    "getgroups": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\ngetgroups (int n _GL_UNUSED, GETGROUPS_T *groups _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_getgroups": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nrpl_getgroups (int n, gid_t *group)\n{\n  int n_groups;\n  GETGROUPS_T *gbuf;\n  int saved_errno;\n\n  if (n < 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  if (n != 0 || !GETGROUPS_ZERO_BUG)\n    {\n      int result;\n      if (sizeof *group == sizeof *gbuf)\n        return getgroups (n, (GETGROUPS_T *) group);\n\n      if (SIZE_MAX / sizeof *gbuf <= n)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      gbuf = malloc (n * sizeof *gbuf);\n      if (!gbuf)\n        return -1;\n      result = getgroups (n, gbuf);\n      if (0 <= result)\n        {\n          n = result;\n          while (n--)\n            group[n] = gbuf[n];\n        }\n      saved_errno = errno;\n      free (gbuf);\n      errno = saved_errno;\n      return result;\n    }\n\n  n = 20;\n  while (1)\n    {\n      /* No need to worry about address arithmetic overflow here,\n         since the ancient systems that we're running on have low\n         limits on the number of secondary groups.  */\n      gbuf = malloc (n * sizeof *gbuf);\n      if (!gbuf)\n        return -1;\n      n_groups = getgroups (n, gbuf);\n      if (n_groups == -1 ? errno != EINVAL : n_groups < n)\n        break;\n      free (gbuf);\n      n *= 2;\n    }\n\n  saved_errno = errno;\n  free (gbuf);\n  errno = saved_errno;\n\n  return n_groups;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/getopt-cdefs.in.h": {},
  "patch/patch-2.7.6/lib/getopt-core.h": {},
  "patch/patch-2.7.6/lib/getopt-ext.h": {
    "struct": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "__BEGIN_DECLS\n\n/* Describe the long-named options requested by the application.\n   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector\n   of 'struct option' terminated by an element containing a name which is\n   zero.\n\n   The field 'has_arg' is:\n   no_argument\t\t(or 0) if the option does not take an argument,\n   required_argument\t(or 1) if the option requires an argument,\n   optional_argument \t(or 2) if the option takes an optional argument.\n\n   If the field 'flag' is not NULL, it points to a variable that is set\n   to the value given in the field 'val' when the option is found, but\n   left unchanged if the option is not found.\n\n   To have a long-named option do something other than set an 'int' to\n   a compiled-in constant, such as set a value from 'optarg', set the\n   option's 'flag' field to zero and its 'val' field to a nonzero\n   value (the equivalent single-letter option character, if there is\n   one).  For long options that have a zero 'flag' field, 'getopt'\n   returns the contents of the 'val' field.  */\n\nstruct option\n{\n  const char *name;\n  /* has_arg can't be an enum because some compilers complain about\n     type mismatches in all the code that assumes it is an int.  */\n  int has_arg;\n  int *flag;\n  int val;\n}",
      "lines": 32,
      "depth": 5,
      "decorators": null
    }
  },
  "patch/patch-2.7.6/lib/getopt-pfx-core.h": {},
  "patch/patch-2.7.6/lib/getopt-pfx-ext.h": {},
  "patch/patch-2.7.6/lib/getopt.c": {
    "exchange": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n\t{\n\t  /* Bottom segment is the short one.  */\n\t  int len = middle - bottom;\n\t  int i;\n\n\t  /* Swap it with the top part of the top segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n\t      argv[top - (middle - bottom) + i] = tem;\n\t    }\n\t  /* Exclude the moved bottom segment from further swapping.  */\n\t  top -= len;\n\t}\n      else\n\t{\n\t  /* Top segment is the short one.  */\n\t  int len = top - middle;\n\t  int i;\n\n\t  /* Swap it with the bottom part of the bottom segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[middle + i];\n\t      argv[middle + i] = tem;\n\t    }\n\t  /* Exclude the moved top segment from further swapping.  */\n\t  bottom += len;\n\t}\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_long_option": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "static int\nprocess_long_option (int argc, char **argv, const char *optstring,\n\t\t     const struct option *longopts, int *longind,\n\t\t     int long_only, struct _getopt_data *d,\n\t\t     int print_errors, const char *prefix)\n{\n  char *nameend;\n  size_t namelen;\n  const struct option *p;\n  const struct option *pfound = NULL;\n  int n_options;\n  int option_index;\n\n  for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n    /* Do nothing.  */ ;\n  namelen = nameend - d->__nextchar;\n\n  /* First look for an exact match, counting the options as a side\n     effect.  */\n  for (p = longopts, n_options = 0; p->name; p++, n_options++)\n    if (!strncmp (p->name, d->__nextchar, namelen)\n\t&& namelen == strlen (p->name))\n      {\n\t/* Exact match found.  */\n\tpfound = p;\n\toption_index = n_options;\n\tbreak;\n      }\n\n  if (pfound == NULL)\n    {\n      /* Didn't find an exact match, so look for abbreviations.  */\n      unsigned char *ambig_set = NULL;\n      int ambig_malloced = 0;\n      int ambig_fallback = 0;\n      int indfound = -1;\n\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n\tif (!strncmp (p->name, d->__nextchar, namelen))\n\t  {\n\t    if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else if (long_only\n\t\t     || pfound->has_arg != p->has_arg\n\t\t     || pfound->flag != p->flag\n\t\t     || pfound->val != p->val)\n\t      {\n\t\t/* Second or later nonexact match found.  */\n\t\tif (!ambig_fallback)\n\t\t  {\n\t\t    if (!print_errors)\n\t\t      /* Don't waste effort tracking the ambig set if\n\t\t\t we're not going to print it anyway.  */\n\t\t      ambig_fallback = 1;\n\t\t    else if (!ambig_set)\n\t\t      {\n\t\t\tif (__libc_use_alloca (n_options))\n\t\t\t  ambig_set = alloca (n_options);\n\t\t\telse if ((ambig_set = malloc (n_options)) == NULL)\n\t\t\t  /* Fall back to simpler error message.  */\n\t\t\t  ambig_fallback = 1;\n\t\t\telse\n\t\t\t  ambig_malloced = 1;\n\n\t\t\tif (ambig_set)\n\t\t\t  {\n\t\t\t    memset (ambig_set, 0, n_options);\n\t\t\t    ambig_set[indfound] = 1;\n\t\t\t  }\n\t\t      }\n\t\t    if (ambig_set)\n\t\t      ambig_set[option_index] = 1;\n\t\t  }\n\t      }\n\t  }\n\n      if (ambig_set || ambig_fallback)\n\t{\n\t  if (print_errors)\n\t    {\n\t      if (ambig_fallback)\n\t\tfprintf (stderr, _(\"%s: option '%s%s' is ambiguous\\n\"),\n\t\t\t argv[0], prefix, d->__nextchar);\n\t      else\n\t\t{\n\t\t  flockfile (stderr);\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option '%s%s' is ambiguous; possibilities:\"),\n\t\t\t   argv[0], prefix, d->__nextchar);\n\n\t\t  for (option_index = 0; option_index < n_options; option_index++)\n\t\t    if (ambig_set[option_index])\n\t\t      fprintf (stderr, \" '%s%s'\",\n\t\t\t       prefix, longopts[option_index].name);\n\n\t\t  /* This must use 'fprintf' even though it's only\n\t\t     printing a single character, so that it goes through\n\t\t     __fxprintf_nocancel when compiled as part of glibc.  */\n\t\t  fprintf (stderr, \"\\n\");\n\t\t  funlockfile (stderr);\n\t\t}\n\t    }\n\t  if (ambig_malloced)\n\t    free (ambig_set);\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      option_index = indfound;\n    }\n\n  if (pfound == NULL)\n    {\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short option,\n\t then it's an error.  */\n      if (!long_only || argv[d->optind][1] == '-'\n\t  || strchr (optstring, *d->__nextchar) == NULL)\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr, _(\"%s: unrecognized option '%s%s'\\n\"),\n\t\t     argv[0], prefix, d->__nextchar);\n\n\t  d->__nextchar = NULL;\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      /* Otherwise interpret it as a short option.  */\n      return -1;\n    }\n\n  /* We have found a matching long option.  Consume it.  */\n  d->optind++;\n  d->__nextchar = NULL;\n  if (*nameend)\n    {\n      /* Don't test has_arg with >, because some C compilers don't\n\t allow it to be used on enums.  */\n      if (pfound->has_arg)\n\td->optarg = nameend + 1;\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' doesn't allow an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return '?';\n\t}\n    }\n  else if (pfound->has_arg == 1)\n    {\n      if (d->optind < argc)\n\td->optarg = argv[d->optind++];\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' requires an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return optstring[0] == ':' ? ':' : '?';\n\t}\n    }\n\n  if (longind != NULL)\n    *longind = option_index;\n  if (pfound->flag)\n    {\n      *(pfound->flag) = pfound->val;\n      return 0;\n    }\n  return pfound->val;\n}",
      "lines": 184,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n  if (d->optind == 0)\n    d->optind = 1;\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n  d->__nextchar = NULL;\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (posixly_correct || !!getenv (\"POSIXLY_CORRECT\"))\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n  d->__initialized = 1;\n  return optstring;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n\t\t    const struct option *longopts, int *longind,\n\t\t    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.  */\n#define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n\t moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n\td->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n\td->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__last_nonopt != d->optind)\n\t    d->__first_nonopt = d->optind;\n\n\t  /* Skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (d->optind < argc && NONOPTION_P)\n\t    d->optind++;\n\t  d->__last_nonopt = d->optind;\n\t}\n\n      /* The special ARGV-element '--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n\t{\n\t  d->optind++;\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__first_nonopt == d->__last_nonopt)\n\t    d->__first_nonopt = d->optind;\n\t  d->__last_nonopt = argc;\n\n\t  d->optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (d->__first_nonopt != d->__last_nonopt)\n\t    d->optind = d->__first_nonopt;\n\t  return -1;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n\t{\n\t  if (d->__ordering == REQUIRE_ORDER)\n\t    return -1;\n\t  d->optarg = argv[d->optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Check whether it might be a long option.  */\n      if (longopts)\n\t{\n\t  if (argv[d->optind][1] == '-')\n\t    {\n\t      /* \"--foo\" is always a long option.  The special option\n\t\t \"--\" was handled above.  */\n\t      d->__nextchar = argv[d->optind] + 2;\n\t      return process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"--\");\n\t    }\n\n\t  /* If long_only and the ARGV-element has the form \"-f\",\n\t     where f is a valid short option, don't consider it an\n\t     abbreviated form of a long option that starts with f.\n\t     Otherwise there would be no way to give the -f short\n\t     option.\n\n\t     On the other hand, if there's a long option \"fubar\" and\n\t     the ARGV-element is \"-fu\", do consider that an\n\t     abbreviation of the long option, just like \"--fu\", and\n\t     not \"-f\" with arg \"u\".\n\n\t     This distinction seems to be the most useful approach.  */\n\t  if (long_only && (argv[d->optind][2]\n\t\t\t    || !strchr (optstring, argv[d->optind][1])))\n\t    {\n\t      int code;\n\t      d->__nextchar = argv[d->optind] + 1;\n\t      code = process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"-\");\n\t      if (code != -1)\n\t\treturn code;\n\t    }\n\t}\n\n      /* It is not a long option.  Skip the initial punctuation.  */\n      d->__nextchar = argv[d->optind] + 1;\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n\tif (print_errors)\n\t  fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n\td->optopt = c;\n\treturn '?';\n      }\n\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';' && longopts != NULL)\n      {\n\t/* This is an option that requires an argument.  */\n\tif (*d->__nextchar != '\\0')\n\t  d->optarg = d->__nextchar;\n\telse if (d->optind == argc)\n\t  {\n\t    if (print_errors)\n\t      fprintf (stderr,\n\t\t       _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t       argv[0], c);\n\n\t    d->optopt = c;\n\t    if (optstring[0] == ':')\n\t      c = ':';\n\t    else\n\t      c = '?';\n\t    return c;\n\t  }\n\telse\n\t  d->optarg = argv[d->optind];\n\n\td->__nextchar = d->optarg;\n\td->optarg = NULL;\n\treturn process_long_option (argc, argv, optstring, longopts, longind,\n\t\t\t\t    0 /* long_only */, d, print_errors, \"-W \");\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\td->optind++;\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\td->optind++;\n\t      }\n\t    else if (d->optind == argc)\n\t      {\n\t\tif (print_errors)\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t   argv[0], c);\n\n\t\td->optopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented 'optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      d->optarg = argv[d->optind++];\n\t    d->__nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}",
      "lines": 231,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        701,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n\t\t  const struct option *longopts, int *longind, int long_only,\n\t\t  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n\t\t\t       longind, long_only, &getopt_data,\n\t\t\t       posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/getopt.in.h": {},
  "patch/patch-2.7.6/lib/getopt1.c": {
    "getopt_long": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n\t     const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n\t\tconst struct option *long_options, int *opt_index,\n\t\tstruct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n\t\t  const char *options,\n\t\t  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n\t\t     const struct option *long_options, int *opt_index,\n\t\t     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n\t{\"add\", 1, 0, 0},\n\t{\"append\", 0, 0, 0},\n\t{\"delete\", 1, 0, 0},\n\t{\"verbose\", 0, 0, 0},\n\t{\"create\", 0, 0, 0},\n\t{\"file\", 1, 0, 0},\n\t{0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n\t\t       long_options, &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  printf (\"option %s\", long_options[option_index].name);\n\t  if (optarg)\n\t    printf (\" with arg %s\", optarg);\n\t  printf (\"\\n\");\n\t  break;\n\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase 'd':\n\t  printf (\"option d with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/getopt_int.h": {},
  "patch/patch-2.7.6/lib/getprogname.c": {
    "getprogname": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "char const *\ngetprogname (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return program_invocation_short_name;\n# elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return last_component (program_invocation_name);\n# elif HAVE_GETEXECNAME                                     /* Solaris */\n  /* https://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n  const char *p = getexecname ();\n  if (!p)\n    p = \"?\";\n  return last_component (p);\n# elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n  /* https://msdn.microsoft.com/en-us/library/dn727674.aspx */\n  const char *p = __argv && __argv[0] ? __argv[0] : \"?\";\n  return last_component (p);\n# elif HAVE_VAR___PROGNAME                                  /* OpenBSD, QNX */\n  /* https://man.openbsd.org/style.9 */\n  /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n  /* Be careful to declare this only when we absolutely need it\n     (OpenBSD 5.1), rather than when it's available.  Otherwise,\n     its mere declaration makes program_invocation_short_name\n     malfunction (have zero length) with Fedora 25's glibc.  */\n  extern char *__progname;\n  const char *p = __progname;\n  return p && p[0] ? p : \"?\";\n# elif _AIX                                                 /* AIX */\n  /* Idea by Bastien ROUCARI\u00c3\u0088S,\n     https://lists.gnu.org/r/bug-gnulib/2010-12/msg00095.html\n     Reference: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.basetrf1/getprocs.htm\n  */\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct procentry64 procs;\n      p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n           ? strdup (procs.pi_comm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif defined __hpux\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct pst_status status;\n      p = (0 < pstat_getproc (&status, sizeof status, 0, pid)\n           ? strdup (status.pst_ucomm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif __MVS__                                              /* z/OS */\n  /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n  static char *p = \"?\";\n  static int first = 1;\n  if (first)\n    {\n      pid_t pid = getpid ();\n      int token;\n      W_PSPROC buf;\n      first = 0;\n      memset (&buf, 0, sizeof(buf));\n      buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n      buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n      buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n      if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n        {\n          for (token = 0; token >= 0;\n               token = w_getpsent (token, &buf, sizeof(buf)))\n            {\n              if (token > 0 && buf.ps_pid == pid)\n                {\n                  char *s = strdup (last_component (buf.ps_pathptr));\n                  if (s)\n                    p = s;\n                  break;\n                }\n            }\n        }\n      free (buf.ps_cmdptr);\n      free (buf.ps_conttyptr);\n      free (buf.ps_pathptr);\n    }\n  return p;\n# elif defined __sgi                                        /* IRIX */\n  char filename[50];\n  int fd;\n\n  sprintf (filename, \"/proc/pinfo/%d\", (int) getpid ());\n  fd = open (filename, O_RDONLY);\n  if (0 <= fd)\n    {\n      prpsinfo_t buf;\n      int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);\n      close (fd);\n      if (ioctl_ok)\n        {\n          char *name = buf.pr_fname;\n          size_t namesize = sizeof buf.pr_fname;\n          char *namenul = memchr (name, '\\0', namesize);\n          size_t namelen = namenul ? namenul - name : namesize;\n          char *namecopy = malloc (namelen + 1);\n          if (namecopy)\n            {\n              namecopy[namelen] = 0;\n              return memcpy (namecopy, name, namelen);\n            }\n        }\n    }\n  return NULL;\n# else\n#  error \"getprogname module not ported to this OS\"\n# endif\n}",
      "lines": 126,
      "depth": 26,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ngetprogname (void)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/getprogname.h": {},
  "patch/patch-2.7.6/lib/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n      found_translation = (translation != msg_ctxt_id);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n      found_translation = !(translation == msg_ctxt_id || translation == msgid_plural);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/gettime.c": {
    "gettime": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\ngettime (struct timespec *ts)\n{\n#if HAVE_NANOTIME\n  nanotime (ts);\n#else\n\n# if defined CLOCK_REALTIME && HAVE_CLOCK_GETTIME\n  if (clock_gettime (CLOCK_REALTIME, ts) == 0)\n    return;\n# endif\n\n  {\n    struct timeval tv;\n    gettimeofday (&tv, NULL);\n    ts->tv_sec = tv.tv_sec;\n    ts->tv_nsec = tv.tv_usec * 1000;\n  }\n\n#endif\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/gettimeofday.c": {
    "initialize": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static void\ninitialize (void)\n{\n  HMODULE kernel32 = LoadLibrary (\"kernel32.dll\");\n  if (kernel32 != NULL)\n    {\n      GetSystemTimePreciseAsFileTimeFunc =\n\t(GetSystemTimePreciseAsFileTimeFuncType) GetProcAddress (kernel32, \"GetSystemTimePreciseAsFileTime\");\n    }\n  initialized = TRUE;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#ifdef WINDOWS_NATIVE\n\n  /* On native Windows, there are two ways to get the current time:\n     GetSystemTimeAsFileTime\n     <https://msdn.microsoft.com/en-us/library/ms724397.aspx>\n     or\n     GetSystemTimePreciseAsFileTime\n     <https://msdn.microsoft.com/en-us/library/hh706895.aspx>.\n     GetSystemTimeAsFileTime produces values that jump by increments of\n     15.627 milliseconds (!) on average.\n     Whereas GetSystemTimePreciseAsFileTime values usually jump by 1 or 2\n     microseconds.\n     More discussion on this topic:\n     <http://www.windowstimestamp.com/description>.  */\n  FILETIME current_time;\n\n  if (!initialized)\n    initialize ();\n  if (GetSystemTimePreciseAsFileTimeFunc != NULL)\n    GetSystemTimePreciseAsFileTimeFunc (&current_time);\n  else\n    GetSystemTimeAsFileTime (&current_time);\n\n  /* Convert from FILETIME to 'struct timeval'.  */\n  /* FILETIME: <https://msdn.microsoft.com/en-us/library/ms724284.aspx> */\n  ULONGLONG since_1601 =\n    ((ULONGLONG) current_time.dwHighDateTime << 32)\n    | (ULONGLONG) current_time.dwLowDateTime;\n  /* Between 1601-01-01 and 1970-01-01 there were 280 normal years and 89 leap\n     years, in total 134774 days.  */\n  ULONGLONG since_1970 =\n    since_1601 - (ULONGLONG) 134774 * (ULONGLONG) 86400 * (ULONGLONG) 10000000;\n  ULONGLONG microseconds_since_1970 = since_1970 / (ULONGLONG) 10;\n  tv->tv_sec = microseconds_since_1970 / (ULONGLONG) 1000000;\n  tv->tv_usec = microseconds_since_1970 % (ULONGLONG) 1000000;\n\n  return 0;\n\n#else\n\n# if HAVE_GETTIMEOFDAY\n#  if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n#  endif\n\n#  if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#   undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n#  else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n#  endif\n\n#  if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n#  endif\n\n  return result;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n  return 0;\n\n# endif\n#endif\n}",
      "lines": 84,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/gl_anylinked_list1.h": {},
  "patch/patch-2.7.6/lib/gl_anylinked_list2.h": {
    "gl_linked_nx_create_empty": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static gl_list_t\ngl_linked_nx_create_empty (gl_list_implementation_t implementation,\n                           gl_listelement_equals_fn equals_fn,\n                           gl_listelement_hashcode_fn hashcode_fn,\n                           gl_listelement_dispose_fn dispose_fn,\n                           bool allow_duplicates)\n{\n  struct gl_list_impl *list =\n    (struct gl_list_impl *) malloc (sizeof (struct gl_list_impl));\n\n  if (list == NULL)\n    return NULL;\n\n  list->base.vtable = implementation;\n  list->base.equals_fn = equals_fn;\n  list->base.hashcode_fn = hashcode_fn;\n  list->base.dispose_fn = dispose_fn;\n  list->base.allow_duplicates = allow_duplicates;\n#if WITH_HASHTABLE\n  list->table_size = 11;\n  list->table =\n    (gl_hash_entry_t *) calloc (list->table_size, sizeof (gl_hash_entry_t));\n  if (list->table == NULL)\n    goto fail;\n#endif\n  list->root.next = &list->root;\n  list->root.prev = &list->root;\n  list->count = 0;\n\n  return list;\n\n#if WITH_HASHTABLE\n fail:\n  free (list);\n  return NULL;\n#endif\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "gl_list_t"
      ]
    },
    "gl_linked_nx_create": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static gl_list_t\ngl_linked_nx_create (gl_list_implementation_t implementation,\n                  gl_listelement_equals_fn equals_fn,\n                  gl_listelement_hashcode_fn hashcode_fn,\n                  gl_listelement_dispose_fn dispose_fn,\n                  bool allow_duplicates,\n                  size_t count, const void **contents)\n{\n  struct gl_list_impl *list =\n    (struct gl_list_impl *) malloc (sizeof (struct gl_list_impl));\n  gl_list_node_t tail;\n\n  if (list == NULL)\n    return NULL;\n\n  list->base.vtable = implementation;\n  list->base.equals_fn = equals_fn;\n  list->base.hashcode_fn = hashcode_fn;\n  list->base.dispose_fn = dispose_fn;\n  list->base.allow_duplicates = allow_duplicates;\n#if WITH_HASHTABLE\n  {\n    size_t estimate = xsum (count, count / 2); /* 1.5 * count */\n    if (estimate < 10)\n      estimate = 10;\n    list->table_size = next_prime (estimate);\n    if (size_overflow_p (xtimes (list->table_size, sizeof (gl_hash_entry_t))))\n      goto fail1;\n    list->table =\n      (gl_hash_entry_t *) calloc (list->table_size, sizeof (gl_hash_entry_t));\n    if (list->table == NULL)\n      goto fail1;\n  }\n#endif\n  list->count = count;\n  tail = &list->root;\n  for (; count > 0; contents++, count--)\n    {\n      gl_list_node_t node =\n        (struct gl_list_node_impl *) malloc (sizeof (struct gl_list_node_impl));\n\n      if (node == NULL)\n        goto fail2;\n\n      node->value = *contents;\n#if WITH_HASHTABLE\n      node->h.hashcode =\n        (list->base.hashcode_fn != NULL\n         ? list->base.hashcode_fn (node->value)\n         : (size_t)(uintptr_t) node->value);\n\n      /* Add node to the hash table.  */\n      if (add_to_bucket (list, node) < 0)\n        {\n          free (node);\n          goto fail2;\n        }\n#endif\n\n      /* Add node to the list.  */\n      node->prev = tail;\n      tail->next = node;\n      tail = node;\n    }\n  tail->next = &list->root;\n  list->root.prev = tail;\n\n  return list;\n\n fail2:\n  {\n    gl_list_node_t node;\n\n    for (node = tail; node != &list->root; )\n      {\n        gl_list_node_t prev = node->prev;\n\n        free (node);\n        node = prev;\n      }\n  }\n#if WITH_HASHTABLE\n  free (list->table);\n fail1:\n#endif\n  free (list);\n  return NULL;\n}",
      "lines": 88,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "gl_list_t"
      ]
    },
    "gl_linked_size": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\ngl_linked_size (gl_list_t list)\n{\n  return list->count;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "gl_linked_node_value": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "static const void * _GL_ATTRIBUTE_PURE\ngl_linked_node_value (gl_list_t list, gl_list_node_t node)\n{\n  return node->value;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "void",
        "* _GL_ATTRIBUTE_PURE\ngl_linked_node_value (gl_list_t list, gl_list_node_t node)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "gl_linked_node_nx_set_value": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "static int\ngl_linked_node_nx_set_value (gl_list_t list, gl_list_node_t node,\n                             const void *elt)\n{\n#if WITH_HASHTABLE\n  if (elt != node->value)\n    {\n      size_t new_hashcode =\n        (list->base.hashcode_fn != NULL\n         ? list->base.hashcode_fn (elt)\n         : (size_t)(uintptr_t) elt);\n\n      if (new_hashcode != node->h.hashcode)\n        {\n          remove_from_bucket (list, node);\n          node->value = elt;\n          node->h.hashcode = new_hashcode;\n          if (add_to_bucket (list, node) < 0)\n            {\n              /* Out of memory.  We removed node from a bucket but cannot add\n                 it to another bucket.  In order to avoid inconsistencies, we\n                 must remove node entirely from the list.  */\n              gl_list_node_t before_removed = node->prev;\n              gl_list_node_t after_removed = node->next;\n              ASYNCSAFE(gl_list_node_t) before_removed->next = after_removed;\n              after_removed->prev = before_removed;\n              list->count--;\n              free (node);\n              return -1;\n            }\n        }\n      else\n        node->value = elt;\n    }\n#else\n  node->value = elt;\n#endif\n  return 0;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gl_linked_next_node": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static gl_list_node_t _GL_ATTRIBUTE_PURE\ngl_linked_next_node (gl_list_t list, gl_list_node_t node)\n{\n  return (node->next != &list->root ? node->next : NULL);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "gl_linked_previous_node": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "static gl_list_node_t _GL_ATTRIBUTE_PURE\ngl_linked_previous_node (gl_list_t list, gl_list_node_t node)\n{\n  return (node->prev != &list->root ? node->prev : NULL);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "gl_linked_get_at": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static const void * _GL_ATTRIBUTE_PURE\ngl_linked_get_at (gl_list_t list, size_t position)\n{\n  size_t count = list->count;\n  gl_list_node_t node;\n\n  if (!(position < count))\n    /* Invalid argument.  */\n    abort ();\n  /* Here we know count > 0.  */\n  if (position <= ((count - 1) / 2))\n    {\n      node = list->root.next;\n      for (; position > 0; position--)\n        node = node->next;\n    }\n  else\n    {\n      position = count - 1 - position;\n      node = list->root.prev;\n      for (; position > 0; position--)\n        node = node->prev;\n    }\n  return node->value;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "void",
        "* _GL_ATTRIBUTE_PURE\ngl_linked_get_at (gl_list_t list, size_t position)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "gl_linked_nx_set_at": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "static gl_list_node_t\ngl_linked_nx_set_at (gl_list_t list, size_t position, const void *elt)\n{\n  size_t count = list->count;\n  gl_list_node_t node;\n\n  if (!(position < count))\n    /* Invalid argument.  */\n    abort ();\n  /* Here we know count > 0.  */\n  if (position <= ((count - 1) / 2))\n    {\n      node = list->root.next;\n      for (; position > 0; position--)\n        node = node->next;\n    }\n  else\n    {\n      position = count - 1 - position;\n      node = list->root.prev;\n      for (; position > 0; position--)\n        node = node->prev;\n    }\n#if WITH_HASHTABLE\n  if (elt != node->value)\n    {\n      size_t new_hashcode =\n        (list->base.hashcode_fn != NULL\n         ? list->base.hashcode_fn (elt)\n         : (size_t)(uintptr_t) elt);\n\n      if (new_hashcode != node->h.hashcode)\n        {\n          remove_from_bucket (list, node);\n          node->value = elt;\n          node->h.hashcode = new_hashcode;\n          if (add_to_bucket (list, node) < 0)\n            {\n              /* Out of memory.  We removed node from a bucket but cannot add\n                 it to another bucket.  In order to avoid inconsistencies, we\n                 must remove node entirely from the list.  */\n              gl_list_node_t before_removed = node->prev;\n              gl_list_node_t after_removed = node->next;\n              ASYNCSAFE(gl_list_node_t) before_removed->next = after_removed;\n              after_removed->prev = before_removed;\n              list->count--;\n              free (node);\n              return NULL;\n            }\n        }\n      else\n        node->value = elt;\n    }\n#else\n  node->value = elt;\n#endif\n  return node;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_linked_search_from_to": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "static gl_list_node_t _GL_ATTRIBUTE_PURE\ngl_linked_search_from_to (gl_list_t list, size_t start_index, size_t end_index,\n                          const void *elt)\n{\n  size_t count = list->count;\n\n  if (!(start_index <= end_index && end_index <= count))\n    /* Invalid arguments.  */\n    abort ();\n  {\n#if WITH_HASHTABLE\n    size_t hashcode =\n      (list->base.hashcode_fn != NULL\n       ? list->base.hashcode_fn (elt)\n       : (size_t)(uintptr_t) elt);\n    size_t bucket = hashcode % list->table_size;\n    gl_listelement_equals_fn equals = list->base.equals_fn;\n\n    if (!list->base.allow_duplicates)\n      {\n        /* Look for the first match in the hash bucket.  */\n        gl_list_node_t found = NULL;\n        gl_list_node_t node;\n\n        for (node = (gl_list_node_t) list->table[bucket];\n             node != NULL;\n             node = (gl_list_node_t) node->h.hash_next)\n          if (node->h.hashcode == hashcode\n              && (equals != NULL\n                  ? equals (elt, node->value)\n                  : elt == node->value))\n            {\n              found = node;\n              break;\n            }\n        if (start_index > 0)\n          /* Look whether found's index is < start_index.  */\n          for (node = list->root.next; ; node = node->next)\n            {\n              if (node == found)\n                return NULL;\n              if (--start_index == 0)\n                break;\n            }\n        if (end_index < count)\n          /* Look whether found's index is >= end_index.  */\n          {\n            end_index = count - end_index;\n            for (node = list->root.prev; ; node = node->prev)\n              {\n                if (node == found)\n                  return NULL;\n                if (--end_index == 0)\n                  break;\n              }\n          }\n        return found;\n      }\n    else\n      {\n        /* Look whether there is more than one match in the hash bucket.  */\n        bool multiple_matches = false;\n        gl_list_node_t first_match = NULL;\n        gl_list_node_t node;\n\n        for (node = (gl_list_node_t) list->table[bucket];\n             node != NULL;\n             node = (gl_list_node_t) node->h.hash_next)\n          if (node->h.hashcode == hashcode\n              && (equals != NULL\n                  ? equals (elt, node->value)\n                  : elt == node->value))\n            {\n              if (first_match == NULL)\n                first_match = node;\n              else\n                {\n                  multiple_matches = true;\n                  break;\n                }\n            }\n        if (multiple_matches)\n          {\n            /* We need the match with the smallest index.  But we don't have\n               a fast mapping node -> index.  So we have to walk the list.  */\n            end_index -= start_index;\n            node = list->root.next;\n            for (; start_index > 0; start_index--)\n              node = node->next;\n\n            for (;\n                 end_index > 0;\n                 node = node->next, end_index--)\n              if (node->h.hashcode == hashcode\n                  && (equals != NULL\n                      ? equals (elt, node->value)\n                      : elt == node->value))\n                return node;\n            /* The matches must have all been at indices < start_index or\n               >= end_index.  */\n            return NULL;\n          }\n        else\n          {\n            if (start_index > 0)\n              /* Look whether first_match's index is < start_index.  */\n              for (node = list->root.next; node != &list->root; node = node->next)\n                {\n                  if (node == first_match)\n                    return NULL;\n                  if (--start_index == 0)\n                    break;\n                }\n            if (end_index < list->count)\n              /* Look whether first_match's index is >= end_index.  */\n              {\n                end_index = list->count - end_index;\n                for (node = list->root.prev; ; node = node->prev)\n                  {\n                    if (node == first_match)\n                      return NULL;\n                    if (--end_index == 0)\n                      break;\n                  }\n              }\n            return first_match;\n          }\n      }\n#else\n    gl_listelement_equals_fn equals = list->base.equals_fn;\n    gl_list_node_t node = list->root.next;\n\n    end_index -= start_index;\n    for (; start_index > 0; start_index--)\n      node = node->next;\n\n    if (equals != NULL)\n      {\n        for (; end_index > 0; node = node->next, end_index--)\n          if (equals (elt, node->value))\n            return node;\n      }\n    else\n      {\n        for (; end_index > 0; node = node->next, end_index--)\n          if (elt == node->value)\n            return node;\n      }\n    return NULL;\n#endif\n  }\n}",
      "lines": 152,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "gl_linked_indexof_from_to": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        592,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\ngl_linked_indexof_from_to (gl_list_t list, size_t start_index, size_t end_index,\n                           const void *elt)\n{\n  size_t count = list->count;\n\n  if (!(start_index <= end_index && end_index <= count))\n    /* Invalid arguments.  */\n    abort ();\n  {\n#if WITH_HASHTABLE\n    /* Here the hash table doesn't help much.  It only allows us to minimize\n       the number of equals() calls, by looking up first the node and then\n       its index.  */\n    size_t hashcode =\n      (list->base.hashcode_fn != NULL\n       ? list->base.hashcode_fn (elt)\n       : (size_t)(uintptr_t) elt);\n    size_t bucket = hashcode % list->table_size;\n    gl_listelement_equals_fn equals = list->base.equals_fn;\n    gl_list_node_t node;\n\n    /* First step: Look up the node.  */\n    if (!list->base.allow_duplicates)\n      {\n        /* Look for the first match in the hash bucket.  */\n        for (node = (gl_list_node_t) list->table[bucket];\n             node != NULL;\n             node = (gl_list_node_t) node->h.hash_next)\n          if (node->h.hashcode == hashcode\n              && (equals != NULL\n                  ? equals (elt, node->value)\n                  : elt == node->value))\n            break;\n      }\n    else\n      {\n        /* Look whether there is more than one match in the hash bucket.  */\n        bool multiple_matches = false;\n        gl_list_node_t first_match = NULL;\n\n        for (node = (gl_list_node_t) list->table[bucket];\n             node != NULL;\n             node = (gl_list_node_t) node->h.hash_next)\n          if (node->h.hashcode == hashcode\n              && (equals != NULL\n                  ? equals (elt, node->value)\n                  : elt == node->value))\n            {\n              if (first_match == NULL)\n                first_match = node;\n              else\n                {\n                  multiple_matches = true;\n                  break;\n                }\n            }\n        if (multiple_matches)\n          {\n            /* We need the match with the smallest index.  But we don't have\n               a fast mapping node -> index.  So we have to walk the list.  */\n            size_t index;\n\n            index = start_index;\n            node = list->root.next;\n            for (; start_index > 0; start_index--)\n              node = node->next;\n\n            for (;\n                 index < end_index;\n                 node = node->next, index++)\n              if (node->h.hashcode == hashcode\n                  && (equals != NULL\n                      ? equals (elt, node->value)\n                      : elt == node->value))\n                return index;\n            /* The matches must have all been at indices < start_index or\n               >= end_index.  */\n            return (size_t)(-1);\n          }\n        node = first_match;\n      }\n\n    /* Second step: Look up the index of the node.  */\n    if (node == NULL)\n      return (size_t)(-1);\n    else\n      {\n        size_t index = 0;\n\n        for (; node->prev != &list->root; node = node->prev)\n          index++;\n\n        if (index >= start_index && index < end_index)\n          return index;\n        else\n          return (size_t)(-1);\n      }\n#else\n    gl_listelement_equals_fn equals = list->base.equals_fn;\n    size_t index = start_index;\n    gl_list_node_t node = list->root.next;\n\n    for (; start_index > 0; start_index--)\n      node = node->next;\n\n    if (equals != NULL)\n      {\n        for (;\n             index < end_index;\n             node = node->next, index++)\n          if (equals (elt, node->value))\n            return index;\n      }\n    else\n      {\n        for (;\n             index < end_index;\n             node = node->next, index++)\n          if (elt == node->value)\n            return index;\n      }\n    return (size_t)(-1);\n#endif\n  }\n}",
      "lines": 126,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "gl_linked_nx_add_first": {
      "start_point": [
        594,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "static gl_list_node_t\ngl_linked_nx_add_first (gl_list_t list, const void *elt)\n{\n  gl_list_node_t node =\n    (struct gl_list_node_impl *) malloc (sizeof (struct gl_list_node_impl));\n\n  if (node == NULL)\n    return NULL;\n\n  ASYNCSAFE(const void *) node->value = elt;\n#if WITH_HASHTABLE\n  node->h.hashcode =\n    (list->base.hashcode_fn != NULL\n     ? list->base.hashcode_fn (node->value)\n     : (size_t)(uintptr_t) node->value);\n\n  /* Add node to the hash table.  */\n  if (add_to_bucket (list, node) < 0)\n    {\n      free (node);\n      return NULL;\n    }\n#endif\n\n  /* Add node to the list.  */\n  node->prev = &list->root;\n  ASYNCSAFE(gl_list_node_t) node->next = list->root.next;\n  node->next->prev = node;\n  ASYNCSAFE(gl_list_node_t) list->root.next = node;\n  list->count++;\n\n#if WITH_HASHTABLE\n  hash_resize_after_add (list);\n#endif\n\n  return node;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_linked_nx_add_last": {
      "start_point": [
        632,
        0
      ],
      "end_point": [
        668,
        1
      ],
      "content": "static gl_list_node_t\ngl_linked_nx_add_last (gl_list_t list, const void *elt)\n{\n  gl_list_node_t node =\n    (struct gl_list_node_impl *) malloc (sizeof (struct gl_list_node_impl));\n\n  if (node == NULL)\n    return NULL;\n\n  ASYNCSAFE(const void *) node->value = elt;\n#if WITH_HASHTABLE\n  node->h.hashcode =\n    (list->base.hashcode_fn != NULL\n     ? list->base.hashcode_fn (node->value)\n     : (size_t)(uintptr_t) node->value);\n\n  /* Add node to the hash table.  */\n  if (add_to_bucket (list, node) < 0)\n    {\n      free (node);\n      return NULL;\n    }\n#endif\n\n  /* Add node to the list.  */\n  ASYNCSAFE(gl_list_node_t) node->next = &list->root;\n  node->prev = list->root.prev;\n  ASYNCSAFE(gl_list_node_t) node->prev->next = node;\n  list->root.prev = node;\n  list->count++;\n\n#if WITH_HASHTABLE\n  hash_resize_after_add (list);\n#endif\n\n  return node;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_linked_nx_add_before": {
      "start_point": [
        670,
        0
      ],
      "end_point": [
        706,
        1
      ],
      "content": "static gl_list_node_t\ngl_linked_nx_add_before (gl_list_t list, gl_list_node_t node, const void *elt)\n{\n  gl_list_node_t new_node =\n    (struct gl_list_node_impl *) malloc (sizeof (struct gl_list_node_impl));\n\n  if (new_node == NULL)\n    return NULL;\n\n  ASYNCSAFE(const void *) new_node->value = elt;\n#if WITH_HASHTABLE\n  new_node->h.hashcode =\n    (list->base.hashcode_fn != NULL\n     ? list->base.hashcode_fn (new_node->value)\n     : (size_t)(uintptr_t) new_node->value);\n\n  /* Add new_node to the hash table.  */\n  if (add_to_bucket (list, new_node) < 0)\n    {\n      free (new_node);\n      return NULL;\n    }\n#endif\n\n  /* Add new_node to the list.  */\n  ASYNCSAFE(gl_list_node_t) new_node->next = node;\n  new_node->prev = node->prev;\n  ASYNCSAFE(gl_list_node_t) new_node->prev->next = new_node;\n  node->prev = new_node;\n  list->count++;\n\n#if WITH_HASHTABLE\n  hash_resize_after_add (list);\n#endif\n\n  return new_node;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_linked_nx_add_after": {
      "start_point": [
        708,
        0
      ],
      "end_point": [
        744,
        1
      ],
      "content": "static gl_list_node_t\ngl_linked_nx_add_after (gl_list_t list, gl_list_node_t node, const void *elt)\n{\n  gl_list_node_t new_node =\n    (struct gl_list_node_impl *) malloc (sizeof (struct gl_list_node_impl));\n\n  if (new_node == NULL)\n    return NULL;\n\n  ASYNCSAFE(const void *) new_node->value = elt;\n#if WITH_HASHTABLE\n  new_node->h.hashcode =\n    (list->base.hashcode_fn != NULL\n     ? list->base.hashcode_fn (new_node->value)\n     : (size_t)(uintptr_t) new_node->value);\n\n  /* Add new_node to the hash table.  */\n  if (add_to_bucket (list, new_node) < 0)\n    {\n      free (new_node);\n      return NULL;\n    }\n#endif\n\n  /* Add new_node to the list.  */\n  new_node->prev = node;\n  ASYNCSAFE(gl_list_node_t) new_node->next = node->next;\n  new_node->next->prev = new_node;\n  ASYNCSAFE(gl_list_node_t) node->next = new_node;\n  list->count++;\n\n#if WITH_HASHTABLE\n  hash_resize_after_add (list);\n#endif\n\n  return new_node;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_linked_nx_add_at": {
      "start_point": [
        746,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "static gl_list_node_t\ngl_linked_nx_add_at (gl_list_t list, size_t position, const void *elt)\n{\n  size_t count = list->count;\n  gl_list_node_t new_node;\n\n  if (!(position <= count))\n    /* Invalid argument.  */\n    abort ();\n\n  new_node = (struct gl_list_node_impl *) malloc (sizeof (struct gl_list_node_impl));\n  if (new_node == NULL)\n    return NULL;\n\n  ASYNCSAFE(const void *) new_node->value = elt;\n#if WITH_HASHTABLE\n  new_node->h.hashcode =\n    (list->base.hashcode_fn != NULL\n     ? list->base.hashcode_fn (new_node->value)\n     : (size_t)(uintptr_t) new_node->value);\n\n  /* Add new_node to the hash table.  */\n  if (add_to_bucket (list, new_node) < 0)\n    {\n      free (new_node);\n      return NULL;\n    }\n#endif\n\n  /* Add new_node to the list.  */\n  if (position <= (count / 2))\n    {\n      gl_list_node_t node;\n\n      node = &list->root;\n      for (; position > 0; position--)\n        node = node->next;\n      new_node->prev = node;\n      ASYNCSAFE(gl_list_node_t) new_node->next = node->next;\n      new_node->next->prev = new_node;\n      ASYNCSAFE(gl_list_node_t) node->next = new_node;\n    }\n  else\n    {\n      gl_list_node_t node;\n\n      position = count - position;\n      node = &list->root;\n      for (; position > 0; position--)\n        node = node->prev;\n      ASYNCSAFE(gl_list_node_t) new_node->next = node;\n      new_node->prev = node->prev;\n      ASYNCSAFE(gl_list_node_t) new_node->prev->next = new_node;\n      node->prev = new_node;\n    }\n  list->count++;\n\n#if WITH_HASHTABLE\n  hash_resize_after_add (list);\n#endif\n\n  return new_node;\n}",
      "lines": 63,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_linked_remove_node": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        833,
        1
      ],
      "content": "static bool\ngl_linked_remove_node (gl_list_t list, gl_list_node_t node)\n{\n  gl_list_node_t prev;\n  gl_list_node_t next;\n\n#if WITH_HASHTABLE\n  /* Remove node from the hash table.  */\n  remove_from_bucket (list, node);\n#endif\n\n  /* Remove node from the list.  */\n  prev = node->prev;\n  next = node->next;\n\n  ASYNCSAFE(gl_list_node_t) prev->next = next;\n  next->prev = prev;\n  list->count--;\n\n  if (list->base.dispose_fn != NULL)\n    list->base.dispose_fn (node->value);\n  free (node);\n  return true;\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "gl_linked_remove_at": {
      "start_point": [
        835,
        0
      ],
      "end_point": [
        881,
        1
      ],
      "content": "static bool\ngl_linked_remove_at (gl_list_t list, size_t position)\n{\n  size_t count = list->count;\n  gl_list_node_t removed_node;\n\n  if (!(position < count))\n    /* Invalid argument.  */\n    abort ();\n  /* Here we know count > 0.  */\n  if (position <= ((count - 1) / 2))\n    {\n      gl_list_node_t node;\n      gl_list_node_t after_removed;\n\n      node = &list->root;\n      for (; position > 0; position--)\n        node = node->next;\n      removed_node = node->next;\n      after_removed = node->next->next;\n      ASYNCSAFE(gl_list_node_t) node->next = after_removed;\n      after_removed->prev = node;\n    }\n  else\n    {\n      gl_list_node_t node;\n      gl_list_node_t before_removed;\n\n      position = count - 1 - position;\n      node = &list->root;\n      for (; position > 0; position--)\n        node = node->prev;\n      removed_node = node->prev;\n      before_removed = node->prev->prev;\n      node->prev = before_removed;\n      ASYNCSAFE(gl_list_node_t) before_removed->next = node;\n    }\n#if WITH_HASHTABLE\n  remove_from_bucket (list, removed_node);\n#endif\n  list->count--;\n\n  if (list->base.dispose_fn != NULL)\n    list->base.dispose_fn (removed_node->value);\n  free (removed_node);\n  return true;\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "gl_linked_remove": {
      "start_point": [
        883,
        0
      ],
      "end_point": [
        892,
        1
      ],
      "content": "static bool\ngl_linked_remove (gl_list_t list, const void *elt)\n{\n  gl_list_node_t node = gl_linked_search_from_to (list, 0, list->count, elt);\n\n  if (node != NULL)\n    return gl_linked_remove_node (list, node);\n  else\n    return false;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "gl_linked_list_free": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        912,
        1
      ],
      "content": "static void\ngl_linked_list_free (gl_list_t list)\n{\n  gl_listelement_dispose_fn dispose = list->base.dispose_fn;\n  gl_list_node_t node;\n\n  for (node = list->root.next; node != &list->root; )\n    {\n      gl_list_node_t next = node->next;\n      if (dispose != NULL)\n        dispose (node->value);\n      free (node);\n      node = next;\n    }\n#if WITH_HASHTABLE\n  free (list->table);\n#endif\n  free (list);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_linked_iterator": {
      "start_point": [
        916,
        0
      ],
      "end_point": [
        932,
        1
      ],
      "content": "static gl_list_iterator_t\ngl_linked_iterator (gl_list_t list)\n{\n  gl_list_iterator_t result;\n\n  result.vtable = list->base.vtable;\n  result.list = list;\n  result.p = list->root.next;\n  result.q = &list->root;\n#if defined GCC_LINT || defined lint\n  result.i = 0;\n  result.j = 0;\n  result.count = 0;\n#endif\n\n  return result;\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "gl_list_iterator_t"
      ]
    },
    "gl_linked_iterator_from_to": {
      "start_point": [
        934,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "static gl_list_iterator_t\ngl_linked_iterator_from_to (gl_list_t list,\n                            size_t start_index, size_t end_index)\n{\n  gl_list_iterator_t result;\n  size_t n1, n2, n3;\n\n  if (!(start_index <= end_index && end_index <= list->count))\n    /* Invalid arguments.  */\n    abort ();\n  result.vtable = list->base.vtable;\n  result.list = list;\n  n1 = start_index;\n  n2 = end_index - start_index;\n  n3 = list->count - end_index;\n  /* Find the maximum among n1, n2, n3, so as to reduce the number of\n     loop iterations to n1 + n2 + n3 - max(n1,n2,n3).  */\n  if (n1 > n2 && n1 > n3)\n    {\n      /* n1 is the maximum, use n2 and n3.  */\n      gl_list_node_t node;\n      size_t i;\n\n      node = &list->root;\n      for (i = n3; i > 0; i--)\n        node = node->prev;\n      result.q = node;\n      for (i = n2; i > 0; i--)\n        node = node->prev;\n      result.p = node;\n    }\n  else if (n2 > n3)\n    {\n      /* n2 is the maximum, use n1 and n3.  */\n      gl_list_node_t node;\n      size_t i;\n\n      node = list->root.next;\n      for (i = n1; i > 0; i--)\n        node = node->next;\n      result.p = node;\n\n      node = &list->root;\n      for (i = n3; i > 0; i--)\n        node = node->prev;\n      result.q = node;\n    }\n  else\n    {\n      /* n3 is the maximum, use n1 and n2.  */\n      gl_list_node_t node;\n      size_t i;\n\n      node = list->root.next;\n      for (i = n1; i > 0; i--)\n        node = node->next;\n      result.p = node;\n      for (i = n2; i > 0; i--)\n        node = node->next;\n      result.q = node;\n    }\n\n#if defined GCC_LINT || defined lint\n  result.i = 0;\n  result.j = 0;\n  result.count = 0;\n#endif\n\n  return result;\n}",
      "lines": 70,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "gl_list_iterator_t"
      ]
    },
    "gl_linked_iterator_next": {
      "start_point": [
        1005,
        0
      ],
      "end_point": [
        1020,
        1
      ],
      "content": "static bool\ngl_linked_iterator_next (gl_list_iterator_t *iterator,\n                         const void **eltp, gl_list_node_t *nodep)\n{\n  if (iterator->p != iterator->q)\n    {\n      gl_list_node_t node = (gl_list_node_t) iterator->p;\n      *eltp = node->value;\n      if (nodep != NULL)\n        *nodep = node;\n      iterator->p = node->next;\n      return true;\n    }\n  else\n    return false;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "gl_linked_iterator_free": {
      "start_point": [
        1022,
        0
      ],
      "end_point": [
        1025,
        1
      ],
      "content": "static void\ngl_linked_iterator_free (gl_list_iterator_t *iterator)\n{\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_linked_sortedlist_search": {
      "start_point": [
        1029,
        0
      ],
      "end_point": [
        1045,
        1
      ],
      "content": "static gl_list_node_t _GL_ATTRIBUTE_PURE\ngl_linked_sortedlist_search (gl_list_t list, gl_listelement_compar_fn compar,\n                             const void *elt)\n{\n  gl_list_node_t node;\n\n  for (node = list->root.next; node != &list->root; node = node->next)\n    {\n      int cmp = compar (node->value, elt);\n\n      if (cmp > 0)\n        break;\n      if (cmp == 0)\n        return node;\n    }\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "gl_linked_sortedlist_search_from_to": {
      "start_point": [
        1047,
        0
      ],
      "end_point": [
        1093,
        1
      ],
      "content": "static gl_list_node_t _GL_ATTRIBUTE_PURE\ngl_linked_sortedlist_search_from_to (gl_list_t list,\n                                     gl_listelement_compar_fn compar,\n                                     size_t low, size_t high,\n                                     const void *elt)\n{\n  size_t count = list->count;\n\n  if (!(low <= high && high <= list->count))\n    /* Invalid arguments.  */\n    abort ();\n\n  high -= low;\n  if (high > 0)\n    {\n      /* Here we know low < count.  */\n      size_t position = low;\n      gl_list_node_t node;\n\n      if (position <= ((count - 1) / 2))\n        {\n          node = list->root.next;\n          for (; position > 0; position--)\n            node = node->next;\n        }\n      else\n        {\n          position = count - 1 - position;\n          node = list->root.prev;\n          for (; position > 0; position--)\n            node = node->prev;\n        }\n\n      do\n        {\n          int cmp = compar (node->value, elt);\n\n          if (cmp > 0)\n            break;\n          if (cmp == 0)\n            return node;\n          node = node->next;\n        }\n      while (--high > 0);\n    }\n  return NULL;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "gl_linked_sortedlist_indexof": {
      "start_point": [
        1095,
        0
      ],
      "end_point": [
        1114,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\ngl_linked_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar,\n                              const void *elt)\n{\n  gl_list_node_t node;\n  size_t index;\n\n  for (node = list->root.next, index = 0;\n       node != &list->root;\n       node = node->next, index++)\n    {\n      int cmp = compar (node->value, elt);\n\n      if (cmp > 0)\n        break;\n      if (cmp == 0)\n        return index;\n    }\n  return (size_t)(-1);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "gl_linked_sortedlist_indexof_from_to": {
      "start_point": [
        1116,
        0
      ],
      "end_point": [
        1164,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\ngl_linked_sortedlist_indexof_from_to (gl_list_t list,\n                                      gl_listelement_compar_fn compar,\n                                      size_t low, size_t high,\n                                      const void *elt)\n{\n  size_t count = list->count;\n\n  if (!(low <= high && high <= list->count))\n    /* Invalid arguments.  */\n    abort ();\n\n  high -= low;\n  if (high > 0)\n    {\n      /* Here we know low < count.  */\n      size_t index = low;\n      size_t position = low;\n      gl_list_node_t node;\n\n      if (position <= ((count - 1) / 2))\n        {\n          node = list->root.next;\n          for (; position > 0; position--)\n            node = node->next;\n        }\n      else\n        {\n          position = count - 1 - position;\n          node = list->root.prev;\n          for (; position > 0; position--)\n            node = node->prev;\n        }\n\n      do\n        {\n          int cmp = compar (node->value, elt);\n\n          if (cmp > 0)\n            break;\n          if (cmp == 0)\n            return index;\n          node = node->next;\n          index++;\n        }\n      while (--high > 0);\n    }\n  return (size_t)(-1);\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "gl_linked_sortedlist_nx_add": {
      "start_point": [
        1166,
        0
      ],
      "end_point": [
        1176,
        1
      ],
      "content": "static gl_list_node_t\ngl_linked_sortedlist_nx_add (gl_list_t list, gl_listelement_compar_fn compar,\n                             const void *elt)\n{\n  gl_list_node_t node;\n\n  for (node = list->root.next; node != &list->root; node = node->next)\n    if (compar (node->value, elt) >= 0)\n      return gl_linked_nx_add_before (list, node, elt);\n  return gl_linked_nx_add_last (list, elt);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_linked_sortedlist_remove": {
      "start_point": [
        1178,
        0
      ],
      "end_point": [
        1194,
        1
      ],
      "content": "static bool\ngl_linked_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar,\n                             const void *elt)\n{\n  gl_list_node_t node;\n\n  for (node = list->root.next; node != &list->root; node = node->next)\n    {\n      int cmp = compar (node->value, elt);\n\n      if (cmp > 0)\n        break;\n      if (cmp == 0)\n        return gl_linked_remove_node (list, node);\n    }\n  return false;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "patch/patch-2.7.6/lib/gl_linked_list.c": {},
  "patch/patch-2.7.6/lib/gl_linked_list.h": {},
  "patch/patch-2.7.6/lib/gl_list.c": {},
  "patch/patch-2.7.6/lib/gl_list.h": {
    "gl_list_nx_create_empty": {
      "start_point": [
        554,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_t\ngl_list_nx_create_empty (gl_list_implementation_t implementation,\n                         gl_listelement_equals_fn equals_fn,\n                         gl_listelement_hashcode_fn hashcode_fn,\n                         gl_listelement_dispose_fn dispose_fn,\n                         bool allow_duplicates)\n{\n  return implementation->nx_create_empty (implementation, equals_fn,\n                                          hashcode_fn, dispose_fn,\n                                          allow_duplicates);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_t",
        "gl_list_t"
      ]
    },
    "gl_list_nx_create": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_t\ngl_list_nx_create (gl_list_implementation_t implementation,\n                   gl_listelement_equals_fn equals_fn,\n                   gl_listelement_hashcode_fn hashcode_fn,\n                   gl_listelement_dispose_fn dispose_fn,\n                   bool allow_duplicates,\n                   size_t count, const void **contents)\n{\n  return implementation->nx_create (implementation, equals_fn, hashcode_fn,\n                                    dispose_fn, allow_duplicates, count,\n                                    contents);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_t",
        "gl_list_t"
      ]
    },
    "gl_list_size": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_size (gl_list_t list)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->size (list);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_node_value": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "GL_LIST_INLINE const void *\ngl_list_node_value (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->node_value (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "const",
        "const",
        "void",
        "void",
        "*\ngl_list_node_value (gl_list_t list, gl_list_node_t node)",
        "*"
      ]
    },
    "__warn_unused_result__": [
      {
        "start_point": [
          598,
          33
        ],
        "end_point": [
          602,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->node_nx_set_value (list, node, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          629,
          58
        ],
        "end_point": [
          633,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_set_at (list, position, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          687,
          44
        ],
        "end_point": [
          691,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_first (list, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          697,
          43
        ],
        "end_point": [
          701,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_last (list, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          707,
          66
        ],
        "end_point": [
          711,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_before (list, node, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          717,
          65
        ],
        "end_point": [
          721,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_after (list, node, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          727,
          58
        ],
        "end_point": [
          731,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_at (list, position, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          821,
          77
        ],
        "end_point": [
          825,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_nx_add (list, compar, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      }
    ],
    "gl_list_next_node": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        609,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_next_node (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->next_node (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_previous_node": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_previous_node (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->previous_node (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_get_at": {
      "start_point": [
        618,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "GL_LIST_INLINE const void *\ngl_list_get_at (gl_list_t list, size_t position)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->get_at (list, position);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "const",
        "const",
        "void",
        "void",
        "*\ngl_list_get_at (gl_list_t list, size_t position)",
        "*"
      ]
    },
    "gl_list_search": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_search (gl_list_t list, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->search_from_to (list, 0, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_search_from": {
      "start_point": [
        643,
        0
      ],
      "end_point": [
        649,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_search_from (gl_list_t list, size_t start_index, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->search_from_to (list, start_index, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_search_from_to": {
      "start_point": [
        651,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_search_from_to (gl_list_t list, size_t start_index, size_t end_index,\n                        const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->search_from_to (list, start_index, end_index, elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_indexof": {
      "start_point": [
        659,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_indexof (gl_list_t list, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->indexof_from_to (list, 0, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_indexof_from": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        673,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_indexof_from (gl_list_t list, size_t start_index, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->indexof_from_to (list, start_index, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_indexof_from_to": {
      "start_point": [
        675,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_indexof_from_to (gl_list_t list, size_t start_index, size_t end_index,\n                         const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->indexof_from_to (list, start_index, end_index, elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_remove_node": {
      "start_point": [
        733,
        0
      ],
      "end_point": [
        738,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_remove_node (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->remove_node (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_remove_at": {
      "start_point": [
        740,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_remove_at (gl_list_t list, size_t position)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->remove_at (list, position);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_remove": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        752,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_remove (gl_list_t list, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->remove_elt (list, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_free": {
      "start_point": [
        754,
        0
      ],
      "end_point": [
        758,
        1
      ],
      "content": "GL_LIST_INLINE void\ngl_list_free (gl_list_t list)\n{\n  ((const struct gl_list_impl_base *) list)->vtable->list_free (list);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "void",
        "void"
      ]
    },
    "gl_list_iterator": {
      "start_point": [
        760,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_iterator_t\ngl_list_iterator (gl_list_t list)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->iterator (list);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_iterator_t",
        "gl_list_iterator_t"
      ]
    },
    "gl_list_iterator_from_to": {
      "start_point": [
        767,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_iterator_t\ngl_list_iterator_from_to (gl_list_t list, size_t start_index, size_t end_index)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->iterator_from_to (list, start_index, end_index);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_iterator_t",
        "gl_list_iterator_t"
      ]
    },
    "gl_list_iterator_next": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_iterator_next (gl_list_iterator_t *iterator,\n                       const void **eltp, gl_list_node_t *nodep)\n{\n  return iterator->vtable->iterator_next (iterator, eltp, nodep);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_iterator_free": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        785,
        1
      ],
      "content": "GL_LIST_INLINE void\ngl_list_iterator_free (gl_list_iterator_t *iterator)\n{\n  iterator->vtable->iterator_free (iterator);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "GL_LIST_INLINE",
        "void",
        "void"
      ]
    },
    "gl_sortedlist_search": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        792,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_sortedlist_search (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_search (list, compar, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_sortedlist_search_from_to": {
      "start_point": [
        794,
        0
      ],
      "end_point": [
        800,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_sortedlist_search_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_search_from_to (list, compar, start_index, end_index,\n                                      elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_sortedlist_indexof": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        807,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_indexof (list, compar, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_sortedlist_indexof_from_to": {
      "start_point": [
        809,
        0
      ],
      "end_point": [
        815,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_indexof_from_to (list, compar, start_index, end_index,\n                                       elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_sortedlist_remove": {
      "start_point": [
        827,
        0
      ],
      "end_point": [
        832,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_remove (list, compar, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    }
  },
  "patch/patch-2.7.6/lib/gl_xlist.c": {},
  "patch/patch-2.7.6/lib/gl_xlist.h": {
    "gl_list_create_empty": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "GL_XLIST_INLINE gl_list_t\ngl_list_create_empty (gl_list_implementation_t implementation,\n                      gl_listelement_equals_fn equals_fn,\n                      gl_listelement_hashcode_fn hashcode_fn,\n                      gl_listelement_dispose_fn dispose_fn,\n                      bool allow_duplicates)\n{\n  gl_list_t result =\n    gl_list_nx_create_empty (implementation, equals_fn, hashcode_fn, dispose_fn,\n                             allow_duplicates);\n  if (result == NULL)\n    xalloc_die ();\n  return result;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "GL_XLIST_INLINE",
        "gl_list_t",
        "gl_list_t"
      ]
    },
    "gl_list_create": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "GL_XLIST_INLINE gl_list_t\ngl_list_create (gl_list_implementation_t implementation,\n                gl_listelement_equals_fn equals_fn,\n                gl_listelement_hashcode_fn hashcode_fn,\n                gl_listelement_dispose_fn dispose_fn,\n                bool allow_duplicates,\n                size_t count, const void **contents)\n{\n  gl_list_t result =\n    gl_list_nx_create (implementation, equals_fn, hashcode_fn, dispose_fn,\n                       allow_duplicates, count, contents);\n  if (result == NULL)\n    xalloc_die ();\n  return result;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "GL_XLIST_INLINE",
        "gl_list_t",
        "gl_list_t"
      ]
    },
    "gl_list_node_set_value": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "GL_XLIST_INLINE void\ngl_list_node_set_value (gl_list_t list, gl_list_node_t node, const void *elt)\n{\n  int result = gl_list_node_nx_set_value (list, node, elt);\n  if (result < 0)\n    xalloc_die ();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "GL_XLIST_INLINE",
        "void",
        "void"
      ]
    },
    "gl_list_set_at": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "GL_XLIST_INLINE gl_list_node_t\ngl_list_set_at (gl_list_t list, size_t position, const void *elt)\n{\n  gl_list_node_t result = gl_list_nx_set_at (list, position, elt);\n  if (result == NULL)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "GL_XLIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_add_first": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "GL_XLIST_INLINE gl_list_node_t\ngl_list_add_first (gl_list_t list, const void *elt)\n{\n  gl_list_node_t result = gl_list_nx_add_first (list, elt);\n  if (result == NULL)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "GL_XLIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_add_last": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "GL_XLIST_INLINE gl_list_node_t\ngl_list_add_last (gl_list_t list, const void *elt)\n{\n  gl_list_node_t result = gl_list_nx_add_last (list, elt);\n  if (result == NULL)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "GL_XLIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_add_before": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "GL_XLIST_INLINE gl_list_node_t\ngl_list_add_before (gl_list_t list, gl_list_node_t node, const void *elt)\n{\n  gl_list_node_t result = gl_list_nx_add_before (list, node, elt);\n  if (result == NULL)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "GL_XLIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_add_after": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "GL_XLIST_INLINE gl_list_node_t\ngl_list_add_after (gl_list_t list, gl_list_node_t node, const void *elt)\n{\n  gl_list_node_t result = gl_list_nx_add_after (list, node, elt);\n  if (result == NULL)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "GL_XLIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_add_at": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "GL_XLIST_INLINE gl_list_node_t\ngl_list_add_at (gl_list_t list, size_t position, const void *elt)\n{\n  gl_list_node_t result = gl_list_nx_add_at (list, position, elt);\n  if (result == NULL)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "GL_XLIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_sortedlist_add": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "GL_XLIST_INLINE gl_list_node_t\ngl_sortedlist_add (gl_list_t list, gl_listelement_compar_fn compar,\n                   const void *elt)\n{\n  gl_list_node_t result = gl_sortedlist_nx_add (list, compar, elt);\n  if (result == NULL)\n    xalloc_die ();\n  return result;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "GL_XLIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/group-member.c": {
    "free_group_info": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\nfree_group_info (struct group_info const *g)\n{\n  if (g->group != g->groupbuf)\n    free (g->group);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_group_info": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nget_group_info (struct group_info *gi)\n{\n  int n_groups = getgroups (GROUPBUF_SIZE, gi->groupbuf);\n  gi->group = gi->groupbuf;\n\n  if (n_groups < 0)\n    {\n      int n_group_slots = getgroups (0, NULL);\n      if (0 <= n_group_slots\n          && ! xalloc_oversized (n_group_slots, sizeof *gi->group))\n        {\n          gi->group = malloc (n_group_slots * sizeof *gi->group);\n          if (gi->group)\n            n_groups = getgroups (n_group_slots, gi->group);\n        }\n    }\n\n  /* In case of error, the user loses.  */\n  return n_groups;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "group_member": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\ngroup_member (gid_t gid)\n{\n  int i;\n  int found;\n  struct group_info gi;\n  int n_groups = get_group_info (&gi);\n\n  /* Search through the list looking for GID. */\n  found = 0;\n  for (i = 0; i < n_groups; i++)\n    {\n      if (gid == gi.group[i])\n        {\n          found = 1;\n          break;\n        }\n    }\n\n  free_group_info (&gi);\n\n  return found;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n\n  for (i = 1; i < argc; i++)\n    {\n      gid_t gid;\n\n      gid = atoi (argv[i]);\n      printf (\"%d: %s\\n\", gid, group_member (gid) ? \"yes\" : \"no\");\n    }\n  exit (0);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/hard-locale.c": {
    "hard_locale": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "bool\nhard_locale (int category)\n{\n  bool hard = true;\n  char const *p = setlocale (category, NULL);\n\n  if (p)\n    {\n      if (2 <= GLIBC_VERSION)\n        {\n          if (strcmp (p, \"C\") == 0 || strcmp (p, \"POSIX\") == 0)\n            hard = false;\n        }\n      else\n        {\n          char *locale = strdup (p);\n          if (locale)\n            {\n              /* Temporarily set the locale to the \"C\" and \"POSIX\" locales\n                 to find their names, so that we can determine whether one\n                 or the other is the caller's locale.  */\n              if (((p = setlocale (category, \"C\"))\n                   && strcmp (p, locale) == 0)\n                  || ((p = setlocale (category, \"POSIX\"))\n                      && strcmp (p, locale) == 0))\n                hard = false;\n\n              /* Restore the caller's locale.  */\n              setlocale (category, locale);\n              free (locale);\n            }\n        }\n    }\n\n  return hard;\n}",
      "lines": 36,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "patch/patch-2.7.6/lib/hard-locale.h": {},
  "patch/patch-2.7.6/lib/hash.c": {
    "hash_get_n_buckets": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "size_t\nhash_get_n_buckets (const Hash_table *table)\n{\n  return table->n_buckets;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_buckets_used": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "size_t\nhash_get_n_buckets_used (const Hash_table *table)\n{\n  return table->n_buckets_used;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_entries": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "size_t\nhash_get_n_entries (const Hash_table *table)\n{\n  return table->n_entries;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_max_bucket_length": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "size_t\nhash_get_max_bucket_length (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t max_bucket_length = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n          size_t bucket_length = 1;\n\n          while (cursor = cursor->next, cursor)\n            bucket_length++;\n\n          if (bucket_length > max_bucket_length)\n            max_bucket_length = bucket_length;\n        }\n    }\n\n  return max_bucket_length;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "hash_table_ok": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "bool\nhash_table_ok (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t n_buckets_used = 0;\n  size_t n_entries = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n\n          /* Count bucket head.  */\n          n_buckets_used++;\n          n_entries++;\n\n          /* Count bucket overflow.  */\n          while (cursor = cursor->next, cursor)\n            n_entries++;\n        }\n    }\n\n  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)\n    return true;\n\n  return false;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "hash_print_statistics": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\nhash_print_statistics (const Hash_table *table, FILE *stream)\n{\n  size_t n_entries = hash_get_n_entries (table);\n  size_t n_buckets = hash_get_n_buckets (table);\n  size_t n_buckets_used = hash_get_n_buckets_used (table);\n  size_t max_bucket_length = hash_get_max_bucket_length (table);\n\n  fprintf (stream, \"# entries:         %lu\\n\", (unsigned long int) n_entries);\n  fprintf (stream, \"# buckets:         %lu\\n\", (unsigned long int) n_buckets);\n  fprintf (stream, \"# buckets used:    %lu (%.2f%%)\\n\",\n           (unsigned long int) n_buckets_used,\n           (100.0 * n_buckets_used) / n_buckets);\n  fprintf (stream, \"max bucket length: %lu\\n\",\n           (unsigned long int) max_bucket_length);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "safe_hasher": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static struct hash_entry *\nsafe_hasher (const Hash_table *table, const void *key)\n{\n  size_t n = table->hasher (key, table->n_buckets);\n  if (! (n < table->n_buckets))\n    abort ();\n  return table->bucket + n;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nsafe_hasher (const Hash_table *table, const void *key)",
        "*"
      ]
    },
    "hash_lookup": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "void *\nhash_lookup (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  if (bucket->data == NULL)\n    return NULL;\n\n  for (cursor = bucket; cursor; cursor = cursor->next)\n    if (entry == cursor->data || table->comparator (entry, cursor->data))\n      return cursor->data;\n\n  return NULL;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_lookup (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_first": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "void *\nhash_get_first (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n\n  if (table->n_entries == 0)\n    return NULL;\n\n  for (bucket = table->bucket; ; bucket++)\n    if (! (bucket < table->bucket_limit))\n      abort ();\n    else if (bucket->data)\n      return bucket->data;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_first (const Hash_table *table)",
        "*"
      ]
    },
    "hash_get_next": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "void *\nhash_get_next (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  /* Find next entry in the same bucket.  */\n  cursor = bucket;\n  do\n    {\n      if (cursor->data == entry && cursor->next)\n        return cursor->next->data;\n      cursor = cursor->next;\n    }\n  while (cursor != NULL);\n\n  /* Find first entry in any subsequent bucket.  */\n  while (++bucket < table->bucket_limit)\n    if (bucket->data)\n      return bucket->data;\n\n  /* None found.  */\n  return NULL;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_next (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_entries": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "size_t\nhash_get_entries (const Hash_table *table, void **buffer,\n                  size_t buffer_size)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (counter >= buffer_size)\n                return counter;\n              buffer[counter++] = cursor->data;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    },
    "hash_do_for_each": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "size_t\nhash_do_for_each (const Hash_table *table, Hash_processor processor,\n                  void *processor_data)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (! processor (cursor->data, processor_data))\n                return counter;\n              counter++;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "hash_string": [
      {
        "start_point": [
          403,
          0
        ],
        "end_point": [
          417,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n# define HASH_ONE_CHAR(Value, Byte) \\\n  ((Byte) + rotl_sz (Value, 7))\n\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = HASH_ONE_CHAR (value, ch);\n  return value % n_buckets;\n\n# undef HASH_ONE_CHAR\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "size_t"
        ]
      },
      {
        "start_point": [
          426,
          0
        ],
        "end_point": [
          435,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = (value * 31 + ch) % n_buckets;\n  return value;\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "size_t"
        ]
      }
    ],
    "_GL_ATTRIBUTE_CONST": [
      {
        "start_point": [
          442,
          0
        ],
        "end_point": [
          456,
          1
        ],
        "content": "static bool _GL_ATTRIBUTE_CONST\nis_prime (size_t candidate)\n{\n  size_t divisor = 3;\n  size_t square = divisor * divisor;\n\n  while (square < candidate && (candidate % divisor))\n    {\n      divisor++;\n      square += 4 * divisor;\n      divisor++;\n    }\n\n  return (candidate % divisor ? true : false);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          461,
          0
        ],
        "end_point": [
          475,
          1
        ],
        "content": "static size_t _GL_ATTRIBUTE_CONST\nnext_prime (size_t candidate)\n{\n  /* Skip small primes.  */\n  if (candidate < 10)\n    candidate = 10;\n\n  /* Make it definitely odd.  */\n  candidate |= 1;\n\n  while (SIZE_MAX != candidate && !is_prime (candidate))\n    candidate += 2;\n\n  return candidate;\n}",
        "lines": 15,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "size_t"
        ]
      }
    ],
    "hash_reset_tuning": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "void\nhash_reset_tuning (Hash_tuning *tuning)\n{\n  *tuning = default_tuning;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "raw_hasher": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "static size_t\nraw_hasher (const void *data, size_t n)\n{\n  /* When hashing unique pointers, it is often the case that they were\n     generated by malloc and thus have the property that the low-order\n     bits are 0.  As this tends to give poorer performance with small\n     tables, we rotate the pointer value before performing division,\n     in an attempt to improve hash quality.  */\n  size_t val = rotr_sz ((size_t) data, 3);\n  return val % n;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "raw_comparator": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "static bool\nraw_comparator (const void *a, const void *b)\n{\n  return a == b;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_tuning": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        536,
        1
      ],
      "content": "static bool\ncheck_tuning (Hash_table *table)\n{\n  const Hash_tuning *tuning = table->tuning;\n  float epsilon;\n  if (tuning == &default_tuning)\n    return true;\n\n  /* Be a bit stricter than mathematics would require, so that\n     rounding errors in size calculations do not cause allocations to\n     fail to grow or shrink as they should.  The smallest allocation\n     is 11 (due to next_prime's algorithm), so an epsilon of 0.1\n     should be good enough.  */\n  epsilon = 0.1f;\n\n  if (epsilon < tuning->growth_threshold\n      && tuning->growth_threshold < 1 - epsilon\n      && 1 + epsilon < tuning->growth_factor\n      && 0 <= tuning->shrink_threshold\n      && tuning->shrink_threshold + epsilon < tuning->shrink_factor\n      && tuning->shrink_factor <= 1\n      && tuning->shrink_threshold + epsilon < tuning->growth_threshold)\n    return true;\n\n  table->tuning = &default_tuning;\n  return false;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "compute_bucket_size": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\ncompute_bucket_size (size_t candidate, const Hash_tuning *tuning)\n{\n  if (!tuning->is_n_buckets)\n    {\n      float new_candidate = candidate / tuning->growth_threshold;\n      if (SIZE_MAX <= new_candidate)\n        return 0;\n      candidate = new_candidate;\n    }\n  candidate = next_prime (candidate);\n  if (xalloc_oversized (candidate, sizeof (struct hash_entry *)))\n    return 0;\n  return candidate;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "hash_initialize": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "Hash_table *\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)\n{\n  Hash_table *table;\n\n  if (hasher == NULL)\n    hasher = raw_hasher;\n  if (comparator == NULL)\n    comparator = raw_comparator;\n\n  table = malloc (sizeof *table);\n  if (table == NULL)\n    return NULL;\n\n  if (!tuning)\n    tuning = &default_tuning;\n  table->tuning = tuning;\n  if (!check_tuning (table))\n    {\n      /* Fail if the tuning options are invalid.  This is the only occasion\n         when the user gets some feedback about it.  Once the table is created,\n         if the user provides invalid tuning options, we silently revert to\n         using the defaults, and ignore further request to change the tuning\n         options.  */\n      goto fail;\n    }\n\n  table->n_buckets = compute_bucket_size (candidate, tuning);\n  if (!table->n_buckets)\n    goto fail;\n\n  table->bucket = calloc (table->n_buckets, sizeof *table->bucket);\n  if (table->bucket == NULL)\n    goto fail;\n  table->bucket_limit = table->bucket + table->n_buckets;\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n\n  table->hasher = hasher;\n  table->comparator = comparator;\n  table->data_freer = data_freer;\n\n  table->free_entry_list = NULL;\n#if USE_OBSTACK\n  obstack_init (&table->entry_stack);\n#endif\n  return table;\n\n fail:\n  free (table);\n  return NULL;\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "Hash_table",
        "*\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)",
        "*"
      ]
    },
    "hash_clear": {
      "start_point": [
        651,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "void\nhash_clear (Hash_table *table)\n{\n  struct hash_entry *bucket;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry *cursor;\n          struct hash_entry *next;\n\n          /* Free the bucket overflow.  */\n          for (cursor = bucket->next; cursor; cursor = next)\n            {\n              if (table->data_freer)\n                table->data_freer (cursor->data);\n              cursor->data = NULL;\n\n              next = cursor->next;\n              /* Relinking is done one entry at a time, as it is to be expected\n                 that overflows are either rare or short.  */\n              cursor->next = table->free_entry_list;\n              table->free_entry_list = cursor;\n            }\n\n          /* Free the bucket head.  */\n          if (table->data_freer)\n            table->data_freer (bucket->data);\n          bucket->data = NULL;\n          bucket->next = NULL;\n        }\n    }\n\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "hash_free": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "void\nhash_free (Hash_table *table)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n\n  /* Call the user data_freer function.  */\n  if (table->data_freer && table->n_entries)\n    {\n      for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n        {\n          if (bucket->data)\n            {\n              for (cursor = bucket; cursor; cursor = cursor->next)\n                table->data_freer (cursor->data);\n            }\n        }\n    }\n\n#if USE_OBSTACK\n\n  obstack_free (&table->entry_stack, NULL);\n\n#else\n\n  /* Free all bucket overflowed entries.  */\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      for (cursor = bucket->next; cursor; cursor = next)\n        {\n          next = cursor->next;\n          free (cursor);\n        }\n    }\n\n  /* Also reclaim the internal list of previously freed entries.  */\n  for (cursor = table->free_entry_list; cursor; cursor = next)\n    {\n      next = cursor->next;\n      free (cursor);\n    }\n\n#endif\n\n  /* Free the remainder of the hash table structure.  */\n  free (table->bucket);\n  free (table);\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "allocate_entry": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "static struct hash_entry *\nallocate_entry (Hash_table *table)\n{\n  struct hash_entry *new;\n\n  if (table->free_entry_list)\n    {\n      new = table->free_entry_list;\n      table->free_entry_list = new->next;\n    }\n  else\n    {\n#if USE_OBSTACK\n      new = obstack_alloc (&table->entry_stack, sizeof *new);\n#else\n      new = malloc (sizeof *new);\n#endif\n    }\n\n  return new;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nallocate_entry (Hash_table *table)",
        "*"
      ]
    },
    "free_entry": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "static void\nfree_entry (Hash_table *table, struct hash_entry *entry)\n{\n  entry->data = NULL;\n  entry->next = table->free_entry_list;\n  table->free_entry_list = entry;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hash_find_entry": {
      "start_point": [
        788,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "static void *\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)\n{\n  struct hash_entry *bucket = safe_hasher (table, entry);\n  struct hash_entry *cursor;\n\n  *bucket_head = bucket;\n\n  /* Test for empty bucket.  */\n  if (bucket->data == NULL)\n    return NULL;\n\n  /* See if the entry is the first in the bucket.  */\n  if (entry == bucket->data || table->comparator (entry, bucket->data))\n    {\n      void *data = bucket->data;\n\n      if (delete)\n        {\n          if (bucket->next)\n            {\n              struct hash_entry *next = bucket->next;\n\n              /* Bump the first overflow entry into the bucket head, then save\n                 the previous first overflow entry for later recycling.  */\n              *bucket = *next;\n              free_entry (table, next);\n            }\n          else\n            {\n              bucket->data = NULL;\n            }\n        }\n\n      return data;\n    }\n\n  /* Scan the bucket overflow.  */\n  for (cursor = bucket; cursor->next; cursor = cursor->next)\n    {\n      if (entry == cursor->next->data\n          || table->comparator (entry, cursor->next->data))\n        {\n          void *data = cursor->next->data;\n\n          if (delete)\n            {\n              struct hash_entry *next = cursor->next;\n\n              /* Unlink the entry to delete, then save the freed entry for later\n                 recycling.  */\n              cursor->next = next->next;\n              free_entry (table, next);\n            }\n\n          return data;\n        }\n    }\n\n  /* No entry found.  */\n  return NULL;\n}",
      "lines": 63,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)",
        "*"
      ]
    },
    "transfer_entries": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "static bool\ntransfer_entries (Hash_table *dst, Hash_table *src, bool safe)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n  for (bucket = src->bucket; bucket < src->bucket_limit; bucket++)\n    if (bucket->data)\n      {\n        void *data;\n        struct hash_entry *new_bucket;\n\n        /* Within each bucket, transfer overflow entries first and\n           then the bucket head, to minimize memory pressure.  After\n           all, the only time we might allocate is when moving the\n           bucket head, but moving overflow entries first may create\n           free entries that can be recycled by the time we finally\n           get to the bucket head.  */\n        for (cursor = bucket->next; cursor; cursor = next)\n          {\n            data = cursor->data;\n            new_bucket = safe_hasher (dst, data);\n\n            next = cursor->next;\n\n            if (new_bucket->data)\n              {\n                /* Merely relink an existing entry, when moving from a\n                   bucket overflow into a bucket overflow.  */\n                cursor->next = new_bucket->next;\n                new_bucket->next = cursor;\n              }\n            else\n              {\n                /* Free an existing entry, when moving from a bucket\n                   overflow into a bucket header.  */\n                new_bucket->data = data;\n                dst->n_buckets_used++;\n                free_entry (dst, cursor);\n              }\n          }\n        /* Now move the bucket head.  Be sure that if we fail due to\n           allocation failure that the src table is in a consistent\n           state.  */\n        data = bucket->data;\n        bucket->next = NULL;\n        if (safe)\n          continue;\n        new_bucket = safe_hasher (dst, data);\n\n        if (new_bucket->data)\n          {\n            /* Allocate or recycle an entry, when moving from a bucket\n               header into a bucket overflow.  */\n            struct hash_entry *new_entry = allocate_entry (dst);\n\n            if (new_entry == NULL)\n              return false;\n\n            new_entry->data = data;\n            new_entry->next = new_bucket->next;\n            new_bucket->next = new_entry;\n          }\n        else\n          {\n            /* Move from one bucket header to another.  */\n            new_bucket->data = data;\n            dst->n_buckets_used++;\n          }\n        bucket->data = NULL;\n        src->n_buckets_used--;\n      }\n  return true;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "hash_rehash": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        1018,
        1
      ],
      "content": "bool\nhash_rehash (Hash_table *table, size_t candidate)\n{\n  Hash_table storage;\n  Hash_table *new_table;\n  size_t new_size = compute_bucket_size (candidate, table->tuning);\n\n  if (!new_size)\n    return false;\n  if (new_size == table->n_buckets)\n    return true;\n  new_table = &storage;\n  new_table->bucket = calloc (new_size, sizeof *new_table->bucket);\n  if (new_table->bucket == NULL)\n    return false;\n  new_table->n_buckets = new_size;\n  new_table->bucket_limit = new_table->bucket + new_size;\n  new_table->n_buckets_used = 0;\n  new_table->n_entries = 0;\n  new_table->tuning = table->tuning;\n  new_table->hasher = table->hasher;\n  new_table->comparator = table->comparator;\n  new_table->data_freer = table->data_freer;\n\n  /* In order for the transfer to successfully complete, we need\n     additional overflow entries when distinct buckets in the old\n     table collide into a common bucket in the new table.  The worst\n     case possible is a hasher that gives a good spread with the old\n     size, but returns a constant with the new size; if we were to\n     guarantee table->n_buckets_used-1 free entries in advance, then\n     the transfer would be guaranteed to not allocate memory.\n     However, for large tables, a guarantee of no further allocation\n     introduces a lot of extra memory pressure, all for an unlikely\n     corner case (most rehashes reduce, rather than increase, the\n     number of overflow entries needed).  So, we instead ensure that\n     the transfer process can be reversed if we hit a memory\n     allocation failure mid-transfer.  */\n\n  /* Merely reuse the extra old space into the new table.  */\n#if USE_OBSTACK\n  new_table->entry_stack = table->entry_stack;\n#endif\n  new_table->free_entry_list = table->free_entry_list;\n\n  if (transfer_entries (new_table, table, false))\n    {\n      /* Entries transferred successfully; tie up the loose ends.  */\n      free (table->bucket);\n      table->bucket = new_table->bucket;\n      table->bucket_limit = new_table->bucket_limit;\n      table->n_buckets = new_table->n_buckets;\n      table->n_buckets_used = new_table->n_buckets_used;\n      table->free_entry_list = new_table->free_entry_list;\n      /* table->n_entries and table->entry_stack already hold their value.  */\n      return true;\n    }\n\n  /* We've allocated new_table->bucket (and possibly some entries),\n     exhausted the free list, and moved some but not all entries into\n     new_table.  We must undo the partial move before returning\n     failure.  The only way to get into this situation is if new_table\n     uses fewer buckets than the old table, so we will reclaim some\n     free entries as overflows in the new table are put back into\n     distinct buckets in the old table.\n\n     There are some pathological cases where a single pass through the\n     table requires more intermediate overflow entries than using two\n     passes.  Two passes give worse cache performance and takes\n     longer, but at this point, we're already out of memory, so slow\n     and safe is better than failure.  */\n  table->free_entry_list = new_table->free_entry_list;\n  if (! (transfer_entries (table, new_table, true)\n         && transfer_entries (table, new_table, false)))\n    abort ();\n  /* table->n_entries already holds its value.  */\n  free (new_table->bucket);\n  return false;\n}",
      "lines": 78,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "hash_insert_if_absent": {
      "start_point": [
        1036,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "int\nhash_insert_if_absent (Hash_table *table, void const *entry,\n                       void const **matched_ent)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  /* The caller cannot insert a NULL entry, since hash_lookup returns NULL\n     to indicate \"not found\", and hash_find_entry uses \"bucket->data == NULL\"\n     to indicate an empty bucket.  */\n  if (! entry)\n    abort ();\n\n  /* If there's a matching entry already in the table, return that.  */\n  if ((data = hash_find_entry (table, entry, &bucket, false)) != NULL)\n    {\n      if (matched_ent)\n        *matched_ent = data;\n      return 0;\n    }\n\n  /* If the growth threshold of the buckets in use has been reached, increase\n     the table size and rehash.  There's no point in checking the number of\n     entries:  if the hashing function is ill-conditioned, rehashing is not\n     likely to improve it.  */\n\n  if (table->n_buckets_used\n      > table->tuning->growth_threshold * table->n_buckets)\n    {\n      /* Check more fully, before starting real work.  If tuning arguments\n         became invalid, the second check will rely on proper defaults.  */\n      check_tuning (table);\n      if (table->n_buckets_used\n          > table->tuning->growth_threshold * table->n_buckets)\n        {\n          const Hash_tuning *tuning = table->tuning;\n          float candidate =\n            (tuning->is_n_buckets\n             ? (table->n_buckets * tuning->growth_factor)\n             : (table->n_buckets * tuning->growth_factor\n                * tuning->growth_threshold));\n\n          if (SIZE_MAX <= candidate)\n            return -1;\n\n          /* If the rehash fails, arrange to return NULL.  */\n          if (!hash_rehash (table, candidate))\n            return -1;\n\n          /* Update the bucket we are interested in.  */\n          if (hash_find_entry (table, entry, &bucket, false) != NULL)\n            abort ();\n        }\n    }\n\n  /* ENTRY is not matched, it should be inserted.  */\n\n  if (bucket->data)\n    {\n      struct hash_entry *new_entry = allocate_entry (table);\n\n      if (new_entry == NULL)\n        return -1;\n\n      /* Add ENTRY in the overflow of the bucket.  */\n\n      new_entry->data = (void *) entry;\n      new_entry->next = bucket->next;\n      bucket->next = new_entry;\n      table->n_entries++;\n      return 1;\n    }\n\n  /* Add ENTRY right in the bucket head.  */\n\n  bucket->data = (void *) entry;\n  table->n_entries++;\n  table->n_buckets_used++;\n\n  return 1;\n}",
      "lines": 81,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "hash_insert": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1132,
        1
      ],
      "content": "void *\nhash_insert (Hash_table *table, void const *entry)\n{\n  void const *matched_ent;\n  int err = hash_insert_if_absent (table, entry, &matched_ent);\n  return (err == -1\n          ? NULL\n          : (void *) (err == 0 ? matched_ent : entry));\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_insert (Hash_table *table, void const *entry)",
        "*"
      ]
    },
    "hash_delete": {
      "start_point": [
        1138,
        0
      ],
      "end_point": [
        1196,
        1
      ],
      "content": "void *\nhash_delete (Hash_table *table, const void *entry)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  data = hash_find_entry (table, entry, &bucket, true);\n  if (!data)\n    return NULL;\n\n  table->n_entries--;\n  if (!bucket->data)\n    {\n      table->n_buckets_used--;\n\n      /* If the shrink threshold of the buckets in use has been reached,\n         rehash into a smaller table.  */\n\n      if (table->n_buckets_used\n          < table->tuning->shrink_threshold * table->n_buckets)\n        {\n          /* Check more fully, before starting real work.  If tuning arguments\n             became invalid, the second check will rely on proper defaults.  */\n          check_tuning (table);\n          if (table->n_buckets_used\n              < table->tuning->shrink_threshold * table->n_buckets)\n            {\n              const Hash_tuning *tuning = table->tuning;\n              size_t candidate =\n                (tuning->is_n_buckets\n                 ? table->n_buckets * tuning->shrink_factor\n                 : (table->n_buckets * tuning->shrink_factor\n                    * tuning->growth_threshold));\n\n              if (!hash_rehash (table, candidate))\n                {\n                  /* Failure to allocate memory in an attempt to\n                     shrink the table is not fatal.  But since memory\n                     is low, we can at least be kind and free any\n                     spare entries, rather than keeping them tied up\n                     in the free entry list.  */\n#if ! USE_OBSTACK\n                  struct hash_entry *cursor = table->free_entry_list;\n                  struct hash_entry *next;\n                  while (cursor)\n                    {\n                      next = cursor->next;\n                      free (cursor);\n                      cursor = next;\n                    }\n                  table->free_entry_list = NULL;\n#endif\n                }\n            }\n        }\n    }\n\n  return data;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "void",
        "*\nhash_delete (Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_print": {
      "start_point": [
        1202,
        0
      ],
      "end_point": [
        1222,
        1
      ],
      "content": "void\nhash_print (const Hash_table *table)\n{\n  struct hash_entry *bucket = (struct hash_entry *) table->bucket;\n\n  for ( ; bucket < table->bucket_limit; bucket++)\n    {\n      struct hash_entry *cursor;\n\n      if (bucket)\n        printf (\"%lu:\\n\", (unsigned long int) (bucket - table->bucket));\n\n      for (cursor = bucket; cursor; cursor = cursor->next)\n        {\n          char const *s = cursor->data;\n          /* FIXME */\n          if (s)\n            printf (\"  %s\\n\", s);\n        }\n    }\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/hash.h": {},
  "patch/patch-2.7.6/lib/ignore-value.h": {},
  "patch/patch-2.7.6/lib/intprops.h": {},
  "patch/patch-2.7.6/lib/inttypes.in.h": {},
  "patch/patch-2.7.6/lib/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/lchown.c": {
    "lchown": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nlchown (const char *file, uid_t uid, gid_t gid)\n{\n# if HAVE_CHOWN\n#  if ! CHOWN_MODIFIES_SYMLINK\n  struct stat stats;\n\n  if (lstat (file, &stats) == 0 && S_ISLNK (stats.st_mode))\n    {\n      errno = EOPNOTSUPP;\n      return -1;\n    }\n#  endif\n\n  return chown (file, uid, gid);\n\n# else /* !HAVE_CHOWN */\n  errno = ENOSYS;\n  return -1;\n# endif\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "rpl_lchown": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nrpl_lchown (const char *file, uid_t uid, gid_t gid)\n{\n  bool stat_valid = false;\n  int result;\n\n# if CHOWN_CHANGE_TIME_BUG\n  struct stat st;\n\n  if (gid != (gid_t) -1 || uid != (uid_t) -1)\n    {\n      if (lstat (file, &st))\n        return -1;\n      stat_valid = true;\n      if (!S_ISLNK (st.st_mode))\n        return chown (file, uid, gid);\n    }\n# endif\n\n# if CHOWN_TRAILING_SLASH_BUG\n  if (!stat_valid)\n    {\n      size_t len = strlen (file);\n      if (len && file[len - 1] == '/')\n        return chown (file, uid, gid);\n    }\n# endif\n\n  result = lchown (file, uid, gid);\n\n# if CHOWN_CHANGE_TIME_BUG && HAVE_LCHMOD\n  if (result == 0 && stat_valid\n      && (uid == st.st_uid || uid == (uid_t) -1)\n      && (gid == st.st_gid || gid == (gid_t) -1))\n    {\n      /* No change in ownership, but at least one argument was not -1,\n         so we are required to update ctime.  Since lchown succeeded,\n         we assume that lchmod will do likewise.  But if the system\n         lacks lchmod and lutimes, we are out of luck.  Oh well.  */\n      result = lchmod (file, st.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO\n                                           | S_ISUID | S_ISGID | S_ISVTX));\n    }\n# endif\n\n  return result;\n}",
      "lines": 46,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/limits.in.h": {},
  "patch/patch-2.7.6/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      char *malloc_dir = NULL;\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate2 (LIBDIR, &malloc_dir);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      free (malloc_dir);\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <https://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 262,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/localcharset.h": {},
  "patch/patch-2.7.6/lib/localtime-buffer.c": {
    "rpl_localtime": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/localtime-buffer.h": {},
  "patch/patch-2.7.6/lib/lstat.c": {
    "orig_lstat": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  int result = orig_lstat (file, sbuf);\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  if (result == 0)\n    {\n      if (S_ISDIR (sbuf->st_mode) || file[strlen (file) - 1] != '/')\n        result = stat_time_normalize (result, sbuf);\n      else\n        {\n          /* At this point, a trailing slash is permitted only on\n             symlink-to-dir; but it should have found information on the\n             directory, not the symlink.  Call 'stat' to get info about the\n             link's referent.  Our replacement stat guarantees valid results,\n             even if the symlink is not pointing to a directory.  */\n          if (!S_ISLNK (sbuf->st_mode))\n            {\n              errno = ENOTDIR;\n              return -1;\n            }\n          result = stat (file, sbuf);\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/malloca.c": {
    "mmalloca": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, used to determine the address to pass to freea(),\n     and room for the alignment \u00e2\u0089\u00a1 sa_alignment_max mod 2*sa_alignment_max.  */\n  size_t nplus = n + sizeof (small_t) + 2 * sa_alignment_max - 1;\n\n  if (nplus >= n)\n    {\n      char *mem = (char *) malloc (nplus);\n\n      if (mem != NULL)\n        {\n          char *p =\n            (char *)((((uintptr_t)mem + sizeof (small_t) + sa_alignment_max - 1)\n                      & ~(uintptr_t)(2 * sa_alignment_max - 1))\n                     + sa_alignment_max);\n          /* Here p >= mem + sizeof (small_t),\n             and p <= mem + sizeof (small_t) + 2 * sa_alignment_max - 1\n             hence p + n <= mem + nplus.\n             So, the memory range [p, p+n) lies in the allocated memory range\n             [mem, mem + nplus).  */\n          ((small_t *) p)[-1] = p - mem;\n          /* p \u00e2\u0089\u00a1 sa_alignment_max mod 2*sa_alignment_max.  */\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 38,
      "depth": 21,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "freea": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nfreea (void *p)\n{\n  /* Check argument.  */\n  if ((uintptr_t) p & (sa_alignment_max - 1))\n    {\n      /* p was not the result of a malloca() call.  Invalid argument.  */\n      abort ();\n    }\n  /* Determine whether p was a non-NULL pointer returned by mmalloca().  */\n  if ((uintptr_t) p & sa_alignment_max)\n    {\n      void *mem = (char *) p - ((small_t *) p)[-1];\n      free (mem);\n    }\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/malloca.h": {},
  "patch/patch-2.7.6/lib/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        FALLTHROUGH;\n      case 2:\n        buf[1] = pstate[2];\n        FALLTHROUGH;\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <https://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  size_t ret;\n  wchar_t wc;\n\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_EMPTY_INPUT_BUG\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n  if (! pwc)\n    pwc = &wc;\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n  ret = mbrtowc (pwc, s, n, ps);\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  if (ret < (size_t) -2 && !*pwc)\n    return 0;\n# endif\n\n# if C_LOCALE_MAYBE_EILSEQ\n  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))\n    {\n      unsigned char uc = *s;\n      *pwc = uc;\n      return 1;\n    }\n# endif\n\n  return ret;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          43,
          0
        ],
        "end_point": [
          49,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          70,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n# if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__\n  /* Native Windows.  */\n#  ifdef __MINGW32__\n  /* On mingw, 'mbstate_t' is defined as 'int'.  */\n  return ps == NULL || *ps == 0;\n#  else\n  /* MSVC defines 'mbstate_t' as an 8-byte struct; the first 4-bytes matter.  */\n  return ps == NULL || *(const unsigned int *)ps == 0;\n#  endif\n# else\n  /* Minix, HP-UX 11.00, Solaris 2.6, Interix, ...  */\n  /* Maybe this definition works, maybe not...  */\n  return ps == NULL || *(const char *)ps == 0;\n# endif\n}",
        "lines": 18,
        "depth": 13,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "patch/patch-2.7.6/lib/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/mempcpy.c": {
    "mempcpy": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void *\nmempcpy (void *dest, const void *src, size_t n)\n{\n  return (char *) memcpy (dest, src, n) + n;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nmempcpy (void *dest, const void *src, size_t n)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/memrchr.c": {
    "__memrchr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void *\n__memrchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the last few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s + n;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n)\n    if (*--char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *--longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        {\n          longword_ptr++;\n          break;\n        }\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  while (n-- > 0)\n    {\n      if (*--char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memrchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/minmax.h": {},
  "patch/patch-2.7.6/lib/mkdir.c": {
    "rpl_mkdir": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\nrpl_mkdir (char const *dir, mode_t mode maybe_unused)\n{\n  int ret_val;\n  char *tmp_dir;\n  size_t len = strlen (dir);\n\n  if (len && dir[len - 1] == '/')\n    {\n      tmp_dir = strdup (dir);\n      if (!tmp_dir)\n        {\n          /* Rather than rely on strdup-posix, we set errno ourselves.  */\n          errno = ENOMEM;\n          return -1;\n        }\n      strip_trailing_slashes (tmp_dir);\n    }\n  else\n    {\n      tmp_dir = (char *) dir;\n    }\n#if FUNC_MKDIR_DOT_BUG\n  /* Additionally, cygwin 1.5 mistakenly creates a directory \"d/./\".  */\n  {\n    char *last = last_component (tmp_dir);\n    if (*last == '.' && (last[1] == '\\0'\n                         || (last[1] == '.' && last[2] == '\\0')))\n      {\n        struct stat st;\n        if (stat (tmp_dir, &st) == 0)\n          errno = EEXIST;\n        return -1;\n      }\n  }\n#endif /* FUNC_MKDIR_DOT_BUG */\n\n  ret_val = mkdir (tmp_dir, mode);\n\n  if (tmp_dir != dir)\n    free (tmp_dir);\n\n  return ret_val;\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/mkdirat.c": {},
  "patch/patch-2.7.6/lib/mktime-internal.h": {},
  "patch/patch-2.7.6/lib/mktime.c": {
    "shr": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static long_int\nshr (long_int a, int b)\n{\n  long_int one = 1;\n  return (-one >> 1 == -1\n\t  ? a >> b\n\t  : a / (one << b) - (a % (one << b) < 0));\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "long_int"
      ]
    },
    "leapyear": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static bool\nleapyear (long_int year)\n{\n  /* Don't add YEAR to TM_YEAR_BASE, as that might overflow.\n     Also, work even if YEAR is negative.  */\n  return\n    ((year & 3) == 0\n     && (year % 100 != 0\n\t || ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));\n}",
      "lines": 10,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "isdst_differ": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "static bool\nisdst_differ (int a, int b)\n{\n  return (!a != !b) && (0 <= a) && (0 <= b);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "ydhms_diff": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static long_int\nydhms_diff (long_int year1, long_int yday1, int hour1, int min1, int sec1,\n\t    int year0, int yday0, int hour0, int min0, int sec0)\n{\n  verify (-1 / 2 == 0);\n\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid integer overflow here.  */\n  int a4 = shr (year1, 2) + shr (TM_YEAR_BASE, 2) - ! (year1 & 3);\n  int b4 = shr (year0, 2) + shr (TM_YEAR_BASE, 2) - ! (year0 & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = shr (a100, 2);\n  int b400 = shr (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n\n  /* Compute the desired time without overflowing.  */\n  long_int years = year1 - year0;\n  long_int days = 365 * years + yday1 - yday0 + intervening_leap_days;\n  long_int hours = 24 * days + hour1 - hour0;\n  long_int minutes = 60 * hours + min1 - min0;\n  long_int seconds = 60 * minutes + sec1 - sec0;\n  return seconds;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long_int"
      ]
    },
    "long_int_avg": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static long_int\nlong_int_avg (long_int a, long_int b)\n{\n  return shr (a, 1) + shr (b, 1) + ((a | b) & 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long_int"
      ]
    },
    "guess_time_tm": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "static long_int\nguess_time_tm (long_int year, long_int yday, int hour, int min, int sec,\n\t       long_int t, const struct tm *tp)\n{\n  if (tp)\n    {\n      long_int result;\n      long_int d = ydhms_diff (year, yday, hour, min, sec,\n\t\t\t       tp->tm_year, tp->tm_yday,\n\t\t\t       tp->tm_hour, tp->tm_min, tp->tm_sec);\n      if (! INT_ADD_WRAPV (t, d, &result))\n\treturn result;\n    }\n\n  /* Overflow occurred one way or another.  Return the nearest result\n     that is actually in range, except don't report a zero difference\n     if the actual difference is nonzero, as that would cause a false\n     match; and don't oscillate between two values, as that would\n     confuse the spring-forward gap detector.  */\n  return (t < long_int_avg (mktime_min, mktime_max)\n\t  ? (t <= mktime_min + 1 ? t + 1 : mktime_min)\n\t  : (mktime_max - 1 <= t ? t - 1 : mktime_max));\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long_int"
      ]
    },
    "convert_time": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static struct tm *\nconvert_time (struct tm *(*convert) (const time_t *, struct tm *),\n\t      long_int t, struct tm *tm)\n{\n  time_t x = t;\n  return convert (&x, tm);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nconvert_time (struct tm *(*convert) (const time_t *, struct tm *),\n\t      long_int t, struct tm *tm)",
        "*"
      ]
    },
    "ranged_convert": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "static struct tm *\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\tlong_int *t, struct tm *tp)\n{\n  struct tm *r;\n  if (*t < mktime_min)\n    *t = mktime_min;\n  else if (mktime_max < *t)\n    *t = mktime_max;\n  r = convert_time (convert, *t, tp);\n\n  if (!r && *t)\n    {\n      long_int bad = *t;\n      long_int ok = 0;\n\n      /* BAD is a known unconvertible value, and OK is a known good one.\n\t Use binary search to narrow the range between BAD and OK until\n\t they differ by 1.  */\n      while (true)\n\t{\n\t  long_int mid = long_int_avg (ok, bad);\n\t  if (mid != ok && mid != bad)\n\t    break;\n\t  r = convert_time (convert, mid, tp);\n\t  if (r)\n\t    ok = mid;\n\t  else\n\t    bad = mid;\n\t}\n\n      if (!r && ok)\n\t{\n\t  /* The last conversion attempt failed;\n\t     revert to the most recent successful attempt.  */\n\t  r = convert_time (convert, ok, tp);\n\t}\n    }\n\n  return r;\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\tlong_int *t, struct tm *tp)",
        "*"
      ]
    },
    "__mktime_internal": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "time_t\n__mktime_internal (struct tm *tp,\n\t\t   struct tm *(*convert) (const time_t *, struct tm *),\n\t\t   mktime_offset_t *offset)\n{\n  long_int t, gt, t0, t1, t2, dt;\n  struct tm tm;\n\n  /* The maximum number of probes (calls to CONVERT) should be enough\n     to handle any combinations of time zone rule changes, solar time,\n     leap seconds, and oscillations around a spring-forward gap.\n     POSIX.1 prohibits leap seconds, but some hosts have them anyway.  */\n  int remaining_probes = 6;\n\n  /* Time requested.  Copy it in case CONVERT modifies *TP; this can\n     occur if TP is localtime's returned value and CONVERT is localtime.  */\n  int sec = tp->tm_sec;\n  int min = tp->tm_min;\n  int hour = tp->tm_hour;\n  int mday = tp->tm_mday;\n  int mon = tp->tm_mon;\n  int year_requested = tp->tm_year;\n  int isdst = tp->tm_isdst;\n\n  /* 1 if the previous probe was DST.  */\n  int dst2;\n\n  /* Ensure that mon is in range, and set year accordingly.  */\n  int mon_remainder = mon % 12;\n  int negative_mon_remainder = mon_remainder < 0;\n  int mon_years = mon / 12 - negative_mon_remainder;\n  long_int lyear_requested = year_requested;\n  long_int year = lyear_requested + mon_years;\n\n  /* The other values need not be in range:\n     the remaining code handles overflows correctly.  */\n\n  /* Calculate day of year from year, month, and day of month.\n     The result need not be in range.  */\n  int mon_yday = ((__mon_yday[leapyear (year)]\n\t\t   [mon_remainder + 12 * negative_mon_remainder])\n\t\t  - 1);\n  long_int lmday = mday;\n  long_int yday = mon_yday + lmday;\n\n  int negative_offset_guess;\n\n  int sec_requested = sec;\n\n  if (LEAP_SECONDS_POSSIBLE)\n    {\n      /* Handle out-of-range seconds specially,\n\t since ydhms_tm_diff assumes every minute has 60 seconds.  */\n      if (sec < 0)\n\tsec = 0;\n      if (59 < sec)\n\tsec = 59;\n    }\n\n  /* Invert CONVERT by probing.  First assume the same offset as last\n     time.  */\n\n  INT_SUBTRACT_WRAPV (0, *offset, &negative_offset_guess);\n  t0 = ydhms_diff (year, yday, hour, min, sec,\n\t\t   EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0, negative_offset_guess);\n\n  /* Repeatedly use the error to improve the guess.  */\n\n  for (t = t1 = t2 = t0, dst2 = 0;\n       (gt = guess_time_tm (year, yday, hour, min, sec, t,\n\t\t\t    ranged_convert (convert, &t, &tm)),\n\tt != gt);\n       t1 = t2, t2 = t, t = gt, dst2 = tm.tm_isdst != 0)\n    if (t == t1 && t != t2\n\t&& (tm.tm_isdst < 0\n\t    || (isdst < 0\n\t\t? dst2 <= (tm.tm_isdst != 0)\n\t\t: (isdst != 0) != (tm.tm_isdst != 0))))\n      /* We can't possibly find a match, as we are oscillating\n\t between two values.  The requested time probably falls\n\t within a spring-forward gap of size GT - T.  Follow the common\n\t practice in this case, which is to return a time that is GT - T\n\t away from the requested time, preferring a time whose\n\t tm_isdst differs from the requested value.  (If no tm_isdst\n\t was requested and only one of the two values has a nonzero\n\t tm_isdst, prefer that value.)  In practice, this is more\n\t useful than returning -1.  */\n      goto offset_found;\n    else if (--remaining_probes == 0)\n      return -1;\n\n  /* We have a match.  Check whether tm.tm_isdst has the requested\n     value, if any.  */\n  if (isdst_differ (isdst, tm.tm_isdst))\n    {\n      /* tm.tm_isdst has the wrong value.  Look for a neighboring\n\t time with the right value, and use its UTC offset.\n\n\t Heuristic: probe the adjacent timestamps in both directions,\n\t looking for the desired isdst.  This should work for all real\n\t time zone histories in the tz database.  */\n\n      /* Distance between probes when looking for a DST boundary.  In\n\t tzdata2003a, the shortest period of DST is 601200 seconds\n\t (e.g., America/Recife starting 2000-10-08 01:00), and the\n\t shortest period of non-DST surrounded by DST is 694800\n\t seconds (Africa/Tunis starting 1943-04-17 01:00).  Use the\n\t minimum of these two values, so we don't miss these short\n\t periods when probing.  */\n      int stride = 601200;\n\n      /* The longest period of DST in tzdata2003a is 536454000 seconds\n\t (e.g., America/Jujuy starting 1946-10-01 01:00).  The longest\n\t period of non-DST is much longer, but it makes no real sense\n\t to search for more than a year of non-DST, so use the DST\n\t max.  */\n      int duration_max = 536454000;\n\n      /* Search in both directions, so the maximum distance is half\n\t the duration; add the stride to avoid off-by-1 problems.  */\n      int delta_bound = duration_max / 2 + stride;\n\n      int delta, direction;\n\n      for (delta = stride; delta < delta_bound; delta += stride)\n\tfor (direction = -1; direction <= 1; direction += 2)\n\t  {\n\t    long_int ot;\n\t    if (! INT_ADD_WRAPV (t, delta * direction, &ot))\n\t      {\n\t\tstruct tm otm;\n\t\tranged_convert (convert, &ot, &otm);\n\t\tif (! isdst_differ (isdst, otm.tm_isdst))\n\t\t  {\n\t\t    /* We found the desired tm_isdst.\n\t\t       Extrapolate back to the desired time.  */\n\t\t    t = guess_time_tm (year, yday, hour, min, sec, ot, &otm);\n\t\t    ranged_convert (convert, &t, &tm);\n\t\t    goto offset_found;\n\t\t  }\n\t      }\n\t  }\n    }\n\n offset_found:\n  /* Set *OFFSET to the low-order bits of T - T0 - NEGATIVE_OFFSET_GUESS.\n     This is just a heuristic to speed up the next mktime call, and\n     correctness is unaffected if integer overflow occurs here.  */\n  INT_SUBTRACT_WRAPV (t, t0, &dt);\n  INT_SUBTRACT_WRAPV (dt, negative_offset_guess, offset);\n\n  if (LEAP_SECONDS_POSSIBLE && sec_requested != tm.tm_sec)\n    {\n      /* Adjust time to reflect the tm_sec requested, not the normalized value.\n\t Also, repair any damage from a false match due to a leap second.  */\n      long_int sec_adjustment = sec == 0 && tm.tm_sec == 60;\n      sec_adjustment -= sec;\n      sec_adjustment += sec_requested;\n      if (INT_ADD_WRAPV (t, sec_adjustment, &t)\n\t  || ! (mktime_min <= t && t <= mktime_max)\n\t  || ! convert_time (convert, t, &tm))\n\treturn -1;\n    }\n\n  *tp = tm;\n  return t;\n}",
      "lines": 167,
      "depth": 17,
      "decorators": [
        "time_t"
      ]
    },
    "mktime": {
      "start_point": [
        489,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "time_t\nmktime (struct tm *tp)\n{\n# if NEED_MKTIME_WINDOWS\n  /* Rectify the value of the environment variable TZ.\n     There are four possible kinds of such values:\n       - Traditional US time zone names, e.g. \"PST8PDT\".  Syntax: see\n         <https://msdn.microsoft.com/en-us/library/90s5c885.aspx>\n       - Time zone names based on geography, that contain one or more\n         slashes, e.g. \"Europe/Moscow\".\n       - Time zone names based on geography, without slashes, e.g.\n         \"Singapore\".\n       - Time zone names that contain explicit DST rules.  Syntax: see\n         <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08_03>\n     The Microsoft CRT understands only the first kind.  It produces incorrect\n     results if the value of TZ is of the other kinds.\n     But in a Cygwin environment, /etc/profile.d/tzset.sh sets TZ to a value\n     of the second kind for most geographies, or of the first kind in a few\n     other geographies.  If it is of the second kind, neutralize it.  For the\n     Microsoft CRT, an absent or empty TZ means the time zone that the user\n     has set in the Windows Control Panel.\n     If the value of TZ is of the third or fourth kind -- Cygwin programs\n     understand these syntaxes as well --, it does not matter whether we\n     neutralize it or not, since these values occur only when a Cygwin user\n     has set TZ explicitly; this case is 1. rare and 2. under the user's\n     responsibility.  */\n  const char *tz = getenv (\"TZ\");\n  if (tz != NULL && strchr (tz, '/') != NULL)\n    _putenv (\"TZ=\");\n# endif\n\n# if NEED_MKTIME_WORKING || DEBUG_MKTIME\n#  ifdef _LIBC\n  /* POSIX.1 8.1.1 requires that whenever mktime() is called, the\n     time zone names contained in the external variable 'tzname' shall\n     be set as if the tzset() function had been called.  */\n  __tzset ();\n#  elif HAVE_TZSET\n  tzset ();\n#  endif\n\n  return __mktime_internal (tp, __localtime_r, &localtime_offset);\n# else\n#  undef mktime\n  return mktime (tp);\n# endif\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "time_t"
      ]
    },
    "not_equal_tm": {
      "start_point": [
        550,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "static int\nnot_equal_tm (const struct tm *a, const struct tm *b)\n{\n  return ((a->tm_sec ^ b->tm_sec)\n\t  | (a->tm_min ^ b->tm_min)\n\t  | (a->tm_hour ^ b->tm_hour)\n\t  | (a->tm_mday ^ b->tm_mday)\n\t  | (a->tm_mon ^ b->tm_mon)\n\t  | (a->tm_year ^ b->tm_year)\n\t  | (a->tm_yday ^ b->tm_yday)\n\t  | isdst_differ (a->tm_isdst, b->tm_isdst));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_tm": {
      "start_point": [
        563,
        0
      ],
      "end_point": [
        573,
        1
      ],
      "content": "static void\nprint_tm (const struct tm *tp)\n{\n  if (tp)\n    printf (\"%04d-%02d-%02d %02d:%02d:%02d yday %03d wday %d isdst %d\",\n\t    tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,\n\t    tp->tm_hour, tp->tm_min, tp->tm_sec,\n\t    tp->tm_yday, tp->tm_wday, tp->tm_isdst);\n  else\n    printf (\"0\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_result": {
      "start_point": [
        575,
        0
      ],
      "end_point": [
        589,
        1
      ],
      "content": "static int\ncheck_result (time_t tk, struct tm tmk, time_t tl, const struct tm *lt)\n{\n  if (tk != tl || !lt || not_equal_tm (&tmk, lt))\n    {\n      printf (\"mktime (\");\n      print_tm (lt);\n      printf (\")\\nyields (\");\n      print_tm (&tmk);\n      printf (\") == %ld, should be %ld\\n\", (long int) tk, (long int) tl);\n      return 1;\n    }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        591,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int status = 0;\n  struct tm tm, tmk, tml;\n  struct tm *lt;\n  time_t tk, tl, tl1;\n  char trailer;\n\n  /* Sanity check, plus call tzset.  */\n  tl = 0;\n  if (! localtime (&tl))\n    {\n      printf (\"localtime (0) fails\\n\");\n      status = 1;\n    }\n\n  if ((argc == 3 || argc == 4)\n      && (sscanf (argv[1], \"%d-%d-%d%c\",\n\t\t  &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)\n\t  == 3)\n      && (sscanf (argv[2], \"%d:%d:%d%c\",\n\t\t  &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)\n\t  == 3))\n    {\n      tm.tm_year -= TM_YEAR_BASE;\n      tm.tm_mon--;\n      tm.tm_isdst = argc == 3 ? -1 : atoi (argv[3]);\n      tmk = tm;\n      tl = mktime (&tmk);\n      lt = localtime_r (&tl, &tml);\n      printf (\"mktime returns %ld == \", (long int) tl);\n      print_tm (&tmk);\n      printf (\"\\n\");\n      status = check_result (tl, tmk, tl, lt);\n    }\n  else if (argc == 4 || (argc == 5 && strcmp (argv[4], \"-\") == 0))\n    {\n      time_t from = atol (argv[1]);\n      time_t by = atol (argv[2]);\n      time_t to = atol (argv[3]);\n\n      if (argc == 4)\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    lt = localtime_r (&tl, &tml);\n\t    if (lt)\n\t      {\n\t\ttmk = tml;\n\t\ttk = mktime (&tmk);\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime_r (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n      else\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    /* Null benchmark.  */\n\t    lt = localtime_r (&tl, &tml);\n\t    if (lt)\n\t      {\n\t\ttmk = tml;\n\t\ttk = tl;\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime_r (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n    }\n  else\n    printf (\"Usage:\\\n\\t%s YYYY-MM-DD HH:MM:SS [ISDST] # Test given time.\\n\\\n\\t%s FROM BY TO # Test values FROM, FROM+BY, ..., TO.\\n\\\n\\t%s FROM BY TO - # Do not test those values (for benchmark).\\n\",\n\t    argv[0], argv[0], argv[0]);\n\n  return status;\n}",
      "lines": 91,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/msvc-inval.h": {},
  "patch/patch-2.7.6/lib/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/msvc-nothrow.h": {},
  "patch/patch-2.7.6/lib/nstrftime.c": {
    "fwrite_lowcase": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "static void\nfwrite_lowcase (FILE *fp, const CHAR_T *src, size_t len)\n{\n  while (len-- > 0)\n    {\n      fputc (TOLOWER ((UCHAR_T) *src, loc), fp);\n      ++src;\n    }\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fwrite_uppcase": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static void\nfwrite_uppcase (FILE *fp, const CHAR_T *src, size_t len)\n{\n  while (len-- > 0)\n    {\n      fputc (TOUPPER ((UCHAR_T) *src, loc), fp);\n      ++src;\n    }\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "memcpy_lowcase": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "static CHAR_T *\nmemcpy_lowcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)\n{\n  while (len-- > 0)\n    dest[len] = TOLOWER ((UCHAR_T) src[len], loc);\n  return dest;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "CHAR_T",
        "*\nmemcpy_lowcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)",
        "*"
      ]
    },
    "memcpy_uppcase": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "static CHAR_T *\nmemcpy_uppcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)\n{\n  while (len-- > 0)\n    dest[len] = TOUPPER ((UCHAR_T) src[len], loc);\n  return dest;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "CHAR_T",
        "*\nmemcpy_uppcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)",
        "*"
      ]
    },
    "tm_diff": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "static int\ntm_diff (const struct tm *a, const struct tm *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations,\n     but it's OK to assume that A and B are close to each other.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  int years = a->tm_year - b->tm_year;\n  int days = (365 * years + intervening_leap_days\n              + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso_week_days": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "static int\niso_week_days (int yday, int wday)\n{\n  /* Add enough to the first operand of % to make it nonnegative.  */\n  int big_enough_multiple_of_7 = (-YDAY_MINIMUM / 7 + 2) * 7;\n  return (yday\n          - (yday - wday + ISO_WEEK1_WDAY + big_enough_multiple_of_7) % 7\n          + ISO_WEEK1_WDAY - ISO_WEEK_START_WDAY);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "my_strftime": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "size_t\nmy_strftime (STREAM_OR_CHAR_T *s, STRFTIME_ARG (size_t maxsize)\n             const CHAR_T *format,\n             const struct tm *tp extra_args_spec LOCALE_PARAM)\n{\n  bool tzset_called = false;\n  return __strftime_internal (s, STRFTIME_ARG (maxsize) format, tp,\n                              false, &tzset_called extra_args LOCALE_ARG);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "__strftime_internal": {
      "start_point": [
        445,
        0
      ],
      "end_point": [
        1519,
        1
      ],
      "content": "static size_t\n__strftime_internal (STREAM_OR_CHAR_T *s, STRFTIME_ARG (size_t maxsize)\n                     const CHAR_T *format,\n                     const struct tm *tp, bool upcase, bool *tzset_called\n                     extra_args_spec LOCALE_PARAM)\n{\n#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL\n  struct __locale_data *const current = loc->__locales[LC_TIME];\n#endif\n#if FPRINTFTIME\n  size_t maxsize = (size_t) -1;\n#endif\n\n  int hour12 = tp->tm_hour;\n#ifdef _NL_CURRENT\n  /* We cannot make the following values variables since we must delay\n     the evaluation of these values until really needed since some\n     expressions might not be valid in every situation.  The 'struct tm'\n     might be generated by a strptime() call that initialized\n     only a few elements.  Dereference the pointers only if the format\n     requires this.  Then it is ok to fail if the pointers are invalid.  */\n# define a_wkday \\\n  ((const CHAR_T *) (tp->tm_wday < 0 || tp->tm_wday > 6                      \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday)))\n# define f_wkday \\\n  ((const CHAR_T *) (tp->tm_wday < 0 || tp->tm_wday > 6                      \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday)))\n# define a_month \\\n  ((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon)))\n# define f_month \\\n  ((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon)))\n# define a_altmonth \\\n  ((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(ABALTMON_1) + tp->tm_mon)))\n# define f_altmonth \\\n  ((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(ALTMON_1) + tp->tm_mon)))\n# define ampm \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11                    \\\n                                 ? NLW(PM_STR) : NLW(AM_STR)))\n\n# define aw_len STRLEN (a_wkday)\n# define am_len STRLEN (a_month)\n# define aam_len STRLEN (a_altmonth)\n# define ap_len STRLEN (ampm)\n#endif\n#if HAVE_TZNAME\n  char **tzname_vec = tzname;\n#endif\n  const char *zone;\n  size_t i = 0;\n  STREAM_OR_CHAR_T *p = s;\n  const CHAR_T *f;\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n  const char *format_end = NULL;\n#endif\n\n#if ! defined _LIBC && ! HAVE_RUN_TZSET_TEST\n  /* Solaris 2.5.x and 2.6 tzset sometimes modify the storage returned\n     by localtime.  On such systems, we must either use the tzset and\n     localtime wrappers to work around the bug (which sets\n     HAVE_RUN_TZSET_TEST) or make a copy of the structure.  */\n  struct tm copy = *tp;\n  tp = &copy;\n#endif\n\n  zone = NULL;\n#if HAVE_TM_ZONE\n  /* The POSIX test suite assumes that setting\n     the environment variable TZ to a new value before calling strftime()\n     will influence the result (the %Z format) even if the information in\n     TP is computed with a totally different time zone.\n     This is bogus: though POSIX allows bad behavior like this,\n     POSIX does not require it.  Do the right thing instead.  */\n  zone = (const char *) tp->tm_zone;\n#endif\n#if HAVE_TZNAME\n  if (!tz)\n    {\n      if (! (zone && *zone))\n        zone = \"GMT\";\n    }\n  else\n    {\n# if !HAVE_TM_ZONE\n      /* Infer the zone name from *TZ instead of from TZNAME.  */\n      tzname_vec = tz->tzname_copy;\n# endif\n    }\n  /* The tzset() call might have changed the value.  */\n  if (!(zone && *zone) && tp->tm_isdst >= 0)\n    {\n      /* POSIX.1 requires that local time zone information be used as\n         though strftime called tzset.  */\n# if HAVE_TZSET\n      if (!*tzset_called)\n        {\n          tzset ();\n          *tzset_called = true;\n        }\n# endif\n      zone = tzname_vec[tp->tm_isdst != 0];\n    }\n#endif\n  if (! zone)\n    zone = \"\";\n\n  if (hour12 > 12)\n    hour12 -= 12;\n  else\n    if (hour12 == 0)\n      hour12 = 12;\n\n  for (f = format; *f != '\\0'; ++f)\n    {\n      int pad = 0;              /* Padding for number ('-', '_', or 0).  */\n      int modifier;             /* Field modifier ('E', 'O', or 0).  */\n      int digits = 0;           /* Max digits for numeric format.  */\n      int number_value;         /* Numeric value to be printed.  */\n      unsigned int u_number_value; /* (unsigned int) number_value.  */\n      bool negative_number;     /* The number is negative.  */\n      bool always_output_a_sign; /* +/- should always be output.  */\n      int tz_colon_mask;        /* Bitmask of where ':' should appear.  */\n      const CHAR_T *subfmt;\n      CHAR_T sign_char;\n      CHAR_T *bufp;\n      CHAR_T buf[1\n                 + 2 /* for the two colons in a %::z or %:::z time zone */\n                 + (sizeof (int) < sizeof (time_t)\n                    ? INT_STRLEN_BOUND (time_t)\n                    : INT_STRLEN_BOUND (int))];\n      int width = -1;\n      bool to_lowcase = false;\n      bool to_uppcase = upcase;\n      size_t colons;\n      bool change_case = false;\n      int format_char;\n\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n      switch (*f)\n        {\n        case L_('%'):\n          break;\n\n        case L_('\\b'): case L_('\\t'): case L_('\\n'):\n        case L_('\\v'): case L_('\\f'): case L_('\\r'):\n        case L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n        case L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n        case L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n        case L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n        case L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n        case L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n        case L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n        case L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n        case L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n        case L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n        case L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n        case L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n        case L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n        case L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n        case L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n        case L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n        case L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n        case L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n        case L_('~'):\n          /* The C Standard requires these 98 characters (plus '%') to\n             be in the basic execution character set.  None of these\n             characters can start a multibyte sequence, so they need\n             not be analyzed further.  */\n          add1 (*f);\n          continue;\n\n        default:\n          /* Copy this multibyte sequence until we reach its end, find\n             an error, or come back to the initial shift state.  */\n          {\n            mbstate_t mbstate = mbstate_zero;\n            size_t len = 0;\n            size_t fsize;\n\n            if (! format_end)\n              format_end = f + strlen (f) + 1;\n            fsize = format_end - f;\n\n            do\n              {\n                size_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n                if (bytes == 0)\n                  break;\n\n                if (bytes == (size_t) -2)\n                  {\n                    len += strlen (f + len);\n                    break;\n                  }\n\n                if (bytes == (size_t) -1)\n                  {\n                    len++;\n                    break;\n                  }\n\n                len += bytes;\n              }\n            while (! mbsinit (&mbstate));\n\n            cpy (len, f);\n            f += len - 1;\n            continue;\n          }\n        }\n\n#else /* ! DO_MULTIBYTE */\n\n      /* Either multibyte encodings are not supported, they are\n         safe for formats, so any non-'%' byte can be copied through,\n         or this is the wide character version.  */\n      if (*f != L_('%'))\n        {\n          add1 (*f);\n          continue;\n        }\n\n#endif /* ! DO_MULTIBYTE */\n\n      /* Check for flags that can modify a format.  */\n      while (1)\n        {\n          switch (*++f)\n            {\n              /* This influences the number formats.  */\n            case L_('_'):\n            case L_('-'):\n            case L_('0'):\n              pad = *f;\n              continue;\n\n              /* This changes textual output.  */\n            case L_('^'):\n              to_uppcase = true;\n              continue;\n            case L_('#'):\n              change_case = true;\n              continue;\n\n            default:\n              break;\n            }\n          break;\n        }\n\n      /* As a GNU extension we allow the field width to be specified.  */\n      if (ISDIGIT (*f))\n        {\n          width = 0;\n          do\n            {\n              if (width > INT_MAX / 10\n                  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n                /* Avoid overflow.  */\n                width = INT_MAX;\n              else\n                {\n                  width *= 10;\n                  width += *f - L_('0');\n                }\n              ++f;\n            }\n          while (ISDIGIT (*f));\n        }\n\n      /* Check for modifiers.  */\n      switch (*f)\n        {\n        case L_('E'):\n        case L_('O'):\n          modifier = *f++;\n          break;\n\n        default:\n          modifier = 0;\n          break;\n        }\n\n      /* Now do the specified format.  */\n      format_char = *f;\n      switch (format_char)\n        {\n#define DO_NUMBER(d, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              number_value = v;                                               \\\n              goto do_number;                                                 \\\n            }                                                                 \\\n          while (0)\n#define DO_SIGNED_NUMBER(d, negative, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              negative_number = negative;                                     \\\n              u_number_value = v;                                             \\\n              goto do_signed_number;                                          \\\n            }                                                                 \\\n          while (0)\n\n          /* The mask is not what you might think.\n             When the ordinal i'th bit is set, insert a colon\n             before the i'th digit of the time zone representation.  */\n#define DO_TZ_OFFSET(d, mask, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              tz_colon_mask = mask;                                           \\\n              u_number_value = v;                                             \\\n              goto do_tz_offset;                                              \\\n            }                                                                 \\\n          while (0)\n#define DO_NUMBER_SPACEPAD(d, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              number_value = v;                                               \\\n              goto do_number_spacepad;                                        \\\n            }                                                                 \\\n          while (0)\n\n        case L_('%'):\n          if (modifier != 0)\n            goto bad_format;\n          add1 (*f);\n          break;\n\n        case L_('a'):\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (aw_len, a_wkday);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case 'A':\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (STRLEN (f_wkday), f_wkday);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('b'):\n        case L_('h'):\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n          if (modifier == L_('E'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (modifier == L_('O'))\n            cpy (aam_len, a_altmonth);\n          else\n            cpy (am_len, a_month);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('B'):\n          if (modifier == L_('E'))\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          if (modifier == L_('O'))\n            cpy (STRLEN (f_altmonth), f_altmonth);\n          else\n            cpy (STRLEN (f_month), f_month);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('c'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == 'E'\n                 && (*(subfmt =\n                       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n                                                     NLW(ERA_D_T_FMT)))\n                     != '\\0')))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n          goto underlying_strftime;\n#endif\n\n        subformat:\n          {\n            size_t len = __strftime_internal (NULL, STRFTIME_ARG ((size_t) -1)\n                                              subfmt,\n                                              tp, to_uppcase, tzset_called\n                                              extra_args LOCALE_ARG);\n            add (len, __strftime_internal (p,\n                                           STRFTIME_ARG (maxsize - i)\n                                           subfmt,\n                                           tp, to_uppcase, tzset_called\n                                           extra_args LOCALE_ARG));\n          }\n          break;\n\n#if !(defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n        underlying_strftime:\n          {\n            /* The relevant information is available only via the\n               underlying strftime implementation, so use that.  */\n            char ufmt[5];\n            char *u = ufmt;\n            char ubuf[1024]; /* enough for any single format in practice */\n            size_t len;\n            /* Make sure we're calling the actual underlying strftime.\n               In some cases, config.h contains something like\n               \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n            size_t strftime ();\n# endif\n\n            /* The space helps distinguish strftime failure from empty\n               output.  */\n            *u++ = ' ';\n            *u++ = '%';\n            if (modifier != 0)\n              *u++ = modifier;\n            *u++ = format_char;\n            *u = '\\0';\n            len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n            if (len != 0)\n              cpy (len - 1, ubuf + 1);\n          }\n          break;\n#endif\n\n        case L_('C'):\n          if (modifier == L_('E'))\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n# ifdef COMPILE_WIDE\n                  size_t len = __wcslen (era->era_wname);\n                  cpy (len, era->era_wname);\n# else\n                  size_t len = strlen (era->era_name);\n                  cpy (len, era->era_name);\n# endif\n                  break;\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          {\n            int century = tp->tm_year / 100 + TM_YEAR_BASE / 100;\n            century -= tp->tm_year % 100 < 0 && 0 < century;\n            DO_SIGNED_NUMBER (2, tp->tm_year < - TM_YEAR_BASE, century);\n          }\n\n        case L_('x'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == L_('E')\n                 && (*(subfmt =\n                       (const CHAR_T *)_NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n                     != L_('\\0'))))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n        case L_('D'):\n          if (modifier != 0)\n            goto bad_format;\n          subfmt = L_(\"%m/%d/%y\");\n          goto subformat;\n\n        case L_('d'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_mday);\n\n        case L_('e'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n          /* All numeric formats set DIGITS and NUMBER_VALUE (or U_NUMBER_VALUE)\n             and then jump to one of these labels.  */\n\n        do_tz_offset:\n          always_output_a_sign = true;\n          goto do_number_body;\n\n        do_number_spacepad:\n          /* Force '_' flag unless overridden by '0' or '-' flag.  */\n          if (pad != L_('0') && pad != L_('-'))\n            pad = L_('_');\n\n        do_number:\n          /* Format NUMBER_VALUE according to the MODIFIER flag.  */\n          negative_number = number_value < 0;\n          u_number_value = number_value;\n\n        do_signed_number:\n          always_output_a_sign = false;\n          tz_colon_mask = 0;\n\n        do_number_body:\n          /* Format U_NUMBER_VALUE according to the MODIFIER flag.\n             NEGATIVE_NUMBER is nonzero if the original number was\n             negative; in this case it was converted directly to\n             unsigned int (i.e., modulo (UINT_MAX + 1)) without\n             negating it.  */\n          if (modifier == L_('O') && !negative_number)\n            {\n#ifdef _NL_CURRENT\n              /* Get the locale specific alternate representation of\n                 the number.  If none exist NULL is returned.  */\n              const CHAR_T *cp = nl_get_alt_digit (u_number_value\n                                                   HELPER_LOCALE_ARG);\n\n              if (cp != NULL)\n                {\n                  size_t digitlen = STRLEN (cp);\n                  if (digitlen != 0)\n                    {\n                      cpy (digitlen, cp);\n                      break;\n                    }\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          bufp = buf + sizeof (buf) / sizeof (buf[0]);\n\n          if (negative_number)\n            u_number_value = - u_number_value;\n\n          do\n            {\n              if (tz_colon_mask & 1)\n                *--bufp = ':';\n              tz_colon_mask >>= 1;\n              *--bufp = u_number_value % 10 + L_('0');\n              u_number_value /= 10;\n            }\n          while (u_number_value != 0 || tz_colon_mask != 0);\n\n        do_number_sign_and_padding:\n          if (digits < width)\n            digits = width;\n\n          sign_char = (negative_number ? L_('-')\n                       : always_output_a_sign ? L_('+')\n                       : 0);\n\n          if (pad == L_('-'))\n            {\n              if (sign_char)\n                add1 (sign_char);\n            }\n          else\n            {\n              int padding = digits - (buf + (sizeof (buf) / sizeof (buf[0]))\n                                      - bufp) - !!sign_char;\n\n              if (padding > 0)\n                {\n                  if (pad == L_('_'))\n                    {\n                      if ((size_t) padding >= maxsize - i)\n                        return 0;\n\n                      if (p)\n                        memset_space (p, padding);\n                      i += padding;\n                      width = width > padding ? width - padding : 0;\n                      if (sign_char)\n                        add1 (sign_char);\n                    }\n                  else\n                    {\n                      if ((size_t) digits >= maxsize - i)\n                        return 0;\n\n                      if (sign_char)\n                        add1 (sign_char);\n\n                      if (p)\n                        memset_zero (p, padding);\n                      i += padding;\n                      width = 0;\n                    }\n                }\n              else\n                {\n                  if (sign_char)\n                    add1 (sign_char);\n                }\n            }\n\n          cpy (buf + sizeof (buf) / sizeof (buf[0]) - bufp, bufp);\n          break;\n\n        case L_('F'):\n          if (modifier != 0)\n            goto bad_format;\n          subfmt = L_(\"%Y-%m-%d\");\n          goto subformat;\n\n        case L_('H'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_hour);\n\n        case L_('I'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, hour12);\n\n        case L_('k'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n        case L_('l'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, hour12);\n\n        case L_('j'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (3, tp->tm_yday < -1, tp->tm_yday + 1U);\n\n        case L_('M'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_min);\n\n        case L_('m'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (2, tp->tm_mon < -1, tp->tm_mon + 1U);\n\n#ifndef _LIBC\n        case L_('N'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          number_value = ns;\n          if (width == -1)\n            width = 9;\n          else\n            {\n              /* Take an explicit width less than 9 as a precision.  */\n              int j;\n              for (j = width; j < 9; j++)\n                number_value /= 10;\n            }\n\n          DO_NUMBER (width, number_value);\n#endif\n\n        case L_('n'):\n          add1 (L_('\\n'));\n          break;\n\n        case L_('P'):\n          to_lowcase = true;\n#ifndef _NL_CURRENT\n          format_char = L_('p');\n#endif\n          FALLTHROUGH;\n        case L_('p'):\n          if (change_case)\n            {\n              to_uppcase = false;\n              to_lowcase = true;\n            }\n#ifdef _NL_CURRENT\n          cpy (ap_len, ampm);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('q'):           /* GNU extension.  */\n          DO_SIGNED_NUMBER (1, false, ((tp->tm_mon * 11) >> 5) + 1);\n          break;\n\n        case L_('R'):\n          subfmt = L_(\"%H:%M\");\n          goto subformat;\n\n        case L_('r'):\n#ifdef _NL_CURRENT\n          if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n                                                       NLW(T_FMT_AMPM)))\n              == L_('\\0'))\n            subfmt = L_(\"%I:%M:%S %p\");\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('S'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_sec);\n\n        case L_('s'):           /* GNU extension.  */\n          {\n            struct tm ltm;\n            time_t t;\n\n            ltm = *tp;\n            t = mktime_z (tz, &ltm);\n\n            /* Generate string value for T using time_t arithmetic;\n               this works even if sizeof (long) < sizeof (time_t).  */\n\n            bufp = buf + sizeof (buf) / sizeof (buf[0]);\n            negative_number = t < 0;\n\n            do\n              {\n                int d = t % 10;\n                t /= 10;\n                *--bufp = (negative_number ? -d : d) + L_('0');\n              }\n            while (t != 0);\n\n            digits = 1;\n            always_output_a_sign = false;\n            goto do_number_sign_and_padding;\n          }\n\n        case L_('X'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == L_('E')\n                 && (*(subfmt =\n                       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n                     != L_('\\0'))))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n        case L_('T'):\n          subfmt = L_(\"%H:%M:%S\");\n          goto subformat;\n\n        case L_('t'):\n          add1 (L_('\\t'));\n          break;\n\n        case L_('u'):\n          DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n        case L_('U'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n        case L_('V'):\n        case L_('g'):\n        case L_('G'):\n          if (modifier == L_('E'))\n            goto bad_format;\n          {\n            /* YEAR is a leap year if and only if (tp->tm_year + TM_YEAR_BASE)\n               is a leap year, except that YEAR and YEAR - 1 both work\n               correctly even when (tp->tm_year + TM_YEAR_BASE) would\n               overflow.  */\n            int year = (tp->tm_year\n                        + (tp->tm_year < 0\n                           ? TM_YEAR_BASE % 400\n                           : TM_YEAR_BASE % 400 - 400));\n            int year_adjust = 0;\n            int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n            if (days < 0)\n              {\n                /* This ISO week belongs to the previous year.  */\n                year_adjust = -1;\n                days = iso_week_days (tp->tm_yday + (365 + __isleap (year - 1)),\n                                      tp->tm_wday);\n              }\n            else\n              {\n                int d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n                                       tp->tm_wday);\n                if (0 <= d)\n                  {\n                    /* This ISO week belongs to the next year.  */\n                    year_adjust = 1;\n                    days = d;\n                  }\n              }\n\n            switch (*f)\n              {\n              case L_('g'):\n                {\n                  int yy = (tp->tm_year % 100 + year_adjust) % 100;\n                  DO_NUMBER (2, (0 <= yy\n                                 ? yy\n                                 : tp->tm_year < -TM_YEAR_BASE - year_adjust\n                                 ? -yy\n                                 : yy + 100));\n                }\n\n              case L_('G'):\n                DO_SIGNED_NUMBER (4, tp->tm_year < -TM_YEAR_BASE - year_adjust,\n                                  (tp->tm_year + (unsigned int) TM_YEAR_BASE\n                                   + year_adjust));\n\n              default:\n                DO_NUMBER (2, days / 7 + 1);\n              }\n          }\n\n        case L_('W'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n        case L_('w'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (1, tp->tm_wday);\n\n        case L_('Y'):\n          if (modifier == 'E')\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n# ifdef COMPILE_WIDE\n                  subfmt = era->era_wformat;\n# else\n                  subfmt = era->era_format;\n# endif\n                  goto subformat;\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n          if (modifier == L_('O'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (4, tp->tm_year < -TM_YEAR_BASE,\n                            tp->tm_year + (unsigned int) TM_YEAR_BASE);\n\n        case L_('y'):\n          if (modifier == L_('E'))\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n                  int delta = tp->tm_year - era->start_date[0];\n                  DO_NUMBER (1, (era->offset\n                                 + delta * era->absolute_direction));\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          {\n            int yy = tp->tm_year % 100;\n            if (yy < 0)\n              yy = tp->tm_year < - TM_YEAR_BASE ? -yy : yy + 100;\n            DO_NUMBER (2, yy);\n          }\n\n        case L_('Z'):\n          if (change_case)\n            {\n              to_uppcase = false;\n              to_lowcase = true;\n            }\n\n#ifdef COMPILE_WIDE\n          {\n            /* The zone string is always given in multibyte form.  We have\n               to transform it first.  */\n            wchar_t *wczone;\n            size_t len;\n            widen (zone, wczone, len);\n            cpy (len, wczone);\n          }\n#else\n          cpy (strlen (zone), zone);\n#endif\n          break;\n\n        case L_(':'):\n          /* :, ::, and ::: are valid only just before 'z'.\n             :::: etc. are rejected later.  */\n          for (colons = 1; f[colons] == L_(':'); colons++)\n            continue;\n          if (f[colons] != L_('z'))\n            goto bad_format;\n          f += colons;\n          goto do_z_conversion;\n\n        case L_('z'):\n          colons = 0;\n\n        do_z_conversion:\n          if (tp->tm_isdst < 0)\n            break;\n\n          {\n            int diff;\n            int hour_diff;\n            int min_diff;\n            int sec_diff;\n#if HAVE_TM_GMTOFF\n            diff = tp->tm_gmtoff;\n#else\n            if (!tz)\n              diff = 0;\n            else\n              {\n                struct tm gtm;\n                struct tm ltm;\n                time_t lt;\n\n                /* POSIX.1 requires that local time zone information be used as\n                   though strftime called tzset.  */\n# if HAVE_TZSET\n                if (!*tzset_called)\n                  {\n                    tzset ();\n                    *tzset_called = true;\n                  }\n# endif\n\n                ltm = *tp;\n                lt = mktime_z (tz, &ltm);\n\n                if (lt == (time_t) -1)\n                  {\n                    /* mktime returns -1 for errors, but -1 is also a\n                       valid time_t value.  Check whether an error really\n                       occurred.  */\n                    struct tm tm;\n\n                    if (! localtime_rz (tz, &lt, &tm)\n                        || ((ltm.tm_sec ^ tm.tm_sec)\n                            | (ltm.tm_min ^ tm.tm_min)\n                            | (ltm.tm_hour ^ tm.tm_hour)\n                            | (ltm.tm_mday ^ tm.tm_mday)\n                            | (ltm.tm_mon ^ tm.tm_mon)\n                            | (ltm.tm_year ^ tm.tm_year)))\n                      break;\n                  }\n\n                if (! localtime_rz (0, &lt, &gtm))\n                  break;\n\n                diff = tm_diff (&ltm, &gtm);\n              }\n#endif\n\n            negative_number = diff < 0 || (diff == 0 && *zone == '-');\n            hour_diff = diff / 60 / 60;\n            min_diff = diff / 60 % 60;\n            sec_diff = diff % 60;\n\n            switch (colons)\n              {\n              case 0: /* +hhmm */\n                DO_TZ_OFFSET (5, 0, hour_diff * 100 + min_diff);\n\n              case 1: tz_hh_mm: /* +hh:mm */\n                DO_TZ_OFFSET (6, 04, hour_diff * 100 + min_diff);\n\n              case 2: tz_hh_mm_ss: /* +hh:mm:ss */\n                DO_TZ_OFFSET (9, 024,\n                              hour_diff * 10000 + min_diff * 100 + sec_diff);\n\n              case 3: /* +hh if possible, else +hh:mm, else +hh:mm:ss */\n                if (sec_diff != 0)\n                  goto tz_hh_mm_ss;\n                if (min_diff != 0)\n                  goto tz_hh_mm;\n                DO_TZ_OFFSET (3, 0, hour_diff);\n\n              default:\n                goto bad_format;\n              }\n          }\n\n        case L_('\\0'):          /* GNU extension: % at end of format.  */\n            --f;\n            FALLTHROUGH;\n        default:\n          /* Unknown format; output the format, including the '%',\n             since this is most likely the right thing to do if a\n             multibyte string has been misparsed.  */\n        bad_format:\n          {\n            int flen;\n            for (flen = 1; f[1 - flen] != L_('%'); flen++)\n              continue;\n            cpy (flen, &f[1 - flen]);\n          }\n          break;\n        }\n    }\n\n#if ! FPRINTFTIME\n  if (p && maxsize != 0)\n    *p = L_('\\0');\n#endif\n\n  return i;\n}",
      "lines": 1075,
      "depth": 27,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/open.c": {
    "orig_open": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\norig_open (const char *filename, int flags, mode_t mode)\n{\n  return open (filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nopen (const char *filename, int flags, ...)\n{\n  /* 0 = unknown, 1 = yes, -1 = no.  */\n#if GNULIB_defined_O_CLOEXEC\n  int have_cloexec = -1;\n#else\n  static int have_cloexec;\n#endif\n\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n#if GNULIB_defined_O_NONBLOCK\n  /* The only known platform that lacks O_NONBLOCK is mingw, but it\n     also lacks named pipes and Unix sockets, which are the only two\n     file types that require non-blocking handling in open().\n     Therefore, it is safe to ignore O_NONBLOCK here.  It is handy\n     that mingw also lacks openat(), so that is also covered here.  */\n  flags &= ~O_NONBLOCK;\n#endif\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n#endif\n\n  fd = orig_open (filename,\n                  flags & ~(have_cloexec <= 0 ? O_CLOEXEC : 0), mode);\n\n  if (flags & O_CLOEXEC)\n    {\n      if (! have_cloexec)\n        {\n          if (0 <= fd)\n            have_cloexec = 1;\n          else if (errno == EINVAL)\n            {\n              fd = orig_open (filename, flags & ~O_CLOEXEC, mode);\n              have_cloexec = -1;\n            }\n        }\n      if (have_cloexec < 0 && 0 <= fd)\n        set_cloexec_flag (fd, true);\n    }\n\n\n#if REPLACE_FCHDIR\n  /* Implementing fchdir and fdopendir requires the ability to open a\n     directory file descriptor.  If open doesn't support that (as on\n     mingw), we use a dummy file that behaves the same as directories\n     on Linux (ie. always reports EOF on attempts to read()), and\n     override fstat() in fchdir.c to hide the fact that we have a\n     dummy.  */\n  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES\n      && ((flags & O_ACCMODE) == O_RDONLY\n          || (O_SEARCH != O_RDONLY && (flags & O_ACCMODE) == O_SEARCH)))\n    {\n      struct stat statbuf;\n      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))\n        {\n          /* Maximum recursion depth of 1.  */\n          fd = open (\"/dev/null\", flags, mode);\n          if (0 <= fd)\n            fd = _gl_register_fd (fd, filename);\n        }\n      else\n        errno = EACCES;\n    }\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n#endif\n\n#if REPLACE_FCHDIR\n  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)\n    fd = _gl_register_fd (fd, filename);\n#endif\n\n  return fd;\n}",
      "lines": 155,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/openat-die.c": {
    "openat_save_fail": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "_Noreturn void\nopenat_save_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"unable to record current working directory\"));\n#endif\n  /* _Noreturn cannot be applied to error, since it returns\n     when its first argument is 0.  To help compilers understand that this\n     function does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "openat_restore_fail": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "_Noreturn void\nopenat_restore_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"failed to return to initial working directory\"));\n#endif\n\n  /* As above.  */\n  abort ();\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/openat-priv.h": {},
  "patch/patch-2.7.6/lib/openat-proc.c": {
    "openat_proc_name": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "char *\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)\n{\n  char *result = buf;\n  int dirlen;\n\n  /* Make sure the caller gets ENOENT when appropriate.  */\n  if (!*file)\n    {\n      buf[0] = '\\0';\n      return buf;\n    }\n\n#ifndef __KLIBC__\n# define PROC_SELF_FD_FORMAT \"/proc/self/fd/%d/\"\n  {\n    enum {\n      PROC_SELF_FD_DIR_SIZE_BOUND\n        = (sizeof PROC_SELF_FD_FORMAT - (sizeof \"%d\" - 1)\n           + INT_STRLEN_BOUND (int))\n    };\n\n    static int proc_status = 0;\n    if (! proc_status)\n      {\n        /* Set PROC_STATUS to a positive value if /proc/self/fd is\n           reliable, and a negative value otherwise.  Solaris 10\n           /proc/self/fd mishandles \"..\", and any file name might expand\n           to \"..\" after symbolic link expansion, so avoid /proc/self/fd\n           if it mishandles \"..\".  Solaris 10 has openat, but this\n           problem is exhibited on code that built on Solaris 8 and\n           running on Solaris 10.  */\n\n        int proc_self_fd = open (\"/proc/self/fd\",\n                                 O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n        if (proc_self_fd < 0)\n          proc_status = -1;\n        else\n          {\n            /* Detect whether /proc/self/fd/%i/../fd exists, where %i is the\n               number of a file descriptor open on /proc/self/fd.  On Linux,\n               that name resolves to /proc/self/fd, which was opened above.\n               However, on Solaris, it may resolve to /proc/self/fd/fd, which\n               cannot exist, since all names in /proc/self/fd are numeric.  */\n            char dotdot_buf[PROC_SELF_FD_DIR_SIZE_BOUND + sizeof \"../fd\" - 1];\n            sprintf (dotdot_buf, PROC_SELF_FD_FORMAT \"../fd\", proc_self_fd);\n            proc_status = access (dotdot_buf, F_OK) ? -1 : 1;\n            close (proc_self_fd);\n          }\n      }\n\n    if (proc_status < 0)\n      return NULL;\n    else\n      {\n        size_t bufsize = PROC_SELF_FD_DIR_SIZE_BOUND + strlen (file);\n        if (OPENAT_BUFFER_SIZE < bufsize)\n          {\n            result = malloc (bufsize);\n            if (! result)\n              return NULL;\n          }\n\n        dirlen = sprintf (result, PROC_SELF_FD_FORMAT, fd);\n      }\n  }\n#else\n  /* OS/2 kLIBC provides a function to retrieve a path from a fd.  */\n  {\n    char dir[_MAX_PATH];\n    size_t bufsize;\n\n    if (__libc_Back_ioFHToPath (fd, dir, sizeof dir))\n      return NULL;\n\n    dirlen = strlen (dir);\n    bufsize = dirlen + 1 + strlen (file) + 1; /* 1 for '/', 1 for null */\n    if (OPENAT_BUFFER_SIZE < bufsize)\n      {\n        result = malloc (bufsize);\n        if (! result)\n          return NULL;\n      }\n\n    strcpy (result, dir);\n    result[dirlen++] = '/';\n  }\n#endif\n\n  strcpy (result + dirlen, file);\n  return result;\n}",
      "lines": 92,
      "depth": 16,
      "decorators": [
        "char",
        "*\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/openat.c": {
    "orig_openat": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static int\norig_openat (int fd, char const *filename, int flags, mode_t mode)\n{\n  return openat (fd, filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_openat": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nrpl_openat (int dfd, char const *filename, int flags, ...)\n{\n  /* 0 = unknown, 1 = yes, -1 = no.  */\n#if GNULIB_defined_O_CLOEXEC\n  int have_cloexec = -1;\n#else\n  static int have_cloexec;\n#endif\n\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n# endif\n\n  fd = orig_openat (dfd, filename,\n                    flags & ~(have_cloexec <= 0 ? O_CLOEXEC : 0), mode);\n\n  if (flags & O_CLOEXEC)\n    {\n      if (! have_cloexec)\n        {\n          if (0 <= fd)\n            have_cloexec = 1;\n          else if (errno == EINVAL)\n            {\n              fd = orig_openat (dfd, filename, flags & ~O_CLOEXEC, mode);\n              have_cloexec = -1;\n            }\n        }\n      if (have_cloexec < 0 && 0 <= fd)\n        set_cloexec_flag (fd, true);\n    }\n\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n# endif\n\n  return fd;\n}",
      "lines": 112,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "openat": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "int\nopenat (int fd, char const *file, int flags, ...)\n{\n  mode_t mode = 0;\n\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n  return openat_permissive (fd, file, flags, mode, NULL);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "openat_permissive": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\nopenat_permissive (int fd, char const *file, int flags, mode_t mode,\n                   int *cwd_errno)\n{\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  int err;\n  bool save_ok;\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return open (file, flags, mode);\n\n  {\n    char buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (buf, fd, file);\n    if (proc_file)\n      {\n        int open_result = open (proc_file, flags, mode);\n        int open_errno = errno;\n        if (proc_file != buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (0 <= open_result || ! EXPECTED_ERRNO (open_errno))\n          {\n            errno = open_errno;\n            return open_result;\n          }\n      }\n  }\n\n  save_ok = (save_cwd (&saved_cwd) == 0);\n  if (! save_ok)\n    {\n      if (! cwd_errno)\n        openat_save_fail (errno);\n      *cwd_errno = errno;\n    }\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return -1;\n    }\n\n  err = fchdir (fd);\n  saved_errno = errno;\n\n  if (! err)\n    {\n      err = open (file, flags, mode);\n      saved_errno = errno;\n      if (save_ok && restore_cwd (&saved_cwd) != 0)\n        {\n          if (! cwd_errno)\n            {\n              /* Don't write a message to just-created fd 2.  */\n              saved_errno = errno;\n              if (err == STDERR_FILENO)\n                close (err);\n              openat_restore_fail (saved_errno);\n            }\n          *cwd_errno = errno;\n        }\n    }\n\n  free_cwd (&saved_cwd);\n  errno = saved_errno;\n  return err;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "openat_needs_fchdir": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "bool\nopenat_needs_fchdir (void)\n{\n  bool needs_fchdir = true;\n  int fd = open (\"/\", O_SEARCH);\n\n  if (0 <= fd)\n    {\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          needs_fchdir = false;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n      close (fd);\n    }\n\n  return needs_fchdir;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "patch/patch-2.7.6/lib/openat.h": {
    "chownat": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchownat": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nlchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "chmodat": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "FCHMODAT_INLINE int\nchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchmodat": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "FCHMODAT_INLINE int\nlchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "statat": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "STATAT_INLINE int\nstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    },
    "lstatat": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "STATAT_INLINE int\nlstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/opendir-safer.c": {
    "opendir_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "DIR *\nopendir_safer (char const *name)\n{\n  DIR *dp = opendir (name);\n\n  if (dp)\n    {\n      int fd = dirfd (dp);\n\n      if (0 <= fd && fd <= STDERR_FILENO)\n        {\n          /* If fdopendir is native (as on Linux), then it is safe to\n             assume dirfd(fdopendir(n))==n.  If we are using the\n             gnulib module fdopendir, then this guarantee is not met,\n             but fdopendir recursively calls opendir_safer up to 3\n             times to at least get a safe fd.  If fdopendir is not\n             present but dirfd is accurate (as on cygwin 1.5.x), then\n             we recurse up to 3 times ourselves.  Finally, if dirfd\n             always fails (as on mingw), then we are already safe.  */\n          DIR *newdp;\n          int e;\n#if HAVE_FDOPENDIR || GNULIB_FDOPENDIR\n          int f = fcntl (fd, F_DUPFD_CLOEXEC, STDERR_FILENO + 1);\n          if (f < 0)\n            {\n              e = errno;\n              newdp = NULL;\n            }\n          else\n            {\n              newdp = fdopendir (f);\n              e = errno;\n              if (! newdp)\n                close (f);\n            }\n#else /* !FDOPENDIR */\n          newdp = opendir_safer (name);\n          e = errno;\n#endif\n          closedir (dp);\n          errno = e;\n          dp = newdp;\n        }\n    }\n\n  return dp;\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "DIR",
        "*\nopendir_safer (char const *name)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/opendir.c": {
    "opendir": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "DIR *\nopendir (const char *dir_name)\n{\n#if HAVE_OPENDIR\n# undef opendir\n  DIR *dirp;\n\n  dirp = opendir (dir_name);\n  if (dirp == NULL)\n    return NULL;\n\n# ifdef __KLIBC__\n  {\n    int fd = open (dir_name, O_RDONLY);\n    if (fd == -1 || _gl_register_dirp_fd (fd, dirp))\n      {\n        int saved_errno = errno;\n\n        close (fd);\n        closedir (dirp);\n\n        errno = saved_errno;\n\n        return NULL;\n      }\n  }\n# endif\n#else\n\n  char dir_name_mask[MAX_PATH + 1 + 1 + 1];\n  int status;\n  HANDLE current;\n  WIN32_FIND_DATA entry;\n  struct gl_directory *dirp;\n\n  if (dir_name[0] == '\\0')\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n\n  /* Make the dir_name absolute, so that we continue reading the same\n     directory if the current directory changed between this opendir()\n     call and a subsequent rewinddir() call.  */\n  if (!GetFullPathName (dir_name, MAX_PATH, dir_name_mask, NULL))\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n  /* Append the mask.\n     \"*\" and \"*.*\" appear to be equivalent.  */\n  {\n    char *p;\n\n    p = dir_name_mask + strlen (dir_name_mask);\n    if (p > dir_name_mask && !ISSLASH (p[-1]))\n      *p++ = '\\\\';\n    *p++ = '*';\n    *p = '\\0';\n  }\n\n  /* Start searching the directory.  */\n  status = -1;\n  current = FindFirstFile (dir_name_mask, &entry);\n  if (current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          status = -2;\n          break;\n        case ERROR_PATH_NOT_FOUND:\n          errno = ENOENT;\n          return NULL;\n        case ERROR_DIRECTORY:\n          errno = ENOTDIR;\n          return NULL;\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          return NULL;\n        default:\n          errno = EIO;\n          return NULL;\n        }\n    }\n\n  /* Allocate the result.  */\n  dirp =\n    (struct gl_directory *)\n    malloc (offsetof (struct gl_directory, dir_name_mask[0])\n            + strlen (dir_name_mask) + 1);\n  if (dirp == NULL)\n    {\n      if (current != INVALID_HANDLE_VALUE)\n        FindClose (current);\n      errno = ENOMEM;\n      return NULL;\n    }\n  dirp->status = status;\n  dirp->current = current;\n  if (status == -1)\n    memcpy (&dirp->entry, &entry, sizeof (WIN32_FIND_DATA));\n  strcpy (dirp->dir_name_mask, dir_name_mask);\n\n#endif\n\n#if REPLACE_FCHDIR\n  {\n    int fd = dirfd (dirp);\n    if (0 <= fd && _gl_register_fd (fd, dir_name) != fd)\n      {\n        int saved_errno = errno;\n        closedir (dirp);\n        errno = saved_errno;\n        return NULL;\n      }\n  }\n#endif\n\n  return dirp;\n}",
      "lines": 122,
      "depth": 15,
      "decorators": [
        "DIR",
        "*\nopendir (const char *dir_name)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/parse-datetime.c": {
    "time_overflow": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "static bool\ntime_overflow (intmax_t n)\n{\n  return ! ((TYPE_SIGNED (time_t) ? TYPE_MINIMUM (time_t) <= n : 0 <= n)\n            && n <= TYPE_MAXIMUM (time_t));\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "to_uchar": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        198,
        54
      ],
      "content": "static unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "_GL_ATTRIBUTE_FORMAT": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static void _GL_ATTRIBUTE_FORMAT ((__printf__, 1, 2))\ndbg_printf (char const *msg, ...)\n{\n  va_list args;\n  /* TODO: use gnulib's 'program_name' instead?  */\n  fputs (\"date: \", stderr);\n\n  va_start (args, msg);\n  vfprintf (stderr, msg, args);\n  va_end (args);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "digits_to_date_time": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "static void\ndigits_to_date_time (parser_control *pc, textint text_int)\n{\n  if (pc->dates_seen && ! pc->year.digits\n      && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n    {\n      pc->year_seen = true;\n      pc->year = text_int;\n    }\n  else\n    {\n      if (4 < text_int.digits)\n        {\n          pc->dates_seen++;\n          pc->day = text_int.value % 100;\n          pc->month = (text_int.value / 100) % 100;\n          pc->year.value = text_int.value / 10000;\n          pc->year.digits = text_int.digits - 4;\n        }\n      else\n        {\n          pc->times_seen++;\n          if (text_int.digits <= 2)\n            {\n              pc->hour = text_int.value;\n              pc->minutes = 0;\n            }\n          else\n            {\n              pc->hour = text_int.value / 100;\n              pc->minutes = text_int.value % 100;\n            }\n          pc->seconds.tv_sec = 0;\n          pc->seconds.tv_nsec = 0;\n          pc->meridian = MER24;\n        }\n    }\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_relative_time": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "static bool\napply_relative_time (parser_control *pc, relative_time rel, int factor)\n{\n  if (factor < 0\n      ? (INT_SUBTRACT_WRAPV (pc->rel.ns, rel.ns, &pc->rel.ns)\n         | INT_SUBTRACT_WRAPV (pc->rel.seconds, rel.seconds, &pc->rel.seconds)\n         | INT_SUBTRACT_WRAPV (pc->rel.minutes, rel.minutes, &pc->rel.minutes)\n         | INT_SUBTRACT_WRAPV (pc->rel.hour, rel.hour, &pc->rel.hour)\n         | INT_SUBTRACT_WRAPV (pc->rel.day, rel.day, &pc->rel.day)\n         | INT_SUBTRACT_WRAPV (pc->rel.month, rel.month, &pc->rel.month)\n         | INT_SUBTRACT_WRAPV (pc->rel.year, rel.year, &pc->rel.year))\n      : (INT_ADD_WRAPV (pc->rel.ns, rel.ns, &pc->rel.ns)\n         | INT_ADD_WRAPV (pc->rel.seconds, rel.seconds, &pc->rel.seconds)\n         | INT_ADD_WRAPV (pc->rel.minutes, rel.minutes, &pc->rel.minutes)\n         | INT_ADD_WRAPV (pc->rel.hour, rel.hour, &pc->rel.hour)\n         | INT_ADD_WRAPV (pc->rel.day, rel.day, &pc->rel.day)\n         | INT_ADD_WRAPV (pc->rel.month, rel.month, &pc->rel.month)\n         | INT_ADD_WRAPV (pc->rel.year, rel.year, &pc->rel.year)))\n    return false;\n  pc->rels_seen = true;\n  return true;\n}",
      "lines": 22,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "set_hhmmss": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "static void\nset_hhmmss (parser_control *pc, intmax_t hour, intmax_t minutes,\n            time_t sec, int nsec)\n{\n  pc->hour = hour;\n  pc->minutes = minutes;\n  pc->seconds.tv_sec = sec;\n  pc->seconds.tv_nsec = nsec;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "str_days": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "static const char *\nstr_days (parser_control *pc, char *buffer, int n)\n{\n  /* TODO: use relative_time_table for reverse lookup.  */\n  static char const ordinal_values[][11] = {\n     \"last\",\n     \"this\",\n     \"next/first\",\n     \"(SECOND)\", /* SECOND is commented out in relative_time_table.  */\n     \"third\",\n     \"fourth\",\n     \"fifth\",\n     \"sixth\",\n     \"seventh\",\n     \"eight\",\n     \"ninth\",\n     \"tenth\",\n     \"eleventh\",\n     \"twelfth\"\n  };\n\n  static char const days_values[][4] = {\n     \"Sun\",\n     \"Mon\",\n     \"Tue\",\n     \"Wed\",\n     \"Thu\",\n     \"Fri\",\n     \"Sat\"\n  };\n\n  int len;\n\n  /* Don't add an ordinal prefix if the user didn't specify it\n     (e.g., \"this wed\" vs \"wed\").  */\n  if (pc->debug_ordinal_day_seen)\n    {\n      /* Use word description if possible (e.g., -1 = last, 3 = third).  */\n      len = (-1 <= pc->day_ordinal && pc->day_ordinal <= 12\n             ? snprintf (buffer, n, \"%s\", ordinal_values[pc->day_ordinal + 1])\n             : snprintf (buffer, n, \"%\"PRIdMAX, pc->day_ordinal));\n    }\n  else\n    {\n      buffer[0] = '\\0';\n      len = 0;\n    }\n\n  /* Add the day name */\n  if (0 <= pc->day_number && pc->day_number <= 6 && 0 <= len && len < n)\n    snprintf (buffer + len, n - len, &\" %s\"[len == 0],\n              days_values[pc->day_number]);\n  else\n    {\n      /* invalid day_number value - should never happen */\n    }\n  return buffer;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nstr_days (parser_control *pc, char *buffer, int n)",
        "*"
      ]
    },
    "time_zone_str": {
      "start_point": [
        466,
        0
      ],
      "end_point": [
        490,
        1
      ],
      "content": "static char const *\ntime_zone_str (int time_zone, char time_zone_buf[TIME_ZONE_BUFSIZE])\n{\n  char *p = time_zone_buf;\n  char sign = time_zone < 0 ? '-' : '+';\n  int hour = abs (time_zone / (60 * 60));\n  p += sprintf (time_zone_buf, \"%c%02d\", sign, hour);\n  int offset_from_hour = abs (time_zone % (60 * 60));\n  if (offset_from_hour != 0)\n    {\n      int mm = offset_from_hour / 60;\n      int ss = offset_from_hour % 60;\n      *p++ = ':';\n      *p++ = '0' + mm / 10;\n      *p++ = '0' + mm % 10;\n      if (ss)\n        {\n          *p++ = ':';\n          *p++ = '0' + ss / 10;\n          *p++ = '0' + ss % 10;\n        }\n      *p = '\\0';\n    }\n  return time_zone_buf;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ntime_zone_str (int time_zone, char time_zone_buf[TIME_ZONE_BUFSIZE])",
        "*"
      ]
    },
    "debug_print_current_time": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "static void\ndebug_print_current_time (char const *item, parser_control *pc)\n{\n  bool space = false;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  /* no newline, more items printed below */\n  dbg_printf (_(\"parsed %s part: \"), item);\n\n  if (pc->dates_seen && !pc->debug_dates_seen)\n    {\n      /*TODO: use pc->year.negative?  */\n      fprintf (stderr, \"(Y-M-D) %04\"PRIdMAX\"-%02\"PRIdMAX\"-%02\"PRIdMAX,\n              pc->year.value, pc->month, pc->day);\n      pc->debug_dates_seen = true;\n      space = true;\n    }\n\n  if (pc->year_seen != pc->debug_year_seen)\n    {\n      if (space)\n        fputc (' ', stderr);\n      fprintf (stderr, _(\"year: %04\"PRIdMAX), pc->year.value);\n\n      pc->debug_year_seen = pc->year_seen;\n      space = true;\n    }\n\n  if (pc->times_seen && !pc->debug_times_seen)\n    {\n      intmax_t sec = pc->seconds.tv_sec;\n      fprintf (stderr, &\" %02\"PRIdMAX\":%02\"PRIdMAX\":%02\"PRIdMAX[!space],\n               pc->hour, pc->minutes, sec);\n      if (pc->seconds.tv_nsec != 0)\n        {\n          int nsec = pc->seconds.tv_nsec;\n          fprintf (stderr, \".%09d\", nsec);\n        }\n      if (pc->meridian == MERpm)\n        fputs (\"pm\", stderr);\n\n      pc->debug_times_seen = true;\n      space = true;\n    }\n\n  if (pc->days_seen && !pc->debug_days_seen)\n    {\n      if (space)\n        fputc (' ', stderr);\n      char tmp[DBGBUFSIZE];\n      fprintf (stderr, _(\"%s (day ordinal=%\"PRIdMAX\" number=%d)\"),\n               str_days (pc, tmp, sizeof tmp),\n               pc->day_ordinal, pc->day_number);\n      pc->debug_days_seen = true;\n      space = true;\n    }\n\n  /* local zone strings only change the DST settings,\n     not the timezone value.  If seen, inform about the DST.  */\n  if (pc->local_zones_seen && !pc->debug_local_zones_seen)\n    {\n      fprintf (stderr, &\" isdst=%d%s\"[!space],\n\t       pc->local_isdst, pc->dsts_seen ? \" DST\" : \"\");\n      pc->debug_local_zones_seen = true;\n      space = true;\n    }\n\n  if (pc->zones_seen && !pc->debug_zones_seen)\n    {\n      char time_zone_buf[TIME_ZONE_BUFSIZE];\n      fprintf (stderr, &\" UTC%s\"[!space],\n               time_zone_str (pc->time_zone, time_zone_buf));\n      pc->debug_zones_seen = true;\n      space = true;\n    }\n\n  if (pc->timespec_seen)\n    {\n      intmax_t sec = pc->seconds.tv_sec;\n      if (space)\n        fputc (' ', stderr);\n      fprintf (stderr, _(\"number of seconds: %\"PRIdMAX), sec);\n    }\n\n  fputc ('\\n', stderr);\n}",
      "lines": 88,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_rel_part": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        593,
        1
      ],
      "content": "static bool\nprint_rel_part (bool space, intmax_t val, char const *name)\n{\n  if (val == 0)\n    return space;\n  fprintf (stderr, &\" %+\"PRIdMAX\" %s\"[!space], val, name);\n  return true;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "debug_print_relative_time": {
      "start_point": [
        595,
        0
      ],
      "end_point": [
        624,
        1
      ],
      "content": "static void\ndebug_print_relative_time (char const *item, parser_control const *pc)\n{\n  bool space = false;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  /* no newline, more items printed below */\n  dbg_printf (_(\"parsed %s part: \"), item);\n\n  if (pc->rel.year == 0 && pc->rel.month == 0 && pc->rel.day == 0\n      && pc->rel.hour == 0 && pc->rel.minutes == 0 && pc->rel.seconds == 0\n      && pc->rel.ns == 0)\n    {\n      /* Special case: relative time of this/today/now */\n      fputs (_(\"today/this/now\\n\"), stderr);\n      return;\n    }\n\n  space = print_rel_part (space, pc->rel.year, \"year(s)\");\n  space = print_rel_part (space, pc->rel.month, \"month(s)\");\n  space = print_rel_part (space, pc->rel.day, \"day(s)\");\n  space = print_rel_part (space, pc->rel.hour, \"hour(s)\");\n  space = print_rel_part (space, pc->rel.minutes, \"minutes\");\n  space = print_rel_part (space, pc->rel.seconds, \"seconds\");\n  print_rel_part (space, pc->rel.ns, \"nanoseconds\");\n\n  fputc ('\\n', stderr);\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_symbol_value_print": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1305,
        1
      ],
      "content": "static void\nyy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, parser_control *pc)\n{\n  FILE *yyo = yyoutput;\n  YYUSE (yyo);\n  YYUSE (pc);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yytype < YYNTOKENS)\n    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);\n# endif\n  YYUSE (yytype);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_symbol_print": {
      "start_point": [
        1312,
        0
      ],
      "end_point": [
        1320,
        1
      ],
      "content": "static void\nyy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, parser_control *pc)\n{\n  YYFPRINTF (yyoutput, \"%s %s (\",\n             yytype < YYNTOKENS ? \"token\" : \"nterm\", yytname[yytype]);\n\n  yy_symbol_value_print (yyoutput, yytype, yyvaluep, pc);\n  YYFPRINTF (yyoutput, \")\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_stack_print": {
      "start_point": [
        1327,
        0
      ],
      "end_point": [
        1337,
        1
      ],
      "content": "static void\nyy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_reduce_print": {
      "start_point": [
        1350,
        0
      ],
      "end_point": [
        1368,
        1
      ],
      "content": "static void\nyy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, parser_control *pc)\n{\n  unsigned long int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  /* The symbols being reduced.  */\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                                              , pc);\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yystrlen": {
      "start_point": [
        1411,
        0
      ],
      "end_point": [
        1418,
        1
      ],
      "content": "static YYSIZE_T\nyystrlen (const char *yystr)\n{\n  YYSIZE_T yylen;\n  for (yylen = 0; yystr[yylen]; yylen++)\n    continue;\n  return yylen;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yystpcpy": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1438,
        1
      ],
      "content": "static char *\nyystpcpy (char *yydest, const char *yysrc)\n{\n  char *yyd = yydest;\n  const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nyystpcpy (char *yydest, const char *yysrc)",
        "*"
      ]
    },
    "yytnamerr": {
      "start_point": [
        1450,
        0
      ],
      "end_point": [
        1487,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            /* Fall through.  */\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1498,
        0
      ],
      "end_point": [
        1623,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 126,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yydestruct": {
      "start_point": [
        1630,
        0
      ],
      "end_point": [
        1642,
        1
      ],
      "content": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, parser_control *pc)\n{\n  YYUSE (yyvaluep);\n  YYUSE (pc);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YYUSE (yytype);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyparse": {
      "start_point": [
        1651,
        0
      ],
      "end_point": [
        2725,
        1
      ],
      "content": "int\nyyparse (parser_control *pc)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, pc);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 4:\n#line 609 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->seconds = (yyvsp[0].timespec);\n        pc->timespec_seen = true;\n        debug_print_current_time (_(\"number of seconds\"), pc);\n      }\n#line 1908 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 7:\n#line 623 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->times_seen++; pc->dates_seen++;\n        debug_print_current_time (_(\"datetime\"), pc);\n      }\n#line 1917 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 8:\n#line 628 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->times_seen++;\n        debug_print_current_time (_(\"time\"), pc);\n      }\n#line 1926 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 633 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->local_zones_seen++;\n        debug_print_current_time (_(\"local_zone\"), pc);\n      }\n#line 1935 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 638 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->zones_seen++;\n        debug_print_current_time (_(\"zone\"), pc);\n      }\n#line 1944 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 643 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->dates_seen++;\n        debug_print_current_time (_(\"date\"), pc);\n      }\n#line 1953 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 648 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->days_seen++;\n        debug_print_current_time (_(\"day\"), pc);\n      }\n#line 1962 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 653 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        debug_print_relative_time (_(\"relative\"), pc);\n      }\n#line 1970 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 657 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        debug_print_current_time (_(\"number\"), pc);\n      }\n#line 1978 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 661 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        debug_print_relative_time (_(\"hybrid\"), pc);\n      }\n#line 1986 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 676 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-1].textintval).value, 0, 0, 0);\n        pc->meridian = (yyvsp[0].intval);\n      }\n#line 1995 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 681 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-3].textintval).value, (yyvsp[-1].textintval).value, 0, 0);\n        pc->meridian = (yyvsp[0].intval);\n      }\n#line 2004 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 686 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-5].textintval).value, (yyvsp[-3].textintval).value, (yyvsp[-1].timespec).tv_sec, (yyvsp[-1].timespec).tv_nsec);\n        pc->meridian = (yyvsp[0].intval);\n      }\n#line 2013 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 695 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-1].textintval).value, 0, 0, 0);\n        pc->meridian = MER24;\n      }\n#line 2022 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 700 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-3].textintval).value, (yyvsp[-1].textintval).value, 0, 0);\n        pc->meridian = MER24;\n      }\n#line 2031 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 705 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-5].textintval).value, (yyvsp[-3].textintval).value, (yyvsp[-1].timespec).tv_sec, (yyvsp[-1].timespec).tv_nsec);\n        pc->meridian = MER24;\n      }\n#line 2040 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 718 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->zones_seen++;\n        if (! time_zone_hhmm (pc, (yyvsp[-1].textintval), (yyvsp[0].intval))) YYABORT;\n      }\n#line 2049 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 743 \"parse-datetime.y\" /* yacc.c:1646  */\n    { pc->local_isdst = (yyvsp[0].intval); }\n#line 2055 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 745 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->local_isdst = 1;\n        pc->dsts_seen++;\n      }\n#line 2064 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 30:\n#line 755 \"parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = (yyvsp[0].intval); }\n#line 2070 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 31:\n#line 757 \"parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = HOUR (7); }\n#line 2076 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 759 \"parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = (yyvsp[-1].intval);\n        if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT;\n        debug_print_relative_time (_(\"relative\"), pc);\n      }\n#line 2085 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 764 \"parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = HOUR (7);\n        if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT;\n        debug_print_relative_time (_(\"relative\"), pc);\n      }\n#line 2094 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 769 \"parse-datetime.y\" /* yacc.c:1646  */\n    { if (! time_zone_hhmm (pc, (yyvsp[-1].textintval), (yyvsp[0].intval))) YYABORT;\n        if (INT_ADD_WRAPV (pc->time_zone, (yyvsp[-2].intval), &pc->time_zone)) YYABORT; }\n#line 2101 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 772 \"parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = (yyvsp[0].intval) + 60 * 60; }\n#line 2107 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 36:\n#line 774 \"parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = (yyvsp[-1].intval) + 60 * 60; }\n#line 2113 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 779 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day_ordinal = 0;\n        pc->day_number = (yyvsp[0].intval);\n      }\n#line 2122 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 784 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day_ordinal = 0;\n        pc->day_number = (yyvsp[-1].intval);\n      }\n#line 2131 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 789 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day_ordinal = (yyvsp[-1].intval);\n        pc->day_number = (yyvsp[0].intval);\n        pc->debug_ordinal_day_seen = true;\n      }\n#line 2141 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 795 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day_ordinal = (yyvsp[-1].textintval).value;\n        pc->day_number = (yyvsp[0].intval);\n        pc->debug_ordinal_day_seen = true;\n      }\n#line 2151 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 41:\n#line 804 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->month = (yyvsp[-2].textintval).value;\n        pc->day = (yyvsp[0].textintval).value;\n      }\n#line 2160 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 42:\n#line 809 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        /* Interpret as YYYY/MM/DD if the first value has 4 or more digits,\n           otherwise as MM/DD/YY.\n           The goal in recognizing YYYY/MM/DD is solely to support legacy\n           machine-generated dates like those in an RCS log listing.  If\n           you want portability, use the ISO 8601 format.  */\n        if (4 <= (yyvsp[-4].textintval).digits)\n          {\n            if (pc->parse_datetime_debug)\n              {\n                intmax_t digits = (yyvsp[-4].textintval).digits;\n                dbg_printf (_(\"warning: value %\"PRIdMAX\" has %\"PRIdMAX\" digits. \"\n                              \"Assuming YYYY/MM/DD\\n\"),\n                            (yyvsp[-4].textintval).value, digits);\n              }\n\n            pc->year = (yyvsp[-4].textintval);\n            pc->month = (yyvsp[-2].textintval).value;\n            pc->day = (yyvsp[0].textintval).value;\n          }\n        else\n          {\n            if (pc->parse_datetime_debug)\n              dbg_printf (_(\"warning: value %\"PRIdMAX\" has less than 4 digits. \"\n                            \"Assuming MM/DD/YY[YY]\\n\"),\n                          (yyvsp[-4].textintval).value);\n\n            pc->month = (yyvsp[-4].textintval).value;\n            pc->day = (yyvsp[-2].textintval).value;\n            pc->year = (yyvsp[0].textintval);\n          }\n      }\n#line 2197 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 43:\n#line 842 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        /* E.g., 17-JUN-1992.  */\n        pc->day = (yyvsp[-2].textintval).value;\n        pc->month = (yyvsp[-1].intval);\n        if (INT_SUBTRACT_WRAPV (0, (yyvsp[0].textintval).value, &pc->year.value)) YYABORT;\n        pc->year.digits = (yyvsp[0].textintval).digits;\n      }\n#line 2209 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 850 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        /* E.g., JUN-17-1992.  */\n        pc->month = (yyvsp[-2].intval);\n        if (INT_SUBTRACT_WRAPV (0, (yyvsp[-1].textintval).value, &pc->day)) YYABORT;\n        if (INT_SUBTRACT_WRAPV (0, (yyvsp[0].textintval).value, &pc->year.value)) YYABORT;\n        pc->year.digits = (yyvsp[0].textintval).digits;\n      }\n#line 2221 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 858 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->month = (yyvsp[-1].intval);\n        pc->day = (yyvsp[0].textintval).value;\n      }\n#line 2230 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 863 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->month = (yyvsp[-3].intval);\n        pc->day = (yyvsp[-2].textintval).value;\n        pc->year = (yyvsp[0].textintval);\n      }\n#line 2240 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 869 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day = (yyvsp[-1].textintval).value;\n        pc->month = (yyvsp[0].intval);\n      }\n#line 2249 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 874 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day = (yyvsp[-2].textintval).value;\n        pc->month = (yyvsp[-1].intval);\n        pc->year = (yyvsp[0].textintval);\n      }\n#line 2259 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 884 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        /* ISO 8601 format.  YYYY-MM-DD.  */\n        pc->year = (yyvsp[-2].textintval);\n        if (INT_SUBTRACT_WRAPV (0, (yyvsp[-1].textintval).value, &pc->month)) YYABORT;\n        if (INT_SUBTRACT_WRAPV (0, (yyvsp[0].textintval).value, &pc->day)) YYABORT;\n      }\n#line 2270 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 894 \"parse-datetime.y\" /* yacc.c:1646  */\n    { if (! apply_relative_time (pc, (yyvsp[-1].rel), (yyvsp[0].intval))) YYABORT; }\n#line 2276 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 52:\n#line 896 \"parse-datetime.y\" /* yacc.c:1646  */\n    { if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT; }\n#line 2282 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 53:\n#line 898 \"parse-datetime.y\" /* yacc.c:1646  */\n    { if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT; }\n#line 2288 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 54:\n#line 903 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].intval); }\n#line 2294 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 55:\n#line 905 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].textintval).value; }\n#line 2300 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 56:\n#line 907 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = 1; }\n#line 2306 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 57:\n#line 909 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].intval); }\n#line 2312 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 58:\n#line 911 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].textintval).value; }\n#line 2318 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 59:\n#line 913 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = 1; }\n#line 2324 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 60:\n#line 915 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0;\n        if (INT_MULTIPLY_WRAPV ((yyvsp[-1].intval), (yyvsp[0].intval), &(yyval.rel).day)) YYABORT; }\n#line 2331 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 61:\n#line 918 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0;\n        if (INT_MULTIPLY_WRAPV ((yyvsp[-1].textintval).value, (yyvsp[0].intval), &(yyval.rel).day)) YYABORT; }\n#line 2338 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 62:\n#line 921 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).day = (yyvsp[0].intval); }\n#line 2344 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 63:\n#line 923 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].intval); }\n#line 2350 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 64:\n#line 925 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].textintval).value; }\n#line 2356 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 65:\n#line 927 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = 1; }\n#line 2362 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 66:\n#line 929 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].intval); }\n#line 2368 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 67:\n#line 931 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].textintval).value; }\n#line 2374 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 68:\n#line 933 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = 1; }\n#line 2380 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 69:\n#line 935 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].intval); }\n#line 2386 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 70:\n#line 937 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].textintval).value; }\n#line 2392 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 71:\n#line 939 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].timespec).tv_sec; (yyval.rel).ns = (yyvsp[-1].timespec).tv_nsec; }\n#line 2398 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 72:\n#line 941 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].timespec).tv_sec; (yyval.rel).ns = (yyvsp[-1].timespec).tv_nsec; }\n#line 2404 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 73:\n#line 943 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = 1; }\n#line 2410 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 75:\n#line 949 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].textintval).value; }\n#line 2416 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 76:\n#line 951 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].textintval).value; }\n#line 2422 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 77:\n#line 953 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0;\n        if (INT_MULTIPLY_WRAPV ((yyvsp[-1].textintval).value, (yyvsp[0].intval), &(yyval.rel).day)) YYABORT; }\n#line 2429 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 78:\n#line 956 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].textintval).value; }\n#line 2435 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 79:\n#line 958 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].textintval).value; }\n#line 2441 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 80:\n#line 960 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].textintval).value; }\n#line 2447 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 81:\n#line 965 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).day = (yyvsp[0].intval); }\n#line 2453 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 85:\n#line 973 \"parse-datetime.y\" /* yacc.c:1646  */\n    { if (time_overflow ((yyvsp[0].textintval).value)) YYABORT;\n        (yyval.timespec).tv_sec = (yyvsp[0].textintval).value; (yyval.timespec).tv_nsec = 0; }\n#line 2460 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 87:\n#line 980 \"parse-datetime.y\" /* yacc.c:1646  */\n    { if (time_overflow ((yyvsp[0].textintval).value)) YYABORT;\n        (yyval.timespec).tv_sec = (yyvsp[0].textintval).value; (yyval.timespec).tv_nsec = 0; }\n#line 2467 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 88:\n#line 986 \"parse-datetime.y\" /* yacc.c:1646  */\n    { digits_to_date_time (pc, (yyvsp[0].textintval)); }\n#line 2473 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 89:\n#line 991 \"parse-datetime.y\" /* yacc.c:1646  */\n    {\n        /* Hybrid all-digit and relative offset, so that we accept e.g.,\n           \"YYYYMMDD +N days\" as well as \"YYYYMMDD N days\".  */\n        digits_to_date_time (pc, (yyvsp[-1].textintval));\n        if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT;\n      }\n#line 2484 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 90:\n#line 1001 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.intval) = -1; }\n#line 2490 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 91:\n#line 1003 \"parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.intval) = (yyvsp[0].textintval).value; }\n#line 2496 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n\n#line 2500 \"parse-datetime.c\" /* yacc.c:1646  */\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (pc, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (pc, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, pc);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, pc);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (pc, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, pc);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp, pc);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
      "lines": 1075,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "time_zone_hhmm": {
      "start_point": [
        2925,
        0
      ],
      "end_point": [
        2950,
        1
      ],
      "content": "static bool\ntime_zone_hhmm (parser_control *pc, textint s, intmax_t mm)\n{\n  intmax_t n_minutes;\n  bool overflow = false;\n\n  /* If the length of S is 1 or 2 and no minutes are specified,\n     interpret it as a number of hours.  */\n  if (s.digits <= 2 && mm < 0)\n    s.value *= 100;\n\n  if (mm < 0)\n    n_minutes = (s.value / 100) * 60 + s.value % 100;\n  else\n    {\n      overflow |= INT_MULTIPLY_WRAPV (s.value, 60, &n_minutes);\n      overflow |= (s.negative\n                   ? INT_SUBTRACT_WRAPV (n_minutes, mm, &n_minutes)\n                   : INT_ADD_WRAPV (n_minutes, mm, &n_minutes));\n    }\n\n  if (overflow || ! (-24 * 60 <= n_minutes && n_minutes <= 24 * 60))\n    return false;\n  pc->time_zone = n_minutes * 60;\n  return true;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "to_hour": {
      "start_point": [
        2952,
        0
      ],
      "end_point": [
        2965,
        1
      ],
      "content": "static int\nto_hour (intmax_t hours, int meridian)\n{\n  switch (meridian)\n    {\n    default: /* Pacify GCC.  */\n    case MER24:\n      return 0 <= hours && hours < 24 ? hours : -1;\n    case MERam:\n      return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n    case MERpm:\n      return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tm_year_str": {
      "start_point": [
        2973,
        0
      ],
      "end_point": [
        2981,
        1
      ],
      "content": "static char const *\ntm_year_str (int tm_year, char buf[TM_YEAR_BUFSIZE])\n{\n  verify (TM_YEAR_BASE % 100 == 0);\n  sprintf (buf, &\"-%02d%02d\"[-TM_YEAR_BASE <= tm_year],\n           abs (tm_year / 100 + TM_YEAR_BASE / 100),\n           abs (tm_year % 100));\n  return buf;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ntm_year_str (int tm_year, char buf[TM_YEAR_BUFSIZE])",
        "*"
      ]
    },
    "to_tm_year": {
      "start_point": [
        2986,
        0
      ],
      "end_point": [
        3012,
        1
      ],
      "content": "static bool\nto_tm_year (textint textyear, bool debug, int *tm_year)\n{\n  intmax_t year = textyear.value;\n\n  /* XPG4 suggests that years 00-68 map to 2000-2068, and\n     years 69-99 map to 1969-1999.  */\n  if (0 <= year && textyear.digits == 2)\n    {\n      year += year < 69 ? 2000 : 1900;\n      if (debug)\n        dbg_printf (_(\"warning: adjusting year value %\"PRIdMAX\n                      \" to %\"PRIdMAX\"\\n\"),\n                    textyear.value, year);\n    }\n\n  if (year < 0\n      ? INT_SUBTRACT_WRAPV (-TM_YEAR_BASE, year, tm_year)\n      : INT_SUBTRACT_WRAPV (year, TM_YEAR_BASE, tm_year))\n    {\n      if (debug)\n        dbg_printf (_(\"error: out-of-range year %\"PRIdMAX\"\\n\"), year);\n      return false;\n    }\n\n  return true;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "lookup_zone": {
      "start_point": [
        3014,
        0
      ],
      "end_point": [
        3034,
        1
      ],
      "content": "static table const * _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)\n{\n  table const *tp;\n\n  for (tp = universal_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  /* Try local zone abbreviations before those in time_zone_table, as\n     the local ones are more likely to be right.  */\n  for (tp = pc->local_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  for (tp = time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "tm_diff": {
      "start_point": [
        3041,
        0
      ],
      "end_point": [
        3060,
        1
      ],
      "content": "static int\ntm_diff (const struct tm *a, const struct tm *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations,\n     but it's OK to assume that A and B are close to each other.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  int years = a->tm_year - b->tm_year;\n  int days = (365 * years + intervening_leap_days\n              + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lookup_word": {
      "start_point": [
        3063,
        0
      ],
      "end_point": [
        3129,
        1
      ],
      "content": "static table const *\nlookup_word (parser_control const *pc, char *word)\n{\n  char *p;\n  char *q;\n  ptrdiff_t wordlen;\n  table const *tp;\n  bool period_found;\n  bool abbrev;\n\n  /* Make it uppercase.  */\n  for (p = word; *p; p++)\n    *p = c_toupper (to_uchar (*p));\n\n  for (tp = meridian_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* See if we have an abbreviation for a month.  */\n  wordlen = strlen (word);\n  abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n\n  for (tp = month_and_day_table; tp->name; tp++)\n    if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n      return tp;\n\n  if ((tp = lookup_zone (pc, word)))\n    return tp;\n\n  if (strcmp (word, dst_table[0].name) == 0)\n    return dst_table;\n\n  for (tp = time_units_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Strip off any plural and try the units table again.  */\n  if (word[wordlen - 1] == 'S')\n    {\n      word[wordlen - 1] = '\\0';\n      for (tp = time_units_table; tp->name; tp++)\n        if (strcmp (word, tp->name) == 0)\n          return tp;\n      word[wordlen - 1] = 'S';  /* For \"this\" in relative_time_table.  */\n    }\n\n  for (tp = relative_time_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Military time zones.  */\n  if (wordlen == 1)\n    for (tp = military_table; tp->name; tp++)\n      if (word[0] == tp->name[0])\n        return tp;\n\n  /* Drop out any periods and try the time zone table again.  */\n  for (period_found = false, p = q = word; (*p = *q); q++)\n    if (*q == '.')\n      period_found = true;\n    else\n      p++;\n  if (period_found && (tp = lookup_zone (pc, word)))\n    return tp;\n\n  return NULL;\n}",
      "lines": 67,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "*\nlookup_word (parser_control const *pc, char *word)",
        "*"
      ]
    },
    "yylex": {
      "start_point": [
        3131,
        0
      ],
      "end_point": [
        3268,
        1
      ],
      "content": "static int\nyylex (union YYSTYPE *lvalp, parser_control *pc)\n{\n  unsigned char c;\n\n  for (;;)\n    {\n      while (c = *pc->input, c_isspace (c))\n        pc->input++;\n\n      if (c_isdigit (c) || c == '-' || c == '+')\n        {\n          char const *p;\n          int sign;\n          intmax_t value = 0;\n          if (c == '-' || c == '+')\n            {\n              sign = c == '-' ? -1 : 1;\n              while (c = *++pc->input, c_isspace (c))\n                continue;\n              if (! c_isdigit (c))\n                /* skip the '-' sign */\n                continue;\n            }\n          else\n            sign = 0;\n          p = pc->input;\n\n          do\n            {\n              if (INT_MULTIPLY_WRAPV (value, 10, &value))\n                return '?';\n              if (INT_ADD_WRAPV (value, sign < 0 ? '0' - c : c - '0', &value))\n                return '?';\n              c = *++p;\n            }\n          while (c_isdigit (c));\n\n          if ((c == '.' || c == ',') && c_isdigit (p[1]))\n            {\n              time_t s;\n              int ns;\n              int digits;\n\n              if (time_overflow (value))\n                return '?';\n              s = value;\n\n              /* Accumulate fraction, to ns precision.  */\n              p++;\n              ns = *p++ - '0';\n              for (digits = 2; digits <= LOG10_BILLION; digits++)\n                {\n                  ns *= 10;\n                  if (c_isdigit (*p))\n                    ns += *p++ - '0';\n                }\n\n              /* Skip excess digits, truncating toward -Infinity.  */\n              if (sign < 0)\n                for (; c_isdigit (*p); p++)\n                  if (*p != '0')\n                    {\n                      ns++;\n                      break;\n                    }\n              while (c_isdigit (*p))\n                p++;\n\n              /* Adjust to the timespec convention, which is that\n                 tv_nsec is always a positive offset even if tv_sec is\n                 negative.  */\n              if (sign < 0 && ns)\n                {\n                  if (s == TYPE_MINIMUM (time_t))\n                    return '?';\n                  s--;\n                  ns = BILLION - ns;\n                }\n\n              lvalp->timespec.tv_sec = s;\n              lvalp->timespec.tv_nsec = ns;\n              pc->input = p;\n              return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n            }\n          else\n            {\n              lvalp->textintval.negative = sign < 0;\n              lvalp->textintval.value = value;\n              lvalp->textintval.digits = p - pc->input;\n              pc->input = p;\n              return sign ? tSNUMBER : tUNUMBER;\n            }\n        }\n\n      if (c_isalpha (c))\n        {\n          char buff[20];\n          char *p = buff;\n          table const *tp;\n\n          do\n            {\n              if (p < buff + sizeof buff - 1)\n                *p++ = c;\n              c = *++pc->input;\n            }\n          while (c_isalpha (c) || c == '.');\n\n          *p = '\\0';\n          tp = lookup_word (pc, buff);\n          if (! tp)\n            {\n              if (pc->parse_datetime_debug)\n                dbg_printf (_(\"error: unknown word '%s'\\n\"), buff);\n              return '?';\n            }\n          lvalp->intval = tp->value;\n          return tp->type;\n        }\n\n      if (c != '(')\n        return to_uchar (*pc->input++);\n\n      ptrdiff_t count = 0;\n      do\n        {\n          c = *pc->input++;\n          if (c == '\\0')\n            return c;\n          if (c == '(')\n            count++;\n          else if (c == ')')\n            count--;\n        }\n      while (count != 0);\n    }\n}",
      "lines": 138,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        3271,
        0
      ],
      "end_point": [
        3276,
        1
      ],
      "content": "static int\nyyerror (parser_control const *pc _GL_UNUSED,\n         char const *s _GL_UNUSED)\n{\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mktime_ok": {
      "start_point": [
        3283,
        0
      ],
      "end_point": [
        3303,
        1
      ],
      "content": "static bool\nmktime_ok (timezone_t tz, struct tm const *tm0, struct tm const *tm1, time_t t)\n{\n  struct tm ltm;\n  if (t == (time_t) -1)\n    {\n      /* Guard against falsely reporting an error when parsing a\n         timestamp that happens to equal (time_t) -1, on a host that\n         supports such a timestamp.  */\n      tm1 = localtime_rz (tz, &t, &ltm);\n      if (!tm1)\n        return false;\n    }\n\n  return ! ((tm0->tm_sec ^ tm1->tm_sec)\n            | (tm0->tm_min ^ tm1->tm_min)\n            | (tm0->tm_hour ^ tm1->tm_hour)\n            | (tm0->tm_mday ^ tm1->tm_mday)\n            | (tm0->tm_mon ^ tm1->tm_mon)\n            | (tm0->tm_year ^ tm1->tm_year));\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "debug_strfdatetime": {
      "start_point": [
        3307,
        0
      ],
      "end_point": [
        3350,
        1
      ],
      "content": "static char const *\ndebug_strfdatetime (struct tm const *tm, parser_control const *pc,\n                    char *buf, int n)\n{\n  /* TODO:\n     1. find an optimal way to print date string in a clear and unambiguous\n        format.  Currently, always add '(Y-M-D)' prefix.\n        Consider '2016y01m10d'  or 'year(2016) month(01) day(10)'.\n\n        If the user needs debug printing, it means he/she already having\n        issues with the parsing - better to avoid formats that could\n        be mis-interpreted (e.g., just YYYY-MM-DD).\n\n     2. Can strftime be used instead?\n        depends if it is portable and can print invalid dates on all systems.\n\n     3. Print timezone information ?\n\n     4. Print DST information ?\n\n     5. Print nanosecond information ?\n\n     NOTE:\n     Printed date/time values might not be valid, e.g., '2016-02-31'\n     or '2016-19-2016' .  These are the values as parsed from the user\n     string, before validation.\n  */\n  int m = nstrftime (buf, n, \"(Y-M-D) %Y-%m-%d %H:%M:%S\", tm, 0, 0);\n\n  /* If parser_control information was provided (for timezone),\n     and there's enough space in the buffer, add timezone info.  */\n  if (pc && m < n && pc->zones_seen)\n    {\n      int tz = pc->time_zone;\n\n      /* Account for DST if tLOCAL_ZONE was seen.  */\n      if (pc->local_zones_seen && !pc->zones_seen && 0 < pc->local_isdst)\n        tz += 60 * 60;\n\n      char time_zone_buf[TIME_ZONE_BUFSIZE];\n      snprintf (&buf[m], n - m, \" TZ=%s\", time_zone_str (tz, time_zone_buf));\n    }\n  return buf;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strfdatetime (struct tm const *tm, parser_control const *pc,\n                    char *buf, int n)",
        "*"
      ]
    },
    "debug_strfdate": {
      "start_point": [
        3352,
        0
      ],
      "end_point": [
        3360,
        1
      ],
      "content": "static char const *\ndebug_strfdate (struct tm const *tm, char *buf, int n)\n{\n  char tm_year_buf[TM_YEAR_BUFSIZE];\n  snprintf (buf, n, \"(Y-M-D) %s-%02d-%02d\",\n            tm_year_str (tm->tm_year, tm_year_buf),\n            tm->tm_mon + 1, tm->tm_mday);\n  return buf;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strfdate (struct tm const *tm, char *buf, int n)",
        "*"
      ]
    },
    "debug_strftime": {
      "start_point": [
        3362,
        0
      ],
      "end_point": [
        3367,
        1
      ],
      "content": "static char const *\ndebug_strftime (struct tm const *tm, char *buf, int n)\n{\n  snprintf (buf, n, \"%02d:%02d:%02d\", tm->tm_hour, tm->tm_min, tm->tm_sec);\n  return buf;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strftime (struct tm const *tm, char *buf, int n)",
        "*"
      ]
    },
    "debug_mktime_not_ok": {
      "start_point": [
        3381,
        0
      ],
      "end_point": [
        3435,
        1
      ],
      "content": "static void\ndebug_mktime_not_ok (struct tm const *tm0, struct tm const *tm1,\n                     parser_control const *pc, bool time_zone_seen)\n{\n  /* TODO: handle t == -1 (as in 'mktime_ok').  */\n  char tmp[DBGBUFSIZE];\n  int i;\n  const bool eq_sec   = (tm0->tm_sec  == tm1->tm_sec);\n  const bool eq_min   = (tm0->tm_min  == tm1->tm_min);\n  const bool eq_hour  = (tm0->tm_hour == tm1->tm_hour);\n  const bool eq_mday  = (tm0->tm_mday == tm1->tm_mday);\n  const bool eq_month = (tm0->tm_mon  == tm1->tm_mon);\n  const bool eq_year  = (tm0->tm_year == tm1->tm_year);\n\n  const bool dst_shift = eq_sec && eq_min && !eq_hour\n                         && eq_mday && eq_month && eq_year;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  dbg_printf (_(\"error: invalid date/time value:\\n\"));\n  dbg_printf (_(\"    user provided time: '%s'\\n\"),\n              debug_strfdatetime (tm0, pc, tmp, sizeof tmp));\n  dbg_printf (_(\"       normalized time: '%s'\\n\"),\n              debug_strfdatetime (tm1, pc, tmp, sizeof tmp));\n  /* The format must be aligned with debug_strfdatetime and the two\n     DEBUG statements above.  This string is not translated.  */\n  i = snprintf (tmp, sizeof tmp,\n                \"                                 %4s %2s %2s %2s %2s %2s\",\n                eq_year ? \"\" : \"----\",\n                eq_month ? \"\" : \"--\",\n                eq_mday ? \"\" : \"--\",\n                eq_hour ? \"\" : \"--\",\n                eq_min ? \"\" : \"--\",\n                eq_sec ? \"\" : \"--\");\n  /* Trim trailing whitespace.  */\n  if (0 <= i)\n    {\n      if (sizeof tmp - 1 < i)\n        i = sizeof tmp - 1;\n      while (0 < i && tmp[i - 1] == ' ')\n        --i;\n      tmp[i] = '\\0';\n    }\n  dbg_printf (\"%s\\n\", tmp);\n\n  dbg_printf (_(\"     possible reasons:\\n\"));\n  if (dst_shift)\n    dbg_printf (_(\"       non-existing due to daylight-saving time;\\n\"));\n  if (!eq_mday && !eq_month)\n    dbg_printf (_(\"       invalid day/month combination;\\n\"));\n  dbg_printf (_(\"       numeric values overflow;\\n\"));\n  dbg_printf (\"       %s\\n\", (time_zone_seen ? _(\"incorrect timezone\")\n                              : _(\"missing timezone\")));\n}",
      "lines": 55,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_datetime": {
      "start_point": [
        3438,
        0
      ],
      "end_point": [
        3449,
        1
      ],
      "content": "bool\nparse_datetime (struct timespec *result, char const *p,\n                struct timespec const *now)\n{\n  char const *tzstring = getenv (\"TZ\");\n  timezone_t tz = tzalloc (tzstring);\n  if (!tz)\n    return false;\n  bool ok = parse_datetime2 (result, p, now, 0, tz, tzstring);\n  tzfree (tz);\n  return ok;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "parse_datetime2": {
      "start_point": [
        3456,
        0
      ],
      "end_point": [
        4111,
        1
      ],
      "content": "bool\nparse_datetime2 (struct timespec *result, char const *p,\n                 struct timespec const *now, unsigned int flags,\n                 timezone_t tzdefault, char const *tzstring)\n{\n  struct tm tm;\n  struct tm tm0;\n  char time_zone_buf[TIME_ZONE_BUFSIZE];\n  char dbg_tm[DBGBUFSIZE];\n  bool ok = false;\n  char const *input_sentinel = p + strlen (p);\n  char *tz1alloc = NULL;\n\n  /* A reasonable upper bound for the size of ordinary TZ strings.\n     Use heap allocation if TZ's length exceeds this.  */\n  enum { TZBUFSIZE = 100 };\n  char tz1buf[TZBUFSIZE];\n\n  struct timespec gettime_buffer;\n  if (! now)\n    {\n      gettime (&gettime_buffer);\n      now = &gettime_buffer;\n    }\n\n  time_t Start = now->tv_sec;\n  int Start_ns = now->tv_nsec;\n\n  unsigned char c;\n  while (c = *p, c_isspace (c))\n    p++;\n\n  timezone_t tz = tzdefault;\n\n  if (strncmp (p, \"TZ=\\\"\", 4) == 0)\n    {\n      char const *tzbase = p + 4;\n      ptrdiff_t tzsize = 1;\n      char const *s;\n\n      for (s = tzbase; *s; s++, tzsize++)\n        if (*s == '\\\\')\n          {\n            s++;\n            if (! (*s == '\\\\' || *s == '\"'))\n              break;\n          }\n        else if (*s == '\"')\n          {\n            timezone_t tz1;\n            char *tz1string = tz1buf;\n            char *z;\n            if (TZBUFSIZE < tzsize)\n              {\n                tz1alloc = malloc (tzsize);\n                if (!tz1alloc)\n                  goto fail;\n                tz1string = tz1alloc;\n              }\n            z = tz1string;\n            for (s = tzbase; *s != '\"'; s++)\n              *z++ = *(s += *s == '\\\\');\n            *z = '\\0';\n            tz1 = tzalloc (tz1string);\n            if (!tz1)\n              goto fail;\n            tz = tz1;\n            tzstring = tz1string;\n\n            p = s + 1;\n            while (c = *p, c_isspace (c))\n              p++;\n\n            break;\n          }\n    }\n\n  struct tm tmp;\n  if (! localtime_rz (tz, &now->tv_sec, &tmp))\n    goto fail;\n\n  /* As documented, be careful to treat the empty string just like\n     a date string of \"0\".  Without this, an empty string would be\n     declared invalid when parsed during a DST transition.  */\n  if (*p == '\\0')\n    p = \"0\";\n\n  parser_control pc;\n  pc.input = p;\n  pc.parse_datetime_debug = (flags & PARSE_DATETIME_DEBUG) != 0;\n  if (INT_ADD_WRAPV (tmp.tm_year, TM_YEAR_BASE, &pc.year.value))\n    {\n      if (pc.parse_datetime_debug)\n        dbg_printf (_(\"error: initial year out of range\\n\"));\n      goto fail;\n    }\n  pc.year.digits = 0;\n  pc.month = tmp.tm_mon + 1;\n  pc.day = tmp.tm_mday;\n  pc.hour = tmp.tm_hour;\n  pc.minutes = tmp.tm_min;\n  pc.seconds.tv_sec = tmp.tm_sec;\n  pc.seconds.tv_nsec = Start_ns;\n  tm.tm_isdst = tmp.tm_isdst;\n\n  pc.meridian = MER24;\n  pc.rel = RELATIVE_TIME_0;\n  pc.timespec_seen = false;\n  pc.rels_seen = false;\n  pc.dates_seen = 0;\n  pc.days_seen = 0;\n  pc.times_seen = 0;\n  pc.local_zones_seen = 0;\n  pc.dsts_seen = 0;\n  pc.zones_seen = 0;\n  pc.year_seen = false;\n  pc.debug_dates_seen = false;\n  pc.debug_days_seen = false;\n  pc.debug_times_seen = false;\n  pc.debug_local_zones_seen = false;\n  pc.debug_zones_seen = false;\n  pc.debug_year_seen = false;\n  pc.debug_ordinal_day_seen = false;\n\n#if HAVE_STRUCT_TM_TM_ZONE\n  pc.local_time_zone_table[0].name = tmp.tm_zone;\n  pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n  pc.local_time_zone_table[0].value = tmp.tm_isdst;\n  pc.local_time_zone_table[1].name = NULL;\n\n  /* Probe the names used in the next three calendar quarters, looking\n     for a tm_isdst different from the one we already have.  */\n  {\n    int quarter;\n    for (quarter = 1; quarter <= 3; quarter++)\n      {\n        intmax_t iprobe;\n        if (INT_ADD_WRAPV (Start, quarter * (90 * 24 * 60 * 60), &iprobe)\n            || time_overflow (iprobe))\n          break;\n        time_t probe = iprobe;\n        struct tm probe_tm;\n        if (localtime_rz (tz, &probe, &probe_tm) && probe_tm.tm_zone\n            && probe_tm.tm_isdst != pc.local_time_zone_table[0].value)\n          {\n              {\n                pc.local_time_zone_table[1].name = probe_tm.tm_zone;\n                pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n                pc.local_time_zone_table[1].value = probe_tm.tm_isdst;\n                pc.local_time_zone_table[2].name = NULL;\n              }\n            break;\n          }\n      }\n  }\n#else\n#if HAVE_TZNAME\n  {\n# if !HAVE_DECL_TZNAME\n    extern char *tzname[];\n# endif\n    int i;\n    for (i = 0; i < 2; i++)\n      {\n        pc.local_time_zone_table[i].name = tzname[i];\n        pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n        pc.local_time_zone_table[i].value = i;\n      }\n    pc.local_time_zone_table[i].name = NULL;\n  }\n#else\n  pc.local_time_zone_table[0].name = NULL;\n#endif\n#endif\n\n  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n      && ! strcmp (pc.local_time_zone_table[0].name,\n                   pc.local_time_zone_table[1].name))\n    {\n      /* This locale uses the same abbreviation for standard and\n         daylight times.  So if we see that abbreviation, we don't\n         know whether it's daylight time.  */\n      pc.local_time_zone_table[0].value = -1;\n      pc.local_time_zone_table[1].name = NULL;\n    }\n\n  if (yyparse (&pc) != 0)\n    {\n      if (pc.parse_datetime_debug)\n        dbg_printf ((input_sentinel <= pc.input\n                     ? _(\"error: parsing failed\\n\")\n                     : _(\"error: parsing failed, stopped at '%s'\\n\")),\n                    pc.input);\n      goto fail;\n    }\n\n\n  /* Determine effective timezone source.  */\n\n  if (pc.parse_datetime_debug)\n    {\n      dbg_printf (_(\"input timezone: \"));\n\n      if (pc.timespec_seen)\n        fprintf (stderr, _(\"'@timespec' - always UTC\"));\n      else if (pc.zones_seen)\n        fprintf (stderr, _(\"parsed date/time string\"));\n      else if (tzstring)\n        {\n          if (tz != tzdefault)\n            fprintf (stderr, _(\"TZ=\\\"%s\\\" in date string\"), tzstring);\n          else if (STREQ (tzstring, \"UTC0\"))\n            {\n              /* Special case: 'date -u' sets TZ=\"UTC0\".  */\n              fprintf (stderr, _(\"TZ=\\\"UTC0\\\" environment value or -u\"));\n            }\n          else\n            fprintf (stderr, _(\"TZ=\\\"%s\\\" environment value\"), tzstring);\n        }\n      else\n        fprintf (stderr, _(\"system default\"));\n\n      /* Account for DST changes if tLOCAL_ZONE was seen.\n         local timezone only changes DST and is relative to the\n         default timezone.*/\n      if (pc.local_zones_seen && !pc.zones_seen && 0 < pc.local_isdst)\n        fprintf (stderr, \", dst\");\n\n      if (pc.zones_seen)\n\tfprintf (stderr, \" (%s)\", time_zone_str (pc.time_zone, time_zone_buf));\n\n      fputc ('\\n', stderr);\n    }\n\n  if (pc.timespec_seen)\n    *result = pc.seconds;\n  else\n    {\n      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n               | (pc.local_zones_seen + pc.zones_seen)))\n        {\n          if (pc.parse_datetime_debug)\n            {\n              if (pc.times_seen > 1)\n                dbg_printf (\"error: seen multiple time parts\\n\");\n              if (pc.dates_seen > 1)\n                dbg_printf (\"error: seen multiple date parts\\n\");\n              if (pc.days_seen > 1)\n                dbg_printf (\"error: seen multiple days parts\\n\");\n              if (pc.dsts_seen > 1)\n                dbg_printf (\"error: seen multiple daylight-saving parts\\n\");\n              if ((pc.local_zones_seen + pc.zones_seen) > 1)\n                dbg_printf (\"error: seen multiple time-zone parts\\n\");\n            }\n          goto fail;\n        }\n\n      if (! to_tm_year (pc.year, pc.parse_datetime_debug, &tm.tm_year)\n          || INT_ADD_WRAPV (pc.month, -1, &tm.tm_mon)\n          || INT_ADD_WRAPV (pc.day, 0, &tm.tm_mday))\n        {\n          if (pc.parse_datetime_debug)\n            dbg_printf (_(\"error: year, month, or day overflow\\n\"));\n          goto fail;\n        }\n      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n        {\n          tm.tm_hour = to_hour (pc.hour, pc.meridian);\n          if (tm.tm_hour < 0)\n            {\n              char const *mrd = (pc.meridian == MERam ? \"am\"\n                                 : pc.meridian == MERpm ?\"pm\" : \"\");\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: invalid hour %\"PRIdMAX\"%s\\n\"),\n                            pc.hour, mrd);\n              goto fail;\n            }\n          tm.tm_min = pc.minutes;\n          tm.tm_sec = pc.seconds.tv_sec;\n          if (pc.parse_datetime_debug)\n            dbg_printf ((pc.times_seen\n                         ? _(\"using specified time as starting value: '%s'\\n\")\n                         : _(\"using current time as starting value: '%s'\\n\")),\n                        debug_strftime (&tm, dbg_tm, sizeof dbg_tm));\n        }\n      else\n        {\n          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n          pc.seconds.tv_nsec = 0;\n          if (pc.parse_datetime_debug)\n            dbg_printf (\"warning: using midnight as starting time: 00:00:00\\n\");\n        }\n\n      /* Let mktime deduce tm_isdst if we have an absolute timestamp.  */\n      if (pc.dates_seen | pc.days_seen | pc.times_seen)\n        tm.tm_isdst = -1;\n\n      /* But if the input explicitly specifies local time with or without\n         DST, give mktime that information.  */\n      if (pc.local_zones_seen)\n        tm.tm_isdst = pc.local_isdst;\n\n      tm0.tm_sec = tm.tm_sec;\n      tm0.tm_min = tm.tm_min;\n      tm0.tm_hour = tm.tm_hour;\n      tm0.tm_mday = tm.tm_mday;\n      tm0.tm_mon = tm.tm_mon;\n      tm0.tm_year = tm.tm_year;\n      tm0.tm_isdst = tm.tm_isdst;\n\n      Start = mktime_z (tz, &tm);\n\n      if (! mktime_ok (tz, &tm0, &tm, Start))\n        {\n          bool repaired = false;\n          bool time_zone_seen = pc.zones_seen != 0;\n          if (time_zone_seen)\n            {\n              /* Guard against falsely reporting errors near the time_t\n                 boundaries when parsing times in other time zones.  For\n                 example, suppose the input string \"1969-12-31 23:00:00 -0100\",\n                 the current time zone is 8 hours ahead of UTC, and the min\n                 time_t value is 1970-01-01 00:00:00 UTC.  Then the min\n                 localtime value is 1970-01-01 08:00:00, and mktime will\n                 therefore fail on 1969-12-31 23:00:00.  To work around the\n                 problem, set the time zone to 1 hour behind UTC temporarily\n                 by setting TZ=\"XXX1:00\" and try mktime again.  */\n\n              char tz2buf[sizeof \"XXX\" - 1 + TIME_ZONE_BUFSIZE];\n              tz2buf[0] = tz2buf[1] = tz2buf[2] = 'X';\n              time_zone_str (pc.time_zone, &tz2buf[3]);\n              timezone_t tz2 = tzalloc (tz2buf);\n              if (!tz2)\n                {\n                  if (pc.parse_datetime_debug)\n                    dbg_printf (_(\"error: tzalloc (\\\"%s\\\") failed\\n\"), tz2buf);\n                  goto fail;\n                }\n              tm.tm_sec = tm0.tm_sec;\n              tm.tm_min = tm0.tm_min;\n              tm.tm_hour = tm0.tm_hour;\n              tm.tm_mday = tm0.tm_mday;\n              tm.tm_mon = tm0.tm_mon;\n              tm.tm_year = tm0.tm_year;\n              tm.tm_isdst = tm0.tm_isdst;\n              Start = mktime_z (tz2, &tm);\n              repaired = mktime_ok (tz2, &tm0, &tm, Start);\n              tzfree (tz2);\n            }\n\n          if (! repaired)\n            {\n              debug_mktime_not_ok (&tm0, &tm, &pc, time_zone_seen);\n              goto fail;\n            }\n        }\n\n      char dbg_ord[DBGBUFSIZE];\n\n      if (pc.days_seen && ! pc.dates_seen)\n        {\n          intmax_t dayincr;\n          if (INT_MULTIPLY_WRAPV ((pc.day_ordinal\n                                   - (0 < pc.day_ordinal\n                                      && tm.tm_wday != pc.day_number)),\n                                  7, &dayincr)\n              || INT_ADD_WRAPV ((pc.day_number - tm.tm_wday + 7) % 7,\n                                dayincr, &dayincr)\n              || INT_ADD_WRAPV (dayincr, tm.tm_mday, &tm.tm_mday))\n            Start = -1;\n          else\n            {\n              tm.tm_isdst = -1;\n              Start = mktime_z (tz, &tm);\n            }\n\n          if (Start == (time_t) -1)\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: day '%s' \"\n                              \"(day ordinal=%\"PRIdMAX\" number=%d) \"\n                              \"resulted in an invalid date: '%s'\\n\"),\n                            str_days (&pc, dbg_ord, sizeof dbg_ord),\n                            pc.day_ordinal, pc.day_number,\n                            debug_strfdatetime (&tm, &pc, dbg_tm,\n                                                sizeof dbg_tm));\n              goto fail;\n            }\n\n          if (pc.parse_datetime_debug)\n            dbg_printf (_(\"new start date: '%s' is '%s'\\n\"),\n                        str_days (&pc, dbg_ord, sizeof dbg_ord),\n                        debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n\n        }\n\n      if (pc.parse_datetime_debug)\n        {\n          if (!pc.dates_seen && !pc.days_seen)\n            dbg_printf (_(\"using current date as starting value: '%s'\\n\"),\n                        debug_strfdate (&tm, dbg_tm, sizeof dbg_tm));\n\n          if (pc.days_seen && pc.dates_seen)\n            dbg_printf (_(\"warning: day (%s) ignored when explicit dates \"\n                          \"are given\\n\"),\n                        str_days (&pc, dbg_ord, sizeof dbg_ord));\n\n          dbg_printf (_(\"starting date/time: '%s'\\n\"),\n                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n        }\n\n      /* Add relative date.  */\n      if (pc.rel.year | pc.rel.month | pc.rel.day)\n        {\n          if (pc.parse_datetime_debug)\n            {\n              if ((pc.rel.year != 0 || pc.rel.month != 0) && tm.tm_mday != 15)\n                dbg_printf (_(\"warning: when adding relative months/years, \"\n                              \"it is recommended to specify the 15th of the \"\n                              \"months\\n\"));\n\n              if (pc.rel.day != 0 && tm.tm_hour != 12)\n                dbg_printf (_(\"warning: when adding relative days, \"\n                              \"it is recommended to specify noon\\n\"));\n            }\n\n          int year, month, day;\n          if (INT_ADD_WRAPV (tm.tm_year, pc.rel.year, &year)\n              || INT_ADD_WRAPV (tm.tm_mon, pc.rel.month, &month)\n              || INT_ADD_WRAPV (tm.tm_mday, pc.rel.day, &day))\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: %s:%d\\n\"), __FILE__, __LINE__);\n              goto fail;\n            }\n          tm.tm_year = year;\n          tm.tm_mon = month;\n          tm.tm_mday = day;\n          tm.tm_hour = tm0.tm_hour;\n          tm.tm_min = tm0.tm_min;\n          tm.tm_sec = tm0.tm_sec;\n          tm.tm_isdst = tm0.tm_isdst;\n          Start = mktime_z (tz, &tm);\n          if (Start == (time_t) -1)\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: adding relative date resulted \"\n                              \"in an invalid date: '%s'\\n\"),\n                            debug_strfdatetime (&tm, &pc, dbg_tm,\n                                                sizeof dbg_tm));\n              goto fail;\n            }\n\n          if (pc.parse_datetime_debug)\n            {\n              dbg_printf (_(\"after date adjustment \"\n                            \"(%+\"PRIdMAX\" years, %+\"PRIdMAX\" months, \"\n                            \"%+\"PRIdMAX\" days),\\n\"),\n                          pc.rel.year, pc.rel.month, pc.rel.day);\n              dbg_printf (_(\"    new date/time = '%s'\\n\"),\n                          debug_strfdatetime (&tm, &pc, dbg_tm,\n                                              sizeof dbg_tm));\n\n              /* Warn about crossing DST due to time adjustment.\n                 Example: https://bugs.gnu.org/8357\n                 env TZ=Europe/Helsinki \\\n                   date --debug \\\n                        -d 'Mon Mar 28 00:36:07 2011 EEST 1 day ago'\n\n                 This case is different than DST changes due to time adjustment,\n                 i.e., \"1 day ago\" vs \"24 hours ago\" are calculated in different\n                 places.\n\n                 'tm0.tm_isdst' contains the DST of the input date,\n                 'tm.tm_isdst' is the normalized result after calling\n                 mktime (&tm).\n              */\n              if (tm0.tm_isdst != -1 && tm.tm_isdst != tm0.tm_isdst)\n                dbg_printf (_(\"warning: daylight saving time changed after \"\n                              \"date adjustment\\n\"));\n\n              /* Warn if the user did not ask to adjust days but mday changed,\n                 or\n                 user did not ask to adjust months/days but the month changed.\n\n                 Example for first case:\n                 2016-05-31 + 1 month => 2016-06-31 => 2016-07-01.\n                 User asked to adjust month, but the day changed from 31 to 01.\n\n                 Example for second case:\n                 2016-02-29 + 1 year => 2017-02-29 => 2017-03-01.\n                 User asked to adjust year, but the month changed from 02 to 03.\n              */\n              if (pc.rel.day == 0\n                  && (tm.tm_mday != day\n                      || (pc.rel.month == 0 && tm.tm_mon != month)))\n                {\n                  dbg_printf (_(\"warning: month/year adjustment resulted in \"\n                                \"shifted dates:\\n\"));\n                  char tm_year_buf[TM_YEAR_BUFSIZE];\n                  dbg_printf (_(\"     adjusted Y M D: %s %02d %02d\\n\"),\n                              tm_year_str (year, tm_year_buf), month + 1, day);\n                  dbg_printf (_(\"   normalized Y M D: %s %02d %02d\\n\"),\n                              tm_year_str (tm.tm_year, tm_year_buf),\n                              tm.tm_mon + 1, tm.tm_mday);\n                }\n            }\n\n        }\n\n      /* The only \"output\" of this if-block is an updated Start value,\n         so this block must follow others that clobber Start.  */\n      if (pc.zones_seen)\n        {\n          intmax_t delta = pc.time_zone, t1;\n          bool overflow = false;\n#ifdef HAVE_TM_GMTOFF\n          long int utcoff = tm.tm_gmtoff;\n#else\n          time_t t = Start;\n          struct tm gmt;\n          int utcoff = (gmtime_r (&t, &gmt)\n                        ? tm_diff (&tm, &gmt)\n                        : (overflow = true, 0));\n#endif\n          overflow |= INT_SUBTRACT_WRAPV (delta, utcoff, &delta);\n          overflow |= INT_SUBTRACT_WRAPV (Start, delta, &t1);\n          if (overflow || time_overflow (t1))\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: timezone %d caused time_t overflow\\n\"),\n                            pc.time_zone);\n              goto fail;\n            }\n          Start = t1;\n        }\n\n      if (pc.parse_datetime_debug)\n        {\n          intmax_t Starti = Start;\n          dbg_printf (_(\"'%s' = %\"PRIdMAX\" epoch-seconds\\n\"),\n                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm),\n                      Starti);\n        }\n\n\n      /* Add relative hours, minutes, and seconds.  On hosts that support\n         leap seconds, ignore the possibility of leap seconds; e.g.,\n         \"+ 10 minutes\" adds 600 seconds, even if one of them is a\n         leap second.  Typically this is not what the user wants, but it's\n         too hard to do it the other way, because the time zone indicator\n         must be applied before relative times, and if mktime is applied\n         again the time zone will be lost.  */\n      {\n        intmax_t orig_ns = pc.seconds.tv_nsec;\n        intmax_t sum_ns = orig_ns + pc.rel.ns;\n        int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n        int d4 = (sum_ns - normalized_ns) / BILLION;\n        intmax_t d1, t1, d2, t2, t3, t4;\n        if (INT_MULTIPLY_WRAPV (pc.rel.hour, 60 * 60, &d1)\n            || INT_ADD_WRAPV (Start, d1, &t1)\n            || INT_MULTIPLY_WRAPV (pc.rel.minutes, 60, &d2)\n            || INT_ADD_WRAPV (t1, d2, &t2)\n            || INT_ADD_WRAPV (t2, pc.rel.seconds, &t3)\n            || INT_ADD_WRAPV (t3, d4, &t4)\n            || time_overflow (t4))\n          {\n            if (pc.parse_datetime_debug)\n              dbg_printf (_(\"error: adding relative time caused an \"\n                            \"overflow\\n\"));\n            goto fail;\n          }\n\n        result->tv_sec = t4;\n        result->tv_nsec = normalized_ns;\n\n        if (pc.parse_datetime_debug\n            && (pc.rel.hour | pc.rel.minutes | pc.rel.seconds | pc.rel.ns))\n          {\n            dbg_printf (_(\"after time adjustment (%+\"PRIdMAX\" hours, \"\n                          \"%+\"PRIdMAX\" minutes, \"\n                          \"%+\"PRIdMAX\" seconds, %+d ns),\\n\"),\n                        pc.rel.hour, pc.rel.minutes, pc.rel.seconds,\n                        pc.rel.ns);\n            dbg_printf (_(\"    new time = %\"PRIdMAX\" epoch-seconds\\n\"), t4);\n\n            /* Warn about crossing DST due to time adjustment.\n               Example: https://bugs.gnu.org/8357\n               env TZ=Europe/Helsinki           \\\n               date --debug                                             \\\n               -d 'Mon Mar 28 00:36:07 2011 EEST 24 hours ago'\n\n               This case is different than DST changes due to days adjustment,\n               i.e., \"1 day ago\" vs \"24 hours ago\" are calculated in different\n               places.\n\n               'tm.tm_isdst' contains the date after date adjustment.  */\n            struct tm lmt;\n            if (tm.tm_isdst != -1 && localtime_rz (tz, &result->tv_sec, &lmt)\n                && tm.tm_isdst != lmt.tm_isdst)\n              dbg_printf (_(\"warning: daylight saving time changed after \"\n                            \"time adjustment\\n\"));\n          }\n      }\n    }\n\n  if (pc.parse_datetime_debug)\n    {\n      /* Special case: using 'date -u' simply set TZ=UTC0 */\n      if (! tzstring)\n        dbg_printf (_(\"timezone: system default\\n\"));\n      else if (STREQ (tzstring, \"UTC0\"))\n        dbg_printf (_(\"timezone: Universal Time\\n\"));\n      else\n        dbg_printf (_(\"timezone: TZ=\\\"%s\\\" environment value\\n\"), tzstring);\n\n      intmax_t sec = result->tv_sec;\n      int nsec = result->tv_nsec;\n      dbg_printf (_(\"final: %\"PRIdMAX\".%09d (epoch-seconds)\\n\"),\n                  sec, nsec);\n\n      struct tm gmt, lmt;\n      bool got_utc = !!gmtime_r (&result->tv_sec, &gmt);\n      if (got_utc)\n        dbg_printf (_(\"final: %s (UTC)\\n\"),\n                    debug_strfdatetime (&gmt, NULL,\n                                        dbg_tm, sizeof dbg_tm));\n      if (localtime_rz (tz, &result->tv_sec, &lmt))\n        {\n#ifdef HAVE_TM_GMTOFF\n          bool got_utcoff = true;\n          long int utcoff = lmt.tm_gmtoff;\n#else\n          bool got_utcoff = got_utc;\n          int utcoff;\n          if (got_utcoff)\n            utcoff = tm_diff (&lmt, &gmt);\n#endif\n          if (got_utcoff)\n            dbg_printf (_(\"final: %s (UTC%s)\\n\"),\n                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm),\n                        time_zone_str (utcoff, time_zone_buf));\n          else\n            dbg_printf (_(\"final: %s (unknown time zone offset)\\n\"),\n                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm));\n        }\n    }\n\n  ok = true;\n\n fail:\n  if (tz != tzdefault)\n    tzfree (tz);\n  free (tz1alloc);\n  return ok;\n}",
      "lines": 656,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        4115,
        0
      ],
      "end_point": [
        4148,
        1
      ],
      "content": "int\nmain (int ac, char **av)\n{\n  char buff[BUFSIZ];\n\n  printf (\"Enter date, or blank line to exit.\\n\\t> \");\n  fflush (stdout);\n\n  buff[BUFSIZ - 1] = '\\0';\n  while (fgets (buff, BUFSIZ - 1, stdin) && buff[0])\n    {\n      struct timespec d;\n      struct tm const *tm;\n      if (! parse_datetime (&d, buff, NULL))\n        printf (\"Bad format - couldn't convert.\\n\");\n      else if (! (tm = localtime (&d.tv_sec)))\n        {\n          intmax_t sec = d.tv_sec;\n          printf (\"localtime (%\"PRIdMAX\") failed\\n\", sec);\n        }\n      else\n        {\n          int ns = d.tv_nsec;\n          char tm_year_buf[TM_YEAR_BUFSIZE];\n          printf (\"%s-%02d-%02d %02d:%02d:%02d.%09d\\n\",\n                  tm_year_str (tm->tm_year, tm_year_buf),\n                  tm->tm_mon + 1, tm->tm_mday,\n                  tm->tm_hour, tm->tm_min, tm->tm_sec, ns);\n        }\n      printf (\"\\t> \");\n      fflush (stdout);\n    }\n  return 0;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/parse-datetime.h": {},
  "patch/patch-2.7.6/lib/parse-datetime.y": {
    "time_overflow": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static bool\ntime_overflow (intmax_t n)\n{\n  return ! ((TYPE_SIGNED (time_t) ? TYPE_MINIMUM (time_t) <= n : 0 <= n)\n            && n <= TYPE_MAXIMUM (time_t));\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "to_uchar": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        133,
        54
      ],
      "content": "static unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "_GL_ATTRIBUTE_FORMAT": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static void _GL_ATTRIBUTE_FORMAT ((__printf__, 1, 2))\ndbg_printf (char const *msg, ...)\n{\n  va_list args;\n  /* TODO: use gnulib's 'program_name' instead?  */\n  fputs (\"date: \", stderr);\n\n  va_start (args, msg);\n  vfprintf (stderr, msg, args);\n  va_end (args);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "digits_to_date_time": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static void\ndigits_to_date_time (parser_control *pc, textint text_int)\n{\n  if (pc->dates_seen && ! pc->year.digits\n      && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n    {\n      pc->year_seen = true;\n      pc->year = text_int;\n    }\n  else\n    {\n      if (4 < text_int.digits)\n        {\n          pc->dates_seen++;\n          pc->day = text_int.value % 100;\n          pc->month = (text_int.value / 100) % 100;\n          pc->year.value = text_int.value / 10000;\n          pc->year.digits = text_int.digits - 4;\n        }\n      else\n        {\n          pc->times_seen++;\n          if (text_int.digits <= 2)\n            {\n              pc->hour = text_int.value;\n              pc->minutes = 0;\n            }\n          else\n            {\n              pc->hour = text_int.value / 100;\n              pc->minutes = text_int.value % 100;\n            }\n          pc->seconds.tv_sec = 0;\n          pc->seconds.tv_nsec = 0;\n          pc->meridian = MER24;\n        }\n    }\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_relative_time": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "static bool\napply_relative_time (parser_control *pc, relative_time rel, int factor)\n{\n  if (factor < 0\n      ? (INT_SUBTRACT_WRAPV (pc->rel.ns, rel.ns, &pc->rel.ns)\n         | INT_SUBTRACT_WRAPV (pc->rel.seconds, rel.seconds, &pc->rel.seconds)\n         | INT_SUBTRACT_WRAPV (pc->rel.minutes, rel.minutes, &pc->rel.minutes)\n         | INT_SUBTRACT_WRAPV (pc->rel.hour, rel.hour, &pc->rel.hour)\n         | INT_SUBTRACT_WRAPV (pc->rel.day, rel.day, &pc->rel.day)\n         | INT_SUBTRACT_WRAPV (pc->rel.month, rel.month, &pc->rel.month)\n         | INT_SUBTRACT_WRAPV (pc->rel.year, rel.year, &pc->rel.year))\n      : (INT_ADD_WRAPV (pc->rel.ns, rel.ns, &pc->rel.ns)\n         | INT_ADD_WRAPV (pc->rel.seconds, rel.seconds, &pc->rel.seconds)\n         | INT_ADD_WRAPV (pc->rel.minutes, rel.minutes, &pc->rel.minutes)\n         | INT_ADD_WRAPV (pc->rel.hour, rel.hour, &pc->rel.hour)\n         | INT_ADD_WRAPV (pc->rel.day, rel.day, &pc->rel.day)\n         | INT_ADD_WRAPV (pc->rel.month, rel.month, &pc->rel.month)\n         | INT_ADD_WRAPV (pc->rel.year, rel.year, &pc->rel.year)))\n    return false;\n  pc->rels_seen = true;\n  return true;\n}",
      "lines": 22,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "set_hhmmss": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nset_hhmmss (parser_control *pc, intmax_t hour, intmax_t minutes,\n            time_t sec, int nsec)\n{\n  pc->hour = hour;\n  pc->minutes = minutes;\n  pc->seconds.tv_sec = sec;\n  pc->seconds.tv_nsec = nsec;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "str_days": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "static const char *\nstr_days (parser_control *pc, char *buffer, int n)\n{\n  /* TODO: use relative_time_table for reverse lookup.  */\n  static char const ordinal_values[][11] = {\n     \"last\",\n     \"this\",\n     \"next/first\",\n     \"(SECOND)\", /* SECOND is commented out in relative_time_table.  */\n     \"third\",\n     \"fourth\",\n     \"fifth\",\n     \"sixth\",\n     \"seventh\",\n     \"eight\",\n     \"ninth\",\n     \"tenth\",\n     \"eleventh\",\n     \"twelfth\"\n  };\n\n  static char const days_values[][4] = {\n     \"Sun\",\n     \"Mon\",\n     \"Tue\",\n     \"Wed\",\n     \"Thu\",\n     \"Fri\",\n     \"Sat\"\n  };\n\n  int len;\n\n  /* Don't add an ordinal prefix if the user didn't specify it\n     (e.g., \"this wed\" vs \"wed\").  */\n  if (pc->debug_ordinal_day_seen)\n    {\n      /* Use word description if possible (e.g., -1 = last, 3 = third).  */\n      len = (-1 <= pc->day_ordinal && pc->day_ordinal <= 12\n             ? snprintf (buffer, n, \"%s\", ordinal_values[pc->day_ordinal + 1])\n             : snprintf (buffer, n, \"%\"PRIdMAX, pc->day_ordinal));\n    }\n  else\n    {\n      buffer[0] = '\\0';\n      len = 0;\n    }\n\n  /* Add the day name */\n  if (0 <= pc->day_number && pc->day_number <= 6 && 0 <= len && len < n)\n    snprintf (buffer + len, n - len, &\" %s\"[len == 0],\n              days_values[pc->day_number]);\n  else\n    {\n      /* invalid day_number value - should never happen */\n    }\n  return buffer;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nstr_days (parser_control *pc, char *buffer, int n)",
        "*"
      ]
    },
    "time_zone_str": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "static char const *\ntime_zone_str (int time_zone, char time_zone_buf[TIME_ZONE_BUFSIZE])\n{\n  char *p = time_zone_buf;\n  char sign = time_zone < 0 ? '-' : '+';\n  int hour = abs (time_zone / (60 * 60));\n  p += sprintf (time_zone_buf, \"%c%02d\", sign, hour);\n  int offset_from_hour = abs (time_zone % (60 * 60));\n  if (offset_from_hour != 0)\n    {\n      int mm = offset_from_hour / 60;\n      int ss = offset_from_hour % 60;\n      *p++ = ':';\n      *p++ = '0' + mm / 10;\n      *p++ = '0' + mm % 10;\n      if (ss)\n        {\n          *p++ = ':';\n          *p++ = '0' + ss / 10;\n          *p++ = '0' + ss % 10;\n        }\n      *p = '\\0';\n    }\n  return time_zone_buf;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ntime_zone_str (int time_zone, char time_zone_buf[TIME_ZONE_BUFSIZE])",
        "*"
      ]
    },
    "debug_print_current_time": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "static void\ndebug_print_current_time (char const *item, parser_control *pc)\n{\n  bool space = false;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  /* no newline, more items printed below */\n  dbg_printf (_(\"parsed %s part: \"), item);\n\n  if (pc->dates_seen && !pc->debug_dates_seen)\n    {\n      /*TODO: use pc->year.negative?  */\n      fprintf (stderr, \"(Y-M-D) %04\"PRIdMAX\"-%02\"PRIdMAX\"-%02\"PRIdMAX,\n              pc->year.value, pc->month, pc->day);\n      pc->debug_dates_seen = true;\n      space = true;\n    }\n\n  if (pc->year_seen != pc->debug_year_seen)\n    {\n      if (space)\n        fputc (' ', stderr);\n      fprintf (stderr, _(\"year: %04\"PRIdMAX), pc->year.value);\n\n      pc->debug_year_seen = pc->year_seen;\n      space = true;\n    }\n\n  if (pc->times_seen && !pc->debug_times_seen)\n    {\n      intmax_t sec = pc->seconds.tv_sec;\n      fprintf (stderr, &\" %02\"PRIdMAX\":%02\"PRIdMAX\":%02\"PRIdMAX[!space],\n               pc->hour, pc->minutes, sec);\n      if (pc->seconds.tv_nsec != 0)\n        {\n          int nsec = pc->seconds.tv_nsec;\n          fprintf (stderr, \".%09d\", nsec);\n        }\n      if (pc->meridian == MERpm)\n        fputs (\"pm\", stderr);\n\n      pc->debug_times_seen = true;\n      space = true;\n    }\n\n  if (pc->days_seen && !pc->debug_days_seen)\n    {\n      if (space)\n        fputc (' ', stderr);\n      char tmp[DBGBUFSIZE];\n      fprintf (stderr, _(\"%s (day ordinal=%\"PRIdMAX\" number=%d)\"),\n               str_days (pc, tmp, sizeof tmp),\n               pc->day_ordinal, pc->day_number);\n      pc->debug_days_seen = true;\n      space = true;\n    }\n\n  /* local zone strings only change the DST settings,\n     not the timezone value.  If seen, inform about the DST.  */\n  if (pc->local_zones_seen && !pc->debug_local_zones_seen)\n    {\n      fprintf (stderr, &\" isdst=%d%s\"[!space],\n\t       pc->local_isdst, pc->dsts_seen ? \" DST\" : \"\");\n      pc->debug_local_zones_seen = true;\n      space = true;\n    }\n\n  if (pc->zones_seen && !pc->debug_zones_seen)\n    {\n      char time_zone_buf[TIME_ZONE_BUFSIZE];\n      fprintf (stderr, &\" UTC%s\"[!space],\n               time_zone_str (pc->time_zone, time_zone_buf));\n      pc->debug_zones_seen = true;\n      space = true;\n    }\n\n  if (pc->timespec_seen)\n    {\n      intmax_t sec = pc->seconds.tv_sec;\n      if (space)\n        fputc (' ', stderr);\n      fprintf (stderr, _(\"number of seconds: %\"PRIdMAX), sec);\n    }\n\n  fputc ('\\n', stderr);\n}",
      "lines": 88,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_rel_part": {
      "start_point": [
        521,
        0
      ],
      "end_point": [
        528,
        1
      ],
      "content": "static bool\nprint_rel_part (bool space, intmax_t val, char const *name)\n{\n  if (val == 0)\n    return space;\n  fprintf (stderr, &\" %+\"PRIdMAX\" %s\"[!space], val, name);\n  return true;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "debug_print_relative_time": {
      "start_point": [
        530,
        0
      ],
      "end_point": [
        559,
        1
      ],
      "content": "static void\ndebug_print_relative_time (char const *item, parser_control const *pc)\n{\n  bool space = false;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  /* no newline, more items printed below */\n  dbg_printf (_(\"parsed %s part: \"), item);\n\n  if (pc->rel.year == 0 && pc->rel.month == 0 && pc->rel.day == 0\n      && pc->rel.hour == 0 && pc->rel.minutes == 0 && pc->rel.seconds == 0\n      && pc->rel.ns == 0)\n    {\n      /* Special case: relative time of this/today/now */\n      fputs (_(\"today/this/now\\n\"), stderr);\n      return;\n    }\n\n  space = print_rel_part (space, pc->rel.year, \"year(s)\");\n  space = print_rel_part (space, pc->rel.month, \"month(s)\");\n  space = print_rel_part (space, pc->rel.day, \"day(s)\");\n  space = print_rel_part (space, pc->rel.hour, \"hour(s)\");\n  space = print_rel_part (space, pc->rel.minutes, \"minutes\");\n  space = print_rel_part (space, pc->rel.seconds, \"seconds\");\n  print_rel_part (space, pc->rel.ns, \"nanoseconds\");\n\n  fputc ('\\n', stderr);\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tZONE": [
      {
        "start_point": [
          684,
          30
        ],
        "end_point": [
          688,
          7
        ],
        "content": "unsigned_seconds tMERIDIAN\n      {\n        set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);\n        pc->meridian = $6;\n      }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          703,
          30
        ],
        "end_point": [
          707,
          7
        ],
        "content": "unsigned_seconds o_zone_offset\n      {\n        set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);\n        pc->meridian = MER24;\n      }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          743,
          4
        ],
        "end_point": [
          747,
          7
        ],
        "content": "tLOCAL_ZONE tDST\n      {\n        pc->local_isdst = 1;\n        pc->dsts_seen++;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          757,
          4
        ],
        "end_point": [
          761,
          7
        ],
        "content": "tZONE relunit_snumber\n      { pc->time_zone = $1;\n        if (! apply_relative_time (pc, $2, 1)) YYABORT;\n        debug_print_relative_time (_(\"relative\"), pc);\n      }",
        "lines": 5,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          767,
          4
        ],
        "end_point": [
          769,
          73
        ],
        "content": "tZONE tSNUMBER o_colon_minutes\n      { if (! time_zone_hhmm (pc, $2, $3)) YYABORT;\n        if (INT_ADD_WRAPV (pc->time_zone, $1, &pc->time_zone)) YYABORT; }",
        "lines": 3,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          772,
          4
        ],
        "end_point": [
          773,
          39
        ],
        "content": "tZONE tDST\n      { pc->time_zone = $1 + 60 * 60; }",
        "lines": 2,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          787,
          4
        ],
        "end_point": [
          792,
          7
        ],
        "content": "tORDINAL tDAY\n      {\n        pc->day_ordinal = $1;\n        pc->day_number = $2;\n        pc->debug_ordinal_day_seen = true;\n      }",
        "lines": 6,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          793,
          4
        ],
        "end_point": [
          798,
          7
        ],
        "content": "tUNUMBER tDAY\n      {\n        pc->day_ordinal = $1.value;\n        pc->day_number = $2;\n        pc->debug_ordinal_day_seen = true;\n      }",
        "lines": 6,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          840,
          4
        ],
        "end_point": [
          847,
          7
        ],
        "content": "tUNUMBER tMONTH tSNUMBER\n      {\n        /* E.g., 17-JUN-1992.  */\n        pc->day = $1.value;\n        pc->month = $2;\n        if (INT_SUBTRACT_WRAPV (0, $3.value, &pc->year.value)) YYABORT;\n        pc->year.digits = $3.digits;\n      }",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          848,
          4
        ],
        "end_point": [
          855,
          7
        ],
        "content": "tMONTH tSNUMBER tSNUMBER\n      {\n        /* E.g., JUN-17-1992.  */\n        pc->month = $1;\n        if (INT_SUBTRACT_WRAPV (0, $2.value, &pc->day)) YYABORT;\n        if (INT_SUBTRACT_WRAPV (0, $3.value, &pc->year.value)) YYABORT;\n        pc->year.digits = $3.digits;\n      }",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          856,
          4
        ],
        "end_point": [
          860,
          7
        ],
        "content": "tMONTH tUNUMBER\n      {\n        pc->month = $1;\n        pc->day = $2.value;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      }
    ],
    "tUNUMBER": [
      {
        "start_point": [
          867,
          4
        ],
        "end_point": [
          871,
          7
        ],
        "content": "tUNUMBER tMONTH\n      {\n        pc->day = $1.value;\n        pc->month = $2;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          872,
          4
        ],
        "end_point": [
          877,
          7
        ],
        "content": "tUNUMBER tMONTH tUNUMBER\n      {\n        pc->day = $1.value;\n        pc->month = $2;\n        pc->year = $3;\n      }",
        "lines": 6,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          882,
          13
        ],
        "end_point": [
          888,
          7
        ],
        "content": "tSNUMBER tSNUMBER\n      {\n        /* ISO 8601 format.  YYYY-MM-DD.  */\n        pc->year = $1;\n        if (INT_SUBTRACT_WRAPV (0, $2.value, &pc->month)) YYABORT;\n        if (INT_SUBTRACT_WRAPV (0, $3.value, &pc->day)) YYABORT;\n      }",
        "lines": 7,
        "depth": 9,
        "decorators": null
      }
    ],
    "tMONTH_UNIT": [
      {
        "start_point": [
          913,
          4
        ],
        "end_point": [
          915,
          60
        ],
        "content": "tORDINAL tDAY_UNIT\n      { $$ = RELATIVE_TIME_0;\n        if (INT_MULTIPLY_WRAPV ($1, $2, &$$.day)) YYABORT; }",
        "lines": 3,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          916,
          4
        ],
        "end_point": [
          918,
          66
        ],
        "content": "tUNUMBER tDAY_UNIT\n      { $$ = RELATIVE_TIME_0;\n        if (INT_MULTIPLY_WRAPV ($1.value, $2, &$$.day)) YYABORT; }",
        "lines": 3,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          951,
          4
        ],
        "end_point": [
          953,
          66
        ],
        "content": "tSNUMBER tDAY_UNIT\n      { $$ = RELATIVE_TIME_0;\n        if (INT_MULTIPLY_WRAPV ($1.value, $2, &$$.day)) YYABORT; }",
        "lines": 3,
        "depth": 9,
        "decorators": null
      }
    ],
    "time_zone_hhmm": {
      "start_point": [
        1203,
        0
      ],
      "end_point": [
        1228,
        1
      ],
      "content": "static bool\ntime_zone_hhmm (parser_control *pc, textint s, intmax_t mm)\n{\n  intmax_t n_minutes;\n  bool overflow = false;\n\n  /* If the length of S is 1 or 2 and no minutes are specified,\n     interpret it as a number of hours.  */\n  if (s.digits <= 2 && mm < 0)\n    s.value *= 100;\n\n  if (mm < 0)\n    n_minutes = (s.value / 100) * 60 + s.value % 100;\n  else\n    {\n      overflow |= INT_MULTIPLY_WRAPV (s.value, 60, &n_minutes);\n      overflow |= (s.negative\n                   ? INT_SUBTRACT_WRAPV (n_minutes, mm, &n_minutes)\n                   : INT_ADD_WRAPV (n_minutes, mm, &n_minutes));\n    }\n\n  if (overflow || ! (-24 * 60 <= n_minutes && n_minutes <= 24 * 60))\n    return false;\n  pc->time_zone = n_minutes * 60;\n  return true;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "to_hour": {
      "start_point": [
        1230,
        0
      ],
      "end_point": [
        1243,
        1
      ],
      "content": "static int\nto_hour (intmax_t hours, int meridian)\n{\n  switch (meridian)\n    {\n    default: /* Pacify GCC.  */\n    case MER24:\n      return 0 <= hours && hours < 24 ? hours : -1;\n    case MERam:\n      return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n    case MERpm:\n      return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tm_year_str": {
      "start_point": [
        1251,
        0
      ],
      "end_point": [
        1259,
        1
      ],
      "content": "static char const *\ntm_year_str (int tm_year, char buf[TM_YEAR_BUFSIZE])\n{\n  verify (TM_YEAR_BASE % 100 == 0);\n  sprintf (buf, &\"-%02d%02d\"[-TM_YEAR_BASE <= tm_year],\n           abs (tm_year / 100 + TM_YEAR_BASE / 100),\n           abs (tm_year % 100));\n  return buf;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ntm_year_str (int tm_year, char buf[TM_YEAR_BUFSIZE])",
        "*"
      ]
    },
    "to_tm_year": {
      "start_point": [
        1264,
        0
      ],
      "end_point": [
        1290,
        1
      ],
      "content": "static bool\nto_tm_year (textint textyear, bool debug, int *tm_year)\n{\n  intmax_t year = textyear.value;\n\n  /* XPG4 suggests that years 00-68 map to 2000-2068, and\n     years 69-99 map to 1969-1999.  */\n  if (0 <= year && textyear.digits == 2)\n    {\n      year += year < 69 ? 2000 : 1900;\n      if (debug)\n        dbg_printf (_(\"warning: adjusting year value %\"PRIdMAX\n                      \" to %\"PRIdMAX\"\\n\"),\n                    textyear.value, year);\n    }\n\n  if (year < 0\n      ? INT_SUBTRACT_WRAPV (-TM_YEAR_BASE, year, tm_year)\n      : INT_SUBTRACT_WRAPV (year, TM_YEAR_BASE, tm_year))\n    {\n      if (debug)\n        dbg_printf (_(\"error: out-of-range year %\"PRIdMAX\"\\n\"), year);\n      return false;\n    }\n\n  return true;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "lookup_zone": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1312,
        1
      ],
      "content": "static table const * _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)\n{\n  table const *tp;\n\n  for (tp = universal_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  /* Try local zone abbreviations before those in time_zone_table, as\n     the local ones are more likely to be right.  */\n  for (tp = pc->local_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  for (tp = time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "tm_diff": {
      "start_point": [
        1319,
        0
      ],
      "end_point": [
        1338,
        1
      ],
      "content": "static int\ntm_diff (const struct tm *a, const struct tm *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations,\n     but it's OK to assume that A and B are close to each other.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  int years = a->tm_year - b->tm_year;\n  int days = (365 * years + intervening_leap_days\n              + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lookup_word": {
      "start_point": [
        1341,
        0
      ],
      "end_point": [
        1407,
        1
      ],
      "content": "static table const *\nlookup_word (parser_control const *pc, char *word)\n{\n  char *p;\n  char *q;\n  ptrdiff_t wordlen;\n  table const *tp;\n  bool period_found;\n  bool abbrev;\n\n  /* Make it uppercase.  */\n  for (p = word; *p; p++)\n    *p = c_toupper (to_uchar (*p));\n\n  for (tp = meridian_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* See if we have an abbreviation for a month.  */\n  wordlen = strlen (word);\n  abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n\n  for (tp = month_and_day_table; tp->name; tp++)\n    if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n      return tp;\n\n  if ((tp = lookup_zone (pc, word)))\n    return tp;\n\n  if (strcmp (word, dst_table[0].name) == 0)\n    return dst_table;\n\n  for (tp = time_units_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Strip off any plural and try the units table again.  */\n  if (word[wordlen - 1] == 'S')\n    {\n      word[wordlen - 1] = '\\0';\n      for (tp = time_units_table; tp->name; tp++)\n        if (strcmp (word, tp->name) == 0)\n          return tp;\n      word[wordlen - 1] = 'S';  /* For \"this\" in relative_time_table.  */\n    }\n\n  for (tp = relative_time_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Military time zones.  */\n  if (wordlen == 1)\n    for (tp = military_table; tp->name; tp++)\n      if (word[0] == tp->name[0])\n        return tp;\n\n  /* Drop out any periods and try the time zone table again.  */\n  for (period_found = false, p = q = word; (*p = *q); q++)\n    if (*q == '.')\n      period_found = true;\n    else\n      p++;\n  if (period_found && (tp = lookup_zone (pc, word)))\n    return tp;\n\n  return NULL;\n}",
      "lines": 67,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "*\nlookup_word (parser_control const *pc, char *word)",
        "*"
      ]
    },
    "yylex": {
      "start_point": [
        1409,
        0
      ],
      "end_point": [
        1546,
        1
      ],
      "content": "static int\nyylex (union YYSTYPE *lvalp, parser_control *pc)\n{\n  unsigned char c;\n\n  for (;;)\n    {\n      while (c = *pc->input, c_isspace (c))\n        pc->input++;\n\n      if (c_isdigit (c) || c == '-' || c == '+')\n        {\n          char const *p;\n          int sign;\n          intmax_t value = 0;\n          if (c == '-' || c == '+')\n            {\n              sign = c == '-' ? -1 : 1;\n              while (c = *++pc->input, c_isspace (c))\n                continue;\n              if (! c_isdigit (c))\n                /* skip the '-' sign */\n                continue;\n            }\n          else\n            sign = 0;\n          p = pc->input;\n\n          do\n            {\n              if (INT_MULTIPLY_WRAPV (value, 10, &value))\n                return '?';\n              if (INT_ADD_WRAPV (value, sign < 0 ? '0' - c : c - '0', &value))\n                return '?';\n              c = *++p;\n            }\n          while (c_isdigit (c));\n\n          if ((c == '.' || c == ',') && c_isdigit (p[1]))\n            {\n              time_t s;\n              int ns;\n              int digits;\n\n              if (time_overflow (value))\n                return '?';\n              s = value;\n\n              /* Accumulate fraction, to ns precision.  */\n              p++;\n              ns = *p++ - '0';\n              for (digits = 2; digits <= LOG10_BILLION; digits++)\n                {\n                  ns *= 10;\n                  if (c_isdigit (*p))\n                    ns += *p++ - '0';\n                }\n\n              /* Skip excess digits, truncating toward -Infinity.  */\n              if (sign < 0)\n                for (; c_isdigit (*p); p++)\n                  if (*p != '0')\n                    {\n                      ns++;\n                      break;\n                    }\n              while (c_isdigit (*p))\n                p++;\n\n              /* Adjust to the timespec convention, which is that\n                 tv_nsec is always a positive offset even if tv_sec is\n                 negative.  */\n              if (sign < 0 && ns)\n                {\n                  if (s == TYPE_MINIMUM (time_t))\n                    return '?';\n                  s--;\n                  ns = BILLION - ns;\n                }\n\n              lvalp->timespec.tv_sec = s;\n              lvalp->timespec.tv_nsec = ns;\n              pc->input = p;\n              return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n            }\n          else\n            {\n              lvalp->textintval.negative = sign < 0;\n              lvalp->textintval.value = value;\n              lvalp->textintval.digits = p - pc->input;\n              pc->input = p;\n              return sign ? tSNUMBER : tUNUMBER;\n            }\n        }\n\n      if (c_isalpha (c))\n        {\n          char buff[20];\n          char *p = buff;\n          table const *tp;\n\n          do\n            {\n              if (p < buff + sizeof buff - 1)\n                *p++ = c;\n              c = *++pc->input;\n            }\n          while (c_isalpha (c) || c == '.');\n\n          *p = '\\0';\n          tp = lookup_word (pc, buff);\n          if (! tp)\n            {\n              if (pc->parse_datetime_debug)\n                dbg_printf (_(\"error: unknown word '%s'\\n\"), buff);\n              return '?';\n            }\n          lvalp->intval = tp->value;\n          return tp->type;\n        }\n\n      if (c != '(')\n        return to_uchar (*pc->input++);\n\n      ptrdiff_t count = 0;\n      do\n        {\n          c = *pc->input++;\n          if (c == '\\0')\n            return c;\n          if (c == '(')\n            count++;\n          else if (c == ')')\n            count--;\n        }\n      while (count != 0);\n    }\n}",
      "lines": 138,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        1549,
        0
      ],
      "end_point": [
        1554,
        1
      ],
      "content": "static int\nyyerror (parser_control const *pc _GL_UNUSED,\n         char const *s _GL_UNUSED)\n{\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mktime_ok": {
      "start_point": [
        1561,
        0
      ],
      "end_point": [
        1581,
        1
      ],
      "content": "static bool\nmktime_ok (timezone_t tz, struct tm const *tm0, struct tm const *tm1, time_t t)\n{\n  struct tm ltm;\n  if (t == (time_t) -1)\n    {\n      /* Guard against falsely reporting an error when parsing a\n         timestamp that happens to equal (time_t) -1, on a host that\n         supports such a timestamp.  */\n      tm1 = localtime_rz (tz, &t, &ltm);\n      if (!tm1)\n        return false;\n    }\n\n  return ! ((tm0->tm_sec ^ tm1->tm_sec)\n            | (tm0->tm_min ^ tm1->tm_min)\n            | (tm0->tm_hour ^ tm1->tm_hour)\n            | (tm0->tm_mday ^ tm1->tm_mday)\n            | (tm0->tm_mon ^ tm1->tm_mon)\n            | (tm0->tm_year ^ tm1->tm_year));\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "debug_strfdatetime": {
      "start_point": [
        1585,
        0
      ],
      "end_point": [
        1628,
        1
      ],
      "content": "static char const *\ndebug_strfdatetime (struct tm const *tm, parser_control const *pc,\n                    char *buf, int n)\n{\n  /* TODO:\n     1. find an optimal way to print date string in a clear and unambiguous\n        format.  Currently, always add '(Y-M-D)' prefix.\n        Consider '2016y01m10d'  or 'year(2016) month(01) day(10)'.\n\n        If the user needs debug printing, it means he/she already having\n        issues with the parsing - better to avoid formats that could\n        be mis-interpreted (e.g., just YYYY-MM-DD).\n\n     2. Can strftime be used instead?\n        depends if it is portable and can print invalid dates on all systems.\n\n     3. Print timezone information ?\n\n     4. Print DST information ?\n\n     5. Print nanosecond information ?\n\n     NOTE:\n     Printed date/time values might not be valid, e.g., '2016-02-31'\n     or '2016-19-2016' .  These are the values as parsed from the user\n     string, before validation.\n  */\n  int m = nstrftime (buf, n, \"(Y-M-D) %Y-%m-%d %H:%M:%S\", tm, 0, 0);\n\n  /* If parser_control information was provided (for timezone),\n     and there's enough space in the buffer, add timezone info.  */\n  if (pc && m < n && pc->zones_seen)\n    {\n      int tz = pc->time_zone;\n\n      /* Account for DST if tLOCAL_ZONE was seen.  */\n      if (pc->local_zones_seen && !pc->zones_seen && 0 < pc->local_isdst)\n        tz += 60 * 60;\n\n      char time_zone_buf[TIME_ZONE_BUFSIZE];\n      snprintf (&buf[m], n - m, \" TZ=%s\", time_zone_str (tz, time_zone_buf));\n    }\n  return buf;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strfdatetime (struct tm const *tm, parser_control const *pc,\n                    char *buf, int n)",
        "*"
      ]
    },
    "debug_strfdate": {
      "start_point": [
        1630,
        0
      ],
      "end_point": [
        1638,
        1
      ],
      "content": "static char const *\ndebug_strfdate (struct tm const *tm, char *buf, int n)\n{\n  char tm_year_buf[TM_YEAR_BUFSIZE];\n  snprintf (buf, n, \"(Y-M-D) %s-%02d-%02d\",\n            tm_year_str (tm->tm_year, tm_year_buf),\n            tm->tm_mon + 1, tm->tm_mday);\n  return buf;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strfdate (struct tm const *tm, char *buf, int n)",
        "*"
      ]
    },
    "debug_strftime": {
      "start_point": [
        1640,
        0
      ],
      "end_point": [
        1645,
        1
      ],
      "content": "static char const *\ndebug_strftime (struct tm const *tm, char *buf, int n)\n{\n  snprintf (buf, n, \"%02d:%02d:%02d\", tm->tm_hour, tm->tm_min, tm->tm_sec);\n  return buf;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strftime (struct tm const *tm, char *buf, int n)",
        "*"
      ]
    },
    "debug_mktime_not_ok": {
      "start_point": [
        1659,
        0
      ],
      "end_point": [
        1713,
        1
      ],
      "content": "static void\ndebug_mktime_not_ok (struct tm const *tm0, struct tm const *tm1,\n                     parser_control const *pc, bool time_zone_seen)\n{\n  /* TODO: handle t == -1 (as in 'mktime_ok').  */\n  char tmp[DBGBUFSIZE];\n  int i;\n  const bool eq_sec   = (tm0->tm_sec  == tm1->tm_sec);\n  const bool eq_min   = (tm0->tm_min  == tm1->tm_min);\n  const bool eq_hour  = (tm0->tm_hour == tm1->tm_hour);\n  const bool eq_mday  = (tm0->tm_mday == tm1->tm_mday);\n  const bool eq_month = (tm0->tm_mon  == tm1->tm_mon);\n  const bool eq_year  = (tm0->tm_year == tm1->tm_year);\n\n  const bool dst_shift = eq_sec && eq_min && !eq_hour\n                         && eq_mday && eq_month && eq_year;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  dbg_printf (_(\"error: invalid date/time value:\\n\"));\n  dbg_printf (_(\"    user provided time: '%s'\\n\"),\n              debug_strfdatetime (tm0, pc, tmp, sizeof tmp));\n  dbg_printf (_(\"       normalized time: '%s'\\n\"),\n              debug_strfdatetime (tm1, pc, tmp, sizeof tmp));\n  /* The format must be aligned with debug_strfdatetime and the two\n     DEBUG statements above.  This string is not translated.  */\n  i = snprintf (tmp, sizeof tmp,\n                \"                                 %4s %2s %2s %2s %2s %2s\",\n                eq_year ? \"\" : \"----\",\n                eq_month ? \"\" : \"--\",\n                eq_mday ? \"\" : \"--\",\n                eq_hour ? \"\" : \"--\",\n                eq_min ? \"\" : \"--\",\n                eq_sec ? \"\" : \"--\");\n  /* Trim trailing whitespace.  */\n  if (0 <= i)\n    {\n      if (sizeof tmp - 1 < i)\n        i = sizeof tmp - 1;\n      while (0 < i && tmp[i - 1] == ' ')\n        --i;\n      tmp[i] = '\\0';\n    }\n  dbg_printf (\"%s\\n\", tmp);\n\n  dbg_printf (_(\"     possible reasons:\\n\"));\n  if (dst_shift)\n    dbg_printf (_(\"       non-existing due to daylight-saving time;\\n\"));\n  if (!eq_mday && !eq_month)\n    dbg_printf (_(\"       invalid day/month combination;\\n\"));\n  dbg_printf (_(\"       numeric values overflow;\\n\"));\n  dbg_printf (\"       %s\\n\", (time_zone_seen ? _(\"incorrect timezone\")\n                              : _(\"missing timezone\")));\n}",
      "lines": 55,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_datetime": {
      "start_point": [
        1716,
        0
      ],
      "end_point": [
        1727,
        1
      ],
      "content": "bool\nparse_datetime (struct timespec *result, char const *p,\n                struct timespec const *now)\n{\n  char const *tzstring = getenv (\"TZ\");\n  timezone_t tz = tzalloc (tzstring);\n  if (!tz)\n    return false;\n  bool ok = parse_datetime2 (result, p, now, 0, tz, tzstring);\n  tzfree (tz);\n  return ok;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "parse_datetime2": {
      "start_point": [
        1734,
        0
      ],
      "end_point": [
        2389,
        1
      ],
      "content": "bool\nparse_datetime2 (struct timespec *result, char const *p,\n                 struct timespec const *now, unsigned int flags,\n                 timezone_t tzdefault, char const *tzstring)\n{\n  struct tm tm;\n  struct tm tm0;\n  char time_zone_buf[TIME_ZONE_BUFSIZE];\n  char dbg_tm[DBGBUFSIZE];\n  bool ok = false;\n  char const *input_sentinel = p + strlen (p);\n  char *tz1alloc = NULL;\n\n  /* A reasonable upper bound for the size of ordinary TZ strings.\n     Use heap allocation if TZ's length exceeds this.  */\n  enum { TZBUFSIZE = 100 };\n  char tz1buf[TZBUFSIZE];\n\n  struct timespec gettime_buffer;\n  if (! now)\n    {\n      gettime (&gettime_buffer);\n      now = &gettime_buffer;\n    }\n\n  time_t Start = now->tv_sec;\n  int Start_ns = now->tv_nsec;\n\n  unsigned char c;\n  while (c = *p, c_isspace (c))\n    p++;\n\n  timezone_t tz = tzdefault;\n\n  if (strncmp (p, \"TZ=\\\"\", 4) == 0)\n    {\n      char const *tzbase = p + 4;\n      ptrdiff_t tzsize = 1;\n      char const *s;\n\n      for (s = tzbase; *s; s++, tzsize++)\n        if (*s == '\\\\')\n          {\n            s++;\n            if (! (*s == '\\\\' || *s == '\"'))\n              break;\n          }\n        else if (*s == '\"')\n          {\n            timezone_t tz1;\n            char *tz1string = tz1buf;\n            char *z;\n            if (TZBUFSIZE < tzsize)\n              {\n                tz1alloc = malloc (tzsize);\n                if (!tz1alloc)\n                  goto fail;\n                tz1string = tz1alloc;\n              }\n            z = tz1string;\n            for (s = tzbase; *s != '\"'; s++)\n              *z++ = *(s += *s == '\\\\');\n            *z = '\\0';\n            tz1 = tzalloc (tz1string);\n            if (!tz1)\n              goto fail;\n            tz = tz1;\n            tzstring = tz1string;\n\n            p = s + 1;\n            while (c = *p, c_isspace (c))\n              p++;\n\n            break;\n          }\n    }\n\n  struct tm tmp;\n  if (! localtime_rz (tz, &now->tv_sec, &tmp))\n    goto fail;\n\n  /* As documented, be careful to treat the empty string just like\n     a date string of \"0\".  Without this, an empty string would be\n     declared invalid when parsed during a DST transition.  */\n  if (*p == '\\0')\n    p = \"0\";\n\n  parser_control pc;\n  pc.input = p;\n  pc.parse_datetime_debug = (flags & PARSE_DATETIME_DEBUG) != 0;\n  if (INT_ADD_WRAPV (tmp.tm_year, TM_YEAR_BASE, &pc.year.value))\n    {\n      if (pc.parse_datetime_debug)\n        dbg_printf (_(\"error: initial year out of range\\n\"));\n      goto fail;\n    }\n  pc.year.digits = 0;\n  pc.month = tmp.tm_mon + 1;\n  pc.day = tmp.tm_mday;\n  pc.hour = tmp.tm_hour;\n  pc.minutes = tmp.tm_min;\n  pc.seconds.tv_sec = tmp.tm_sec;\n  pc.seconds.tv_nsec = Start_ns;\n  tm.tm_isdst = tmp.tm_isdst;\n\n  pc.meridian = MER24;\n  pc.rel = RELATIVE_TIME_0;\n  pc.timespec_seen = false;\n  pc.rels_seen = false;\n  pc.dates_seen = 0;\n  pc.days_seen = 0;\n  pc.times_seen = 0;\n  pc.local_zones_seen = 0;\n  pc.dsts_seen = 0;\n  pc.zones_seen = 0;\n  pc.year_seen = false;\n  pc.debug_dates_seen = false;\n  pc.debug_days_seen = false;\n  pc.debug_times_seen = false;\n  pc.debug_local_zones_seen = false;\n  pc.debug_zones_seen = false;\n  pc.debug_year_seen = false;\n  pc.debug_ordinal_day_seen = false;\n\n#if HAVE_STRUCT_TM_TM_ZONE\n  pc.local_time_zone_table[0].name = tmp.tm_zone;\n  pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n  pc.local_time_zone_table[0].value = tmp.tm_isdst;\n  pc.local_time_zone_table[1].name = NULL;\n\n  /* Probe the names used in the next three calendar quarters, looking\n     for a tm_isdst different from the one we already have.  */\n  {\n    int quarter;\n    for (quarter = 1; quarter <= 3; quarter++)\n      {\n        intmax_t iprobe;\n        if (INT_ADD_WRAPV (Start, quarter * (90 * 24 * 60 * 60), &iprobe)\n            || time_overflow (iprobe))\n          break;\n        time_t probe = iprobe;\n        struct tm probe_tm;\n        if (localtime_rz (tz, &probe, &probe_tm) && probe_tm.tm_zone\n            && probe_tm.tm_isdst != pc.local_time_zone_table[0].value)\n          {\n              {\n                pc.local_time_zone_table[1].name = probe_tm.tm_zone;\n                pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n                pc.local_time_zone_table[1].value = probe_tm.tm_isdst;\n                pc.local_time_zone_table[2].name = NULL;\n              }\n            break;\n          }\n      }\n  }\n#else\n#if HAVE_TZNAME\n  {\n# if !HAVE_DECL_TZNAME\n    extern char *tzname[];\n# endif\n    int i;\n    for (i = 0; i < 2; i++)\n      {\n        pc.local_time_zone_table[i].name = tzname[i];\n        pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n        pc.local_time_zone_table[i].value = i;\n      }\n    pc.local_time_zone_table[i].name = NULL;\n  }\n#else\n  pc.local_time_zone_table[0].name = NULL;\n#endif\n#endif\n\n  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n      && ! strcmp (pc.local_time_zone_table[0].name,\n                   pc.local_time_zone_table[1].name))\n    {\n      /* This locale uses the same abbreviation for standard and\n         daylight times.  So if we see that abbreviation, we don't\n         know whether it's daylight time.  */\n      pc.local_time_zone_table[0].value = -1;\n      pc.local_time_zone_table[1].name = NULL;\n    }\n\n  if (yyparse (&pc) != 0)\n    {\n      if (pc.parse_datetime_debug)\n        dbg_printf ((input_sentinel <= pc.input\n                     ? _(\"error: parsing failed\\n\")\n                     : _(\"error: parsing failed, stopped at '%s'\\n\")),\n                    pc.input);\n      goto fail;\n    }\n\n\n  /* Determine effective timezone source.  */\n\n  if (pc.parse_datetime_debug)\n    {\n      dbg_printf (_(\"input timezone: \"));\n\n      if (pc.timespec_seen)\n        fprintf (stderr, _(\"'@timespec' - always UTC\"));\n      else if (pc.zones_seen)\n        fprintf (stderr, _(\"parsed date/time string\"));\n      else if (tzstring)\n        {\n          if (tz != tzdefault)\n            fprintf (stderr, _(\"TZ=\\\"%s\\\" in date string\"), tzstring);\n          else if (STREQ (tzstring, \"UTC0\"))\n            {\n              /* Special case: 'date -u' sets TZ=\"UTC0\".  */\n              fprintf (stderr, _(\"TZ=\\\"UTC0\\\" environment value or -u\"));\n            }\n          else\n            fprintf (stderr, _(\"TZ=\\\"%s\\\" environment value\"), tzstring);\n        }\n      else\n        fprintf (stderr, _(\"system default\"));\n\n      /* Account for DST changes if tLOCAL_ZONE was seen.\n         local timezone only changes DST and is relative to the\n         default timezone.*/\n      if (pc.local_zones_seen && !pc.zones_seen && 0 < pc.local_isdst)\n        fprintf (stderr, \", dst\");\n\n      if (pc.zones_seen)\n\tfprintf (stderr, \" (%s)\", time_zone_str (pc.time_zone, time_zone_buf));\n\n      fputc ('\\n', stderr);\n    }\n\n  if (pc.timespec_seen)\n    *result = pc.seconds;\n  else\n    {\n      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n               | (pc.local_zones_seen + pc.zones_seen)))\n        {\n          if (pc.parse_datetime_debug)\n            {\n              if (pc.times_seen > 1)\n                dbg_printf (\"error: seen multiple time parts\\n\");\n              if (pc.dates_seen > 1)\n                dbg_printf (\"error: seen multiple date parts\\n\");\n              if (pc.days_seen > 1)\n                dbg_printf (\"error: seen multiple days parts\\n\");\n              if (pc.dsts_seen > 1)\n                dbg_printf (\"error: seen multiple daylight-saving parts\\n\");\n              if ((pc.local_zones_seen + pc.zones_seen) > 1)\n                dbg_printf (\"error: seen multiple time-zone parts\\n\");\n            }\n          goto fail;\n        }\n\n      if (! to_tm_year (pc.year, pc.parse_datetime_debug, &tm.tm_year)\n          || INT_ADD_WRAPV (pc.month, -1, &tm.tm_mon)\n          || INT_ADD_WRAPV (pc.day, 0, &tm.tm_mday))\n        {\n          if (pc.parse_datetime_debug)\n            dbg_printf (_(\"error: year, month, or day overflow\\n\"));\n          goto fail;\n        }\n      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n        {\n          tm.tm_hour = to_hour (pc.hour, pc.meridian);\n          if (tm.tm_hour < 0)\n            {\n              char const *mrd = (pc.meridian == MERam ? \"am\"\n                                 : pc.meridian == MERpm ?\"pm\" : \"\");\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: invalid hour %\"PRIdMAX\"%s\\n\"),\n                            pc.hour, mrd);\n              goto fail;\n            }\n          tm.tm_min = pc.minutes;\n          tm.tm_sec = pc.seconds.tv_sec;\n          if (pc.parse_datetime_debug)\n            dbg_printf ((pc.times_seen\n                         ? _(\"using specified time as starting value: '%s'\\n\")\n                         : _(\"using current time as starting value: '%s'\\n\")),\n                        debug_strftime (&tm, dbg_tm, sizeof dbg_tm));\n        }\n      else\n        {\n          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n          pc.seconds.tv_nsec = 0;\n          if (pc.parse_datetime_debug)\n            dbg_printf (\"warning: using midnight as starting time: 00:00:00\\n\");\n        }\n\n      /* Let mktime deduce tm_isdst if we have an absolute timestamp.  */\n      if (pc.dates_seen | pc.days_seen | pc.times_seen)\n        tm.tm_isdst = -1;\n\n      /* But if the input explicitly specifies local time with or without\n         DST, give mktime that information.  */\n      if (pc.local_zones_seen)\n        tm.tm_isdst = pc.local_isdst;\n\n      tm0.tm_sec = tm.tm_sec;\n      tm0.tm_min = tm.tm_min;\n      tm0.tm_hour = tm.tm_hour;\n      tm0.tm_mday = tm.tm_mday;\n      tm0.tm_mon = tm.tm_mon;\n      tm0.tm_year = tm.tm_year;\n      tm0.tm_isdst = tm.tm_isdst;\n\n      Start = mktime_z (tz, &tm);\n\n      if (! mktime_ok (tz, &tm0, &tm, Start))\n        {\n          bool repaired = false;\n          bool time_zone_seen = pc.zones_seen != 0;\n          if (time_zone_seen)\n            {\n              /* Guard against falsely reporting errors near the time_t\n                 boundaries when parsing times in other time zones.  For\n                 example, suppose the input string \"1969-12-31 23:00:00 -0100\",\n                 the current time zone is 8 hours ahead of UTC, and the min\n                 time_t value is 1970-01-01 00:00:00 UTC.  Then the min\n                 localtime value is 1970-01-01 08:00:00, and mktime will\n                 therefore fail on 1969-12-31 23:00:00.  To work around the\n                 problem, set the time zone to 1 hour behind UTC temporarily\n                 by setting TZ=\"XXX1:00\" and try mktime again.  */\n\n              char tz2buf[sizeof \"XXX\" - 1 + TIME_ZONE_BUFSIZE];\n              tz2buf[0] = tz2buf[1] = tz2buf[2] = 'X';\n              time_zone_str (pc.time_zone, &tz2buf[3]);\n              timezone_t tz2 = tzalloc (tz2buf);\n              if (!tz2)\n                {\n                  if (pc.parse_datetime_debug)\n                    dbg_printf (_(\"error: tzalloc (\\\"%s\\\") failed\\n\"), tz2buf);\n                  goto fail;\n                }\n              tm.tm_sec = tm0.tm_sec;\n              tm.tm_min = tm0.tm_min;\n              tm.tm_hour = tm0.tm_hour;\n              tm.tm_mday = tm0.tm_mday;\n              tm.tm_mon = tm0.tm_mon;\n              tm.tm_year = tm0.tm_year;\n              tm.tm_isdst = tm0.tm_isdst;\n              Start = mktime_z (tz2, &tm);\n              repaired = mktime_ok (tz2, &tm0, &tm, Start);\n              tzfree (tz2);\n            }\n\n          if (! repaired)\n            {\n              debug_mktime_not_ok (&tm0, &tm, &pc, time_zone_seen);\n              goto fail;\n            }\n        }\n\n      char dbg_ord[DBGBUFSIZE];\n\n      if (pc.days_seen && ! pc.dates_seen)\n        {\n          intmax_t dayincr;\n          if (INT_MULTIPLY_WRAPV ((pc.day_ordinal\n                                   - (0 < pc.day_ordinal\n                                      && tm.tm_wday != pc.day_number)),\n                                  7, &dayincr)\n              || INT_ADD_WRAPV ((pc.day_number - tm.tm_wday + 7) % 7,\n                                dayincr, &dayincr)\n              || INT_ADD_WRAPV (dayincr, tm.tm_mday, &tm.tm_mday))\n            Start = -1;\n          else\n            {\n              tm.tm_isdst = -1;\n              Start = mktime_z (tz, &tm);\n            }\n\n          if (Start == (time_t) -1)\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: day '%s' \"\n                              \"(day ordinal=%\"PRIdMAX\" number=%d) \"\n                              \"resulted in an invalid date: '%s'\\n\"),\n                            str_days (&pc, dbg_ord, sizeof dbg_ord),\n                            pc.day_ordinal, pc.day_number,\n                            debug_strfdatetime (&tm, &pc, dbg_tm,\n                                                sizeof dbg_tm));\n              goto fail;\n            }\n\n          if (pc.parse_datetime_debug)\n            dbg_printf (_(\"new start date: '%s' is '%s'\\n\"),\n                        str_days (&pc, dbg_ord, sizeof dbg_ord),\n                        debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n\n        }\n\n      if (pc.parse_datetime_debug)\n        {\n          if (!pc.dates_seen && !pc.days_seen)\n            dbg_printf (_(\"using current date as starting value: '%s'\\n\"),\n                        debug_strfdate (&tm, dbg_tm, sizeof dbg_tm));\n\n          if (pc.days_seen && pc.dates_seen)\n            dbg_printf (_(\"warning: day (%s) ignored when explicit dates \"\n                          \"are given\\n\"),\n                        str_days (&pc, dbg_ord, sizeof dbg_ord));\n\n          dbg_printf (_(\"starting date/time: '%s'\\n\"),\n                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n        }\n\n      /* Add relative date.  */\n      if (pc.rel.year | pc.rel.month | pc.rel.day)\n        {\n          if (pc.parse_datetime_debug)\n            {\n              if ((pc.rel.year != 0 || pc.rel.month != 0) && tm.tm_mday != 15)\n                dbg_printf (_(\"warning: when adding relative months/years, \"\n                              \"it is recommended to specify the 15th of the \"\n                              \"months\\n\"));\n\n              if (pc.rel.day != 0 && tm.tm_hour != 12)\n                dbg_printf (_(\"warning: when adding relative days, \"\n                              \"it is recommended to specify noon\\n\"));\n            }\n\n          int year, month, day;\n          if (INT_ADD_WRAPV (tm.tm_year, pc.rel.year, &year)\n              || INT_ADD_WRAPV (tm.tm_mon, pc.rel.month, &month)\n              || INT_ADD_WRAPV (tm.tm_mday, pc.rel.day, &day))\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: %s:%d\\n\"), __FILE__, __LINE__);\n              goto fail;\n            }\n          tm.tm_year = year;\n          tm.tm_mon = month;\n          tm.tm_mday = day;\n          tm.tm_hour = tm0.tm_hour;\n          tm.tm_min = tm0.tm_min;\n          tm.tm_sec = tm0.tm_sec;\n          tm.tm_isdst = tm0.tm_isdst;\n          Start = mktime_z (tz, &tm);\n          if (Start == (time_t) -1)\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: adding relative date resulted \"\n                              \"in an invalid date: '%s'\\n\"),\n                            debug_strfdatetime (&tm, &pc, dbg_tm,\n                                                sizeof dbg_tm));\n              goto fail;\n            }\n\n          if (pc.parse_datetime_debug)\n            {\n              dbg_printf (_(\"after date adjustment \"\n                            \"(%+\"PRIdMAX\" years, %+\"PRIdMAX\" months, \"\n                            \"%+\"PRIdMAX\" days),\\n\"),\n                          pc.rel.year, pc.rel.month, pc.rel.day);\n              dbg_printf (_(\"    new date/time = '%s'\\n\"),\n                          debug_strfdatetime (&tm, &pc, dbg_tm,\n                                              sizeof dbg_tm));\n\n              /* Warn about crossing DST due to time adjustment.\n                 Example: https://bugs.gnu.org/8357\n                 env TZ=Europe/Helsinki \\\n                   date --debug \\\n                        -d 'Mon Mar 28 00:36:07 2011 EEST 1 day ago'\n\n                 This case is different than DST changes due to time adjustment,\n                 i.e., \"1 day ago\" vs \"24 hours ago\" are calculated in different\n                 places.\n\n                 'tm0.tm_isdst' contains the DST of the input date,\n                 'tm.tm_isdst' is the normalized result after calling\n                 mktime (&tm).\n              */\n              if (tm0.tm_isdst != -1 && tm.tm_isdst != tm0.tm_isdst)\n                dbg_printf (_(\"warning: daylight saving time changed after \"\n                              \"date adjustment\\n\"));\n\n              /* Warn if the user did not ask to adjust days but mday changed,\n                 or\n                 user did not ask to adjust months/days but the month changed.\n\n                 Example for first case:\n                 2016-05-31 + 1 month => 2016-06-31 => 2016-07-01.\n                 User asked to adjust month, but the day changed from 31 to 01.\n\n                 Example for second case:\n                 2016-02-29 + 1 year => 2017-02-29 => 2017-03-01.\n                 User asked to adjust year, but the month changed from 02 to 03.\n              */\n              if (pc.rel.day == 0\n                  && (tm.tm_mday != day\n                      || (pc.rel.month == 0 && tm.tm_mon != month)))\n                {\n                  dbg_printf (_(\"warning: month/year adjustment resulted in \"\n                                \"shifted dates:\\n\"));\n                  char tm_year_buf[TM_YEAR_BUFSIZE];\n                  dbg_printf (_(\"     adjusted Y M D: %s %02d %02d\\n\"),\n                              tm_year_str (year, tm_year_buf), month + 1, day);\n                  dbg_printf (_(\"   normalized Y M D: %s %02d %02d\\n\"),\n                              tm_year_str (tm.tm_year, tm_year_buf),\n                              tm.tm_mon + 1, tm.tm_mday);\n                }\n            }\n\n        }\n\n      /* The only \"output\" of this if-block is an updated Start value,\n         so this block must follow others that clobber Start.  */\n      if (pc.zones_seen)\n        {\n          intmax_t delta = pc.time_zone, t1;\n          bool overflow = false;\n#ifdef HAVE_TM_GMTOFF\n          long int utcoff = tm.tm_gmtoff;\n#else\n          time_t t = Start;\n          struct tm gmt;\n          int utcoff = (gmtime_r (&t, &gmt)\n                        ? tm_diff (&tm, &gmt)\n                        : (overflow = true, 0));\n#endif\n          overflow |= INT_SUBTRACT_WRAPV (delta, utcoff, &delta);\n          overflow |= INT_SUBTRACT_WRAPV (Start, delta, &t1);\n          if (overflow || time_overflow (t1))\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: timezone %d caused time_t overflow\\n\"),\n                            pc.time_zone);\n              goto fail;\n            }\n          Start = t1;\n        }\n\n      if (pc.parse_datetime_debug)\n        {\n          intmax_t Starti = Start;\n          dbg_printf (_(\"'%s' = %\"PRIdMAX\" epoch-seconds\\n\"),\n                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm),\n                      Starti);\n        }\n\n\n      /* Add relative hours, minutes, and seconds.  On hosts that support\n         leap seconds, ignore the possibility of leap seconds; e.g.,\n         \"+ 10 minutes\" adds 600 seconds, even if one of them is a\n         leap second.  Typically this is not what the user wants, but it's\n         too hard to do it the other way, because the time zone indicator\n         must be applied before relative times, and if mktime is applied\n         again the time zone will be lost.  */\n      {\n        intmax_t orig_ns = pc.seconds.tv_nsec;\n        intmax_t sum_ns = orig_ns + pc.rel.ns;\n        int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n        int d4 = (sum_ns - normalized_ns) / BILLION;\n        intmax_t d1, t1, d2, t2, t3, t4;\n        if (INT_MULTIPLY_WRAPV (pc.rel.hour, 60 * 60, &d1)\n            || INT_ADD_WRAPV (Start, d1, &t1)\n            || INT_MULTIPLY_WRAPV (pc.rel.minutes, 60, &d2)\n            || INT_ADD_WRAPV (t1, d2, &t2)\n            || INT_ADD_WRAPV (t2, pc.rel.seconds, &t3)\n            || INT_ADD_WRAPV (t3, d4, &t4)\n            || time_overflow (t4))\n          {\n            if (pc.parse_datetime_debug)\n              dbg_printf (_(\"error: adding relative time caused an \"\n                            \"overflow\\n\"));\n            goto fail;\n          }\n\n        result->tv_sec = t4;\n        result->tv_nsec = normalized_ns;\n\n        if (pc.parse_datetime_debug\n            && (pc.rel.hour | pc.rel.minutes | pc.rel.seconds | pc.rel.ns))\n          {\n            dbg_printf (_(\"after time adjustment (%+\"PRIdMAX\" hours, \"\n                          \"%+\"PRIdMAX\" minutes, \"\n                          \"%+\"PRIdMAX\" seconds, %+d ns),\\n\"),\n                        pc.rel.hour, pc.rel.minutes, pc.rel.seconds,\n                        pc.rel.ns);\n            dbg_printf (_(\"    new time = %\"PRIdMAX\" epoch-seconds\\n\"), t4);\n\n            /* Warn about crossing DST due to time adjustment.\n               Example: https://bugs.gnu.org/8357\n               env TZ=Europe/Helsinki           \\\n               date --debug                                             \\\n               -d 'Mon Mar 28 00:36:07 2011 EEST 24 hours ago'\n\n               This case is different than DST changes due to days adjustment,\n               i.e., \"1 day ago\" vs \"24 hours ago\" are calculated in different\n               places.\n\n               'tm.tm_isdst' contains the date after date adjustment.  */\n            struct tm lmt;\n            if (tm.tm_isdst != -1 && localtime_rz (tz, &result->tv_sec, &lmt)\n                && tm.tm_isdst != lmt.tm_isdst)\n              dbg_printf (_(\"warning: daylight saving time changed after \"\n                            \"time adjustment\\n\"));\n          }\n      }\n    }\n\n  if (pc.parse_datetime_debug)\n    {\n      /* Special case: using 'date -u' simply set TZ=UTC0 */\n      if (! tzstring)\n        dbg_printf (_(\"timezone: system default\\n\"));\n      else if (STREQ (tzstring, \"UTC0\"))\n        dbg_printf (_(\"timezone: Universal Time\\n\"));\n      else\n        dbg_printf (_(\"timezone: TZ=\\\"%s\\\" environment value\\n\"), tzstring);\n\n      intmax_t sec = result->tv_sec;\n      int nsec = result->tv_nsec;\n      dbg_printf (_(\"final: %\"PRIdMAX\".%09d (epoch-seconds)\\n\"),\n                  sec, nsec);\n\n      struct tm gmt, lmt;\n      bool got_utc = !!gmtime_r (&result->tv_sec, &gmt);\n      if (got_utc)\n        dbg_printf (_(\"final: %s (UTC)\\n\"),\n                    debug_strfdatetime (&gmt, NULL,\n                                        dbg_tm, sizeof dbg_tm));\n      if (localtime_rz (tz, &result->tv_sec, &lmt))\n        {\n#ifdef HAVE_TM_GMTOFF\n          bool got_utcoff = true;\n          long int utcoff = lmt.tm_gmtoff;\n#else\n          bool got_utcoff = got_utc;\n          int utcoff;\n          if (got_utcoff)\n            utcoff = tm_diff (&lmt, &gmt);\n#endif\n          if (got_utcoff)\n            dbg_printf (_(\"final: %s (UTC%s)\\n\"),\n                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm),\n                        time_zone_str (utcoff, time_zone_buf));\n          else\n            dbg_printf (_(\"final: %s (unknown time zone offset)\\n\"),\n                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm));\n        }\n    }\n\n  ok = true;\n\n fail:\n  if (tz != tzdefault)\n    tzfree (tz);\n  free (tz1alloc);\n  return ok;\n}",
      "lines": 656,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        2393,
        0
      ],
      "end_point": [
        2426,
        1
      ],
      "content": "int\nmain (int ac, char **av)\n{\n  char buff[BUFSIZ];\n\n  printf (\"Enter date, or blank line to exit.\\n\\t> \");\n  fflush (stdout);\n\n  buff[BUFSIZ - 1] = '\\0';\n  while (fgets (buff, BUFSIZ - 1, stdin) && buff[0])\n    {\n      struct timespec d;\n      struct tm const *tm;\n      if (! parse_datetime (&d, buff, NULL))\n        printf (\"Bad format - couldn't convert.\\n\");\n      else if (! (tm = localtime (&d.tv_sec)))\n        {\n          intmax_t sec = d.tv_sec;\n          printf (\"localtime (%\"PRIdMAX\") failed\\n\", sec);\n        }\n      else\n        {\n          int ns = d.tv_nsec;\n          char tm_year_buf[TM_YEAR_BUFSIZE];\n          printf (\"%s-%02d-%02d %02d:%02d:%02d.%09d\\n\",\n                  tm_year_str (tm->tm_year, tm_year_buf),\n                  tm->tm_mon + 1, tm->tm_mday,\n                  tm->tm_hour, tm->tm_min, tm->tm_sec, ns);\n        }\n      printf (\"\\t> \");\n      fflush (stdout);\n    }\n  return 0;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/pathmax.h": {},
  "patch/patch-2.7.6/lib/pipe-safer.c": {
    "pipe_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\npipe_safer (int fd[2])\n{\n#if HAVE_PIPE\n  if (pipe (fd) == 0)\n    {\n      int i;\n      for (i = 0; i < 2; i++)\n        {\n          fd[i] = fd_safer (fd[i]);\n          if (fd[i] < 0)\n            {\n              int e = errno;\n              close (fd[1 - i]);\n              errno = e;\n              return -1;\n            }\n        }\n\n      return 0;\n    }\n#else\n  errno = ENOSYS;\n#endif\n\n  return -1;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/printf-args.h": {},
  "patch/patch-2.7.6/lib/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On Mac OS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/printf-parse.h": {},
  "patch/patch-2.7.6/lib/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/progname.h": {},
  "patch/patch-2.7.6/lib/quote.h": {},
  "patch/patch-2.7.6/lib/quotearg.c": {
    "clone_quoting_options": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "struct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  int e = errno;\n  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n                                       sizeof *o);\n  errno = e;\n  return p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct quoting_options",
        "struct",
        "quoting_options",
        "*\nclone_quoting_options (struct quoting_options *o)",
        "*"
      ]
    },
    "get_quoting_style": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "enum quoting_style\nget_quoting_style (struct quoting_options const *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "enum quoting_style",
        "enum",
        "quoting_style"
      ]
    },
    "set_quoting_style": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_char_quoting": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "int\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  unsigned int *p =\n    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_quoting_flags": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\nset_quoting_flags (struct quoting_options *o, int i)\n{\n  int r;\n  if (!o)\n    o = &default_quoting_options;\n  r = o->flags;\n  o->flags = i;\n  return r;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_custom_quoting": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nset_custom_quoting (struct quoting_options *o,\n                    char const *left_quote, char const *right_quote)\n{\n  if (!o)\n    o = &default_quoting_options;\n  o->style = custom_quoting_style;\n  if (!left_quote || !right_quote)\n    abort ();\n  o->left_quote = left_quote;\n  o->right_quote = right_quote;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "quoting_options_from_style": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static struct quoting_options /* NOT PURE!! */\nquoting_options_from_style (enum quoting_style style)\n{\n  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };\n  if (style == custom_quoting_style)\n    abort ();\n  o.style = style;\n  return o;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct quoting_options",
        "struct",
        "quoting_options",
        "/* NOT PURE!! */"
      ]
    },
    "gettext_quote": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static char const *\ngettext_quote (char const *msgid, enum quoting_style s)\n{\n  char const *translation = _(msgid);\n  char const *locale_code;\n\n  if (translation != msgid)\n    return translation;\n\n  /* For UTF-8 and GB-18030, use single quotes U+2018 and U+2019.\n     Here is a list of other locales that include U+2018 and U+2019:\n\n        ISO-8859-7   0xA1                 KOI8-T       0x91\n        CP869        0x8B                 CP874        0x91\n        CP932        0x81 0x65            CP936        0xA1 0xAE\n        CP949        0xA1 0xAE            CP950        0xA1 0xA5\n        CP1250       0x91                 CP1251       0x91\n        CP1252       0x91                 CP1253       0x91\n        CP1254       0x91                 CP1255       0x91\n        CP1256       0x91                 CP1257       0x91\n        EUC-JP       0xA1 0xC6            EUC-KR       0xA1 0xAE\n        EUC-TW       0xA1 0xE4            BIG5         0xA1 0xA5\n        BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE\n        GBK          0xA1 0xAE            Georgian-PS  0x91\n        PT154        0x91\n\n     None of these is still in wide use; using iconv is overkill.  */\n  locale_code = locale_charset ();\n  if (STRCASEEQ (locale_code, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    return msgid[0] == '`' ? \"\\xe2\\x80\\x98\": \"\\xe2\\x80\\x99\";\n  if (STRCASEEQ (locale_code, \"GB18030\", 'G','B','1','8','0','3','0',0,0))\n    return msgid[0] == '`' ? \"\\xa1\\ae\": \"\\xa1\\xaf\";\n\n  return (s == clocale_quoting_style ? \"\\\"\" : \"'\");\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ngettext_quote (char const *msgid, enum quoting_style s)",
        "*"
      ]
    },
    "quotearg_buffer_restyled": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        771,
        1
      ],
      "content": "static size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n                          char const *arg, size_t argsize,\n                          enum quoting_style quoting_style, int flags,\n                          unsigned int const *quote_these_too,\n                          char const *left_quote,\n                          char const *right_quote)\n{\n  size_t i;\n  size_t len = 0;\n  size_t orig_buffersize = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  bool backslash_escapes = false;\n  bool unibyte_locale = MB_CUR_MAX == 1;\n  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n  bool pending_shell_escape_end = false;\n  bool encountered_single_quote = false;\n  bool all_c_and_shell_quote_compat = true;\n\n#define STORE(c) \\\n    do \\\n      { \\\n        if (len < buffersize) \\\n          buffer[len] = (c); \\\n        len++; \\\n      } \\\n    while (0)\n\n#define START_ESC() \\\n    do \\\n      { \\\n        if (elide_outer_quotes) \\\n          goto force_outer_quoting_style; \\\n        escaping = true; \\\n        if (quoting_style == shell_always_quoting_style \\\n            && ! pending_shell_escape_end) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('$'); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = true; \\\n          } \\\n        STORE ('\\\\'); \\\n      } \\\n    while (0)\n\n#define END_ESC() \\\n    do \\\n      { \\\n        if (pending_shell_escape_end && ! escaping) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = false; \\\n          } \\\n      } \\\n    while (0)\n\n process_input:\n\n  switch (quoting_style)\n    {\n    case c_maybe_quoting_style:\n      quoting_style = c_quoting_style;\n      elide_outer_quotes = true;\n      FALLTHROUGH;\n    case c_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\"');\n      backslash_escapes = true;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = true;\n      elide_outer_quotes = false;\n      break;\n\n    case locale_quoting_style:\n    case clocale_quoting_style:\n    case custom_quoting_style:\n      {\n        if (quoting_style != custom_quoting_style)\n          {\n            /* TRANSLATORS:\n               Get translations for open and closing quotation marks.\n               The message catalog should translate \"`\" to a left\n               quotation mark suitable for the locale, and similarly for\n               \"'\".  For example, a French Unicode local should translate\n               these to U+00AB (LEFT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), respectively.\n\n               If the catalog has no translation, we will try to\n               use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and\n               Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the\n               current locale is not Unicode, locale_quoting_style\n               will quote 'like this', and clocale_quoting_style will\n               quote \"like this\".  You should always include translations\n               for \"`\" and \"'\" even if U+2018 and U+2019 are appropriate\n               for your locale.\n\n               If you don't know what to put here, please see\n               <https://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>\n               and use glyphs suitable for your language.  */\n            left_quote = gettext_quote (N_(\"`\"), quoting_style);\n            right_quote = gettext_quote (N_(\"'\"), quoting_style);\n          }\n        if (!elide_outer_quotes)\n          for (quote_string = left_quote; *quote_string; quote_string++)\n            STORE (*quote_string);\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen (quote_string);\n      }\n      break;\n\n    case shell_escape_quoting_style:\n      backslash_escapes = true;\n      FALLTHROUGH;\n    case shell_quoting_style:\n      elide_outer_quotes = true;\n      FALLTHROUGH;\n    case shell_escape_always_quoting_style:\n      if (!elide_outer_quotes)\n        backslash_escapes = true;\n      FALLTHROUGH;\n    case shell_always_quoting_style:\n      quoting_style = shell_always_quoting_style;\n      if (!elide_outer_quotes)\n        STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    case literal_quoting_style:\n      elide_outer_quotes = false;\n      break;\n\n    default:\n      abort ();\n    }\n\n  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n      bool is_right_quote = false;\n      bool escaping = false;\n      bool c_and_shell_quote_compat = false;\n\n      if (backslash_escapes\n          && quoting_style != shell_always_quoting_style\n          && quote_string_len\n          && (i + quote_string_len\n              <= (argsize == SIZE_MAX && 1 < quote_string_len\n                  /* Use strlen only if we must: when argsize is SIZE_MAX,\n                     and when the quote string is more than 1 byte long.\n                     If we do call strlen, save the result.  */\n                  ? (argsize = strlen (arg)) : argsize))\n          && memcmp (arg + i, quote_string, quote_string_len) == 0)\n        {\n          if (elide_outer_quotes)\n            goto force_outer_quoting_style;\n          is_right_quote = true;\n        }\n\n      c = arg[i];\n      switch (c)\n        {\n        case '\\0':\n          if (backslash_escapes)\n            {\n              START_ESC ();\n              /* If quote_string were to begin with digits, we'd need to\n                 test for the end of the arg as well.  However, it's\n                 hard to imagine any locale that would use digits in\n                 quotes, and set_custom_quoting is documented not to\n                 accept them.  Use only a single \\0 with shell-escape\n                 as currently digits are not printed within $'...'  */\n              if (quoting_style != shell_always_quoting_style\n                  && i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n                {\n                  STORE ('0');\n                  STORE ('0');\n                }\n              c = '0';\n              /* We don't have to worry that this last '0' will be\n                 backslash-escaped because, again, quote_string should\n                 not start with it and because quote_these_too is\n                 documented as not accepting it.  */\n            }\n          else if (flags & QA_ELIDE_NULL_BYTES)\n            continue;\n          break;\n\n        case '?':\n          switch (quoting_style)\n            {\n            case shell_always_quoting_style:\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              break;\n\n            case c_quoting_style:\n              if ((flags & QA_SPLIT_TRIGRAPHS)\n                  && i + 2 < argsize && arg[i + 1] == '?')\n                switch (arg[i + 2])\n                  {\n                  case '!': case '\\'':\n                  case '(': case ')': case '-': case '/':\n                  case '<': case '=': case '>':\n                    /* Escape the second '?' in what would otherwise be\n                       a trigraph.  */\n                    if (elide_outer_quotes)\n                      goto force_outer_quoting_style;\n                    c = arg[i + 2];\n                    i += 2;\n                    STORE ('?');\n                    STORE ('\"');\n                    STORE ('\"');\n                    STORE ('?');\n                    break;\n\n                  default:\n                    break;\n                  }\n              break;\n\n            default:\n              break;\n            }\n          break;\n\n        case '\\a': esc = 'a'; goto c_escape;\n        case '\\b': esc = 'b'; goto c_escape;\n        case '\\f': esc = 'f'; goto c_escape;\n        case '\\n': esc = 'n'; goto c_and_shell_escape;\n        case '\\r': esc = 'r'; goto c_and_shell_escape;\n        case '\\t': esc = 't'; goto c_and_shell_escape;\n        case '\\v': esc = 'v'; goto c_escape;\n        case '\\\\': esc = c;\n          /* Never need to escape '\\' in shell case.  */\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              goto store_c;\n            }\n\n          /* No need to escape the escape if we are trying to elide\n             outer quotes and nothing else is problematic.  */\n          if (backslash_escapes && elide_outer_quotes && quote_string_len)\n            goto store_c;\n\n        c_and_shell_escape:\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          /* fall through */\n        c_escape:\n          if (backslash_escapes)\n            {\n              c = esc;\n              goto store_escape;\n            }\n          break;\n\n        case '{': case '}': /* sometimes special if isolated */\n          if (! (argsize == SIZE_MAX ? arg[1] == '\\0' : argsize == 1))\n            break;\n          FALLTHROUGH;\n        case '#': case '~':\n          if (i != 0)\n            break;\n          FALLTHROUGH;\n        case ' ':\n          c_and_shell_quote_compat = true;\n          FALLTHROUGH;\n        case '!': /* special in bash */\n        case '\"': case '$': case '&':\n        case '(': case ')': case '*': case ';':\n        case '<':\n        case '=': /* sometimes special in 0th or (with \"set -k\") later args */\n        case '>': case '[':\n        case '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */\n        case '`': case '|':\n          /* A shell special character.  In theory, '$' and '`' could\n             be the first bytes of multibyte characters, which means\n             we should check them with mbrtowc, but in practice this\n             doesn't happen so it's not worth worrying about.  */\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          break;\n\n        case '\\'':\n          encountered_single_quote = true;\n          c_and_shell_quote_compat = true;\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n\n              if (buffersize && ! orig_buffersize)\n                {\n                  /* Just scan string to see if supports a more concise\n                     representation, rather than writing a longer string\n                     but returning the length of the more concise form.  */\n                  orig_buffersize = buffersize;\n                  buffersize = 0;\n                }\n\n              STORE ('\\'');\n              STORE ('\\\\');\n              STORE ('\\'');\n              pending_shell_escape_end = false;\n            }\n          break;\n\n        case '%': case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': case ':':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n        case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n        case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n          /* These characters don't cause problems, no matter what the\n             quoting style is.  They cannot start multibyte sequences.\n             A digit or a special letter would cause trouble if it\n             appeared at the beginning of quote_string because we'd then\n             escape by prepending a backslash.  However, it's hard to\n             imagine any locale that would use digits or letters as\n             quotes, and set_custom_quoting is documented not to accept\n             them.  Also, a digit or a special letter would cause\n             trouble if it appeared in quote_these_too, but that's also\n             documented as not accepting them.  */\n          c_and_shell_quote_compat = true;\n          break;\n\n        default:\n          /* If we have a multibyte sequence, copy it until we reach\n             its end, find an error, or come back to the initial shift\n             state.  For C-like styles, if the sequence has\n             unprintable characters, escape the whole sequence, since\n             we can't easily escape single characters within it.  */\n          {\n            /* Length of multibyte sequence found so far.  */\n            size_t m;\n\n            bool printable;\n\n            if (unibyte_locale)\n              {\n                m = 1;\n                printable = isprint (c) != 0;\n              }\n            else\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n\n                m = 0;\n                printable = true;\n                if (argsize == SIZE_MAX)\n                  argsize = strlen (arg);\n\n                do\n                  {\n                    wchar_t w;\n                    size_t bytes = mbrtowc (&w, &arg[i + m],\n                                            argsize - (i + m), &mbstate);\n                    if (bytes == 0)\n                      break;\n                    else if (bytes == (size_t) -1)\n                      {\n                        printable = false;\n                        break;\n                      }\n                    else if (bytes == (size_t) -2)\n                      {\n                        printable = false;\n                        while (i + m < argsize && arg[i + m])\n                          m++;\n                        break;\n                      }\n                    else\n                      {\n                        /* Work around a bug with older shells that \"see\" a '\\'\n                           that is really the 2nd byte of a multibyte character.\n                           In practice the problem is limited to ASCII\n                           chars >= '@' that are shell special chars.  */\n                        if ('[' == 0x5b && elide_outer_quotes\n                            && quoting_style == shell_always_quoting_style)\n                          {\n                            size_t j;\n                            for (j = 1; j < bytes; j++)\n                              switch (arg[i + m + j])\n                                {\n                                case '[': case '\\\\': case '^':\n                                case '`': case '|':\n                                  goto force_outer_quoting_style;\n\n                                default:\n                                  break;\n                                }\n                          }\n\n                        if (! iswprint (w))\n                          printable = false;\n                        m += bytes;\n                      }\n                  }\n                while (! mbsinit (&mbstate));\n              }\n\n            c_and_shell_quote_compat = printable;\n\n            if (1 < m || (backslash_escapes && ! printable))\n              {\n                /* Output a multibyte sequence, or an escaped\n                   unprintable unibyte character.  */\n                size_t ilim = i + m;\n\n                for (;;)\n                  {\n                    if (backslash_escapes && ! printable)\n                      {\n                        START_ESC ();\n                        STORE ('0' + (c >> 6));\n                        STORE ('0' + ((c >> 3) & 7));\n                        c = '0' + (c & 7);\n                      }\n                    else if (is_right_quote)\n                      {\n                        STORE ('\\\\');\n                        is_right_quote = false;\n                      }\n                    if (ilim <= i + 1)\n                      break;\n                    END_ESC ();\n                    STORE (c);\n                    c = arg[++i];\n                  }\n\n                goto store_c;\n              }\n          }\n        }\n\n      if (! (((backslash_escapes && quoting_style != shell_always_quoting_style)\n              || elide_outer_quotes)\n             && quote_these_too\n             && quote_these_too[c / INT_BITS] >> (c % INT_BITS) & 1)\n          && !is_right_quote)\n        goto store_c;\n\n    store_escape:\n      START_ESC ();\n\n    store_c:\n      END_ESC ();\n      STORE (c);\n\n      if (! c_and_shell_quote_compat)\n        all_c_and_shell_quote_compat = false;\n    }\n\n  if (len == 0 && quoting_style == shell_always_quoting_style\n      && elide_outer_quotes)\n    goto force_outer_quoting_style;\n\n  /* Single shell quotes (') are commonly enough used as an apostrophe,\n     that we attempt to minimize the quoting in this case.  Note it\u00ca\u00bcs\n     better to use the apostrophe modifier \"\\u02BC\" if possible, as that\n     renders better and works with the word match regex \\W+ etc.  */\n  if (quoting_style == shell_always_quoting_style && ! elide_outer_quotes\n      && encountered_single_quote)\n    {\n      if (all_c_and_shell_quote_compat)\n        return quotearg_buffer_restyled (buffer, orig_buffersize, arg, argsize,\n                                         c_quoting_style,\n                                         flags, quote_these_too,\n                                         left_quote, right_quote);\n      else if (! buffersize && orig_buffersize)\n        {\n          /* Disable read-only scan, and reprocess to write quoted string.  */\n          buffersize = orig_buffersize;\n          len = 0;\n          goto process_input;\n        }\n    }\n\n  if (quote_string && !elide_outer_quotes)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n force_outer_quoting_style:\n  /* Don't reuse quote_these_too, since the addition of outer quotes\n     sufficiently quotes the specified characters.  */\n  if (quoting_style == shell_always_quoting_style && backslash_escapes)\n    quoting_style = shell_escape_always_quoting_style;\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                   quoting_style,\n                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n                                   left_quote, right_quote);\n}",
      "lines": 518,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "quotearg_buffer": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "size_t\nquotearg_buffer (char *buffer, size_t buffersize,\n                 char const *arg, size_t argsize,\n                 struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                       p->style, p->flags, p->quote_these_too,\n                                       p->left_quote, p->right_quote);\n  errno = e;\n  return r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "quotearg_alloc": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "char *\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)\n{\n  return quotearg_alloc_mem (arg, argsize, NULL, o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_alloc_mem": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "char *\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  /* Elide embedded null bytes if we can't return a size.  */\n  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n                                             flags, p->quote_these_too,\n                                             p->left_quote,\n                                             p->right_quote) + 1;\n  char *buf = xcharalloc (bufsize);\n  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n                            p->quote_these_too,\n                            p->left_quote, p->right_quote);\n  errno = e;\n  if (size)\n    *size = bufsize - 1;\n  return buf;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "char",
        "*\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_free": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "void\nquotearg_free (void)\n{\n  struct slotvec *sv = slotvec;\n  int i;\n  for (i = 1; i < nslots; i++)\n    free (sv[i].val);\n  if (sv[0].val != slot0)\n    {\n      free (sv[0].val);\n      slotvec0.size = sizeof slot0;\n      slotvec0.val = slot0;\n    }\n  if (sv != &slotvec0)\n    {\n      free (sv);\n      slotvec = &slotvec0;\n    }\n  nslots = 1;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quotearg_n_options": {
      "start_point": [
        875,
        0
      ],
      "end_point": [
        927,
        1
      ],
      "content": "static char *\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)\n{\n  int e = errno;\n\n  struct slotvec *sv = slotvec;\n\n  if (n < 0)\n    abort ();\n\n  if (nslots <= n)\n    {\n      bool preallocated = (sv == &slotvec0);\n      int nmax = MIN (INT_MAX, MIN (PTRDIFF_MAX, SIZE_MAX) / sizeof *sv) - 1;\n\n      if (nmax < n)\n        xalloc_die ();\n\n      slotvec = sv = xrealloc (preallocated ? NULL : sv, (n + 1) * sizeof *sv);\n      if (preallocated)\n        *sv = slotvec0;\n      memset (sv + nslots, 0, (n + 1 - nslots) * sizeof *sv);\n      nslots = n + 1;\n    }\n\n  {\n    size_t size = sv[n].size;\n    char *val = sv[n].val;\n    /* Elide embedded null bytes since we don't return a size.  */\n    int flags = options->flags | QA_ELIDE_NULL_BYTES;\n    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n                                             options->style, flags,\n                                             options->quote_these_too,\n                                             options->left_quote,\n                                             options->right_quote);\n\n    if (size <= qsize)\n      {\n        sv[n].size = size = qsize + 1;\n        if (val != slot0)\n          free (val);\n        sv[n].val = val = xcharalloc (size);\n        quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n                                  flags, options->quote_these_too,\n                                  options->left_quote,\n                                  options->right_quote);\n      }\n\n    errno = e;\n    return val;\n  }\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)",
        "*"
      ]
    },
    "quotearg_n": {
      "start_point": [
        929,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "char *\nquotearg_n (int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n (int n, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_mem": {
      "start_point": [
        935,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "char *\nquotearg_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "char *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg (char const *arg)",
        "*"
      ]
    },
    "quotearg_mem": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        951,
        1
      ],
      "content": "char *\nquotearg_mem (char const *arg, size_t argsize)\n{\n  return quotearg_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style": {
      "start_point": [
        953,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "char *\nquotearg_n_style (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, SIZE_MAX, &o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_style_mem": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        966,
        1
      ],
      "content": "char *\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_style": {
      "start_point": [
        968,
        0
      ],
      "end_point": [
        972,
        1
      ],
      "content": "char *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style (enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_style_mem": {
      "start_point": [
        974,
        0
      ],
      "end_point": [
        978,
        1
      ],
      "content": "char *\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n{\n  return quotearg_n_style_mem (0, s, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_char_mem": {
      "start_point": [
        980,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "char *\nquotearg_char_mem (char const *arg, size_t argsize, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, argsize, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char_mem (char const *arg, size_t argsize, char ch)",
        "*"
      ]
    },
    "quotearg_char": {
      "start_point": [
        989,
        0
      ],
      "end_point": [
        993,
        1
      ],
      "content": "char *\nquotearg_char (char const *arg, char ch)\n{\n  return quotearg_char_mem (arg, SIZE_MAX, ch);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char (char const *arg, char ch)",
        "*"
      ]
    },
    "quotearg_colon": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "char *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon (char const *arg)",
        "*"
      ]
    },
    "quotearg_colon_mem": {
      "start_point": [
        1001,
        0
      ],
      "end_point": [
        1005,
        1
      ],
      "content": "char *\nquotearg_colon_mem (char const *arg, size_t argsize)\n{\n  return quotearg_char_mem (arg, argsize, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style_colon": {
      "start_point": [
        1007,
        0
      ],
      "end_point": [
        1014,
        1
      ],
      "content": "char *\nquotearg_n_style_colon (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options options;\n  options = quoting_options_from_style (s);\n  set_char_quoting (&options, ':', 1);\n  return quotearg_n_options (n, arg, SIZE_MAX, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_colon (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom": {
      "start_point": [
        1016,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "char *\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)\n{\n  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n                                SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom_mem": {
      "start_point": [
        1024,
        0
      ],
      "end_point": [
        1032,
        1
      ],
      "content": "char *\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)\n{\n  struct quoting_options o = default_quoting_options;\n  set_custom_quoting (&o, left_quote, right_quote);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_custom": {
      "start_point": [
        1034,
        0
      ],
      "end_point": [
        1039,
        1
      ],
      "content": "char *\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)\n{\n  return quotearg_n_custom (0, left_quote, right_quote, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)",
        "*"
      ]
    },
    "quotearg_custom_mem": {
      "start_point": [
        1041,
        0
      ],
      "end_point": [
        1047,
        1
      ],
      "content": "char *\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)\n{\n  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n                                argsize);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n_mem": {
      "start_point": [
        1059,
        0
      ],
      "end_point": [
        1063,
        1
      ],
      "content": "char const *\nquote_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_mem": {
      "start_point": [
        1065,
        0
      ],
      "end_point": [
        1069,
        1
      ],
      "content": "char const *\nquote_mem (char const *arg, size_t argsize)\n{\n  return quote_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n": {
      "start_point": [
        1071,
        0
      ],
      "end_point": [
        1075,
        1
      ],
      "content": "char const *\nquote_n (int n, char const *arg)\n{\n  return quote_n_mem (n, arg, SIZE_MAX);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n (int n, char const *arg)",
        "*"
      ]
    },
    "quote": {
      "start_point": [
        1077,
        0
      ],
      "end_point": [
        1081,
        1
      ],
      "content": "char const *\nquote (char const *arg)\n{\n  return quote_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote (char const *arg)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/quotearg.h": {},
  "patch/patch-2.7.6/lib/raise.c": {
    "raise_nothrow": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        5
      ],
      "content": "static int\nraise_nothrow (int sig)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = raise (sig);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_raise": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\nrpl_raise (int sig)\n{\n#if GNULIB_defined_signal_blocking && GNULIB_defined_SIGPIPE\n  if (sig == SIGPIPE)\n    return _gl_raise_SIGPIPE ();\n#endif\n\n#if HAVE_RAISE\n  return raise_nothrow (sig);\n#else\n  return kill (getpid (), sig);\n#endif\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/readdir.c": {
    "readdir": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "struct dirent *\nreaddir (DIR *dirp)\n{\n  char type;\n  struct dirent *result;\n\n  /* There is no need to add code to produce entries for \".\" and \"..\".\n     According to the POSIX:2008 section \"4.12 Pathname Resolution\"\n     <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html>\n     \".\" and \"..\" are syntactic entities.\n     POSIX also says:\n       \"If entries for dot or dot-dot exist, one entry shall be returned\n        for dot and one entry shall be returned for dot-dot; otherwise,\n        they shall not be returned.\"  */\n\n  switch (dirp->status)\n    {\n    case -2:\n      /* End of directory already reached.  */\n      return NULL;\n    case -1:\n      break;\n    case 0:\n      if (!FindNextFile (dirp->current, &dirp->entry))\n        {\n          switch (GetLastError ())\n            {\n            case ERROR_NO_MORE_FILES:\n              dirp->status = -2;\n              return NULL;\n            default:\n              errno = EIO;\n              return NULL;\n            }\n        }\n      break;\n    default:\n      errno = dirp->status;\n      return NULL;\n    }\n\n  dirp->status = 0;\n\n  if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n    type = DT_DIR;\n  else if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)\n    type = DT_LNK;\n  else if ((dirp->entry.dwFileAttributes\n            & ~(FILE_ATTRIBUTE_READONLY\n                | FILE_ATTRIBUTE_HIDDEN\n                | FILE_ATTRIBUTE_SYSTEM\n                | FILE_ATTRIBUTE_ARCHIVE\n                | FILE_ATTRIBUTE_NORMAL\n                | FILE_ATTRIBUTE_TEMPORARY\n                | FILE_ATTRIBUTE_SPARSE_FILE\n                | FILE_ATTRIBUTE_COMPRESSED\n                | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED\n                | FILE_ATTRIBUTE_ENCRYPTED)) == 0)\n    /* Devices like COM1, LPT1, NUL would also have the attributes 0x20 but\n       they cannot occur here.  */\n    type = DT_REG;\n  else\n    type = DT_UNKNOWN;\n\n  /* Reuse the memory of dirp->entry for the result.  */\n  result =\n    (struct dirent *)\n    ((char *) dirp->entry.cFileName - offsetof (struct dirent, d_name[0]));\n  result->d_type = type;\n\n  return result;\n}",
      "lines": 72,
      "depth": 21,
      "decorators": [
        "struct dirent",
        "struct",
        "dirent",
        "*\nreaddir (DIR *dirp)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/readlink.c": {
    "readlink": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "ssize_t\nreadlink (const char *name, char *buf _GL_UNUSED,\n          size_t bufsize _GL_UNUSED)\n{\n  struct stat statbuf;\n\n  /* In general we should use lstat() here, not stat().  But on platforms\n     without symbolic links, lstat() - if it exists - would be equivalent to\n     stat(), therefore we can use stat().  This saves us a configure check.  */\n  if (stat (name, &statbuf) >= 0)\n    errno = EINVAL;\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "ssize_t"
      ]
    },
    "rpl_readlink": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "ssize_t\nrpl_readlink (const char *name, char *buf, size_t bufsize)\n{\n# if READLINK_TRAILING_SLASH_BUG\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      /* Even if name without the slash is a symlink to a directory,\n         both lstat() and stat() must resolve the trailing slash to\n         the directory rather than the symlink.  We can therefore\n         safely use stat() to distinguish between EINVAL and\n         ENOTDIR/ENOENT, avoiding extra overhead of rpl_lstat().  */\n      struct stat st;\n      if (stat (name, &st) == 0)\n        errno = EINVAL;\n      return -1;\n    }\n# endif /* READLINK_TRAILING_SLASH_BUG */\n  return readlink (name, buf, bufsize);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/readlinkat.c": {
    "rpl_readlinkat": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "ssize_t\nrpl_readlinkat (int fd, char const *file, char *buf, size_t len)\n{\n# if READLINK_TRAILING_SLASH_BUG\n  size_t file_len = strlen (file);\n  if (file_len && file[file_len - 1] == '/')\n    {\n      /* Even if FILE without the slash is a symlink to a directory,\n         both lstat() and stat() must resolve the trailing slash to\n         the directory rather than the symlink.  We can therefore\n         safely use stat() to distinguish between EINVAL and\n         ENOTDIR/ENOENT, avoiding extra overhead of rpl_lstat().  */\n      struct stat st;\n      if (stat (file, &st) == 0)\n        errno = EINVAL;\n      return -1;\n    }\n# endif /* READLINK_TRAILING_SLASH_BUG */\n  return readlinkat (fd, file, buf, len);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/rename.c": {
    "rpl_rename": [
      {
        "start_point": [
          44,
          0
        ],
        "end_point": [
          262,
          1
        ],
        "content": "int\nrpl_rename (char const *src, char const *dst)\n{\n  int error;\n  size_t src_len = strlen (src);\n  size_t dst_len = strlen (dst);\n  char *src_base = last_component (src);\n  char *dst_base = last_component (dst);\n  bool src_slash;\n  bool dst_slash;\n  bool dst_exists;\n  struct stat src_st;\n  struct stat dst_st;\n\n  /* Filter out dot as last component.  */\n  if (!src_len || !dst_len)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n  if (*src_base == '.')\n    {\n      size_t len = base_len (src_base);\n      if (len == 1 || (len == 2 && src_base[1] == '.'))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n    }\n  if (*dst_base == '.')\n    {\n      size_t len = base_len (dst_base);\n      if (len == 1 || (len == 2 && dst_base[1] == '.'))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n    }\n\n  /* Presence of a trailing slash requires directory semantics.  If\n     the source does not exist, or if the destination cannot be turned\n     into a directory, give up now.  Otherwise, strip trailing slashes\n     before calling rename.  There are no symlinks on mingw, so stat\n     works instead of lstat.  */\n  src_slash = ISSLASH (src[src_len - 1]);\n  dst_slash = ISSLASH (dst[dst_len - 1]);\n  if (stat (src, &src_st))\n    return -1;\n  if (stat (dst, &dst_st))\n    {\n      if (errno != ENOENT || (!S_ISDIR (src_st.st_mode) && dst_slash))\n        return -1;\n      dst_exists = false;\n    }\n  else\n    {\n      if (S_ISDIR (dst_st.st_mode) != S_ISDIR (src_st.st_mode))\n        {\n          errno = S_ISDIR (dst_st.st_mode) ? EISDIR : ENOTDIR;\n          return -1;\n        }\n      dst_exists = true;\n    }\n\n  /* There are no symlinks, so if a file existed with a trailing\n     slash, it must be a directory, and we don't have to worry about\n     stripping strip trailing slash.  However, mingw refuses to\n     replace an existing empty directory, so we have to help it out.\n     And canonicalize_file_name is not yet ported to mingw; however,\n     for directories, getcwd works as a viable alternative.  Ensure\n     that we can get back to where we started before using it; later\n     attempts to return are fatal.  Note that we can end up losing a\n     directory if rename then fails, but it was empty, so not much\n     damage was done.  */\n  if (dst_exists && S_ISDIR (dst_st.st_mode))\n    {\n      char *cwd = getcwd (NULL, 0);\n      char *src_temp;\n      char *dst_temp;\n      if (!cwd || chdir (cwd))\n        return -1;\n      if (IS_ABSOLUTE_FILE_NAME (src))\n        {\n          dst_temp = chdir (dst) ? NULL : getcwd (NULL, 0);\n          src_temp = chdir (src) ? NULL : getcwd (NULL, 0);\n        }\n      else\n        {\n          src_temp = chdir (src) ? NULL : getcwd (NULL, 0);\n          if (!IS_ABSOLUTE_FILE_NAME (dst) && chdir (cwd))\n            abort ();\n          dst_temp = chdir (dst) ? NULL : getcwd (NULL, 0);\n        }\n      if (chdir (cwd))\n        abort ();\n      free (cwd);\n      if (!src_temp || !dst_temp)\n        {\n          free (src_temp);\n          free (dst_temp);\n          errno = ENOMEM;\n          return -1;\n        }\n      src_len = strlen (src_temp);\n      if (strncmp (src_temp, dst_temp, src_len) == 0\n          && (ISSLASH (dst_temp[src_len]) || dst_temp[src_len] == '\\0'))\n        {\n          error = dst_temp[src_len];\n          free (src_temp);\n          free (dst_temp);\n          if (error)\n            {\n              errno = EINVAL;\n              return -1;\n            }\n          return 0;\n        }\n      if (rmdir (dst))\n        {\n          error = errno;\n          free (src_temp);\n          free (dst_temp);\n          errno = error;\n          return -1;\n        }\n      free (src_temp);\n      free (dst_temp);\n    }\n\n  /* MoveFileEx works if SRC is a directory without any flags, but\n     fails with MOVEFILE_REPLACE_EXISTING, so try without flags first.\n     Thankfully, MoveFileEx handles hard links correctly, even though\n     rename() does not.  */\n  if (MoveFileEx (src, dst, 0))\n    return 0;\n\n  /* Retry with MOVEFILE_REPLACE_EXISTING if the move failed\n     due to the destination already existing.  */\n  error = GetLastError ();\n  if (error == ERROR_FILE_EXISTS || error == ERROR_ALREADY_EXISTS)\n    {\n      if (MoveFileEx (src, dst, MOVEFILE_REPLACE_EXISTING))\n        return 0;\n\n      error = GetLastError ();\n    }\n\n  switch (error)\n    {\n    case ERROR_FILE_NOT_FOUND:\n    case ERROR_PATH_NOT_FOUND:\n    case ERROR_BAD_PATHNAME:\n    case ERROR_DIRECTORY:\n      errno = ENOENT;\n      break;\n\n    case ERROR_ACCESS_DENIED:\n    case ERROR_SHARING_VIOLATION:\n      errno = EACCES;\n      break;\n\n    case ERROR_OUTOFMEMORY:\n      errno = ENOMEM;\n      break;\n\n    case ERROR_CURRENT_DIRECTORY:\n      errno = EBUSY;\n      break;\n\n    case ERROR_NOT_SAME_DEVICE:\n      errno = EXDEV;\n      break;\n\n    case ERROR_WRITE_PROTECT:\n      errno = EROFS;\n      break;\n\n    case ERROR_WRITE_FAULT:\n    case ERROR_READ_FAULT:\n    case ERROR_GEN_FAILURE:\n      errno = EIO;\n      break;\n\n    case ERROR_HANDLE_DISK_FULL:\n    case ERROR_DISK_FULL:\n    case ERROR_DISK_TOO_FRAGMENTED:\n      errno = ENOSPC;\n      break;\n\n    case ERROR_FILE_EXISTS:\n    case ERROR_ALREADY_EXISTS:\n      errno = EEXIST;\n      break;\n\n    case ERROR_BUFFER_OVERFLOW:\n    case ERROR_FILENAME_EXCED_RANGE:\n      errno = ENAMETOOLONG;\n      break;\n\n    case ERROR_INVALID_NAME:\n    case ERROR_DELETE_PENDING:\n      errno = EPERM;        /* ? */\n      break;\n\n# ifndef ERROR_FILE_TOO_LARGE\n/* This value is documented but not defined in all versions of windows.h.  */\n#  define ERROR_FILE_TOO_LARGE 223\n# endif\n    case ERROR_FILE_TOO_LARGE:\n      errno = EFBIG;\n      break;\n\n    default:\n      errno = EINVAL;\n      break;\n    }\n\n  return -1;\n}",
        "lines": 219,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          278,
          0
        ],
        "end_point": [
          473,
          1
        ],
        "content": "int\nrpl_rename (char const *src, char const *dst)\n{\n  size_t src_len = strlen (src);\n  size_t dst_len = strlen (dst);\n  char *src_temp = (char *) src;\n  char *dst_temp = (char *) dst;\n  bool src_slash;\n  bool dst_slash;\n  bool dst_exists _GL_UNUSED;\n  int ret_val = -1;\n  int rename_errno = ENOTDIR;\n  struct stat src_st;\n  struct stat dst_st;\n\n  if (!src_len || !dst_len)\n    return rename (src, dst); /* Let strace see the ENOENT failure.  */\n\n# if RENAME_DEST_EXISTS_BUG\n  {\n    char *src_base = last_component (src);\n    char *dst_base = last_component (dst);\n    if (*src_base == '.')\n      {\n        size_t len = base_len (src_base);\n        if (len == 1 || (len == 2 && src_base[1] == '.'))\n          {\n            errno = EINVAL;\n            return -1;\n          }\n      }\n    if (*dst_base == '.')\n      {\n        size_t len = base_len (dst_base);\n        if (len == 1 || (len == 2 && dst_base[1] == '.'))\n          {\n            errno = EINVAL;\n            return -1;\n          }\n      }\n  }\n# endif /* RENAME_DEST_EXISTS_BUG */\n\n  src_slash = src[src_len - 1] == '/';\n  dst_slash = dst[dst_len - 1] == '/';\n\n# if !RENAME_HARD_LINK_BUG && !RENAME_DEST_EXISTS_BUG\n  /* If there are no trailing slashes, then trust the native\n     implementation unless we also suspect issues with hard link\n     detection or file/directory conflicts.  */\n  if (!src_slash && !dst_slash)\n    return rename (src, dst);\n# endif /* !RENAME_HARD_LINK_BUG && !RENAME_DEST_EXISTS_BUG */\n\n  /* Presence of a trailing slash requires directory semantics.  If\n     the source does not exist, or if the destination cannot be turned\n     into a directory, give up now.  Otherwise, strip trailing slashes\n     before calling rename.  */\n  if (lstat (src, &src_st))\n    return -1;\n  if (lstat (dst, &dst_st))\n    {\n      if (errno != ENOENT || (!S_ISDIR (src_st.st_mode) && dst_slash))\n        return -1;\n      dst_exists = false;\n    }\n  else\n    {\n      if (S_ISDIR (dst_st.st_mode) != S_ISDIR (src_st.st_mode))\n        {\n          errno = S_ISDIR (dst_st.st_mode) ? EISDIR : ENOTDIR;\n          return -1;\n        }\n# if RENAME_HARD_LINK_BUG\n      if (SAME_INODE (src_st, dst_st))\n        return 0;\n# endif /* RENAME_HARD_LINK_BUG */\n      dst_exists = true;\n    }\n\n# if (RENAME_TRAILING_SLASH_SOURCE_BUG || RENAME_DEST_EXISTS_BUG        \\\n      || RENAME_HARD_LINK_BUG)\n  /* If the only bug was that a trailing slash was allowed on a\n     non-existing file destination, as in Solaris 10, then we've\n     already covered that situation.  But if there is any problem with\n     a trailing slash on an existing source or destination, as in\n     Solaris 9, or if a directory can overwrite a symlink, as on\n     Cygwin 1.5, or if directories cannot be created with trailing\n     slash, as on NetBSD 1.6, then we must strip the offending slash\n     and check that we have not encountered a symlink instead of a\n     directory.\n\n     Stripping a trailing slash interferes with POSIX semantics, where\n     rename behavior on a symlink with a trailing slash operates on\n     the corresponding target directory.  We prefer the GNU semantics\n     of rejecting any use of a symlink with trailing slash, but do not\n     enforce them, since Solaris 10 is able to obey POSIX semantics\n     and there might be clients expecting it, as counter-intuitive as\n     those semantics are.\n\n     Technically, we could also follow the POSIX behavior by chasing a\n     readlink trail, but that is harder to implement.  */\n  if (src_slash)\n    {\n      src_temp = strdup (src);\n      if (!src_temp)\n        {\n          /* Rather than rely on strdup-posix, we set errno ourselves.  */\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (src_temp);\n      if (lstat (src_temp, &src_st))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n      if (S_ISLNK (src_st.st_mode))\n        goto out;\n    }\n  if (dst_slash)\n    {\n      dst_temp = strdup (dst);\n      if (!dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (dst_temp);\n      if (lstat (dst_temp, &dst_st))\n        {\n          if (errno != ENOENT)\n            {\n              rename_errno = errno;\n              goto out;\n            }\n        }\n      else if (S_ISLNK (dst_st.st_mode))\n        goto out;\n    }\n# endif /* RENAME_TRAILING_SLASH_SOURCE_BUG || RENAME_DEST_EXISTS_BUG\n           || RENAME_HARD_LINK_BUG */\n\n# if RENAME_DEST_EXISTS_BUG\n  /* Cygwin 1.5 sometimes behaves oddly when moving a non-empty\n     directory on top of an empty one (the old directory name can\n     reappear if the new directory tree is removed).  Work around this\n     by removing the target first, but don't remove the target if it\n     is a subdirectory of the source.  Note that we can end up losing\n     a directory if rename then fails, but it was empty, so not much\n     damage was done.  */\n  if (dst_exists && S_ISDIR (dst_st.st_mode))\n    {\n      if (src_st.st_dev != dst_st.st_dev)\n        {\n          rename_errno = EXDEV;\n          goto out;\n        }\n      if (src_temp != src)\n        free (src_temp);\n      src_temp = canonicalize_file_name (src);\n      if (dst_temp != dst)\n        free (dst_temp);\n      dst_temp = canonicalize_file_name (dst);\n      if (!src_temp || !dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      src_len = strlen (src_temp);\n      if (strncmp (src_temp, dst_temp, src_len) == 0\n          && dst_temp[src_len] == '/')\n        {\n          rename_errno = EINVAL;\n          goto out;\n        }\n      if (rmdir (dst))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n    }\n# endif /* RENAME_DEST_EXISTS_BUG */\n\n  ret_val = rename (src_temp, dst_temp);\n  rename_errno = errno;\n\n out: _GL_UNUSED_LABEL;\n\n  if (src_temp != src)\n    free (src_temp);\n  if (dst_temp != dst)\n    free (dst_temp);\n  errno = rename_errno;\n  return ret_val;\n}",
        "lines": 196,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "patch/patch-2.7.6/lib/renameat.c": {
    "renameat": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        24,
        1
      ],
      "content": "int\nrenameat (int fd1, char const *src, int fd2, char const *dst)\n{\n  return renameat2 (fd1, src, fd2, dst, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/renameat2.c": {
    "errno_fail": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nerrno_fail (int e)\n{\n  errno = e;\n  return -1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rename_noreplace": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\nrename_noreplace (char const *src, char const *dst)\n{\n  /* This has a race between the call to lstat and the call to rename.  */\n  struct stat st;\n  return (lstat (dst, &st) == 0 || errno == EOVERFLOW ? errno_fail (EEXIST)\n          : errno == ENOENT ? rename (src, dst)\n          : -1);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "renameat2": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "int\nrenameat2 (int fd1, char const *src, int fd2, char const *dst,\n           unsigned int flags)\n{\n  int ret_val = -1;\n  int err = EINVAL;\n\n#ifdef SYS_renameat2\n  ret_val = syscall (SYS_renameat2, fd1, src, fd2, dst, flags);\n  err = errno;\n#elif defined RENAME_EXCL\n  if (! (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE)))\n    {\n      ret_val = renameatx_np (fd1, src, fd2, dst,\n                             ((flags & RENAME_EXCHANGE ? RENAME_SWAP : 0)\n                              | (flags & RENAME_NOREPLACE ? RENAME_EXCL : 0)));\n      err = errno;\n    }\n#endif\n\n  if (! (ret_val < 0 && (err == EINVAL || err == ENOSYS || err == ENOTSUP)))\n    return ret_val;\n\n#if HAVE_RENAMEAT\n  {\n  size_t src_len;\n  size_t dst_len;\n  char *src_temp = (char *) src;\n  char *dst_temp = (char *) dst;\n  bool src_slash;\n  bool dst_slash;\n  int rename_errno = ENOTDIR;\n  struct stat src_st;\n  struct stat dst_st;\n  bool dst_found_nonexistent = false;\n\n  if (flags != 0)\n    {\n      /* RENAME_NOREPLACE is the only flag currently supported.  */\n      if (flags & ~RENAME_NOREPLACE)\n        return errno_fail (ENOTSUP);\n      else\n        {\n          /* This has a race between the call to lstatat and the calls to\n             renameat below.  */\n          if (lstatat (fd2, dst, &dst_st) == 0 || errno == EOVERFLOW)\n            return errno_fail (EEXIST);\n          if (errno != ENOENT)\n            return -1;\n          dst_found_nonexistent = true;\n        }\n    }\n\n  /* Let strace see any ENOENT failure.  */\n  src_len = strlen (src);\n  dst_len = strlen (dst);\n  if (!src_len || !dst_len)\n    return renameat (fd1, src, fd2, dst);\n\n  src_slash = src[src_len - 1] == '/';\n  dst_slash = dst[dst_len - 1] == '/';\n  if (!src_slash && !dst_slash)\n    return renameat (fd1, src, fd2, dst);\n\n  /* Presence of a trailing slash requires directory semantics.  If\n     the source does not exist, or if the destination cannot be turned\n     into a directory, give up now.  Otherwise, strip trailing slashes\n     before calling rename.  */\n  if (lstatat (fd1, src, &src_st))\n    return -1;\n  if (dst_found_nonexistent)\n    {\n      if (!S_ISDIR (src_st.st_mode))\n        return errno_fail (ENOENT);\n    }\n  else if (lstatat (fd2, dst, &dst_st))\n    {\n      if (errno != ENOENT || !S_ISDIR (src_st.st_mode))\n        return -1;\n    }\n  else if (!S_ISDIR (dst_st.st_mode))\n    return errno_fail (ENOTDIR);\n  else if (!S_ISDIR (src_st.st_mode))\n    return errno_fail (EISDIR);\n\n# if RENAME_TRAILING_SLASH_SOURCE_BUG\n  /* See the lengthy comment in rename.c why Solaris 9 is forced to\n     GNU behavior, while Solaris 10 is left with POSIX behavior,\n     regarding symlinks with trailing slash.  */\n  ret_val = -1;\n  if (src_slash)\n    {\n      src_temp = strdup (src);\n      if (!src_temp)\n        {\n          /* Rather than rely on strdup-posix, we set errno ourselves.  */\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (src_temp);\n      if (lstatat (fd1, src_temp, &src_st))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n      if (S_ISLNK (src_st.st_mode))\n        goto out;\n    }\n  if (dst_slash)\n    {\n      dst_temp = strdup (dst);\n      if (!dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (dst_temp);\n      if (lstatat (fd2, dst_temp, &dst_st))\n        {\n          if (errno != ENOENT)\n            {\n              rename_errno = errno;\n              goto out;\n            }\n        }\n      else if (S_ISLNK (dst_st.st_mode))\n        goto out;\n    }\n# endif /* RENAME_TRAILING_SLASH_SOURCE_BUG */\n\n  /* renameat does not honor trailing / on Solaris 10.  Solve it in a\n     similar manner to rename.  No need to worry about bugs not present\n     on Solaris, since all other systems either lack renameat or honor\n     trailing slash correctly.  */\n\n  ret_val = renameat (fd1, src_temp, fd2, dst_temp);\n  rename_errno = errno;\n  goto out;\n out:\n  if (src_temp != src)\n    free (src_temp);\n  if (dst_temp != dst)\n    free (dst_temp);\n  errno = rename_errno;\n  return ret_val;\n  }\n#else /* !HAVE_RENAMEAT */\n\n  /* RENAME_NOREPLACE is the only flag currently supported.  */\n  if (flags & ~RENAME_NOREPLACE)\n    return errno_fail (ENOTSUP);\n  return at_func2 (fd1, src, fd2, dst, flags ? rename_noreplace : rename);\n\n#endif /* !HAVE_RENAMEAT */\n}",
      "lines": 155,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/renameat2.h": {},
  "patch/patch-2.7.6/lib/rmdir.c": {
    "rpl_rmdir": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nrpl_rmdir (char const *dir)\n{\n  /* Work around cygwin 1.5.x bug where rmdir(\"dir/./\") succeeds.  */\n  size_t len = strlen (dir);\n  int result;\n  while (len && ISSLASH (dir[len - 1]))\n    len--;\n  if (len && dir[len - 1] == '.' && (1 == len || ISSLASH (dir[len - 2])))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  result = rmdir (dir);\n  /* Work around mingw bug, where rmdir(\"file/\") fails with EINVAL\n     instead of ENOTDIR.  We've already filtered out trailing ., the\n     only reason allowed by POSIX for EINVAL.  */\n  if (result == -1 && errno == EINVAL)\n    errno = ENOTDIR;\n  return result;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/root-uid.h": {},
  "patch/patch-2.7.6/lib/safe-read.c": {
    "safe_rw": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "size_t\nsafe_rw (int fd, void const *buf, size_t count)\n{\n  /* Work around a bug in Tru64 5.1.  Attempting to read more than\n     INT_MAX bytes fails with errno == EINVAL.  See\n     <https://lists.gnu.org/r/bug-gnu-utils/2002-04/msg00010.html>.\n     When decreasing COUNT, keep it block-aligned.  */\n  enum { BUGGY_READ_MAXIMUM = INT_MAX & ~8191 };\n\n  for (;;)\n    {\n      ssize_t result = rw (fd, buf, count);\n\n      if (0 <= result)\n        return result;\n      else if (IS_EINTR (errno))\n        continue;\n      else if (errno == EINVAL && BUGGY_READ_MAXIMUM < count)\n        count = BUGGY_READ_MAXIMUM;\n      else\n        return result;\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/safe-write.c": {},
  "patch/patch-2.7.6/lib/safe-write.h": {},
  "patch/patch-2.7.6/lib/same-inode.h": {},
  "patch/patch-2.7.6/lib/save-cwd.c": {
    "save_cwd": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\nsave_cwd (struct saved_cwd *cwd)\n{\n  cwd->name = NULL;\n\n  cwd->desc = open (\".\", O_SEARCH | O_CLOEXEC);\n  if (!GNULIB_FCNTL_SAFER)\n    cwd->desc = fd_safer_flag (cwd->desc, O_CLOEXEC);\n  if (cwd->desc < 0)\n    {\n      cwd->name = getcwd (NULL, 0);\n      return cwd->name ? 0 : -1;\n    }\n\n  return 0;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "restore_cwd": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nrestore_cwd (const struct saved_cwd *cwd)\n{\n  if (0 <= cwd->desc)\n    return fchdir (cwd->desc);\n  else\n    return chdir_long (cwd->name);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_cwd": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nfree_cwd (struct saved_cwd *cwd)\n{\n  if (cwd->desc >= 0)\n    close (cwd->desc);\n  free (cwd->name);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/save-cwd.h": {},
  "patch/patch-2.7.6/lib/setenv.c": {
    "__add_to_environ": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\n__add_to_environ (const char *name, const char *value, const char *combined,\n                  int replace)\n{\n  char **ep;\n  size_t size;\n  const size_t namelen = strlen (name);\n  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;\n\n  LOCK;\n\n  /* We have to get the pointer now that we have the lock and not earlier\n     since another thread might have created a new environment.  */\n  ep = __environ;\n\n  size = 0;\n  if (ep != NULL)\n    {\n      for (; *ep != NULL; ++ep)\n        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')\n          break;\n        else\n          ++size;\n    }\n\n  if (ep == NULL || *ep == NULL)\n    {\n      char **new_environ;\n#ifdef USE_TSEARCH\n      char *new_value;\n#endif\n\n      /* We allocated this space; we can extend it.  */\n      new_environ =\n        (char **) (last_environ == NULL\n                   ? malloc ((size + 2) * sizeof (char *))\n                   : realloc (last_environ, (size + 2) * sizeof (char *)));\n      if (new_environ == NULL)\n        {\n          /* It's easier to set errno to ENOMEM than to rely on the\n             'malloc-posix' and 'realloc-posix' gnulib modules.  */\n          __set_errno (ENOMEM);\n          UNLOCK;\n          return -1;\n        }\n\n      /* If the whole entry is given add it.  */\n      if (combined != NULL)\n        /* We must not add the string to the search tree since it belongs\n           to the user.  */\n        new_environ[size] = (char *) combined;\n      else\n        {\n          /* See whether the value is already known.  */\n#ifdef USE_TSEARCH\n# ifdef _LIBC\n          new_value = (char *) alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = (char *) malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          new_environ[size] = KNOWN_VALUE (new_value);\n          if (new_environ[size] == NULL)\n#endif\n            {\n              new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n              if (new_environ[size] == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (new_environ[size], new_value, namelen + 1 + vallen);\n#else\n              memcpy (new_environ[size], name, namelen);\n              new_environ[size][namelen] = '=';\n              memcpy (&new_environ[size][namelen + 1], value, vallen);\n#endif\n              /* And save the value now.  We cannot do this when we remove\n                 the string since then we cannot decide whether it is a\n                 user string or not.  */\n              STORE_VALUE (new_environ[size]);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      if (__environ != last_environ)\n        memcpy ((char *) new_environ, (char *) __environ,\n                size * sizeof (char *));\n\n      new_environ[size + 1] = NULL;\n\n      last_environ = __environ = new_environ;\n    }\n  else if (replace)\n    {\n      char *np;\n\n      /* Use the user string if given.  */\n      if (combined != NULL)\n        np = (char *) combined;\n      else\n        {\n#ifdef USE_TSEARCH\n          char *new_value;\n# ifdef _LIBC\n          new_value = alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          np = KNOWN_VALUE (new_value);\n          if (np == NULL)\n#endif\n            {\n              np = (char *) malloc (namelen + 1 + vallen);\n              if (np == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (np, new_value, namelen + 1 + vallen);\n#else\n              memcpy (np, name, namelen);\n              np[namelen] = '=';\n              memcpy (&np[namelen + 1], value, vallen);\n#endif\n              /* And remember the value.  */\n              STORE_VALUE (np);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      *ep = np;\n    }\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 177,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "setenv": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "clearenv": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_mem": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nfree_mem (void)\n{\n  /* Remove all traces.  */\n  clearenv ();\n\n  /* Now remove the search tree.  */\n  __tdestroy (known_values, free);\n  known_values = NULL;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_setenv": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\nrpl_setenv (const char *name, const char *value, int replace)\n{\n  int result;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Call the real setenv even if replace is 0, in case implementation\n     has underlying data to update, such as when environ changes.  */\n  result = setenv (name, value, replace);\n  if (result == 0 && replace && *value == '=')\n    {\n      char *tmp = getenv (name);\n      if (!STREQ (tmp, value))\n        {\n          int saved_errno;\n          size_t len = strlen (value);\n          tmp = malloca (len + 2);\n          /* Since leading '=' is eaten, double it up.  */\n          *tmp = '=';\n          memcpy (tmp + 1, value, len + 1);\n          result = setenv (name, tmp, replace);\n          saved_errno = errno;\n          freea (tmp);\n          errno = saved_errno;\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/signal.in.h": {},
  "patch/patch-2.7.6/lib/size_max.h": {},
  "patch/patch-2.7.6/lib/stat-time.c": {},
  "patch/patch-2.7.6/lib/stat-time.h": {
    "get_stat_atime_ns": {
      "start_point": [
        64,
        26
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_atime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_atim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_atim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_ctime_ns": {
      "start_point": [
        77,
        26
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_ctime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_ctim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_ctim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_mtime_ns": {
      "start_point": [
        90,
        26
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_mtime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_mtim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_mtim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_birthtime_ns": {
      "start_point": [
        103,
        26
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_birthtime_ns (struct stat const *st _GL_UNUSED)\n{\n# if defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC\n  return STAT_TIMESPEC (st, st_birthtim).tv_nsec;\n# elif defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC\n  return STAT_TIMESPEC_NS (st, st_birthtim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_atime": {
      "start_point": [
        116,
        28
      ],
      "end_point": [
        127,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_atime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_atim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_atime;\n  t.tv_nsec = get_stat_atime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_ctime": {
      "start_point": [
        130,
        28
      ],
      "end_point": [
        141,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_ctime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_ctim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_ctime;\n  t.tv_nsec = get_stat_ctime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_mtime": {
      "start_point": [
        144,
        28
      ],
      "end_point": [
        155,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_mtime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_mtim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_mtime;\n  t.tv_nsec = get_stat_mtime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_birthtime": {
      "start_point": [
        159,
        28
      ],
      "end_point": [
        202,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_birthtime (struct stat const *st _GL_UNUSED)\n{\n  struct timespec t;\n\n#if (defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC)\n  t = STAT_TIMESPEC (st, st_birthtim);\n#elif defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC\n  t.tv_sec = st->st_birthtime;\n  t.tv_nsec = st->st_birthtimensec;\n#elif (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Native Windows platforms (but not Cygwin) put the \"file creation\n     time\" in st_ctime (!).  See\n     <https://msdn.microsoft.com/en-us/library/14h5k7ff(VS.80).aspx>.  */\n# if _GL_WINDOWS_STAT_TIMESPEC\n  t = st->st_ctim;\n# else\n  t.tv_sec = st->st_ctime;\n  t.tv_nsec = 0;\n# endif\n#else\n  /* Birth time is not supported.  */\n  t.tv_sec = -1;\n  t.tv_nsec = -1;\n#endif\n\n#if (defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC)\n  /* FreeBSD and NetBSD sometimes signal the absence of knowledge by\n     using zero.  Attempt to work around this problem.  Alas, this can\n     report failure even for valid timestamps.  Also, NetBSD\n     sometimes returns junk in the birth time fields; work around this\n     bug if it is detected.  */\n  if (! (t.tv_sec && 0 <= t.tv_nsec && t.tv_nsec < 1000000000))\n    {\n      t.tv_sec = -1;\n      t.tv_nsec = -1;\n    }\n#endif\n\n  return t;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "stat_time_normalize": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "_GL_STAT_TIME_INLINE int\nstat_time_normalize (int result, struct stat *st _GL_UNUSED)\n{\n#if defined __sun && defined STAT_TIMESPEC\n  if (result == 0)\n    {\n      long int timespec_resolution = 1000000000;\n      short int const ts_off[] = { offsetof (struct stat, st_atim),\n                                   offsetof (struct stat, st_mtim),\n                                   offsetof (struct stat, st_ctim) };\n      int i;\n      for (i = 0; i < sizeof ts_off / sizeof *ts_off; i++)\n        {\n          struct timespec *ts = (struct timespec *) ((char *) st + ts_off[i]);\n          long int q = ts->tv_nsec / timespec_resolution;\n          long int r = ts->tv_nsec % timespec_resolution;\n          if (r < 0)\n            {\n              r += timespec_resolution;\n              q--;\n            }\n          ts->tv_nsec = r;\n          /* Overflow is possible, as Solaris 11 stat can yield\n             tv_sec == TYPE_MINIMUM (time_t) && tv_nsec == -1000000000.\n             INT_ADD_WRAPV is OK, since time_t is signed on Solaris.  */\n          if (INT_ADD_WRAPV (q, ts->tv_sec, &ts->tv_sec))\n            {\n              errno = EOVERFLOW;\n              return -1;\n            }\n        }\n    }\n#endif\n  return result;\n}",
      "lines": 35,
      "depth": 16,
      "decorators": [
        "_GL_STAT_TIME_INLINE",
        "int",
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/stat-w32.c": {
    "initialize": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\ninitialize (void)\n{\n  HMODULE kernel32 = LoadLibrary (\"kernel32.dll\");\n  if (kernel32 != NULL)\n    {\n#if _GL_WINDOWS_STAT_INODES == 2\n      GetFileInformationByHandleExFunc =\n        (GetFileInformationByHandleExFuncType) GetProcAddress (kernel32, \"GetFileInformationByHandleEx\");\n#endif\n      GetFinalPathNameByHandleFunc =\n        (GetFinalPathNameByHandleFuncType) GetProcAddress (kernel32, \"GetFinalPathNameByHandleA\");\n    }\n  initialized = TRUE;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_gl_convert_FILETIME_to_timespec": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "struct timespec\n_gl_convert_FILETIME_to_timespec (const FILETIME *ft)\n{\n  struct timespec result;\n  /* FILETIME: <https://msdn.microsoft.com/en-us/library/ms724284.aspx> */\n  unsigned long long since_1601 =\n    ((unsigned long long) ft->dwHighDateTime << 32)\n    | (unsigned long long) ft->dwLowDateTime;\n  if (since_1601 == 0)\n    {\n      result.tv_sec = 0;\n      result.tv_nsec = 0;\n    }\n  else\n    {\n      /* Between 1601-01-01 and 1970-01-01 there were 280 normal years and 89\n         leap years, in total 134774 days.  */\n      unsigned long long since_1970 =\n        since_1601 - (unsigned long long) 134774 * (unsigned long long) 86400 * (unsigned long long) 10000000;\n      result.tv_sec = since_1970 / (unsigned long long) 10000000;\n      result.tv_nsec = (unsigned long) (since_1970 % (unsigned long long) 10000000) * 100;\n    }\n  return result;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "struct timespec",
        "struct",
        "timespec"
      ]
    },
    "_gl_convert_FILETIME_to_POSIX": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "time_t\n_gl_convert_FILETIME_to_POSIX (const FILETIME *ft)\n{\n  /* FILETIME: <https://msdn.microsoft.com/en-us/library/ms724284.aspx> */\n  unsigned long long since_1601 =\n    ((unsigned long long) ft->dwHighDateTime << 32)\n    | (unsigned long long) ft->dwLowDateTime;\n  if (since_1601 == 0)\n    return 0;\n  else\n    {\n      /* Between 1601-01-01 and 1970-01-01 there were 280 normal years and 89\n         leap years, in total 134774 days.  */\n      unsigned long long since_1970 =\n        since_1601 - (unsigned long long) 134774 * (unsigned long long) 86400 * (unsigned long long) 10000000;\n      return since_1970 / (unsigned long long) 10000000;\n    }\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "time_t"
      ]
    },
    "_gl_fstat_by_handle": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "int\n_gl_fstat_by_handle (HANDLE h, const char *path, struct stat *buf)\n{\n  /* GetFileType\n     <https://msdn.microsoft.com/en-us/library/aa364960.aspx> */\n  DWORD type = GetFileType (h);\n  if (type == FILE_TYPE_DISK)\n    {\n      if (!initialized)\n        initialize ();\n\n      /* st_mode can be determined through\n         GetFileAttributesEx\n         <https://msdn.microsoft.com/en-us/library/aa364946.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365739.aspx>\n         or through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileBasicInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364217.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n      BY_HANDLE_FILE_INFORMATION info;\n      if (! GetFileInformationByHandle (h, &info))\n        goto failed;\n\n      /* Test for error conditions before starting to fill *buf.  */\n      if (sizeof (buf->st_size) <= 4 && info.nFileSizeHigh > 0)\n        {\n          errno = EOVERFLOW;\n          return -1;\n        }\n\n#if _GL_WINDOWS_STAT_INODES\n      /* st_ino can be determined through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         as 64 bits, or through\n         GetFileInformationByHandleEx with argument FileIdInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/hh802691.aspx>\n         as 128 bits.\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_WIN8 or higher.  */\n      /* Experiments show that GetFileInformationByHandleEx does not provide\n         much more information than GetFileInformationByHandle:\n           * The dwVolumeSerialNumber from GetFileInformationByHandle is equal\n             to the low 32 bits of the 64-bit VolumeSerialNumber from\n             GetFileInformationByHandleEx, and is apparently sufficient for\n             identifying the device.\n           * The nFileIndex from GetFileInformationByHandle is equal to the low\n             64 bits of the 128-bit FileId from GetFileInformationByHandleEx,\n             and the high 64 bits of this 128-bit FileId are zero.\n           * On a FAT file system, GetFileInformationByHandleEx fails with error\n             ERROR_INVALID_PARAMETER, whereas GetFileInformationByHandle\n             succeeds.\n           * On a CIFS/SMB file system, GetFileInformationByHandleEx fails with\n             error ERROR_INVALID_LEVEL, whereas GetFileInformationByHandle\n             succeeds.  */\n# if _GL_WINDOWS_STAT_INODES == 2\n      if (GetFileInformationByHandleExFunc != NULL)\n        {\n          FILE_ID_INFO id;\n          if (GetFileInformationByHandleExFunc (h, FileIdInfo, &id, sizeof (id)))\n            {\n              buf->st_dev = id.VolumeSerialNumber;\n              verify (sizeof (ino_t) == sizeof (id.FileId));\n              memcpy (&buf->st_ino, &id.FileId, sizeof (ino_t));\n              goto ino_done;\n            }\n          else\n            {\n              switch (GetLastError ())\n                {\n                case ERROR_INVALID_PARAMETER: /* older Windows version, or FAT */\n                case ERROR_INVALID_LEVEL: /* CIFS/SMB file system */\n                  goto fallback;\n                default:\n                  goto failed;\n                }\n            }\n        }\n     fallback: ;\n      /* Fallback for older Windows versions.  */\n      buf->st_dev = info.dwVolumeSerialNumber;\n      buf->st_ino._gl_ino[0] = ((ULONGLONG) info.nFileIndexHigh << 32) | (ULONGLONG) info.nFileIndexLow;\n      buf->st_ino._gl_ino[1] = 0;\n     ino_done: ;\n# else /* _GL_WINDOWS_STAT_INODES == 1 */\n      buf->st_dev = info.dwVolumeSerialNumber;\n      buf->st_ino = ((ULONGLONG) info.nFileIndexHigh << 32) | (ULONGLONG) info.nFileIndexLow;\n# endif\n#else\n      /* st_ino is not wide enough for identifying a file on a device.\n         Without st_ino, st_dev is pointless.  */\n      buf->st_dev = 0;\n      buf->st_ino = 0;\n#endif\n\n      /* st_mode.  */\n      unsigned int mode =\n        /* XXX How to handle FILE_ATTRIBUTE_REPARSE_POINT ?  */\n        ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : _S_IFREG)\n        | S_IREAD_UGO\n        | ((info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? 0 : S_IWRITE_UGO);\n      if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))\n        {\n          /* Determine whether the file is executable by looking at the file\n             name suffix.\n             If the file name is already known, use it. Otherwise, for\n             non-empty files, it can be determined through\n             GetFinalPathNameByHandle\n             <https://msdn.microsoft.com/en-us/library/aa364962.aspx>\n             or through\n             GetFileInformationByHandleEx with argument FileNameInfo\n             <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n             <https://msdn.microsoft.com/en-us/library/aa364388.aspx>\n             Both require -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n          if (info.nFileSizeHigh > 0 || info.nFileSizeLow > 0)\n            {\n              char fpath[PATH_MAX];\n              if (path != NULL\n                  || (GetFinalPathNameByHandleFunc != NULL\n                      && GetFinalPathNameByHandleFunc (h, fpath, sizeof (fpath), VOLUME_NAME_NONE)\n                         < sizeof (fpath)\n                      && (path = fpath, 1)))\n                {\n                  const char *last_dot = NULL;\n                  const char *p;\n                  for (p = path; *p != '\\0'; p++)\n                    if (*p == '.')\n                      last_dot = p;\n                  if (last_dot != NULL)\n                    {\n                      const char *suffix = last_dot + 1;\n                      if (_stricmp (suffix, \"exe\") == 0\n                          || _stricmp (suffix, \"bat\") == 0\n                          || _stricmp (suffix, \"cmd\") == 0\n                          || _stricmp (suffix, \"com\") == 0)\n                        mode |= S_IEXEC_UGO;\n                    }\n                }\n              else\n                /* Cannot determine file name.  Pretend that it is executable.  */\n                mode |= S_IEXEC_UGO;\n            }\n        }\n      buf->st_mode = mode;\n\n      /* st_nlink can be determined through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileStandardInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364401.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n      buf->st_nlink = (info.nNumberOfLinks > SHRT_MAX ? SHRT_MAX : info.nNumberOfLinks);\n\n      /* There's no easy way to map the Windows SID concept to an integer.  */\n      buf->st_uid = 0;\n      buf->st_gid = 0;\n\n      /* st_rdev is irrelevant for normal files and directories.  */\n      buf->st_rdev = 0;\n\n      /* st_size can be determined through\n         GetFileSizeEx\n         <https://msdn.microsoft.com/en-us/library/aa364957.aspx>\n         or through\n         GetFileAttributesEx\n         <https://msdn.microsoft.com/en-us/library/aa364946.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365739.aspx>\n         or through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileStandardInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364401.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n      if (sizeof (buf->st_size) <= 4)\n        /* Range check already done above.  */\n        buf->st_size = info.nFileSizeLow;\n      else\n        buf->st_size = ((long long) info.nFileSizeHigh << 32) | (long long) info.nFileSizeLow;\n\n      /* st_atime, st_mtime, st_ctime can be determined through\n         GetFileTime\n         <https://msdn.microsoft.com/en-us/library/ms724320.aspx>\n         or through\n         GetFileAttributesEx\n         <https://msdn.microsoft.com/en-us/library/aa364946.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365739.aspx>\n         or through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileBasicInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364217.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n#if _GL_WINDOWS_STAT_TIMESPEC\n      buf->st_atim = _gl_convert_FILETIME_to_timespec (&info.ftLastAccessTime);\n      buf->st_mtim = _gl_convert_FILETIME_to_timespec (&info.ftLastWriteTime);\n      buf->st_ctim = _gl_convert_FILETIME_to_timespec (&info.ftCreationTime);\n#else\n      buf->st_atime = _gl_convert_FILETIME_to_POSIX (&info.ftLastAccessTime);\n      buf->st_mtime = _gl_convert_FILETIME_to_POSIX (&info.ftLastWriteTime);\n      buf->st_ctime = _gl_convert_FILETIME_to_POSIX (&info.ftCreationTime);\n#endif\n\n      return 0;\n    }\n  else if (type == FILE_TYPE_CHAR || type == FILE_TYPE_PIPE)\n    {\n      buf->st_dev = 0;\n#if _GL_WINDOWS_STAT_INODES == 2\n      buf->st_ino._gl_ino[0] = buf->st_ino._gl_ino[1] = 0;\n#else\n      buf->st_ino = 0;\n#endif\n      buf->st_mode = (type == FILE_TYPE_PIPE ? _S_IFIFO : _S_IFCHR);\n      buf->st_nlink = 1;\n      buf->st_uid = 0;\n      buf->st_gid = 0;\n      buf->st_rdev = 0;\n      if (type == FILE_TYPE_PIPE)\n        {\n          /* PeekNamedPipe\n             <https://msdn.microsoft.com/en-us/library/aa365779.aspx> */\n          DWORD bytes_available;\n          if (PeekNamedPipe (h, NULL, 0, NULL, &bytes_available, NULL))\n            buf->st_size = bytes_available;\n          else\n            buf->st_size = 0;\n        }\n      else\n        buf->st_size = 0;\n#if _GL_WINDOWS_STAT_TIMESPEC\n      buf->st_atim.tv_sec = 0; buf->st_atim.tv_nsec = 0;\n      buf->st_mtim.tv_sec = 0; buf->st_mtim.tv_nsec = 0;\n      buf->st_ctim.tv_sec = 0; buf->st_ctim.tv_nsec = 0;\n#else\n      buf->st_atime = 0;\n      buf->st_mtime = 0;\n      buf->st_ctime = 0;\n#endif\n      return 0;\n    }\n  else\n    {\n      errno = ENOENT;\n      return -1;\n    }\n\n failed:\n  {\n    DWORD error = GetLastError ();\n    #if 0\n    fprintf (stderr, \"_gl_fstat_by_handle error 0x%x\\n\", (unsigned int) error);\n    #endif\n    switch (error)\n      {\n      case ERROR_ACCESS_DENIED:\n      case ERROR_SHARING_VIOLATION:\n        errno = EACCES;\n        break;\n\n      case ERROR_OUTOFMEMORY:\n        errno = ENOMEM;\n        break;\n\n      case ERROR_WRITE_FAULT:\n      case ERROR_READ_FAULT:\n      case ERROR_GEN_FAILURE:\n        errno = EIO;\n        break;\n\n      default:\n        errno = EINVAL;\n        break;\n      }\n    return -1;\n  }\n}",
      "lines": 291,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/stat-w32.h": {},
  "patch/patch-2.7.6/lib/stat.c": {
    "orig_stat": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_unc_root": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static BOOL\nis_unc_root (const char *rname)\n{\n  /* Test whether it has the syntax '\\\\server\\share'.  */\n  if (ISSLASH (rname[0]) && ISSLASH (rname[1]))\n    {\n      /* It starts with two slashes.  Find the next slash.  */\n      const char *p = rname + 2;\n      const char *q = p;\n      while (*q != '\\0' && !ISSLASH (*q))\n        q++;\n      if (q > p && *q != '\\0')\n        {\n          /* Found the next slash at q.  */\n          q++;\n          const char *r = q;\n          while (*r != '\\0' && !ISSLASH (*r))\n            r++;\n          if (r > q && *r == '\\0')\n            return TRUE;\n        }\n    }\n  return FALSE;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "rpl_stat": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *buf)\n{\n#ifdef WINDOWS_NATIVE\n  /* Fill the fields ourselves, because the original stat function returns\n     values for st_atime, st_mtime, st_ctime that depend on the current time\n     zone.  See\n     <https://lists.gnu.org/r/bug-gnulib/2017-04/msg00134.html>  */\n  /* XXX Should we convert to wchar_t* and prepend '\\\\?\\', in order to work\n     around length limitations\n     <https://msdn.microsoft.com/en-us/library/aa365247.aspx> ?  */\n\n  /* POSIX <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>\n     specifies: \"More than two leading <slash> characters shall be treated as\n     a single <slash> character.\"  */\n  if (ISSLASH (name[0]) && ISSLASH (name[1]) && ISSLASH (name[2]))\n    {\n      name += 2;\n      while (ISSLASH (name[1]))\n        name++;\n    }\n\n  size_t len = strlen (name);\n  size_t drive_prefix_len = (HAS_DEVICE (name) ? 2 : 0);\n\n  /* Remove trailing slashes (except the very first one, at position\n     drive_prefix_len), but remember their presence.  */\n  size_t rlen;\n  bool check_dir = false;\n\n  rlen = len;\n  while (rlen > drive_prefix_len && ISSLASH (name[rlen-1]))\n    {\n      check_dir = true;\n      if (rlen == drive_prefix_len + 1)\n        break;\n      rlen--;\n    }\n\n  /* Handle '' and 'C:'.  */\n  if (!check_dir && rlen == drive_prefix_len)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n\n  /* Handle '\\\\'.  */\n  if (rlen == 1 && ISSLASH (name[0]) && len >= 2)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n\n  const char *rname;\n  char *malloca_rname;\n  if (rlen == len)\n    {\n      rname = name;\n      malloca_rname = NULL;\n    }\n  else\n    {\n      malloca_rname = malloca (rlen + 1);\n      if (malloca_rname == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      memcpy (malloca_rname, name, rlen);\n      malloca_rname[rlen] = '\\0';\n      rname = malloca_rname;\n    }\n\n  /* There are two ways to get at the requested information:\n       - by scanning the parent directory and examining the relevant\n         directory entry,\n       - by opening the file directly.\n     The first approach fails for root directories (e.g. 'C:\\') and\n     UNC root directories (e.g. '\\\\server\\share').\n     The second approach fails for some system files (e.g. 'C:\\pagefile.sys'\n     and 'C:\\hiberfil.sys'): ERROR_SHARING_VIOLATION.\n     The second approach gives more information (in particular, correct\n     st_dev, st_ino, st_nlink fields).\n     So we use the second approach and, as a fallback except for root and\n     UNC root directories, also the first approach.  */\n  {\n    int ret;\n\n    {\n      /* Approach based on the file.  */\n\n      /* Open a handle to the file.\n         CreateFile\n         <https://msdn.microsoft.com/en-us/library/aa363858.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363874.aspx>  */\n      HANDLE h =\n        CreateFile (rname,\n                    FILE_READ_ATTRIBUTES,\n                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                    NULL,\n                    OPEN_EXISTING,\n                    /* FILE_FLAG_POSIX_SEMANTICS (treat file names that differ only\n                       in case as different) makes sense only when applied to *all*\n                       filesystem operations.  */\n                    FILE_FLAG_BACKUP_SEMANTICS /* | FILE_FLAG_POSIX_SEMANTICS */,\n                    NULL);\n      if (h != INVALID_HANDLE_VALUE)\n        {\n          ret = _gl_fstat_by_handle (h, rname, buf);\n          CloseHandle (h);\n          goto done;\n        }\n    }\n\n    /* Test for root and UNC root directories.  */\n    if ((rlen == drive_prefix_len + 1 && ISSLASH (rname[drive_prefix_len]))\n        || is_unc_root (rname))\n      goto failed;\n\n    /* Fallback.  */\n    {\n      /* Approach based on the directory entry.  */\n\n      if (strchr (rname, '?') != NULL || strchr (rname, '*') != NULL)\n        {\n          /* Other Windows API functions would fail with error\n             ERROR_INVALID_NAME.  */\n          if (malloca_rname != NULL)\n            freea (malloca_rname);\n          errno = ENOENT;\n          return -1;\n        }\n\n      /* Get the details about the directory entry.  This can be done through\n         FindFirstFile\n         <https://msdn.microsoft.com/en-us/library/aa364418.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365740.aspx>\n         or through\n         FindFirstFileEx with argument FindExInfoBasic\n         <https://msdn.microsoft.com/en-us/library/aa364419.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364415.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365740.aspx>  */\n      WIN32_FIND_DATA info;\n      HANDLE h = FindFirstFile (rname, &info);\n      if (h == INVALID_HANDLE_VALUE)\n        goto failed;\n\n      /* Test for error conditions before starting to fill *buf.  */\n      if (sizeof (buf->st_size) <= 4 && info.nFileSizeHigh > 0)\n        {\n          FindClose (h);\n          if (malloca_rname != NULL)\n            freea (malloca_rname);\n          errno = EOVERFLOW;\n          return -1;\n        }\n\n# if _GL_WINDOWS_STAT_INODES\n      buf->st_dev = 0;\n#  if _GL_WINDOWS_STAT_INODES == 2\n      buf->st_ino._gl_ino[0] = buf->st_ino._gl_ino[1] = 0;\n#  else /* _GL_WINDOWS_STAT_INODES == 1 */\n      buf->st_ino = 0;\n#  endif\n# else\n      /* st_ino is not wide enough for identifying a file on a device.\n         Without st_ino, st_dev is pointless.  */\n      buf->st_dev = 0;\n      buf->st_ino = 0;\n# endif\n\n      /* st_mode.  */\n      unsigned int mode =\n        /* XXX How to handle FILE_ATTRIBUTE_REPARSE_POINT ?  */\n        ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : _S_IFREG)\n        | S_IREAD_UGO\n        | ((info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? 0 : S_IWRITE_UGO);\n      if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))\n        {\n          /* Determine whether the file is executable by looking at the file\n             name suffix.  */\n          if (info.nFileSizeHigh > 0 || info.nFileSizeLow > 0)\n            {\n              const char *last_dot = NULL;\n              const char *p;\n              for (p = info.cFileName; *p != '\\0'; p++)\n                if (*p == '.')\n                  last_dot = p;\n              if (last_dot != NULL)\n                {\n                  const char *suffix = last_dot + 1;\n                  if (_stricmp (suffix, \"exe\") == 0\n                      || _stricmp (suffix, \"bat\") == 0\n                      || _stricmp (suffix, \"cmd\") == 0\n                      || _stricmp (suffix, \"com\") == 0)\n                    mode |= S_IEXEC_UGO;\n                }\n            }\n        }\n      buf->st_mode = mode;\n\n      /* st_nlink.  Ignore hard links here.  */\n      buf->st_nlink = 1;\n\n      /* There's no easy way to map the Windows SID concept to an integer.  */\n      buf->st_uid = 0;\n      buf->st_gid = 0;\n\n      /* st_rdev is irrelevant for normal files and directories.  */\n      buf->st_rdev = 0;\n\n      /* st_size.  */\n      if (sizeof (buf->st_size) <= 4)\n        /* Range check already done above.  */\n        buf->st_size = info.nFileSizeLow;\n      else\n        buf->st_size = ((long long) info.nFileSizeHigh << 32) | (long long) info.nFileSizeLow;\n\n      /* st_atime, st_mtime, st_ctime.  */\n# if _GL_WINDOWS_STAT_TIMESPEC\n      buf->st_atim = _gl_convert_FILETIME_to_timespec (&info.ftLastAccessTime);\n      buf->st_mtim = _gl_convert_FILETIME_to_timespec (&info.ftLastWriteTime);\n      buf->st_ctim = _gl_convert_FILETIME_to_timespec (&info.ftCreationTime);\n# else\n      buf->st_atime = _gl_convert_FILETIME_to_POSIX (&info.ftLastAccessTime);\n      buf->st_mtime = _gl_convert_FILETIME_to_POSIX (&info.ftLastWriteTime);\n      buf->st_ctime = _gl_convert_FILETIME_to_POSIX (&info.ftCreationTime);\n# endif\n\n      FindClose (h);\n\n      ret = 0;\n    }\n\n   done:\n    if (ret >= 0 && check_dir && !S_ISDIR (buf->st_mode))\n      {\n        errno = ENOTDIR;\n        ret = -1;\n      }\n    if (malloca_rname != NULL)\n      {\n        int saved_errno = errno;\n        freea (malloca_rname);\n        errno = saved_errno;\n      }\n    return ret;\n  }\n\n failed:\n  {\n    DWORD error = GetLastError ();\n    #if 0\n    fprintf (stderr, \"rpl_stat error 0x%x\\n\", (unsigned int) error);\n    #endif\n\n    if (malloca_rname != NULL)\n      freea (malloca_rname);\n\n    switch (error)\n      {\n      /* Some of these errors probably cannot happen with the specific flags\n         that we pass to CreateFile.  But who knows...  */\n      case ERROR_FILE_NOT_FOUND: /* The last component of rname does not exist.  */\n      case ERROR_PATH_NOT_FOUND: /* Some directory component in rname does not exist.  */\n      case ERROR_BAD_PATHNAME:   /* rname is such as '\\\\server'.  */\n      case ERROR_BAD_NET_NAME:   /* rname is such as '\\\\server\\nonexistentshare'.  */\n      case ERROR_INVALID_NAME:   /* rname contains wildcards, misplaced colon, etc.  */\n      case ERROR_DIRECTORY:\n        errno = ENOENT;\n        break;\n\n      case ERROR_ACCESS_DENIED:  /* rname is such as 'C:\\System Volume Information\\foo'.  */\n      case ERROR_SHARING_VIOLATION: /* rname is such as 'C:\\pagefile.sys' (second approach only).  */\n                                    /* XXX map to EACCESS or EPERM? */\n        errno = EACCES;\n        break;\n\n      case ERROR_OUTOFMEMORY:\n        errno = ENOMEM;\n        break;\n\n      case ERROR_WRITE_PROTECT:\n        errno = EROFS;\n        break;\n\n      case ERROR_WRITE_FAULT:\n      case ERROR_READ_FAULT:\n      case ERROR_GEN_FAILURE:\n        errno = EIO;\n        break;\n\n      case ERROR_BUFFER_OVERFLOW:\n      case ERROR_FILENAME_EXCED_RANGE:\n        errno = ENAMETOOLONG;\n        break;\n\n      case ERROR_DELETE_PENDING: /* XXX map to EACCESS or EPERM? */\n        errno = EPERM;\n        break;\n\n      default:\n        errno = EINVAL;\n        break;\n      }\n\n    return -1;\n  }\n#else\n  int result = orig_stat (name, buf);\n  if (result == 0)\n    {\n# if REPLACE_FUNC_STAT_FILE\n      /* Solaris 9 mistakenly succeeds when given a non-directory with a\n         trailing slash.  */\n      if (!S_ISDIR (buf->st_mode))\n        {\n          size_t len = strlen (name);\n          if (ISSLASH (name[len - 1]))\n            {\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n# endif /* REPLACE_FUNC_STAT_FILE */\n      result = stat_time_normalize (result, buf);\n    }\n  return result;\n#endif\n}",
      "lines": 330,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/statat.c": {},
  "patch/patch-2.7.6/lib/stdarg.in.h": {},
  "patch/patch-2.7.6/lib/stdbool.in.h": {},
  "patch/patch-2.7.6/lib/stddef.in.h": {},
  "patch/patch-2.7.6/lib/stdint.in.h": {},
  "patch/patch-2.7.6/lib/stdio.in.h": {},
  "patch/patch-2.7.6/lib/stdlib.in.h": {},
  "patch/patch-2.7.6/lib/strdup.c": {
    "__strdup": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "char *\n__strdup (const char *s)\n{\n  size_t len = strlen (s) + 1;\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (char *) memcpy (new, s, len);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__strdup (const char *s)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/strerror-override.h": {},
  "patch/patch-2.7.6/lib/strerror.c": {},
  "patch/patch-2.7.6/lib/strftime.h": {},
  "patch/patch-2.7.6/lib/string.in.h": {},
  "patch/patch-2.7.6/lib/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "patch/patch-2.7.6/lib/strndup.c": {
    "strndup": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nstrndup (char const *s, size_t n)\n{\n  size_t len = strnlen (s, n);\n  char *new = malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return memcpy (new, s, len);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrndup (char const *s, size_t n)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/strnlen.c": {
    "strnlen": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\nstrnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/symlink.c": {
    "rpl_symlink": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nrpl_symlink (char const *contents, char const *name)\n{\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      struct stat st;\n      if (lstat (name, &st) == 0)\n        errno = EEXIST;\n      return -1;\n    }\n  return symlink (contents, name);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "symlink": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nsymlink (char const *contents _GL_UNUSED,\n         char const *name _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/symlinkat.c": {
    "rpl_symlinkat": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nrpl_symlinkat (char const *contents, int fd, char const *name)\n{\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      struct stat st;\n      if (fstatat (fd, name, &st, 0) == 0)\n        errno = EEXIST;\n      return -1;\n    }\n  return symlinkat (contents, fd, name);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "symlinkat": [
      {
        "start_point": [
          48,
          0
        ],
        "end_point": [
          54,
          1
        ],
        "content": "int\nsymlinkat (char const *path1 _GL_UNUSED, int fd _GL_UNUSED,\n           char const *path2 _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          93,
          1
        ],
        "content": "int\nsymlinkat (char const *contents, int fd, char const *file)\n{\n  return symlinkat_reversed (fd, file, contents);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "symlink_reversed": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nsymlink_reversed (char const *file, char const *contents)\n{\n  return symlink (contents, file);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/sys_time.in.h": {
    "GNULIB_NAMESPACE": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "namespace GNULIB_NAMESPACE {\n  typedef ::timeval\n#undef timeval\n    timeval;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": null
    }
  },
  "patch/patch-2.7.6/lib/sys_types.in.h": {},
  "patch/patch-2.7.6/lib/tempname.c": {
    "direxists": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\ndirexists (const char *dir)\n{\n  struct_stat64 buf;\n  return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__path_search": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\n__path_search (char *tmpl, size_t tmpl_len, const char *dir, const char *pfx,\n               int try_tmpdir)\n{\n  const char *d;\n  size_t dlen, plen;\n\n  if (!pfx || !pfx[0])\n    {\n      pfx = \"file\";\n      plen = 4;\n    }\n  else\n    {\n      plen = strlen (pfx);\n      if (plen > 5)\n        plen = 5;\n    }\n\n  if (try_tmpdir)\n    {\n      d = __secure_getenv (\"TMPDIR\");\n      if (d != NULL && direxists (d))\n        dir = d;\n      else if (dir != NULL && direxists (dir))\n        /* nothing */ ;\n      else\n        dir = NULL;\n    }\n  if (dir == NULL)\n    {\n      if (direxists (P_tmpdir))\n        dir = P_tmpdir;\n      else if (strcmp (P_tmpdir, \"/tmp\") != 0 && direxists (\"/tmp\"))\n        dir = \"/tmp\";\n      else\n        {\n          __set_errno (ENOENT);\n          return -1;\n        }\n    }\n\n  dlen = strlen (dir);\n  while (dlen > 1 && dir[dlen - 1] == '/')\n    dlen--;                     /* remove trailing slashes */\n\n  /* check we have room for \"${dir}/${pfx}XXXXXX\\0\" */\n  if (tmpl_len < dlen + 1 + plen + 6 + 1)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  sprintf (tmpl, \"%.*s/%.*sXXXXXX\", (int) dlen, dir, (int) plen, pfx);\n  return 0;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "__try_tempname": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "int\n__try_tempname (char *tmpl, int suffixlen, void *args,\n                int (*tryfunc) (char *, void *))\n{\n  int len;\n  char *XXXXXX;\n  static uint64_t value;\n  uint64_t random_time_bits;\n  unsigned int count;\n  int fd = -1;\n  int save_errno = errno;\n\n  /* A lower bound on the number of temporary files to attempt to\n     generate.  The maximum total number of temporary file names that\n     can exist for a given template is 62**6.  It should never be\n     necessary to try all of these combinations.  Instead if a reasonable\n     number of names is tried (we define reasonable as 62**3) fail to\n     give the system administrator the chance to remove the problems.  */\n#define ATTEMPTS_MIN (62 * 62 * 62)\n\n  /* The number of times to attempt to generate a temporary file.  To\n     conform to POSIX, this must be no smaller than TMP_MAX.  */\n#if ATTEMPTS_MIN < TMP_MAX\n  unsigned int attempts = TMP_MAX;\n#else\n  unsigned int attempts = ATTEMPTS_MIN;\n#endif\n\n  len = strlen (tmpl);\n  if (len < 6 + suffixlen || memcmp (&tmpl[len - 6 - suffixlen], \"XXXXXX\", 6))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* This is where the Xs start.  */\n  XXXXXX = &tmpl[len - 6 - suffixlen];\n\n  /* Get some more or less random data.  */\n#ifdef RANDOM_BITS\n  RANDOM_BITS (random_time_bits);\n#else\n  {\n    struct timeval tv;\n    __gettimeofday (&tv, NULL);\n    random_time_bits = ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec;\n  }\n#endif\n  value += random_time_bits ^ __getpid ();\n\n  for (count = 0; count < attempts; value += 7777, ++count)\n    {\n      uint64_t v = value;\n\n      /* Fill in the random bits.  */\n      XXXXXX[0] = letters[v % 62];\n      v /= 62;\n      XXXXXX[1] = letters[v % 62];\n      v /= 62;\n      XXXXXX[2] = letters[v % 62];\n      v /= 62;\n      XXXXXX[3] = letters[v % 62];\n      v /= 62;\n      XXXXXX[4] = letters[v % 62];\n      v /= 62;\n      XXXXXX[5] = letters[v % 62];\n\n      fd = tryfunc (tmpl, args);\n      if (fd >= 0)\n        {\n          __set_errno (save_errno);\n          return fd;\n        }\n      else if (errno != EEXIST)\n        return -1;\n    }\n\n  /* We got out of the loop because we ran out of combinations to try.  */\n  __set_errno (EEXIST);\n  return -1;\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "try_file": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static int\ntry_file (char *tmpl, void *flags)\n{\n  int *openflags = flags;\n  return __open (tmpl,\n                 (*openflags & ~O_ACCMODE)\n                 | O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_dir": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static int\ntry_dir (char *tmpl, void *flags _GL_UNUSED)\n{\n  return __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_nocreate": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static int\ntry_nocreate (char *tmpl, void *flags _GL_UNUSED)\n{\n  struct_stat64 st;\n\n  if (__lxstat64 (_STAT_VER, tmpl, &st) == 0 || errno == EOVERFLOW)\n    __set_errno (EEXIST);\n  return errno == ENOENT ? 0 : -1;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__gen_tempname": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\n__gen_tempname (char *tmpl, int suffixlen, int flags, int kind)\n{\n  int (*tryfunc) (char *, void *);\n\n  switch (kind)\n    {\n    case __GT_FILE:\n      tryfunc = try_file;\n      break;\n\n    case __GT_DIR:\n      tryfunc = try_dir;\n      break;\n\n    case __GT_NOCREATE:\n      tryfunc = try_nocreate;\n      break;\n\n    default:\n      assert (! \"invalid KIND in __gen_tempname\");\n      abort ();\n    }\n  return __try_tempname (tmpl, suffixlen, &flags, tryfunc);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/tempname.h": {},
  "patch/patch-2.7.6/lib/time-internal.h": {},
  "patch/patch-2.7.6/lib/time.in.h": {},
  "patch/patch-2.7.6/lib/timegm.c": {
    "timegm": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "time_t\ntimegm (struct tm *tmp)\n{\n  static mktime_offset_t gmtime_offset;\n  tmp->tm_isdst = 0;\n  return __mktime_internal (tmp, __gmtime_r, &gmtime_offset);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "time_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/timespec.c": {},
  "patch/patch-2.7.6/lib/timespec.h": {
    "make_timespec": {
      "start_point": [
        45,
        27
      ],
      "end_point": [
        52,
        1
      ],
      "content": "timespec\nmake_timespec (time_t s, long int ns)\n{\n  struct timespec r;\n  r.tv_sec = s;\n  r.tv_nsec = ns;\n  return r;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "timespec"
      ]
    },
    "timespec_cmp": {
      "start_point": [
        80,
        24
      ],
      "end_point": [
        94,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\ntimespec_cmp (struct timespec a, struct timespec b)\n{\n  if (a.tv_sec < b.tv_sec)\n    return -1;\n  if (a.tv_sec > b.tv_sec)\n    return 1;\n\n  /* Pacify gcc -Wstrict-overflow (bleeding-edge circa 2017-10-02).  See:\n     http://lists.gnu.org/r/bug-gnulib/2017-10/msg00006.html  */\n  assume (-1 <= a.tv_nsec && a.tv_nsec <= 2 * TIMESPEC_RESOLUTION);\n  assume (-1 <= b.tv_nsec && b.tv_nsec <= 2 * TIMESPEC_RESOLUTION);\n\n  return a.tv_nsec - b.tv_nsec;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "timespec_sign": {
      "start_point": [
        98,
        24
      ],
      "end_point": [
        102,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\ntimespec_sign (struct timespec a)\n{\n  return a.tv_sec < 0 ? -1 : a.tv_sec || a.tv_nsec;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "timespectod": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "_GL_TIMESPEC_INLINE double\ntimespectod (struct timespec a)\n{\n  return a.tv_sec + a.tv_nsec / 1e9;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_TIMESPEC_INLINE",
        "double",
        "double"
      ]
    }
  },
  "patch/patch-2.7.6/lib/time_r.c": {
    "copy_tm_result": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static struct tm *\ncopy_tm_result (struct tm *dest, struct tm const *src)\n{\n  if (! src)\n    return 0;\n  *dest = *src;\n  return dest;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\ncopy_tm_result (struct tm *dest, struct tm const *src)",
        "*"
      ]
    },
    "gmtime_r": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "struct tm *\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, gmtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    },
    "localtime_r": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "struct tm *\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, localtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/time_rz.c": {
    "isdst_differ": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static bool\nisdst_differ (int a, int b)\n{\n  return !a != !b && 0 <= a && 0 <= b;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "equal_tm": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static int\nequal_tm (const struct tm *a, const struct tm *b)\n{\n  return ! ((a->tm_sec ^ b->tm_sec)\n            | (a->tm_min ^ b->tm_min)\n            | (a->tm_hour ^ b->tm_hour)\n            | (a->tm_mday ^ b->tm_mday)\n            | (a->tm_mon ^ b->tm_mon)\n            | (a->tm_year ^ b->tm_year)\n            | isdst_differ (a->tm_isdst, b->tm_isdst));\n}",
      "lines": 11,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extend_abbrs": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\nextend_abbrs (char *abbrs, char const *abbr, size_t abbr_size)\n{\n  memcpy (abbrs, abbr, abbr_size);\n  abbrs[abbr_size] = '\\0';\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tzalloc": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "timezone_t\ntzalloc (char const *name)\n{\n  size_t name_size = name ? strlen (name) + 1 : 0;\n  size_t abbr_size = name_size < ABBR_SIZE_MIN ? ABBR_SIZE_MIN : name_size + 1;\n  timezone_t tz = malloc (FLEXSIZEOF (struct tm_zone, abbrs, abbr_size));\n  if (tz)\n    {\n      tz->next = NULL;\n#if HAVE_TZNAME && !HAVE_TM_ZONE\n      tz->tzname_copy[0] = tz->tzname_copy[1] = NULL;\n#endif\n      tz->tz_is_set = !!name;\n      tz->abbrs[0] = '\\0';\n      if (name)\n        extend_abbrs (tz->abbrs, name, name_size);\n    }\n  return tz;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "timezone_t"
      ]
    },
    "save_abbr": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static bool\nsave_abbr (timezone_t tz, struct tm *tm)\n{\n#if HAVE_TM_ZONE || HAVE_TZNAME\n  char const *zone = NULL;\n  char *zone_copy = (char *) \"\";\n\n# if HAVE_TZNAME\n  int tzname_index = -1;\n# endif\n\n# if HAVE_TM_ZONE\n  zone = tm->tm_zone;\n# endif\n\n# if HAVE_TZNAME\n  if (! (zone && *zone) && 0 <= tm->tm_isdst)\n    {\n      tzname_index = tm->tm_isdst != 0;\n      zone = tzname[tzname_index];\n    }\n# endif\n\n  /* No need to replace null zones, or zones within the struct tm.  */\n  if (!zone || ((char *) tm <= zone && zone < (char *) (tm + 1)))\n    return true;\n\n  if (*zone)\n    {\n      zone_copy = tz->abbrs;\n\n      while (strcmp (zone_copy, zone) != 0)\n        {\n          if (! (*zone_copy || (zone_copy == tz->abbrs && tz->tz_is_set)))\n            {\n              size_t zone_size = strlen (zone) + 1;\n              size_t zone_used = zone_copy - tz->abbrs;\n              if (SIZE_MAX - zone_used < zone_size)\n                {\n                  errno = ENOMEM;\n                  return false;\n                }\n              if (zone_used + zone_size < ABBR_SIZE_MIN)\n                extend_abbrs (zone_copy, zone, zone_size);\n              else\n                {\n                  tz = tz->next = tzalloc (zone);\n                  if (!tz)\n                    return false;\n                  tz->tz_is_set = 0;\n                  zone_copy = tz->abbrs;\n                }\n              break;\n            }\n\n          zone_copy += strlen (zone_copy) + 1;\n          if (!*zone_copy && tz->next)\n            {\n              tz = tz->next;\n              zone_copy = tz->abbrs;\n            }\n        }\n    }\n\n  /* Replace the zone name so that its lifetime matches that of TZ.  */\n# if HAVE_TM_ZONE\n  tm->tm_zone = zone_copy;\n# else\n  if (0 <= tzname_index)\n    tz->tzname_copy[tzname_index] = zone_copy;\n# endif\n#endif\n\n  return true;\n}",
      "lines": 75,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tzfree": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "void\ntzfree (timezone_t tz)\n{\n  if (tz != local_tz)\n    while (tz)\n      {\n        timezone_t next = tz->next;\n        free (tz);\n        tz = next;\n      }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "getenv_TZ": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "static char *\ngetenv_TZ (void)\n{\n  return getenv (\"TZ\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ngetenv_TZ (void)",
        "*"
      ]
    },
    "setenv_TZ": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "static int\nsetenv_TZ (char const *tz)\n{\n  return tz ? setenv (\"TZ\", tz, 1) : unsetenv (\"TZ\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "change_env": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static bool\nchange_env (timezone_t tz)\n{\n  if (setenv_TZ (tz->tz_is_set ? tz->abbrs : NULL) != 0)\n    return false;\n  tzset ();\n  return true;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "set_tz": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static timezone_t\nset_tz (timezone_t tz)\n{\n  char *env_tz = getenv_TZ ();\n  if (env_tz\n      ? tz->tz_is_set && strcmp (tz->abbrs, env_tz) == 0\n      : !tz->tz_is_set)\n    return local_tz;\n  else\n    {\n      timezone_t old_tz = tzalloc (env_tz);\n      if (!old_tz)\n        return old_tz;\n      if (! change_env (tz))\n        {\n          int saved_errno = errno;\n          tzfree (old_tz);\n          errno = saved_errno;\n          return NULL;\n        }\n      return old_tz;\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "timezone_t"
      ]
    },
    "revert_tz": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static bool\nrevert_tz (timezone_t tz)\n{\n  if (tz == local_tz)\n    return true;\n  else\n    {\n      int saved_errno = errno;\n      bool ok = change_env (tz);\n      if (!ok)\n        saved_errno = errno;\n      tzfree (tz);\n      errno = saved_errno;\n      return ok;\n    }\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "localtime_rz": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "struct tm *\nlocaltime_rz (timezone_t tz, time_t const *t, struct tm *tm)\n{\n  if (!tz)\n    return gmtime_r (t, tm);\n  else\n    {\n      timezone_t old_tz = set_tz (tz);\n      if (old_tz)\n        {\n          bool abbr_saved = localtime_r (t, tm) && save_abbr (tz, tm);\n          if (revert_tz (old_tz) && abbr_saved)\n            return tm;\n        }\n      return NULL;\n    }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nlocaltime_rz (timezone_t tz, time_t const *t, struct tm *tm)",
        "*"
      ]
    },
    "mktime_z": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "time_t\nmktime_z (timezone_t tz, struct tm *tm)\n{\n  if (!tz)\n    return timegm (tm);\n  else\n    {\n      timezone_t old_tz = set_tz (tz);\n      if (old_tz)\n        {\n          time_t t = mktime (tm);\n#if HAVE_TM_ZONE || HAVE_TZNAME\n          time_t badtime = -1;\n          struct tm tm_1;\n          if ((t != badtime\n               || (localtime_r (&t, &tm_1) && equal_tm (tm, &tm_1)))\n              && !save_abbr (tz, tm))\n            t = badtime;\n#endif\n          if (revert_tz (old_tz))\n            return t;\n        }\n      return -1;\n    }\n}",
      "lines": 25,
      "depth": 18,
      "decorators": [
        "time_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/tzset.c": {},
  "patch/patch-2.7.6/lib/unistd--.h": {},
  "patch/patch-2.7.6/lib/unistd-safer.h": {},
  "patch/patch-2.7.6/lib/unistd.c": {},
  "patch/patch-2.7.6/lib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        912,
        0
      ],
      "end_point": [
        916,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/unlink.c": {
    "rpl_unlink": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\nrpl_unlink (char const *name)\n{\n  /* Work around Solaris 9 bug where unlink(\"file/\") succeeds.  */\n  size_t len = strlen (name);\n  int result = 0;\n  if (len && ISSLASH (name[len - 1]))\n    {\n      /* We can't unlink(2) something if it doesn't exist.  If it does\n         exist, then it resolved to a directory, due to the trailing\n         slash, and POSIX requires that the unlink attempt to remove\n         that directory (which would leave the symlink dangling).\n         Unfortunately, Solaris 9 is one of the platforms where the\n         root user can unlink directories, and we don't want to\n         cripple this behavior on real directories, even if it is\n         seldom needed (at any rate, it's nicer to let coreutils'\n         unlink(1) give the correct errno for non-root users).  But we\n         don't know whether name was an actual directory, or a symlink\n         to a directory; and due to the bug of ignoring trailing\n         slash, Solaris 9 would end up successfully unlinking the\n         symlink instead of the directory.  Technically, we could use\n         realpath to find the canonical directory name to attempt\n         deletion on.  But that is a lot of work for a corner case; so\n         we instead just use an lstat on the shortened name, and\n         reject symlinks with trailing slashes.  The root user of\n         unlink(1) will just have to live with the rule that they\n         can't delete a directory via a symlink.  */\n      struct stat st;\n      result = lstat (name, &st);\n      if (result == 0)\n        {\n          /* Trailing NUL will overwrite the trailing slash.  */\n          char *short_name = malloc (len);\n          if (!short_name)\n            {\n              errno = EPERM;\n              return -1;\n            }\n          memcpy (short_name, name, len);\n          while (len && ISSLASH (short_name[len - 1]))\n            short_name[--len] = '\\0';\n          if (len && (lstat (short_name, &st) || S_ISLNK (st.st_mode)))\n            {\n              free (short_name);\n              errno = EPERM;\n              return -1;\n            }\n          free (short_name);\n        }\n    }\n  if (!result)\n    {\n#if UNLINK_PARENT_BUG\n      if (len >= 2 && name[len - 1] == '.' && name[len - 2] == '.'\n          && (len == 2 || ISSLASH (name[len - 3])))\n        {\n          errno = EISDIR; /* could also use EPERM */\n          return -1;\n        }\n#endif\n      result = unlink (name);\n    }\n  return result;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/unlinkat.c": {
    "rpl_unlinkat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\nrpl_unlinkat (int fd, char const *name, int flag)\n{\n  size_t len;\n  int result = 0;\n  /* rmdir behavior has no problems with trailing slash.  */\n  if (flag & AT_REMOVEDIR)\n    return unlinkat (fd, name, flag);\n\n  len = strlen (name);\n  if (len && ISSLASH (name[len - 1]))\n    {\n      /* See the lengthy comment in unlink.c why we disobey the POSIX\n         rule of letting unlink(\"link-to-dir/\") attempt to unlink a\n         directory.  */\n      struct stat st;\n      result = lstatat (fd, name, &st);\n      if (result == 0)\n        {\n          /* Trailing NUL will overwrite the trailing slash.  */\n          char *short_name = malloc (len);\n          if (!short_name)\n            {\n              errno = EPERM;\n              return -1;\n            }\n          memcpy (short_name, name, len);\n          while (len && ISSLASH (short_name[len - 1]))\n            short_name[--len] = '\\0';\n          if (len && (lstatat (fd, short_name, &st) || S_ISLNK (st.st_mode)))\n            {\n              free (short_name);\n              errno = EPERM;\n              return -1;\n            }\n          free (short_name);\n        }\n    }\n  if (!result)\n    {\n# if UNLINK_PARENT_BUG\n      if (len >= 2 && name[len - 1] == '.' && name[len - 2] == '.'\n          && (len == 2 || ISSLASH (name[len - 3])))\n        {\n          errno = EISDIR; /* could also use EPERM */\n          return -1;\n        }\n# endif\n      result = unlinkat (fd, name, flag);\n    }\n  return result;\n}",
      "lines": 52,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/unsetenv.c": {
    "unsetenv": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nunsetenv (const char *name)\n{\n  size_t len;\n  char **ep;\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n  LOCK;\n\n  ep = __environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rpl_unsetenv": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nrpl_unsetenv (const char *name)\n{\n  int result = 0;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  while (getenv (name))\n# if !VOID_UNSETENV\n    result =\n# endif\n      unsetenv (name);\n  return result;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/utime.c": {
    "_gl_utimens_windows": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "int\n_gl_utimens_windows (const char *name, struct timespec ts[2])\n{\n  /* POSIX <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>\n     specifies: \"More than two leading <slash> characters shall be treated as\n     a single <slash> character.\"  */\n  if (ISSLASH (name[0]) && ISSLASH (name[1]) && ISSLASH (name[2]))\n    {\n      name += 2;\n      while (ISSLASH (name[1]))\n        name++;\n    }\n\n  size_t len = strlen (name);\n  size_t drive_prefix_len = (HAS_DEVICE (name) ? 2 : 0);\n\n  /* Remove trailing slashes (except the very first one, at position\n     drive_prefix_len), but remember their presence.  */\n  size_t rlen;\n  bool check_dir = false;\n\n  rlen = len;\n  while (rlen > drive_prefix_len && ISSLASH (name[rlen-1]))\n    {\n      check_dir = true;\n      if (rlen == drive_prefix_len + 1)\n        break;\n      rlen--;\n    }\n\n  const char *rname;\n  char *malloca_rname;\n  if (rlen == len)\n    {\n      rname = name;\n      malloca_rname = NULL;\n    }\n  else\n    {\n      malloca_rname = malloca (rlen + 1);\n      if (malloca_rname == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      memcpy (malloca_rname, name, rlen);\n      malloca_rname[rlen] = '\\0';\n      rname = malloca_rname;\n    }\n\n  DWORD error;\n\n  /* Open a handle to the file.\n     CreateFile\n     <https://msdn.microsoft.com/en-us/library/aa363858.aspx>\n     <https://msdn.microsoft.com/en-us/library/aa363874.aspx>  */\n  HANDLE handle =\n    CreateFile (rname,\n                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,\n                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                NULL,\n                OPEN_EXISTING,\n                /* FILE_FLAG_POSIX_SEMANTICS (treat file names that differ only\n                   in case as different) makes sense only when applied to *all*\n                   filesystem operations.  */\n                FILE_FLAG_BACKUP_SEMANTICS /* | FILE_FLAG_POSIX_SEMANTICS */,\n                NULL);\n  if (handle == INVALID_HANDLE_VALUE)\n    {\n      error = GetLastError ();\n      goto failed;\n    }\n\n  if (check_dir)\n    {\n      /* GetFileAttributes\n         <https://msdn.microsoft.com/en-us/library/aa364944.aspx>  */\n      DWORD attributes = GetFileAttributes (rname);\n      if (attributes == INVALID_FILE_ATTRIBUTES)\n        {\n          error = GetLastError ();\n          CloseHandle (handle);\n          goto failed;\n        }\n      if ((attributes & FILE_ATTRIBUTE_DIRECTORY) == 0)\n        {\n          CloseHandle (handle);\n          if (malloca_rname != NULL)\n            freea (malloca_rname);\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n\n  {\n    /* Use SetFileTime(). See\n       <https://msdn.microsoft.com/en-us/library/ms724933.aspx>\n       <https://msdn.microsoft.com/en-us/library/ms724284.aspx>  */\n    FILETIME last_access_time;\n    FILETIME last_write_time;\n    if (ts == NULL)\n      {\n        /* GetSystemTimeAsFileTime is the same as\n           GetSystemTime followed by SystemTimeToFileTime.\n           <https://msdn.microsoft.com/en-us/library/ms724397.aspx>.\n           It would be overkill to use\n           GetSystemTimePreciseAsFileTime\n           <https://msdn.microsoft.com/en-us/library/hh706895.aspx>.  */\n        FILETIME current_time;\n        GetSystemTimeAsFileTime (&current_time);\n        last_access_time = current_time;\n        last_write_time = current_time;\n      }\n    else\n      {\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[0].tv_sec * 10000000 + ts[0].tv_nsec / 100 + 116444736000000000LL;\n          last_access_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_access_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[1].tv_sec * 10000000 + ts[1].tv_nsec / 100 + 116444736000000000LL;\n          last_write_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_write_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n      }\n    if (SetFileTime (handle, NULL, &last_access_time, &last_write_time))\n      {\n        CloseHandle (handle);\n        if (malloca_rname != NULL)\n          freea (malloca_rname);\n        return 0;\n      }\n    else\n      {\n        #if 0\n        DWORD sft_error = GetLastError ();\n        fprintf (stderr, \"utimens SetFileTime error 0x%x\\n\", (unsigned int) sft_error);\n        #endif\n        CloseHandle (handle);\n        if (malloca_rname != NULL)\n          freea (malloca_rname);\n        errno = EINVAL;\n        return -1;\n      }\n  }\n\n failed:\n  {\n    #if 0\n    fprintf (stderr, \"utimens CreateFile/GetFileAttributes error 0x%x\\n\", (unsigned int) error);\n    #endif\n    if (malloca_rname != NULL)\n      freea (malloca_rname);\n\n    switch (error)\n      {\n      /* Some of these errors probably cannot happen with the specific flags\n         that we pass to CreateFile.  But who knows...  */\n      case ERROR_FILE_NOT_FOUND: /* The last component of rname does not exist.  */\n      case ERROR_PATH_NOT_FOUND: /* Some directory component in rname does not exist.  */\n      case ERROR_BAD_PATHNAME:   /* rname is such as '\\\\server'.  */\n      case ERROR_BAD_NETPATH:    /* rname is such as '\\\\nonexistentserver\\share'.  */\n      case ERROR_BAD_NET_NAME:   /* rname is such as '\\\\server\\nonexistentshare'.  */\n      case ERROR_INVALID_NAME:   /* rname contains wildcards, misplaced colon, etc.  */\n      case ERROR_DIRECTORY:\n        errno = ENOENT;\n        break;\n\n      case ERROR_ACCESS_DENIED:  /* rname is such as 'C:\\System Volume Information\\foo'.  */\n      case ERROR_SHARING_VIOLATION: /* rname is such as 'C:\\pagefile.sys'.  */\n        errno = (ts != NULL ? EPERM : EACCES);\n        break;\n\n      case ERROR_OUTOFMEMORY:\n        errno = ENOMEM;\n        break;\n\n      case ERROR_WRITE_PROTECT:\n        errno = EROFS;\n        break;\n\n      case ERROR_WRITE_FAULT:\n      case ERROR_READ_FAULT:\n      case ERROR_GEN_FAILURE:\n        errno = EIO;\n        break;\n\n      case ERROR_BUFFER_OVERFLOW:\n      case ERROR_FILENAME_EXCED_RANGE:\n        errno = ENAMETOOLONG;\n        break;\n\n      case ERROR_DELETE_PENDING: /* XXX map to EACCESS or EPERM? */\n        errno = EPERM;\n        break;\n\n      default:\n        errno = EINVAL;\n        break;\n      }\n\n    return -1;\n  }\n}",
      "lines": 207,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "utime": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "int\nutime (const char *name, const struct utimbuf *ts)\n{\n  if (ts == NULL)\n    return _gl_utimens_windows (name, NULL);\n  else\n    {\n      struct timespec ts_with_nanoseconds[2];\n      ts_with_nanoseconds[0].tv_sec = ts->actime;\n      ts_with_nanoseconds[0].tv_nsec = 0;\n      ts_with_nanoseconds[1].tv_sec = ts->modtime;\n      ts_with_nanoseconds[1].tv_nsec = 0;\n      return _gl_utimens_windows (name, ts_with_nanoseconds);\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/utime.in.h": {},
  "patch/patch-2.7.6/lib/utimens.c": {
    "validate_timespec": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static int\nvalidate_timespec (struct timespec timespec[2])\n{\n  int result = 0;\n  int utime_omit_count = 0;\n  if ((timespec[0].tv_nsec != UTIME_NOW\n       && timespec[0].tv_nsec != UTIME_OMIT\n       && ! (0 <= timespec[0].tv_nsec\n             && timespec[0].tv_nsec < TIMESPEC_RESOLUTION))\n      || (timespec[1].tv_nsec != UTIME_NOW\n          && timespec[1].tv_nsec != UTIME_OMIT\n          && ! (0 <= timespec[1].tv_nsec\n                && timespec[1].tv_nsec < TIMESPEC_RESOLUTION)))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Work around Linux kernel 2.6.25 bug, where utimensat fails with\n     EINVAL if tv_sec is not 0 when using the flag values of tv_nsec.\n     Flag a Linux kernel 2.6.32 bug, where an mtime of UTIME_OMIT\n     fails to bump ctime.  */\n  if (timespec[0].tv_nsec == UTIME_NOW\n      || timespec[0].tv_nsec == UTIME_OMIT)\n    {\n      timespec[0].tv_sec = 0;\n      result = 1;\n      if (timespec[0].tv_nsec == UTIME_OMIT)\n        utime_omit_count++;\n    }\n  if (timespec[1].tv_nsec == UTIME_NOW\n      || timespec[1].tv_nsec == UTIME_OMIT)\n    {\n      timespec[1].tv_sec = 0;\n      result = 1;\n      if (timespec[1].tv_nsec == UTIME_OMIT)\n        utime_omit_count++;\n    }\n  return result + (utime_omit_count == 1);\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "update_timespec": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static bool\nupdate_timespec (struct stat const *statbuf, struct timespec *ts[2])\n{\n  struct timespec *timespec = *ts;\n  if (timespec[0].tv_nsec == UTIME_OMIT\n      && timespec[1].tv_nsec == UTIME_OMIT)\n    return true;\n  if (timespec[0].tv_nsec == UTIME_NOW\n      && timespec[1].tv_nsec == UTIME_NOW)\n    {\n      *ts = NULL;\n      return false;\n    }\n\n  if (timespec[0].tv_nsec == UTIME_OMIT)\n    timespec[0] = get_stat_atime (statbuf);\n  else if (timespec[0].tv_nsec == UTIME_NOW)\n    gettime (&timespec[0]);\n\n  if (timespec[1].tv_nsec == UTIME_OMIT)\n    timespec[1] = get_stat_mtime (statbuf);\n  else if (timespec[1].tv_nsec == UTIME_NOW)\n    gettime (&timespec[1]);\n\n  return false;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "fdutimens": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "int\nfdutimens (int fd, char const *file, struct timespec const timespec[2])\n{\n  struct timespec adjusted_timespec[2];\n  struct timespec *ts = timespec ? adjusted_timespec : NULL;\n  int adjustment_needed = 0;\n  struct stat st;\n\n  if (ts)\n    {\n      adjusted_timespec[0] = timespec[0];\n      adjusted_timespec[1] = timespec[1];\n      adjustment_needed = validate_timespec (ts);\n    }\n  if (adjustment_needed < 0)\n    return -1;\n\n  /* Require that at least one of FD or FILE are potentially valid, to avoid\n     a Linux bug where futimens (AT_FDCWD, NULL) changes \".\" rather\n     than failing.  */\n  if (fd < 0 && !file)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  /* Some Linux-based NFS clients are buggy, and mishandle timestamps\n     of files in NFS file systems in some cases.  We have no\n     configure-time test for this, but please see\n     <https://bugs.gentoo.org/show_bug.cgi?id=132673> for references to\n     some of the problems with Linux 2.6.16.  If this affects you,\n     compile with -DHAVE_BUGGY_NFS_TIME_STAMPS; this is reported to\n     help in some cases, albeit at a cost in performance.  But you\n     really should upgrade your kernel to a fixed version, since the\n     problem affects many applications.  */\n\n#if HAVE_BUGGY_NFS_TIME_STAMPS\n  if (fd < 0)\n    sync ();\n  else\n    fsync (fd);\n#endif\n\n  /* POSIX 2008 added two interfaces to set file timestamps with\n     nanosecond resolution; newer Linux implements both functions via\n     a single syscall.  We provide a fallback for ENOSYS (for example,\n     compiling against Linux 2.6.25 kernel headers and glibc 2.7, but\n     running on Linux 2.6.18 kernel).  */\n#if HAVE_UTIMENSAT || HAVE_FUTIMENS\n  if (0 <= utimensat_works_really)\n    {\n      int result;\n# if __linux__ || __sun\n      /* As recently as Linux kernel 2.6.32 (Dec 2009), several file\n         systems (xfs, ntfs-3g) have bugs with a single UTIME_OMIT,\n         but work if both times are either explicitly specified or\n         UTIME_NOW.  Work around it with a preparatory [f]stat prior\n         to calling futimens/utimensat; fortunately, there is not much\n         timing impact due to the extra syscall even on file systems\n         where UTIME_OMIT would have worked.\n\n         The same bug occurs in Solaris 11.1 (Apr 2013).\n\n         FIXME: Simplify this for Linux in 2016 and for Solaris in\n         2024, when file system bugs are no longer common.  */\n      if (adjustment_needed == 2)\n        {\n          if (fd < 0 ? stat (file, &st) : fstat (fd, &st))\n            return -1;\n          if (ts[0].tv_nsec == UTIME_OMIT)\n            ts[0] = get_stat_atime (&st);\n          else if (ts[1].tv_nsec == UTIME_OMIT)\n            ts[1] = get_stat_mtime (&st);\n          /* Note that st is good, in case utimensat gives ENOSYS.  */\n          adjustment_needed++;\n        }\n# endif\n# if HAVE_UTIMENSAT\n      if (fd < 0)\n        {\n          result = utimensat (AT_FDCWD, file, ts, 0);\n#  ifdef __linux__\n          /* Work around a kernel bug:\n             https://bugzilla.redhat.com/show_bug.cgi?id=442352\n             https://bugzilla.redhat.com/show_bug.cgi?id=449910\n             It appears that utimensat can mistakenly return 280 rather\n             than -1 upon ENOSYS failure.\n             FIXME: remove in 2010 or whenever the offending kernels\n             are no longer in common use.  */\n          if (0 < result)\n            errno = ENOSYS;\n#  endif /* __linux__ */\n          if (result == 0 || errno != ENOSYS)\n            {\n              utimensat_works_really = 1;\n              return result;\n            }\n        }\n# endif /* HAVE_UTIMENSAT */\n# if HAVE_FUTIMENS\n      if (0 <= fd)\n        {\n          result = futimens (fd, ts);\n#  ifdef __linux__\n          /* Work around the same bug as above.  */\n          if (0 < result)\n            errno = ENOSYS;\n#  endif /* __linux__ */\n          if (result == 0 || errno != ENOSYS)\n            {\n              utimensat_works_really = 1;\n              return result;\n            }\n        }\n# endif /* HAVE_FUTIMENS */\n    }\n  utimensat_works_really = -1;\n  lutimensat_works_really = -1;\n#endif /* HAVE_UTIMENSAT || HAVE_FUTIMENS */\n\n#ifdef USE_SETFILETIME\n  /* On native Windows, use SetFileTime(). See\n     <https://msdn.microsoft.com/en-us/library/ms724933.aspx>\n     <https://msdn.microsoft.com/en-us/library/ms724284.aspx>  */\n  if (0 <= fd)\n    {\n      HANDLE handle;\n      FILETIME current_time;\n      FILETIME last_access_time;\n      FILETIME last_write_time;\n\n      handle = (HANDLE) _get_osfhandle (fd);\n      if (handle == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n\n      if (ts == NULL || ts[0].tv_nsec == UTIME_NOW || ts[1].tv_nsec == UTIME_NOW)\n        {\n          /* GetSystemTimeAsFileTime\n             <https://msdn.microsoft.com/en-us/library/ms724397.aspx>.\n             It would be overkill to use\n             GetSystemTimePreciseAsFileTime\n             <https://msdn.microsoft.com/en-us/library/hh706895.aspx>.  */\n          GetSystemTimeAsFileTime (&current_time);\n        }\n\n      if (ts == NULL || ts[0].tv_nsec == UTIME_NOW)\n        {\n          last_access_time = current_time;\n        }\n      else if (ts[0].tv_nsec == UTIME_OMIT)\n        {\n          last_access_time.dwLowDateTime = 0;\n          last_access_time.dwHighDateTime = 0;\n        }\n      else\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[0].tv_sec * 10000000 + ts[0].tv_nsec / 100 + 116444736000000000LL;\n          last_access_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_access_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n\n      if (ts == NULL || ts[1].tv_nsec == UTIME_NOW)\n        {\n          last_write_time = current_time;\n        }\n      else if (ts[1].tv_nsec == UTIME_OMIT)\n        {\n          last_write_time.dwLowDateTime = 0;\n          last_write_time.dwHighDateTime = 0;\n        }\n      else\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[1].tv_sec * 10000000 + ts[1].tv_nsec / 100 + 116444736000000000LL;\n          last_write_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_write_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n\n      if (SetFileTime (handle, NULL, &last_access_time, &last_write_time))\n        return 0;\n      else\n        {\n          DWORD sft_error = GetLastError ();\n          #if 0\n          fprintf (stderr, \"fdutimens SetFileTime error 0x%x\\n\", (unsigned int) sft_error);\n          #endif\n          switch (sft_error)\n            {\n            case ERROR_ACCESS_DENIED: /* fd was opened without O_RDWR */\n              errno = EACCES; /* not specified by POSIX */\n              break;\n            default:\n              errno = EINVAL;\n              break;\n            }\n          return -1;\n        }\n    }\n#endif\n\n  /* The platform lacks an interface to set file timestamps with\n     nanosecond resolution, so do the best we can, discarding any\n     fractional part of the timestamp.  */\n\n  if (adjustment_needed || (REPLACE_FUNC_STAT_FILE && fd < 0))\n    {\n      if (adjustment_needed != 3\n          && (fd < 0 ? stat (file, &st) : fstat (fd, &st)))\n        return -1;\n      if (ts && update_timespec (&st, &ts))\n        return 0;\n    }\n\n  {\n#if HAVE_FUTIMESAT || HAVE_WORKING_UTIMES\n    struct timeval timeval[2];\n    struct timeval *t;\n    if (ts)\n      {\n        timeval[0].tv_sec = ts[0].tv_sec;\n        timeval[0].tv_usec = ts[0].tv_nsec / 1000;\n        timeval[1].tv_sec = ts[1].tv_sec;\n        timeval[1].tv_usec = ts[1].tv_nsec / 1000;\n        t = timeval;\n      }\n    else\n      t = NULL;\n\n    if (fd < 0)\n      {\n# if HAVE_FUTIMESAT\n        return futimesat (AT_FDCWD, file, t);\n# endif\n      }\n    else\n      {\n        /* If futimesat or futimes fails here, don't try to speed things\n           up by returning right away.  glibc can incorrectly fail with\n           errno == ENOENT if /proc isn't mounted.  Also, Mandrake 10.0\n           in high security mode doesn't allow ordinary users to read\n           /proc/self, so glibc incorrectly fails with errno == EACCES.\n           If errno == EIO, EPERM, or EROFS, it's probably safe to fail\n           right away, but these cases are rare enough that they're not\n           worth optimizing, and who knows what other messed-up systems\n           are out there?  So play it safe and fall back on the code\n           below.  */\n\n# if (HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG) || HAVE_FUTIMES\n#  if HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG\n#   undef futimes\n#   define futimes(fd, t) futimesat (fd, NULL, t)\n#  endif\n        if (futimes (fd, t) == 0)\n          {\n#  if __linux__ && __GLIBC__\n            /* Work around a longstanding glibc bug, still present as\n               of 2010-12-27.  On older Linux kernels that lack both\n               utimensat and utimes, glibc's futimes rounds instead of\n               truncating when falling back on utime.  The same bug\n               occurs in futimesat with a null 2nd arg.  */\n            if (t)\n              {\n                bool abig = 500000 <= t[0].tv_usec;\n                bool mbig = 500000 <= t[1].tv_usec;\n                if ((abig | mbig) && fstat (fd, &st) == 0)\n                  {\n                    /* If these two subtractions overflow, they'll\n                       track the overflows inside the buggy glibc.  */\n                    time_t adiff = st.st_atime - t[0].tv_sec;\n                    time_t mdiff = st.st_mtime - t[1].tv_sec;\n\n                    struct timeval *tt = NULL;\n                    struct timeval truncated_timeval[2];\n                    truncated_timeval[0] = t[0];\n                    truncated_timeval[1] = t[1];\n                    if (abig && adiff == 1 && get_stat_atime_ns (&st) == 0)\n                      {\n                        tt = truncated_timeval;\n                        tt[0].tv_usec = 0;\n                      }\n                    if (mbig && mdiff == 1 && get_stat_mtime_ns (&st) == 0)\n                      {\n                        tt = truncated_timeval;\n                        tt[1].tv_usec = 0;\n                      }\n                    if (tt)\n                      futimes (fd, tt);\n                  }\n              }\n#  endif\n\n            return 0;\n          }\n# endif\n      }\n#endif /* HAVE_FUTIMESAT || HAVE_WORKING_UTIMES */\n\n    if (!file)\n      {\n#if ! ((HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG)          \\\n        || (HAVE_WORKING_UTIMES && HAVE_FUTIMES))\n        errno = ENOSYS;\n#endif\n        return -1;\n      }\n\n#ifdef USE_SETFILETIME\n    return _gl_utimens_windows (file, ts);\n#elif HAVE_WORKING_UTIMES\n    return utimes (file, t);\n#else\n    {\n      struct utimbuf utimbuf;\n      struct utimbuf *ut;\n      if (ts)\n        {\n          utimbuf.actime = ts[0].tv_sec;\n          utimbuf.modtime = ts[1].tv_sec;\n          ut = &utimbuf;\n        }\n      else\n        ut = NULL;\n\n      return utime (file, ut);\n    }\n#endif /* !HAVE_WORKING_UTIMES */\n  }\n}",
      "lines": 332,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "utimens": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        508,
        1
      ],
      "content": "int\nutimens (char const *file, struct timespec const timespec[2])\n{\n  return fdutimens (-1, file, timespec);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lutimens": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "int\nlutimens (char const *file, struct timespec const timespec[2])\n{\n  struct timespec adjusted_timespec[2];\n  struct timespec *ts = timespec ? adjusted_timespec : NULL;\n  int adjustment_needed = 0;\n  struct stat st;\n\n  if (ts)\n    {\n      adjusted_timespec[0] = timespec[0];\n      adjusted_timespec[1] = timespec[1];\n      adjustment_needed = validate_timespec (ts);\n    }\n  if (adjustment_needed < 0)\n    return -1;\n\n  /* The Linux kernel did not support symlink timestamps until\n     utimensat, in version 2.6.22, so we don't need to mimic\n     fdutimens' worry about buggy NFS clients.  But we do have to\n     worry about bogus return values.  */\n\n#if HAVE_UTIMENSAT\n  if (0 <= lutimensat_works_really)\n    {\n      int result;\n# if __linux__ || __sun\n      /* As recently as Linux kernel 2.6.32 (Dec 2009), several file\n         systems (xfs, ntfs-3g) have bugs with a single UTIME_OMIT,\n         but work if both times are either explicitly specified or\n         UTIME_NOW.  Work around it with a preparatory lstat prior to\n         calling utimensat; fortunately, there is not much timing\n         impact due to the extra syscall even on file systems where\n         UTIME_OMIT would have worked.\n\n         The same bug occurs in Solaris 11.1 (Apr 2013).\n\n         FIXME: Simplify this for Linux in 2016 and for Solaris in\n         2024, when file system bugs are no longer common.  */\n      if (adjustment_needed == 2)\n        {\n          if (lstat (file, &st))\n            return -1;\n          if (ts[0].tv_nsec == UTIME_OMIT)\n            ts[0] = get_stat_atime (&st);\n          else if (ts[1].tv_nsec == UTIME_OMIT)\n            ts[1] = get_stat_mtime (&st);\n          /* Note that st is good, in case utimensat gives ENOSYS.  */\n          adjustment_needed++;\n        }\n# endif\n      result = utimensat (AT_FDCWD, file, ts, AT_SYMLINK_NOFOLLOW);\n# ifdef __linux__\n      /* Work around a kernel bug:\n         https://bugzilla.redhat.com/show_bug.cgi?id=442352\n         https://bugzilla.redhat.com/show_bug.cgi?id=449910\n         It appears that utimensat can mistakenly return 280 rather\n         than -1 upon ENOSYS failure.\n         FIXME: remove in 2010 or whenever the offending kernels\n         are no longer in common use.  */\n      if (0 < result)\n        errno = ENOSYS;\n# endif\n      if (result == 0 || errno != ENOSYS)\n        {\n          utimensat_works_really = 1;\n          lutimensat_works_really = 1;\n          return result;\n        }\n    }\n  lutimensat_works_really = -1;\n#endif /* HAVE_UTIMENSAT */\n\n  /* The platform lacks an interface to set file timestamps with\n     nanosecond resolution, so do the best we can, discarding any\n     fractional part of the timestamp.  */\n\n  if (adjustment_needed || REPLACE_FUNC_STAT_FILE)\n    {\n      if (adjustment_needed != 3 && lstat (file, &st))\n        return -1;\n      if (ts && update_timespec (&st, &ts))\n        return 0;\n    }\n\n  /* On Linux, lutimes is a thin wrapper around utimensat, so there is\n     no point trying lutimes if utimensat failed with ENOSYS.  */\n#if HAVE_LUTIMES && !HAVE_UTIMENSAT\n  {\n    struct timeval timeval[2];\n    struct timeval *t;\n    int result;\n    if (ts)\n      {\n        timeval[0].tv_sec = ts[0].tv_sec;\n        timeval[0].tv_usec = ts[0].tv_nsec / 1000;\n        timeval[1].tv_sec = ts[1].tv_sec;\n        timeval[1].tv_usec = ts[1].tv_nsec / 1000;\n        t = timeval;\n      }\n    else\n      t = NULL;\n\n    result = lutimes (file, t);\n    if (result == 0 || errno != ENOSYS)\n      return result;\n  }\n#endif /* HAVE_LUTIMES && !HAVE_UTIMENSAT */\n\n  /* Out of luck for symlinks, but we still handle regular files.  */\n  if (!(adjustment_needed || REPLACE_FUNC_STAT_FILE) && lstat (file, &st))\n    return -1;\n  if (!S_ISLNK (st.st_mode))\n    return fdutimens (-1, file, ts);\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 117,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/utimens.h": {
    "lutimensat": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "_GL_UTIMENS_INLINE int\nlutimensat (int dir, char const *file, struct timespec const times[2])\n{\n  return utimensat (dir, file, times, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UTIMENS_INLINE",
        "int",
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/utimensat.c": {
    "rpl_utimensat": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\nrpl_utimensat (int fd, char const *file, struct timespec const times[2],\n               int flag)\n{\n# if defined __linux__ || defined __sun\n  struct timespec ts[2];\n# endif\n\n  /* See comments in utimens.c for details.  */\n  static int utimensat_works_really; /* 0 = unknown, 1 = yes, -1 = no.  */\n  if (0 <= utimensat_works_really)\n    {\n      int result;\n# if defined __linux__ || defined __sun\n      struct stat st;\n      /* As recently as Linux kernel 2.6.32 (Dec 2009), several file\n         systems (xfs, ntfs-3g) have bugs with a single UTIME_OMIT,\n         but work if both times are either explicitly specified or\n         UTIME_NOW.  Work around it with a preparatory [l]stat prior\n         to calling utimensat; fortunately, there is not much timing\n         impact due to the extra syscall even on file systems where\n         UTIME_OMIT would have worked.\n\n         The same bug occurs in Solaris 11.1 (Apr 2013).\n\n         FIXME: Simplify this in 2024, when these file system bugs are\n         no longer common on Gnulib target platforms.  */\n      if (times && (times[0].tv_nsec == UTIME_OMIT\n                    || times[1].tv_nsec == UTIME_OMIT))\n        {\n          if (fstatat (fd, file, &st, flag))\n            return -1;\n          if (times[0].tv_nsec == UTIME_OMIT && times[1].tv_nsec == UTIME_OMIT)\n            return 0;\n          if (times[0].tv_nsec == UTIME_OMIT)\n            ts[0] = get_stat_atime (&st);\n          else\n            ts[0] = times[0];\n          if (times[1].tv_nsec == UTIME_OMIT)\n            ts[1] = get_stat_mtime (&st);\n          else\n            ts[1] = times[1];\n          times = ts;\n        }\n#  ifdef __hppa__\n      /* Linux kernel 2.6.22.19 on hppa does not reject invalid tv_nsec\n         values.  */\n      else if (times\n               && ((times[0].tv_nsec != UTIME_NOW\n                    && ! (0 <= times[0].tv_nsec\n                          && times[0].tv_nsec < TIMESPEC_RESOLUTION))\n                   || (times[1].tv_nsec != UTIME_NOW\n                       && ! (0 <= times[1].tv_nsec\n                             && times[1].tv_nsec < TIMESPEC_RESOLUTION))))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n#  endif\n# endif\n      result = utimensat (fd, file, times, flag);\n      /* Linux kernel 2.6.25 has a bug where it returns EINVAL for\n         UTIME_NOW or UTIME_OMIT with non-zero tv_sec, which\n         local_utimensat works around.  Meanwhile, EINVAL for a bad\n         flag is indeterminate whether the native utimensat works, but\n         local_utimensat will also reject it.  */\n      if (result == -1 && errno == EINVAL && (flag & ~AT_SYMLINK_NOFOLLOW))\n        return result;\n      if (result == 0 || (errno != ENOSYS && errno != EINVAL))\n        {\n          utimensat_works_really = 1;\n          return result;\n        }\n    }\n  /* No point in trying openat/futimens, since on Linux, futimens is\n     implemented with the same syscall as utimensat.  Only avoid the\n     native utimensat due to an ENOSYS failure; an EINVAL error was\n     data-dependent, and the next caller may pass valid data.  */\n  if (0 <= utimensat_works_really && errno == ENOSYS)\n    utimensat_works_really = -1;\n  return local_utimensat (fd, file, times, flag);\n}",
      "lines": 82,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and Mac OS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        847,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        901,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        909,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        997,
        0
      ],
      "end_point": [
        1072,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1081,
        0
      ],
      "end_point": [
        1294,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1303,
        0
      ],
      "end_point": [
        1310,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1321,
        0
      ],
      "end_point": [
        1328,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1337,
        0
      ],
      "end_point": [
        1419,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1510,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1516,
        0
      ],
      "end_point": [
        1526,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1543,
        0
      ],
      "end_point": [
        1778,
        1
      ],
      "content": "static size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4625,
        16
      ],
      "end_point": [
        5554,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 930,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = -width;",
        "width = -width",
        "width",
        "=",
        "-width",
        "-",
        "width",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "#endif",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "# endif",
        "#endif",
        "FALLTHROUGH;",
        "FALLTHROUGH",
        ";",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "(defined __APPLE__ && defined __MACH__)",
        "(",
        "defined __APPLE__ && defined __MACH__",
        "defined __APPLE__",
        "defined",
        "__APPLE__",
        "&&",
        "defined __MACH__",
        "defined",
        "__MACH__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "if",
        "(saved_errno == 0)",
        "(",
        "saved_errno == 0",
        "saved_errno",
        "==",
        "0",
        ")",
        "{\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "{",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "saved_errno = EILSEQ;",
        "saved_errno = EILSEQ",
        "saved_errno",
        "=",
        "EILSEQ",
        ";",
        "else",
        "saved_errno = EINVAL;",
        "saved_errno = EINVAL",
        "saved_errno",
        "=",
        "EINVAL",
        ";",
        "}",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "patch/patch-2.7.6/lib/vasnprintf.h": {},
  "patch/patch-2.7.6/lib/vasprintf.c": {
    "vasprintf": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nvasprintf (char **resultp, const char *format, va_list args)\n{\n  size_t length;\n  char *result = vasnprintf (NULL, &length, format, args);\n  if (result == NULL)\n    return -1;\n\n  if (length > INT_MAX)\n    {\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  *resultp = result;\n  /* Return the number of resulting bytes, excluding the trailing NUL.  */\n  return length;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/lib/verify.h": {},
  "patch/patch-2.7.6/lib/verror.c": {
    "verror": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\nverror (int status, int errnum, const char *format, va_list args)\n{\n  verror_at_line (status, errnum, NULL, 0, format, args);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "verror_at_line": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\nverror_at_line (int status, int errnum, const char *file,\n                unsigned int line_number, const char *format, va_list args)\n{\n  char *message = xvasprintf (format, args);\n  if (message)\n    {\n      /* Until https://sourceware.org/bugzilla/show_bug.cgi?id=2997 is fixed,\n         glibc violates GNU Coding Standards when the file argument to\n         error_at_line is NULL.  */\n      if (file)\n        error_at_line (status, errnum, file, line_number, \"%s\", message);\n      else\n        error (status, errnum, \"%s\", message);\n    }\n  else\n    {\n      /* EOVERFLOW, EINVAL, and EILSEQ from xvasprintf are signs of\n         serious programmer errors.  */\n      error (0, errno, _(\"unable to display error message\"));\n      abort ();\n    }\n  free (message);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/verror.h": {},
  "patch/patch-2.7.6/lib/warn-on-use.h": {},
  "patch/patch-2.7.6/lib/wchar.in.h": {},
  "patch/patch-2.7.6/lib/wctype-h.c": {},
  "patch/patch-2.7.6/lib/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/write.c": {
    "write_nothrow": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        56,
        5
      ],
      "content": "static ssize_t\nwrite_nothrow (int fd, const void *buf, size_t count)\n{\n  ssize_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = write (fd, buf, count);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "rpl_write": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "ssize_t\nrpl_write (int fd, const void *buf, size_t count)\n{\n  for (;;)\n    {\n      ssize_t ret = write_nothrow (fd, buf, count);\n\n      if (ret < 0)\n        {\n# if GNULIB_NONBLOCKING\n          if (errno == ENOSPC)\n            {\n              HANDLE h = (HANDLE) _get_osfhandle (fd);\n              if (GetFileType (h) == FILE_TYPE_PIPE)\n                {\n                  /* h is a pipe or socket.  */\n                  DWORD state;\n                  if (GetNamedPipeHandleState (h, &state, NULL, NULL, NULL,\n                                               NULL, 0)\n                      && (state & PIPE_NOWAIT) != 0)\n                    {\n                      /* h is a pipe in non-blocking mode.\n                         We can get here in four situations:\n                           1. When the pipe buffer is full.\n                           2. When count <= pipe_buf_size and the number of\n                              free bytes in the pipe buffer is < count.\n                           3. When count > pipe_buf_size and the number of free\n                              bytes in the pipe buffer is > 0, < pipe_buf_size.\n                           4. When count > pipe_buf_size and the pipe buffer is\n                              entirely empty.\n                         The cases 1 and 2 are POSIX compliant.  In cases 3 and\n                         4 POSIX specifies that write() must split the request\n                         and succeed with a partial write.  We fix case 4.\n                         We don't fix case 3 because it is not essential for\n                         programs.  */\n                      DWORD out_size; /* size of the buffer for outgoing data */\n                      DWORD in_size;  /* size of the buffer for incoming data */\n                      if (GetNamedPipeInfo (h, NULL, &out_size, &in_size, NULL))\n                        {\n                          size_t reduced_count = count;\n                          /* In theory we need only one of out_size, in_size.\n                             But I don't know which of the two.  The description\n                             is ambiguous.  */\n                          if (out_size != 0 && out_size < reduced_count)\n                            reduced_count = out_size;\n                          if (in_size != 0 && in_size < reduced_count)\n                            reduced_count = in_size;\n                          if (reduced_count < count)\n                            {\n                              /* Attempt to write only the first part.  */\n                              count = reduced_count;\n                              continue;\n                            }\n                        }\n                      /* Change errno from ENOSPC to EAGAIN.  */\n                      errno = EAGAIN;\n                    }\n                }\n            }\n          else\n# endif\n            {\n# if GNULIB_SIGPIPE\n              if (GetLastError () == ERROR_NO_DATA\n                  && GetFileType ((HANDLE) _get_osfhandle (fd))\n                     == FILE_TYPE_PIPE)\n                {\n                  /* Try to raise signal SIGPIPE.  */\n                  raise (SIGPIPE);\n                  /* If it is currently blocked or ignored, change errno from\n                     EINVAL to EPIPE.  */\n                  errno = EPIPE;\n                }\n# endif\n            }\n        }\n      return ret;\n    }\n}",
      "lines": 79,
      "depth": 20,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "patch/patch-2.7.6/lib/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/lib/xalloc-oversized.h": {},
  "patch/patch-2.7.6/lib/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          122,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          239,
          29
        ],
        "end_point": [
          243,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          178,
          0
        ],
        "end_point": [
          213,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n      if (xalloc_oversized (n, s))\n        xalloc_die ();\n    }\n  else\n    {\n      /* Set N = floor (1.5 * N) + 1 so that progress is made even if N == 0.\n         Check for overflow, so that N * S stays in both ptrdiff_t and\n         size_t range.  The check may be slightly conservative, but an\n         exact check isn't worth the trouble.  */\n      if ((PTRDIFF_MAX < SIZE_MAX ? PTRDIFF_MAX : SIZE_MAX) / 3 * 2 / s\n          <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 36,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          251,
          29
        ],
        "end_point": [
          255,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        233,
        29
      ],
      "end_point": [
        237,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        245,
        29
      ],
      "end_point": [
        249,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        257,
        29
      ],
      "end_point": [
        261,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/xasprintf.c": {
    "xasprintf": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nxasprintf (const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = xvasprintf (format, args);\n  va_end (args);\n\n  return result;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxasprintf (const char *format, ...)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since objects with size greater than\n     PTRDIFF_MAX cause pointer subtraction to go awry.  Omit size-zero\n     tests if HAVE_GNU_CALLOC, since GNU calloc never returns NULL if\n     successful.  */\n  if (xalloc_oversized (n, s)\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/xmemdup0.c": {
    "xmemdup0": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "char *\nxmemdup0 (void const *p, size_t s)\n{\n  char *result = xcharalloc (s + 1);\n  memcpy (result, p, s);\n  result[s] = 0;\n  return result;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "char",
        "*\nxmemdup0 (void const *p, size_t s)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/xmemdup0.h": {},
  "patch/patch-2.7.6/lib/xsize.c": {},
  "patch/patch-2.7.6/lib/xsize.h": {
    "size_t": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "__pure__": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    }
  },
  "patch/patch-2.7.6/lib/xstrndup.c": {
    "xstrndup": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nxstrndup (const char *string, size_t n)\n{\n  char *s = strndup (string, n);\n  if (! s)\n    xalloc_die ();\n  return s;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxstrndup (const char *string, size_t n)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/xstrndup.h": {},
  "patch/patch-2.7.6/lib/xvasprintf.c": {
    "xstrcat": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static char *\nxstrcat (size_t argcount, va_list args)\n{\n  char *result;\n  va_list ap;\n  size_t totalsize;\n  size_t i;\n  char *p;\n\n  /* Determine the total size.  */\n  totalsize = 0;\n  va_copy (ap, args);\n  for (i = argcount; i > 0; i--)\n    {\n      const char *next = va_arg (ap, const char *);\n      totalsize = xsum (totalsize, strlen (next));\n    }\n  va_end (ap);\n\n  /* Test for overflow in the summing pass above or in (totalsize + 1) below.\n     Also, don't return a string longer than INT_MAX, for consistency with\n     vasprintf().  */\n  if (totalsize == SIZE_MAX || totalsize > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      return NULL;\n    }\n\n  /* Allocate and fill the result string.  */\n  result = XNMALLOC (totalsize + 1, char);\n  p = result;\n  for (i = argcount; i > 0; i--)\n    {\n      const char *next = va_arg (args, const char *);\n      size_t len = strlen (next);\n      memcpy (p, next, len);\n      p += len;\n    }\n  *p = '\\0';\n\n  return result;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nxstrcat (size_t argcount, va_list args)",
        "*"
      ]
    },
    "xvasprintf": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "char *\nxvasprintf (const char *format, va_list args)\n{\n  char *result;\n\n  /* Recognize the special case format = \"%s...%s\".  It is a frequently used\n     idiom for string concatenation and needs to be fast.  We don't want to\n     have a separate function xstrcat() for this purpose.  */\n  {\n    size_t argcount = 0;\n    const char *f;\n\n    for (f = format;;)\n      {\n        if (*f == '\\0')\n          /* Recognized the special case of string concatenation.  */\n          return xstrcat (argcount, args);\n        if (*f != '%')\n          break;\n        f++;\n        if (*f != 's')\n          break;\n        f++;\n        argcount++;\n      }\n  }\n\n  if (vasprintf (&result, format, args) < 0)\n    {\n      if (errno == ENOMEM)\n        xalloc_die ();\n      return NULL;\n    }\n\n  return result;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "char",
        "*\nxvasprintf (const char *format, va_list args)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/lib/xvasprintf.h": {},
  "patch/patch-2.7.6/lib/_Noreturn.h": {},
  "patch/patch-2.7.6/pc/chdirsaf.c": {
    "restore_wd": {
      "start_point": [
        10,
        0
      ],
      "end_point": [
        14,
        1
      ],
      "content": "static void\nrestore_wd (void)\n{\n  chdir (initial_wd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "chdir_safer": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nchdir_safer (char const *dir)\n{\n  if (! initial_wd)\n    {\n      size_t s;\n      for (s = 256;  ! (initial_wd = getcwd (0, s));  s *= 2)\n\tif (errno != ERANGE)\n\t  return -1;\n      if (atexit (restore_wd) != 0)\n\t{\n\t  free (initial_wd);\n\t  initial_wd = 0;\n\t  return -1;\n\t}\n    }\n\n  return chdir (dir);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/src/bestmatch.h": {
    "bestmatch": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static OFFSET\nbestmatch(OFFSET xoff, OFFSET xlim, OFFSET yoff, OFFSET ylim,\n\t  OFFSET min, OFFSET max, OFFSET *py)\n{\n    const OFFSET dmin = xoff - ylim;      /* Minimum valid diagonal. */\n    const OFFSET dmax = xlim - yoff;      /* Maximum valid diagonal. */\n    const OFFSET fmid = xoff - yoff;      /* Center diagonal. */\n    OFFSET fmin = fmid;\n    OFFSET fmax = fmid;\n    OFFSET *V, *fd;\n    OFFSET fmid_plus_2_min, ymax = -1;\n    OFFSET c;\n\n    V = xmalloc ((2 * max + 3) * sizeof (OFFSET));\n    fd = V + max + 1 - fmid;\n\n    /*\n       The number of elements that were matched in x and in y can be\n       computed as either (x - x_skipped) or (y - y_skipped), with:\n\n\t delta = (x - xoff) - (y - yoff)\n\t x_skipped = (c + delta) / 2\n\t y_skipped = (c - delta) / 2\n\n       For searching for a minimum number of matching elements, we end up\n       with this check:\n\n         (x - x_skipped) >= min\n\t  ...\n\t x + y - c >= (xoff - yoff) + 2 * min\n\t x + y - c >= fmid + 2 * min\n    */\n\n    if (min)\n      {\n\tfmid_plus_2_min = fmid + 2 * min;\n\tmin += yoff;\n\tif (min > ylim)\n\t  {\n\t    c = max + 1;\n\t    goto free_and_return;\n\t  }\n      }\n    else\n      fmid_plus_2_min = 0;  /* disable this check */\n    if (!py)\n      min = ylim;\n\n    /* Handle the exact-match case. */\n    while (xoff < xlim && yoff < ylim && EQUAL_IDX (xoff, yoff))\n      {\n\txoff++;\n\tyoff++;\n      }\n    if (xoff == xlim && yoff >= min\n\t&& xoff + yoff >= fmid_plus_2_min)\n      {\n\tymax = yoff;\n        c = 0;\n      }\n    else\n      {\n\tfd[fmid] = xoff;\n\tfor (c = 1; c <= max; c++)\n\t  {\n\t    OFFSET d;\n\n\t    if (fmin > dmin)\n\t      fd[--fmin - 1] = -1;\n\t    else\n\t      ++fmin;\n\t    if (fmax < dmax)\n\t      fd[++fmax + 1] = -1;\n\t    else\n\t      --fmax;\n\t    for (d = fmax; d >= fmin; d -= 2)\n\t      {\n\t\tOFFSET x, y;\n\n\t\tif (fd[d - 1] < fd[d + 1])\n\t\t  x = fd[d + 1];\n\t\telse\n\t\t  x = fd[d - 1] + 1;\n\t\tfor (y = x - d;\n\t\t     x < xlim && y < ylim && EQUAL_IDX (x, y);\n\t\t     x++, y++)\n\t\t  /* do nothing */ ;\n\t\tfd[d] = x;\n\t\tif (x == xlim && y >= min\n\t\t    && x + y - c >= fmid_plus_2_min)\n\t\t  {\n\t\t    if (ymax < y)\n\t\t      ymax = y;\n\t\t    if (y == ylim)\n\t\t      goto done;\n\t\t  }\n\t      }\n\t    if (ymax != -1)\n\t      goto done;\n\t  }\n      }\n\n  done:\n    if (py)\n      *py = ymax;\n\n  free_and_return:\n    free (V);\n    return c;\n}",
      "lines": 110,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "OFFSET"
      ]
    }
  },
  "patch/patch-2.7.6/src/common.h": {
    "bool": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        110,
        49
      ],
      "content": "XTERN enum { DEFAULT_VERBOSITY, SILENT, VERBOSE }",
      "lines": 1,
      "depth": 6,
      "decorators": null
    }
  },
  "patch/patch-2.7.6/src/inp.c": {
    "re_input": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\nre_input (void)\n{\n    if (using_plan_a) {\n      if (i_buffer)\n\t{\n\t  free (i_buffer);\n\t  i_buffer = 0;\n\t  free (i_ptr);\n\t}\n    }\n    else {\n\tif (tifd >= 0)\n\t  close (tifd);\n\ttifd = -1;\n\tif (tibuf[0])\n\t  {\n\t    free (tibuf[0]);\n\t    tibuf[0] = 0;\n\t  }\n\ttiline[0] = tiline[1] = -1;\n\ttireclen = 0;\n    }\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "scan_input": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nscan_input (char *filename, mode_t file_type)\n{\n    using_plan_a = ! (debug & 16) && plan_a (filename);\n    if (!using_plan_a)\n      {\n\tif (! S_ISREG (file_type))\n\t  {\n\t    assert (S_ISLNK (file_type));\n\t    fatal (\"Can't handle %s %s\", \"symbolic link\", quotearg (filename));\n\t  }\n\tplan_b(filename);\n      }\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "report_revision": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static void\nreport_revision (bool found_revision)\n{\n  char const *rev = quotearg (revision);\n\n  if (found_revision)\n    {\n      if (verbosity == VERBOSE)\n\tsay (\"Good.  This file appears to be the %s version.\\n\", rev);\n    }\n  else if (force)\n    {\n      if (verbosity != SILENT)\n\tsay (\"Warning: this file doesn't appear to be the %s version -- patching anyway.\\n\",\n\t     rev);\n    }\n  else if (batch)\n    fatal (\"This file doesn't appear to be the %s version -- aborting.\",\n\t   rev);\n  else\n    {\n      ask (\"This file doesn't appear to be the %s version -- patch anyway? [n] \",\n\t   rev);\n      if (*buf != 'y')\n\tfatal (\"aborted\");\n    }\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "too_many_lines": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static void\ntoo_many_lines (char const *filename)\n{\n  fatal (\"File %s has too many lines\", quotearg (filename));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lines_too_long": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "static void\nlines_too_long (char const *filename)\n{\n  fatal (\"Lines in file %s are too long\", quotearg (filename));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_input_file": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "bool\nget_input_file (char const *filename, char const *outname, mode_t file_type)\n{\n    bool elsewhere = strcmp (filename, outname) != 0;\n    char const *cs;\n    char *diffbuf;\n    char *getbuf;\n\n    if (inerrno == -1)\n      inerrno = stat_file (filename, &instat);\n\n    /* Perhaps look for RCS or SCCS versions.  */\n    if (S_ISREG (file_type)\n\t&& patch_get\n\t&& invc != 0\n\t&& (inerrno\n\t    || (! elsewhere\n\t\t&& (/* No one can write to it.  */\n\t\t    (instat.st_mode & (S_IWUSR|S_IWGRP|S_IWOTH)) == 0\n\t\t    /* Only the owner (who's not me) can write to it.  */\n\t\t    || ((instat.st_mode & (S_IWGRP|S_IWOTH)) == 0\n\t\t\t&& instat.st_uid != geteuid ()))))\n\t&& (invc = !! (cs = (version_controller\n\t\t\t     (filename, elsewhere,\n\t\t\t      inerrno ? (struct stat *) 0 : &instat,\n\t\t\t      &getbuf, &diffbuf))))) {\n\n\t    if (!inerrno) {\n\t\tif (!elsewhere\n\t\t    && (instat.st_mode & (S_IWUSR|S_IWGRP|S_IWOTH)) != 0)\n\t\t    /* Somebody can write to it.  */\n\t\t  fatal (\"File %s seems to be locked by somebody else under %s\",\n\t\t\t quotearg (filename), cs);\n\t\tif (diffbuf)\n\t\t  {\n\t\t    /* It might be checked out unlocked.  See if it's safe to\n\t\t       check out the default version locked.  */\n\n\t\t    if (verbosity == VERBOSE)\n\t\t      say (\"Comparing file %s to default %s version...\\n\",\n\t\t\t   quotearg (filename), cs);\n\n\t\t    if (systemic (diffbuf) != 0)\n\t\t      {\n\t\t\tsay (\"warning: Patching file %s, which does not match default %s version\\n\",\n\t\t\t     quotearg (filename), cs);\n\t\t\tcs = 0;\n\t\t      }\n\t\t  }\n\t\tif (dry_run)\n\t\t  cs = 0;\n\t    }\n\n\t    if (cs && version_get (filename, cs, ! inerrno, elsewhere, getbuf,\n\t\t\t\t   &instat))\n\t      inerrno = 0;\n\n\t    free (getbuf);\n\t    free (diffbuf);\n      }\n\n    if (inerrno)\n      {\n\tinstat.st_mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH;\n\tinstat.st_size = 0;\n      }\n    else if (! ((S_ISREG (file_type) || S_ISLNK (file_type))\n\t        && (file_type & S_IFMT) == (instat.st_mode & S_IFMT)))\n      {\n\tsay (\"File %s is not a %s -- refusing to patch\\n\",\n\t     quotearg (filename),\n\t     S_ISLNK (file_type) ? \"symbolic link\" : \"regular file\");\n\treturn false;\n      }\n    return true;\n}",
      "lines": 76,
      "depth": 20,
      "decorators": [
        "bool"
      ]
    },
    "plan_a": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "static bool\nplan_a (char const *filename)\n{\n  char const *s;\n  char const *lim;\n  char const **ptr;\n  char *buffer;\n  lin iline;\n  size_t size = instat.st_size;\n\n  /* Fail if the file size doesn't fit in a size_t,\n     or if storage isn't available.  */\n  if (! (size == instat.st_size\n\t && (buffer = malloc (size ? size : (size_t) 1))))\n    return false;\n\n  /* Read the input file, but don't bother reading it if it's empty.\n     When creating files, the files do not actually exist.  */\n  if (size)\n    {\n      if (S_ISREG (instat.st_mode))\n        {\n\t  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);\n\t  size_t buffered = 0, n;\n\t  if (ifd < 0)\n\t    pfatal (\"can't open file %s\", quotearg (filename));\n\n\t  while (size - buffered != 0)\n\t    {\n\t      n = read (ifd, buffer + buffered, size - buffered);\n\t      if (n == 0)\n\t\t{\n\t\t  /* Some non-POSIX hosts exaggerate st_size in text mode;\n\t\t     or the file may have shrunk!  */\n\t\t  size = buffered;\n\t\t  break;\n\t\t}\n\t      if (n == (size_t) -1)\n\t\t{\n\t\t  /* Perhaps size is too large for this host.  */\n\t\t  close (ifd);\n\t\t  free (buffer);\n\t\t  return false;\n\t\t}\n\t      buffered += n;\n\t    }\n\n\t  if (close (ifd) != 0)\n\t    read_fatal ();\n\t}\n      else if (S_ISLNK (instat.st_mode))\n\t{\n\t  ssize_t n;\n\t  n = safe_readlink (filename, buffer, size);\n\t  if (n < 0)\n\t    pfatal (\"can't read %s %s\", \"symbolic link\", quotearg (filename));\n\t  size = n;\n\t}\n      else\n\t{\n\t  free (buffer);\n\t  return false;\n\t}\n  }\n\n  /* Scan the buffer and build array of pointers to lines.  */\n  lim = buffer + size;\n  iline = 3; /* 1 unused, 1 for SOF, 1 for EOF if last line is incomplete */\n  for (s = buffer;  (s = (char *) memchr (s, '\\n', lim - s));  s++)\n    if (++iline < 0)\n      too_many_lines (filename);\n  if (! (iline == (size_t) iline\n\t && (size_t) iline * sizeof *ptr / sizeof *ptr == (size_t) iline\n\t && (ptr = (char const **) malloc ((size_t) iline * sizeof *ptr))))\n    {\n      free (buffer);\n      return false;\n    }\n  iline = 0;\n  for (s = buffer;  ;  s++)\n    {\n      ptr[++iline] = s;\n      if (! (s = (char *) memchr (s, '\\n', lim - s)))\n\tbreak;\n    }\n  if (size && lim[-1] != '\\n')\n    ptr[++iline] = lim;\n  input_lines = iline - 1;\n\n  if (revision)\n    {\n      char const *rev = revision;\n      int rev0 = rev[0];\n      bool found_revision = false;\n      size_t revlen = strlen (rev);\n\n      if (revlen <= size)\n\t{\n\t  char const *limrev = lim - revlen;\n\n\t  for (s = buffer;  (s = (char *) memchr (s, rev0, limrev - s));  s++)\n\t    if (memcmp (s, rev, revlen) == 0\n\t\t&& (s == buffer || ISSPACE ((unsigned char) s[-1]))\n\t\t&& (s + 1 == limrev || ISSPACE ((unsigned char) s[revlen])))\n\t      {\n\t\tfound_revision = true;\n\t\tbreak;\n\t      }\n\t}\n\n      report_revision (found_revision);\n    }\n\n  /* Plan A will work.  */\n  i_buffer = buffer;\n  i_ptr = ptr;\n  return true;\n}",
      "lines": 118,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "plan_b": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "static void\nplan_b (char const *filename)\n{\n  int ifd;\n  FILE *ifp;\n  int c;\n  size_t len;\n  size_t maxlen;\n  bool found_revision;\n  size_t i;\n  char const *rev;\n  size_t revlen;\n  lin line = 1;\n\n  if (instat.st_size == 0)\n    filename = NULL_DEVICE;\n  if ((ifd = safe_open (filename, O_RDONLY | binary_transput, 0)) < 0\n      || ! (ifp = fdopen (ifd, binary_transput ? \"rb\" : \"r\")))\n    pfatal (\"Can't open file %s\", quotearg (filename));\n  if (TMPINNAME_needs_removal)\n    {\n      /* Reopen the existing temporary file. */\n      tifd = create_file (TMPINNAME, O_RDWR | O_BINARY, 0, true);\n    }\n  else\n    {\n      tifd = make_tempfile (&TMPINNAME, 'i', NULL, O_RDWR | O_BINARY,\n\t\t\t    S_IRUSR | S_IWUSR);\n      if (tifd == -1)\n\tpfatal (\"Can't create temporary file %s\", TMPINNAME);\n      TMPINNAME_needs_removal = true;\n    }\n  i = 0;\n  len = 0;\n  maxlen = 1;\n  rev = revision;\n  found_revision = !rev;\n  revlen = rev ? strlen (rev) : 0;\n\n  while ((c = getc (ifp)) != EOF)\n    {\n      if (++len > ((size_t) -1) / 2)\n\tlines_too_long (filename);\n\n      if (c == '\\n')\n\t{\n\t  if (++line < 0)\n\t    too_many_lines (filename);\n\t  if (maxlen < len)\n\t      maxlen = len;\n\t  len = 0;\n\t}\n\n      if (!found_revision)\n\t{\n\t  if (i == revlen)\n\t    {\n\t      found_revision = ISSPACE ((unsigned char) c);\n\t      i = (size_t) -1;\n\t    }\n\t  else if (i != (size_t) -1)\n\t    i = rev[i]==c ? i + 1 : (size_t) -1;\n\n\t  if (i == (size_t) -1  &&  ISSPACE ((unsigned char) c))\n\t    i = 0;\n\t}\n    }\n\n  if (revision)\n    report_revision (found_revision);\n  Fseek (ifp, 0, SEEK_SET);\t\t/* rewind file */\n  for (tibufsize = TIBUFSIZE_MINIMUM;  tibufsize < maxlen;  tibufsize <<= 1)\n    /* do nothing */ ;\n  lines_per_buf = tibufsize / maxlen;\n  tireclen = maxlen;\n  tibuf[0] = xmalloc (2 * tibufsize);\n  tibuf[1] = tibuf[0] + tibufsize;\n\n  for (line = 1; ; line++)\n    {\n      char *p = tibuf[0] + maxlen * (line % lines_per_buf);\n      char const *p0 = p;\n      if (! (line % lines_per_buf))\t/* new block */\n\tif (write (tifd, tibuf[0], tibufsize) != tibufsize)\n\t  write_fatal ();\n      if ((c = getc (ifp)) == EOF)\n\tbreak;\n\n      for (;;)\n\t{\n\t  *p++ = c;\n\t  if (c == '\\n')\n\t    {\n\t      last_line_size = p - p0;\n\t      break;\n\t    }\n\n\t  if ((c = getc (ifp)) == EOF)\n\t    {\n\t      last_line_size = p - p0;\n\t      line++;\n\t      goto EOF_reached;\n\t    }\n\t}\n    }\n EOF_reached:\n  if (ferror (ifp)  ||  fclose (ifp) != 0)\n    read_fatal ();\n\n  if (line % lines_per_buf  !=  0)\n    if (write (tifd, tibuf[0], tibufsize) != tibufsize)\n      write_fatal ();\n  input_lines = line - 1;\n}",
      "lines": 114,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ifetch": {
      "start_point": [
        457,
        0
      ],
      "end_point": [
        496,
        1
      ],
      "content": "char const *\nifetch (lin line, bool whichbuf, size_t *psize)\n{\n    char const *q;\n    char const *p;\n\n    if (line < 1 || line > input_lines) {\n\t*psize = 0;\n\treturn \"\";\n    }\n    if (using_plan_a) {\n\tp = i_ptr[line];\n\t*psize = i_ptr[line + 1] - p;\n\treturn p;\n    } else {\n\tlin offline = line % lines_per_buf;\n\tlin baseline = line - offline;\n\n\tif (tiline[0] == baseline)\n\t    whichbuf = false;\n\telse if (tiline[1] == baseline)\n\t    whichbuf = true;\n\telse {\n\t    tiline[whichbuf] = baseline;\n\t    if ((lseek (tifd, baseline/lines_per_buf * tibufsize, SEEK_SET)\n\t\t == -1)\n\t\t|| read (tifd, tibuf[whichbuf], tibufsize) < 0)\n\t      read_fatal ();\n\t}\n\tp = tibuf[whichbuf] + (tireclen*offline);\n\tif (line == input_lines)\n\t    *psize = last_line_size;\n\telse {\n\t    for (q = p;  *q++ != '\\n';  )\n\t\t/* do nothing */ ;\n\t    *psize = q - p;\n\t}\n\treturn p;\n    }\n}",
      "lines": 40,
      "depth": 17,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nifetch (lin line, bool whichbuf, size_t *psize)",
        "*"
      ]
    }
  },
  "patch/patch-2.7.6/src/inp.h": {},
  "patch/patch-2.7.6/src/list.h": {
    "INIT_LIST_HEAD": {
      "start_point": [
        14,
        0
      ],
      "end_point": [
        18,
        1
      ],
      "content": "static inline void INIT_LIST_HEAD(struct list_head *list)\n{\n  list->next = list;\n  list->prev = list;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "list_add": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "static inline void\nlist_add (struct list_head *entry, struct list_head *head)\n{\n  struct list_head *next = head->next;\n  entry->prev = head;\n  entry->next = next;\n  next->prev = head->next = entry;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "list_del": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static inline void\nlist_del (struct list_head *entry)\n{\n  struct list_head *next = entry->next;\n  struct list_head *prev = entry->prev;\n  next->prev = prev;\n  prev->next = next;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "list_del_init": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static inline void\nlist_del_init (struct list_head *entry)\n{\n  list_del(entry);\n  INIT_LIST_HEAD(entry);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "list_empty": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static inline bool\nlist_empty (const struct list_head *head)\n{\n  return head->next == head;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    }
  },
  "patch/patch-2.7.6/src/merge.c": {
    "locate_merge": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static lin\nlocate_merge (lin *matched)\n{\n    lin first_guess = pch_first () + in_offset;\n    lin pat_lines = pch_ptrn_lines ();\n    lin context_lines = count_context_lines ();\n    lin max_where = input_lines - pat_lines + context_lines + 1;\n    lin min_where = last_frozen_line + 1;\n    lin max_pos_offset = max_where - first_guess;\n    lin max_neg_offset = first_guess - min_where;\n    lin max_offset = (max_pos_offset < max_neg_offset\n\t\t      ? max_neg_offset : max_pos_offset);\n    lin where = first_guess, max_matched = 0;\n    lin min, max;\n    lin offset;\n    bool match_until_eof;\n\n    /* Note: we need to preserve patch's property that it applies hunks at the\n       best match closest to their original position in the file.  It is\n       common for hunks to apply equally well in several places in a file.\n       Applying at the first best match would be a lot easier.\n     */\n\n    if (context_lines == 0)\n      goto out;  /* locate_hunk() already tried that */\n\n    /* Allow at most CONTEXT_LINES lines to be replaced (replacing counts\n       as insert + delete), and require the remaining MIN lines to match.  */\n    max = 2 * context_lines;\n    min = pat_lines - context_lines;\n\n    if (debug & 1)\n      {\n\tchar numbuf0[LINENUM_LENGTH_BOUND + 1];\n\tchar numbuf1[LINENUM_LENGTH_BOUND + 1];\n\tsay (\"locating merge: min=%s max=%s \",\n\t     format_linenum (numbuf0, min),\n\t     format_linenum (numbuf1, max));\n      }\n\n    /* Hunks from the start or end of the file have less context. Anchor them\n       to the start or end, trying to make up for this disadvantage.  */\n    offset = pch_suffix_context () - pch_prefix_context ();\n    if (offset > 0 && pch_first () <= 1)\n      max_pos_offset = 0;\n    match_until_eof = offset < 0;\n\n    /* Do not try lines <= 0.  */\n    if (first_guess <= max_neg_offset)\n      max_neg_offset = first_guess - 1;\n\n    for (offset = 0; offset <= max_offset; offset++)\n      {\n\tif (offset <= max_pos_offset)\n\t  {\n\t    lin guess = first_guess + offset;\n\t    lin last;\n\t    lin changes;\n\n\t    changes = bestmatch (1, pat_lines + 1, guess, input_lines + 1,\n\t\t\t\t match_until_eof ? input_lines - guess + 1 : min,\n\t\t\t\t max, &last);\n\t    if (changes <= max && max_matched < last - guess)\n\t      {\n\t\tmax_matched = last - guess;\n\t\twhere = guess;\n\t\tif (changes == 0)\n\t\t  break;\n\t\tmin = last - guess;\n\t\tmax = changes - 1;\n\t      }\n\t  }\n\tif (0 < offset && offset <= max_neg_offset)\n\t  {\n\t    lin guess = first_guess - offset;\n\t    lin last;\n\t    lin changes;\n\n\t    changes = bestmatch (1, pat_lines + 1, guess, input_lines + 1,\n\t\t\t\t match_until_eof ? input_lines - guess + 1 : min,\n\t\t\t\t max, &last);\n\t    if (changes <= max && max_matched < last - guess)\n\t      {\n\t\tmax_matched = last - guess;\n\t\twhere = guess;\n\t\tif (changes == 0)\n\t\t  break;\n\t\tmin = last - guess;\n\t\tmax = changes - 1;\n\t      }\n\t  }\n      }\n    if (debug & 1)\n      {\n\tchar numbuf0[LINENUM_LENGTH_BOUND + 1];\n\tchar numbuf1[LINENUM_LENGTH_BOUND + 1];\n\tchar numbuf2[LINENUM_LENGTH_BOUND + 1];\n\tsay (\"where=%s matched=%s changes=%s\\n\",\n\t     format_linenum (numbuf0, where),\n\t     format_linenum (numbuf1, max_matched),\n\t     format_linenum (numbuf2, max + 1));\n      }\n\n  out:\n    *matched = max_matched;\n    if (where < min_where)\n      where = min_where;\n    return where;\n}",
      "lines": 109,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "lin"
      ]
    },
    "print_linerange": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\nprint_linerange (lin from, lin to)\n{\n  char numbuf0[LINENUM_LENGTH_BOUND + 1];\n  char numbuf1[LINENUM_LENGTH_BOUND + 1];\n\n  if (to <= from)\n    printf (\"%s\",\n\t    format_linenum (numbuf0, from));\n  else\n    printf (\"%s-%s\",\n\t    format_linenum (numbuf0, from),\n\t    format_linenum (numbuf1, to));\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "merge_result": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static void\nmerge_result (bool *first_result, int hunk, char const *what, lin from, lin to)\n{\n  static char const *last_what;\n\n  if (*first_result && what)\n    {\n      printf (\"Hunk #%d %s at \", hunk, what);\n      last_what = what;\n    }\n  else if (! what)\n    {\n      if (! *first_result)\n\t{\n\t  fputs (\".\\n\", stdout);\n\t  fflush (stdout);\n\t  last_what = 0;\n\t}\n      return;\n    }\n  else if (last_what == what)\n    fputs (\",\", stdout);\n  else\n    printf (\", %s at \", what);\n  print_linerange (from + out_offset, to + out_offset);\n  *first_result = false;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "merge_hunk": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "bool\nmerge_hunk (int hunk, struct outstate *outstate, lin where, bool *somefailed)\n{\n  bool applies_cleanly;\n  bool first_result = true;\n  bool already_applied;\n  FILE *fp = outstate->ofp;\n  lin old = 1;\n  lin firstold = pch_ptrn_lines ();\n  lin new = firstold + 1;\n  lin firstnew = pch_end ();\n  lin in;\n  lin firstin;\n  char *oldin;\n  lin matched;\n  lin lastwhere;\n\n  /* Convert '!' markers into '-' and '+' to simplify things here.  */\n  pch_normalize (UNI_DIFF);\n\n  assert (pch_char (firstnew + 1) == '^');\n  while (pch_char (new) == '=' || pch_char (new) == '\\n')\n    new++;\n\n  if (where)\n    {\n      applies_cleanly = true;\n      matched = pch_ptrn_lines ();\n    }\n  else\n    {\n      where = locate_merge (&matched);\n      applies_cleanly = false;\n    }\n\n  in = firstold + 2;\n  oldin = xmalloc (in + matched + 1);\n  memset (oldin, ' ', in + matched);\n  oldin[0] = '*';\n  oldin[in - 1] = '=';\n  oldin[in + matched] = '^';\n  compute_changes (old, in - 1, where, where + matched,\n\t\t   oldin + old, oldin + in);\n\n  if (debug & 2)\n    {\n      char numbuf0[LINENUM_LENGTH_BOUND + 1];\n      char numbuf1[LINENUM_LENGTH_BOUND + 1];\n      lin n;\n\n      fputc ('\\n', stderr);\n      for (n = 0; n <= in + matched; n++)\n\t{\n\t  fprintf (stderr, \"%s %c\",\n\t\t  format_linenum (numbuf0, n),\n\t\t  oldin[n]);\n\t  if (n == 0)\n\t    fprintf(stderr, \" %s,%s\\n\",\n\t\t    format_linenum (numbuf0, pch_first()),\n\t\t    format_linenum (numbuf1, pch_ptrn_lines()));\n\t  else if (n <= firstold)\n\t    fprintf (stderr, \" |%.*s\",\n\t\t     (int) pch_line_len (n), pfetch (n));\n\t  else if (n == in - 1)\n\t    fprintf(stderr, \" %s,%s\\n\",\n\t\t    format_linenum (numbuf0, where),\n\t\t    format_linenum (numbuf1, matched));\n\t  else if (n >= in && n < in + matched)\n\t    {\n\t      size_t size;\n\t      const char *line;\n\n\t      line = ifetch (where + n - in, false, &size);\n\t      fprintf (stderr, \" |%.*s\",\n\t\t       (int) size, line);\n\t    }\n\t  else\n\t    fputc('\\n', stderr);\n\t}\n      fflush (stderr);\n    }\n\n  if (last_frozen_line < where - 1)\n    if (! copy_till (outstate, where - 1))\n      return false;\n\n  for (;;)\n    {\n      firstold = old;\n      firstnew = new;\n      firstin = in;\n\n      if (pch_char (old) == '-' || pch_char (new) == '+')\n\t{\n\t  lin lines;\n\n\t  while (pch_char (old) == '-')\n\t    {\n\t      if (oldin[old] == '-' || oldin[in] == '+')\n\t\tgoto conflict;\n\t      else if (oldin[old] == ' ')\n\t\t{\n\t\t  assert (oldin[in] == ' ');\n\t\t  in++;\n\t\t}\n\t      old++;\n\t    }\n\t  if (oldin[old] == '-' || oldin[in] == '+')\n\t    goto conflict;\n\t  while (pch_char (new) == '+')\n\t    new++;\n\n\t  lines = new - firstnew;\n\t  if (verbosity == VERBOSE\n\t      || ((verbosity != SILENT) && ! applies_cleanly))\n\t    merge_result (&first_result, hunk, \"merged\",\n\t\t\t  where, where + lines - 1);\n\t  last_frozen_line += (old - firstold);\n\t  where += (old - firstold);\n\t  out_offset += new - firstnew;\n\n\t  if (firstnew < new)\n\t    {\n\t      while (firstnew < new)\n\t\t{\n\t\t  outstate->after_newline = pch_write_line (firstnew, fp);\n\t\t  firstnew++;\n\t\t}\n\t      outstate->zero_output = false;\n\t    }\n\t}\n      else if (pch_char (old) == ' ')\n\t{\n\t  if (oldin[old] == '-')\n\t    {\n\t      while (pch_char (old) == ' ')\n\t\t{\n\t\t  if (oldin[old] != '-')\n\t\t    break;\n\t\t  if (pch_char (new) == '+')\n\t\t    goto conflict;\n\t\t  else\n\t\t    assert (pch_char (new) == ' ');\n\t\t  old++;\n\t\t  new++;\n\t\t}\n\t      if (pch_char (old) == '-' || pch_char (new) == '+')\n\t\tgoto conflict;\n\t    }\n\t  else if (oldin[in] == '+')\n\t    {\n\t      while (oldin[in] == '+')\n\t\tin++;\n\n\t      /* Take these lines from the input file.  */\n\t      where += in - firstin;\n\t      if (! copy_till (outstate, where - 1))\n\t\treturn false;\n\t    }\n\t  else if (oldin[old] == ' ')\n\t    {\n\t      while (pch_char (old) == ' '\n\t\t     && oldin[old] == ' '\n\t\t     && pch_char (new) == ' '\n\t\t     && oldin[in] == ' ')\n\t\t{\n\t\t  old++;\n\t\t  new++;\n\t\t  in++;\n\t\t}\n\n\t      /* Take these lines from the input file.  */\n\t      where += (in - firstin);\n\t      if (! copy_till (outstate, where - 1))\n\t\treturn false;\n\t    }\n\t}\n      else\n\t{\n\t  assert (pch_char (old) == '=' && pch_char (new) == '^');\n\t  /* Nothing more left to merge.  */\n\t  break;\n\t}\n      continue;\n\n    conflict:\n      /* Find the end of the conflict.  */\n      for (;;)\n\t{\n\t  if (pch_char (old) == '-')\n\t    {\n\t      while (oldin[in] == '+')\n\t\tin++;\n\t      if (oldin[old] == ' ')\n\t\t{\n\t\t  assert (oldin[in] == ' ');\n\t\t  in++;\n\t\t}\n\t      old++;\n\t    }\n\t  else if (oldin[old] == '-')\n\t    {\n\t      while (pch_char (new) == '+')\n\t\tnew++;\n\t      if (pch_char (old) == ' ')\n\t\t{\n\t\t  assert (pch_char (new) == ' ');\n\t\t  new++;\n\t\t}\n\t      old++;\n\t    }\n\t  else if (pch_char (new) == '+')\n\t    while (pch_char (new) == '+')\n\t      new++;\n\t  else if (oldin[in] == '+')\n\t    while (oldin[in] == '+')\n\t      in++;\n\t  else\n\t    break;\n\t}\n      assert (((pch_char (old) == ' ' && pch_char (new) == ' ')\n\t       || (pch_char (old) == '=' && pch_char (new) == '^'))\n\t      && ((oldin[old] == ' ' && oldin[in] == ' ')\n\t\t  || (oldin[old] == '=' && oldin[in] == '^')));\n\n      /* Output common prefix lines.  */\n      for (lastwhere = where;\n\t   firstin < in && firstnew < new\n\t     && context_matches_file (firstnew, lastwhere);\n\t   firstin++, firstnew++, lastwhere++)\n\t/* do nothing */ ;\n      already_applied = (firstin == in && firstnew == new);\n      if (already_applied)\n\tmerge_result (&first_result, hunk, \"already applied\",\n\t\t      where, lastwhere - 1);\n      if (conflict_style == MERGE_DIFF3)\n\t{\n\t  lin common_prefix = lastwhere - where;\n\n\t  /* Forget about common prefix lines.  */\n\t  firstin -= common_prefix;\n\t  firstnew -= common_prefix;\n\t  lastwhere -= common_prefix;\n\t}\n      if (where != lastwhere)\n\t{\n\t  where = lastwhere;\n\t  if (! copy_till (outstate, where - 1))\n\t    return false;\n\t}\n\n      if (! already_applied)\n\t{\n\t  lin common_suffix = 0;\n\t  lin lines;\n\n\t  if (conflict_style == MERGE_MERGE)\n\t    {\n\t      /* Remember common suffix lines.  */\n\t      for (lastwhere = where + (in - firstin);\n\t\t   firstin < in && firstnew < new\n\t\t   && context_matches_file (new - 1, lastwhere - 1);\n\t\t   in--, new--, lastwhere--, common_suffix++)\n\t\t/* do nothing */ ;\n\t    }\n\n\t  lines = 3 + (in - firstin) + (new - firstnew);\n\t  if (conflict_style == MERGE_DIFF3)\n\t    lines += 1 + (old - firstold);\n\t  merge_result (&first_result, hunk, \"NOT MERGED\",\n\t\t\twhere, where + lines - 1);\n\t  out_offset += lines - (in - firstin);\n\n\t  fputs (outstate->after_newline + \"\\n<<<<<<<\\n\", fp);\n\t  outstate->after_newline = true;\n\t  if (firstin < in)\n\t    {\n\t      where += (in - firstin);\n\t      if (! copy_till (outstate, where - 1))\n\t\treturn false;\n\t    }\n\n\t  if (conflict_style == MERGE_DIFF3)\n\t    {\n\t      fputs (outstate->after_newline + \"\\n|||||||\\n\", fp);\n\t      outstate->after_newline = true;\n\t      while (firstold < old)\n\t\t{\n\t\t  outstate->after_newline = pch_write_line (firstold, fp);\n\t\t  firstold++;\n\t\t}\n\t    }\n\n\t  fputs (outstate->after_newline + \"\\n=======\\n\", fp);\n\t  outstate->after_newline = true;\n\t  while (firstnew < new)\n\t    {\n\t      outstate->after_newline = pch_write_line (firstnew, fp);\n\t      firstnew++;\n\t    }\n\t  fputs (outstate->after_newline + \"\\n>>>>>>>\\n\", fp);\n\t  outstate->after_newline = true;\n\t  outstate->zero_output = false;\n\t  if (ferror (fp))\n\t    write_fatal ();\n\n\t  /* Output common suffix lines.  */\n\t  if (common_suffix)\n\t    {\n\t      where += common_suffix;\n\t      if (! copy_till (outstate, where - 1))\n\t\treturn false;\n\t      in += common_suffix;\n\t      new += common_suffix;\n\t    }\n\t  *somefailed = true;\n\t}\n    }\n  merge_result (&first_result, 0, 0, 0, 0);\n\n  assert (last_frozen_line == where - 1);\n  free (oldin);\n  return true;\n}",
      "lines": 324,
      "depth": 20,
      "decorators": [
        "bool"
      ]
    },
    "count_context_lines": {
      "start_point": [
        522,
        0
      ],
      "end_point": [
        533,
        1
      ],
      "content": "static lin\ncount_context_lines (void)\n{\n  lin old;\n  lin lastold = pch_ptrn_lines ();\n  lin context;\n\n  for (context = 0, old = 1; old <= lastold; old++)\n    if (pch_char (old) == ' ')\n      context++;\n  return context;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "lin"
      ]
    },
    "context_matches_file": {
      "start_point": [
        535,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "static bool\ncontext_matches_file (lin old, lin where)\n{\n  size_t size;\n  const char *line;\n\n  line = ifetch (where, false, &size);\n  return size &&\n\t (canonicalize_ws ?\n\t  similar (pfetch (old), pch_line_len (old), line, size) :\n\t  (size == pch_line_len (old) &&\n\t   memcmp (line, pfetch (old), size) == 0));\n}",
      "lines": 13,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "compute_changes": {
      "start_point": [
        549,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "static void\ncompute_changes (lin xmin, lin xmax, lin ymin, lin ymax,\n\t\t char *xchar, char *ychar)\n{\n  struct context ctxt;\n  lin diags;\n\n  ctxt.xchar = xchar - xmin;\n  ctxt.ychar = ychar - ymin;\n\n  diags = xmax + ymax + 3;\n  ctxt.fdiag = xmalloc (2 * diags * sizeof (*ctxt.fdiag));\n  ctxt.bdiag = ctxt.fdiag + diags;\n  ctxt.fdiag += ymax + 1;\n  ctxt.bdiag += ymax + 1;\n\n  ctxt.heuristic = true;\n\n  compareseq (xmin, xmax, ymin, ymax, false, &ctxt);\n\n  ctxt.fdiag -= ymax + 1;\n  free (ctxt.fdiag);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/src/patch.c": {
    "main": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n    char const *val;\n    bool somefailed = false;\n    struct outstate outstate;\n    struct stat tmpoutst;\n    char numbuf[LINENUM_LENGTH_BOUND + 1];\n    bool written_to_rejname = false;\n    bool skip_reject_file = false;\n    bool apply_empty_patch = false;\n    mode_t file_type;\n    int outfd = -1;\n    bool have_git_diff = false;\n\n    exit_failure = 2;\n    set_program_name (argv[0]);\n    init_time ();\n\n    setbuf(stderr, serrbuf);\n\n    bufsize = 8 * 1024;\n    buf = xmalloc (bufsize);\n\n    strippath = -1;\n\n    val = getenv (\"QUOTING_STYLE\");\n    {\n      int i = val ? argmatch (val, quoting_style_args, 0, 0) : -1;\n      set_quoting_style ((struct quoting_options *) 0,\n\t\t\t i < 0 ? shell_quoting_style : (enum quoting_style) i);\n    }\n\n    posixly_correct = getenv (\"POSIXLY_CORRECT\") != 0;\n    backup_if_mismatch = ! posixly_correct;\n    patch_get = ((val = getenv (\"PATCH_GET\"))\n\t\t ? numeric_string (val, true, \"PATCH_GET value\")\n\t\t : 0);\n\n    val = getenv (\"SIMPLE_BACKUP_SUFFIX\");\n    simple_backup_suffix = val && *val ? val : \".orig\";\n\n    if ((version_control = getenv (\"PATCH_VERSION_CONTROL\")))\n      version_control_context = \"$PATCH_VERSION_CONTROL\";\n    else if ((version_control = getenv (\"VERSION_CONTROL\")))\n      version_control_context = \"$VERSION_CONTROL\";\n\n    init_backup_hash_table ();\n    init_files_to_delete ();\n    init_files_to_output ();\n\n    /* parse switches */\n    Argc = argc;\n    Argv = argv;\n    get_some_switches();\n\n    /* Make get_date() assume that context diff headers use UTC. */\n    if (set_utc)\n      setenv (\"TZ\", \"UTC\", 1);\n\n    if (make_backups | backup_if_mismatch)\n      backup_type = get_version (version_control_context, version_control);\n\n    init_output (&outstate);\n    if (outfile)\n      outstate.ofp = open_outfile (outfile);\n\n    /* Make sure we clean up in case of disaster.  */\n    set_signals (false);\n\n    /* When the file to patch is specified on the command line, allow that file\n       to lie outside the current working tree.  Still doesn't allow to follow\n       symlinks.  */\n    if (inname)\n      unsafe = true;\n\n    if (inname && outfile)\n      {\n\t/* When an input and an output filename is given and the patch is\n\t   empty, copy the input file to the output file.  In this case, the\n\t   input file must be a regular file (i.e., symlinks cannot be copied\n\t   this way).  */\n\tapply_empty_patch = true;\n\tfile_type = S_IFREG;\n\tinerrno = -1;\n      }\n    for (\n\topen_patch_file (patchname);\n\tthere_is_another_patch (! (inname || posixly_correct), &file_type)\n\t  || apply_empty_patch;\n\treinitialize_almost_everything(),\n\t  skip_reject_file = false,\n\t  apply_empty_patch = false\n    ) {\t\t\t\t\t/* for each patch in patch file */\n      int hunk = 0;\n      int failed = 0;\n      bool mismatch = false;\n      char const *outname = NULL;\n\n      if (skip_rest_of_patch)\n\tsomefailed = true;\n\n      if (have_git_diff != pch_git_diff ())\n\t{\n\t  if (have_git_diff)\n\t    {\n\t      output_files (NULL);\n\t      inerrno = -1;\n\t    }\n\t  have_git_diff = ! have_git_diff;\n\t}\n\n      if (TMPREJNAME_needs_removal)\n\t{\n\t  if (rejfp)\n\t    {\n\t      fclose (rejfp);\n\t      rejfp = NULL;\n\t    }\n\t  remove_if_needed (TMPREJNAME, &TMPREJNAME_needs_removal);\n\t}\n      if (TMPOUTNAME_needs_removal)\n        {\n\t  if (outfd != -1)\n\t    {\n\t      close (outfd);\n\t      outfd = -1;\n\t    }\n\t  remove_if_needed (TMPOUTNAME, &TMPOUTNAME_needs_removal);\n\t}\n\n      if (! skip_rest_of_patch && ! file_type)\n\t{\n\t  say (\"File %s: can't change file type from 0%o to 0%o.\\n\",\n\t       quotearg (inname),\n\t       (unsigned int) (pch_mode (reverse) & S_IFMT),\n\t       (unsigned int) (pch_mode (! reverse) & S_IFMT));\n\t  skip_rest_of_patch = true;\n\t  somefailed = true;\n\t}\n\n      if (! skip_rest_of_patch)\n\t{\n\t  if (outfile)\n\t    outname = outfile;\n\t  else if (pch_copy () || pch_rename ())\n\t    outname = pch_name (! reverse);\n\t  else\n\t    outname = inname;\n\t}\n\n      if (pch_git_diff () && ! skip_rest_of_patch)\n\t{\n\t  struct stat outstat;\n\t  int outerrno = 0;\n\n\t  /* Try to recognize concatenated git diffs based on the SHA1 hashes\n\t     in the headers.  Will not always succeed for patches that rename\n\t     or copy files.  */\n\n\t  if (! strcmp (inname, outname))\n\t    {\n\t      if (inerrno == -1)\n\t\tinerrno = stat_file (inname, &instat);\n\t      outstat = instat;\n\t      outerrno = inerrno;\n\t    }\n\t  else\n\t    outerrno = stat_file (outname, &outstat);\n\n\t  if (! outerrno)\n\t    {\n\t      if (has_queued_output (&outstat))\n\t\t{\n\t\t  output_files (&outstat);\n\t\t  outerrno = stat_file (outname, &outstat);\n\t\t  inerrno = -1;\n\t\t}\n\t      if (! outerrno)\n\t\tset_queued_output (&outstat, true);\n\t    }\n\t}\n\n      if (! skip_rest_of_patch)\n\t{\n\t  if (! get_input_file (inname, outname, file_type))\n\t    {\n\t      skip_rest_of_patch = true;\n\t      somefailed = true;\n\t    }\n\t}\n\n      if (read_only_behavior != RO_IGNORE\n\t  && ! inerrno && ! S_ISLNK (instat.st_mode)\n\t  && safe_access (inname, W_OK) != 0)\n\t{\n\t  say (\"File %s is read-only; \", quotearg (inname));\n\t  if (read_only_behavior == RO_WARN)\n\t    say (\"trying to patch anyway\\n\");\n\t  else\n\t    {\n\t      say (\"refusing to patch\\n\");\n\t      skip_rest_of_patch = true;\n\t      somefailed = true;\n\t    }\n\t}\n\n      tmpoutst.st_size = -1;\n      outfd = make_tempfile (&TMPOUTNAME, 'o', outname,\n\t\t\t     O_WRONLY | binary_transput,\n\t\t\t     instat.st_mode & S_IRWXUGO);\n      if (outfd == -1)\n\t{\n\t  if (errno == ELOOP || errno == EXDEV)\n\t    {\n\t      say (\"Invalid file name %s -- skipping patch\\n\", quotearg (outname));\n\t      skip_rest_of_patch = true;\n\t      skip_reject_file = true;\n\t      somefailed = true;\n\t    }\n\t  else\n\t    pfatal (\"Can't create temporary file %s\", TMPOUTNAME);\n\t}\n      else\n        TMPOUTNAME_needs_removal = true;\n      if (diff_type == ED_DIFF) {\n\toutstate.zero_output = false;\n\tsomefailed |= skip_rest_of_patch;\n\tdo_ed_script (inname, TMPOUTNAME, &TMPOUTNAME_needs_removal,\n\t\t      outstate.ofp);\n\tif (! dry_run && ! outfile && ! skip_rest_of_patch)\n\t  {\n\t    if (fstat (outfd, &tmpoutst) != 0)\n\t      pfatal (\"%s\", TMPOUTNAME);\n\t    outstate.zero_output = tmpoutst.st_size == 0;\n\t  }\n\tclose (outfd);\n\toutfd = -1;\n      } else {\n\tint got_hunk;\n\tbool apply_anyway = merge;  /* don't try to reverse when merging */\n\n\tif (! skip_rest_of_patch && diff_type == GIT_BINARY_DIFF) {\n\t  say (\"File %s: git binary diffs are not supported.\\n\",\n\t       quotearg (outname));\n\t  skip_rest_of_patch = true;\n\t  somefailed = true;\n\t}\n\t/* initialize the patched file */\n\tif (! skip_rest_of_patch && ! outfile)\n\t  {\n\t    init_output (&outstate);\n\t    outstate.ofp = fdopen(outfd, binary_transput ? \"wb\" : \"w\");\n\t    if (! outstate.ofp)\n\t      pfatal (\"%s\", TMPOUTNAME);\n\t    /* outstate.ofp now owns the file descriptor */\n\t    outfd = -1;\n\t  }\n\n\t/* find out where all the lines are */\n\tif (!skip_rest_of_patch) {\n\t    scan_input (inname, file_type);\n\n\t    if (verbosity != SILENT)\n\t      {\n\t\tbool renamed = strcmp (inname, outname);\n\t\tbool skip_rename = ! renamed && pch_rename ();\n\n\t\tsay (\"%s %s %s%c\",\n\t\t     dry_run ? \"checking\" : \"patching\",\n\t\t     S_ISLNK (file_type) ? \"symbolic link\" : \"file\",\n\t\t     quotearg (outname), renamed || skip_rename ? ' ' : '\\n');\n\t\tif (renamed || skip_rename)\n\t\t  say (\"(%s%s from %s)\\n\",\n\t\t       skip_rename ? \"already \" : \"\",\n\t\t       pch_copy () ? \"copied\" :\n\t\t       (pch_rename () ? \"renamed\" : \"read\"),\n\t\t       ! skip_rename ? inname : pch_name (! strcmp (inname, pch_name (OLD))));\n\t\tif (verbosity == VERBOSE)\n\t\t  say (\"Using Plan %s...\\n\", using_plan_a ? \"A\" : \"B\");\n\t      }\n\t}\n\n\t/* from here on, open no standard i/o files, because malloc */\n\t/* might misfire and we can't catch it easily */\n\n\t/* apply each hunk of patch */\n\twhile (0 < (got_hunk = another_hunk (diff_type, reverse)))\n\t  {\n\t    lin where = 0; /* Pacify 'gcc -Wall'.  */\n\t    lin newwhere;\n\t    lin fuzz = 0;\n\t    lin mymaxfuzz;\n\n\t    if (merge)\n\t      {\n\t\t/* When in merge mode, don't apply with fuzz.  */\n\t\tmymaxfuzz = 0;\n\t      }\n\t    else\n\t      {\n\t\tlin prefix_context = pch_prefix_context ();\n\t\tlin suffix_context = pch_suffix_context ();\n\t\tlin context = (prefix_context < suffix_context\n\t\t\t       ? suffix_context : prefix_context);\n\t\tmymaxfuzz = (maxfuzz < context ? maxfuzz : context);\n\t      }\n\n\t    hunk++;\n\t    if (!skip_rest_of_patch) {\n\t\tdo {\n\t\t    where = locate_hunk(fuzz);\n\t\t    if (! where || fuzz || in_offset)\n\t\t      mismatch = true;\n\t\t    if (hunk == 1 && ! where && ! (force | apply_anyway)\n\t\t\t&& reverse == reverse_flag_specified) {\n\t\t\t\t\t\t/* dwim for reversed patch? */\n\t\t\tif (!pch_swap()) {\n\t\t\t    say (\n\"Not enough memory to try swapped hunk!  Assuming unswapped.\\n\");\n\t\t\t    continue;\n\t\t\t}\n\t\t\t/* Try again.  */\n\t\t\twhere = locate_hunk (fuzz);\n\t\t\tif (where\n\t\t\t    && (ok_to_reverse\n\t\t\t\t(\"%s patch detected!\",\n\t\t\t\t (reverse\n\t\t\t\t  ? \"Unreversed\"\n\t\t\t\t  : \"Reversed (or previously applied)\"))))\n\t\t\t  reverse = ! reverse;\n\t\t\telse\n\t\t\t  {\n\t\t\t    /* Put it back to normal.  */\n\t\t\t    if (! pch_swap ())\n\t\t\t      fatal (\"lost hunk on alloc error!\");\n\t\t\t    if (where)\n\t\t\t      {\n\t\t\t\tapply_anyway = true;\n\t\t\t\tfuzz--; /* Undo '++fuzz' below.  */\n\t\t\t\twhere = 0;\n\t\t\t      }\n\t\t\t  }\n\t\t    }\n\t\t} while (!skip_rest_of_patch && !where\n\t\t\t && ++fuzz <= mymaxfuzz);\n\n\t\tif (skip_rest_of_patch) {\t\t/* just got decided */\n\t\t  if (outstate.ofp && ! outfile)\n\t\t    {\n\t\t      fclose (outstate.ofp);\n\t\t      outstate.ofp = 0;\n\t\t      outfd = -1;\n\t\t    }\n\t\t}\n\t    }\n\n\t    newwhere = (where ? where : pch_first()) + out_offset;\n\t    if (skip_rest_of_patch\n\t\t|| (merge && ! merge_hunk (hunk, &outstate, where,\n\t\t\t\t\t   &somefailed))\n\t\t|| (! merge\n\t\t    && ((where == 1 && pch_says_nonexistent (reverse) == 2\n\t\t\t && instat.st_size)\n\t\t\t|| ! where\n\t\t\t|| ! apply_hunk (&outstate, where))))\n\t      {\n\t\tif (! skip_reject_file)\n\t\t  abort_hunk (outname, ! failed, reverse);\n\t\tfailed++;\n\t\tif (verbosity == VERBOSE ||\n\t\t    (! skip_rest_of_patch && verbosity != SILENT))\n\t\t  say (\"Hunk #%d %s at %s%s.\\n\", hunk,\n\t\t       skip_rest_of_patch ? \"ignored\" : \"FAILED\",\n\t\t       format_linenum (numbuf, newwhere),\n\t\t       ! skip_rest_of_patch && check_line_endings (newwhere)\n\t\t\t ?  \" (different line endings)\" : \"\");\n\t      }\n\t    else if (! merge &&\n\t\t     (verbosity == VERBOSE\n\t\t      || (verbosity != SILENT && (fuzz || in_offset))))\n\t      {\n\t\tsay (\"Hunk #%d succeeded at %s\", hunk,\n\t\t     format_linenum (numbuf, newwhere));\n\t\tif (fuzz)\n\t\t  say (\" with fuzz %s\", format_linenum (numbuf, fuzz));\n\t\tif (in_offset)\n\t\t  say (\" (offset %s line%s)\",\n\t\t       format_linenum (numbuf, in_offset),\n\t\t       \"s\" + (in_offset == 1));\n\t\tsay (\".\\n\");\n\t      }\n\t  }\n\n\tif (!skip_rest_of_patch)\n\t  {\n\t    if (got_hunk < 0  &&  using_plan_a)\n\t      {\n\t\tif (outfile)\n\t\t  fatal (\"out of memory using Plan A\");\n\t\tsay (\"\\n\\nRan out of memory using Plan A -- trying again...\\n\\n\");\n\t\tif (outstate.ofp)\n\t\t  {\n\t\t    fclose (outstate.ofp);\n\t\t    outstate.ofp = 0;\n\t\t  }\n\t\tcontinue;\n\t      }\n\n\t    /* Finish spewing out the new file.  */\n\t    if (! spew_output (&outstate, &tmpoutst))\n\t      {\n\t\tsay (\"Skipping patch.\\n\");\n\t\tskip_rest_of_patch = true;\n\t      }\n\t  }\n      }\n\n      /* and put the output where desired */\n      ignore_signals ();\n      if (! skip_rest_of_patch && ! outfile) {\n\t  bool backup = make_backups\n\t\t\t|| (backup_if_mismatch && (mismatch | failed));\n\t  if (outstate.zero_output\n\t      && (remove_empty_files\n\t\t  || (pch_says_nonexistent (! reverse) == 2\n\t\t      && ! posixly_correct)\n\t\t  || S_ISLNK (file_type)))\n\t    {\n\t      if (! dry_run)\n\t\toutput_file (NULL, NULL, NULL, outname,\n\t\t\t     (inname == outname) ? &instat : NULL,\n\t\t\t     file_type | 0, backup);\n\t    }\n\t  else\n\t    {\n\t      if (! outstate.zero_output\n\t\t  && pch_says_nonexistent (! reverse) == 2\n\t\t  && (remove_empty_files || ! posixly_correct)\n\t\t  && ! (merge && somefailed))\n\t\t{\n\t\t  mismatch = true;\n\t\t  somefailed = true;\n\t\t  if (verbosity != SILENT)\n\t\t    say (\"Not deleting file %s as content differs from patch\\n\",\n\t\t\t quotearg (outname));\n\t\t}\n\n\t      if (! dry_run)\n\t\t{\n\t\t  mode_t old_mode = pch_mode (reverse);\n\t\t  mode_t new_mode = pch_mode (! reverse);\n\t\t  bool set_mode = new_mode && old_mode != new_mode;\n\n\t\t  /* Avoid replacing files when nothing has changed.  */\n\t\t  if (failed < hunk || diff_type == ED_DIFF || set_mode\n\t\t      || pch_copy () || pch_rename ())\n\t\t    {\n\t\t      enum file_attributes attr = 0;\n\t\t      struct timespec new_time = pch_timestamp (! reverse);\n\t\t      mode_t mode = file_type |\n\t\t\t  ((set_mode ? new_mode : instat.st_mode) & S_IRWXUGO);\n\n\t\t      if ((set_time | set_utc) && new_time.tv_sec != -1)\n\t\t\t{\n\t\t\t  struct timespec old_time = pch_timestamp (reverse);\n\n\t\t\t  if (! force && ! inerrno\n\t\t\t      && pch_says_nonexistent (reverse) != 2\n\t\t\t      && old_time.tv_sec != -1\n\t\t\t      && timespec_cmp (old_time,\n\t\t\t\t\t       get_stat_mtime (&instat)))\n\t\t\t    say (\"Not setting time of file %s \"\n\t\t\t\t \"(time mismatch)\\n\",\n\t\t\t\t quotearg (outname));\n\t\t\t  else if (! force && (mismatch | failed))\n\t\t\t    say (\"Not setting time of file %s \"\n\t\t\t\t \"(contents mismatch)\\n\",\n\t\t\t\t quotearg (outname));\n\t\t\t  else\n\t\t\t    attr |= FA_TIMES;\n\t\t\t}\n\n\t\t      if (inerrno)\n\t\t        {\n\t\t\t  if (set_mode)\n\t\t\t    attr |= FA_MODE;\n\t\t\t  set_file_attributes (TMPOUTNAME, attr, NULL, NULL,\n\t\t\t\t\t       mode, &new_time);\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  attr |= FA_IDS | FA_MODE | FA_XATTRS;\n\t\t\t  set_file_attributes (TMPOUTNAME, attr, inname, &instat,\n\t\t\t\t\t       mode, &new_time);\n\t\t\t}\n\n\t\t      output_file (TMPOUTNAME, &TMPOUTNAME_needs_removal,\n\t\t\t\t   &tmpoutst, outname, NULL, mode, backup);\n\n\t\t      if (pch_rename ())\n\t\t\toutput_file (NULL, NULL, NULL, inname, &instat,\n\t\t\t\t     mode, backup);\n\t\t    }\n\t\t  else\n\t\t    output_file (outname, NULL, &tmpoutst, NULL, NULL,\n\t\t\t\t file_type | 0, backup);\n\t\t}\n\t    }\n      }\n      if (diff_type != ED_DIFF) {\n\tstruct stat rejst;\n\n\tif (failed && ! skip_reject_file) {\n\t    if (fstat (fileno (rejfp), &rejst) != 0 || fclose (rejfp) != 0)\n\t      write_fatal ();\n\t    rejfp = NULL;\n\t    somefailed = true;\n\t    say (\"%d out of %d hunk%s %s\", failed, hunk, \"s\" + (hunk == 1),\n\t\t skip_rest_of_patch ? \"ignored\" : \"FAILED\");\n\t    if (outname && (! rejname || strcmp (rejname, \"-\") != 0)) {\n\t\tchar *rej = rejname;\n\t\tif (!rejname) {\n\t\t    /* FIXME: This should really be done differently!  */\n\t\t    const char *s = simple_backup_suffix;\n\t\t    size_t len;\n\t\t    simple_backup_suffix = \".rej\";\n\t\t    rej = find_backup_file_name (outname, simple_backups);\n\t\t    len = strlen (rej);\n\t\t    if (rej[len - 1] == '~')\n\t\t      rej[len - 1] = '#';\n\t\t    simple_backup_suffix = s;\n\t\t}\n\t\tif (! dry_run)\n\t\t  {\n\t\t    say (\" -- saving rejects to file %s\\n\", quotearg (rej));\n\t\t    if (rejname)\n\t\t      {\n\t\t\tif (! written_to_rejname)\n\t\t\t  {\n\t\t\t    copy_file (TMPREJNAME, rejname, 0, 0,\n\t\t\t\t       S_IFREG | 0666, true);\n\t\t\t    written_to_rejname = true;\n\t\t\t  }\n\t\t\telse\n\t\t\t  append_to_file (TMPREJNAME, rejname);\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\tstruct stat oldst;\n\t\t\tint olderrno;\n\n\t\t\tolderrno = stat_file (rej, &oldst);\n\t\t\tif (olderrno && olderrno != ENOENT)\n\t\t\t  write_fatal ();\n\t\t        if (! olderrno && lookup_file_id (&oldst) == CREATED)\n\t\t\t  append_to_file (TMPREJNAME, rej);\n\t\t\telse\n\t\t\t  move_file (TMPREJNAME, &TMPREJNAME_needs_removal,\n\t\t\t\t     &rejst, rej, S_IFREG | 0666, false);\n\t\t      }\n\t\t  }\n\t\telse\n\t\t  say (\"\\n\");\n\t\tif (!rejname)\n\t\t    free (rej);\n\t    } else\n\t      say (\"\\n\");\n\t}\n      }\n      set_signals (true);\n    }\n    if (outstate.ofp && (ferror (outstate.ofp) || fclose (outstate.ofp) != 0))\n      write_fatal ();\n    output_files (NULL);\n    cleanup ();\n    delete_files ();\n    if (somefailed)\n      exit (1);\n    return 0;\n}",
      "lines": 581,
      "depth": 24,
      "decorators": [
        "int"
      ]
    },
    "reinitialize_almost_everything": {
      "start_point": [
        692,
        0
      ],
      "end_point": [
        718,
        1
      ],
      "content": "static void\nreinitialize_almost_everything (void)\n{\n    re_patch();\n    re_input();\n\n    input_lines = 0;\n    last_frozen_line = 0;\n\n    if (inname && ! explicit_inname) {\n\tfree (inname);\n\tinname = 0;\n    }\n\n    in_offset = 0;\n    out_offset = 0;\n\n    diff_type = NO_DIFF;\n\n    if (revision) {\n\tfree(revision);\n\trevision = 0;\n    }\n\n    reverse = reverse_flag_specified;\n    skip_rest_of_patch = false;\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "usage": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "static void\nusage (FILE *stream, int status)\n{\n  char const * const *p;\n\n  if (status != 0)\n    {\n      fprintf (stream, \"%s: Try '%s --help' for more information.\\n\",\n\t       program_name, Argv[0]);\n    }\n  else\n    {\n      fprintf (stream, \"Usage: %s [OPTION]... [ORIGFILE [PATCHFILE]]\\n\\n\",\n\t       Argv[0]);\n      for (p = option_help;  *p;  p++)\n\tfprintf (stream, \"%s\\n\", *p);\n    }\n\n  exit (status);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_some_switches": {
      "start_point": [
        869,
        0
      ],
      "end_point": [
        1087,
        1
      ],
      "content": "static void\nget_some_switches (void)\n{\n    int optc;\n\n    free (rejname);\n    rejname = 0;\n    if (optind == Argc)\n\treturn;\n    while ((optc = getopt_long (Argc, Argv, shortopts, longopts, (int *) 0))\n\t   != -1) {\n\tswitch (optc) {\n\t    case 'b':\n\t\tmake_backups = true;\n\t\t /* Special hack for backward compatibility with CVS 1.9.\n\t\t    If the last 4 args are '-b SUFFIX ORIGFILE PATCHFILE',\n\t\t    treat '-b' as if it were '-b -z'.  */\n\t\tif (Argc - optind == 3\n\t\t    && strcmp (Argv[optind - 1], \"-b\") == 0\n\t\t    && ! (Argv[optind + 0][0] == '-' && Argv[optind + 0][1])\n\t\t    && ! (Argv[optind + 1][0] == '-' && Argv[optind + 1][1])\n\t\t    && ! (Argv[optind + 2][0] == '-' && Argv[optind + 2][1]))\n\t\t  {\n\t\t    optarg = Argv[optind++];\n\t\t    if (verbosity != SILENT)\n\t\t      say (\"warning: the '-b %s' option is obsolete; use '-b -z %s' instead\\n\",\n\t\t\t   optarg, optarg);\n\t\t    goto case_z;\n\t\t  }\n\t\tbreak;\n\t    case 'B':\n\t\tif (!*optarg)\n\t\t  fatal (\"backup prefix is empty\");\n\t\torigprae = xstrdup (optarg);\n\t\tbreak;\n\t    case 'c':\n\t\tdiff_type = CONTEXT_DIFF;\n\t\tbreak;\n\t    case 'd':\n\t\tif (chdir(optarg) < 0)\n\t\t  pfatal (\"Can't change to directory %s\", quotearg (optarg));\n\t\tbreak;\n\t    case 'D':\n\t\tdo_defines = xstrdup (optarg);\n\t\tbreak;\n\t    case 'e':\n\t\tdiff_type = ED_DIFF;\n\t\tbreak;\n\t    case 'E':\n\t\tremove_empty_files = true;\n\t\tbreak;\n\t    case 'f':\n\t\tforce = true;\n\t\tbreak;\n\t    case 'F':\n\t\tmaxfuzz = numeric_string (optarg, false, \"fuzz factor\");\n\t\tbreak;\n\t    case 'g':\n\t\tpatch_get = numeric_string (optarg, true, \"get option value\");\n\t\tbreak;\n\t    case 'i':\n\t\tpatchname = xstrdup (optarg);\n\t\tbreak;\n\t    case 'l':\n\t\tcanonicalize_ws = true;\n\t\tbreak;\n#ifdef ENABLE_MERGE\n\t    case 'm':\n\t\tmerge = true;\n\t\tif (optarg)\n\t\t  {\n\t\t    if (! strcmp (optarg, \"merge\"))\n\t\t      conflict_style = MERGE_MERGE;\n\t\t    else if (! strcmp (optarg, \"diff3\"))\n\t\t      conflict_style = MERGE_DIFF3;\n\t\t    else\n\t\t      usage (stderr, 2);\n\t\t  }\n\t\telse\n\t\t  conflict_style = MERGE_MERGE;\n\t\tbreak;\n#endif\n\t    case 'n':\n\t\tdiff_type = NORMAL_DIFF;\n\t\tbreak;\n\t    case 'N':\n\t\tnoreverse = true;\n\t\tbreak;\n\t    case 'o':\n\t\toutfile = xstrdup (optarg);\n\t\tbreak;\n\t    case 'p':\n\t\tstrippath = numeric_string (optarg, false, \"strip count\");\n\t\tbreak;\n\t    case 'r':\n\t\trejname = xstrdup (optarg);\n\t\tbreak;\n\t    case 'R':\n\t\treverse = true;\n\t\treverse_flag_specified = true;\n\t\tbreak;\n\t    case 's':\n\t\tverbosity = SILENT;\n\t\tbreak;\n\t    case 't':\n\t\tbatch = true;\n\t\tbreak;\n\t    case 'T':\n\t\tset_time = true;\n\t\tbreak;\n\t    case 'u':\n\t\tdiff_type = UNI_DIFF;\n\t\tbreak;\n\t    case 'v':\n\t\tversion();\n\t\texit (0);\n\t\tbreak;\n\t    case 'V':\n\t\tversion_control = optarg;\n\t\tversion_control_context = \"--version-control or -V option\";\n\t\tbreak;\n#if DEBUGGING\n\t    case 'x':\n\t\tdebug = numeric_string (optarg, true, \"debugging option\");\n\t\tbreak;\n#endif\n\t    case 'Y':\n\t\tif (!*optarg)\n\t\t  fatal (\"backup basename prefix is empty\");\n\t\torigbase = xstrdup (optarg);\n\t\tbreak;\n\t    case 'z':\n\t    case_z:\n\t\tif (!*optarg)\n\t\t  fatal (\"backup suffix is empty\");\n\t\torigsuff = xstrdup (optarg);\n\t\tbreak;\n\t    case 'Z':\n\t\tset_utc = true;\n\t\tbreak;\n\t    case CHAR_MAX + 1:\n\t\tdry_run = true;\n\t\tbreak;\n\t    case CHAR_MAX + 2:\n\t\tverbosity = VERBOSE;\n\t\tbreak;\n\t    case CHAR_MAX + 3:\n\t\tno_strip_trailing_cr = true;\n#if HAVE_SETMODE_DOS\n\t\tbinary_transput = O_BINARY;\n#endif\n\t\tbreak;\n\t    case CHAR_MAX + 4:\n\t\tusage (stdout, 0);\n\t    case CHAR_MAX + 5:\n\t\tbackup_if_mismatch = true;\n\t\tbreak;\n\t    case CHAR_MAX + 6:\n\t\tbackup_if_mismatch = false;\n\t\tbreak;\n\t    case CHAR_MAX + 7:\n\t\tposixly_correct = true;\n\t\tbreak;\n\t    case CHAR_MAX + 8:\n\t\t{\n\t\t  int i = argmatch (optarg, quoting_style_args, 0, 0);\n\t\t  if (i < 0)\n\t\t    {\n\t\t      invalid_arg (\"quoting style\", optarg, i);\n\t\t      usage (stderr, 2);\n\t\t    }\n\t\t  set_quoting_style ((struct quoting_options *) 0,\n\t\t\t\t     (enum quoting_style) i);\n\t\t}\n\t\tbreak;\n\t    case CHAR_MAX + 9:\n\t\tif (strcmp (optarg, \"context\") == 0)\n\t\t  reject_format = NEW_CONTEXT_DIFF;\n\t\telse if (strcmp (optarg, \"unified\") == 0)\n\t\t  reject_format = UNI_DIFF;\n\t\telse\n\t\t  usage (stderr, 2);\n\t\tbreak;\n\t    case CHAR_MAX + 10:\n\t\tif (strcmp (optarg, \"ignore\") == 0)\n\t\t  read_only_behavior = RO_IGNORE;\n\t\telse if (strcmp (optarg, \"warn\") == 0)\n\t\t  read_only_behavior = RO_WARN;\n\t\telse if (strcmp (optarg, \"fail\") == 0)\n\t\t  read_only_behavior = RO_FAIL;\n\t\telse\n\t\t  usage (stderr, 2);\n\t\tbreak;\n\t    case CHAR_MAX + 11:\n\t\tfollow_symlinks = true;\n\t\tbreak;\n\t    default:\n\t\tusage (stderr, 2);\n\t}\n    }\n\n    /* Process any filename args.  */\n    if (optind < Argc)\n      {\n\tinname = xstrdup (Argv[optind++]);\n\texplicit_inname = true;\n\tinvc = -1;\n\tif (optind < Argc)\n\t  {\n\t    patchname = xstrdup (Argv[optind++]);\n\t    if (optind < Argc)\n\t      {\n\t\tfprintf (stderr, \"%s: %s: extra operand\\n\",\n\t\t\t program_name, quotearg (Argv[optind]));\n\t\tusage (stderr, 2);\n\t      }\n\t  }\n      }\n}",
      "lines": 219,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "numeric_string": {
      "start_point": [
        1092,
        0
      ],
      "end_point": [
        1124,
        1
      ],
      "content": "static int\nnumeric_string (char const *string,\n\t\tbool negative_allowed,\n\t\tchar const *argtype_msgid)\n{\n  int value = 0;\n  char const *p = string;\n  int sign = *p == '-' ? -1 : 1;\n\n  p += *p == '-' || *p == '+';\n\n  do\n    {\n      int v10 = value * 10;\n      int digit = *p - '0';\n      int signed_digit = sign * digit;\n      int next_value = v10 + signed_digit;\n\n      if (9 < (unsigned) digit)\n\tfatal (\"%s %s is not a number\", argtype_msgid, quotearg (string));\n\n      if (v10 / 10 != value || (next_value < v10) != (signed_digit < 0))\n\tfatal (\"%s %s is too large\", argtype_msgid, quotearg (string));\n\n      value = next_value;\n    }\n  while (*++p);\n\n  if (value < 0 && ! negative_allowed)\n    fatal (\"%s %s is negative\", argtype_msgid, quotearg (string));\n\n  return value;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "locate_hunk": {
      "start_point": [
        1128,
        0
      ],
      "end_point": [
        1217,
        1
      ],
      "content": "static lin\nlocate_hunk (lin fuzz)\n{\n    lin first_guess = pch_first () + in_offset;\n    lin offset;\n    lin pat_lines = pch_ptrn_lines();\n    lin prefix_context = pch_prefix_context ();\n    lin suffix_context = pch_suffix_context ();\n    lin context = (prefix_context < suffix_context\n\t\t   ? suffix_context : prefix_context);\n    lin prefix_fuzz = fuzz + prefix_context - context;\n    lin suffix_fuzz = fuzz + suffix_context - context;\n    lin max_where = input_lines - (pat_lines - suffix_fuzz) + 1;\n    lin min_where = last_frozen_line + 1;\n    lin max_pos_offset = max_where - first_guess;\n    lin max_neg_offset = first_guess - min_where;\n    lin max_offset = MAX(max_pos_offset, max_neg_offset);\n    lin min_offset;\n\n    if (!pat_lines)\t\t\t/* null range matches always */\n\treturn first_guess;\n\n    /* Do not try lines <= 0.  */\n    if (first_guess <= max_neg_offset)\n\tmax_neg_offset = first_guess - 1;\n\n    if (prefix_fuzz < 0 && pch_first () <= 1)\n      {\n\t/* Can only match start of file.  */\n\n\tif (suffix_fuzz < 0)\n\t  /* Can only match entire file.  */\n\t  if (pat_lines != input_lines || prefix_context < last_frozen_line)\n\t    return 0;\n\n\toffset = 1 - first_guess;\n\tif (last_frozen_line <= prefix_context\n\t    && offset <= max_pos_offset\n\t    && patch_match (first_guess, offset, 0, suffix_fuzz))\n\t  {\n\t    in_offset += offset;\n\t    return first_guess + offset;\n\t  }\n\telse\n\t  return 0;\n      }\n    else if (prefix_fuzz < 0)\n      prefix_fuzz = 0;\n\n    if (suffix_fuzz < 0)\n      {\n\t/* Can only match end of file.  */\n\toffset = first_guess - (input_lines - pat_lines + 1);\n\tif (offset <= max_neg_offset\n\t    && patch_match (first_guess, -offset, prefix_fuzz, 0))\n\t  {\n\t    in_offset -= offset;\n\t    return first_guess - offset;\n\t  }\n\telse\n\t  return 0;\n      }\n\n    min_offset = max_pos_offset < 0 ? first_guess - max_where\n\t       : max_neg_offset < 0 ? first_guess - min_where\n\t       : 0;\n    for (offset = min_offset;  offset <= max_offset;  offset++) {\n\tchar numbuf0[LINENUM_LENGTH_BOUND + 1];\n\tchar numbuf1[LINENUM_LENGTH_BOUND + 1];\n\tif (offset <= max_pos_offset\n\t    && patch_match (first_guess, offset, prefix_fuzz, suffix_fuzz)) {\n\t    if (debug & 1)\n\t      say (\"Offset changing from %s to %s\\n\",\n\t\t   format_linenum (numbuf0, in_offset),\n\t\t   format_linenum (numbuf1, in_offset + offset));\n\t    in_offset += offset;\n\t    return first_guess+offset;\n\t}\n\tif (offset <= max_neg_offset\n\t    && patch_match (first_guess, -offset, prefix_fuzz, suffix_fuzz)) {\n\t    if (debug & 1)\n\t      say (\"Offset changing from %s to %s\\n\",\n\t\t   format_linenum (numbuf0, in_offset),\n\t\t   format_linenum (numbuf1, in_offset - offset));\n\t    in_offset -= offset;\n\t    return first_guess-offset;\n\t}\n    }\n    return 0;\n}",
      "lines": 90,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "lin"
      ]
    },
    "mangled_patch": {
      "start_point": [
        1219,
        0
      ],
      "end_point": [
        1231,
        1
      ],
      "content": "static void __attribute__ ((noreturn))\nmangled_patch (lin old, lin new)\n{\n  char numbuf0[LINENUM_LENGTH_BOUND + 1];\n  char numbuf1[LINENUM_LENGTH_BOUND + 1];\n  if (debug & 1)\n    say (\"oldchar = '%c', newchar = '%c'\\n\",\n        pch_char (old), pch_char (new));\n  fatal (\"Out-of-sync patch, lines %s,%s -- mangled text or line numbers, \"\n        \"maybe?\",\n        format_linenum (numbuf0, pch_hunk_beg () + old),\n        format_linenum (numbuf1, pch_hunk_beg () + new));\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((noreturn))",
        "__attribute__",
        "(",
        "(noreturn)",
        "(",
        "noreturn",
        ")",
        ")"
      ]
    },
    "print_unidiff_range": {
      "start_point": [
        1235,
        0
      ],
      "end_point": [
        1257,
        1
      ],
      "content": "static void\nprint_unidiff_range (FILE *fp, lin start, lin count)\n{\n  char numbuf0[LINENUM_LENGTH_BOUND + 1];\n  char numbuf1[LINENUM_LENGTH_BOUND + 1];\n\n  switch (count)\n    {\n    case 0:\n      fprintf (fp, \"%s,0\", format_linenum (numbuf0, start - 1));\n      break;\n\n    case 1:\n      fprintf (fp, \"%s\", format_linenum (numbuf0, start));\n      break;\n\n    default:\n      fprintf (fp, \"%s,%s\",\n              format_linenum (numbuf0, start),\n              format_linenum (numbuf1, count));\n      break;\n    }\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_header_line": {
      "start_point": [
        1259,
        0
      ],
      "end_point": [
        1267,
        1
      ],
      "content": "static void\nprint_header_line (FILE *fp, const char *tag, bool reverse)\n{\n  const char *name = pch_name (reverse);\n  const char *timestr = pch_timestr (reverse);\n\n  fprintf (fp, \"%s %s%s\\n\", tag, name ? name : \"/dev/null\",\n\t   timestr ? timestr : \"\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "abort_hunk_unified": {
      "start_point": [
        1271,
        0
      ],
      "end_point": [
        1324,
        1
      ],
      "content": "static void\nabort_hunk_unified (bool header, bool reverse)\n{\n  lin old = 1;\n  lin lastline = pch_ptrn_lines ();\n  lin new = lastline + 1;\n  char const *c_function = pch_c_function();\n\n  if (header)\n    {\n      if (pch_name (INDEX))\n\tfprintf(rejfp, \"Index: %s\\n\", pch_name (INDEX));\n      print_header_line (rejfp, \"---\", reverse);\n      print_header_line (rejfp, \"+++\", ! reverse);\n    }\n\n  /* Add out_offset to guess the same as the previous successful hunk.  */\n  fprintf (rejfp, \"@@ -\");\n  print_unidiff_range (rejfp, pch_first () + out_offset, lastline);\n  fprintf (rejfp, \" +\");\n  print_unidiff_range (rejfp, pch_newfirst () + out_offset, pch_repl_lines ());\n  fprintf (rejfp, \" @@%s\\n\", c_function ? c_function : \"\");\n\n  while (pch_char (new) == '=' || pch_char (new) == '\\n')\n    new++;\n\n  if (diff_type != UNI_DIFF)\n    pch_normalize (UNI_DIFF);\n\n  for (; ; old++, new++)\n    {\n      for (;  pch_char (old) == '-';  old++)\n\t{\n\t  fputc ('-', rejfp);\n\t  pch_write_line (old, rejfp);\n\t}\n      for (;  pch_char (new) == '+';  new++)\n\t{\n\t  fputc ('+', rejfp);\n\t  pch_write_line (new, rejfp);\n\t}\n\n      if (old > lastline)\n\t  break;\n\n      if (pch_char (new) != pch_char (old))\n\tmangled_patch (old, new);\n\n      fputc (' ', rejfp);\n      pch_write_line (old, rejfp);\n    }\n  if (pch_char (new) != '^')\n    mangled_patch (old, new);\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "abort_hunk_context": {
      "start_point": [
        1328,
        0
      ],
      "end_point": [
        1393,
        1
      ],
      "content": "static void\nabort_hunk_context (bool header, bool reverse)\n{\n    lin i;\n    lin pat_end = pch_end ();\n    /* add in out_offset to guess the same as the previous successful hunk */\n    lin oldfirst = pch_first() + out_offset;\n    lin newfirst = pch_newfirst() + out_offset;\n    lin oldlast = oldfirst + pch_ptrn_lines() - 1;\n    lin newlast = newfirst + pch_repl_lines() - 1;\n    char const *stars =\n      (int) NEW_CONTEXT_DIFF <= (int) diff_type ? \" ****\" : \"\";\n    char const *minuses =\n      (int) NEW_CONTEXT_DIFF <= (int) diff_type ? \" ----\" : \" -----\";\n    char const *c_function = pch_c_function();\n\n    if (diff_type == UNI_DIFF)\n      pch_normalize (NEW_CONTEXT_DIFF);\n\n    if (header)\n      {\n\tif (pch_name (INDEX))\n\t  fprintf(rejfp, \"Index: %s\\n\", pch_name (INDEX));\n\tprint_header_line (rejfp, \"***\", reverse);\n\tprint_header_line (rejfp, \"---\", ! reverse);\n      }\n    fprintf(rejfp, \"***************%s\\n\", c_function ? c_function : \"\");\n    for (i=0; i<=pat_end; i++) {\n\tchar numbuf0[LINENUM_LENGTH_BOUND + 1];\n\tchar numbuf1[LINENUM_LENGTH_BOUND + 1];\n\tswitch (pch_char(i)) {\n\tcase '*':\n\t    if (oldlast < oldfirst)\n\t\tfprintf(rejfp, \"*** 0%s\\n\", stars);\n\t    else if (oldlast == oldfirst)\n\t\tfprintf (rejfp, \"*** %s%s\\n\",\n\t\t\t format_linenum (numbuf0, oldfirst), stars);\n\t    else\n\t\tfprintf (rejfp, \"*** %s,%s%s\\n\",\n\t\t\t format_linenum (numbuf0, oldfirst),\n\t\t\t format_linenum (numbuf1, oldlast), stars);\n\t    break;\n\tcase '=':\n\t    if (newlast < newfirst)\n\t\tfprintf(rejfp, \"--- 0%s\\n\", minuses);\n\t    else if (newlast == newfirst)\n\t\tfprintf (rejfp, \"--- %s%s\\n\",\n\t\t\t format_linenum (numbuf0, newfirst), minuses);\n\t    else\n\t\tfprintf (rejfp, \"--- %s,%s%s\\n\",\n\t\t\t format_linenum (numbuf0, newfirst),\n\t\t\t format_linenum (numbuf1, newlast), minuses);\n\t    break;\n\tcase ' ': case '-': case '+': case '!':\n\t    fprintf (rejfp, \"%c \", pch_char (i));\n\t    /* fall into */\n\tcase '\\n':\n\t    pch_write_line (i, rejfp);\n\t    break;\n\tdefault:\n\t    fatal (\"fatal internal error in abort_hunk_context\");\n\t}\n\tif (ferror (rejfp))\n\t  write_fatal ();\n    }\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "abort_hunk": {
      "start_point": [
        1397,
        0
      ],
      "end_point": [
        1407,
        1
      ],
      "content": "static void\nabort_hunk (char const *outname, bool header, bool reverse)\n{\n  if (! TMPREJNAME_needs_removal)\n    init_reject (outname);\n  if (reject_format == UNI_DIFF\n      || (reject_format == NO_DIFF && diff_type == UNI_DIFF))\n    abort_hunk_unified (header, reverse);\n  else\n    abort_hunk_context (header, reverse);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_hunk": {
      "start_point": [
        1411,
        0
      ],
      "end_point": [
        1560,
        1
      ],
      "content": "static bool\napply_hunk (struct outstate *outstate, lin where)\n{\n    lin old = 1;\n    lin lastline = pch_ptrn_lines ();\n    lin new = lastline+1;\n    enum {OUTSIDE, IN_IFNDEF, IN_IFDEF, IN_ELSE} def_state = OUTSIDE;\n    char const *R_do_defines = do_defines;\n    lin pat_end = pch_end ();\n    FILE *fp = outstate->ofp;\n\n    where--;\n    while (pch_char(new) == '=' || pch_char(new) == '\\n')\n\tnew++;\n\n    while (old <= lastline) {\n\tif (pch_char(old) == '-') {\n\t    assert (outstate->after_newline);\n\t    if (! copy_till (outstate, where + old - 1))\n\t\treturn false;\n\t    if (R_do_defines) {\n\t\tif (def_state == OUTSIDE) {\n\t\t    fprintf (fp, outstate->after_newline + not_defined,\n\t\t\t     R_do_defines);\n\t\t    def_state = IN_IFNDEF;\n\t\t}\n\t\telse if (def_state == IN_IFDEF) {\n\t\t    fputs (outstate->after_newline + else_defined, fp);\n\t\t    def_state = IN_ELSE;\n\t\t}\n\t\tif (ferror (fp))\n\t\t  write_fatal ();\n\t\toutstate->after_newline = pch_write_line (old, fp);\n\t\toutstate->zero_output = false;\n\t    }\n\t    last_frozen_line++;\n\t    old++;\n\t}\n\telse if (new > pat_end) {\n\t    break;\n\t}\n\telse if (pch_char(new) == '+') {\n\t    if (! copy_till (outstate, where + old - 1))\n\t\treturn false;\n\t    if (R_do_defines) {\n\t\tif (def_state == IN_IFNDEF) {\n\t\t    fputs (outstate->after_newline + else_defined, fp);\n\t\t    def_state = IN_ELSE;\n\t\t}\n\t\telse if (def_state == OUTSIDE) {\n\t\t    fprintf (fp, outstate->after_newline + if_defined,\n\t\t\t     R_do_defines);\n\t\t    def_state = IN_IFDEF;\n\t\t}\n\t\tif (ferror (fp))\n\t\t  write_fatal ();\n\t    }\n\t    outstate->after_newline = pch_write_line (new, fp);\n\t    outstate->zero_output = false;\n\t    new++;\n\t}\n\telse if (pch_char(new) != pch_char(old))\n\t  mangled_patch (old, new);\n\telse if (pch_char(new) == '!') {\n\t    assert (outstate->after_newline);\n\t    if (! copy_till (outstate, where + old - 1))\n\t\treturn false;\n\t    assert (outstate->after_newline);\n\t    if (R_do_defines) {\n\t       fprintf (fp, 1 + not_defined, R_do_defines);\n\t       if (ferror (fp))\n\t\twrite_fatal ();\n\t       def_state = IN_IFNDEF;\n\t    }\n\n\t    do\n\t      {\n\t\tif (R_do_defines) {\n\t\t    outstate->after_newline = pch_write_line (old, fp);\n\t\t}\n\t\tlast_frozen_line++;\n\t\told++;\n\t      }\n\t    while (pch_char (old) == '!');\n\n\t    if (R_do_defines) {\n\t\tfputs (outstate->after_newline + else_defined, fp);\n\t\tif (ferror (fp))\n\t\t  write_fatal ();\n\t\tdef_state = IN_ELSE;\n\t    }\n\n\t    do\n\t      {\n\t\toutstate->after_newline = pch_write_line (new, fp);\n\t\tnew++;\n\t      }\n\t    while (pch_char (new) == '!');\n\t    outstate->zero_output = false;\n\t}\n\telse {\n\t    assert(pch_char(new) == ' ');\n\t    old++;\n\t    new++;\n\t    if (R_do_defines && def_state != OUTSIDE) {\n\t\tfputs (outstate->after_newline + end_defined, fp);\n\t\tif (ferror (fp))\n\t\t  write_fatal ();\n\t\toutstate->after_newline = true;\n\t\tdef_state = OUTSIDE;\n\t    }\n\t}\n    }\n    if (new <= pat_end && pch_char(new) == '+') {\n\tif (! copy_till (outstate, where + old - 1))\n\t    return false;\n\tif (R_do_defines) {\n\t    if (def_state == OUTSIDE) {\n\t\tfprintf (fp, outstate->after_newline + if_defined,\n\t\t\t R_do_defines);\n\t\tdef_state = IN_IFDEF;\n\t    }\n\t    else if (def_state == IN_IFNDEF) {\n\t\tfputs (outstate->after_newline + else_defined, fp);\n\t\tdef_state = IN_ELSE;\n\t    }\n\t    if (ferror (fp))\n\t      write_fatal ();\n\t    outstate->zero_output = false;\n\t}\n\n\tdo\n\t  {\n\t    if (! outstate->after_newline  &&  putc ('\\n', fp) == EOF)\n\t      write_fatal ();\n\t    outstate->after_newline = pch_write_line (new, fp);\n\t    outstate->zero_output = false;\n\t    new++;\n\t  }\n\twhile (new <= pat_end && pch_char (new) == '+');\n    }\n    if (R_do_defines && def_state != OUTSIDE) {\n\tfputs (outstate->after_newline + end_defined, fp);\n\tif (ferror (fp))\n\t  write_fatal ();\n\toutstate->after_newline = true;\n    }\n    out_offset += pch_repl_lines() - pch_ptrn_lines ();\n    return true;\n}",
      "lines": 150,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "create_output_file": {
      "start_point": [
        1564,
        0
      ],
      "end_point": [
        1573,
        1
      ],
      "content": "static FILE *\ncreate_output_file (char const *name, int open_flags)\n{\n  int fd = create_file (name, O_WRONLY | binary_transput | open_flags,\n\t\t\tinstat.st_mode, true);\n  FILE *f = fdopen (fd, binary_transput ? \"wb\" : \"w\");\n  if (! f)\n    pfatal (\"Can't create file %s\", quotearg (name));\n  return f;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\ncreate_output_file (char const *name, int open_flags)",
        "*"
      ]
    },
    "init_output": {
      "start_point": [
        1577,
        0
      ],
      "end_point": [
        1583,
        1
      ],
      "content": "static void\ninit_output (struct outstate *outstate)\n{\n  outstate->ofp = NULL;\n  outstate->after_newline = true;\n  outstate->zero_output = true;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_outfile": {
      "start_point": [
        1585,
        0
      ],
      "end_point": [
        1604,
        1
      ],
      "content": "static FILE *\nopen_outfile (char const *name)\n{\n  if (strcmp (name, \"-\") != 0)\n    return create_output_file (name, 0);\n  else\n    {\n      FILE *ofp;\n      int stdout_dup = dup (fileno (stdout));\n      if (stdout_dup == -1)\n\tpfatal (\"Failed to duplicate standard output\");\n      ofp = fdopen (stdout_dup, \"a\");\n      if (! ofp)\n\tpfatal (\"Failed to duplicate standard output\");\n      if (dup2 (fileno (stderr), fileno (stdout)) == -1)\n\tpfatal (\"Failed to redirect messages to standard error\");\n      /* FIXME: Do we need to switch stdout_dup into O_BINARY mode here? */\n      return ofp;\n    }\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nopen_outfile (char const *name)",
        "*"
      ]
    },
    "init_reject": {
      "start_point": [
        1608,
        0
      ],
      "end_point": [
        1620,
        1
      ],
      "content": "static void\ninit_reject (char const *outname)\n{\n  int fd;\n  fd = make_tempfile (&TMPREJNAME, 'r', outname, O_WRONLY | binary_transput,\n\t\t      0666);\n  if (fd == -1)\n    pfatal (\"Can't create temporary file %s\", TMPREJNAME);\n  TMPREJNAME_needs_removal = true;\n  rejfp = fdopen (fd, binary_transput ? \"wb\" : \"w\");\n  if (! rejfp)\n    pfatal (\"Can't open stream for file %s\", quotearg (TMPREJNAME));\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copy_till": {
      "start_point": [
        1624,
        0
      ],
      "end_point": [
        1651,
        1
      ],
      "content": "bool\ncopy_till (struct outstate *outstate, lin lastline)\n{\n    lin R_last_frozen_line = last_frozen_line;\n    FILE *fp = outstate->ofp;\n    char const *s;\n    size_t size;\n\n    if (R_last_frozen_line > lastline)\n      {\n\tsay (\"misordered hunks! output would be garbled\\n\");\n\treturn false;\n      }\n    while (R_last_frozen_line < lastline)\n      {\n\ts = ifetch (++R_last_frozen_line, false, &size);\n\tif (size)\n\t  {\n\t    if ((! outstate->after_newline  &&  putc ('\\n', fp) == EOF)\n\t\t|| ! fwrite (s, sizeof *s, size, fp))\n\t      write_fatal ();\n\t    outstate->after_newline = s[size - 1] == '\\n';\n\t    outstate->zero_output = false;\n\t  }\n      }\n    last_frozen_line = R_last_frozen_line;\n    return true;\n}",
      "lines": 28,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    },
    "spew_output": {
      "start_point": [
        1655,
        0
      ],
      "end_point": [
        1681,
        1
      ],
      "content": "static bool\nspew_output (struct outstate *outstate, struct stat *st)\n{\n    if (debug & 256)\n      {\n\tchar numbuf0[LINENUM_LENGTH_BOUND + 1];\n\tchar numbuf1[LINENUM_LENGTH_BOUND + 1];\n\tsay (\"il=%s lfl=%s\\n\",\n\t     format_linenum (numbuf0, input_lines),\n\t     format_linenum (numbuf1, last_frozen_line));\n      }\n\n    if (last_frozen_line < input_lines)\n      if (! copy_till (outstate, input_lines))\n\treturn false;\n\n    if (outstate->ofp && ! outfile)\n      {\n\tif (fflush (outstate->ofp) != 0\n\t    || fstat (fileno (outstate->ofp), st) != 0\n\t    || fclose (outstate->ofp) != 0)\n\t  write_fatal ();\n\toutstate->ofp = 0;\n      }\n\n    return true;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "patch_match": {
      "start_point": [
        1685,
        0
      ],
      "end_point": [
        1707,
        1
      ],
      "content": "static bool\npatch_match (lin base, lin offset, lin prefix_fuzz, lin suffix_fuzz)\n{\n    lin pline = 1 + prefix_fuzz;\n    lin iline;\n    lin pat_lines = pch_ptrn_lines () - suffix_fuzz;\n    size_t size;\n    char const *p;\n\n    for (iline=base+offset+prefix_fuzz; pline <= pat_lines; pline++,iline++) {\n\tp = ifetch (iline, offset >= 0, &size);\n\tif (canonicalize_ws) {\n\t    if (!similar(p, size,\n\t\t\t pfetch(pline),\n\t\t\t pch_line_len(pline) ))\n\t\treturn false;\n\t}\n\telse if (size != pch_line_len (pline)\n\t\t || memcmp (p, pfetch (pline), size) != 0)\n\t    return false;\n    }\n    return true;\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_line_endings": {
      "start_point": [
        1711,
        0
      ],
      "end_point": [
        1734,
        1
      ],
      "content": "static bool\ncheck_line_endings (lin where)\n{\n  char const *p;\n  size_t size;\n  bool input_crlf, patch_crlf;\n\n  p = pfetch (1);\n  size = pch_line_len (1);\n  if (! size)\n    return false;\n  patch_crlf = size >= 2 && p[size - 2] == '\\r' && p[size - 1] == '\\n';\n\n  if (! input_lines)\n    return false;\n  if (where > input_lines)\n    where = input_lines;\n  p = ifetch (where, false, &size);\n  if (! size)\n    return false;\n  input_crlf = size >= 2 && p[size - 2] == '\\r' && p[size - 1] == '\\n';\n\n  return patch_crlf != input_crlf;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "similar": {
      "start_point": [
        1738,
        0
      ],
      "end_point": [
        1766,
        1
      ],
      "content": "bool\nsimilar (char const *a, size_t alen, char const *b, size_t blen)\n{\n  /* Ignore presence or absence of trailing newlines.  */\n  alen  -=  alen && a[alen - 1] == '\\n';\n  blen  -=  blen && b[blen - 1] == '\\n';\n\n  for (;;)\n    {\n      if (!blen || (*b == ' ' || *b == '\\t'))\n\t{\n\t  while (blen && (*b == ' ' || *b == '\\t'))\n\t    b++, blen--;\n\t  if (alen)\n\t    {\n\t      if (!(*a == ' ' || *a == '\\t'))\n\t\treturn false;\n\t      do a++, alen--;\n\t      while (alen && (*a == ' ' || *a == '\\t'));\n\t    }\n\t  if (!alen || !blen)\n\t    return alen == blen;\n\t}\n      else if (!alen || *a++ != *b++)\n\treturn false;\n      else\n\talen--, blen--;\n    }\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    },
    "init_files_to_delete": {
      "start_point": [
        1778,
        0
      ],
      "end_point": [
        1782,
        1
      ],
      "content": "static void\ninit_files_to_delete (void)\n{\n  files_to_delete = gl_list_create_empty (GL_LINKED_LIST, NULL, NULL, NULL, true);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delete_file_later": {
      "start_point": [
        1784,
        0
      ],
      "end_point": [
        1802,
        1
      ],
      "content": "static void\ndelete_file_later (const char *name, const struct stat *st, bool backup)\n{\n  struct file_to_delete *file_to_delete;\n  struct stat st_tmp;\n\n  if (! st)\n    {\n      if (stat_file (name, &st_tmp) != 0)\n\tpfatal (\"Can't get file attributes of %s %s\", \"file\", name);\n      st = &st_tmp;\n    }\n  file_to_delete = xmalloc (sizeof *file_to_delete);\n  file_to_delete->name = xstrdup (name);\n  file_to_delete->st = *st;\n  file_to_delete->backup = backup;\n  gl_list_add_last (files_to_delete, file_to_delete);\n  insert_file_id (st, DELETE_LATER);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delete_files": {
      "start_point": [
        1804,
        0
      ],
      "end_point": [
        1829,
        1
      ],
      "content": "static void\ndelete_files (void)\n{\n  gl_list_iterator_t iter;\n  const void *elt;\n\n  iter = gl_list_iterator (files_to_delete);\n  while (gl_list_iterator_next (&iter, &elt, NULL))\n    {\n      const struct file_to_delete *file_to_delete = elt;\n\n      if (lookup_file_id (&file_to_delete->st) == DELETE_LATER)\n\t{\n\t  mode_t mode = file_to_delete->st.st_mode;\n\n\t  if (verbosity == VERBOSE)\n\t    say (\"Removing %s %s\\n\",\n\t\t S_ISLNK (mode) ? \"symbolic link\" : \"file\",\n\t\t quotearg (file_to_delete->name));\n\t  move_file (0, 0, 0, file_to_delete->name, mode,\n\t\t     file_to_delete->backup);\n\t  removedirs (file_to_delete->name);\n\t}\n    }\n  gl_list_iterator_free (&iter);\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_file_later": {
      "start_point": [
        1843,
        0
      ],
      "end_point": [
        1858,
        1
      ],
      "content": "static void\noutput_file_later (char const *from, bool *from_needs_removal, const struct stat *from_st,\n\t\t   char const *to, mode_t mode, bool backup)\n{\n  struct file_to_output *file_to_output;\n\n  file_to_output = xmalloc (sizeof *file_to_output);\n  file_to_output->from = xstrdup (from);\n  file_to_output->from_st = *from_st;\n  file_to_output->to = to ? xstrdup (to) : NULL;\n  file_to_output->mode = mode;\n  file_to_output->backup = backup;\n  gl_list_add_last (files_to_output, file_to_output);\n  if (from_needs_removal)\n    *from_needs_removal = false;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_file_now": {
      "start_point": [
        1860,
        0
      ],
      "end_point": [
        1875,
        1
      ],
      "content": "static void\noutput_file_now (char const *from, bool *from_needs_removal,\n\t\t const struct stat *from_st, char const *to,\n\t\t mode_t mode, bool backup)\n{\n  if (to == NULL)\n    {\n      if (backup)\n\tcreate_backup (from, from_st, true);\n    }\n  else\n    {\n      assert (from_st->st_size != -1);\n      move_file (from, from_needs_removal, from_st, to, mode, backup);\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_file": {
      "start_point": [
        1877,
        0
      ],
      "end_point": [
        1910,
        1
      ],
      "content": "static void\noutput_file (char const *from, bool *from_needs_removal,\n\t     const struct stat *from_st, char const *to,\n\t     const struct stat *to_st, mode_t mode, bool backup)\n{\n  if (from == NULL)\n    {\n      /* Remember which files should be deleted and only delete them when the\n\t entire input to patch has been processed.  This allows to correctly\n\t determine for which files backup files have already been created.  */\n\n      delete_file_later (to, to_st, backup);\n    }\n  else if (pch_git_diff () && pch_says_nonexistent (reverse) != 2)\n    {\n      /* In git-style diffs, the \"before\" state of each patch refers to the initial\n\t state before modifying any files, input files can be referenced more than\n\t once (when creating copies), and output files are modified at most once.\n\t However, the input to GNU patch may consist of multiple concatenated\n\t git-style diffs, which must be processed separately.  (The same output\n\t file may go through multiple revisions.)\n\n\t To implement this, we remember which files to /modify/ instead of\n\t modifying the files immediately, but we create /new/ output files\n\t immediately.  The new output files serve as markers to detect when a\n\t file is modified more than once; this allows to recognize most\n\t concatenated git-style diffs.\n      */\n\n      output_file_later (from, from_needs_removal, from_st, to, mode, backup);\n    }\n  else\n    output_file_now (from, from_needs_removal, from_st, to, mode, backup);\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dispose_file_to_output": {
      "start_point": [
        1912,
        0
      ],
      "end_point": [
        1919,
        1
      ],
      "content": "static void\ndispose_file_to_output (const void *elt)\n{\n  const struct file_to_output *file_to_output = elt;\n\n  free (file_to_output->from);\n  free (file_to_output->to);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_files_to_output": {
      "start_point": [
        1921,
        0
      ],
      "end_point": [
        1926,
        1
      ],
      "content": "static void\ninit_files_to_output (void)\n{\n  files_to_output = gl_list_create_empty (GL_LINKED_LIST, NULL, NULL,\n\t\t\t\t\t  dispose_file_to_output, true);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_list_clear": {
      "start_point": [
        1928,
        0
      ],
      "end_point": [
        1933,
        1
      ],
      "content": "static void\ngl_list_clear (gl_list_t list)\n{\n  while (gl_list_size (list) > 0)\n    gl_list_remove_at (list, 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_files": {
      "start_point": [
        1935,
        0
      ],
      "end_point": [
        1970,
        1
      ],
      "content": "static void\noutput_files (struct stat const *st)\n{\n  gl_list_iterator_t iter;\n  const void *elt;\n\n  iter = gl_list_iterator (files_to_output);\n  while (gl_list_iterator_next (&iter, &elt, NULL))\n    {\n      const struct file_to_output *file_to_output = elt;\n      bool from_needs_removal = true;\n      struct stat const *from_st = &file_to_output->from_st;\n\n      output_file_now (file_to_output->from, &from_needs_removal,\n\t\t       from_st, file_to_output->to,\n\t\t       file_to_output->mode, file_to_output->backup);\n      if (file_to_output->to && from_needs_removal)\n\tsafe_unlink (file_to_output->from);\n\n      if (st && st->st_dev == from_st->st_dev && st->st_ino == from_st->st_ino)\n\t{\n\t  /* Free the list up to here. */\n\t  for (;;)\n\t    {\n\t      const void *elt2 = gl_list_get_at (files_to_output, 0);\n\t      gl_list_remove_at (files_to_output, 0);\n\t      if (elt == elt2)\n\t\tbreak;\n\t    }\n\t  gl_list_iterator_free (&iter);\n\t  return;\n\t}\n    }\n  gl_list_iterator_free (&iter);\n  gl_list_clear (files_to_output);\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fatal_exit": {
      "start_point": [
        1974,
        0
      ],
      "end_point": [
        1983,
        1
      ],
      "content": "void\nfatal_exit (int sig)\n{\n  cleanup ();\n\n  if (sig)\n    exit_with_signal (sig);\n\n  exit (2);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "remove_if_needed": {
      "start_point": [
        1985,
        0
      ],
      "end_point": [
        1993,
        1
      ],
      "content": "static void\nremove_if_needed (char const *name, bool *needs_removal)\n{\n  if (*needs_removal)\n    {\n      safe_unlink (name);\n      *needs_removal = false;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cleanup": {
      "start_point": [
        1995,
        0
      ],
      "end_point": [
        2003,
        1
      ],
      "content": "static void\ncleanup (void)\n{\n  remove_if_needed (TMPINNAME, &TMPINNAME_needs_removal);\n  remove_if_needed (TMPOUTNAME, &TMPOUTNAME_needs_removal);\n  remove_if_needed (TMPPATNAME, &TMPPATNAME_needs_removal);\n  remove_if_needed (TMPREJNAME, &TMPREJNAME_needs_removal);\n  output_files (NULL);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/src/pch.c": {
    "re_patch": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nre_patch (void)\n{\n    p_first = 0;\n    p_newfirst = 0;\n    p_ptrn_lines = 0;\n    p_repl_lines = 0;\n    p_end = -1;\n    p_max = 0;\n    p_indent = 0;\n    p_strip_trailing_cr = false;\n}",
      "lines": 12,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "open_patch_file": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\nopen_patch_file (char const *filename)\n{\n    file_offset file_pos = 0;\n    file_offset pos;\n    struct stat st;\n\n    if (!filename || !*filename || strEQ (filename, \"-\"))\n      pfp = stdin;\n    else\n      {\n\tpfp = fopen (filename, binary_transput ? \"rb\" : \"r\");\n\tif (!pfp)\n\t  pfatal (\"Can't open patch file %s\", quotearg (filename));\n      }\n#if HAVE_SETMODE_DOS\n    if (binary_transput)\n      {\n\tif (isatty (fileno (pfp)))\n\t  fatal (\"cannot read binary data from tty on this platform\");\n\tsetmode (fileno (pfp), O_BINARY);\n      }\n#endif\n    if (fstat (fileno (pfp), &st) != 0)\n      pfatal (\"fstat\");\n    if (S_ISREG (st.st_mode) && (pos = file_tell (pfp)) != -1)\n      file_pos = pos;\n    else\n      {\n\tsize_t charsread;\n\tint fd;\n\tFILE *read_pfp = pfp;\n\tfd = make_tempfile (&TMPPATNAME, 'p', NULL, O_RDWR | O_BINARY, 0);\n\tif (fd == -1)\n\t  pfatal (\"Can't create temporary file %s\", TMPPATNAME);\n\tTMPPATNAME_needs_removal = true;\n\tpfp = fdopen (fd, \"w+b\");\n\tif (! pfp)\n\t  pfatal (\"Can't open stream for file %s\", quotearg (TMPPATNAME));\n\tfor (st.st_size = 0;\n\t     (charsread = fread (buf, 1, bufsize, read_pfp)) != 0;\n\t     st.st_size += charsread)\n\t  if (fwrite (buf, 1, charsread, pfp) != charsread)\n\t    write_fatal ();\n\tif (ferror (read_pfp) || fclose (read_pfp) != 0)\n\t  read_fatal ();\n\tif (fflush (pfp) != 0\n\t    || file_seek (pfp, (file_offset) 0, SEEK_SET) != 0)\n\t  write_fatal ();\n      }\n    p_filesize = st.st_size;\n    if (p_filesize != (file_offset) p_filesize)\n      fatal (\"patch file is too long\");\n    next_intuit_at (file_pos, 1);\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "set_hunkmax": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static void\nset_hunkmax (void)\n{\n    if (!p_line)\n\tp_line = xmalloc (hunkmax * sizeof *p_line);\n    if (!p_len)\n\tp_len = xmalloc (hunkmax * sizeof *p_len);\n    if (!p_Char)\n\tp_Char = xmalloc (hunkmax * sizeof *p_Char);\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grow_hunkmax": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static bool\ngrow_hunkmax (void)\n{\n    hunkmax *= 2;\n    assert (p_line && p_len && p_Char);\n    if ((p_line = realloc (p_line, hunkmax * sizeof (*p_line)))\n\t&& (p_len = realloc (p_len, hunkmax * sizeof (*p_len)))\n\t&& (p_Char = realloc (p_Char, hunkmax * sizeof (*p_Char))))\n      return true;\n    if (!using_plan_a)\n      xalloc_die ();\n    /* Don't free previous values of p_line etc.,\n       since some broken implementations free them for us.\n       Whatever is null will be allocated again from within plan_a (),\n       of all places.  */\n    return false;\n}",
      "lines": 17,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "maybe_reverse": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static bool\nmaybe_reverse (char const *name, bool nonexistent, bool is_empty)\n{\n  bool looks_reversed = (! is_empty) < p_says_nonexistent[reverse ^ is_empty];\n\n  /* Allow to create and delete empty files when we know that they are empty:\n     in the \"diff --git\" format, we know that from the index header.  */\n  if (is_empty\n      && p_says_nonexistent[reverse ^ nonexistent] == 1\n      && p_says_nonexistent[! reverse ^ nonexistent] == 2)\n    return false;\n\n  if (looks_reversed)\n    reverse ^=\n      ok_to_reverse (\"The next patch%s would %s the file %s,\\nwhich %s!\",\n\t\t     reverse ? \", when reversed,\" : \"\",\n\t\t     (nonexistent ? \"delete\"\n\t\t      : is_empty ? \"empty out\"\n\t\t      : \"create\"),\n\t\t     quotearg (name),\n\t\t     (nonexistent ? \"does not exist\"\n\t\t      : is_empty ? \"is already empty\"\n\t\t      : \"already exists\"));\n  return looks_reversed;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "there_is_another_patch": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "bool\nthere_is_another_patch (bool need_header, mode_t *file_type)\n{\n    if (p_base != 0 && p_base >= p_filesize) {\n\tif (verbosity == VERBOSE)\n\t    say (\"done\\n\");\n\treturn false;\n    }\n    if (verbosity == VERBOSE)\n\tsay (\"Hmm...\");\n    diff_type = intuit_diff_type (need_header, file_type);\n    if (diff_type == NO_DIFF) {\n\tif (verbosity == VERBOSE)\n\t  say (p_base\n\t       ? \"  Ignoring the trailing garbage.\\ndone\\n\"\n\t       : \"  I can't seem to find a patch in there anywhere.\\n\");\n\tif (! p_base && p_filesize)\n\t  fatal (\"Only garbage was found in the patch input.\");\n\treturn false;\n    }\n    if (skip_rest_of_patch)\n      {\n\tFseek (pfp, p_start, SEEK_SET);\n\tp_input_line = p_sline - 1;\n\treturn true;\n      }\n    if (verbosity == VERBOSE)\n\tsay (\"  %sooks like %s to me...\\n\",\n\t    (p_base == 0 ? \"L\" : \"The next patch l\"),\n\t    diff_type == UNI_DIFF ? \"a unified diff\" :\n\t    diff_type == CONTEXT_DIFF ? \"a context diff\" :\n\t    diff_type == NEW_CONTEXT_DIFF ? \"a new-style context diff\" :\n\t    diff_type == NORMAL_DIFF ? \"a normal diff\" :\n\t    diff_type == GIT_BINARY_DIFF ? \"a git binary diff\" :\n\t    \"an ed script\" );\n\n    if (no_strip_trailing_cr)\n      p_strip_trailing_cr = false;\n\n    if (verbosity != SILENT)\n      {\n\tif (p_indent)\n\t  say (\"(Patch is indented %lu space%s.)\\n\",\n\t       (unsigned long int) p_indent, p_indent==1?\"\":\"s\");\n\tif (p_strip_trailing_cr)\n\t  say (\"(Stripping trailing CRs from patch; use --binary to disable.)\\n\");\n\tif (! inname)\n\t  {\n\t    char numbuf[LINENUM_LENGTH_BOUND + 1];\n\t    say (\"can't find file to patch at input line %s\\n\",\n\t\t format_linenum (numbuf, p_sline));\n\t    if (diff_type != ED_DIFF && diff_type != NORMAL_DIFF)\n\t      say (strippath == -1\n\t\t   ? \"Perhaps you should have used the -p or --strip option?\\n\"\n\t\t   : \"Perhaps you used the wrong -p or --strip option?\\n\");\n\t  }\n      }\n\n    skip_to(p_start,p_sline);\n    while (!inname) {\n\tchar *t;\n\tif (force | batch) {\n\t    say (\"No file to patch.  Skipping patch.\\n\");\n\t    skip_rest_of_patch = true;\n\t    return true;\n\t}\n\task (\"File to patch: \");\n\tt = buf + strlen (buf);\n\tif (t > buf + 1 && *(t - 1) == '\\n')\n\t  {\n\t    inname = xmemdup0 (buf, t - buf - 1);\n\t    inerrno = stat_file (inname, &instat);\n\t    if (inerrno)\n\t      {\n\t\tperror (inname);\n\t\tfflush (stderr);\n\t\tfree (inname);\n\t\tinname = 0;\n\t      }\n\t    else\n\t      invc = -1;\n\t  }\n\tif (!inname) {\n\t    ask (\"Skip this patch? [y] \");\n\t    if (*buf != 'n') {\n\t\tif (verbosity != SILENT)\n\t\t    say (\"Skipping patch.\\n\");\n\t\tskip_rest_of_patch = true;\n\t\treturn true;\n\t    }\n\t}\n    }\n    return true;\n}",
      "lines": 94,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "_GL_ATTRIBUTE_PURE": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "static mode_t _GL_ATTRIBUTE_PURE\nfetchmode (char const *str)\n{\n   const char *s;\n   mode_t mode;\n\n   while (ISSPACE ((unsigned char) *str))\n     str++;\n\n   for (s = str, mode = 0; s < str + 6; s++)\n     {\n       if (*s >= '0' && *s <= '7')\n\tmode = (mode << 3) + (*s - '0');\n       else\n\t{\n\t mode = 0;\n\t break;\n\t}\n     }\n   if (*s == '\\r')\n     s++;\n   if (*s != '\\n')\n     mode = 0;\n\n    /* NOTE: The \"diff --git\" format always sets the file mode permission\n       bits of symlinks to 0.  (On Linux, symlinks actually always have\n       0777 permissions, so this is not even consistent.)  */\n\n   return mode;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mode_t"
      ]
    },
    "get_sha1": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "static void\nget_sha1(char **sha1, char const *start, char const *end)\n{\n  unsigned int len = end - start;\n  *sha1 = xmalloc (len + 1);\n  memcpy (*sha1, start, len);\n  (*sha1)[len] = 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sha1_says_nonexistent": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static int _GL_ATTRIBUTE_PURE\nsha1_says_nonexistent(char const *sha1)\n{\n  char const *empty_sha1 = \"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391\";\n  char const *s;\n\n  /* Nonexisting files have an all-zero checksum.  */\n  for (s = sha1; *s; s++)\n    if (*s != '0')\n      break;\n  if (! *s)\n    return 2;\n\n  /* Empty files have empty_sha1 as their checksum.  */\n  for (s = sha1; *s; s++, empty_sha1++)\n    if (*s != *empty_sha1)\n      break;\n  return ! *s;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "skip_hex_digits": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "static char const * _GL_ATTRIBUTE_PURE\nskip_hex_digits (char const *str)\n{\n  char const *s;\n\n  for (s = str; (*s >= '0' && *s <= '9') || (*s >= 'a' && *s <= 'f'); s++)\n    /* do nothing */ ;\n  return s == str ? NULL : s;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nskip_hex_digits (char const *str)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "name_is_valid": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "static bool\nname_is_valid (char const *name)\n{\n  int i;\n  bool is_valid = true;\n\n  for (i = 0; i < ARRAY_SIZE (invalid_names); i++)\n    {\n      if (! invalid_names[i])\n\tbreak;\n      if (! strcmp (invalid_names[i], name))\n\treturn false;\n    }\n\n  is_valid = filename_is_safe (name);\n\n  /* Allow any filename if we are in the filesystem root.  */\n  if (! is_valid && cwd_is_root (name))\n    is_valid = true;\n\n  if (! is_valid)\n    {\n      say (\"Ignoring potentially dangerous file name %s\\n\", quotearg (name));\n      if (i < ARRAY_SIZE (invalid_names))\n\tinvalid_names[i] = name;\n    }\n  return is_valid;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "intuit_diff_type": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "static enum diff\nintuit_diff_type (bool need_header, mode_t *p_file_type)\n{\n    file_offset this_line = 0;\n    file_offset first_command_line = -1;\n    char first_ed_command_letter = 0;\n    lin fcl_line = 0; /* Pacify 'gcc -W'.  */\n    bool this_is_a_command = false;\n    bool stars_this_line = false;\n    bool extended_headers = false;\n    enum nametype i;\n    struct stat st[3];\n    int stat_errno[3];\n    int version_controlled[3];\n    enum diff retval;\n    mode_t file_type;\n    size_t indent = 0;\n\n    for (i = OLD;  i <= INDEX;  i++)\n      if (p_name[i]) {\n\t  free (p_name[i]);\n\t  p_name[i] = 0;\n        }\n    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)\n\tinvalid_names[i] = NULL;\n    for (i = OLD; i <= NEW; i++)\n      if (p_timestr[i])\n\t{\n\t  free(p_timestr[i]);\n\t  p_timestr[i] = 0;\n\t}\n    for (i = OLD; i <= NEW; i++)\n      if (p_sha1[i])\n\t{\n\t  free (p_sha1[i]);\n\t  p_sha1[i] = 0;\n\t}\n    p_git_diff = false;\n    for (i = OLD; i <= NEW; i++)\n      {\n\tp_mode[i] = 0;\n\tp_copy[i] = false;\n\tp_rename[i] = false;\n      }\n\n    /* Ed and normal format patches don't have filename headers.  */\n    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)\n      need_header = false;\n\n    version_controlled[OLD] = -1;\n    version_controlled[NEW] = -1;\n    version_controlled[INDEX] = -1;\n    p_rfc934_nesting = 0;\n    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;\n    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;\n    Fseek (pfp, p_base, SEEK_SET);\n    p_input_line = p_bline - 1;\n    for (;;) {\n\tchar *s;\n\tchar *t;\n\tfile_offset previous_line = this_line;\n\tbool last_line_was_command = this_is_a_command;\n\tbool stars_last_line = stars_this_line;\n\tsize_t indent_last_line = indent;\n\tchar ed_command_letter;\n\tbool strip_trailing_cr;\n\tsize_t chars_read;\n\n\tindent = 0;\n\tthis_line = file_tell (pfp);\n\tchars_read = pget_line (0, 0, false, false);\n\tif (chars_read == (size_t) -1)\n\t  xalloc_die ();\n\tif (! chars_read) {\n\t    if (first_ed_command_letter) {\n\t\t\t\t\t/* nothing but deletes!? */\n\t\tp_start = first_command_line;\n\t\tp_sline = fcl_line;\n\t\tretval = ED_DIFF;\n\t\tgoto scan_exit;\n\t    }\n\t    else {\n\t\tp_start = this_line;\n\t\tp_sline = p_input_line;\n\t\tif (extended_headers)\n\t\t  {\n\t\t    /* Patch contains no hunks; any diff type will do. */\n\t\t    retval = UNI_DIFF;\n\t\t    goto scan_exit;\n\t\t  }\n\t\treturn NO_DIFF;\n\t    }\n\t}\n\tstrip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\\r';\n\tfor (s = buf; *s == ' ' || *s == '\\t' || *s == 'X'; s++) {\n\t    if (*s == '\\t')\n\t\tindent = (indent + 8) & ~7;\n\t    else\n\t\tindent++;\n\t}\n\tif (ISDIGIT (*s))\n\t  {\n\t    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)\n\t      /* do nothing */ ;\n\t    if (*t == 'd' || *t == 'c' || *t == 'a')\n\t      {\n\t\tfor (t++;  ISDIGIT (*t) || *t == ',';  t++)\n\t\t  /* do nothing */ ;\n\t\tfor (; *t == ' ' || *t == '\\t'; t++)\n\t\t  /* do nothing */ ;\n\t\tif (*t == '\\r')\n\t\t  t++;\n\t\tthis_is_a_command = (*t == '\\n');\n\t      }\n\t  }\n\tif (! need_header\n\t    && first_command_line < 0\n\t    && ((ed_command_letter = get_ed_command_letter (s))\n\t\t|| this_is_a_command)) {\n\t    first_command_line = this_line;\n\t    first_ed_command_letter = ed_command_letter;\n\t    fcl_line = p_input_line;\n\t    p_indent = indent;\t\t/* assume this for now */\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t}\n\tif (!stars_last_line && strnEQ(s, \"*** \", 4))\n\t  {\n\t    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header = false;\n\t  }\n\telse if (strnEQ(s, \"+++ \", 4))\n\t  {\n\t    /* Swap with NEW below.  */\n\t    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header = false;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t  }\n\telse if (strnEQ(s, \"Index:\", 6))\n\t  {\n\t    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);\n\t    need_header = false;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t  }\n\telse if (strnEQ(s, \"Prereq:\", 7))\n\t  {\n\t    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)\n\t      /* do nothing */ ;\n\t    revision = t;\n\t    for (t = revision;  *t;  t++)\n\t      if (ISSPACE ((unsigned char) *t))\n\t\t{\n\t\t  char const *u;\n\t\t  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)\n\t\t    /* do nothing */ ;\n\t\t  if (*u)\n\t\t    {\n\t\t      char numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\t      say (\"Prereq: with multiple words at line %s of patch\\n\",\n\t\t\t   format_linenum (numbuf, this_line));\n\t\t    }\n\t\t  break;\n\t\t}\n\t    if (t == revision)\n\t\trevision = 0;\n\t    else {\n\t\tchar oldc = *t;\n\t\t*t = '\\0';\n\t\trevision = xstrdup (revision);\n\t\t*t = oldc;\n\t    }\n\t  }\n\telse if (strnEQ (s, \"diff --git \", 11))\n\t  {\n\t    char const *u;\n\n\t    if (extended_headers)\n\t      {\n\t\tp_start = this_line;\n\t\tp_sline = p_input_line;\n\t\t/* Patch contains no hunks; any diff type will do. */\n\t\tretval = UNI_DIFF;\n\t\tgoto scan_exit;\n\t      }\n\n\t    for (i = OLD; i <= NEW; i++)\n\t      {\n\t\tfree (p_name[i]);\n\t\tp_name[i] = 0;\n\t      }\n\t    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))\n\t\t   && ISSPACE ((unsigned char) *u)\n\t\t   && (p_name[NEW] = parse_name (u, strippath, &u))\n\t\t   && (u = skip_spaces (u), ! *u)))\n\t      for (i = OLD; i <= NEW; i++)\n\t\t{\n\t\t  free (p_name[i]);\n\t\t  p_name[i] = 0;\n\t\t}\n\t    p_git_diff = true;\n\t    need_header = false;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"index \", 6))\n\t  {\n\t    char const *u, *v;\n\t    if ((u = skip_hex_digits (s + 6))\n\t\t&& u[0] == '.' && u[1] == '.'\n\t\t&& (v = skip_hex_digits (u + 2))\n\t\t&& (! *v || ISSPACE ((unsigned char) *v)))\n\t      {\n\t\tget_sha1(&p_sha1[OLD], s + 6, u);\n\t\tget_sha1(&p_sha1[NEW], u + 2, v);\n\t\tp_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);\n\t\tp_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);\n\t\tif (*(v = skip_spaces (v)))\n\t\t  p_mode[OLD] = p_mode[NEW] = fetchmode (v);\n\t\textended_headers = true;\n\t      }\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"old mode \", 9))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 9);\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"new mode \", 9))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 9);\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"deleted file mode \", 18))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 18);\n\t    p_says_nonexistent[NEW] = 2;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"new file mode \", 14))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 14);\n\t    p_says_nonexistent[OLD] = 2;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"rename from \", 12))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_rename[OLD] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"rename to \", 10))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_rename[NEW] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"copy from \", 10))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_copy[OLD] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"copy to \", 8))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_copy[NEW] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"GIT binary patch\", 16))\n\t  {\n\t    p_start = this_line;\n\t    p_sline = p_input_line;\n\t    retval = GIT_BINARY_DIFF;\n\t    goto scan_exit;\n\t  }\n\telse\n\t  {\n\t    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)\n\t      /* do nothing */ ;\n\t    if (strnEQ(t, \"--- \", 4))\n\t      {\n\t\tstruct timespec timestamp;\n\t\ttimestamp.tv_sec = -1;\n\t\tfetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],\n\t\t\t   &timestamp);\n\t\tneed_header = false;\n\t\tif (timestamp.tv_sec != -1)\n\t\t  {\n\t\t    p_timestamp[NEW] = timestamp;\n\t\t    p_rfc934_nesting = (t - s) >> 1;\n\t\t  }\n\t\tp_strip_trailing_cr = strip_trailing_cr;\n\t      }\n\t  }\n\tif (need_header)\n\t  continue;\n\tif ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&\n\t  first_command_line >= 0 &&\n\t  strEQ(s, \".\\n\") ) {\n\t    p_start = first_command_line;\n\t    p_sline = fcl_line;\n\t    retval = ED_DIFF;\n\t    goto scan_exit;\n\t}\n\tif ((diff_type == NO_DIFF || diff_type == UNI_DIFF)\n\t    && strnEQ(s, \"@@ -\", 4)) {\n\n\t    /* 'p_name', 'p_timestr', and 'p_timestamp' are backwards;\n\t       swap them.  */\n\t    struct timespec ti = p_timestamp[OLD];\n\t    p_timestamp[OLD] = p_timestamp[NEW];\n\t    p_timestamp[NEW] = ti;\n\t    t = p_name[OLD];\n\t    p_name[OLD] = p_name[NEW];\n\t    p_name[NEW] = t;\n\t    t = p_timestr[OLD];\n\t    p_timestr[OLD] = p_timestr[NEW];\n\t    p_timestr[NEW] = t;\n\n\t    s += 4;\n\t    if (s[0] == '0' && !ISDIGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    while (*s != ' ' && *s != '\\n')\n\t      s++;\n\t    while (*s == ' ')\n\t      s++;\n\t    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))\n\t      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t    p_indent = indent;\n\t    p_start = this_line;\n\t    p_sline = p_input_line;\n\t    retval = UNI_DIFF;\n\t    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)\n\t      {\n\t\tchar numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\tsay (\"missing header for unified diff at line %s of patch\\n\",\n\t\t     format_linenum (numbuf, p_sline));\n\t      }\n\t    goto scan_exit;\n\t}\n\tstars_this_line = strnEQ(s, \"********\", 8);\n\tif ((diff_type == NO_DIFF\n\t     || diff_type == CONTEXT_DIFF\n\t     || diff_type == NEW_CONTEXT_DIFF)\n\t    && stars_last_line && indent_last_line == indent\n\t    && strnEQ (s, \"*** \", 4)) {\n\t    s += 4;\n\t    if (s[0] == '0' && !ISDIGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    /* if this is a new context diff the character just before */\n\t    /* the newline is a '*'. */\n\t    while (*s != '\\n')\n\t\ts++;\n\t    p_indent = indent;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t    p_start = previous_line;\n\t    p_sline = p_input_line - 1;\n\t    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);\n\n\t    {\n\t      /* Scan the first hunk to see whether the file contents\n\t\t appear to have been deleted.  */\n\t      file_offset saved_p_base = p_base;\n\t      lin saved_p_bline = p_bline;\n\t      Fseek (pfp, previous_line, SEEK_SET);\n\t      p_input_line -= 2;\n\t      if (another_hunk (retval, false)\n\t\t  && ! p_repl_lines && p_newfirst == 1)\n\t\tp_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t      next_intuit_at (saved_p_base, saved_p_bline);\n\t    }\n\n\t    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)\n\t      {\n\t\tchar numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\tsay (\"missing header for context diff at line %s of patch\\n\",\n\t\t     format_linenum (numbuf, p_sline));\n\t      }\n\t    goto scan_exit;\n\t}\n\tif ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&\n\t  last_line_was_command &&\n\t  (strnEQ(s, \"< \", 2) || strnEQ(s, \"> \", 2)) ) {\n\t    p_start = previous_line;\n\t    p_sline = p_input_line - 1;\n\t    p_indent = indent;\n\t    retval = NORMAL_DIFF;\n\t    goto scan_exit;\n\t}\n    }\n\n  scan_exit:\n\n    /* The old, new, or old and new file types may be defined.  When both\n       file types are defined, make sure they are the same, or else assume\n       we do not know the file type.  */\n    file_type = p_mode[OLD] & S_IFMT;\n    if (file_type)\n      {\n\tmode_t new_file_type = p_mode[NEW] & S_IFMT;\n\tif (new_file_type && file_type != new_file_type)\n\t  file_type = 0;\n      }\n    else\n      {\n\tfile_type = p_mode[NEW] & S_IFMT;\n\tif (! file_type)\n\t  file_type = S_IFREG;\n      }\n    *p_file_type = file_type;\n\n    /* To intuit 'inname', the name of the file to patch,\n       use the algorithm specified by POSIX 1003.1-2001 XCU lines 25680-26599\n       (with some modifications if posixly_correct is zero):\n\n       - Take the old and new names from the context header if present,\n\t and take the index name from the 'Index:' line if present and\n\t if either the old and new names are both absent\n\t or posixly_correct is nonzero.\n\t Consider the file names to be in the order (old, new, index).\n       - If some named files exist, use the first one if posixly_correct\n\t is nonzero, the best one otherwise.\n       - If patch_get is nonzero, and no named files exist,\n\t but an RCS or SCCS master file exists,\n\t use the first named file with an RCS or SCCS master.\n       - If no named files exist, no RCS or SCCS master was found,\n\t some names are given, posixly_correct is zero,\n\t and the patch appears to create a file, then use the best name\n\t requiring the creation of the fewest directories.\n       - Otherwise, report failure by setting 'inname' to 0;\n\t this causes our invoker to ask the user for a file name.  */\n\n    i = NONE;\n\n    if (!inname)\n      {\n\tenum nametype i0 = NONE;\n\n\tif (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])\n\t  {\n\t    free (p_name[INDEX]);\n\t    p_name[INDEX] = 0;\n\t  }\n\n\tfor (i = OLD;  i <= INDEX;  i++)\n\t  if (p_name[i])\n\t    {\n\t      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)\n\t\t{\n\t\t  /* It's the same name as before; reuse stat results.  */\n\t\t  stat_errno[i] = stat_errno[i0];\n\t\t  if (! stat_errno[i])\n\t\t    st[i] = st[i0];\n\t\t}\n\t      else\n\t\t{\n\t\t  stat_errno[i] = stat_file (p_name[i], &st[i]);\n\t\t  if (! stat_errno[i])\n\t\t    {\n\t\t      if (lookup_file_id (&st[i]) == DELETE_LATER)\n\t\t\tstat_errno[i] = ENOENT;\n\t\t      else if (posixly_correct && name_is_valid (p_name[i]))\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t      i0 = i;\n\t    }\n\n\tif (! posixly_correct)\n\t  {\n\t    /* The best of all existing files. */\n\t    i = best_name (p_name, stat_errno);\n\n\t    if (i == NONE && patch_get)\n\t      {\n\t\tenum nametype nope = NONE;\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      char const *cs;\n\t\t      char *getbuf;\n\t\t      char *diffbuf;\n\t\t      bool readonly = (outfile\n\t\t\t\t       && strcmp (outfile, p_name[i]) != 0);\n\n\t\t      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)\n\t\t\t{\n\t\t\t  cs = (version_controller\n\t\t\t        (p_name[i], readonly, (struct stat *) 0,\n\t\t\t\t &getbuf, &diffbuf));\n\t\t\t  version_controlled[i] = !! cs;\n\t\t\t  if (cs)\n\t\t\t    {\n\t\t\t      if (version_get (p_name[i], cs, false, readonly,\n\t\t\t\t\t       getbuf, &st[i]))\n\t\t\t\tstat_errno[i] = 0;\n\t\t\t      else\n\t\t\t\tversion_controlled[i] = 0;\n\n\t\t\t      free (getbuf);\n\t\t\t      free (diffbuf);\n\n\t\t\t      if (! stat_errno[i])\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t      nope = i;\n\t\t    }\n\t      }\n\n\t    if (i0 != NONE\n\t\t&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)\n\t\t&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,\n\t\t\t\t  i == NONE || st[i].st_size == 0)\n\t\t&& i == NONE)\n\t      i = i0;\n\n\t    if (i == NONE && p_says_nonexistent[reverse])\n\t      {\n\t\tint newdirs[3];\n\t\tint newdirs_min = INT_MAX;\n\t\tint distance_from_minimum[3];\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      newdirs[i] = (prefix_components (p_name[i], false)\n\t\t\t\t    - prefix_components (p_name[i], true));\n\t\t      if (newdirs[i] < newdirs_min)\n\t\t\tnewdirs_min = newdirs[i];\n\t\t    }\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    distance_from_minimum[i] = newdirs[i] - newdirs_min;\n\n\t\t/* The best of the filenames which create the fewest directories. */\n\t\ti = best_name (p_name, distance_from_minimum);\n\t      }\n\t  }\n      }\n\n    if ((pch_rename () || pch_copy ())\n\t&& ! inname\n\t&& ! ((i == OLD || i == NEW) &&\n\t      p_name[! reverse] &&\n\t      name_is_valid (p_name[! reverse])))\n      {\n\tsay (\"Cannot %s file without two valid file names\\n\", pch_rename () ? \"rename\" : \"copy\");\n\tskip_rest_of_patch = true;\n      }\n\n    if (i == NONE)\n      {\n\tif (inname)\n\t  {\n\t    inerrno = stat_file (inname, &instat);\n\t    if (inerrno || (instat.st_mode & S_IFMT) == file_type)\n\t      maybe_reverse (inname, inerrno, inerrno || instat.st_size == 0);\n\t  }\n\telse\n          inerrno = -1;\n      }\n    else\n      {\n\tinname = xstrdup (p_name[i]);\n\tinerrno = stat_errno[i];\n\tinvc = version_controlled[i];\n\tinstat = st[i];\n      }\n\n    return retval;\n}",
      "lines": 581,
      "depth": 30,
      "decorators": [
        "static",
        "static",
        "enum diff",
        "enum",
        "diff"
      ]
    },
    "prefix_components": {
      "start_point": [
        1007,
        0
      ],
      "end_point": [
        1032,
        1
      ],
      "content": "static int\nprefix_components (char *filename, bool checkdirs)\n{\n  int count = 0;\n  struct stat stat_buf;\n  int stat_result;\n  char *f = filename + FILE_SYSTEM_PREFIX_LEN (filename);\n\n  if (*f)\n    while (*++f)\n      if (ISSLASH (f[0]) && ! ISSLASH (f[-1]))\n\t{\n\t  if (checkdirs)\n\t    {\n\t      *f = '\\0';\n\t      stat_result = safe_stat (filename, &stat_buf);\n\t      *f = '/';\n\t      if (! (stat_result == 0 && S_ISDIR (stat_buf.st_mode)))\n\t\tbreak;\n\t    }\n\n\t  count++;\n\t}\n\n  return count;\n}",
      "lines": 26,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "best_name": {
      "start_point": [
        1037,
        0
      ],
      "end_point": [
        1080,
        1
      ],
      "content": "static enum nametype\nbest_name (char *const *name, int const *ignore)\n{\n  enum nametype i;\n  int components[3];\n  int components_min = INT_MAX;\n  size_t basename_len[3];\n  size_t basename_len_min = SIZE_MAX;\n  size_t len[3];\n  size_t len_min = SIZE_MAX;\n\n  for (i = OLD;  i <= INDEX;  i++)\n    if (name[i] && !ignore[i])\n      {\n\t/* Take the names with the fewest prefix components.  */\n\tcomponents[i] = prefix_components (name[i], false);\n\tif (components_min < components[i])\n\t  continue;\n\tcomponents_min = components[i];\n\n\t/* Of those, take the names with the shortest basename.  */\n\tbasename_len[i] = base_len (name[i]);\n\tif (basename_len_min < basename_len[i])\n\t  continue;\n\tbasename_len_min = basename_len[i];\n\n\t/* Of those, take the shortest names.  */\n\tlen[i] = strlen (name[i]);\n\tif (len_min < len[i])\n\t  continue;\n\tlen_min = len[i];\n      }\n\n  /* Of those, take the first name.  */\n  for (i = OLD;  i <= INDEX;  i++)\n    if (name[i] && !ignore[i]\n\t&& name_is_valid (name[i])\n\t&& components[i] == components_min\n\t&& basename_len[i] == basename_len_min\n\t&& len[i] == len_min)\n      break;\n\n  return i;\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "enum nametype",
        "enum",
        "nametype"
      ]
    },
    "next_intuit_at": {
      "start_point": [
        1084,
        0
      ],
      "end_point": [
        1089,
        1
      ],
      "content": "static void\nnext_intuit_at (file_offset file_pos, lin file_line)\n{\n    p_base = file_pos;\n    p_bline = file_line;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "skip_to": {
      "start_point": [
        1093,
        0
      ],
      "end_point": [
        1122,
        1
      ],
      "content": "static void\nskip_to (file_offset file_pos, lin file_line)\n{\n    FILE *i = pfp;\n    FILE *o = stdout;\n    int c;\n\n    assert(p_base <= file_pos);\n    if ((verbosity == VERBOSE || !inname) && p_base < file_pos) {\n\tFseek (i, p_base, SEEK_SET);\n\tsay (\"The text leading up to this was:\\n--------------------------\\n\");\n\n\twhile (file_tell (i) < file_pos)\n\t  {\n\t    putc ('|', o);\n\t    do\n\t      {\n\t\tif ((c = getc (i)) == EOF)\n\t\t  read_fatal ();\n\t\tputc (c, o);\n\t      }\n\t    while (c != '\\n');\n\t  }\n\n\tsay (\"--------------------------\\n\");\n    }\n    else\n\tFseek (i, file_pos, SEEK_SET);\n    p_input_line = file_line - 1;\n}",
      "lines": 30,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "malformed": {
      "start_point": [
        1125,
        0
      ],
      "end_point": [
        1132,
        1
      ],
      "content": "static void\nmalformed (void)\n{\n    char numbuf[LINENUM_LENGTH_BOUND + 1];\n    fatal (\"malformed patch at line %s: %s\",\n\t   format_linenum (numbuf, p_input_line), buf);\n\t\t/* about as informative as \"Syntax error\" in C */\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "scan_linenum": {
      "start_point": [
        1136,
        0
      ],
      "end_point": [
        1161,
        1
      ],
      "content": "static char *\nscan_linenum (char *s0, lin *linenum)\n{\n  char *s;\n  lin n = 0;\n  bool overflow = false;\n  char numbuf[LINENUM_LENGTH_BOUND + 1];\n\n  for (s = s0;  ISDIGIT (*s);  s++)\n    {\n      lin new_n = 10 * n + (*s - '0');\n      overflow |= new_n / 10 != n;\n      n = new_n;\n    }\n\n  if (s == s0)\n    fatal (\"missing line number at line %s: %s\",\n\t   format_linenum (numbuf, p_input_line), buf);\n\n  if (overflow)\n    fatal (\"line number %.*s is too large at line %s: %s\",\n\t   (int) (s - s0), s0, format_linenum (numbuf, p_input_line), buf);\n\n  *linenum = n;\n  return s;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscan_linenum (char *s0, lin *linenum)",
        "*"
      ]
    },
    "another_hunk": {
      "start_point": [
        1166,
        0
      ],
      "end_point": [
        1937,
        1
      ],
      "content": "int\nanother_hunk (enum diff difftype, bool rev)\n{\n    char *s;\n    lin context = 0;\n    size_t chars_read;\n    char numbuf0[LINENUM_LENGTH_BOUND + 1];\n    char numbuf1[LINENUM_LENGTH_BOUND + 1];\n    char numbuf2[LINENUM_LENGTH_BOUND + 1];\n    char numbuf3[LINENUM_LENGTH_BOUND + 1];\n\n    set_hunkmax();\n\n    while (p_end >= 0) {\n\tif (p_end == p_efake)\n\t    p_end = p_bfake;\t\t/* don't free twice */\n\telse\n\t    free(p_line[p_end]);\n\tp_end--;\n    }\n    assert(p_end == -1);\n    p_efake = -1;\n\n    if (p_c_function)\n      {\n\tfree (p_c_function);\n\tp_c_function = NULL;\n      }\n\n    p_max = hunkmax;\t\t\t/* gets reduced when --- found */\n    if (difftype == CONTEXT_DIFF || difftype == NEW_CONTEXT_DIFF) {\n\tfile_offset line_beginning = file_tell (pfp);\n\t\t\t\t\t/* file pos of the current line */\n\tlin repl_beginning = 0;\t\t/* index of --- line */\n\tlin fillcnt = 0;\t/* #lines of missing ptrn or repl */\n\tlin fillsrc;\t\t/* index of first line to copy */\n\tlin filldst;\t\t/* index of first missing line */\n\tbool ptrn_spaces_eaten = false;\t/* ptrn was slightly misformed */\n\tbool some_context = false;\t/* (perhaps internal) context seen */\n\tbool repl_could_be_missing = true;\n\tbool ptrn_missing = false;\t/* The pattern was missing.  */\n\tbool repl_missing = false;\t/* Likewise for replacement.  */\n\tfile_offset repl_backtrack_position = 0;\n\t\t\t\t\t/* file pos of first repl line */\n\tlin repl_patch_line;\t\t/* input line number for same */\n\tlin repl_context;\t\t/* context for same */\n\tlin ptrn_prefix_context = -1;\t/* lines in pattern prefix context */\n\tlin ptrn_suffix_context = -1;\t/* lines in pattern suffix context */\n\tlin repl_prefix_context = -1;\t/* lines in replac. prefix context */\n\tlin ptrn_copiable = 0;\t\t/* # of copiable lines in ptrn */\n\tlin repl_copiable = 0;\t\t/* Likewise for replacement.  */\n\n\t/* Pacify 'gcc -Wall'.  */\n\tfillsrc = filldst = repl_patch_line = repl_context = 0;\n\n\tchars_read = get_line ();\n\tif (chars_read == (size_t) -1\n\t    || chars_read <= 8\n\t    || strncmp (buf, \"********\", 8) != 0) {\n\t    next_intuit_at(line_beginning,p_input_line);\n\t    return chars_read == (size_t) -1 ? -1 : 0;\n\t}\n\ts = buf;\n\twhile (*s == '*')\n\t    s++;\n\tif (*s == ' ')\n\t  {\n\t    p_c_function = s;\n\t    while (*s != '\\n')\n\t\ts++;\n\t    *s = '\\0';\n\t    p_c_function = savestr (p_c_function);\n\t    if (! p_c_function)\n\t      return -1;\n\t  }\n\tp_hunk_beg = p_input_line + 1;\n\twhile (p_end < p_max) {\n\t    chars_read = get_line ();\n\t    if (chars_read == (size_t) -1)\n\t      return -1;\n\t    if (!chars_read) {\n\t\tif (repl_beginning && repl_could_be_missing) {\n\t\t    repl_missing = true;\n\t\t    goto hunk_done;\n\t\t}\n\t\tif (p_max - p_end < 4) {\n\t\t    strcpy (buf, \"  \\n\");  /* assume blank lines got chopped */\n\t\t    chars_read = 3;\n\t\t} else {\n\t\t    fatal (\"unexpected end of file in patch\");\n\t\t}\n\t    }\n\t    p_end++;\n\t    if (p_end == hunkmax)\n\t      fatal (\"unterminated hunk starting at line %s; giving up at line %s: %s\",\n\t\t     format_linenum (numbuf0, pch_hunk_beg ()),\n\t\t     format_linenum (numbuf1, p_input_line), buf);\n\t    assert(p_end < hunkmax);\n\t    p_Char[p_end] = *buf;\n\t    p_len[p_end] = 0;\n\t    p_line[p_end] = 0;\n\t    switch (*buf) {\n\t    case '*':\n\t\tif (strnEQ(buf, \"********\", 8)) {\n\t\t    if (repl_beginning && repl_could_be_missing) {\n\t\t\trepl_missing = true;\n\t\t\tgoto hunk_done;\n\t\t    }\n\t\t    else\n\t\t      fatal (\"unexpected end of hunk at line %s\",\n\t\t\t     format_linenum (numbuf0, p_input_line));\n\t\t}\n\t\tif (p_end != 0) {\n\t\t    if (repl_beginning && repl_could_be_missing) {\n\t\t\trepl_missing = true;\n\t\t\tgoto hunk_done;\n\t\t    }\n\t\t    fatal (\"unexpected '***' at line %s: %s\",\n\t\t\t   format_linenum (numbuf0, p_input_line), buf);\n\t\t}\n\t\tcontext = 0;\n\t\tp_len[p_end] = strlen (buf);\n\t\tif (! (p_line[p_end] = savestr (buf))) {\n\t\t    p_end--;\n\t\t    return -1;\n\t\t}\n\t\tfor (s = buf;  *s && !ISDIGIT (*s);  s++)\n\t\t  /* do nothing */ ;\n\t\tif (strnEQ(s,\"0,0\",3))\n\t\t    remove_prefix (s, 2);\n\t\ts = scan_linenum (s, &p_first);\n\t\tif (*s == ',') {\n\t\t    while (*s && !ISDIGIT (*s))\n\t\t      s++;\n\t\t    scan_linenum (s, &p_ptrn_lines);\n\t\t    p_ptrn_lines += 1 - p_first;\n\t\t    if (p_ptrn_lines < 0)\n\t\t      malformed ();\n\t\t}\n\t\telse if (p_first)\n\t\t    p_ptrn_lines = 1;\n\t\telse {\n\t\t    p_ptrn_lines = 0;\n\t\t    p_first = 1;\n\t\t}\n\t\tif (p_first >= LINENUM_MAX - p_ptrn_lines ||\n\t\t    p_ptrn_lines >= LINENUM_MAX - 6)\n\t\t  malformed ();\n\t\tp_max = p_ptrn_lines + 6;\t/* we need this much at least */\n\t\twhile (p_max + 1 >= hunkmax)\n\t\t    if (! grow_hunkmax ())\n\t\t\treturn -1;\n\t\tp_max = hunkmax;\n\t\tbreak;\n\t    case '-':\n\t\tif (buf[1] != '-')\n\t\t  goto change_line;\n\t\tif (ptrn_prefix_context == -1)\n\t\t  ptrn_prefix_context = context;\n\t\tptrn_suffix_context = context;\n\t\tif (repl_beginning\n\t\t    || (p_end\n\t\t\t!= p_ptrn_lines + 1 + (p_Char[p_end - 1] == '\\n')))\n\t\t  {\n\t\t    if (p_end == 1)\n\t\t      {\n\t\t\t/* 'Old' lines were omitted.  Set up to fill\n\t\t\t   them in from 'new' context lines.  */\n\t\t\tptrn_missing = true;\n\t\t\tp_end = p_ptrn_lines + 1;\n\t\t\tptrn_prefix_context = ptrn_suffix_context = -1;\n\t\t\tfillsrc = p_end + 1;\n\t\t\tfilldst = 1;\n\t\t\tfillcnt = p_ptrn_lines;\n\t\t      }\n\t\t    else if (! repl_beginning)\n\t\t      fatal (\"%s '---' at line %s; check line numbers at line %s\",\n\t\t\t     (p_end <= p_ptrn_lines\n\t\t\t      ? \"Premature\"\n\t\t\t      : \"Overdue\"),\n\t\t\t     format_linenum (numbuf0, p_input_line),\n\t\t\t     format_linenum (numbuf1, p_hunk_beg));\n\t\t    else if (! repl_could_be_missing)\n\t\t      fatal (\"duplicate '---' at line %s; check line numbers at line %s\",\n\t\t\t     format_linenum (numbuf0, p_input_line),\n\t\t\t     format_linenum (numbuf1,\n\t\t\t\t\t     p_hunk_beg + repl_beginning));\n\t\t    else\n\t\t      {\n\t\t\trepl_missing = true;\n\t\t\tgoto hunk_done;\n\t\t      }\n\t\t  }\n\t\trepl_beginning = p_end;\n\t\trepl_backtrack_position = file_tell (pfp);\n\t\trepl_patch_line = p_input_line;\n\t\trepl_context = context;\n\t\tp_len[p_end] = strlen (buf);\n\t\tif (! (p_line[p_end] = savestr (buf)))\n\t\t  {\n\t\t    p_end--;\n\t\t    return -1;\n\t\t  }\n\t\tp_Char[p_end] = '=';\n\t\tfor (s = buf;  *s && ! ISDIGIT (*s);  s++)\n\t\t  /* do nothing */ ;\n\t\ts = scan_linenum (s, &p_newfirst);\n\t\tif (*s == ',')\n\t\t  {\n\t\t    do\n\t\t      {\n\t\t\tif (!*++s)\n\t\t\t  malformed ();\n\t\t      }\n\t\t    while (! ISDIGIT (*s));\n\t\t    scan_linenum (s, &p_repl_lines);\n\t\t    p_repl_lines += 1 - p_newfirst;\n\t\t    if (p_repl_lines < 0)\n\t\t      malformed ();\n\t\t  }\n\t\telse if (p_newfirst)\n\t\t  p_repl_lines = 1;\n\t\telse\n\t\t  {\n\t\t    p_repl_lines = 0;\n\t\t    p_newfirst = 1;\n\t\t  }\n\t\tif (p_newfirst >= LINENUM_MAX - p_repl_lines ||\n\t\t    p_repl_lines >= LINENUM_MAX - p_end)\n\t\t  malformed ();\n\t\tp_max = p_repl_lines + p_end;\n\t\twhile (p_max + 1 >= hunkmax)\n\t\t  if (! grow_hunkmax ())\n\t\t    return -1;\n\t\tif (p_repl_lines != ptrn_copiable\n\t\t    && (p_prefix_context != 0\n\t\t\t|| context != 0\n\t\t\t|| p_repl_lines != 1))\n\t\t  repl_could_be_missing = false;\n\t\tcontext = 0;\n\t\tbreak;\n\t    case '+':  case '!':\n\t\trepl_could_be_missing = false;\n\t      change_line:\n\t\ts = buf + 1;\n\t\tchars_read--;\n\t\tif (*s == '\\n' && canonicalize_ws) {\n\t\t    strcpy (s, \" \\n\");\n\t\t    chars_read = 2;\n\t\t}\n\t\tif (*s == ' ' || *s == '\\t') {\n\t\t    s++;\n\t\t    chars_read--;\n\t\t} else if (repl_beginning && repl_could_be_missing) {\n\t\t    repl_missing = true;\n\t\t    goto hunk_done;\n\t\t}\n\t\tif (! repl_beginning)\n\t\t  {\n\t\t    if (ptrn_prefix_context == -1)\n\t\t      ptrn_prefix_context = context;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (repl_prefix_context == -1)\n\t\t      repl_prefix_context = context;\n\t\t  }\n\t\tchars_read -=\n\t\t  (1 < chars_read\n\t\t   && p_end == (repl_beginning ? p_max : p_ptrn_lines)\n\t\t   && incomplete_line ());\n\t\tp_len[p_end] = chars_read;\n\t\tp_line[p_end] = savebuf (s, chars_read);\n\t\tif (chars_read && ! p_line[p_end]) {\n\t\t    p_end--;\n\t\t    return -1;\n\t        }\n\t\tcontext = 0;\n\t\tbreak;\n\t    case '\\t': case '\\n':\t/* assume spaces got eaten */\n\t\ts = buf;\n\t\tif (*buf == '\\t') {\n\t\t    s++;\n\t\t    chars_read--;\n\t\t}\n\t\tif (repl_beginning && repl_could_be_missing &&\n\t\t    (!ptrn_spaces_eaten || difftype == NEW_CONTEXT_DIFF) ) {\n\t\t    repl_missing = true;\n\t\t    goto hunk_done;\n\t\t}\n\t\tchars_read -=\n\t\t  (1 < chars_read\n\t\t   && p_end == (repl_beginning ? p_max : p_ptrn_lines)\n\t\t   && incomplete_line ());\n\t\tp_len[p_end] = chars_read;\n\t\tp_line[p_end] = savebuf (buf, chars_read);\n\t\tif (chars_read && ! p_line[p_end]) {\n\t\t    p_end--;\n\t\t    return -1;\n\t\t}\n\t\tif (p_end != p_ptrn_lines + 1) {\n\t\t    ptrn_spaces_eaten |= (repl_beginning != 0);\n\t\t    some_context = true;\n\t\t    context++;\n\t\t    if (repl_beginning)\n\t\t\trepl_copiable++;\n\t\t    else\n\t\t\tptrn_copiable++;\n\t\t    p_Char[p_end] = ' ';\n\t\t}\n\t\tbreak;\n\t    case ' ':\n\t\ts = buf + 1;\n\t\tchars_read--;\n\t\tif (*s == '\\n' && canonicalize_ws) {\n\t\t    strcpy (s, \"\\n\");\n\t\t    chars_read = 2;\n\t\t}\n\t\tif (*s == ' ' || *s == '\\t') {\n\t\t    s++;\n\t\t    chars_read--;\n\t\t} else if (repl_beginning && repl_could_be_missing) {\n\t\t    repl_missing = true;\n\t\t    goto hunk_done;\n\t\t}\n\t\tsome_context = true;\n\t\tcontext++;\n\t\tif (repl_beginning)\n\t\t    repl_copiable++;\n\t\telse\n\t\t    ptrn_copiable++;\n\t\tchars_read -=\n\t\t  (1 < chars_read\n\t\t   && p_end == (repl_beginning ? p_max : p_ptrn_lines)\n\t\t   && incomplete_line ());\n\t\tp_len[p_end] = chars_read;\n\t\tp_line[p_end] = savebuf (s, chars_read);\n\t\tif (chars_read && ! p_line[p_end]) {\n\t\t    p_end--;\n\t\t    return -1;\n\t\t}\n\t\tbreak;\n\t    default:\n\t\tif (repl_beginning && repl_could_be_missing) {\n\t\t    repl_missing = true;\n\t\t    goto hunk_done;\n\t\t}\n\t\tmalformed ();\n\t    }\n\t}\n\n    hunk_done:\n\tif (p_end >=0 && !repl_beginning)\n\t  fatal (\"no '---' found in patch at line %s\",\n\t\t format_linenum (numbuf0, pch_hunk_beg ()));\n\n\tif (repl_missing) {\n\n\t    /* reset state back to just after --- */\n\t    p_input_line = repl_patch_line;\n\t    context = repl_context;\n\t    for (p_end--; p_end > repl_beginning; p_end--)\n\t\tfree(p_line[p_end]);\n\t    Fseek (pfp, repl_backtrack_position, SEEK_SET);\n\n\t    /* redundant 'new' context lines were omitted - set */\n\t    /* up to fill them in from the old file context */\n\t    fillsrc = 1;\n\t    filldst = repl_beginning+1;\n\t    fillcnt = p_repl_lines;\n\t    p_end = p_max;\n\t}\n\telse if (! ptrn_missing && ptrn_copiable != repl_copiable)\n\t  fatal (\"context mangled in hunk at line %s\",\n\t\t format_linenum (numbuf0, p_hunk_beg));\n\telse if (!some_context && fillcnt == 1) {\n\t    /* the first hunk was a null hunk with no context */\n\t    /* and we were expecting one line -- fix it up. */\n\t    while (filldst < p_end) {\n\t\tp_line[filldst] = p_line[filldst+1];\n\t\tp_Char[filldst] = p_Char[filldst+1];\n\t\tp_len[filldst] = p_len[filldst+1];\n\t\tfilldst++;\n\t    }\n#if 0\n\t    repl_beginning--;\t\t/* this doesn't need to be fixed */\n#endif\n\t    p_end--;\n\t    p_first++;\t\t\t/* do append rather than insert */\n\t    fillcnt = 0;\n\t    p_ptrn_lines = 0;\n\t}\n\n\tp_prefix_context = ((repl_prefix_context == -1\n\t\t\t     || (ptrn_prefix_context != -1\n\t\t\t\t && ptrn_prefix_context < repl_prefix_context))\n\t\t\t    ? ptrn_prefix_context : repl_prefix_context);\n\tp_suffix_context = ((ptrn_suffix_context != -1\n\t\t\t     && ptrn_suffix_context < context)\n\t\t\t    ? ptrn_suffix_context : context);\n\tif (p_prefix_context == -1 || p_suffix_context == -1)\n\t    fatal (\"replacement text or line numbers mangled in hunk at line %s\",\n\t\t   format_linenum (numbuf0, p_hunk_beg));\n\n\tif (difftype == CONTEXT_DIFF\n\t    && (fillcnt\n\t\t|| (p_first > 1\n\t\t    && p_prefix_context + p_suffix_context < ptrn_copiable))) {\n\t    if (verbosity == VERBOSE)\n\t\tsay (\"%s\\n%s\\n%s\\n\",\n\"(Fascinating -- this is really a new-style context diff but without\",\n\"the telltale extra asterisks on the *** line that usually indicate\",\n\"the new style...)\");\n\t    diff_type = difftype = NEW_CONTEXT_DIFF;\n\t}\n\n\t/* if there were omitted context lines, fill them in now */\n\tif (fillcnt) {\n\t    p_bfake = filldst;\t\t/* remember where not to free() */\n\t    p_efake = filldst + fillcnt - 1;\n\t    while (fillcnt-- > 0) {\n\t\twhile (fillsrc <= p_end && fillsrc != repl_beginning\n\t\t       && p_Char[fillsrc] != ' ')\n\t\t    fillsrc++;\n\t\tif (p_end < fillsrc || fillsrc == repl_beginning)\n\t\t  {\n\t\t    fatal (\"replacement text or line numbers mangled in hunk at line %s\",\n\t\t\t   format_linenum (numbuf0, p_hunk_beg));\n\t\t  }\n\t\tp_line[filldst] = p_line[fillsrc];\n\t\tp_Char[filldst] = p_Char[fillsrc];\n\t\tp_len[filldst] = p_len[fillsrc];\n\t\tfillsrc++; filldst++;\n\t    }\n\t    while (fillsrc <= p_end && fillsrc != repl_beginning)\n\t      {\n\t\tif (p_Char[fillsrc] == ' ')\n\t\t  fatal (\"replacement text or line numbers mangled in hunk at line %s\",\n\t\t\t format_linenum (numbuf0, p_hunk_beg));\n\t\tfillsrc++;\n\t      }\n\t    if (debug & 64)\n\t      printf (\"fillsrc %s, filldst %s, rb %s, e+1 %s\\n\",\n\t\t      format_linenum (numbuf0, fillsrc),\n\t\t      format_linenum (numbuf1, filldst),\n\t\t      format_linenum (numbuf2, repl_beginning),\n\t\t      format_linenum (numbuf3, p_end + 1));\n\t    assert(fillsrc==p_end+1 || fillsrc==repl_beginning);\n\t    assert(filldst==p_end+1 || filldst==repl_beginning);\n\t}\n    }\n    else if (difftype == UNI_DIFF) {\n\tfile_offset line_beginning = file_tell (pfp);  /* file pos of the current line */\n\tlin fillsrc;  /* index of old lines */\n\tlin filldst;  /* index of new lines */\n\tchar ch = '\\0';\n\n\tchars_read = get_line ();\n\tif (chars_read == (size_t) -1\n\t    || chars_read <= 4\n\t    || strncmp (buf, \"@@ -\", 4) != 0) {\n\t    next_intuit_at(line_beginning,p_input_line);\n\t    return chars_read == (size_t) -1 ? -1 : 0;\n\t}\n\ts = scan_linenum (buf + 4, &p_first);\n\tif (*s == ',')\n\t    s = scan_linenum (s + 1, &p_ptrn_lines);\n\telse\n\t    p_ptrn_lines = 1;\n\tif (p_first >= LINENUM_MAX - p_ptrn_lines)\n\t  malformed ();\n\tif (*s == ' ') s++;\n\tif (*s != '+')\n\t    malformed ();\n\ts = scan_linenum (s + 1, &p_newfirst);\n\tif (*s == ',')\n\t    s = scan_linenum (s + 1, &p_repl_lines);\n\telse\n\t    p_repl_lines = 1;\n\tif (p_newfirst >= LINENUM_MAX - p_repl_lines)\n\t  malformed ();\n\tif (*s == ' ') s++;\n\tif (*s++ != '@')\n\t    malformed ();\n\tif (*s++ == '@' && *s == ' ')\n\t  {\n\t    p_c_function = s;\n\t    while (*s != '\\n')\n\t\ts++;\n\t    *s = '\\0';\n\t    p_c_function = savestr (p_c_function);\n\t    if (! p_c_function)\n\t      return -1;\n\t  }\n\tif (!p_ptrn_lines)\n\t    p_first++;\t\t\t/* do append rather than insert */\n\tif (!p_repl_lines)\n\t    p_newfirst++;\n\tif (p_ptrn_lines >= LINENUM_MAX - (p_repl_lines + 1))\n\t  malformed ();\n\tp_max = p_ptrn_lines + p_repl_lines + 1;\n\twhile (p_max + 1 >= hunkmax)\n\t    if (! grow_hunkmax ())\n\t\treturn -1;\n\tfillsrc = 1;\n\tfilldst = fillsrc + p_ptrn_lines;\n\tp_end = filldst + p_repl_lines;\n\tsprintf (buf, \"*** %s,%s ****\\n\",\n\t\t format_linenum (numbuf0, p_first),\n\t\t format_linenum (numbuf1, p_first + p_ptrn_lines - 1));\n\tp_len[0] = strlen (buf);\n\tif (! (p_line[0] = savestr (buf))) {\n\t    p_end = -1;\n\t    return -1;\n\t}\n\tp_Char[0] = '*';\n\tsprintf (buf, \"--- %s,%s ----\\n\",\n\t\t format_linenum (numbuf0, p_newfirst),\n\t\t format_linenum (numbuf1, p_newfirst + p_repl_lines - 1));\n\tp_len[filldst] = strlen (buf);\n\tif (! (p_line[filldst] = savestr (buf))) {\n\t    p_end = 0;\n\t    return -1;\n\t}\n\tp_Char[filldst++] = '=';\n\tp_prefix_context = -1;\n\tp_hunk_beg = p_input_line + 1;\n\twhile (fillsrc <= p_ptrn_lines || filldst <= p_end) {\n\t    chars_read = get_line ();\n\t    if (!chars_read) {\n\t\tif (p_max - filldst < 3) {\n\t\t    strcpy (buf, \" \\n\");  /* assume blank lines got chopped */\n\t\t    chars_read = 2;\n\t\t} else {\n\t\t    fatal (\"unexpected end of file in patch\");\n\t\t}\n\t    }\n\t    if (chars_read == (size_t) -1)\n\t\ts = 0;\n\t    else if (*buf == '\\t' || *buf == '\\n') {\n\t\tch = ' ';\t\t/* assume the space got eaten */\n\t\ts = savebuf (buf, chars_read);\n\t    }\n\t    else {\n\t\tch = *buf;\n\t\ts = savebuf (buf+1, --chars_read);\n\t    }\n\t    if (chars_read && ! s)\n\t      {\n\t\twhile (--filldst > p_ptrn_lines)\n\t\t    free(p_line[filldst]);\n\t\tp_end = fillsrc-1;\n\t\treturn -1;\n\t      }\n\t    switch (ch) {\n\t    case '-':\n\t\tif (fillsrc > p_ptrn_lines) {\n\t\t    free(s);\n\t\t    p_end = filldst-1;\n\t\t    malformed ();\n\t\t}\n\t\tchars_read -= fillsrc == p_ptrn_lines && incomplete_line ();\n\t\tp_Char[fillsrc] = ch;\n\t\tp_line[fillsrc] = s;\n\t\tp_len[fillsrc++] = chars_read;\n\t\tbreak;\n\t    case '=':\n\t\tch = ' ';\n\t\t/* FALL THROUGH */\n\t    case ' ':\n\t\tif (fillsrc > p_ptrn_lines) {\n\t\t    free(s);\n\t\t    while (--filldst > p_ptrn_lines)\n\t\t\tfree(p_line[filldst]);\n\t\t    p_end = fillsrc-1;\n\t\t    malformed ();\n\t\t}\n\t\tcontext++;\n\t\tchars_read -= fillsrc == p_ptrn_lines && incomplete_line ();\n\t\tp_Char[fillsrc] = ch;\n\t\tp_line[fillsrc] = s;\n\t\tp_len[fillsrc++] = chars_read;\n\t\ts = savebuf (s, chars_read);\n\t\tif (chars_read && ! s) {\n\t\t    while (--filldst > p_ptrn_lines)\n\t\t\tfree(p_line[filldst]);\n\t\t    p_end = fillsrc-1;\n\t\t    return -1;\n\t\t}\n\t\t/* FALL THROUGH */\n\t    case '+':\n\t\tif (filldst > p_end) {\n\t\t    free(s);\n\t\t    while (--filldst > p_ptrn_lines)\n\t\t\tfree(p_line[filldst]);\n\t\t    p_end = fillsrc-1;\n\t\t    malformed ();\n\t\t}\n\t\tchars_read -= filldst == p_end && incomplete_line ();\n\t\tp_Char[filldst] = ch;\n\t\tp_line[filldst] = s;\n\t\tp_len[filldst++] = chars_read;\n\t\tbreak;\n\t    default:\n\t\tp_end = filldst;\n\t\tmalformed ();\n\t    }\n\t    if (ch != ' ') {\n\t\tif (p_prefix_context == -1)\n\t\t    p_prefix_context = context;\n\t\tcontext = 0;\n\t    }\n\t}/* while */\n\tif (p_prefix_context == -1)\n\t  malformed ();\n\tp_suffix_context = context;\n    }\n    else {\t\t\t\t/* normal diff--fake it up */\n\tchar hunk_type;\n\tint i;\n\tlin min, max;\n\tfile_offset line_beginning = file_tell (pfp);\n\n\tp_prefix_context = p_suffix_context = 0;\n\tchars_read = get_line ();\n\tif (chars_read == (size_t) -1 || !chars_read || !ISDIGIT (*buf)) {\n\t    next_intuit_at(line_beginning,p_input_line);\n\t    return chars_read == (size_t) -1 ? -1 : 0;\n\t}\n\ts = scan_linenum (buf, &p_first);\n\tif (*s == ',') {\n\t    s = scan_linenum (s + 1, &p_ptrn_lines);\n\t    p_ptrn_lines += 1 - p_first;\n\t}\n\telse\n\t    p_ptrn_lines = (*s != 'a');\n\tif (p_first >= LINENUM_MAX - p_ptrn_lines)\n\t  malformed ();\n\thunk_type = *s;\n\tif (hunk_type == 'a')\n\t    p_first++;\t\t\t/* do append rather than insert */\n\ts = scan_linenum (s + 1, &min);\n\tif (*s == ',')\n\t    scan_linenum (s + 1, &max);\n\telse\n\t    max = min;\n\tif (min > max || max - min == LINENUM_MAX)\n\t  malformed ();\n\tif (hunk_type == 'd')\n\t    min++;\n\tp_newfirst = min;\n\tp_repl_lines = max - min + 1;\n\tif (p_newfirst >= LINENUM_MAX - p_repl_lines)\n\t  malformed ();\n\tif (p_ptrn_lines >= LINENUM_MAX - (p_repl_lines + 1))\n\t  malformed ();\n\tp_end = p_ptrn_lines + p_repl_lines + 1;\n\twhile (p_end + 1 >= hunkmax)\n\t  if (! grow_hunkmax ())\n\t    {\n\t      p_end = -1;\n\t      return -1;\n\t    }\n\tsprintf (buf, \"*** %s,%s\\n\",\n\t\t format_linenum (numbuf0, p_first),\n\t\t format_linenum (numbuf1, p_first + p_ptrn_lines - 1));\n\tp_len[0] = strlen (buf);\n\tif (! (p_line[0] = savestr (buf))) {\n\t    p_end = -1;\n\t    return -1;\n\t}\n\tp_Char[0] = '*';\n\tfor (i=1; i<=p_ptrn_lines; i++) {\n\t    chars_read = get_line ();\n\t    if (chars_read == (size_t) -1)\n\t      {\n\t\tp_end = i - 1;\n\t\treturn -1;\n\t      }\n\t    if (!chars_read)\n\t      fatal (\"unexpected end of file in patch at line %s\",\n\t\t     format_linenum (numbuf0, p_input_line));\n\t    if (buf[0] != '<' || (buf[1] != ' ' && buf[1] != '\\t'))\n\t      fatal (\"'<' followed by space or tab expected at line %s of patch\",\n\t\t     format_linenum (numbuf0, p_input_line));\n\t    chars_read -= 2 + (i == p_ptrn_lines && incomplete_line ());\n\t    p_len[i] = chars_read;\n\t    p_line[i] = savebuf (buf + 2, chars_read);\n\t    if (chars_read && ! p_line[i]) {\n\t\tp_end = i-1;\n\t\treturn -1;\n\t    }\n\t    p_Char[i] = '-';\n\t}\n\tif (hunk_type == 'c') {\n\t    chars_read = get_line ();\n\t    if (chars_read == (size_t) -1)\n\t      {\n\t\tp_end = i - 1;\n\t\treturn -1;\n\t      }\n\t    if (! chars_read)\n\t      fatal (\"unexpected end of file in patch at line %s\",\n\t\t     format_linenum (numbuf0, p_input_line));\n\t    if (*buf != '-')\n\t      fatal (\"'---' expected at line %s of patch\",\n\t\t     format_linenum (numbuf0, p_input_line));\n\t}\n\tsprintf (buf, \"--- %s,%s\\n\",\n\t\t format_linenum (numbuf0, min),\n\t\t format_linenum (numbuf1, max));\n\tp_len[i] = strlen (buf);\n\tif (! (p_line[i] = savestr (buf))) {\n\t    p_end = i-1;\n\t    return -1;\n\t}\n\tp_Char[i] = '=';\n\tfor (i++; i<=p_end; i++) {\n\t    chars_read = get_line ();\n\t    if (chars_read == (size_t) -1)\n\t      {\n\t\tp_end = i - 1;\n\t\treturn -1;\n\t      }\n\t    if (!chars_read)\n\t      fatal (\"unexpected end of file in patch at line %s\",\n\t\t     format_linenum (numbuf0, p_input_line));\n\t    if (buf[0] != '>' || (buf[1] != ' ' && buf[1] != '\\t'))\n\t      fatal (\"'>' followed by space or tab expected at line %s of patch\",\n\t\t     format_linenum (numbuf0, p_input_line));\n\t    chars_read -= 2 + (i == p_end && incomplete_line ());\n\t    p_len[i] = chars_read;\n\t    p_line[i] = savebuf (buf + 2, chars_read);\n\t    if (chars_read && ! p_line[i]) {\n\t\tp_end = i-1;\n\t\treturn -1;\n\t    }\n\t    p_Char[i] = '+';\n\t}\n    }\n    if (rev)\t\t\t\t/* backwards patch? */\n\tif (!pch_swap())\n\t    say (\"Not enough memory to swap next hunk!\\n\");\n    assert (p_end + 1 < hunkmax);\n    p_Char[p_end + 1] = '^';  /* add a stopper for apply_hunk */\n    if (debug & 2) {\n\tlin i;\n\n\tfor (i = 0; i <= p_end + 1; i++) {\n\t    fprintf (stderr, \"%s %c\",\n\t\t     format_linenum (numbuf0, i),\n\t\t     p_Char[i]);\n\t    if (p_Char[i] == '*')\n\t      fprintf (stderr, \" %s,%s\\n\",\n\t\t       format_linenum (numbuf0, p_first),\n\t\t       format_linenum (numbuf1, p_ptrn_lines));\n\t    else if (p_Char[i] == '=')\n\t      fprintf (stderr, \" %s,%s\\n\",\n\t\t       format_linenum (numbuf0, p_newfirst),\n\t\t       format_linenum (numbuf1, p_repl_lines));\n\t    else if (p_Char[i] != '^')\n\t      {\n\t\tfputs(\" |\", stderr);\n\t\tpch_write_line (i, stderr);\n\t      }\n\t    else\n\t      fputc('\\n', stderr);\n\t}\n\tfflush (stderr);\n    }\n    return 1;\n}",
      "lines": 772,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "get_line": {
      "start_point": [
        1939,
        0
      ],
      "end_point": [
        1944,
        1
      ],
      "content": "static size_t\nget_line (void)\n{\n   return pget_line (p_indent, p_rfc934_nesting, p_strip_trailing_cr,\n\t\t     p_pass_comments_through);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "pget_line": {
      "start_point": [
        1957,
        0
      ],
      "end_point": [
        2047,
        1
      ],
      "content": "static size_t\npget_line (size_t indent, int rfc934_nesting, bool strip_trailing_cr,\n\t   bool pass_comments_through)\n{\n  FILE *fp = pfp;\n  int c;\n  size_t i;\n  char *b;\n  size_t s;\n\n  do\n    {\n      i = 0;\n      for (;;)\n\t{\n\t  c = getc (fp);\n\t  if (c == EOF)\n\t    {\n\t      if (ferror (fp))\n\t\tread_fatal ();\n\t      return 0;\n\t    }\n\t  if (indent <= i)\n\t    break;\n\t  if (c == ' ' || c == 'X')\n\t    i++;\n\t  else if (c == '\\t')\n\t    i = (i + 8) & ~7;\n\t  else\n\t    break;\n\t}\n\n      i = 0;\n      b = buf;\n\n      while (c == '-' && 0 <= --rfc934_nesting)\n\t{\n\t  c = getc (fp);\n\t  if (c == EOF)\n\t    goto patch_ends_in_middle_of_line;\n\t  if (c != ' ')\n\t    {\n\t      i = 1;\n\t      b[0] = '-';\n\t      break;\n\t    }\n\t  c = getc (fp);\n\t  if (c == EOF)\n\t    goto patch_ends_in_middle_of_line;\n\t}\n\n      s = bufsize;\n\n      for (;;)\n\t{\n\t  if (i == s - 1)\n\t    {\n\t      s *= 2;\n\t      b = realloc (b, s);\n\t      if (!b)\n\t\t{\n\t\t  if (!using_plan_a)\n\t\t    xalloc_die ();\n\t\t  return (size_t) -1;\n\t\t}\n\t      buf = b;\n\t      bufsize = s;\n\t    }\n\t  b[i++] = c;\n\t  if (c == '\\n')\n\t    break;\n\t  c = getc (fp);\n\t  if (c == EOF)\n\t    goto patch_ends_in_middle_of_line;\n\t}\n\n      p_input_line++;\n    }\n  while (*b == '#' && !pass_comments_through);\n\n  if (strip_trailing_cr && 2 <= i && b[i - 2] == '\\r')\n    b[i-- - 2] = '\\n';\n  b[i] = '\\0';\n  return i;\n\n patch_ends_in_middle_of_line:\n  if (ferror (fp))\n    read_fatal ();\n  say (\"patch unexpectedly ends in middle of line\\n\");\n  return 0;\n}",
      "lines": 91,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "incomplete_line": {
      "start_point": [
        2049,
        0
      ],
      "end_point": [
        2068,
        1
      ],
      "content": "static bool\nincomplete_line (void)\n{\n  FILE *fp = pfp;\n  int c;\n  file_offset line_beginning = file_tell (fp);\n\n  if (getc (fp) == '\\\\')\n    {\n      while ((c = getc (fp)) != '\\n'  &&  c != EOF)\n\t/* do nothing */ ;\n      return true;\n    }\n  else\n    {\n      /* We don't trust ungetc.  */\n      Fseek (pfp, line_beginning, SEEK_SET);\n      return false;\n    }\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pch_swap": {
      "start_point": [
        2072,
        0
      ],
      "end_point": [
        2164,
        1
      ],
      "content": "bool\npch_swap (void)\n{\n    char **tp_line;\t\t/* the text of the hunk */\n    size_t *tp_len;\t\t/* length of each line */\n    char *tp_char;\t\t/* +, -, and ! */\n    lin i;\n    lin n;\n    bool blankline = false;\n    char *s;\n\n    i = p_first;\n    p_first = p_newfirst;\n    p_newfirst = i;\n\n    /* make a scratch copy */\n\n    tp_line = p_line;\n    tp_len = p_len;\n    tp_char = p_Char;\n    p_line = 0;\t/* force set_hunkmax to allocate again */\n    p_len = 0;\n    p_Char = 0;\n    set_hunkmax();\n    if (!p_line || !p_len || !p_Char) {\n\tfree (p_line);\n\tp_line = tp_line;\n\tfree (p_len);\n\tp_len = tp_len;\n\tfree (p_Char);\n\tp_Char = tp_char;\n\treturn false;\t\t/* not enough memory to swap hunk! */\n    }\n\n    /* now turn the new into the old */\n\n    i = p_ptrn_lines + 1;\n    if (tp_char[i] == '\\n') {\t\t/* account for possible blank line */\n\tblankline = true;\n\ti++;\n    }\n    if (p_efake >= 0) {\t\t\t/* fix non-freeable ptr range */\n\tif (p_efake <= i)\n\t    n = p_end - i + 1;\n\telse\n\t    n = -i;\n\tp_efake += n;\n\tp_bfake += n;\n    }\n    for (n=0; i <= p_end; i++,n++) {\n\tp_line[n] = tp_line[i];\n\tp_Char[n] = tp_char[i];\n\tif (p_Char[n] == '+')\n\t    p_Char[n] = '-';\n\tp_len[n] = tp_len[i];\n    }\n    if (blankline) {\n\ti = p_ptrn_lines + 1;\n\tp_line[n] = tp_line[i];\n\tp_Char[n] = tp_char[i];\n\tp_len[n] = tp_len[i];\n\tn++;\n    }\n    assert(p_Char[0] == '=');\n    p_Char[0] = '*';\n    for (s=p_line[0]; *s; s++)\n\tif (*s == '-')\n\t    *s = '*';\n\n    /* now turn the old into the new */\n\n    assert(tp_char[0] == '*');\n    tp_char[0] = '=';\n    for (s=tp_line[0]; *s; s++)\n\tif (*s == '*')\n\t    *s = '-';\n    for (i=0; n <= p_end; i++,n++) {\n\tp_line[n] = tp_line[i];\n\tp_Char[n] = tp_char[i];\n\tif (p_Char[n] == '-')\n\t    p_Char[n] = '+';\n\tp_len[n] = tp_len[i];\n    }\n    assert(i == p_ptrn_lines + 1);\n    i = p_ptrn_lines;\n    p_ptrn_lines = p_repl_lines;\n    p_repl_lines = i;\n    p_Char[p_end + 1] = '^';\n    free (tp_line);\n    free (tp_len);\n    free (tp_char);\n    return true;\n}",
      "lines": 93,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "pch_says_nonexistent": {
      "start_point": [
        2169,
        0
      ],
      "end_point": [
        2173,
        1
      ],
      "content": "int\npch_says_nonexistent (bool which)\n{\n  return p_says_nonexistent[which];\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "pch_name": {
      "start_point": [
        2175,
        0
      ],
      "end_point": [
        2179,
        1
      ],
      "content": "const char *\npch_name (enum nametype type)\n{\n  return type == NONE ? NULL : p_name[type];\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\npch_name (enum nametype type)",
        "*"
      ]
    },
    "pch_copy": {
      "start_point": [
        2181,
        0
      ],
      "end_point": [
        2184,
        1
      ],
      "content": "bool pch_copy (void)\n{\n  return p_copy[OLD] && p_copy[NEW];\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "pch_rename": {
      "start_point": [
        2186,
        0
      ],
      "end_point": [
        2189,
        1
      ],
      "content": "bool pch_rename (void)\n{\n  return p_rename[OLD] && p_rename[NEW];\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "pch_first": {
      "start_point": [
        2193,
        0
      ],
      "end_point": [
        2197,
        1
      ],
      "content": "lin\npch_first (void)\n{\n    return p_first;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "lin"
      ]
    },
    "pch_ptrn_lines": {
      "start_point": [
        2201,
        0
      ],
      "end_point": [
        2205,
        1
      ],
      "content": "lin\npch_ptrn_lines (void)\n{\n    return p_ptrn_lines;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "lin"
      ]
    },
    "pch_newfirst": {
      "start_point": [
        2209,
        0
      ],
      "end_point": [
        2213,
        1
      ],
      "content": "lin\npch_newfirst (void)\n{\n    return p_newfirst;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "lin"
      ]
    },
    "pch_repl_lines": {
      "start_point": [
        2217,
        0
      ],
      "end_point": [
        2221,
        1
      ],
      "content": "lin\npch_repl_lines (void)\n{\n    return p_repl_lines;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "lin"
      ]
    },
    "pch_end": {
      "start_point": [
        2225,
        0
      ],
      "end_point": [
        2229,
        1
      ],
      "content": "lin\npch_end (void)\n{\n    return p_end;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "lin"
      ]
    },
    "pch_prefix_context": {
      "start_point": [
        2233,
        0
      ],
      "end_point": [
        2237,
        1
      ],
      "content": "lin\npch_prefix_context (void)\n{\n    return p_prefix_context;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "lin"
      ]
    },
    "pch_suffix_context": {
      "start_point": [
        2241,
        0
      ],
      "end_point": [
        2245,
        1
      ],
      "content": "lin\npch_suffix_context (void)\n{\n    return p_suffix_context;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "lin"
      ]
    },
    "pch_line_len": {
      "start_point": [
        2249,
        0
      ],
      "end_point": [
        2253,
        1
      ],
      "content": "size_t\npch_line_len (lin line)\n{\n    return p_len[line];\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "pch_char": {
      "start_point": [
        2259,
        0
      ],
      "end_point": [
        2263,
        1
      ],
      "content": "char\npch_char (lin line)\n{\n    return p_Char[line];\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "char"
      ]
    },
    "pfetch": {
      "start_point": [
        2267,
        0
      ],
      "end_point": [
        2271,
        1
      ],
      "content": "char *\npfetch (lin line)\n{\n    return p_line[line];\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "char",
        "*\npfetch (lin line)",
        "*"
      ]
    },
    "pch_write_line": {
      "start_point": [
        2275,
        0
      ],
      "end_point": [
        2282,
        1
      ],
      "content": "bool\npch_write_line (lin line, FILE *file)\n{\n  bool after_newline = (p_len[line] > 0) && (p_line[line][p_len[line] - 1] == '\\n');\n  if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file))\n    write_fatal ();\n  return after_newline;\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "pch_hunk_beg": {
      "start_point": [
        2286,
        0
      ],
      "end_point": [
        2290,
        1
      ],
      "content": "lin\npch_hunk_beg (void)\n{\n    return p_hunk_beg;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "lin"
      ]
    },
    "pch_c_function": {
      "start_point": [
        2292,
        0
      ],
      "end_point": [
        2296,
        1
      ],
      "content": "char const *\npch_c_function (void)\n{\n    return p_c_function;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "char",
        "const",
        "const",
        "*\npch_c_function (void)",
        "*"
      ]
    },
    "pch_git_diff": {
      "start_point": [
        2300,
        0
      ],
      "end_point": [
        2304,
        1
      ],
      "content": "bool\npch_git_diff (void)\n{\n  return p_git_diff;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "bool"
      ]
    },
    "pch_timestr": {
      "start_point": [
        2306,
        0
      ],
      "end_point": [
        2310,
        1
      ],
      "content": "char const *\npch_timestr (bool which)\n{\n  return p_timestr[which];\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "char",
        "const",
        "const",
        "*\npch_timestr (bool which)",
        "*"
      ]
    },
    "pch_sha1": {
      "start_point": [
        2312,
        0
      ],
      "end_point": [
        2316,
        1
      ],
      "content": "char const *\npch_sha1 (bool which)\n{\n  return p_sha1[which];\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "char",
        "const",
        "const",
        "*\npch_sha1 (bool which)",
        "*"
      ]
    },
    "pch_mode": {
      "start_point": [
        2318,
        0
      ],
      "end_point": [
        2322,
        1
      ],
      "content": "mode_t\npch_mode (bool which)\n{\n  return p_mode[which];\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "mode_t"
      ]
    },
    "get_ed_command_letter": {
      "start_point": [
        2329,
        0
      ],
      "end_point": [
        2379,
        1
      ],
      "content": "static char _GL_ATTRIBUTE_PURE\nget_ed_command_letter (char const *line)\n{\n  char const *p = line;\n  char letter;\n  bool pair = false;\n\n  if (ISDIGIT (*p))\n    {\n      while (ISDIGIT (*++p))\n\t/* do nothing */ ;\n      if (*p == ',')\n\t{\n\t  if (! ISDIGIT (*++p))\n\t    return 0;\n\t  while (ISDIGIT (*++p))\n\t    /* do nothing */ ;\n\t  pair = true;\n\t}\n    }\n\n  letter = *p++;\n\n  switch (letter)\n    {\n    case 'a':\n    case 'i':\n      if (pair)\n\treturn 0;\n      break;\n\n    case 'c':\n    case 'd':\n      break;\n\n    case 's':\n      if (strncmp (p, \"/.//\", 4) != 0)\n\treturn 0;\n      p += 4;\n      break;\n\n    default:\n      return 0;\n    }\n\n  while (*p == ' ' || *p == '\\t')\n    p++;\n  if (*p == '\\n')\n    return letter;\n  return 0;\n}",
      "lines": 51,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "do_ed_script": {
      "start_point": [
        2383,
        0
      ],
      "end_point": [
        2456,
        1
      ],
      "content": "void\ndo_ed_script (char const *inname, char const *outname,\n\t      bool *outname_needs_removal, FILE *ofp)\n{\n    static char const editor_program[] = EDITOR_PROGRAM;\n\n    file_offset beginning_of_this_line;\n    FILE *pipefp = 0;\n    size_t chars_read;\n\n    if (! dry_run && ! skip_rest_of_patch) {\n\tint exclusive = *outname_needs_removal ? 0 : O_EXCL;\n\tassert (! inerrno);\n\t*outname_needs_removal = true;\n\tcopy_file (inname, outname, 0, exclusive, instat.st_mode, true);\n\tsprintf (buf, \"%s %s%s\", editor_program,\n\t\t verbosity == VERBOSE ? \"\" : \"- \",\n\t\t outname);\n\tfflush (stdout);\n\tpipefp = popen(buf, binary_transput ? \"wb\" : \"w\");\n\tif (!pipefp)\n\t  pfatal (\"Can't open pipe to %s\", quotearg (buf));\n    }\n    for (;;) {\n\tchar ed_command_letter;\n\tbeginning_of_this_line = file_tell (pfp);\n\tchars_read = get_line ();\n\tif (! chars_read) {\n\t    next_intuit_at(beginning_of_this_line,p_input_line);\n\t    break;\n\t}\n\ted_command_letter = get_ed_command_letter (buf);\n\tif (ed_command_letter) {\n\t    if (pipefp)\n\t\tif (! fwrite (buf, sizeof *buf, chars_read, pipefp))\n\t\t    write_fatal ();\n\t    if (ed_command_letter != 'd' && ed_command_letter != 's') {\n\t        p_pass_comments_through = true;\n\t\twhile ((chars_read = get_line ()) != 0) {\n\t\t    if (pipefp)\n\t\t\tif (! fwrite (buf, sizeof *buf, chars_read, pipefp))\n\t\t\t    write_fatal ();\n\t\t    if (chars_read == 2  &&  strEQ (buf, \".\\n\"))\n\t\t\tbreak;\n\t\t}\n\t\tp_pass_comments_through = false;\n\t    }\n\t}\n\telse {\n\t    next_intuit_at(beginning_of_this_line,p_input_line);\n\t    break;\n\t}\n    }\n    if (!pipefp)\n      return;\n    if (fwrite (\"w\\nq\\n\", sizeof (char), (size_t) 4, pipefp) == 0\n\t|| fflush (pipefp) != 0)\n      write_fatal ();\n    if (pclose (pipefp) != 0)\n      fatal (\"%s FAILED\", editor_program);\n\n    if (ofp)\n      {\n\tFILE *ifp = fopen (outname, binary_transput ? \"rb\" : \"r\");\n\tint c;\n\tif (!ifp)\n\t  pfatal (\"can't open '%s'\", outname);\n\twhile ((c = getc (ifp)) != EOF)\n\t  if (putc (c, ofp) == EOF)\n\t    write_fatal ();\n\tif (ferror (ifp) || fclose (ifp) != 0)\n\t  read_fatal ();\n      }\n}",
      "lines": 74,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "pch_normalize": {
      "start_point": [
        2458,
        0
      ],
      "end_point": [
        2523,
        1
      ],
      "content": "void\npch_normalize (enum diff format)\n{\n  lin old = 1;\n  lin new = p_ptrn_lines + 1;\n\n  while (p_Char[new] == '=' || p_Char[new] == '\\n')\n    new++;\n\n  if (format == UNI_DIFF)\n    {\n      /* Convert '!' markers into '-' and '+' as defined by the Unified\n         Format.  */\n\n      for (; old <= p_ptrn_lines; old++)\n\tif (p_Char[old] == '!')\n\t  p_Char[old] = '-';\n      for (; new <= p_end; new++)\n\tif (p_Char[new] == '!')\n\t  p_Char[new] = '+';\n    }\n  else\n    {\n      /* Convert '-' and '+' markers which are part of a group into '!' as\n\t defined by the Context Format.  */\n\n      while (old <= p_ptrn_lines)\n\t{\n\t  if (p_Char[old] == '-')\n\t    {\n\t      if (new <= p_end && p_Char[new] == '+')\n\t\t{\n\t\t  do\n\t\t    {\n\t\t      p_Char[old] = '!';\n\t\t      old++;\n\t\t    }\n\t\t  while (old <= p_ptrn_lines && p_Char[old] == '-');\n\t\t  do\n\t\t    {\n\t\t      p_Char[new] = '!';\n\t\t      new++;\n\t\t    }\n\t\t  while (new <= p_end && p_Char[new] == '+');\n\t\t}\n\t      else\n\t\t{\n\t\t  do\n\t\t    old++;\n\t\t  while (old <= p_ptrn_lines && p_Char[old] == '-');\n\t\t}\n\t    }\n\t  else if (new <= p_end && p_Char[new] == '+')\n\t    {\n\t      do\n\t\tnew++;\n\t      while (new <= p_end && p_Char[new] == '+');\n\t    }\n\t  else\n\t    {\n\t      old++;\n\t      new++;\n\t    }\n\t}\n    }\n}",
      "lines": 66,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/src/pch.h": {
    "pch_timestamp": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static inline struct timespec pch_timestamp (bool which)\n{\n  return p_timestamp[which];\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct timespec",
        "struct",
        "timespec"
      ]
    }
  },
  "patch/patch-2.7.6/src/safe.c": {
    "hash_cached_dirfd": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static size_t hash_cached_dirfd (const void *entry, size_t table_size)\n{\n  const struct cached_dirfd *d = entry;\n  size_t strhash = hash_string (d->name, table_size);\n  return (strhash * 31 + d->parent->fd) % table_size;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "compare_cached_dirfds": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static bool compare_cached_dirfds (const void *_a,\n\t\t\t\t   const void *_b)\n{\n  const struct cached_dirfd *a = _a;\n  const struct cached_dirfd *b = _b;\n\n  return (a->parent->fd == b->parent->fd &&\n\t  !strcmp (a->name, b->name));\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "free_cached_dirfd": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static void free_cached_dirfd (struct cached_dirfd *entry)\n{\n  list_del (&entry->children_link);\n  free (entry->name);\n  free (entry);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_dirfd_cache": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static void init_dirfd_cache (void)\n{\n  struct rlimit nofile;\n\n  max_cached_fds = 8;\n  if (getrlimit (RLIMIT_NOFILE, &nofile) == 0)\n    max_cached_fds = MAX (nofile.rlim_cur / 4, max_cached_fds);\n\n  cached_dirfds = hash_initialize (max_cached_fds,\n\t\t\t\t   NULL,\n\t\t\t\t   hash_cached_dirfd,\n\t\t\t\t   compare_cached_dirfds,\n\t\t\t\t   NULL);\n\n  if (!cached_dirfds)\n    xalloc_die ();\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lookup_cached_dirfd": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static struct cached_dirfd *lookup_cached_dirfd (struct cached_dirfd *dir, const char *name)\n{\n  struct cached_dirfd *entry = NULL;\n\n  if (cached_dirfds)\n    {\n      struct cached_dirfd key;\n      key.parent = dir;\n      key.name = (char *) name;\n      entry = hash_lookup (cached_dirfds, &key);\n    }\n\n  return entry;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct cached_dirfd",
        "struct",
        "cached_dirfd",
        "*lookup_cached_dirfd (struct cached_dirfd *dir, const char *name)",
        "*"
      ]
    },
    "remove_cached_dirfd": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static void remove_cached_dirfd (struct cached_dirfd *entry)\n{\n  while (! list_empty (&entry->children))\n    {\n      struct cached_dirfd *child =\n\tlist_entry (entry->children.next, struct cached_dirfd, children_link);\n      list_del_init (&child->children_link);\n      /* assert (list_empty (&child->children_link)); */\n      hash_delete (cached_dirfds, child);  /* noop when not hashed */\n    }\n  list_del (&entry->lru_link);\n  hash_delete (cached_dirfds, entry);  /* noop when not hashed */\n  close (entry->fd);\n  free_cached_dirfd (entry);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "insert_cached_dirfd": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static void insert_cached_dirfd (struct cached_dirfd *entry, int keepfd)\n{\n  if (cached_dirfds == NULL)\n    init_dirfd_cache ();\n\n  /* Trim off the least recently used entries */\n  while (hash_get_n_entries (cached_dirfds) >= max_cached_fds)\n    {\n      struct cached_dirfd *last =\n\tlist_entry (lru_list.prev, struct cached_dirfd, lru_link);\n      if (&last->lru_link == &lru_list)\n\tbreak;\n      if (last->fd == keepfd)\n\t{\n\t  last = list_entry (last->lru_link.prev, struct cached_dirfd, lru_link);\n\t  if (&last->lru_link == &lru_list)\n\t    break;\n\t}\n      remove_cached_dirfd (last);\n    }\n\n  /* Only insert if the parent still exists. */\n  if (! list_empty (&entry->children_link))\n    assert (hash_insert (cached_dirfds, entry) == entry);\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "invalidate_cached_dirfd": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "static void invalidate_cached_dirfd (int dirfd, const char *name)\n{\n  struct cached_dirfd dir, key, *entry;\n  if (!cached_dirfds)\n    return;\n\n  dir.fd = dirfd;\n  key.parent = &dir;\n  key.name = (char *) name;\n  entry = hash_lookup (cached_dirfds, &key);\n  if (entry)\n    remove_cached_dirfd (entry);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "put_path": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static int put_path (struct cached_dirfd *entry)\n{\n  int fd = entry->fd;\n\n  while (entry)\n    {\n      struct cached_dirfd *parent = entry->parent;\n      if (! parent)\n\tbreak;\n      list_add (&entry->lru_link, &lru_list);\n      entry = parent;\n    }\n\n  return fd;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "new_cached_dirfd": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "static struct cached_dirfd *new_cached_dirfd (struct cached_dirfd *dir, const char *name, int fd)\n{\n  struct cached_dirfd *entry = xmalloc (sizeof (struct cached_dirfd));\n\n  INIT_LIST_HEAD (&entry->lru_link);\n  list_add (&entry->children_link, &dir->children);\n  INIT_LIST_HEAD (&entry->children);\n  entry->parent = dir;\n  entry->name = xstrdup (name);\n  entry->fd = fd;\n  return entry;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct cached_dirfd",
        "struct",
        "cached_dirfd",
        "*new_cached_dirfd (struct cached_dirfd *dir, const char *name, int fd)",
        "*"
      ]
    },
    "openat_cached": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static struct cached_dirfd *openat_cached (struct cached_dirfd *dir, const char *name, int keepfd)\n{\n  int fd;\n  struct cached_dirfd *entry = lookup_cached_dirfd (dir, name);\n\n  if (entry)\n    {\n      list_del_init (&entry->lru_link);\n      /* assert (list_empty (&entry->lru_link)); */\n      goto out;\n    }\n  dirfd_cache_misses++;\n\n  /* Actually get the new directory file descriptor. Don't follow\n     symbolic links. */\n  fd = openat (dir->fd, name, O_DIRECTORY | O_NOFOLLOW);\n\n  /* Don't cache errors. */\n  if (fd < 0)\n    return NULL;\n\n  /* Store new cache entry */\n  entry = new_cached_dirfd (dir, name, fd);\n  insert_cached_dirfd (entry, keepfd);\n\nout:\n  return entry;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct cached_dirfd",
        "struct",
        "cached_dirfd",
        "*openat_cached (struct cached_dirfd *dir, const char *name, int keepfd)",
        "*"
      ]
    },
    "count_path_components": {
      "start_point": [
        246,
        16
      ],
      "end_point": [
        262,
        1
      ],
      "content": "int count_path_components (const char *path)\n{\n  unsigned int components;\n\n  while (ISSLASH (*path))\n    path++;\n  if (! *path)\n    return 1;\n  for (components = 0; *path; components++)\n    {\n      while (*path && ! ISSLASH (*path))\n\tpath++;\n      while (ISSLASH (*path))\n\tpath++;\n    }\n  return components;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "push_symlink": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static void push_symlink (struct symlink **stack, struct symlink *symlink)\n{\n  symlink->prev = *stack;\n  *stack = symlink;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pop_symlink": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "static void pop_symlink (struct symlink **stack)\n{\n  struct symlink *top = *stack;\n  *stack = top->prev;\n  free (top);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_symlink": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static struct symlink *read_symlink(int dirfd, const char *name)\n{\n  int saved_errno = errno;\n  struct stat st;\n  struct symlink *symlink;\n  char *buffer;\n  ssize_t ret;\n\n  if (fstatat (dirfd, name, &st, AT_SYMLINK_NOFOLLOW)\n      || ! S_ISLNK (st.st_mode))\n    {\n      errno = saved_errno;\n      return NULL;\n    }\n  symlink = xmalloc (sizeof (*symlink) + st.st_size + 1);\n  buffer = (char *)(symlink + 1);\n  ret = readlinkat (dirfd, name, buffer, st.st_size);\n  if (ret <= 0)\n    goto fail;\n  buffer[ret] = 0;\n  symlink->path = buffer;\n  if (ISSLASH (*buffer))\n    {\n      char *end;\n\n      if (cwd_stat_errno == -1)\n\t{\n\t  cwd_stat_errno = stat (\".\", &cwd_stat) == 0 ? 0 : errno;\n\t  if (cwd_stat_errno)\n\t    goto fail_exdev;\n\t}\n      end = buffer + ret;\n      for (;;)\n\t{\n\t  char slash;\n\t  int rv;\n\n\t  slash = *end; *end = 0;\n\t  rv = stat (symlink->path, &st);\n\t  *end = slash;\n\n\t  if (rv == 0\n\t      && st.st_dev == cwd_stat.st_dev\n\t      && st.st_ino == cwd_stat.st_ino)\n\t    {\n\t      while (ISSLASH (*end))\n\t\tend++;\n\t      symlink->path = end;\n\t      return symlink;\n\t    }\n\t  end--;\n\t  if (end == symlink->path)\n\t    break;\n\t  while (end != symlink->path + 1 && ! ISSLASH (*end))\n\t    end--;\n\t  while (end != symlink->path + 1 && ISSLASH (*(end - 1)))\n\t    end--;\n\t}\n      goto fail_exdev;\n    }\n  return symlink;\n\nfail_exdev:\n  errno = EXDEV;\nfail:\n  free (symlink);\n  return NULL;\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "struct symlink",
        "struct",
        "symlink",
        "*read_symlink(int dirfd, const char *name)",
        "*"
      ]
    },
    "traverse_next": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "static struct cached_dirfd *\ntraverse_next (struct cached_dirfd *dir, const char **path, int keepfd,\n\t       struct symlink **symlink)\n{\n  const char *p = *path;\n  struct cached_dirfd *entry = dir;\n  char *name;\n\n  while (*p && ! ISSLASH (*p))\n    p++;\n  if (**path == '.' && *path + 1 == p)\n    goto skip;\n  if (**path == '.' && *(*path + 1) == '.' && *path + 2 == p)\n    {\n      entry = dir->parent;\n      if (! entry)\n\t{\n\t  /* Must not leave the working tree. */\n\t  errno = EXDEV;\n\t  goto out;\n\t}\n      assert (list_empty (&dir->lru_link));\n      list_add (&dir->lru_link, &lru_list);\n      goto skip;\n    }\n  name = alloca (p - *path + 1);\n  memcpy(name, *path, p - *path);\n  name[p - *path] = 0;\n\n  entry = openat_cached (dir, name, keepfd);\n  if (! entry)\n    {\n      if (errno == ELOOP\n\t  || errno == EMLINK  /* FreeBSD 10.1: Too many links */\n\t  || errno == EFTYPE  /* NetBSD 6.1: Inappropriate file type or format */\n\t  || errno == ENOTDIR)\n\t{\n\t  if ((*symlink = read_symlink (dir->fd, name)))\n\t    {\n\t      entry = dir;\n\t      goto skip;\n\t    }\n\t  errno = ELOOP;\n\t}\n      goto out;\n    }\nskip:\n  while (ISSLASH (*p))\n    p++;\nout:\n  *path = p;\n  return entry;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "struct cached_dirfd",
        "struct",
        "cached_dirfd",
        "*\ntraverse_next (struct cached_dirfd *dir, const char **path, int keepfd,\n\t       struct symlink **symlink)",
        "*"
      ]
    },
    "traverse_another_path": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "static int traverse_another_path (const char **pathname, int keepfd)\n{\n  static struct cached_dirfd cwd = {\n    .fd = AT_FDCWD,\n  };\n\n  unsigned int misses = dirfd_cache_misses;\n  const char *path = *pathname, *last;\n  struct cached_dirfd *dir = &cwd;\n  struct symlink *stack = NULL;\n  unsigned int steps = count_path_components (path);\n  struct cached_dirfd *traversed_symlink = NULL;\n\n  INIT_LIST_HEAD (&cwd.children);\n\n  if (steps > MAX_PATH_COMPONENTS)\n    {\n      errno = ELOOP;\n      return -1;\n    }\n\n  if (! *path || IS_ABSOLUTE_FILE_NAME (path))\n    return AT_FDCWD;\n\n  /* Find the last pathname component */\n  last = strrchr (path, 0) - 1;\n  if (ISSLASH (*last))\n    {\n      while (last != path)\n\tif (! ISSLASH (*--last))\n\t  break;\n    }\n  while (last != path && ! ISSLASH (*(last - 1)))\n    last--;\n  if (last == path)\n    return AT_FDCWD;\n\n  if (debug & 32)\n    printf (\"Resolving path \\\"%.*s\\\"\", (int) (last - path), path);\n\n  while (stack || path != last)\n    {\n      struct cached_dirfd *entry;\n      struct symlink *symlink = NULL;\n      const char *prev = path;\n\n      entry = traverse_next (dir, stack ? &stack->path : &path, keepfd, &symlink);\n      if (! entry)\n\t{\n\t  if (debug & 32)\n\t    {\n\t      printf (\" (failed)\\n\");\n\t      fflush (stdout);\n\t    }\n\t  goto fail;\n\t}\n      dir = entry;\n      if (! stack && symlink)\n\t{\n\t  const char *p = prev;\n\t  char *name;\n\n\t  while (*p && ! ISSLASH (*p))\n\t    p++;\n\t  name = alloca (p - prev + 1);\n\t  memcpy (name, prev, p - prev);\n\t  name[p - prev] = 0;\n\n\t  traversed_symlink = new_cached_dirfd (dir, name, -1);\n\t}\n      if (stack && ! *stack->path)\n\tpop_symlink (&stack);\n      if (symlink && *symlink->path)\n\t{\n\t  push_symlink (&stack, symlink);\n\t  steps += count_path_components (symlink->path);\n\t  if (steps > MAX_PATH_COMPONENTS)\n\t    {\n\t      errno = ELOOP;\n\t      goto fail;\n\t    }\n\t}\n      else if (symlink)\n\tpop_symlink (&symlink);\n      if (traversed_symlink && ! stack)\n\t{\n\t  traversed_symlink->fd =\n\t    entry->fd == AT_FDCWD ? AT_FDCWD : dup (entry->fd);\n\t  if (traversed_symlink->fd != -1)\n\t    {\n\t      insert_cached_dirfd (traversed_symlink, keepfd);\n\t      list_add (&traversed_symlink->lru_link, &lru_list);\n\t    }\n\t  else\n\t    free_cached_dirfd (traversed_symlink);\n\t  traversed_symlink = NULL;\n\t}\n    }\n  *pathname = last;\n  if (debug & 32)\n    {\n      misses = (signed int) dirfd_cache_misses - (signed int) misses;\n      if (! misses)\n\tprintf(\" (cached)\\n\");\n      else\n\tprintf (\" (%u miss%s)\\n\", misses, misses == 1 ? \"\" : \"es\");\n      fflush (stdout);\n    }\n  return put_path (dir);\n\nfail:\n  if (traversed_symlink)\n    free_cached_dirfd (traversed_symlink);\n  put_path (dir);\n  while (stack)\n    pop_symlink (&stack);\n  return -1;\n}",
      "lines": 118,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "traverse_path": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "static int traverse_path (const char **pathname)\n{\n  return traverse_another_path (pathname, -1);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "safe_xstat": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        557,
        1
      ],
      "content": "static int safe_xstat (const char *pathname, struct stat *buf, int flags)\n{\n  int dirfd;\n\n  if (unsafe)\n    return fstatat (AT_FDCWD, pathname, buf, flags);\n\n  dirfd = traverse_path (&pathname);\n  if (dirfd < 0 && dirfd != AT_FDCWD)\n    return dirfd;\n  return fstatat (dirfd, pathname, buf, flags);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "safe_stat": {
      "start_point": [
        560,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "int safe_stat (const char *pathname, struct stat *buf)\n{\n  return safe_xstat (pathname, buf, 0);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "safe_lstat": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        569,
        1
      ],
      "content": "int safe_lstat (const char *pathname, struct stat *buf)\n{\n  return safe_xstat (pathname, buf, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "safe_open": {
      "start_point": [
        572,
        0
      ],
      "end_point": [
        583,
        1
      ],
      "content": "int safe_open (const char *pathname, int flags, mode_t mode)\n{\n  int dirfd;\n\n  if (unsafe)\n    return open (pathname, flags, mode);\n\n  dirfd = traverse_path (&pathname);\n  if (dirfd < 0 && dirfd != AT_FDCWD)\n    return dirfd;\n  return openat (dirfd, pathname, flags, mode);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "safe_rename": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        609,
        1
      ],
      "content": "int safe_rename (const char *oldpath, const char *newpath)\n{\n  int olddirfd, newdirfd;\n  int ret;\n\n  if (unsafe)\n    return rename (oldpath, newpath);\n\n  olddirfd = traverse_path (&oldpath);\n  if (olddirfd < 0 && olddirfd != AT_FDCWD)\n    return olddirfd;\n\n  newdirfd = traverse_another_path (&newpath, olddirfd);\n  if (newdirfd < 0 && newdirfd != AT_FDCWD)\n    return newdirfd;\n\n  ret = renameat (olddirfd, oldpath, newdirfd, newpath);\n  if (! ret)\n    {\n      invalidate_cached_dirfd (olddirfd, oldpath);\n      invalidate_cached_dirfd (newdirfd, newpath);\n    }\n  return ret;\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "safe_mkdir": {
      "start_point": [
        612,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "int safe_mkdir (const char *pathname, mode_t mode)\n{\n  int dirfd;\n\n  if (unsafe)\n    return mkdir (pathname, mode);\n\n  dirfd = traverse_path (&pathname);\n  if (dirfd < 0 && dirfd != AT_FDCWD)\n    return dirfd;\n  return mkdirat (dirfd, pathname, mode);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "safe_rmdir": {
      "start_point": [
        626,
        0
      ],
      "end_point": [
        642,
        1
      ],
      "content": "int safe_rmdir (const char *pathname)\n{\n  int dirfd;\n  int ret;\n\n  if (unsafe)\n    return rmdir (pathname);\n\n  dirfd = traverse_path (&pathname);\n  if (dirfd < 0 && dirfd != AT_FDCWD)\n    return dirfd;\n\n  ret = unlinkat (dirfd, pathname, AT_REMOVEDIR);\n  if (! ret)\n    invalidate_cached_dirfd (dirfd, pathname);\n  return ret;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "safe_unlink": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "int safe_unlink (const char *pathname)\n{\n  int dirfd;\n\n  if (unsafe)\n    return unlink (pathname);\n\n  dirfd = traverse_path (&pathname);\n  if (dirfd < 0 && dirfd != AT_FDCWD)\n    return dirfd;\n  return unlinkat (dirfd, pathname, 0);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "safe_symlink": {
      "start_point": [
        659,
        0
      ],
      "end_point": [
        670,
        1
      ],
      "content": "int safe_symlink (const char *target, const char *linkpath)\n{\n  int dirfd;\n\n  if (unsafe)\n    return symlink (target, linkpath);\n\n  dirfd = traverse_path (&linkpath);\n  if (dirfd < 0 && dirfd != AT_FDCWD)\n    return dirfd;\n  return symlinkat (target, dirfd, linkpath);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "safe_chmod": {
      "start_point": [
        673,
        0
      ],
      "end_point": [
        684,
        1
      ],
      "content": "int safe_chmod (const char *pathname, mode_t mode)\n{\n  int dirfd;\n\n  if (unsafe)\n    return chmod (pathname, mode);\n\n  dirfd = traverse_path (&pathname);\n  if (dirfd < 0 && dirfd != AT_FDCWD)\n    return dirfd;\n  return fchmodat (dirfd, pathname, mode, 0);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "safe_lchown": {
      "start_point": [
        687,
        0
      ],
      "end_point": [
        698,
        1
      ],
      "content": "int safe_lchown (const char *pathname, uid_t owner, gid_t group)\n{\n  int dirfd;\n\n  if (unsafe)\n    return lchown (pathname, owner, group);\n\n  dirfd = traverse_path (&pathname);\n  if (dirfd < 0 && dirfd != AT_FDCWD)\n    return dirfd;\n  return fchownat (dirfd, pathname, owner, group, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "safe_lutimens": {
      "start_point": [
        701,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "int safe_lutimens (const char *pathname, struct timespec const times[2])\n{\n  int dirfd;\n\n  if (unsafe)\n    return utimensat (AT_FDCWD, pathname, times, AT_SYMLINK_NOFOLLOW);\n\n  dirfd = traverse_path (&pathname);\n  if (dirfd < 0 && dirfd != AT_FDCWD)\n    return dirfd;\n  return utimensat (dirfd, pathname, times, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "safe_readlink": {
      "start_point": [
        715,
        0
      ],
      "end_point": [
        726,
        1
      ],
      "content": "ssize_t safe_readlink (const char *pathname, char *buf, size_t bufsiz)\n{\n  int dirfd;\n\n  if (unsafe)\n    return readlink (pathname, buf, bufsiz);\n\n  dirfd = traverse_path (&pathname);\n  if (dirfd < 0 && dirfd != AT_FDCWD)\n    return dirfd;\n  return readlinkat (dirfd, pathname, buf, bufsiz);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "ssize_t"
      ]
    },
    "safe_access": {
      "start_point": [
        729,
        0
      ],
      "end_point": [
        740,
        1
      ],
      "content": "int safe_access (const char *pathname, int mode)\n{\n  int dirfd;\n\n  if (unsafe)\n    return access (pathname, mode);\n\n  dirfd = traverse_path (&pathname);\n  if (dirfd < 0 && dirfd != AT_FDCWD)\n    return dirfd;\n  return faccessat (dirfd, pathname, mode, 0);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "patch/patch-2.7.6/src/safe.h": {},
  "patch/patch-2.7.6/src/util.c": {
    "file_id_hasher": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static size_t\nfile_id_hasher (void const *entry, size_t table_size)\n{\n  file_id const *e = entry;\n  size_t i = e->ino + e->dev;\n  return i % table_size;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "file_id_comparator": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static bool\nfile_id_comparator (void const *entry1, void const *entry2)\n{\n  file_id const *e1 = entry1;\n  file_id const *e2 = entry2;\n  return (e1->ino == e2->ino && e1->dev == e2->dev);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "init_backup_hash_table": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\ninit_backup_hash_table (void)\n{\n  file_id_table = hash_initialize (0, NULL, file_id_hasher,\n\t\t\t\t   file_id_comparator, free);\n  if (!file_id_table)\n    xalloc_die ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "__insert_file_id": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static file_id *\n__insert_file_id (struct stat const *st, enum file_id_type type)\n{\n   file_id *p;\n   static file_id *next_slot;\n\n   if (!next_slot)\n     next_slot = xmalloc (sizeof *next_slot);\n   next_slot->dev = st->st_dev;\n   next_slot->ino = st->st_ino;\n   next_slot->queued_output = false;\n   p = hash_insert (file_id_table, next_slot);\n   if (!p)\n     xalloc_die ();\n   if (p == next_slot)\n     next_slot = NULL;\n   p->type = type;\n   return p;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "file_id",
        "*\n__insert_file_id (struct stat const *st, enum file_id_type type)",
        "*"
      ]
    },
    "__lookup_file_id": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static file_id *\n__lookup_file_id (struct stat const *st)\n{\n  file_id f;\n\n  f.dev = st->st_dev;\n  f.ino = st->st_ino;\n  return hash_lookup (file_id_table, &f);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "file_id",
        "*\n__lookup_file_id (struct stat const *st)",
        "*"
      ]
    },
    "insert_file_id": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\ninsert_file_id (struct stat const *st, enum file_id_type type)\n{\n  __insert_file_id (st, type);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lookup_file_id": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "enum file_id_type\nlookup_file_id (struct stat const *st)\n{\n  file_id *p = __lookup_file_id (st);\n\n  return p ? p->type : UNKNOWN;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "enum file_id_type",
        "enum",
        "file_id_type"
      ]
    },
    "set_queued_output": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void\nset_queued_output (struct stat const *st, bool queued_output)\n{\n  file_id *p = __lookup_file_id (st);\n\n  if (! p)\n    p = __insert_file_id (st, UNKNOWN);\n  p->queued_output = queued_output;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "has_queued_output": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "bool\nhas_queued_output (struct stat const *st)\n{\n  file_id *p = __lookup_file_id (st);\n\n  return p && p->queued_output;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "contains_slash": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static bool _GL_ATTRIBUTE_PURE\ncontains_slash (const char *s)\n{\n  for (; *s; s++)\n    if (ISSLASH(*s))\n      return true;\n  return false;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "copy_attr_error": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static void\ncopy_attr_error (struct error_context *ctx, char const *fmt, ...)\n{\n  int err = errno;\n  va_list ap;\n\n  if (err != ENOSYS && err != ENOTSUP && err != EPERM)\n    {\n      /* use verror module to print error message */\n      va_start (ap, fmt);\n      verror (0, err, fmt, ap);\n      va_end (ap);\n    }\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copy_attr_quote": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static char const *\ncopy_attr_quote (struct error_context *ctx, char const *str)\n{\n  return quotearg (str);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ncopy_attr_quote (struct error_context *ctx, char const *str)",
        "*"
      ]
    },
    "copy_attr_free": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static void\ncopy_attr_free (struct error_context *ctx, char const *str)\n{\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copy_attr_check": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "static int\ncopy_attr_check (const char *name, struct error_context *ctx)\n{\n\tint action = attr_copy_action (name, ctx);\n\treturn action == 0 || action == ATTR_ACTION_PERMISSIONS;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "copy_attr": [
      {
        "start_point": [
          211,
          0
        ],
        "end_point": [
          224,
          1
        ],
        "content": "static int\ncopy_attr (char const *src_path, char const *dst_path)\n{\n  struct error_context ctx =\n  {\n    .error = copy_attr_error,\n    .quote = copy_attr_quote,\n    .quote_free = copy_attr_free\n  };\n  /* FIXME: We are copying between files we know we can safely access by\n   * pathname. A safe_ version of attr_copy_file() might still be slightly\n   * more efficient for deep paths. */\n  return attr_copy_file (src_path, dst_path, copy_attr_check, &ctx);\n}",
        "lines": 14,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          228,
          0
        ],
        "end_point": [
          232,
          1
        ],
        "content": "static int\ncopy_attr (char const *src_path, char const *dst_path)\n{\n  return 0;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "set_file_attributes": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "void\nset_file_attributes (char const *to, enum file_attributes attr,\n\t\t     char const *from, const struct stat *st, mode_t mode,\n\t\t     struct timespec *new_time)\n{\n  if (attr & FA_TIMES)\n    {\n      struct timespec times[2];\n      if (new_time)\n\ttimes[0] = times[1] = *new_time;\n      else\n        {\n\t  times[0] = get_stat_atime (st);\n\t  times[1] = get_stat_mtime (st);\n\t}\n      if (safe_lutimens (to, times) != 0)\n\tpfatal (\"Failed to set the timestamps of %s %s\",\n\t\tS_ISLNK (mode) ? \"symbolic link\" : \"file\",\n\t\tquotearg (to));\n    }\n  if (attr & FA_IDS)\n    {\n      static uid_t euid = -1;\n      static gid_t egid = -1;\n      uid_t uid;\n      uid_t gid;\n\n      if (euid == -1)\n        {\n\t  euid = geteuid ();\n\t  egid = getegid ();\n\t}\n      uid = (euid == st->st_uid) ? -1 : st->st_uid;\n      gid = (egid == st->st_gid) ? -1 : st->st_gid;\n\n      /* May fail if we are not privileged to set the file owner, or we are\n         not in group instat.st_gid.  Ignore those errors.  */\n      if ((uid != -1 || gid != -1)\n\t  && safe_lchown (to, uid, gid) != 0\n\t  && (errno != EPERM\n\t      || (uid != -1\n\t\t  && safe_lchown (to, (uid = -1), gid) != 0\n\t\t  && errno != EPERM)))\n\tpfatal (\"Failed to set the %s of %s %s\",\n\t\t(uid == -1) ? \"owner\" : \"owning group\",\n\t\tS_ISLNK (mode) ? \"symbolic link\" : \"file\",\n\t\tquotearg (to));\n    }\n  if (attr & FA_XATTRS)\n    if (copy_attr (from, to) != 0\n\t&& errno != ENOSYS && errno != ENOTSUP && errno != EPERM)\n      fatal_exit (0);\n  if (attr & FA_MODE)\n    {\n#if 0 && defined HAVE_LCHMOD\n      /* The \"diff --git\" format does not store the file permissions of\n\t symlinks, so don't try to set symlink file permissions even on\n\t systems where we could.  */\n      if (lchmod (to, mode))\n#else\n      if (! S_ISLNK (mode) && safe_chmod (to, mode) != 0)\n#endif\n\tpfatal (\"Failed to set the permissions of %s %s\",\n\t\tS_ISLNK (mode) ? \"symbolic link\" : \"file\",\n\t\tquotearg (to));\n    }\n}",
      "lines": 67,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "create_backup_copy": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "static void\ncreate_backup_copy (char const *from, char const *to, const struct stat *st,\n\t\t    bool to_dir_known_to_exist)\n{\n  copy_file (from, to, NULL, 0, st->st_mode, to_dir_known_to_exist);\n  set_file_attributes (to, FA_TIMES | FA_IDS | FA_MODE, from, st, st->st_mode, NULL);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_backup": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "void\ncreate_backup (char const *to, const struct stat *to_st, bool leave_original)\n{\n  /* When the input to patch modifies the same file more than once, patch only\n     backs up the initial version of each file.\n\n     To figure out which files have already been backed up, patch remembers the\n     files that replace the original files.  Files not known already are backed\n     up; files already known have already been backed up before, and are\n     skipped.\n\n     When a patch tries to delete a file, in order to not break the above\n     logic, we merely remember which file to delete.  After the entire patch\n     file has been read, we delete all files marked for deletion which have not\n     been recreated in the meantime.  */\n\n  if (to_st && ! (S_ISREG (to_st->st_mode) || S_ISLNK (to_st->st_mode)))\n    fatal (\"File %s is not a %s -- refusing to create backup\",\n\t   to, S_ISLNK (to_st->st_mode) ? \"symbolic link\" : \"regular file\");\n\n  if (to_st && lookup_file_id (to_st) == CREATED)\n    {\n      if (debug & 4)\n\tsay (\"File %s already seen\\n\", quotearg (to));\n    }\n  else\n    {\n      int try_makedirs_errno = 0;\n      char *bakname;\n\n      if (origprae || origbase || origsuff)\n\t{\n\t  char const *p = origprae ? origprae : \"\";\n\t  char const *b = origbase ? origbase : \"\";\n\t  char const *s = origsuff ? origsuff : \"\";\n\t  char const *t = to;\n\t  size_t plen = strlen (p);\n\t  size_t blen = strlen (b);\n\t  size_t slen = strlen (s);\n\t  size_t tlen = strlen (t);\n\t  char const *o;\n\t  size_t olen;\n\n\t  for (o = t + tlen, olen = 0;\n\t       o > t && ! ISSLASH (*(o - 1));\n\t       o--)\n\t    /* do nothing */ ;\n\t  olen = t + tlen - o;\n\t  tlen -= olen;\n\t  bakname = xmalloc (plen + tlen + blen + olen + slen + 1);\n\t  memcpy (bakname, p, plen);\n\t  memcpy (bakname + plen, t, tlen);\n\t  memcpy (bakname + plen + tlen, b, blen);\n\t  memcpy (bakname + plen + tlen + blen, o, olen);\n\t  memcpy (bakname + plen + tlen + blen + olen, s, slen + 1);\n\n\t  if ((origprae\n\t       && (contains_slash (origprae + FILE_SYSTEM_PREFIX_LEN (origprae))\n\t\t   || contains_slash (to)))\n\t      || (origbase && contains_slash (origbase)))\n\t    try_makedirs_errno = ENOENT;\n\t}\n      else\n\t{\n\t  bakname = find_backup_file_name (to, backup_type);\n\t  if (!bakname)\n\t    xalloc_die ();\n\t}\n\n      if (! to_st)\n\t{\n\t  int fd;\n\n\t  if (debug & 4)\n\t    say (\"Creating empty file %s\\n\", quotearg (bakname));\n\n\t  try_makedirs_errno = ENOENT;\n\t  safe_unlink (bakname);\n\t  while ((fd = safe_open (bakname, O_CREAT | O_WRONLY | O_TRUNC, 0666)) < 0)\n\t    {\n\t      if (errno != try_makedirs_errno)\n\t\tpfatal (\"Can't create file %s\", quotearg (bakname));\n\t      makedirs (bakname);\n\t      try_makedirs_errno = 0;\n\t    }\n\t  if (close (fd) != 0)\n\t    pfatal (\"Can't close file %s\", quotearg (bakname));\n\t}\n      else if (leave_original)\n\tcreate_backup_copy (to, bakname, to_st, try_makedirs_errno == 0);\n      else\n\t{\n\t  if (debug & 4)\n\t    say (\"Renaming file %s to %s\\n\",\n\t\t quotearg_n (0, to), quotearg_n (1, bakname));\n\t  while (safe_rename (to, bakname) != 0)\n\t    {\n\t      if (errno == try_makedirs_errno)\n\t\t{\n\t\t  makedirs (bakname);\n\t\t  try_makedirs_errno = 0;\n\t\t}\n\t      else if (errno == EXDEV)\n\t\t{\n\t\t  create_backup_copy (to, bakname, to_st,\n\t\t\t\t      try_makedirs_errno == 0);\n\t\t  safe_unlink (to);\n\t\t  break;\n\t\t}\n\t      else\n\t\tpfatal (\"Can't rename file %s to %s\",\n\t\t\tquotearg_n (0, to), quotearg_n (1, bakname));\n\t    }\n\t}\n      free (bakname);\n    }\n}",
      "lines": 117,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "move_file": {
      "start_point": [
        440,
        0
      ],
      "end_point": [
        546,
        1
      ],
      "content": "void\nmove_file (char const *from, bool *from_needs_removal,\n\t   struct stat const *fromst,\n\t   char const *to, mode_t mode, bool backup)\n{\n  struct stat to_st;\n  int to_errno;\n\n  to_errno = stat_file (to, &to_st);\n  if (backup)\n    create_backup (to, to_errno ? NULL : &to_st, false);\n  if (! to_errno)\n    insert_file_id (&to_st, OVERWRITTEN);\n\n  if (from)\n    {\n      if (S_ISLNK (mode))\n\t{\n\t  bool to_dir_known_to_exist = false;\n\n\t  /* FROM contains the contents of the symlink we have patched; need\n\t     to convert that back into a symlink. */\n\t  char *buffer = xmalloc (PATH_MAX);\n\t  int fd, size = 0, i;\n\n\t  if ((fd = safe_open (from, O_RDONLY | O_BINARY, 0)) < 0)\n\t    pfatal (\"Can't reopen file %s\", quotearg (from));\n\t  while ((i = read (fd, buffer + size, PATH_MAX - size)) > 0)\n\t    size += i;\n\t  if (i != 0 || close (fd) != 0)\n\t    read_fatal ();\n\t  buffer[size] = 0;\n\n\t  if (! backup)\n\t    {\n\t      if (safe_unlink (to) == 0)\n\t\tto_dir_known_to_exist = true;\n\t    }\n\t  if (safe_symlink (buffer, to) != 0)\n\t    {\n\t      if (errno == ENOENT && ! to_dir_known_to_exist)\n\t\tmakedirs (to);\n\t      if (safe_symlink (buffer, to) != 0)\n\t\tpfatal (\"Can't create %s %s\", \"symbolic link\", to);\n\t    }\n\t  free (buffer);\n\t  if (safe_lstat (to, &to_st) != 0)\n\t    pfatal (\"Can't get file attributes of %s %s\", \"symbolic link\", to);\n\t  insert_file_id (&to_st, CREATED);\n\t}\n      else\n\t{\n\t  if (debug & 4)\n\t    say (\"Renaming file %s to %s\\n\",\n\t\t quotearg_n (0, from), quotearg_n (1, to));\n\n\t  if (safe_rename (from, to) != 0)\n\t    {\n\t      bool to_dir_known_to_exist = false;\n\n\t      if (errno == ENOENT\n\t\t  && (to_errno == -1 || to_errno == ENOENT))\n\t\t{\n\t\t  makedirs (to);\n\t\t  to_dir_known_to_exist = true;\n\t\t  if (safe_rename (from, to) == 0)\n\t\t    goto rename_succeeded;\n\t\t}\n\n\t      if (errno == EXDEV)\n\t\t{\n\t\t  struct stat tost;\n\t\t  if (! backup)\n\t\t    {\n\t\t      if (safe_unlink (to) == 0)\n\t\t\tto_dir_known_to_exist = true;\n\t\t      else if (errno != ENOENT)\n\t\t\tpfatal (\"Can't remove file %s\", quotearg (to));\n\t\t    }\n\t\t  copy_file (from, to, &tost, 0, mode, to_dir_known_to_exist);\n\t\t  insert_file_id (&tost, CREATED);\n\t\t  return;\n\t\t}\n\n\t      pfatal (\"Can't rename file %s to %s\",\n\t\t      quotearg_n (0, from), quotearg_n (1, to));\n\t    }\n\n\trename_succeeded:\n\t  insert_file_id (fromst, CREATED);\n\t  /* Do not clear *FROM_NEEDS_REMOVAL if it's possible that the\n\t     rename returned zero because FROM and TO are hard links to\n\t     the same file.  */\n\t  if ((0 < to_errno\n\t       || (to_errno == 0 && to_st.st_nlink <= 1))\n\t      && from_needs_removal)\n\t    *from_needs_removal = false;\n\t}\n    }\n  else if (! backup)\n    {\n      if (debug & 4)\n\tsay (\"Removing file %s\\n\", quotearg (to));\n      if (safe_unlink (to) != 0 && errno != ENOENT)\n\tpfatal (\"Can't remove file %s\", quotearg (to));\n    }\n}",
      "lines": 107,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "create_file": {
      "start_point": [
        551,
        0
      ],
      "end_point": [
        576,
        1
      ],
      "content": "int\ncreate_file (char const *file, int open_flags, mode_t mode,\n\t     bool to_dir_known_to_exist)\n{\n  int try_makedirs_errno = to_dir_known_to_exist ? 0 : ENOENT;\n  int fd;\n  mode |= S_IRUSR | S_IWUSR;\n  mode &= ~ (S_IXUSR | S_IXGRP | S_IXOTH);\n  do\n    {\n      if (! (O_CREAT && O_TRUNC))\n\tclose (safe_open (file, O_CREAT | O_WRONLY | O_TRUNC, mode));\n      fd = safe_open (file, O_CREAT | O_TRUNC | open_flags, mode);\n      if (fd < 0)\n\t{\n\t  char *f;\n\t  if (errno != try_makedirs_errno)\n\t    pfatal (\"Can't create file %s\", quotearg (file));\n\t  f = xstrdup (file);\n\t  makedirs (f);\n\t  free (f);\n\t  try_makedirs_errno = 0;\n\t}\n    } while (fd < 0);\n  return fd;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "copy_to_fd": {
      "start_point": [
        578,
        0
      ],
      "end_point": [
        595,
        1
      ],
      "content": "static void\ncopy_to_fd (const char *from, int tofd)\n{\n  int fromfd;\n  ssize_t i;\n\n  if ((fromfd = safe_open (from, O_RDONLY | O_BINARY, 0)) < 0)\n    pfatal (\"Can't reopen file %s\", quotearg (from));\n  while ((i = read (fromfd, buf, bufsize)) != 0)\n    {\n      if (i == (ssize_t) -1)\n\tread_fatal ();\n      if (full_write (tofd, buf, i) != i)\n\twrite_fatal ();\n    }\n  if (close (fromfd) != 0)\n    read_fatal ();\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copy_file": {
      "start_point": [
        599,
        0
      ],
      "end_point": [
        635,
        1
      ],
      "content": "void\ncopy_file (char const *from, char const *to, struct stat *tost,\n\t   int to_flags, mode_t mode, bool to_dir_known_to_exist)\n{\n  int tofd;\n\n  if (debug & 4)\n    say (\"Copying %s %s to %s\\n\",\n\t S_ISLNK (mode) ? \"symbolic link\" : \"file\",\n\t quotearg_n (0, from), quotearg_n (1, to));\n\n  if (S_ISLNK (mode))\n    {\n      char *buffer = xmalloc (PATH_MAX + 1);\n      ssize_t r;\n\n      if ((r = safe_readlink (from, buffer, PATH_MAX)) < 0)\n\tpfatal (\"Can't read %s %s\", \"symbolic link\", from);\n      buffer[r] = '\\0';\n      if (safe_symlink (buffer, to) != 0)\n\tpfatal (\"Can't create %s %s\", \"symbolic link\", to);\n      if (tost && safe_lstat (to, tost) != 0)\n\tpfatal (\"Can't get file attributes of %s %s\", \"symbolic link\", to);\n      free (buffer);\n    }\n  else\n    {\n      assert (S_ISREG (mode));\n      tofd = create_file (to, O_WRONLY | O_BINARY | to_flags, mode,\n\t\t\t  to_dir_known_to_exist);\n      copy_to_fd (from, tofd);\n      if (tost && fstat (tofd, tost) != 0)\n\tpfatal (\"Can't get file attributes of %s %s\", \"file\", to);\n      if (close (tofd) != 0)\n\twrite_fatal ();\n    }\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "append_to_file": {
      "start_point": [
        639,
        0
      ],
      "end_point": [
        649,
        1
      ],
      "content": "void\nappend_to_file (char const *from, char const *to)\n{\n  int tofd;\n\n  if ((tofd = safe_open (to, O_WRONLY | O_BINARY | O_APPEND, 0)) < 0)\n    pfatal (\"Can't reopen file %s\", quotearg (to));\n  copy_to_fd (from, tofd);\n  if (close (tofd) != 0)\n    write_fatal ();\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "quote_system_arg": {
      "start_point": [
        668,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "static size_t\nquote_system_arg (char *quoted, char const *arg)\n{\n  char *q = quotearg_style (shell_quoting_style, arg);\n  size_t len = strlen (q);\n\n  if (quoted)\n    memcpy (quoted, q, len + 1);\n  return len;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "version_controller": {
      "start_point": [
        690,
        0
      ],
      "end_point": [
        811,
        1
      ],
      "content": "char const *\nversion_controller (char const *filename, bool readonly,\n\t\t    struct stat const *filestat, char **getbuf, char **diffbuf)\n{\n  struct stat cstat;\n  char *dir = dir_name (filename);\n  char *filebase = base_name (filename);\n  char const *dotslash = *filename == '-' ? \"./\" : \"\";\n  size_t dirlen = strlen (dir) + 1;\n  size_t maxfixlen = sizeof \"SCCS/\" - 1 + sizeof SCCSPREFIX - 1;\n  size_t maxtrysize = dirlen + strlen (filebase) + maxfixlen + 1;\n  size_t quotelen = quote_system_arg (0, dir) + quote_system_arg (0, filebase);\n  size_t maxgetsize = sizeof CLEARTOOL_CO + quotelen + maxfixlen;\n  size_t maxdiffsize =\n    (sizeof SCCSDIFF1 + sizeof SCCSDIFF2 + sizeof DEV_NULL - 1\n     + 2 * quotelen + maxfixlen);\n  char *trybuf = xmalloc (maxtrysize);\n  char const *r = 0;\n\n  sprintf (trybuf, \"%s/\", dir);\n\n#define try1(f,a1)    (sprintf (trybuf + dirlen, f, a1),    safe_stat (trybuf, &cstat) == 0)\n#define try2(f,a1,a2) (sprintf (trybuf + dirlen, f, a1,a2), safe_stat (trybuf, &cstat) == 0)\n\n  /* Check that RCS file is not working file.\n     Some hosts don't report file name length errors.  */\n\n  if ((try2 (\"RCS/%s%s\", filebase, RCSSUFFIX)\n       || try1 (\"RCS/%s\", filebase)\n       || try2 (\"%s%s\", filebase, RCSSUFFIX))\n      && ! (filestat\n\t    && filestat->st_dev == cstat.st_dev\n\t    && filestat->st_ino == cstat.st_ino))\n    {\n      if (getbuf)\n\t{\n\t  char *p = *getbuf = xmalloc (maxgetsize);\n\t  sprintf (p, readonly ? CHECKOUT : CHECKOUT_LOCKED, dotslash);\n\t  p += strlen (p);\n\t  p += quote_system_arg (p, filename);\n\t  *p = '\\0';\n\t}\n\n      if (diffbuf)\n\t{\n\t  char *p = *diffbuf = xmalloc (maxdiffsize);\n\t  sprintf (p, RCSDIFF1, dotslash);\n\t  p += strlen (p);\n\t  p += quote_system_arg (p, filename);\n\t  *p++ = '>';\n\t  strcpy (p, DEV_NULL);\n\t}\n\n      r = \"RCS\";\n    }\n  else if (try2 (\"SCCS/%s%s\", SCCSPREFIX, filebase)\n\t   || try2 (\"%s%s\", SCCSPREFIX, filebase))\n    {\n      if (getbuf)\n\t{\n\t  char *p = *getbuf = xmalloc (maxgetsize);\n\t  sprintf (p, readonly ? GET : GET_LOCKED);\n\t  p += strlen (p);\n\t  p += quote_system_arg (p, trybuf);\n\t  *p = '\\0';\n\t}\n\n      if (diffbuf)\n\t{\n\t  char *p = *diffbuf = xmalloc (maxdiffsize);\n\t  strcpy (p, SCCSDIFF1);\n\t  p += sizeof SCCSDIFF1 - 1;\n\t  p += quote_system_arg (p, trybuf);\n\t  sprintf (p, SCCSDIFF2, dotslash);\n\t  p += strlen (p);\n\t  p += quote_system_arg (p, filename);\n\t  *p++ = '>';\n\t  strcpy (p, DEV_NULL);\n\t}\n\n      r = \"SCCS\";\n    }\n  else if (!readonly && filestat\n\t   && try1 (\"%s@@\", filebase) && S_ISDIR (cstat.st_mode))\n    {\n      if (getbuf)\n\t{\n\t  char *p = *getbuf = xmalloc (maxgetsize);\n\t  strcpy (p, CLEARTOOL_CO);\n\t  p += sizeof CLEARTOOL_CO - 1;\n\t  p += quote_system_arg (p, filename);\n\t  *p = '\\0';\n\t}\n\n      if (diffbuf)\n\t*diffbuf = 0;\n\n      r = \"ClearCase\";\n     }\n  else if (!readonly && filestat &&\n           (getenv(\"P4PORT\") || getenv(\"P4USER\") || getenv(\"P4CONFIG\")))\n    {\n      if (getbuf)\n\t{\n\t  char *p = *getbuf = xmalloc (maxgetsize);\n\t  strcpy (p, PERFORCE_CO);\n\t  p += sizeof PERFORCE_CO - 1;\n\t  p += quote_system_arg (p, filename);\n\t  *p = '\\0';\n\t}\n\n      if (diffbuf)\n\t*diffbuf = 0;\n\n      r = \"Perforce\";\n    }\n\n  free (trybuf);\n  free (filebase);\n  free (dir);\n  return r;\n}",
      "lines": 122,
      "depth": 15,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nversion_controller (char const *filename, bool readonly,\n\t\t    struct stat const *filestat, char **getbuf, char **diffbuf)",
        "*"
      ]
    },
    "version_get": {
      "start_point": [
        818,
        0
      ],
      "end_point": [
        848,
        1
      ],
      "content": "bool\nversion_get (char const *filename, char const *cs, bool exists, bool readonly,\n\t     char const *getbuf, struct stat *filestat)\n{\n  if (patch_get < 0)\n    {\n      ask (\"Get file %s from %s%s? [y] \",\n\t   quotearg (filename), cs, readonly ? \"\" : \" with lock\");\n      if (*buf == 'n')\n\treturn 0;\n    }\n\n  if (dry_run)\n    {\n      if (! exists)\n\tfatal (\"can't do dry run on nonexistent version-controlled file %s; invoke '%s' and try again\",\n\t       quotearg (filename), getbuf);\n    }\n  else\n    {\n      if (verbosity == VERBOSE)\n\tsay (\"Getting file %s from %s%s...\\n\", quotearg (filename),\n\t     cs, readonly ? \"\" : \" with lock\");\n      if (systemic (getbuf) != 0)\n\tfatal (\"Can't get file %s from %s\", quotearg (filename), cs);\n      if (safe_stat (filename, filestat) != 0)\n\tpfatal (\"%s\", quotearg (filename));\n    }\n\n  return 1;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "savebuf": {
      "start_point": [
        852,
        0
      ],
      "end_point": [
        871,
        1
      ],
      "content": "char *\nsavebuf (char const *s, size_t size)\n{\n  char *rv;\n\n  if (! size)\n    return NULL;\n\n  rv = malloc (size);\n\n  if (! rv)\n    {\n      if (! using_plan_a)\n\txalloc_die ();\n    }\n  else\n    memcpy (rv, s, size);\n\n  return rv;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsavebuf (char const *s, size_t size)",
        "*"
      ]
    },
    "savestr": {
      "start_point": [
        873,
        0
      ],
      "end_point": [
        877,
        1
      ],
      "content": "char *\nsavestr (char const *s)\n{\n  return savebuf (s, strlen (s) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsavestr (char const *s)",
        "*"
      ]
    },
    "remove_prefix": {
      "start_point": [
        879,
        0
      ],
      "end_point": [
        885,
        1
      ],
      "content": "void\nremove_prefix (char *p, size_t prefixlen)\n{\n  char const *s = p + prefixlen;\n  while ((*p++ = *s++))\n    /* do nothing */ ;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "format_linenum": {
      "start_point": [
        887,
        0
      ],
      "end_point": [
        909,
        1
      ],
      "content": "char *\nformat_linenum (char numbuf[LINENUM_LENGTH_BOUND + 1], lin n)\n{\n  char *p = numbuf + LINENUM_LENGTH_BOUND;\n  *p = '\\0';\n\n  if (n < 0)\n    {\n      do\n\t*--p = '0' - (int) (n % 10);\n      while ((n /= 10) != 0);\n\n      *--p = '-';\n    }\n  else\n    {\n      do\n\t*--p = '0' + (int) (n % 10);\n      while ((n /= 10) != 0);\n    }\n\n  return p;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "char",
        "*\nformat_linenum (char numbuf[LINENUM_LENGTH_BOUND + 1], lin n)",
        "*"
      ]
    },
    "fatal": {
      "start_point": [
        913,
        0
      ],
      "end_point": [
        924,
        1
      ],
      "content": "void\nfatal (char const *format, ...)\n{\n  va_list args;\n  fprintf (stderr, \"%s: **** \", program_name);\n  va_start (args, format);\n  vfprintf (stderr, format, args);\n  va_end (args);\n  putc ('\\n', stderr);\n  fflush (stderr);\n  fatal_exit (0);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "xalloc_die": {
      "start_point": [
        926,
        0
      ],
      "end_point": [
        930,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  fatal (\"out of memory\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "read_fatal": {
      "start_point": [
        932,
        0
      ],
      "end_point": [
        936,
        1
      ],
      "content": "void\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "write_fatal": {
      "start_point": [
        938,
        0
      ],
      "end_point": [
        942,
        1
      ],
      "content": "void\nwrite_fatal (void)\n{\n  pfatal (\"write error\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "pfatal": {
      "start_point": [
        946,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "void\npfatal (char const *format, ...)\n{\n  int errnum = errno;\n  va_list args;\n  fprintf (stderr, \"%s: **** \", program_name);\n  va_start (args, format);\n  vfprintf (stderr, format, args);\n  va_end (args);\n  fflush (stderr); /* perror bypasses stdio on some hosts.  */\n  errno = errnum;\n  perror (\" \");\n  fflush (stderr);\n  fatal_exit (0);\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "vsay": {
      "start_point": [
        964,
        0
      ],
      "end_point": [
        969,
        1
      ],
      "content": "static void\nvsay (char const *format, va_list args)\n{\n  vfprintf (stdout, format, args);\n  fflush (stdout);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "say": {
      "start_point": [
        971,
        0
      ],
      "end_point": [
        978,
        1
      ],
      "content": "void\nsay (char const *format, ...)\n{\n  va_list args;\n  va_start (args, format);\n  vsay (format, args);\n  va_end (args);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "ask": {
      "start_point": [
        982,
        0
      ],
      "end_point": [
        1037,
        1
      ],
      "content": "void\nask (char const *format, ...)\n{\n  static int ttyfd = -2;\n  ssize_t r;\n  va_list args;\n\n  va_start (args, format);\n  vfprintf (stdout, format, args);\n  va_end (args);\n  fflush (stdout);\n\n  if (ttyfd == -2)\n    {\n      /* If standard output is not a tty, don't bother opening /dev/tty,\n\t since it's unlikely that stdout will be seen by the tty user.\n\t The isatty test also works around a bug in GNU Emacs 19.34 under Linux\n\t which makes a call-process 'patch' hang when it reads from /dev/tty.\n\t POSIX.1-2001 XCU line 26599 requires that we read /dev/tty,\n\t though.  */\n      ttyfd = (posixly_correct || isatty (STDOUT_FILENO)\n\t       ? open (TTY_DEVICE, O_RDONLY)\n\t       : -1);\n    }\n\n  if (ttyfd < 0)\n    {\n      /* No terminal at all -- default it.  */\n      printf (\"\\n\");\n      buf[0] = '\\n';\n      buf[1] = '\\0';\n    }\n  else\n    {\n      size_t s = 0;\n      while ((r = read (ttyfd, buf + s, bufsize - 1 - s)) == bufsize - 1 - s\n\t     && buf[bufsize - 2] != '\\n')\n\t{\n\t  s = bufsize - 1;\n\t  bufsize *= 2;\n\t  buf = realloc (buf, bufsize);\n\t  if (!buf)\n\t    xalloc_die ();\n\t}\n      if (r == 0)\n\tprintf (\"EOF\\n\");\n      else if (r < 0)\n\t{\n\t  error (0, errno, \"tty read failed\");\n\t  ignore_value (close (ttyfd));\n\t  ttyfd = -1;\n\t  r = 0;\n\t}\n      buf[s + r] = '\\0';\n    }\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "ok_to_reverse": {
      "start_point": [
        1041,
        0
      ],
      "end_point": [
        1086,
        1
      ],
      "content": "bool\nok_to_reverse (char const *format, ...)\n{\n  bool r = false;\n\n  if (noreverse || ! (force && verbosity == SILENT))\n    {\n      va_list args;\n      va_start (args, format);\n      vsay (format, args);\n      va_end (args);\n    }\n\n  if (noreverse)\n    {\n      say (\"  Skipping patch.\\n\");\n      skip_rest_of_patch = true;\n    }\n  else if (force)\n    {\n      if (verbosity != SILENT)\n\tsay (\"  Applying it anyway.\\n\");\n    }\n  else if (batch)\n    {\n      say (reverse ? \"  Ignoring -R.\\n\" : \"  Assuming -R.\\n\");\n      r = true;\n    }\n  else\n    {\n      ask (reverse ? \"  Ignore -R? [n] \" : \"  Assume -R? [n] \");\n      r = *buf == 'y';\n      if (! r)\n\t{\n\t  ask (\"Apply anyway? [n] \");\n\t  if (*buf != 'y')\n\t    {\n\t      if (verbosity != SILENT)\n\t\tsay (\"Skipping patch.\\n\");\n\t      skip_rest_of_patch = true;\n\t    }\n\t}\n    }\n\n  return r;\n}",
      "lines": 46,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    },
    "fatal_exit_handler": {
      "start_point": [
        1135,
        0
      ],
      "end_point": [
        1140,
        1
      ],
      "content": "static void\nfatal_exit_handler (int sig)\n{\n  signal (sig, SIG_IGN);\n  fatal_exit (sig);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_signals": {
      "start_point": [
        1143,
        0
      ],
      "end_point": [
        1192,
        1
      ],
      "content": "void\nset_signals (bool reset)\n{\n  int i;\n#if HAVE_SIGACTION\n  struct sigaction initial_act, fatal_act;\n  fatal_act.sa_handler = fatal_exit;\n  sigemptyset (&fatal_act.sa_mask);\n  fatal_act.sa_flags = 0;\n#define setup_handler(sig) sigaction (sig, &fatal_act, (struct sigaction *) 0)\n#else\n#define setup_handler(sig) signal (sig, fatal_exit_handler)\n#endif\n\n  if (!reset)\n    {\n#ifdef SIGCHLD\n      /* System V fork+wait does not work if SIGCHLD is ignored.  */\n      signal (SIGCHLD, SIG_DFL);\n#endif\n      sigemptyset (&signals_to_block);\n      for (i = 0;  i < NUM_SIGS;  i++)\n\t{\n\t  bool ignoring_signal;\n#if HAVE_SIGACTION\n\t  if (sigaction (sigs[i], (struct sigaction *) 0, &initial_act) != 0)\n\t    continue;\n\t  ignoring_signal = initial_act.sa_handler == SIG_IGN;\n#else\n\t  ignoring_signal = signal (sigs[i], SIG_IGN) == SIG_IGN;\n#endif\n\t  if (! ignoring_signal)\n\t    {\n\t      sigaddset (&signals_to_block, sigs[i]);\n\t      setup_handler (sigs[i]);\n\t    }\n\t}\n    }\n  else\n    {\n      /* Undo the effect of ignore_signals.  */\n#if HAVE_SIGPROCMASK || HAVE_SIGSETMASK\n      sigprocmask (SIG_SETMASK, &initial_signal_mask, (sigset_t *) 0);\n#else\n      for (i = 0;  i < NUM_SIGS;  i++)\n\tif (sigismember (&signals_to_block, sigs[i]))\n\t  setup_handler (sigs[i]);\n#endif\n    }\n}",
      "lines": 50,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "ignore_signals": {
      "start_point": [
        1196,
        0
      ],
      "end_point": [
        1207,
        1
      ],
      "content": "void\nignore_signals (void)\n{\n#if HAVE_SIGPROCMASK || HAVE_SIGSETMASK\n  sigprocmask (SIG_BLOCK, &signals_to_block, &initial_signal_mask);\n#else\n  int i;\n  for (i = 0;  i < NUM_SIGS;  i++)\n    if (sigismember (&signals_to_block, sigs[i]))\n      signal (sigs[i], SIG_IGN);\n#endif\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "exit_with_signal": {
      "start_point": [
        1209,
        0
      ],
      "end_point": [
        1219,
        1
      ],
      "content": "void\nexit_with_signal (int sig)\n{\n  sigset_t s;\n  signal (sig, SIG_DFL);\n  sigemptyset (&s);\n  sigaddset (&s, sig);\n  sigprocmask (SIG_UNBLOCK, &s, (sigset_t *) 0);\n  raise (sig);\n  exit (2);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "systemic": {
      "start_point": [
        1221,
        0
      ],
      "end_point": [
        1228,
        1
      ],
      "content": "int\nsystemic (char const *command)\n{\n  if (debug & 8)\n    say (\"+ %s\\n\", command);\n  fflush (stdout);\n  return system (command);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "replace_slashes": {
      "start_point": [
        1233,
        0
      ],
      "end_point": [
        1270,
        1
      ],
      "content": "static char *\nreplace_slashes (char *filename)\n{\n  char *f;\n  char *last_location_replaced = 0;\n  char const *component_start;\n\n  for (f = filename + FILE_SYSTEM_PREFIX_LEN (filename);  ISSLASH (*f);  f++)\n    /* do nothing */ ;\n\n  component_start = f;\n\n  for (; *f; f++)\n    if (ISSLASH (*f))\n      {\n\tchar *slash = f;\n\n\t/* Treat multiple slashes as if they were one slash.  */\n\twhile (ISSLASH (f[1]))\n\t  f++;\n\n\t/* Ignore slashes at the end of the path.  */\n\tif (! f[1])\n\t  break;\n\n\t/* \".\" and \"..\" need not be tested.  */\n\tif (! (slash - component_start <= 2\n\t       && component_start[0] == '.' && slash[-1] == '.'))\n\t  {\n\t    *slash = '\\0';\n\t    last_location_replaced = slash;\n\t  }\n\n\tcomponent_start = f + 1;\n      }\n\n  return last_location_replaced;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nreplace_slashes (char *filename)",
        "*"
      ]
    },
    "makedirs": {
      "start_point": [
        1275,
        0
      ],
      "end_point": [
        1303,
        1
      ],
      "content": "static void\nmakedirs (char const *name)\n{\n  char *filename = xstrdup (name);\n  char *f;\n  char *flim = replace_slashes (filename);\n\n  /* FIXME: Now with the pathname lookup cache, there is no reason for\n     deferring the creation of directories. Callers should be updated. */\n\n  if (flim)\n    {\n      /* Create any missing directories, replacing NULs by '/'s.\n\t Ignore errors.  We may have to keep going even after an EEXIST,\n\t since the path may contain \"..\"s; and when there is an EEXIST\n\t failure the system may return some other error number.\n\t Any problems will eventually be reported when we create the file.  */\n      for (f = filename;  f <= flim;  f++)\n\tif (!*f)\n\t  {\n\t    safe_mkdir (filename,\n\t\t   S_IRUSR|S_IWUSR|S_IXUSR\n\t\t   |S_IRGRP|S_IWGRP|S_IXGRP\n\t\t   |S_IROTH|S_IWOTH|S_IXOTH);\n\t    *f = '/';\n\t  }\n    }\n  free (filename);\n}",
      "lines": 29,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "removedirs": {
      "start_point": [
        1308,
        0
      ],
      "end_point": [
        1330,
        1
      ],
      "content": "void\nremovedirs (char const *name)\n{\n  char *filename = xstrdup (name);\n  size_t i;\n\n  for (i = strlen (filename);  i != 0;  i--)\n    if (ISSLASH (filename[i])\n\t&& ! (ISSLASH (filename[i - 1])\n\t      || (filename[i - 1] == '.'\n\t\t  && (i == 1\n\t\t      || ISSLASH (filename[i - 2])\n\t\t      || (filename[i - 2] == '.'\n\t\t\t  && (i == 2\n\t\t\t      || ISSLASH (filename[i - 3])))))))\n      {\n\tfilename[i] = '\\0';\n\tif (safe_rmdir (filename) == 0 && verbosity == VERBOSE)\n\t  say (\"Removed empty directory %s\\n\", quotearg (filename));\n\tfilename[i] = '/';\n      }\n  free (filename);\n}",
      "lines": 23,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "init_time": {
      "start_point": [
        1334,
        0
      ],
      "end_point": [
        1338,
        1
      ],
      "content": "void\ninit_time (void)\n{\n  gettime (&initial_time);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "parse_c_string": {
      "start_point": [
        1340,
        0
      ],
      "end_point": [
        1412,
        1
      ],
      "content": "static char *\nparse_c_string (char const *s, char const **endp)\n{\n  char *u, *v;\n\n  assert (*s == '\"');\n  s++;\n  u = v = xmalloc (strlen (s));\n  for (;;)\n    {\n      char c = *s++;\n\n      switch (c)\n\t{\n\t  case 0:\n\t    goto fail;\n\n\t  case '\"':\n\t    *v++ = 0;\n\t    v = realloc (u, v - u);\n\t    if (v)\n\t      u = v;\n\t    if (endp)\n\t      *endp = s;\n\t    return u;\n\n\t  case '\\\\':\n\t    break;\n\n\t  default:\n\t    *v++ = c;\n\t    continue;\n\t}\n\n      c = *s++;\n      switch (c)\n\t{\n\t  case 'a': c = '\\a'; break;\n\t  case 'b': c = '\\b'; break;\n\t  case 'f': c = '\\f'; break;\n\t  case 'n': c = '\\n'; break;\n\t  case 'r': c = '\\r'; break;\n\t  case 't': c = '\\t'; break;\n\t  case 'v': c = '\\v'; break;\n\t  case '\\\\': case '\"':\n\t    break;  /* verbatim */\n\t  case '0': case '1': case '2': case '3':\n\t    {\n\t      int acc = (c - '0') << 6;\n\n\t      c = *s++;\n\t      if (c < '0' || c > '7')\n\t        goto fail;\n\t      acc |= (c - '0') << 3;\n\t      c = *s++;\n\t      if (c < '0' || c > '7')\n\t        goto fail;\n\t      acc |= (c - '0');\n\t      c = acc;\n\t      break;\n\t    }\n\t  default:\n\t    goto fail;\n\t}\n      *v++ = c;\n    }\n\nfail:\n  free (u);\n  if (endp)\n    *endp = s;\n  return NULL;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nparse_c_string (char const *s, char const **endp)",
        "*"
      ]
    },
    "strip_leading_slashes": {
      "start_point": [
        1418,
        0
      ],
      "end_point": [
        1441,
        1
      ],
      "content": "static bool\nstrip_leading_slashes (char *name, int strip_leading)\n{\n  int s = strip_leading;\n  char *p, *n;\n\n  for (p = n = name;  *p;  p++)\n    {\n      if (ISSLASH (*p))\n\t{\n\t  while (ISSLASH (p[1]))\n\t    p++;\n\t  if (strip_leading < 0 || --s >= 0)\n\t      n = p+1;\n\t}\n    }\n  if ((strip_leading < 0 || s <= 0) && *n)\n    {\n      memmove (name, n, strlen (n) + 1);\n      return true;\n    }\n  else\n    return false;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "fetchname": {
      "start_point": [
        1446,
        0
      ],
      "end_point": [
        1562,
        1
      ],
      "content": "void\nfetchname (char const *at, int strip_leading, char **pname,\n\t   char **ptimestr, struct timespec *pstamp)\n{\n    char *name;\n    const char *t;\n    char *timestr = NULL;\n    struct timespec stamp;\n\n    stamp.tv_sec = -1;\n    stamp.tv_nsec = 0;\n\n    while (ISSPACE ((unsigned char) *at))\n\tat++;\n    if (debug & 128)\n\tsay (\"fetchname %s %d\\n\", at, strip_leading);\n\n    if (*at == '\"')\n      {\n\tname = parse_c_string (at, &t);\n\tif (! name)\n\t  {\n\t    if (debug & 128)\n\t      say (\"ignoring malformed filename %s\\n\", quotearg (at));\n\t    return;\n\t  }\n      }\n    else\n      {\n\tfor (t = at;  *t;  t++)\n\t  {\n\t    if (ISSPACE ((unsigned char) *t))\n\t      {\n\t\t/* Allow file names with internal spaces,\n\t\t   but only if a tab separates the file name from the date.  */\n\t\tchar const *u = t;\n\t\twhile (*u != '\\t' && ISSPACE ((unsigned char) u[1]))\n\t\t  u++;\n\t\tif (*u != '\\t' && (strchr (u + 1, pstamp ? '\\t' : '\\n')))\n\t\t  continue;\n\t\tbreak;\n\t      }\n\t  }\n\tname = xmemdup0 (at, t - at);\n      }\n\n    /* If the name is \"/dev/null\", ignore the name and mark the file\n       as being nonexistent.  The name \"/dev/null\" appears in patches\n       regardless of how NULL_DEVICE is spelled.  */\n    if (strcmp (name, \"/dev/null\") == 0)\n      {\n\tfree (name);\n\tif (pstamp)\n\t  {\n\t    pstamp->tv_sec = 0;\n\t    pstamp->tv_nsec = 0;\n\t  }\n\treturn;\n      }\n\n    /* Ignore the name if it doesn't have enough slashes to strip off.  */\n    if (! strip_leading_slashes (name, strip_leading))\n      {\n\tfree (name);\n\treturn;\n      }\n\n    if (ptimestr)\n      {\n\tchar const *u = t + strlen (t);\n\n\tif (u != t && *(u-1) == '\\n')\n\t  u--;\n\tif (u != t && *(u-1) == '\\r')\n\t  u--;\n\ttimestr = xmemdup0 (t, u - t);\n      }\n\n      if (*t != '\\n')\n\t{\n\t  if (! pstamp)\n\t    {\n\t      free (name);\n\t      free (timestr);\n\t      return;\n\t    }\n\n\t  if (set_time | set_utc)\n\t    get_date (&stamp, t, &initial_time);\n\t  else\n\t    {\n\t      /* The head says the file is nonexistent if the\n\t\t timestamp is the epoch; but the listed time is\n\t\t local time, not UTC, and POSIX.1 allows local\n\t\t time offset anywhere in the range -25:00 <\n\t\t offset < +26:00.  Match any time in that range.  */\n\t      const struct timespec lower = { -25L * 60 * 60 },\n\t\t\t\t    upper = {  26L * 60 * 60 };\n\t      if (get_date (&stamp, t, &initial_time)\n\t\t  && timespec_cmp (stamp, lower) > 0\n\t\t  && timespec_cmp (stamp, upper) < 0) {\n\t\t      stamp.tv_sec = 0;\n\t\t      stamp.tv_nsec = 0;\n\t      }\n\t    }\n\t}\n\n    free (*pname);\n    *pname = name;\n    if (ptimestr)\n      {\n\tfree (*ptimestr);\n\t*ptimestr = timestr;\n      }\n    if (pstamp)\n      *pstamp = stamp;\n}",
      "lines": 117,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "parse_name": {
      "start_point": [
        1564,
        0
      ],
      "end_point": [
        1593,
        1
      ],
      "content": "char *\nparse_name (char const *s, int strip_leading, char const **endp)\n{\n  char *ret;\n\n  while (ISSPACE ((unsigned char) *s))\n    s++;\n  if (*s == '\"')\n    {\n      ret = parse_c_string (s, endp);\n      if (!ret)\n        return NULL;\n    }\n  else\n    {\n      char const *t;\n\n      for (t = s; *t && ! ISSPACE ((unsigned char) *t); t++)\n\t/* do nothing*/ ;\n      ret = xmemdup0 (s, t - s);\n      if (endp)\n\t*endp = t;\n    }\n  if (! strip_leading_slashes (ret, strip_leading))\n    {\n      free (ret);\n      ret = NULL;\n    }\n  return ret;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "char",
        "*\nparse_name (char const *s, int strip_leading, char const **endp)",
        "*"
      ]
    },
    "Fseek": {
      "start_point": [
        1595,
        0
      ],
      "end_point": [
        1600,
        1
      ],
      "content": "void\nFseek (FILE *stream, file_offset offset, int ptrname)\n{\n  if (file_seek (stream, offset, ptrname) != 0)\n    pfatal (\"fseek\");\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "try_safe_open": {
      "start_point": [
        1612,
        0
      ],
      "end_point": [
        1627,
        1
      ],
      "content": "static int try_safe_open (char *template, void *__args)\n{\n  struct try_safe_open_args *args = __args;\n  int try_makedirs_errno = ENOENT;\n  int fd;\n\nrepeat:\n  fd = safe_open (template, O_CREAT | O_EXCL | args->flags, args->mode);\n  if (fd < 0 && errno == try_makedirs_errno)\n    {\n      makedirs (template);\n      try_makedirs_errno = 0;\n      goto repeat;\n    }\n  return fd;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "make_tempfile": {
      "start_point": [
        1629,
        0
      ],
      "end_point": [
        1670,
        1
      ],
      "content": "int\nmake_tempfile (char const **name, char letter, char const *real_name,\n\t       int flags, mode_t mode)\n{\n  char *template;\n  struct try_safe_open_args args = {\n    .flags = flags,\n    .mode = mode,\n  };\n  int fd;\n\n  if (real_name && ! dry_run)\n    {\n      char *dirname, *basename;\n\n      dirname = dir_name (real_name);\n      basename = base_name (real_name);\n\n      template = xmalloc (strlen (dirname) + 1 + strlen (basename) + 9);\n      sprintf (template, \"%s/%s.%cXXXXXX\", dirname, basename, letter);\n      free (dirname);\n      free (basename);\n    }\n  else\n    {\n      char const *tmpdir;\n\n      tmpdir = getenv (\"TMPDIR\");  /* Unix tradition */\n      if (! tmpdir)\n\ttmpdir = getenv (\"TMP\");  /* DOS tradition */\n      if (! tmpdir)\n\ttmpdir = getenv (\"TEMP\");  /* another DOS tradition */\n      if (! tmpdir)\n\ttmpdir = TMPDIR;\n\n      template = xmalloc (strlen (tmpdir) + 10);\n      sprintf (template, \"%s/p%cXXXXXX\", tmpdir, letter);\n    }\n  fd = try_tempname(template, 0, &args, try_safe_open);\n  *name = template;\n  return fd;\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "stat_file": {
      "start_point": [
        1672,
        0
      ],
      "end_point": [
        1678,
        1
      ],
      "content": "int stat_file (char const *filename, struct stat *st)\n{\n  int (*xstat)(char const *, struct stat *) =\n    follow_symlinks ? safe_stat : safe_lstat;\n\n  return xstat (filename, st) == 0 ? 0 : errno;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "filename_is_safe": {
      "start_point": [
        1684,
        0
      ],
      "end_point": [
        1700,
        1
      ],
      "content": "bool\nfilename_is_safe (char const *name)\n{\n  if (IS_ABSOLUTE_FILE_NAME (name))\n    return false;\n  while (*name)\n    {\n      if (*name == '.' && *++name == '.'\n\t  && ( ! *++name || ISSLASH (*name)))\n\treturn false;\n      while (*name && ! ISSLASH (*name))\n\tname++;\n      while (ISSLASH (*name))\n\tname++;\n    }\n  return true;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "cwd_is_root": {
      "start_point": [
        1704,
        0
      ],
      "end_point": [
        1723,
        1
      ],
      "content": "bool\ncwd_is_root (char const *name)\n{\n  unsigned int prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n  char root[prefix_len + 2];\n  struct stat st;\n  dev_t root_dev;\n  ino_t root_ino;\n\n  memcpy (root, name, prefix_len);\n  root[prefix_len] = '/';\n  root[prefix_len + 1] = 0;\n  if (stat (root, &st))\n    return false;\n  root_dev = st.st_dev;\n  root_ino = st.st_ino;\n  if (stat (\".\", &st))\n    return false;\n  return root_dev == st.st_dev && root_ino == st.st_ino;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "patch/patch-2.7.6/src/util.h": {
    "skip_spaces": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static inline char const * _GL_ATTRIBUTE_PURE\nskip_spaces (char const *str)\n{\n  while (ISSPACE ((unsigned char) *str))\n    str++;\n  return str;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nskip_spaces (char const *str)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    }
  },
  "patch/patch-2.7.6/src/version.c": {
    "version": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        23,
        1
      ],
      "content": "void\nversion (void)\n{\n  printf (\"%s %s\\n%s\\n\\n%s\\n\\n%s\\n\", PACKAGE_NAME, PACKAGE_VERSION,\n\t  copyright_string, free_software_msgid, authorship_msgid);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "patch/patch-2.7.6/src/version.h": {}
}