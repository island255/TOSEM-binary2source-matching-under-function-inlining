{
  "gmp/gmp-6.1.2/assert.c": {
    "__gmp_assert_header": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "void\n__gmp_assert_header (const char *filename, int linenum)\n{\n  if (filename != NULL && filename[0] != '\\0')\n    {\n      fprintf (stderr, \"%s:\", filename);\n      if (linenum != -1)\n        fprintf (stderr, \"%d: \", linenum);\n    }\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "__gmp_assert_fail": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\n__gmp_assert_fail (const char *filename, int linenum,\n                   const char *expr)\n{\n  __gmp_assert_header (filename, linenum);\n  fprintf (stderr, \"GNU MP assertion failed: %s\\n\", expr);\n  abort();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/bootstrap.c": {
    "isprime": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nisprime (unsigned long int t)\n{\n  unsigned long int q, r, d;\n\n  if (t < 32)\n    return (0xa08a28acUL >> t) & 1;\n  if ((t & 1) == 0)\n    return 0;\n\n  if (t % 3 == 0)\n    return 0;\n  if (t % 5 == 0)\n    return 0;\n  if (t % 7 == 0)\n    return 0;\n\n  for (d = 11;;)\n    {\n      q = t / d;\n      r = t - q * d;\n      if (q < d)\n\treturn 1;\n      if (r == 0)\n\tbreak;\n      d += 2;\n      q = t / d;\n      r = t - q * d;\n      if (q < d)\n\treturn 1;\n      if (r == 0)\n\tbreak;\n      d += 4;\n    }\n  return 0;\n}",
      "lines": 36,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "log2_ceil": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nlog2_ceil (int n)\n{\n  int  e;\n  assert (n >= 1);\n  for (e = 0; ; e++)\n    if ((1 << e) >= n)\n      break;\n  return e;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_preinv_invert": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nmpz_preinv_invert (mpz_t inv, mpz_t d, int numb_bits)\n{\n  mpz_t  t;\n  int    norm;\n  assert (SIZ(d) > 0);\n\n  norm = numb_bits - mpz_sizeinbase (d, 2);\n  assert (norm >= 0);\n  mpz_init_set_ui (t, 1L);\n  mpz_mul_2exp (t, t, 2*numb_bits - norm);\n  mpz_tdiv_q (inv, t, d);\n  mpz_set_ui (t, 1L);\n  mpz_mul_2exp (t, t, numb_bits);\n  mpz_sub (inv, inv, t);\n\n  mpz_clear (t);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_invert_2exp": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\nmpz_invert_2exp (mpz_t r, mpz_t a, unsigned long n)\n{\n  unsigned long  i;\n  mpz_t  inv, prod;\n\n  assert (mpz_odd_p (a));\n\n  mpz_init_set_ui (inv, 1L);\n  mpz_init (prod);\n\n  for (i = 1; i < n; i++)\n    {\n      mpz_mul (prod, inv, a);\n      if (mpz_tstbit (prod, i) != 0)\n\tmpz_setbit (inv, i);\n    }\n\n  mpz_mul (prod, inv, a);\n  mpz_tdiv_r_2exp (prod, prod, n);\n  assert (mpz_cmp_ui (prod, 1L) == 0);\n\n  mpz_set (r, inv);\n\n  mpz_clear (inv);\n  mpz_clear (prod);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpz_invert_ui_2exp": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\nmpz_invert_ui_2exp (mpz_t r, unsigned long a, unsigned long n)\n{\n  mpz_t  az;\n  mpz_init_set_ui (az, a);\n  mpz_invert_2exp (r, az, n);\n  mpz_clear (az);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/compat.c": {
    "__MPN": [
      {
        "start_point": [
          37,
          0
        ],
        "end_point": [
          41,
          1
        ],
        "content": "mp_limb_t\n__MPN (divexact_by3) (mp_ptr dst, mp_srcptr src, mp_size_t size)\n{\n  return mpn_divexact_by3 (dst, src, size);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "mp_limb_t\n__MPN (divmod_1) (mp_ptr dst, mp_srcptr src, mp_size_t size, mp_limb_t divisor)\n{\n  return mpn_divmod_1 (dst, src, size, divisor);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "mp_limb_t"
        ]
      }
    ],
    "__gmpz_legendre": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\n__gmpz_legendre (mpz_srcptr a, mpz_srcptr b)\n{\n  return mpz_jacobi (a, b);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/errno.c": {
    "__gmp_exception": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\n__gmp_exception (int error_bit)\n{\n  gmp_errno |= error_bit;\n  __gmp_junk = 10 / __gmp_0;\n  abort ();\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "__gmp_sqrt_of_negative": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\n__gmp_sqrt_of_negative (void)\n{\n  __gmp_exception (GMP_ERROR_SQRT_OF_NEGATIVE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "__gmp_divide_by_zero": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "void\n__gmp_divide_by_zero (void)\n{\n  __gmp_exception (GMP_ERROR_DIVISION_BY_ZERO);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/extract-dbl.c": {},
  "gmp/gmp-6.1.2/gen-bases.c": {
    "ulog2": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "unsigned int\nulog2 (unsigned int x)\n{\n  unsigned int i;\n  for (i = 0;  x != 0;  i++)\n    x >>= 1;\n  return i;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "generate": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "void\ngenerate (int limb_bits, int nail_bits, int base)\n{\n  int  numb_bits = limb_bits - nail_bits;\n\n  mpz_set_ui (t, 1L);\n  mpz_mul_2exp (t, t, numb_bits);\n  mpz_set_ui (big_base, 1L);\n  chars_per_limb = 0;\n  for (;;)\n    {\n      mpz_mul_ui (big_base, big_base, (long) base);\n      if (mpz_cmp (big_base, t) > 0)\n        break;\n      chars_per_limb++;\n    }\n\n  mpz_ui_pow_ui (big_base, (long) base, (long) chars_per_limb);\n\n  normalization_steps = limb_bits - mpz_sizeinbase (big_base, 2);\n\n  mpz_set_ui (t, 1L);\n  mpz_mul_2exp (t, t, 2*limb_bits - normalization_steps);\n  mpz_tdiv_q (big_base_inverted, t, big_base);\n  mpz_set_ui (t, 1L);\n  mpz_mul_2exp (t, t, limb_bits);\n  mpz_sub (big_base_inverted, big_base_inverted, t);\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "header": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void\nheader (int limb_bits, int nail_bits)\n{\n  int  numb_bits = limb_bits - nail_bits;\n\n  generate (limb_bits, nail_bits, 10);\n\n  printf (\"/* This file generated by gen-bases.c - DO NOT EDIT. */\\n\");\n  printf (\"\\n\");\n  printf (\"#if GMP_NUMB_BITS != %d\\n\", numb_bits);\n  printf (\"Error, error, this data is for %d bits\\n\", numb_bits);\n  printf (\"#endif\\n\");\n  printf (\"\\n\");\n  printf (\"/* mp_bases[10] data, as literal values */\\n\");\n  printf (\"#define MP_BASES_CHARS_PER_LIMB_10      %d\\n\", chars_per_limb);\n  printf (\"#define MP_BASES_BIG_BASE_10            CNST_LIMB(0x\");\n  mpz_out_str (stdout, 16, big_base);\n  printf (\")\\n\");\n  printf (\"#define MP_BASES_BIG_BASE_INVERTED_10   CNST_LIMB(0x\");\n  mpz_out_str (stdout, 16, big_base_inverted);\n  printf (\")\\n\");\n  printf (\"#define MP_BASES_NORMALIZATION_STEPS_10 %d\\n\", normalization_steps);\n}",
      "lines": 23,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mp_2logb": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nmp_2logb (mpz_t r, int bi, int prec)\n{\n  mpz_t t, t2, two, b;\n  int i;\n\n  mpz_init_set_ui (t, 1);\n  mpz_mul_2exp (t, t, prec+EXTRA);\n\n  mpz_init (t2);\n\n  mpz_init_set_ui (two, 2);\n  mpz_mul_2exp (two, two, prec+EXTRA);\n\n  mpz_set_ui (r, 0);\n\n  mpz_init_set_ui (b, bi);\n  mpz_mul_2exp (b, b, prec+EXTRA);\n\n  for (i = prec-1; i >= 0; i--)\n    {\n      mpz_mul_2exp (b, b, prec+EXTRA);\n      mpz_sqrt (b, b);\n\n      mpz_mul (t2, t, b);\n      mpz_tdiv_q_2exp (t2, t2, prec+EXTRA);\n\n      if (mpz_cmp (t2, two) < 0)\t/* not too large? */\n\t{\n\t  mpz_setbit (r, i);\t\t/* set next less significant bit */\n\t  mpz_set (t, t2);\t\t/* new value acceptable */\n\t}\n    }\n\n  mpz_clear (t);\n  mpz_clear (t2);\n  mpz_clear (two);\n  mpz_clear (b);\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "table": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "void\ntable (int limb_bits, int nail_bits)\n{\n  int  numb_bits = limb_bits - nail_bits;\n  int  base;\n  mpz_t r, t, logb2, log2b;\n\n  mpz_init (r);\n  mpz_init (t);\n  mpz_init (logb2);\n  mpz_init (log2b);\n\n  printf (\"/* This file generated by gen-bases.c - DO NOT EDIT. */\\n\");\n  printf (\"\\n\");\n  printf (\"#include \\\"gmp.h\\\"\\n\");\n  printf (\"#include \\\"gmp-impl.h\\\"\\n\");\n  printf (\"\\n\");\n  printf (\"#if GMP_NUMB_BITS != %d\\n\", numb_bits);\n  printf (\"Error, error, this data is for %d bits\\n\", numb_bits);\n  printf (\"#endif\\n\");\n  printf (\"\\n\");\n  puts (\"const struct bases mp_bases[257] =\\n{\");\n  puts (\"  /*   0 */ { 0, 0, 0, 0, 0 },\");\n  puts (\"  /*   1 */ { 0, 0, 0, 0, 0 },\");\n  for (base = 2; base <= 256; base++)\n    {\n      generate (limb_bits, nail_bits, base);\n      mp_2logb (r, base, limb_bits + 8);\n      mpz_tdiv_q_2exp (logb2, r, 8);\n      mpz_set_ui (t, 1);\n      mpz_mul_2exp (t, t, 2*limb_bits + 5);\n      mpz_sub_ui (t, t, 1);\n      mpz_add_ui (r, r, 1);\n      mpz_tdiv_q (log2b, t, r);\n\n      printf (\"  /* %3u */ { \", base);\n      if (POW2_P (base))\n\t{\n          mpz_set_ui (big_base, ulog2 (base) - 1);\n\t  mpz_set_ui (big_base_inverted, 0);\n\t}\n\n      printf (\"%u,\", chars_per_limb);\n      printf (\" CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, logb2);\n      printf (\"), CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, log2b);\n      printf (\"), CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, big_base);\n      printf (\"), CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, big_base_inverted);\n      printf (\") },\\n\");\n    }\n\n  puts (\"};\");\n\n  mpz_clear (r);\n  mpz_clear (t);\n  mpz_clear (logb2);\n  mpz_clear (log2b);\n\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int  limb_bits, nail_bits;\n\n  mpz_init (big_base);\n  mpz_init (big_base_inverted);\n  mpz_init (t);\n\n  if (argc != 4)\n    {\n      fprintf (stderr, \"Usage: gen-bases <header|table> <limbbits> <nailbits>\\n\");\n      exit (1);\n    }\n\n  limb_bits = atoi (argv[2]);\n  nail_bits = atoi (argv[3]);\n\n  if (limb_bits <= 0\n      || nail_bits < 0\n      || nail_bits >= limb_bits)\n    {\n      fprintf (stderr, \"Invalid limb/nail bits: %d %d\\n\",\n               limb_bits, nail_bits);\n      exit (1);\n    }\n\n  if (strcmp (argv[1], \"header\") == 0)\n    header (limb_bits, nail_bits);\n  else if (strcmp (argv[1], \"table\") == 0)\n    table (limb_bits, nail_bits);\n  else\n    {\n      fprintf (stderr, \"Invalid header/table choice: %s\\n\", argv[1]);\n      exit (1);\n    }\n\n  return 0;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/gen-fac.c": {
    "mpz_remove_twos": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\nmpz_remove_twos (mpz_t x)\n{\n  mp_bitcnt_t r = mpz_scan1(x, 0);\n  mpz_tdiv_q_2exp (x, x, r);\n  return r;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gen_consts": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "int\ngen_consts (int numb, int nail, int limb)\n{\n  mpz_t x, mask, y, last;\n  unsigned long a, b;\n  unsigned long ofl, ofe;\n\n  printf (\"/* This file is automatically generated by gen-fac.c */\\n\\n\");\n  printf (\"#if GMP_NUMB_BITS != %d\\n\", numb);\n  printf (\"Error , error this data is for %d GMP_NUMB_BITS only\\n\", numb);\n  printf (\"#endif\\n\");\n#if 0\n  printf (\"#if GMP_LIMB_BITS != %d\\n\", limb);\n  printf (\"Error , error this data is for %d GMP_LIMB_BITS only\\n\", limb);\n  printf (\"#endif\\n\");\n#endif\n\n  printf\n    (\"/* This table is 0!,1!,2!,3!,...,n! where n! has <= GMP_NUMB_BITS bits */\\n\");\n  printf\n    (\"#define ONE_LIMB_FACTORIAL_TABLE CNST_LIMB(0x1),CNST_LIMB(0x1\");\n  mpz_init_set_ui (x, 1);\n  mpz_init (last);\n  for (b = 2;; b++)\n    {\n      mpz_mul_ui (x, x, b);\t/* so b!=a       */\n      if (mpz_sizeinbase (x, 2) > numb)\n\tbreak;\n      printf (\"),CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, x);\n    }\n  printf (\")\\n\");\n\n  printf\n    (\"\\n/* This table is 0!,1!,2!/2,3!/2,...,n!/2^sn where n!/2^sn is an */\\n\");\n  printf\n    (\"/* odd integer for each n, and n!/2^sn has <= GMP_NUMB_BITS bits */\\n\");\n  printf\n    (\"#define ONE_LIMB_ODD_FACTORIAL_TABLE CNST_LIMB(0x1),CNST_LIMB(0x1),CNST_LIMB(0x1\");\n  mpz_set_ui (x, 1);\n  for (b = 3;; b++)\n    {\n      for (a = b; (a & 1) == 0; a >>= 1);\n      mpz_swap (last, x);\n      mpz_mul_ui (x, last, a);\n      if (mpz_sizeinbase (x, 2) > numb)\n\tbreak;\n      printf (\"),CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, x);\n    }\n  printf (\")\\n\");\n  printf\n    (\"#define ODD_FACTORIAL_TABLE_MAX CNST_LIMB(0x\");\n  mpz_out_str (stdout, 16, last);\n  printf (\")\\n\");\n\n  ofl = b - 1;\n  printf\n    (\"#define ODD_FACTORIAL_TABLE_LIMIT (%lu)\\n\", ofl);\n  mpz_init2 (mask, numb + 1);\n  mpz_setbit (mask, numb);\n  mpz_sub_ui (mask, mask, 1);\n  printf\n    (\"\\n/* Previous table, continued, values modulo 2^GMP_NUMB_BITS */\\n\");\n  printf\n    (\"#define ONE_LIMB_ODD_FACTORIAL_EXTTABLE CNST_LIMB(0x\");\n  mpz_and (x, x, mask);\n  mpz_out_str (stdout, 16, x);\n  mpz_init (y);\n  mpz_bin_uiui (y, b, b/2);\n  b++;\n  for (;; b++)\n    {\n      for (a = b; (a & 1) == 0; a >>= 1);\n      if (a == b) {\n\tmpz_divexact_ui (y, y, a/2+1);\n\tmpz_mul_ui (y, y, a);\n      } else\n\tmpz_mul_2exp (y, y, 1);\n      if (mpz_sizeinbase (y, 2) > numb)\n\tbreak;\n      mpz_mul_ui (x, x, a);\n      mpz_and (x, x, mask);\n      printf (\"),CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, x);\n    }\n  printf (\")\\n\");\n  ofe = b - 1;\n  printf\n    (\"#define ODD_FACTORIAL_EXTTABLE_LIMIT (%lu)\\n\", ofe);\n\n  printf\n    (\"\\n/* This table is 1!!,3!!,...,(2n+1)!! where (2n+1)!! has <= GMP_NUMB_BITS bits */\\n\");\n  printf\n    (\"#define ONE_LIMB_ODD_DOUBLEFACTORIAL_TABLE CNST_LIMB(0x1\");\n  mpz_set_ui (x, 1);\n  for (b = 3;; b+=2)\n    {\n      mpz_swap (last, x);\n      mpz_mul_ui (x, last, b);\n      if (mpz_sizeinbase (x, 2) > numb)\n\tbreak;\n      printf (\"),CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, x);\n    }\n  printf (\")\\n\");\n  printf\n    (\"#define ODD_DOUBLEFACTORIAL_TABLE_MAX CNST_LIMB(0x\");\n  mpz_out_str (stdout, 16, last);\n  printf (\")\\n\");\n\n  printf\n    (\"#define ODD_DOUBLEFACTORIAL_TABLE_LIMIT (%lu)\\n\", b - 2);\n\n  printf\n    (\"\\n/* This table x_1, x_2,... contains values s.t. x_n^n has <= GMP_NUMB_BITS bits */\\n\");\n  printf\n    (\"#define NTH_ROOT_NUMB_MASK_TABLE (GMP_NUMB_MASK\");\n  for (b = 2;b <= 8; b++)\n    {\n      mpz_root (x, mask, b);\n      printf (\"),CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, x);\n    }\n  printf (\")\\n\");\n\n  mpz_add_ui (mask, mask, 1);\n  printf\n    (\"\\n/* This table contains inverses of odd factorials, modulo 2^GMP_NUMB_BITS */\\n\");\n  printf\n    (\"\\n/* It begins with (2!/2)^-1=1 */\\n\");\n  printf\n    (\"#define ONE_LIMB_ODD_FACTORIAL_INVERSES_TABLE CNST_LIMB(0x1\");\n  mpz_set_ui (x, 1);\n  for (b = 3;b <= ofe - 2; b++)\n    {\n      for (a = b; (a & 1) == 0; a >>= 1);\n      mpz_mul_ui (x, x, a);\n      mpz_invert (y, x, mask);\n      printf (\"),CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, y);\n    }\n  printf (\")\\n\");\n\n  ofe = (ofe / 16 + 1) * 16;\n\n  printf\n    (\"\\n/* This table contains 2n-popc(2n) for small n */\\n\");\n  printf\n    (\"\\n/* It begins with 2-1=1 (n=1) */\\n\");\n  printf\n    (\"#define TABLE_2N_MINUS_POPC_2N 1\");\n  for (b = 4; b <= ofe; b += 2)\n    {\n      mpz_set_ui (x, b);\n      printf (\",%lu\",b - mpz_popcount (x));\n    }\n  printf (\"\\n\");\n  printf\n    (\"#define TABLE_LIMIT_2N_MINUS_POPC_2N %lu\\n\", ofe + 1);\n\n\n  ofl = (ofl + 1) / 2;\n  printf\n    (\"#define ODD_CENTRAL_BINOMIAL_OFFSET (%lu)\\n\", ofl);\n  printf\n    (\"\\n/* This table contains binomial(2k,k)/2^t */\\n\");\n  printf\n    (\"\\n/* It begins with ODD_CENTRAL_BINOMIAL_TABLE_MIN */\\n\");\n  printf\n    (\"#define ONE_LIMB_ODD_CENTRAL_BINOMIAL_TABLE \");\n  for (b = ofl;; b++)\n    {\n      mpz_bin_uiui (x, 2 * b, b);\n      mpz_remove_twos (x);\n      if (mpz_sizeinbase (x, 2) > numb)\n\tbreak;\n      if (b != ofl)\n\tprintf (\"),\");\n      printf(\"CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, x);\n    }\n  printf (\")\\n\");\n\n  ofe = b - 1;\n  printf\n    (\"#define ODD_CENTRAL_BINOMIAL_TABLE_LIMIT (%lu)\\n\", ofe);\n\n  printf\n    (\"\\n/* This table contains the inverses of elements in the previous table. */\\n\");\n  printf\n    (\"#define ONE_LIMB_ODD_CENTRAL_BINOMIAL_INVERSE_TABLE CNST_LIMB(0x\");\n  for (b = ofl; b <= ofe; b++)\n    {\n      mpz_bin_uiui (x, 2 * b, b);\n      mpz_remove_twos (x);\n      mpz_invert (x, x, mask);\n      mpz_out_str (stdout, 16, x);\n      if (b != ofe)\n\tprintf (\"),CNST_LIMB(0x\");\n    }\n  printf (\")\\n\");\n\n  printf\n    (\"\\n/* This table contains the values t in the formula binomial(2k,k)/2^t */\\n\");\n  printf\n    (\"#define CENTRAL_BINOMIAL_2FAC_TABLE \");\n  for (b = ofl; b <= ofe; b++)\n    {\n      mpz_bin_uiui (x, 2 * b, b);\n      printf (\"%d\", mpz_remove_twos (x));\n      if (b != ofe)\n\tprintf (\",\");\n    }\n  printf (\"\\n\");\n\n  return 0;\n}",
      "lines": 218,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int nail_bits, limb_bits, numb_bits;\n\n  if (argc != 3)\n    {\n      fprintf (stderr, \"Usage: gen-fac limbbits nailbits\\n\");\n      exit (1);\n    }\n  limb_bits = atoi (argv[1]);\n  nail_bits = atoi (argv[2]);\n  numb_bits = limb_bits - nail_bits;\n  if (limb_bits < 2 || nail_bits < 0 || numb_bits < 1)\n    {\n      fprintf (stderr, \"Invalid limb/nail bits %d,%d\\n\", limb_bits,\n\t       nail_bits);\n      exit (1);\n    }\n  gen_consts (numb_bits, nail_bits, limb_bits);\n  return 0;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/gen-fib.c": {
    "generate": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\ngenerate (int numb_bits)\n{\n  mpz_t  limit, l;\n  int    falloc, i;\n\n  mpz_init2 (limit, numb_bits + 1);\n  mpz_setbit (limit, numb_bits);\n\n  /* fib(2n) > 2^n, so use 2n as a limit for the table size */\n  falloc = 2 * numb_bits;\n  f = (mpz_t*) xmalloc (falloc * sizeof (*f));\n\n  mpz_init_set_ui (f[0], 1L);  /* F[-1] */\n  mpz_init_set_ui (f[1], 0L);  /* F[0] */\n\n  mpz_init (l);\n\n  for (i = 2; ; i++)\n    {\n      assert (i < falloc);\n\n      /* F[i] = F[i-1] + F[i-2] */\n      mpz_init (f[i]);\n      mpz_add (f[i], f[i-1], f[i-2]);\n      if (mpz_cmp (f[i], limit) >= 0)\n        break;\n\n      fnum = i+1;\n      fib_limit = i-1;\n\n      /* L[i] = F[i]+2*F[i-1] */\n      mpz_add (l, f[i], f[i-1]);\n      mpz_add (l, l, f[i-1]);\n\n      if (mpz_cmp (l, limit) < 0)\n        luc_limit = i-1;\n    }\n\n  mpz_clear (limit);\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "header": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\nheader (int numb_bits)\n{\n  printf (\"/* This file generated by gen-fib.c - DO NOT EDIT. */\\n\");\n  printf (\"\\n\");\n  printf (\"#if GMP_NUMB_BITS != %d\\n\", numb_bits);\n  printf (\"Error, error, this data is for %d bits\\n\", numb_bits);\n  printf (\"#endif\\n\");\n  printf (\"\\n\");\n  printf (\"#define FIB_TABLE_LIMIT         %d\\n\", fib_limit);\n  printf (\"#define FIB_TABLE_LUCNUM_LIMIT  %d\\n\", luc_limit);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "table": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\ntable (int numb_bits)\n{\n  int  i;\n\n  printf (\"/* This file generated by gen-fib.c - DO NOT EDIT. */\\n\");\n  printf (\"\\n\");\n  printf (\"#include \\\"gmp.h\\\"\\n\");\n  printf (\"#include \\\"gmp-impl.h\\\"\\n\");\n  printf (\"\\n\");\n  printf (\"#if GMP_NUMB_BITS != %d\\n\", numb_bits);\n  printf (\"Error, error, this data is for %d bits\\n\", numb_bits);\n  printf (\"#endif\\n\");\n  printf (\"\\n\");\n  printf (\"const mp_limb_t\\n\");\n  printf (\"__gmp_fib_table[FIB_TABLE_LIMIT+2] = {\\n\");\n\n  for (i = 0; i < fnum; i++)\n    {\n      printf (\"  CNST_LIMB (0x\");\n      mpz_out_str (stdout, 16, f[i]);\n      printf (\"),  /* %d */\\n\", i-1);\n    }\n  printf (\"};\\n\");\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int  limb_bits, nail_bits, numb_bits;\n\n  if (argc != 4)\n    {\n      fprintf (stderr, \"Usage: gen-fib <header|table> <limbbits> <nailbits>\\n\");\n      exit (1);\n    }\n\n  limb_bits = atoi (argv[2]);\n  nail_bits = atoi (argv[3]);\n\n  if (limb_bits <= 0\n      || nail_bits < 0\n      || nail_bits >= limb_bits)\n    {\n      fprintf (stderr, \"Invalid limb/nail bits: %d %d\\n\",\n               limb_bits, nail_bits);\n      exit (1);\n    }\n  numb_bits = limb_bits - nail_bits;\n\n  generate (numb_bits);\n\n  if (strcmp (argv[1], \"header\") == 0)\n    header (numb_bits);\n  else if (strcmp (argv[1], \"table\") == 0)\n    table (numb_bits);\n  else\n    {\n      fprintf (stderr, \"Invalid header/table choice: %s\\n\", argv[1]);\n      exit (1);\n    }\n\n  return 0;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/gen-jacobitab.c": {
    "encode": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static unsigned\nencode (unsigned a, unsigned b, unsigned d)\n{\n  unsigned i;\n\n  assert (d < 2);\n  assert (a < 4);\n  assert (b < 4);\n  assert ( (a | b ) & 1);\n\n  if (a == 3 && b == 3)\n    return d ? 7 : 12;\n\n  for (i = 0; i < 12; i++)\n    if (decode_table[i].a == a\n\t&& decode_table[i].b == b)\n      return i;\n\n  abort ();\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "main": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  unsigned bits;\n\n  for (bits = 0; bits < 208; bits++)\n    {\n      unsigned e, a, b, d_old, d, q;\n\n      if (bits && !(bits & 0xf))\n\tprintf(\"\\n\");\n\n      q = bits & 3;\n      d = (bits >> 2) & 1;\n\n      e = JACOBI_E (bits >> 3);\n      a = JACOBI_A (bits >> 3);\n      b = JACOBI_B (bits >> 3);\n      d_old = JACOBI_D (bits >> 3);\n\n      if (d != d_old && a == 3 && b == 3)\n\te ^= 1;\n\n      if (d == 1)\n\t{\n\t  if (b == 2)\n\t    e ^= (q & (a >> 1)) ^ (q >> 1);\n\t  a = (a - q * b) & 3;\n\t}\n      else\n\t{\n\t  if (a == 2)\n\t    e ^= (q & (b >> 1)) ^ (q >> 1);\n\t  b = (b - q * a) & 3;\n\t}\n\n      printf(\"%2d,\", (encode (a, b, d) << 1) | e);\n    }\n  printf(\"\\n\");\n\n  return 0;\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/gen-psqr.c": {
    "f_cmp_divisor": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\nf_cmp_divisor (const void *parg, const void *qarg)\n{\n  const struct factor_t *p, *q;\n  p = (const struct factor_t *) parg;\n  q = (const struct factor_t *) qarg;\n  if (p->divisor > q->divisor)\n    return 1;\n  else if (p->divisor < q->divisor)\n    return -1;\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "f_cmp_fraction": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "int\nf_cmp_fraction (const void *parg, const void *qarg)\n{\n  const struct factor_t *p, *q;\n  p = (const struct factor_t *) parg;\n  q = (const struct factor_t *) qarg;\n  if (p->fraction > q->fraction)\n    return 1;\n  else if (p->fraction < q->fraction)\n    return -1;\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mul_2exp_mod": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "int\nmul_2exp_mod (int n, int p, int m)\n{\n  while (--p >= 0)\n    n = (2 * n) % m;\n  return n;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "neg_mod": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int\nneg_mod (int n, int m)\n{\n  assert (n >= 0 && n < m);\n  return (n == 0 ? 0 : m-n);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "square_mask": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void\nsquare_mask (mpz_t mask, int m)\n{\n  int    p, i, r, idx;\n\n  p = mul_2exp_mod (1, mod_bits, m);\n  p = neg_mod (p, m);\n\n  mpz_set_ui (mask, 0L);\n  for (i = 0; i < m; i++)\n    {\n      r = (i * i) % m;\n      idx = (r * p) % m;\n      mpz_setbit (mask, (unsigned long) idx);\n    }\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "generate_sq_res_0x100": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "void\ngenerate_sq_res_0x100 (int limb_bits)\n{\n  int  i, res;\n\n  nsq_res_0x100 = (0x100 + limb_bits - 1) / limb_bits;\n  sq_res_0x100 = (mpz_t *) xmalloc (nsq_res_0x100 * sizeof (*sq_res_0x100));\n\n  for (i = 0; i < nsq_res_0x100; i++)\n    mpz_init_set_ui (sq_res_0x100[i], 0L);\n\n  for (i = 0; i < 0x100; i++)\n    {\n      res = (i * i) % 0x100;\n      mpz_setbit (sq_res_0x100[res / limb_bits],\n                  (unsigned long) (res % limb_bits));\n    }\n\n  sq_res_0x100_num = 0;\n  for (i = 0; i < nsq_res_0x100; i++)\n    sq_res_0x100_num += mpz_popcount (sq_res_0x100[i]);\n  sq_res_0x100_fraction = (double) sq_res_0x100_num / 256.0;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "generate_mod": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "void\ngenerate_mod (int limb_bits, int nail_bits)\n{\n  int    numb_bits = limb_bits - nail_bits;\n  int    i, divisor;\n\n  mpz_init_set_ui (pp, 0L);\n  mpz_init_set_ui (pp_norm, 0L);\n  mpz_init_set_ui (pp_inverted, 0L);\n\n  /* no more than limb_bits many factors in a one limb modulus (and of\n     course in reality nothing like that many) */\n  factor_alloc = limb_bits;\n  factor = (struct factor_t *) xmalloc (factor_alloc * sizeof (*factor));\n  rawfactor = (struct rawfactor_t *) xmalloc (factor_alloc * sizeof (*rawfactor));\n\n  if (numb_bits % 4 != 0)\n    {\n      strcpy (mod34_excuse, \"GMP_NUMB_BITS % 4 != 0\");\n      goto use_pp;\n    }\n\n  max_divisor = 2*limb_bits;\n  max_divisor_bits = log2_ceil (max_divisor);\n\n  if (numb_bits / 4 < max_divisor_bits)\n    {\n      /* Wind back to one limb worth of max_divisor, if that will let us use\n         mpn_mod_34lsub1.  */\n      max_divisor = limb_bits;\n      max_divisor_bits = log2_ceil (max_divisor);\n\n      if (numb_bits / 4 < max_divisor_bits)\n        {\n          strcpy (mod34_excuse, \"GMP_NUMB_BITS / 4 too small\");\n          goto use_pp;\n        }\n    }\n\n  {\n    /* Can use mpn_mod_34lsub1, find small factors of 2^mod34_bits-1. */\n    mpz_t  m, q, r;\n    int    multiplicity;\n\n    mod34_bits = (numb_bits / 4) * 3;\n\n    /* mpn_mod_34lsub1 returns a full limb value, PERFSQR_MOD_34 folds it at\n       the mod34_bits mark, adding the two halves for a remainder of at most\n       mod34_bits+1 many bits */\n    mod_bits = mod34_bits + 1;\n\n    mpz_init_set_ui (m, 1L);\n    mpz_mul_2exp (m, m, mod34_bits);\n    mpz_sub_ui (m, m, 1L);\n\n    mpz_init (q);\n    mpz_init (r);\n\n    for (i = 3; i <= max_divisor; i+=2)\n      {\n        if (! isprime (i))\n          continue;\n\n        mpz_tdiv_qr_ui (q, r, m, (unsigned long) i);\n        if (mpz_sgn (r) != 0)\n          continue;\n\n        /* if a repeated prime is found it's used as an i^n in one factor */\n        divisor = 1;\n        multiplicity = 0;\n        do\n          {\n            if (divisor > max_divisor / i)\n              break;\n            multiplicity++;\n            mpz_set (m, q);\n            mpz_tdiv_qr_ui (q, r, m, (unsigned long) i);\n          }\n        while (mpz_sgn (r) == 0);\n\n        assert (nrawfactor < factor_alloc);\n        rawfactor[nrawfactor].divisor = i;\n        rawfactor[nrawfactor].multiplicity = multiplicity;\n        nrawfactor++;\n      }\n\n    mpz_clear (m);\n    mpz_clear (q);\n    mpz_clear (r);\n  }\n\n  if (nrawfactor <= 2)\n    {\n      mpz_t  new_pp;\n\n      sprintf (mod34_excuse, \"only %d small factor%s\",\n               nrawfactor, nrawfactor == 1 ? \"\" : \"s\");\n\n    use_pp:\n      /* reset to two limbs of max_divisor, in case the mpn_mod_34lsub1 code\n         tried with just one */\n      max_divisor = 2*limb_bits;\n      max_divisor_bits = log2_ceil (max_divisor);\n\n      mpz_init (new_pp);\n      nrawfactor = 0;\n      mod_bits = MIN (numb_bits, limb_bits - max_divisor_bits);\n\n      /* one copy of each small prime */\n      mpz_set_ui (pp, 1L);\n      for (i = 3; i <= max_divisor; i+=2)\n        {\n          if (! isprime (i))\n            continue;\n\n          mpz_mul_ui (new_pp, pp, (unsigned long) i);\n          if (mpz_sizeinbase (new_pp, 2) > mod_bits)\n            break;\n          mpz_set (pp, new_pp);\n\n          assert (nrawfactor < factor_alloc);\n          rawfactor[nrawfactor].divisor = i;\n          rawfactor[nrawfactor].multiplicity = 1;\n          nrawfactor++;\n        }\n\n      /* Plus an extra copy of one or more of the primes selected, if that\n         still fits in max_divisor and the total in mod_bits.  Usually only\n         3 or 5 will be candidates */\n      for (i = nrawfactor-1; i >= 0; i--)\n        {\n          if (rawfactor[i].divisor > max_divisor / rawfactor[i].divisor)\n            continue;\n          mpz_mul_ui (new_pp, pp, (unsigned long) rawfactor[i].divisor);\n          if (mpz_sizeinbase (new_pp, 2) > mod_bits)\n            continue;\n          mpz_set (pp, new_pp);\n\n          rawfactor[i].multiplicity++;\n        }\n\n      mod_bits = mpz_sizeinbase (pp, 2);\n\n      mpz_set (pp_norm, pp);\n      while (mpz_sizeinbase (pp_norm, 2) < numb_bits)\n        mpz_add (pp_norm, pp_norm, pp_norm);\n\n      mpz_preinv_invert (pp_inverted, pp_norm, numb_bits);\n\n      mpz_clear (new_pp);\n    }\n\n  /* start the factor array */\n  for (i = 0; i < nrawfactor; i++)\n    {\n      int  j;\n      assert (nfactor < factor_alloc);\n      factor[nfactor].divisor = 1;\n      for (j = 0; j < rawfactor[i].multiplicity; j++)\n        factor[nfactor].divisor *= rawfactor[i].divisor;\n      nfactor++;\n    }\n\n combine:\n  /* Combine entries in the factor array.  Combine the smallest entry with\n     the biggest one that will fit with it (ie. under max_divisor), then\n     repeat that with the new smallest entry. */\n  qsort (factor, nfactor, sizeof (factor[0]), f_cmp_divisor);\n  for (i = nfactor-1; i >= 1; i--)\n    {\n      if (factor[i].divisor <= max_divisor / factor[0].divisor)\n        {\n          factor[0].divisor *= factor[i].divisor;\n          COLLAPSE_ELEMENT (factor, i, nfactor);\n          goto combine;\n        }\n    }\n\n  total_fraction = 1.0;\n  for (i = 0; i < nfactor; i++)\n    {\n      mpz_init (factor[i].inverse);\n      mpz_invert_ui_2exp (factor[i].inverse,\n                          (unsigned long) factor[i].divisor,\n                          (unsigned long) mod_bits);\n\n      mpz_init (factor[i].mask);\n      square_mask (factor[i].mask, factor[i].divisor);\n\n      /* fraction of possible squares */\n      factor[i].fraction = (double) mpz_popcount (factor[i].mask)\n        / factor[i].divisor;\n\n      /* total fraction of possible squares */\n      total_fraction *= factor[i].fraction;\n    }\n\n  /* best tests first (ie. smallest fraction) */\n  qsort (factor, nfactor, sizeof (factor[0]), f_cmp_fraction);\n}",
      "lines": 200,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "print": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        553,
        1
      ],
      "content": "void\nprint (int limb_bits, int nail_bits)\n{\n  int    i;\n  mpz_t  mhi, mlo;\n\n  printf (\"/* This file generated by gen-psqr.c - DO NOT EDIT. */\\n\");\n  printf (\"\\n\");\n\n  printf (\"#if GMP_LIMB_BITS != %d || GMP_NAIL_BITS != %d\\n\",\n          limb_bits, nail_bits);\n  printf (\"Error, error, this data is for %d bit limb and %d bit nail\\n\",\n          limb_bits, nail_bits);\n  printf (\"#endif\\n\");\n  printf (\"\\n\");\n\n  printf (\"/* Non-zero bit indicates a quadratic residue mod 0x100.\\n\");\n  printf (\"   This test identifies %.2f%% as non-squares (%d/256). */\\n\",\n          (1.0 - sq_res_0x100_fraction) * 100.0,\n          0x100 - sq_res_0x100_num);\n  printf (\"static const mp_limb_t\\n\");\n  printf (\"sq_res_0x100[%d] = {\\n\", nsq_res_0x100);\n  for (i = 0; i < nsq_res_0x100; i++)\n    {\n      printf (\"  CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, sq_res_0x100[i]);\n      printf (\"),\\n\");\n    }\n  printf (\"};\\n\");\n  printf (\"\\n\");\n\n  if (mpz_sgn (pp) != 0)\n    {\n      printf (\"/* mpn_mod_34lsub1 not used due to %s */\\n\", mod34_excuse);\n      printf (\"/* PERFSQR_PP = \");\n    }\n  else\n    printf (\"/* 2^%d-1 = \", mod34_bits);\n  for (i = 0; i < nrawfactor; i++)\n    {\n      if (i != 0)\n        printf (\" * \");\n      printf (\"%d\", rawfactor[i].divisor);\n      if (rawfactor[i].multiplicity != 1)\n        printf (\"^%d\", rawfactor[i].multiplicity);\n    }\n  printf (\" %s*/\\n\", mpz_sgn (pp) == 0 ? \"... \" : \"\");\n\n  printf (\"#define PERFSQR_MOD_BITS  %d\\n\", mod_bits);\n  if (mpz_sgn (pp) != 0)\n    {\n      printf (\"#define PERFSQR_PP            CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, pp);\n      printf (\")\\n\");\n      printf (\"#define PERFSQR_PP_NORM       CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, pp_norm);\n      printf (\")\\n\");\n      printf (\"#define PERFSQR_PP_INVERTED   CNST_LIMB(0x\");\n      mpz_out_str (stdout, 16, pp_inverted);\n      printf (\")\\n\");\n    }\n  printf (\"\\n\");\n\n  mpz_init (mhi);\n  mpz_init (mlo);\n\n  printf (\"/* This test identifies %.2f%% as non-squares. */\\n\",\n          (1.0 - total_fraction) * 100.0);\n  printf (\"#define PERFSQR_MOD_TEST(up, usize) \\\\\\n\");\n  printf (\"  do {                              \\\\\\n\");\n  printf (\"    mp_limb_t  r;                   \\\\\\n\");\n  if (mpz_sgn (pp) != 0)\n    printf (\"    PERFSQR_MOD_PP (r, up, usize);  \\\\\\n\");\n  else\n    printf (\"    PERFSQR_MOD_34 (r, up, usize);  \\\\\\n\");\n\n  for (i = 0; i < nfactor; i++)\n    {\n      printf (\"                                    \\\\\\n\");\n      printf (\"    /* %5.2f%% */                    \\\\\\n\",\n              (1.0 - factor[i].fraction) * 100.0);\n\n      printf (\"    PERFSQR_MOD_%d (r, CNST_LIMB(%2d), CNST_LIMB(0x\",\n              factor[i].divisor <= limb_bits ? 1 : 2,\n              factor[i].divisor);\n      mpz_out_str (stdout, 16, factor[i].inverse);\n      printf (\"), \\\\\\n\");\n      printf (\"                   CNST_LIMB(0x\");\n\n      if ( factor[i].divisor <= limb_bits)\n        {\n          mpz_out_str (stdout, 16, factor[i].mask);\n        }\n      else\n        {\n          mpz_tdiv_r_2exp (mlo, factor[i].mask, (unsigned long) limb_bits);\n          mpz_tdiv_q_2exp (mhi, factor[i].mask, (unsigned long) limb_bits);\n          mpz_out_str (stdout, 16, mhi);\n          printf (\"), CNST_LIMB(0x\");\n          mpz_out_str (stdout, 16, mlo);\n        }\n      printf (\")); \\\\\\n\");\n    }\n\n  printf (\"  } while (0)\\n\");\n  printf (\"\\n\");\n\n  printf (\"/* Grand total sq_res_0x100 and PERFSQR_MOD_TEST, %.2f%% non-squares. */\\n\",\n          (1.0 - (total_fraction * 44.0/256.0)) * 100.0);\n  printf (\"\\n\");\n\n  printf (\"/* helper for tests/mpz/t-perfsqr.c */\\n\");\n  printf (\"#define PERFSQR_DIVISORS  { 256,\");\n  for (i = 0; i < nfactor; i++)\n      printf (\" %d,\", factor[i].divisor);\n  printf (\" }\\n\");\n\n\n  mpz_clear (mhi);\n  mpz_clear (mlo);\n}",
      "lines": 121,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        555,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int  limb_bits, nail_bits;\n\n  if (argc != 3)\n    {\n      fprintf (stderr, \"Usage: gen-psqr <limbbits> <nailbits>\\n\");\n      exit (1);\n    }\n\n  limb_bits = atoi (argv[1]);\n  nail_bits = atoi (argv[2]);\n\n  if (limb_bits <= 0\n      || nail_bits < 0\n      || nail_bits >= limb_bits)\n    {\n      fprintf (stderr, \"Invalid limb/nail bits: %d %d\\n\",\n               limb_bits, nail_bits);\n      exit (1);\n    }\n\n  generate_sq_res_0x100 (limb_bits);\n  generate_mod (limb_bits, nail_bits);\n\n  print (limb_bits, nail_bits);\n\n  return 0;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/gen-trialdivtab.c": {
    "main": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  unsigned long t, p;\n  mpz_t ppp, acc, inv, gmp_numb_max, tmp, Bhalf;\n  mpz_t pre[7];\n  int i;\n  int start_p, end_p, interval_start, interval_end, omitted_p;\n  const char *endtok;\n  int stop;\n  int np, start_idx;\n\n  if (argc < 2)\n    {\n      fprintf (stderr, \"usage: %s bits endprime\\n\", argv[0]);\n      exit (1);\n    }\n\n  limb_bits = atoi (argv[1]);\n\n  end_p = 1290;\t\t\t/* default end prime */\n  if (argc == 3)\n    end_p = atoi (argv[2]);\n\n  printf (\"#if GMP_LIMB_BITS != %d\\n\", limb_bits);\n  printf (\"#error This table is for GMP_LIMB_BITS = %d\\n\", limb_bits);\n  printf (\"#endif\\n\\n\");\n\n  printf (\"#if GMP_NAIL_BITS != 0\\n\");\n  printf (\"#error This table does not support nails\\n\");\n  printf (\"#endif\\n\\n\");\n\n  for (i = 0; i < 7; i++)\n    mpz_init (pre[i]);\n\n  mpz_init_set_ui (gmp_numb_max, 1);\n  mpz_mul_2exp (gmp_numb_max, gmp_numb_max, limb_bits);\n  mpz_sub_ui (gmp_numb_max, gmp_numb_max, 1);\n\n  mpz_init (tmp);\n  mpz_init (inv);\n\n  mpz_init_set_ui (B, 1);  mpz_mul_2exp (B, B, limb_bits);\n  mpz_init_set_ui (Bhalf, 1);  mpz_mul_2exp (Bhalf, Bhalf, limb_bits - 1);\n\n  start_p = 3;\n\n  mpz_init_set_ui (ppp, 1);\n  mpz_init (acc);\n  interval_start = start_p;\n  omitted_p = 3;\n  interval_end = 0;\n\n/*  printf (\"static struct gmp_primes_dtab gmp_primes_dtab[] = {\\n\"); */\n\n  printf (\"#ifdef WANT_dtab\\n\");\n\n  for (t = start_p; t <= end_p; t += 2)\n    {\n      if (! isprime (t))\n\tcontinue;\n\n      mpz_mul_ui (acc, ppp, t);\n      stop = mpz_cmp (acc, Bhalf) >= 0;\n      if (!stop)\n\t{\n\t  mpn_mod_1s_4p_cps (pre, acc);\n\t  stop = sumspills (acc, pre + 2, 5);\n\t}\n\n      if (stop)\n\t{\n\t  for (p = interval_start; p <= interval_end; p += 2)\n\t    {\n\t      if (! isprime (p))\n\t\tcontinue;\n\n\t      printf (\"  P(%d,\", (int) p);\n\t      mpz_invert_ui_2exp (inv, p, limb_bits);\n\t      printf (\"CNST_LIMB(0x\");  mpz_out_str (stdout, 16, inv);  printf (\"),\");\n\n\t      mpz_tdiv_q_ui (tmp, gmp_numb_max, p);\n\t      printf (\"CNST_LIMB(0x\");  mpz_out_str (stdout, 16, tmp);\n\t      printf (\")),\\n\");\n\t    }\n\t  mpz_set_ui (ppp, t);\n\t  interval_start = t;\n\t  omitted_p = t;\n\t}\n      else\n\t{\n\t  mpz_set (ppp, acc);\n\t}\n      interval_end = t;\n    }\n  printf (\"#define SMALLEST_OMITTED_PRIME %d\\n\", (int) omitted_p);\n  printf (\"#endif\\n\");\n\n  printf (\"#ifdef WANT_ptab\\n\");\n\n/*  printf (\"static struct gmp_primes_ptab gmp_primes_ptab[] = {\\n\"); */\n\n  endtok = \"\";\n\n  mpz_set_ui (ppp, 1);\n  interval_start = start_p;\n  interval_end = 0;\n  np = 0;\n  start_idx = 0;\n  for (t = start_p; t <= end_p; t += 2)\n    {\n      if (! isprime (t))\n\tcontinue;\n\n      mpz_mul_ui (acc, ppp, t);\n\n      stop = mpz_cmp (acc, Bhalf) >= 0;\n      if (!stop)\n\t{\n\t  mpn_mod_1s_4p_cps (pre, acc);\n\t  stop = sumspills (acc, pre + 2, 5);\n\t}\n\n      if (stop)\n\t{\n\t  mpn_mod_1s_4p_cps (pre, ppp);\n\t  printf (\"%s\", endtok);\n\t  printf (\"  {CNST_LIMB(0x\");  mpz_out_str (stdout, 16, ppp);\n\t  printf (\"),{CNST_LIMB(0x\");  mpz_out_str (stdout, 16, pre[0]);\n\t  printf (\"),%d\", (int) PTR(pre[1])[0]);\n\t  for (i = 0; i < 5; i++)\n\t    {\n\t      printf (\",\");\n\t      printf (\"CNST_LIMB(0x\");  mpz_out_str (stdout, 16, pre[2 + i]);\n\t      printf (\")\");\n\t    }\n\t  printf (\"},\");\n\t  printf (\"%d,\", start_idx);\n\t  printf (\"%d}\", np - start_idx);\n\n\t  endtok = \",\\n\";\n\t  mpz_set_ui (ppp, t);\n\t  interval_start = t;\n\t  start_idx = np;\n\t}\n      else\n\t{\n\t  mpz_set (ppp, acc);\n\t}\n      interval_end = t;\n      np++;\n    }\n\n  printf (\"\\n\");\n  printf (\"#endif\\n\");\n\n  return 0;\n}",
      "lines": 158,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "mpz_log2": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "unsigned long\nmpz_log2 (mpz_t x)\n{\n  return mpz_sgn (x) ? mpz_sizeinbase (x, 2) : 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpn_mod_1s_4p_cps": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "void\nmpn_mod_1s_4p_cps (mpz_t cps[7], mpz_t bparm)\n{\n  mpz_t b, bi;\n  mpz_t B1modb, B2modb, B3modb, B4modb, B5modb;\n  mpz_t t;\n  int cnt;\n\n  mpz_init_set (b, bparm);\n\n  cnt = limb_bits - mpz_log2 (b);\n\n  mpz_init (bi);\n  mpz_init (t);\n  mpz_init (B1modb);\n  mpz_init (B2modb);\n  mpz_init (B3modb);\n  mpz_init (B4modb);\n  mpz_init (B5modb);\n\n  mpz_set_ui (t, 1);\n  mpz_mul_2exp (t, t, limb_bits - cnt);\n  mpz_sub (t, t, b);\n  mpz_mul_2exp (t, t, limb_bits);\n  mpz_tdiv_q (bi, t, b);\t\t/* bi = B^2/b, except msb */\n\n  mpz_set_ui (t, 1);\n  mpz_mul_2exp (t, t, limb_bits);\t/* t = B */\n  mpz_tdiv_r (B1modb, t, b);\n\n  mpz_mul_2exp (t, B1modb, limb_bits);\n  mpz_tdiv_r (B2modb, t, b);\n\n  mpz_mul_2exp (t, B2modb, limb_bits);\n  mpz_tdiv_r (B3modb, t, b);\n\n  mpz_mul_2exp (t, B3modb, limb_bits);\n  mpz_tdiv_r (B4modb, t, b);\n\n  mpz_mul_2exp (t, B4modb, limb_bits);\n  mpz_tdiv_r (B5modb, t, b);\n\n  mpz_set (cps[0], bi);\n  mpz_set_ui (cps[1], cnt);\n  mpz_tdiv_q_2exp (cps[2], B1modb, 0);\n  mpz_tdiv_q_2exp (cps[3], B2modb, 0);\n  mpz_tdiv_q_2exp (cps[4], B3modb, 0);\n  mpz_tdiv_q_2exp (cps[5], B4modb, 0);\n  mpz_tdiv_q_2exp (cps[6], B5modb, 0);\n\n  mpz_clear (b);\n  mpz_clear (bi);\n  mpz_clear (t);\n  mpz_clear (B1modb);\n  mpz_clear (B2modb);\n  mpz_clear (B3modb);\n  mpz_clear (B4modb);\n  mpz_clear (B5modb);\n}",
      "lines": 59,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sumspills": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nsumspills (mpz_t ppp, mpz_t *a, int n)\n{\n  mpz_t s;\n  int i, ret;\n\n  mpz_init_set (s, a[0]);\n\n  for (i = 1; i < n; i++)\n    {\n      mpz_add (s, s, a[i]);\n    }\n  ret = mpz_cmp (s, B) >= 0;\n  mpz_clear (s);\n\n  return ret;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/gmp-impl.h": {
    "mpn_mulmod_bnm1_itch": {
      "start_point": [
        1173,
        0
      ],
      "end_point": [
        1180,
        1
      ],
      "content": "static inline mp_size_t\nmpn_mulmod_bnm1_itch (mp_size_t rn, mp_size_t an, mp_size_t bn) {\n  mp_size_t n, itch;\n  n = rn >> 1;\n  itch = rn + 4 +\n    (an > n ? (bn > n ? rn : n) : 0);\n  return itch;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "mpn_sqrmod_bnm1_itch": {
      "start_point": [
        1186,
        0
      ],
      "end_point": [
        1193,
        1
      ],
      "content": "static inline mp_size_t\nmpn_sqrmod_bnm1_itch (mp_size_t rn, mp_size_t an) {\n  mp_size_t n, itch;\n  n = rn >> 1;\n  itch = rn + 3 +\n    (an > n ? an : 0);\n  return itch;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "_mpz_newalloc": {
      "start_point": [
        1945,
        0
      ],
      "end_point": [
        1952,
        1
      ],
      "content": "static inline void *\n_mpz_newalloc (mpz_ptr z, mp_size_t n)\n{\n  void * res = _mpz_realloc(z,n);\n  /* If we are checking the code, force a random change to limbs. */\n  ((mp_ptr) res)[0] = ~ ((mp_ptr) res)[ALLOC (z) - 1];\n  return res;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "*\n_mpz_newalloc (mpz_ptr z, mp_size_t n)",
        "*"
      ]
    },
    "log_n_max": {
      "start_point": [
        2006,
        0
      ],
      "end_point": [
        2012,
        1
      ],
      "content": "static inline unsigned\nlog_n_max (mp_limb_t n)\n{\n  unsigned log;\n  for (log = 8; n > __gmp_limbroots_table[log - 1]; log--);\n  return log;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned",
        "unsigned"
      ]
    },
    "mpn_jacobi_init": {
      "start_point": [
        4082,
        0
      ],
      "end_point": [
        4088,
        1
      ],
      "content": "static inline unsigned\nmpn_jacobi_init (unsigned a, unsigned b, unsigned s)\n{\n  ASSERT (b & 1);\n  ASSERT (s <= 1);\n  return ((a & 3) << 2) + (b & 2) + s;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned",
        "unsigned"
      ]
    },
    "mpn_jacobi_finish": {
      "start_point": [
        4090,
        0
      ],
      "end_point": [
        4097,
        1
      ],
      "content": "static inline int\nmpn_jacobi_finish (unsigned bits)\n{\n  /* (a, b) = (1,0) or (0,1) */\n  ASSERT ( (bits & 14) == 0);\n\n  return 1-2*(bits & 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "mpn_jacobi_update": {
      "start_point": [
        4099,
        0
      ],
      "end_point": [
        4132,
        1
      ],
      "content": "static inline unsigned\nmpn_jacobi_update (unsigned bits, unsigned denominator, unsigned q)\n{\n  /* FIXME: Could halve table size by not including the e bit in the\n   * index, and instead xor when updating. Then the lookup would be\n   * like\n   *\n   *   bits ^= table[((bits & 30) << 2) + (denominator << 2) + q];\n   */\n\n  ASSERT (bits < 26);\n  ASSERT (denominator < 2);\n  ASSERT (q < 4);\n\n  /* For almost all calls, denominator is constant and quite often q\n     is constant too. So use addition rather than or, so the compiler\n     can put the constant part can into the offset of an indexed\n     addressing instruction.\n\n     With constant denominator, the below table lookup is compiled to\n\n       C Constant q = 1, constant denominator = 1\n       movzbl table+5(%eax,8), %eax\n\n     or\n\n       C q in %edx, constant denominator = 1\n       movzbl table+4(%edx,%eax,8), %eax\n\n     One could maintain the state preshifted 3 bits, to save a shift\n     here, but at least on x86, that's no real saving.\n  */\n  return bits = jacobi_table[(bits << 3) + (denominator << 2) + q];\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned",
        "unsigned"
      ]
    },
    "mpn_add_nc": {
      "start_point": [
        4664,
        0
      ],
      "end_point": [
        4672,
        1
      ],
      "content": "static inline\nmp_limb_t\nmpn_add_nc (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n, mp_limb_t ci)\n{\n  mp_limb_t co;\n  co = mpn_add_n (rp, up, vp, n);\n  co += mpn_add_1 (rp, rp, n, ci);\n  return co;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_limb_t"
      ]
    },
    "mpn_sub_nc": {
      "start_point": [
        4679,
        0
      ],
      "end_point": [
        4686,
        1
      ],
      "content": "static inline mp_limb_t\nmpn_sub_nc (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n, mp_limb_t ci)\n{\n  mp_limb_t co;\n  co = mpn_sub_n (rp, up, vp, n);\n  co += mpn_sub_1 (rp, rp, n, ci);\n  return co;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_limb_t"
      ]
    },
    "mpn_toom6h_mul_itch": {
      "start_point": [
        5089,
        0
      ],
      "end_point": [
        5094,
        1
      ],
      "content": "static inline mp_size_t\nmpn_toom6h_mul_itch (mp_size_t an, mp_size_t bn) {\n  mp_size_t estimatedN;\n  estimatedN = (an + bn) / (size_t) 10 + 1;\n  return mpn_toom6_mul_n_itch (estimatedN * 6);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "mpn_toom8h_mul_itch": {
      "start_point": [
        5109,
        0
      ],
      "end_point": [
        5114,
        1
      ],
      "content": "static inline mp_size_t\nmpn_toom8h_mul_itch (mp_size_t an, mp_size_t bn) {\n  mp_size_t estimatedN;\n  estimatedN = (an + bn) / (size_t) 14 + 1;\n  return mpn_toom8_mul_n_itch (estimatedN * 8);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "mpn_toom32_mul_itch": {
      "start_point": [
        5116,
        0
      ],
      "end_point": [
        5123,
        1
      ],
      "content": "static inline mp_size_t\nmpn_toom32_mul_itch (mp_size_t an, mp_size_t bn)\n{\n  mp_size_t n = 1 + (2 * an >= 3 * bn ? (an - 1) / (size_t) 3 : (bn - 1) >> 1);\n  mp_size_t itch = 2 * n + 1;\n\n  return itch;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "mpn_toom42_mul_itch": {
      "start_point": [
        5125,
        0
      ],
      "end_point": [
        5130,
        1
      ],
      "content": "static inline mp_size_t\nmpn_toom42_mul_itch (mp_size_t an, mp_size_t bn)\n{\n  mp_size_t n = an >= 2 * bn ? (an + 3) >> 2 : (bn + 1) >> 1;\n  return 6 * n + 3;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "mpn_toom43_mul_itch": {
      "start_point": [
        5132,
        0
      ],
      "end_point": [
        5138,
        1
      ],
      "content": "static inline mp_size_t\nmpn_toom43_mul_itch (mp_size_t an, mp_size_t bn)\n{\n  mp_size_t n = 1 + (3 * an >= 4 * bn ? (an - 1) >> 2 : (bn - 1) / (size_t) 3);\n\n  return 6*n + 4;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "mpn_toom52_mul_itch": {
      "start_point": [
        5140,
        0
      ],
      "end_point": [
        5145,
        1
      ],
      "content": "static inline mp_size_t\nmpn_toom52_mul_itch (mp_size_t an, mp_size_t bn)\n{\n  mp_size_t n = 1 + (2 * an >= 5 * bn ? (an - 1) / (size_t) 5 : (bn - 1) >> 1);\n  return 6*n + 4;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "mpn_toom53_mul_itch": {
      "start_point": [
        5147,
        0
      ],
      "end_point": [
        5152,
        1
      ],
      "content": "static inline mp_size_t\nmpn_toom53_mul_itch (mp_size_t an, mp_size_t bn)\n{\n  mp_size_t n = 1 + (3 * an >= 5 * bn ? (an - 1) / (size_t) 5 : (bn - 1) / (size_t) 3);\n  return 10 * n + 10;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "mpn_toom62_mul_itch": {
      "start_point": [
        5154,
        0
      ],
      "end_point": [
        5159,
        1
      ],
      "content": "static inline mp_size_t\nmpn_toom62_mul_itch (mp_size_t an, mp_size_t bn)\n{\n  mp_size_t n = 1 + (an >= 3 * bn ? (an - 1) / (size_t) 6 : (bn - 1) >> 1);\n  return 10 * n + 10;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "mpn_toom63_mul_itch": {
      "start_point": [
        5161,
        0
      ],
      "end_point": [
        5166,
        1
      ],
      "content": "static inline mp_size_t\nmpn_toom63_mul_itch (mp_size_t an, mp_size_t bn)\n{\n  mp_size_t n = 1 + (an >= 2 * bn ? (an - 1) / (size_t) 6 : (bn - 1) / (size_t) 3);\n  return 9 * n + 3;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "mpn_toom54_mul_itch": {
      "start_point": [
        5168,
        0
      ],
      "end_point": [
        5173,
        1
      ],
      "content": "static inline mp_size_t\nmpn_toom54_mul_itch (mp_size_t an, mp_size_t bn)\n{\n  mp_size_t n = 1 + (4 * an >= 5 * bn ? (an - 1) / (size_t) 5 : (bn - 1) / (size_t) 4);\n  return 9 * n + 3;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "gmp_allocated_string": {
      "start_point": [
        5197,
        0
      ],
      "end_point": [
        5210,
        1
      ],
      "content": "class gmp_allocated_string {\n public:\n  char *str;\n  size_t len;\n  gmp_allocated_string(char *arg)\n  {\n    str = arg;\n    len = std::strlen (str);\n  }\n  ~gmp_allocated_string()\n  {\n    (*__gmp_free_func) (str, len+1);\n  }\n}",
      "lines": 14,
      "depth": 8,
      "decorators": null
    }
  },
  "gmp/gmp-6.1.2/gmpxx.h": {
    "__mpz_set_ui_safe": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "inline void __mpz_set_ui_safe(mpz_ptr p, unsigned long l)\n{\n  p->_mp_size = (l != 0);\n  p->_mp_d[0] = l & GMP_NUMB_MASK;\n#if __GMPZ_ULI_LIMBS > 1\n  l >>= GMP_NUMB_BITS;\n  p->_mp_d[1] = l;\n  p->_mp_size += (l != 0);\n#endif\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "inline",
        "inline",
        "void"
      ]
    },
    "__mpz_set_si_safe": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "inline void __mpz_set_si_safe(mpz_ptr p, long l)\n{\n  if(l < 0)\n  {\n    __mpz_set_ui_safe(p, -static_cast<unsigned long>(l));\n    mpz_neg(p, p);\n  }\n  else\n    __mpz_set_ui_safe(p, l);\n    // Note: we know the high bit of l is 0 so we could do slightly better\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "inline",
        "inline",
        "void"
      ]
    },
    "__gmpxx_abs_ui": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "inline unsigned long __gmpxx_abs_ui (signed long l)\n{\n  return l >= 0 ? static_cast<unsigned long>(l)\n\t  : -static_cast<unsigned long>(l);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "inline",
        "inline",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "eval": [
      {
        "start_point": [
          162,
          0
        ],
        "end_point": [
          165,
          62
        ],
        "content": "struct __gmp_unary_plus\n{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_set(z, w); }\n  static void eval(mpq_ptr q, mpq_srcptr r) { mpq_set(q, r); }",
        "lines": 4,
        "depth": 9,
        "decorators": [
          "struct __gmp_unary_plus\n{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_set(z, w); }",
          "struct",
          "__gmp_unary_plus",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_set(z, w); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w) { mpz_set(z, w);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w) {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ")",
          "{",
          "mpz_set",
          "(z, w)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          166,
          2
        ],
        "end_point": [
          166,
          62
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g) { mpf_set(f, g); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          169,
          0
        ],
        "end_point": [
          172,
          62
        ],
        "content": "struct __gmp_unary_minus\n{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_neg(z, w); }\n  static void eval(mpq_ptr q, mpq_srcptr r) { mpq_neg(q, r); }",
        "lines": 4,
        "depth": 9,
        "decorators": [
          "struct __gmp_unary_minus\n{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_neg(z, w); }",
          "struct",
          "__gmp_unary_minus",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_neg(z, w); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w) { mpz_neg(z, w);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w) {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ")",
          "{",
          "mpz_neg",
          "(z, w)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          173,
          2
        ],
        "end_point": [
          173,
          62
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g) { mpf_neg(f, g); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          181,
          0
        ],
        "end_point": [
          196,
          3
        ],
        "content": "struct __gmp_binary_plus\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_add(z, w, v); }\n\n  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)\n  {\n    // Ideally, those checks should happen earlier so that the tree\n    // generated for a+0+b would just be sum(a,b).\n    if (__GMPXX_CONSTANT(l) && l == 0)\n    {\n      if (z != w) mpz_set(z, w);\n    }\n    else\n      mpz_add_ui(z, w, l);\n  }",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "struct __gmp_binary_plus\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_add(z, w, v); }",
          "struct",
          "__gmp_binary_plus",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_add(z, w, v); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_add(z, w, v);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ",",
          "mpz_srcptr v",
          "mpz_srcptr",
          "v",
          ")",
          "{",
          "mpz_add",
          "(z, w, v)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ",",
          "v",
          "v",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          197,
          2
        ],
        "end_point": [
          198,
          20
        ],
        "content": "static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)\n  { eval(z, w, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          199,
          2
        ],
        "end_point": [
          205,
          3
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)\n  {\n    if (l >= 0)\n      eval(z, w, static_cast<unsigned long>(l));\n    else\n      mpz_sub_ui(z, w, -static_cast<unsigned long>(l));\n  }",
        "lines": 7,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          206,
          2
        ],
        "end_point": [
          207,
          20
        ],
        "content": "static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)\n  { eval(z, w, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          208,
          2
        ],
        "end_point": [
          209,
          47
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, double d)\n  {  __GMPXX_TMPZ_D;    mpz_add (z, w, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          210,
          2
        ],
        "end_point": [
          211,
          20
        ],
        "content": "static void eval(mpz_ptr z, double d, mpz_srcptr w)\n  { eval(z, w, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          213,
          2
        ],
        "end_point": [
          214,
          23
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, mpq_srcptr s)\n  { mpq_add(q, r, s); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          216,
          2
        ],
        "end_point": [
          233,
          3
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, unsigned long int l)\n  {\n    if (__GMPXX_CONSTANT(l) && l == 0)\n    {\n      if (q != r) mpq_set(q, r);\n    }\n    else\n    {\n      if (q == r)\n        mpz_addmul_ui(mpq_numref(q), mpq_denref(q), l);\n      else\n      {\n        mpz_mul_ui(mpq_numref(q), mpq_denref(r), l);\n        mpz_add(mpq_numref(q), mpq_numref(q), mpq_numref(r));\n        mpz_set(mpq_denref(q), mpq_denref(r));\n      }\n    }\n  }",
        "lines": 18,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          234,
          2
        ],
        "end_point": [
          235,
          20
        ],
        "content": "static void eval(mpq_ptr q, unsigned long int l, mpq_srcptr r)\n  { eval(q, r, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          238,
          2
        ],
        "end_point": [
          239,
          20
        ],
        "content": "static void eval(mpq_ptr q, signed long int l, mpq_srcptr r)\n  { eval(q, r, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          240,
          2
        ],
        "end_point": [
          241,
          47
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, double d)\n  {  __GMPXX_TMPQ_D;    mpq_add (q, r, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          242,
          2
        ],
        "end_point": [
          243,
          20
        ],
        "content": "static void eval(mpq_ptr q, double d, mpq_srcptr r)\n  { eval(q, r, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          245,
          2
        ],
        "end_point": [
          255,
          3
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, mpz_srcptr z)\n  {\n    if (q == r)\n      mpz_addmul(mpq_numref(q), mpq_denref(q), z);\n    else\n    {\n      mpz_mul(mpq_numref(q), mpq_denref(r), z);\n      mpz_add(mpq_numref(q), mpq_numref(q), mpq_numref(r));\n      mpz_set(mpq_denref(q), mpq_denref(r));\n    }\n  }",
        "lines": 11,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          256,
          2
        ],
        "end_point": [
          257,
          20
        ],
        "content": "static void eval(mpq_ptr q, mpz_srcptr z, mpq_srcptr r)\n  { eval(q, r, z); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          259,
          2
        ],
        "end_point": [
          260,
          23
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)\n  { mpf_add(f, g, h); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          262,
          2
        ],
        "end_point": [
          263,
          26
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, unsigned long int l)\n  { mpf_add_ui(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          264,
          2
        ],
        "end_point": [
          265,
          26
        ],
        "content": "static void eval(mpf_ptr f, unsigned long int l, mpf_srcptr g)\n  { mpf_add_ui(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          266,
          2
        ],
        "end_point": [
          272,
          3
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, signed long int l)\n  {\n    if (l >= 0)\n      mpf_add_ui(f, g, l);\n    else\n      mpf_sub_ui(f, g, -static_cast<unsigned long>(l));\n  }",
        "lines": 7,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          273,
          2
        ],
        "end_point": [
          274,
          20
        ],
        "content": "static void eval(mpf_ptr f, signed long int l, mpf_srcptr g)\n  { eval(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          275,
          2
        ],
        "end_point": [
          282,
          3
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, double d)\n  {\n    mpf_t temp;\n    mpf_init2(temp, 8*sizeof(double));\n    mpf_set_d(temp, d);\n    mpf_add(f, g, temp);\n    mpf_clear(temp);\n  }",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          283,
          2
        ],
        "end_point": [
          284,
          20
        ],
        "content": "static void eval(mpf_ptr f, double d, mpf_srcptr g)\n  { eval(f, g, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          287,
          0
        ],
        "end_point": [
          300,
          3
        ],
        "content": "struct __gmp_binary_minus\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_sub(z, w, v); }\n\n  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)\n  {\n    if (__GMPXX_CONSTANT(l) && l == 0)\n    {\n      if (z != w) mpz_set(z, w);\n    }\n    else\n      mpz_sub_ui(z, w, l);\n  }",
        "lines": 14,
        "depth": 9,
        "decorators": [
          "struct __gmp_binary_minus\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_sub(z, w, v); }",
          "struct",
          "__gmp_binary_minus",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_sub(z, w, v); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_sub(z, w, v);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ",",
          "mpz_srcptr v",
          "mpz_srcptr",
          "v",
          ")",
          "{",
          "mpz_sub",
          "(z, w, v)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ",",
          "v",
          "v",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          301,
          2
        ],
        "end_point": [
          309,
          3
        ],
        "content": "static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)\n  {\n    if (__GMPXX_CONSTANT(l) && l == 0)\n    {\n      mpz_neg(z, w);\n    }\n    else\n      mpz_ui_sub(z, l, w);\n  }",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          310,
          2
        ],
        "end_point": [
          316,
          3
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)\n  {\n    if (l >= 0)\n      eval(z, w, static_cast<unsigned long>(l));\n    else\n      mpz_add_ui(z, w, -static_cast<unsigned long>(l));\n  }",
        "lines": 7,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          317,
          2
        ],
        "end_point": [
          326,
          3
        ],
        "content": "static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)\n  {\n    if (l >= 0)\n      eval(z, static_cast<unsigned long>(l), w);\n    else\n      {\n        mpz_add_ui(z, w, -static_cast<unsigned long>(l));\n        mpz_neg(z, z);\n      }\n  }",
        "lines": 10,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          327,
          2
        ],
        "end_point": [
          328,
          47
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, double d)\n  {  __GMPXX_TMPZ_D;    mpz_sub (z, w, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          329,
          2
        ],
        "end_point": [
          330,
          47
        ],
        "content": "static void eval(mpz_ptr z, double d, mpz_srcptr w)\n  {  __GMPXX_TMPZ_D;    mpz_sub (z, temp, w); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          332,
          2
        ],
        "end_point": [
          333,
          23
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, mpq_srcptr s)\n  { mpq_sub(q, r, s); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          335,
          2
        ],
        "end_point": [
          352,
          3
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, unsigned long int l)\n  {\n    if (__GMPXX_CONSTANT(l) && l == 0)\n    {\n      if (q != r) mpq_set(q, r);\n    }\n    else\n    {\n      if (q == r)\n        mpz_submul_ui(mpq_numref(q), mpq_denref(q), l);\n      else\n      {\n        mpz_mul_ui(mpq_numref(q), mpq_denref(r), l);\n        mpz_sub(mpq_numref(q), mpq_numref(r), mpq_numref(q));\n        mpz_set(mpq_denref(q), mpq_denref(r));\n      }\n    }\n  }",
        "lines": 18,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          353,
          2
        ],
        "end_point": [
          354,
          35
        ],
        "content": "static void eval(mpq_ptr q, unsigned long int l, mpq_srcptr r)\n  { eval(q, r, l); mpq_neg(q, q); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          355,
          2
        ],
        "end_point": [
          361,
          3
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, signed long int l)\n  {\n    if (l >= 0)\n      eval(q, r, static_cast<unsigned long>(l));\n    else\n      __gmp_binary_plus::eval(q, r, -static_cast<unsigned long>(l));\n  }",
        "lines": 7,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          362,
          2
        ],
        "end_point": [
          363,
          35
        ],
        "content": "static void eval(mpq_ptr q, signed long int l, mpq_srcptr r)\n  { eval(q, r, l); mpq_neg(q, q); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          364,
          2
        ],
        "end_point": [
          365,
          47
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, double d)\n  {  __GMPXX_TMPQ_D;    mpq_sub (q, r, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          366,
          2
        ],
        "end_point": [
          367,
          47
        ],
        "content": "static void eval(mpq_ptr q, double d, mpq_srcptr r)\n  {  __GMPXX_TMPQ_D;    mpq_sub (q, temp, r); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          369,
          2
        ],
        "end_point": [
          379,
          3
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, mpz_srcptr z)\n  {\n    if (q == r)\n      mpz_submul(mpq_numref(q), mpq_denref(q), z);\n    else\n    {\n      mpz_mul(mpq_numref(q), mpq_denref(r), z);\n      mpz_sub(mpq_numref(q), mpq_numref(r), mpq_numref(q));\n      mpz_set(mpq_denref(q), mpq_denref(r));\n    }\n  }",
        "lines": 11,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          380,
          2
        ],
        "end_point": [
          381,
          35
        ],
        "content": "static void eval(mpq_ptr q, mpz_srcptr z, mpq_srcptr r)\n  { eval(q, r, z); mpq_neg(q, q); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          383,
          2
        ],
        "end_point": [
          384,
          23
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)\n  { mpf_sub(f, g, h); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          386,
          2
        ],
        "end_point": [
          387,
          26
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, unsigned long int l)\n  { mpf_sub_ui(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          388,
          2
        ],
        "end_point": [
          389,
          26
        ],
        "content": "static void eval(mpf_ptr f, unsigned long int l, mpf_srcptr g)\n  { mpf_ui_sub(f, l, g); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          390,
          2
        ],
        "end_point": [
          396,
          3
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, signed long int l)\n  {\n    if (l >= 0)\n      mpf_sub_ui(f, g, l);\n    else\n      mpf_add_ui(f, g, -static_cast<unsigned long>(l));\n  }",
        "lines": 7,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          397,
          2
        ],
        "end_point": [
          404,
          3
        ],
        "content": "static void eval(mpf_ptr f, signed long int l, mpf_srcptr g)\n  {\n    if (l >= 0)\n      mpf_sub_ui(f, g, l);\n    else\n      mpf_add_ui(f, g, -static_cast<unsigned long>(l));\n    mpf_neg(f, f);\n  }",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          405,
          2
        ],
        "end_point": [
          412,
          3
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, double d)\n  {\n    mpf_t temp;\n    mpf_init2(temp, 8*sizeof(double));\n    mpf_set_d(temp, d);\n    mpf_sub(f, g, temp);\n    mpf_clear(temp);\n  }",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          413,
          2
        ],
        "end_point": [
          420,
          3
        ],
        "content": "static void eval(mpf_ptr f, double d, mpf_srcptr g)\n  {\n    mpf_t temp;\n    mpf_init2(temp, 8*sizeof(double));\n    mpf_set_d(temp, d);\n    mpf_sub(f, temp, g);\n    mpf_clear(temp);\n  }",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          424,
          0
        ],
        "end_point": [
          431,
          1
        ],
        "content": "inline void\n__gmp_binary_plus::eval(mpq_ptr q, mpq_srcptr r, signed long int l)\n{\n  if (l >= 0)\n    eval(q, r, static_cast<unsigned long>(l));\n  else\n    __gmp_binary_minus::eval(q, r, -static_cast<unsigned long>(l));\n}",
        "lines": 8,
        "depth": 11,
        "decorators": [
          "inline",
          "inline",
          "void",
          "__gmp_binary_plus::",
          "__gmp_binary_plus",
          "::"
        ]
      },
      {
        "start_point": [
          444,
          2
        ],
        "end_point": [
          452,
          3
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, mp_bitcnt_t l)\n  {\n    if (__GMPXX_CONSTANT(l) && (l == 0))\n    {\n      if (q != r) mpq_set(q, r);\n    }\n    else\n      mpq_mul_2exp(q, r, l);\n  }",
        "lines": 9,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          453,
          2
        ],
        "end_point": [
          454,
          28
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, mp_bitcnt_t l)\n  { mpf_mul_2exp(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          468,
          2
        ],
        "end_point": [
          476,
          3
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, mp_bitcnt_t l)\n  {\n    if (__GMPXX_CONSTANT(l) && (l == 0))\n    {\n      if (q != r) mpq_set(q, r);\n    }\n    else\n      mpq_div_2exp(q, r, l);\n  }",
        "lines": 9,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          477,
          2
        ],
        "end_point": [
          478,
          28
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, mp_bitcnt_t l)\n  { mpf_div_2exp(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          481,
          0
        ],
        "end_point": [
          504,
          3
        ],
        "content": "struct __gmp_binary_multiplies\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_mul(z, w, v); }\n\n  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)\n  {\n// gcc-3.3 doesn't have __builtin_ctzl. Don't bother optimizing for old gcc.\n#if __GMP_GNUC_PREREQ(3, 4)\n    if (__GMPXX_CONSTANT(l) && (l & (l-1)) == 0)\n    {\n      if (l == 0)\n      {\n        z->_mp_size = 0;\n      }\n      else\n      {\n        __gmp_binary_lshift::eval(z, w, __builtin_ctzl(l));\n      }\n    }\n    else\n#endif\n      mpz_mul_ui(z, w, l);\n  }",
        "lines": 24,
        "depth": 14,
        "decorators": [
          "struct __gmp_binary_multiplies\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_mul(z, w, v); }",
          "struct",
          "__gmp_binary_multiplies",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_mul(z, w, v); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_mul(z, w, v);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ",",
          "mpz_srcptr v",
          "mpz_srcptr",
          "v",
          ")",
          "{",
          "mpz_mul",
          "(z, w, v)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ",",
          "v",
          "v",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          505,
          2
        ],
        "end_point": [
          506,
          20
        ],
        "content": "static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)\n  { eval(z, w, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          507,
          2
        ],
        "end_point": [
          518,
          3
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)\n  {\n    if (__GMPXX_CONSTANT_TRUE(l >= 0))\n      eval(z, w, static_cast<unsigned long>(l));\n    else if (__GMPXX_CONSTANT_TRUE(l <= 0))\n      {\n        eval(z, w, -static_cast<unsigned long>(l));\n\tmpz_neg(z, z);\n      }\n    else\n      mpz_mul_si (z, w, l);\n  }",
        "lines": 12,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          519,
          2
        ],
        "end_point": [
          520,
          20
        ],
        "content": "static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)\n  { eval(z, w, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          521,
          2
        ],
        "end_point": [
          522,
          47
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, double d)\n  {  __GMPXX_TMPZ_D;    mpz_mul (z, w, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          523,
          2
        ],
        "end_point": [
          524,
          20
        ],
        "content": "static void eval(mpz_ptr z, double d, mpz_srcptr w)\n  { eval(z, w, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          526,
          2
        ],
        "end_point": [
          527,
          23
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, mpq_srcptr s)\n  { mpq_mul(q, r, s); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          529,
          2
        ],
        "end_point": [
          549,
          3
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, unsigned long int l)\n  {\n#if __GMP_GNUC_PREREQ(3, 4)\n    if (__GMPXX_CONSTANT(l) && (l & (l-1)) == 0)\n    {\n      if (l == 0)\n      {\n\tmpq_set_ui(q, 0, 1);\n      }\n      else\n      {\n        __gmp_binary_lshift::eval(q, r, __builtin_ctzl(l));\n      }\n    }\n    else\n#endif\n    {\n      __GMPXX_TMPQ_UI;\n      mpq_mul (q, r, temp);\n    }\n  }",
        "lines": 21,
        "depth": 14,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          550,
          2
        ],
        "end_point": [
          551,
          20
        ],
        "content": "static void eval(mpq_ptr q, unsigned long int l, mpq_srcptr r)\n  { eval(q, r, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          552,
          2
        ],
        "end_point": [
          566,
          3
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, signed long int l)\n  {\n    if (__GMPXX_CONSTANT_TRUE(l >= 0))\n      eval(q, r, static_cast<unsigned long>(l));\n    else if (__GMPXX_CONSTANT_TRUE(l <= 0))\n      {\n        eval(q, r, -static_cast<unsigned long>(l));\n\tmpq_neg(q, q);\n      }\n    else\n      {\n\t__GMPXX_TMPQ_SI;\n\tmpq_mul (q, r, temp);\n      }\n  }",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          567,
          2
        ],
        "end_point": [
          568,
          20
        ],
        "content": "static void eval(mpq_ptr q, signed long int l, mpq_srcptr r)\n  { eval(q, r, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          569,
          2
        ],
        "end_point": [
          570,
          47
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, double d)\n  {  __GMPXX_TMPQ_D;    mpq_mul (q, r, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          571,
          2
        ],
        "end_point": [
          572,
          20
        ],
        "content": "static void eval(mpq_ptr q, double d, mpq_srcptr r)\n  { eval(q, r, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          574,
          2
        ],
        "end_point": [
          575,
          23
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)\n  { mpf_mul(f, g, h); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          577,
          2
        ],
        "end_point": [
          578,
          26
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, unsigned long int l)\n  { mpf_mul_ui(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          579,
          2
        ],
        "end_point": [
          580,
          26
        ],
        "content": "static void eval(mpf_ptr f, unsigned long int l, mpf_srcptr g)\n  { mpf_mul_ui(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          581,
          2
        ],
        "end_point": [
          590,
          3
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, signed long int l)\n  {\n    if (l >= 0)\n      mpf_mul_ui(f, g, l);\n    else\n      {\n\tmpf_mul_ui(f, g, -static_cast<unsigned long>(l));\n\tmpf_neg(f, f);\n      }\n  }",
        "lines": 10,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          591,
          2
        ],
        "end_point": [
          592,
          20
        ],
        "content": "static void eval(mpf_ptr f, signed long int l, mpf_srcptr g)\n  { eval(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          593,
          2
        ],
        "end_point": [
          600,
          3
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, double d)\n  {\n    mpf_t temp;\n    mpf_init2(temp, 8*sizeof(double));\n    mpf_set_d(temp, d);\n    mpf_mul(f, g, temp);\n    mpf_clear(temp);\n  }",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          601,
          2
        ],
        "end_point": [
          602,
          20
        ],
        "content": "static void eval(mpf_ptr f, double d, mpf_srcptr g)\n  { eval(f, g, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          605,
          0
        ],
        "end_point": [
          627,
          3
        ],
        "content": "struct __gmp_binary_divides\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_tdiv_q(z, w, v); }\n\n  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)\n  {\n#if __GMP_GNUC_PREREQ(3, 4)\n    // Don't optimize division by 0...\n    if (__GMPXX_CONSTANT(l) && (l & (l-1)) == 0 && l != 0)\n    {\n      if (l == 1)\n      {\n        if (z != w) mpz_set(z, w);\n      }\n      else\n        mpz_tdiv_q_2exp(z, w, __builtin_ctzl(l));\n        // warning: do not use rshift (fdiv)\n    }\n    else\n#endif\n      mpz_tdiv_q_ui(z, w, l);\n  }",
        "lines": 23,
        "depth": 13,
        "decorators": [
          "struct __gmp_binary_divides\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_tdiv_q(z, w, v); }",
          "struct",
          "__gmp_binary_divides",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_tdiv_q(z, w, v); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_tdiv_q(z, w, v);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ",",
          "mpz_srcptr v",
          "mpz_srcptr",
          "v",
          ")",
          "{",
          "mpz_tdiv_q",
          "(z, w, v)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ",",
          "v",
          "v",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          628,
          2
        ],
        "end_point": [
          648,
          3
        ],
        "content": "static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)\n  {\n    if (mpz_sgn(w) >= 0)\n      {\n\tif (mpz_fits_ulong_p(w))\n\t  mpz_set_ui(z, l / mpz_get_ui(w));\n\telse\n\t  mpz_set_ui(z, 0);\n      }\n    else\n      {\n\tmpz_neg(z, w);\n\tif (mpz_fits_ulong_p(z))\n\t  {\n\t    mpz_set_ui(z, l / mpz_get_ui(z));\n\t    mpz_neg(z, z);\n\t  }\n\telse\n\t  mpz_set_ui(z, 0);\n      }\n  }",
        "lines": 21,
        "depth": 13,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          649,
          2
        ],
        "end_point": [
          658,
          3
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)\n  {\n    if (l >= 0)\n      eval(z, w, static_cast<unsigned long>(l));\n    else\n      {\n\teval(z, w, -static_cast<unsigned long>(l));\n\tmpz_neg(z, z);\n      }\n  }",
        "lines": 10,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          659,
          2
        ],
        "end_point": [
          669,
          3
        ],
        "content": "static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)\n  {\n    if (mpz_fits_slong_p(w))\n      mpz_set_si(z, l / mpz_get_si(w));\n    else\n      {\n        /* if w is bigger than a long then the quotient must be zero, unless\n           l==LONG_MIN and w==-LONG_MIN in which case the quotient is -1 */\n        mpz_set_si (z, (mpz_cmpabs_ui (w, __gmpxx_abs_ui(l)) == 0 ? -1 : 0));\n      }\n  }",
        "lines": 11,
        "depth": 15,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          670,
          2
        ],
        "end_point": [
          671,
          50
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, double d)\n  {  __GMPXX_TMPZ_D;    mpz_tdiv_q (z, w, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          672,
          2
        ],
        "end_point": [
          673,
          50
        ],
        "content": "static void eval(mpz_ptr z, double d, mpz_srcptr w)\n  {  __GMPXX_TMPZ_D;    mpz_tdiv_q (z, temp, w); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          675,
          2
        ],
        "end_point": [
          676,
          23
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, mpq_srcptr s)\n  { mpq_div(q, r, s); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          678,
          2
        ],
        "end_point": [
          689,
          3
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, unsigned long int l)\n  {\n#if __GMP_GNUC_PREREQ(3, 4)\n    if (__GMPXX_CONSTANT(l) && (l & (l-1)) == 0 && l != 0)\n      __gmp_binary_rshift::eval(q, r, __builtin_ctzl(l));\n    else\n#endif\n    {\n      __GMPXX_TMPQ_UI;\n      mpq_div (q, r, temp);\n    }\n  }",
        "lines": 12,
        "depth": 13,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          690,
          2
        ],
        "end_point": [
          691,
          47
        ],
        "content": "static void eval(mpq_ptr q, unsigned long int l, mpq_srcptr r)\n  {  __GMPXX_TMPQ_UI;   mpq_div (q, temp, r); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          692,
          2
        ],
        "end_point": [
          706,
          3
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, signed long int l)\n  {\n    if (__GMPXX_CONSTANT_TRUE(l >= 0))\n      eval(q, r, static_cast<unsigned long>(l));\n    else if (__GMPXX_CONSTANT_TRUE(l <= 0))\n      {\n        eval(q, r, -static_cast<unsigned long>(l));\n\tmpq_neg(q, q);\n      }\n    else\n      {\n\t__GMPXX_TMPQ_SI;\n\tmpq_div (q, r, temp);\n      }\n  }",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          707,
          2
        ],
        "end_point": [
          708,
          47
        ],
        "content": "static void eval(mpq_ptr q, signed long int l, mpq_srcptr r)\n  {  __GMPXX_TMPQ_SI;   mpq_div (q, temp, r); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          709,
          2
        ],
        "end_point": [
          710,
          47
        ],
        "content": "static void eval(mpq_ptr q, mpq_srcptr r, double d)\n  {  __GMPXX_TMPQ_D;    mpq_div (q, r, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          711,
          2
        ],
        "end_point": [
          712,
          47
        ],
        "content": "static void eval(mpq_ptr q, double d, mpq_srcptr r)\n  {  __GMPXX_TMPQ_D;    mpq_div (q, temp, r); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          714,
          2
        ],
        "end_point": [
          715,
          23
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)\n  { mpf_div(f, g, h); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          717,
          2
        ],
        "end_point": [
          718,
          26
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, unsigned long int l)\n  { mpf_div_ui(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          719,
          2
        ],
        "end_point": [
          720,
          26
        ],
        "content": "static void eval(mpf_ptr f, unsigned long int l, mpf_srcptr g)\n  { mpf_ui_div(f, l, g); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          721,
          2
        ],
        "end_point": [
          730,
          3
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, signed long int l)\n  {\n    if (l >= 0)\n      mpf_div_ui(f, g, l);\n    else\n      {\n\tmpf_div_ui(f, g, -static_cast<unsigned long>(l));\n\tmpf_neg(f, f);\n      }\n  }",
        "lines": 10,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          731,
          2
        ],
        "end_point": [
          740,
          3
        ],
        "content": "static void eval(mpf_ptr f, signed long int l, mpf_srcptr g)\n  {\n    if (l >= 0)\n      mpf_ui_div(f, l, g);\n    else\n      {\n\tmpf_ui_div(f, -static_cast<unsigned long>(l), g);\n\tmpf_neg(f, f);\n      }\n  }",
        "lines": 10,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          741,
          2
        ],
        "end_point": [
          748,
          3
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, double d)\n  {\n    mpf_t temp;\n    mpf_init2(temp, 8*sizeof(double));\n    mpf_set_d(temp, d);\n    mpf_div(f, g, temp);\n    mpf_clear(temp);\n  }",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          749,
          2
        ],
        "end_point": [
          756,
          3
        ],
        "content": "static void eval(mpf_ptr f, double d, mpf_srcptr g)\n  {\n    mpf_t temp;\n    mpf_init2(temp, 8*sizeof(double));\n    mpf_set_d(temp, d);\n    mpf_div(f, temp, g);\n    mpf_clear(temp);\n  }",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          759,
          0
        ],
        "end_point": [
          765,
          29
        ],
        "content": "struct __gmp_binary_modulus\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_tdiv_r(z, w, v); }\n\n  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)\n  { mpz_tdiv_r_ui(z, w, l); }",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "struct __gmp_binary_modulus\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_tdiv_r(z, w, v); }",
          "struct",
          "__gmp_binary_modulus",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_tdiv_r(z, w, v); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_tdiv_r(z, w, v);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ",",
          "mpz_srcptr v",
          "mpz_srcptr",
          "v",
          ")",
          "{",
          "mpz_tdiv_r",
          "(z, w, v)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ",",
          "v",
          "v",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          766,
          2
        ],
        "end_point": [
          783,
          3
        ],
        "content": "static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)\n  {\n    if (mpz_sgn(w) >= 0)\n      {\n\tif (mpz_fits_ulong_p(w))\n\t  mpz_set_ui(z, l % mpz_get_ui(w));\n\telse\n\t  mpz_set_ui(z, l);\n      }\n    else\n      {\n\tmpz_neg(z, w);\n\tif (mpz_fits_ulong_p(z))\n\t  mpz_set_ui(z, l % mpz_get_ui(z));\n\telse\n\t  mpz_set_ui(z, l);\n      }\n  }",
        "lines": 18,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          784,
          2
        ],
        "end_point": [
          787,
          3
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)\n  {\n    mpz_tdiv_r_ui (z, w, __gmpxx_abs_ui(l));\n  }",
        "lines": 4,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          788,
          2
        ],
        "end_point": [
          798,
          3
        ],
        "content": "static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)\n  {\n    if (mpz_fits_slong_p(w))\n      mpz_set_si(z, l % mpz_get_si(w));\n    else\n      {\n        /* if w is bigger than a long then the remainder is l unchanged,\n           unless l==LONG_MIN and w==-LONG_MIN in which case it's 0 */\n        mpz_set_si (z, mpz_cmpabs_ui (w, __gmpxx_abs_ui(l)) == 0 ? 0 : l);\n      }\n  }",
        "lines": 11,
        "depth": 14,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          799,
          2
        ],
        "end_point": [
          800,
          50
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, double d)\n  {  __GMPXX_TMPZ_D;    mpz_tdiv_r (z, w, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          801,
          2
        ],
        "end_point": [
          802,
          50
        ],
        "content": "static void eval(mpz_ptr z, double d, mpz_srcptr w)\n  {  __GMPXX_TMPZ_D;    mpz_tdiv_r (z, temp, w); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          805,
          0
        ],
        "end_point": [
          811,
          48
        ],
        "content": "struct __gmp_binary_and\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_and(z, w, v); }\n\n  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)\n  {  __GMPXX_TMPZ_UI;   mpz_and (z, w, temp);  }",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "struct __gmp_binary_and\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_and(z, w, v); }",
          "struct",
          "__gmp_binary_and",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_and(z, w, v); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_and(z, w, v);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ",",
          "mpz_srcptr v",
          "mpz_srcptr",
          "v",
          ")",
          "{",
          "mpz_and",
          "(z, w, v)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ",",
          "v",
          "v",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          812,
          2
        ],
        "end_point": [
          813,
          21
        ],
        "content": "static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)\n  { eval(z, w, l);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          814,
          2
        ],
        "end_point": [
          815,
          48
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)\n  {  __GMPXX_TMPZ_SI;   mpz_and (z, w, temp);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          816,
          2
        ],
        "end_point": [
          817,
          21
        ],
        "content": "static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)\n  { eval(z, w, l);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          818,
          2
        ],
        "end_point": [
          819,
          47
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, double d)\n  {  __GMPXX_TMPZ_D;    mpz_and (z, w, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          820,
          2
        ],
        "end_point": [
          821,
          21
        ],
        "content": "static void eval(mpz_ptr z, double d, mpz_srcptr w)\n  { eval(z, w, d);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          824,
          0
        ],
        "end_point": [
          829,
          48
        ],
        "content": "struct __gmp_binary_ior\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_ior(z, w, v); }\n  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)\n  {  __GMPXX_TMPZ_UI;   mpz_ior (z, w, temp);  }",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "struct __gmp_binary_ior\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_ior(z, w, v); }",
          "struct",
          "__gmp_binary_ior",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_ior(z, w, v); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_ior(z, w, v);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ",",
          "mpz_srcptr v",
          "mpz_srcptr",
          "v",
          ")",
          "{",
          "mpz_ior",
          "(z, w, v)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ",",
          "v",
          "v",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          830,
          2
        ],
        "end_point": [
          831,
          21
        ],
        "content": "static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)\n  { eval(z, w, l);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          832,
          2
        ],
        "end_point": [
          833,
          48
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)\n  {  __GMPXX_TMPZ_SI;   mpz_ior (z, w, temp);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          834,
          2
        ],
        "end_point": [
          835,
          21
        ],
        "content": "static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)\n  { eval(z, w, l);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          836,
          2
        ],
        "end_point": [
          837,
          47
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, double d)\n  {  __GMPXX_TMPZ_D;    mpz_ior (z, w, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          838,
          2
        ],
        "end_point": [
          839,
          21
        ],
        "content": "static void eval(mpz_ptr z, double d, mpz_srcptr w)\n  { eval(z, w, d);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          842,
          0
        ],
        "end_point": [
          847,
          48
        ],
        "content": "struct __gmp_binary_xor\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_xor(z, w, v); }\n  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)\n  {  __GMPXX_TMPZ_UI;   mpz_xor (z, w, temp);  }",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "struct __gmp_binary_xor\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_xor(z, w, v); }",
          "struct",
          "__gmp_binary_xor",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_xor(z, w, v); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_xor(z, w, v);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ",",
          "mpz_srcptr v",
          "mpz_srcptr",
          "v",
          ")",
          "{",
          "mpz_xor",
          "(z, w, v)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ",",
          "v",
          "v",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          848,
          2
        ],
        "end_point": [
          849,
          21
        ],
        "content": "static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)\n  { eval(z, w, l);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          850,
          2
        ],
        "end_point": [
          851,
          48
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)\n  {  __GMPXX_TMPZ_SI;   mpz_xor (z, w, temp);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          852,
          2
        ],
        "end_point": [
          853,
          21
        ],
        "content": "static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)\n  { eval(z, w, l);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          854,
          2
        ],
        "end_point": [
          855,
          47
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, double d)\n  {  __GMPXX_TMPZ_D;    mpz_xor (z, w, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          856,
          2
        ],
        "end_point": [
          857,
          21
        ],
        "content": "static void eval(mpz_ptr z, double d, mpz_srcptr w)\n  { eval(z, w, d);  }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          860,
          0
        ],
        "end_point": [
          865,
          30
        ],
        "content": "struct __gmp_cmp_function\n{\n  static int eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w); }\n\n  static int eval(mpz_srcptr z, unsigned long int l)\n  { return mpz_cmp_ui(z, l); }",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "struct __gmp_cmp_function\n{\n  static int eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w); }",
          "struct",
          "__gmp_cmp_function",
          "{\n  static int eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w); }",
          "{",
          "static int eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w);",
          "static",
          "static",
          "int",
          "eval(mpz_srcptr z, mpz_srcptr w) { return",
          "eval",
          "(mpz_srcptr z, mpz_srcptr w)",
          "(",
          "mpz_srcptr z",
          "mpz_srcptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ")",
          "{",
          "return",
          "mpz_cmp",
          "(z, w)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ")",
          ";",
          "}",
          "static",
          "static",
          "int",
          "int"
        ]
      },
      {
        "start_point": [
          866,
          2
        ],
        "end_point": [
          867,
          31
        ],
        "content": "static int eval(unsigned long int l, mpz_srcptr z)\n  { return -mpz_cmp_ui(z, l); }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          868,
          2
        ],
        "end_point": [
          869,
          30
        ],
        "content": "static int eval(mpz_srcptr z, signed long int l)\n  { return mpz_cmp_si(z, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          870,
          2
        ],
        "end_point": [
          871,
          31
        ],
        "content": "static int eval(signed long int l, mpz_srcptr z)\n  { return -mpz_cmp_si(z, l); }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          872,
          2
        ],
        "end_point": [
          873,
          29
        ],
        "content": "static int eval(mpz_srcptr z, double d)\n  { return mpz_cmp_d(z, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          874,
          2
        ],
        "end_point": [
          875,
          30
        ],
        "content": "static int eval(double d, mpz_srcptr z)\n  { return -mpz_cmp_d(z, d); }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          877,
          2
        ],
        "end_point": [
          877,
          71
        ],
        "content": "static int eval(mpq_srcptr q, mpq_srcptr r) { return mpq_cmp(q, r); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          879,
          2
        ],
        "end_point": [
          880,
          33
        ],
        "content": "static int eval(mpq_srcptr q, unsigned long int l)\n  { return mpq_cmp_ui(q, l, 1); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          881,
          2
        ],
        "end_point": [
          882,
          34
        ],
        "content": "static int eval(unsigned long int l, mpq_srcptr q)\n  { return -mpq_cmp_ui(q, l, 1); }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          883,
          2
        ],
        "end_point": [
          884,
          33
        ],
        "content": "static int eval(mpq_srcptr q, signed long int l)\n  { return mpq_cmp_si(q, l, 1); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          885,
          2
        ],
        "end_point": [
          886,
          34
        ],
        "content": "static int eval(signed long int l, mpq_srcptr q)\n  { return -mpq_cmp_si(q, l, 1); }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          887,
          2
        ],
        "end_point": [
          888,
          51
        ],
        "content": "static int eval(mpq_srcptr q, double d)\n  {  __GMPXX_TMPQ_D;    return mpq_cmp (q, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          889,
          2
        ],
        "end_point": [
          890,
          51
        ],
        "content": "static int eval(double d, mpq_srcptr q)\n  {  __GMPXX_TMPQ_D;    return mpq_cmp (temp, q); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          891,
          2
        ],
        "end_point": [
          892,
          29
        ],
        "content": "static int eval(mpq_srcptr q, mpz_srcptr z)\n  { return mpq_cmp_z(q, z); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          893,
          2
        ],
        "end_point": [
          894,
          30
        ],
        "content": "static int eval(mpz_srcptr z, mpq_srcptr q)\n  { return -mpq_cmp_z(q, z); }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          896,
          2
        ],
        "end_point": [
          896,
          71
        ],
        "content": "static int eval(mpf_srcptr f, mpf_srcptr g) { return mpf_cmp(f, g); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          898,
          2
        ],
        "end_point": [
          899,
          30
        ],
        "content": "static int eval(mpf_srcptr f, unsigned long int l)\n  { return mpf_cmp_ui(f, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          900,
          2
        ],
        "end_point": [
          901,
          31
        ],
        "content": "static int eval(unsigned long int l, mpf_srcptr f)\n  { return -mpf_cmp_ui(f, l); }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          902,
          2
        ],
        "end_point": [
          903,
          30
        ],
        "content": "static int eval(mpf_srcptr f, signed long int l)\n  { return mpf_cmp_si(f, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          904,
          2
        ],
        "end_point": [
          905,
          31
        ],
        "content": "static int eval(signed long int l, mpf_srcptr f)\n  { return -mpf_cmp_si(f, l); }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          906,
          2
        ],
        "end_point": [
          907,
          29
        ],
        "content": "static int eval(mpf_srcptr f, double d)\n  { return mpf_cmp_d(f, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          908,
          2
        ],
        "end_point": [
          909,
          30
        ],
        "content": "static int eval(double d, mpf_srcptr f)\n  { return -mpf_cmp_d(f, d); }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          910,
          2
        ],
        "end_point": [
          911,
          29
        ],
        "content": "static int eval(mpf_srcptr f, mpz_srcptr z)\n  { return mpf_cmp_z(f, z); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          912,
          2
        ],
        "end_point": [
          913,
          30
        ],
        "content": "static int eval(mpz_srcptr z, mpf_srcptr f)\n  { return -mpf_cmp_z(f, z); }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          914,
          2
        ],
        "end_point": [
          922,
          3
        ],
        "content": "static int eval(mpf_srcptr f, mpq_srcptr q)\n  {\n    mpf_t qf;\n    mpf_init(qf); /* Should we use the precision of f?  */\n    mpf_set_q(qf, q);\n    int ret = eval(f, qf);\n    mpf_clear(qf);\n    return ret;\n  }",
        "lines": 9,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          923,
          2
        ],
        "end_point": [
          924,
          25
        ],
        "content": "static int eval(mpq_srcptr q, mpf_srcptr f)\n  { return -eval(f, q); }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          927,
          0
        ],
        "end_point": [
          932,
          35
        ],
        "content": "struct __gmp_binary_equal\n{\n  static bool eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w) == 0; }\n\n  static bool eval(mpz_srcptr z, unsigned long int l)\n  { return mpz_cmp_ui(z, l) == 0; }",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "struct __gmp_binary_equal\n{\n  static bool eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w) == 0; }",
          "struct",
          "__gmp_binary_equal",
          "{\n  static bool eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w) == 0; }",
          "{",
          "static bool eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w) == 0;",
          "static",
          "static",
          "bool",
          "eval(mpz_srcptr z, mpz_srcptr w) { return",
          "eval",
          "(mpz_srcptr z, mpz_srcptr w)",
          "(",
          "mpz_srcptr z",
          "mpz_srcptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ")",
          "{",
          "return",
          "mpz_cmp",
          "(z, w)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ")",
          "== 0",
          "==",
          "0",
          ";",
          "}",
          "static",
          "static",
          "bool",
          "bool"
        ]
      },
      {
        "start_point": [
          933,
          2
        ],
        "end_point": [
          934,
          24
        ],
        "content": "static bool eval(unsigned long int l, mpz_srcptr z)\n  { return eval(z, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          935,
          2
        ],
        "end_point": [
          936,
          35
        ],
        "content": "static bool eval(mpz_srcptr z, signed long int l)\n  { return mpz_cmp_si(z, l) == 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          937,
          2
        ],
        "end_point": [
          938,
          24
        ],
        "content": "static bool eval(signed long int l, mpz_srcptr z)\n  { return eval(z, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          939,
          2
        ],
        "end_point": [
          940,
          34
        ],
        "content": "static bool eval(mpz_srcptr z, double d)\n  { return mpz_cmp_d(z, d) == 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          941,
          2
        ],
        "end_point": [
          942,
          24
        ],
        "content": "static bool eval(double d, mpz_srcptr z)\n  { return eval(z, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          944,
          2
        ],
        "end_point": [
          945,
          34
        ],
        "content": "static bool eval(mpq_srcptr q, mpq_srcptr r)\n  { return mpq_equal(q, r) != 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          947,
          2
        ],
        "end_point": [
          948,
          38
        ],
        "content": "static bool eval(mpq_srcptr q, unsigned long int l)\n  { return mpq_cmp_ui(q, l, 1) == 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          949,
          2
        ],
        "end_point": [
          950,
          24
        ],
        "content": "static bool eval(unsigned long int l, mpq_srcptr q)\n  { return eval(q, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          951,
          2
        ],
        "end_point": [
          952,
          38
        ],
        "content": "static bool eval(mpq_srcptr q, signed long int l)\n  { return mpq_cmp_si(q, l, 1) == 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          953,
          2
        ],
        "end_point": [
          954,
          24
        ],
        "content": "static bool eval(signed long int l, mpq_srcptr q)\n  { return eval(q, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          955,
          2
        ],
        "end_point": [
          956,
          58
        ],
        "content": "static bool eval(mpq_srcptr q, double d)\n  {  __GMPXX_TMPQ_D;    return mpq_equal (q, temp) != 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          957,
          2
        ],
        "end_point": [
          958,
          24
        ],
        "content": "static bool eval(double d, mpq_srcptr q)\n  { return eval(q, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          959,
          2
        ],
        "end_point": [
          960,
          34
        ],
        "content": "static bool eval(mpq_srcptr q, mpz_srcptr z)\n  { return mpq_cmp_z(q, z) == 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          961,
          2
        ],
        "end_point": [
          962,
          24
        ],
        "content": "static bool eval(mpz_srcptr z, mpq_srcptr q)\n  { return eval(q, z); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          964,
          2
        ],
        "end_point": [
          964,
          77
        ],
        "content": "static bool eval(mpf_srcptr f, mpf_srcptr g) { return mpf_cmp(f, g) == 0; }",
        "lines": 1,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          966,
          2
        ],
        "end_point": [
          967,
          35
        ],
        "content": "static bool eval(mpf_srcptr f, unsigned long int l)\n  { return mpf_cmp_ui(f, l) == 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          968,
          2
        ],
        "end_point": [
          969,
          24
        ],
        "content": "static bool eval(unsigned long int l, mpf_srcptr f)\n  { return eval(f, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          970,
          2
        ],
        "end_point": [
          971,
          35
        ],
        "content": "static bool eval(mpf_srcptr f, signed long int l)\n  { return mpf_cmp_si(f, l) == 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          972,
          2
        ],
        "end_point": [
          973,
          24
        ],
        "content": "static bool eval(signed long int l, mpf_srcptr f)\n  { return eval(f, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          974,
          2
        ],
        "end_point": [
          975,
          34
        ],
        "content": "static bool eval(mpf_srcptr f, double d)\n  { return mpf_cmp_d(f, d) == 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          976,
          2
        ],
        "end_point": [
          977,
          24
        ],
        "content": "static bool eval(double d, mpf_srcptr f)\n  { return eval(f, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          978,
          2
        ],
        "end_point": [
          979,
          34
        ],
        "content": "static bool eval(mpf_srcptr f, mpz_srcptr z)\n  { return mpf_cmp_z(f, z) == 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          980,
          2
        ],
        "end_point": [
          981,
          24
        ],
        "content": "static bool eval(mpz_srcptr z, mpf_srcptr f)\n  { return eval(f, z); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          982,
          2
        ],
        "end_point": [
          983,
          49
        ],
        "content": "static bool eval(mpf_srcptr f, mpq_srcptr q)\n  { return __gmp_cmp_function::eval(f, q) == 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          984,
          2
        ],
        "end_point": [
          985,
          24
        ],
        "content": "static bool eval(mpq_srcptr q, mpf_srcptr f)\n  { return eval(f, q); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          988,
          0
        ],
        "end_point": [
          993,
          34
        ],
        "content": "struct __gmp_binary_less\n{\n  static bool eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w) < 0; }\n\n  static bool eval(mpz_srcptr z, unsigned long int l)\n  { return mpz_cmp_ui(z, l) < 0; }",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "struct __gmp_binary_less\n{\n  static bool eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w) < 0; }",
          "struct",
          "__gmp_binary_less",
          "{\n  static bool eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w) < 0; }",
          "{",
          "static bool eval(mpz_srcptr z, mpz_srcptr w) { return mpz_cmp(z, w) < 0;",
          "static",
          "static",
          "bool",
          "eval(mpz_srcptr z, mpz_srcptr w) { return",
          "eval",
          "(mpz_srcptr z, mpz_srcptr w)",
          "(",
          "mpz_srcptr z",
          "mpz_srcptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ")",
          "{",
          "return",
          "mpz_cmp",
          "(z, w)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ")",
          "< 0",
          "<",
          "0",
          ";",
          "}",
          "static",
          "static",
          "bool",
          "bool"
        ]
      },
      {
        "start_point": [
          994,
          2
        ],
        "end_point": [
          995,
          34
        ],
        "content": "static bool eval(unsigned long int l, mpz_srcptr z)\n  { return mpz_cmp_ui(z, l) > 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          996,
          2
        ],
        "end_point": [
          997,
          34
        ],
        "content": "static bool eval(mpz_srcptr z, signed long int l)\n  { return mpz_cmp_si(z, l) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          998,
          2
        ],
        "end_point": [
          999,
          34
        ],
        "content": "static bool eval(signed long int l, mpz_srcptr z)\n  { return mpz_cmp_si(z, l) > 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1000,
          2
        ],
        "end_point": [
          1001,
          33
        ],
        "content": "static bool eval(mpz_srcptr z, double d)\n  { return mpz_cmp_d(z, d) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1002,
          2
        ],
        "end_point": [
          1003,
          33
        ],
        "content": "static bool eval(double d, mpz_srcptr z)\n  { return mpz_cmp_d(z, d) > 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1005,
          2
        ],
        "end_point": [
          1005,
          76
        ],
        "content": "static bool eval(mpq_srcptr q, mpq_srcptr r) { return mpq_cmp(q, r) < 0; }",
        "lines": 1,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1007,
          2
        ],
        "end_point": [
          1008,
          37
        ],
        "content": "static bool eval(mpq_srcptr q, unsigned long int l)\n  { return mpq_cmp_ui(q, l, 1) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1009,
          2
        ],
        "end_point": [
          1010,
          37
        ],
        "content": "static bool eval(unsigned long int l, mpq_srcptr q)\n  { return mpq_cmp_ui(q, l, 1) > 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1011,
          2
        ],
        "end_point": [
          1012,
          37
        ],
        "content": "static bool eval(mpq_srcptr q, signed long int l)\n  { return mpq_cmp_si(q, l, 1) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1013,
          2
        ],
        "end_point": [
          1014,
          37
        ],
        "content": "static bool eval(signed long int l, mpq_srcptr q)\n  { return mpq_cmp_si(q, l, 1) > 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1015,
          2
        ],
        "end_point": [
          1016,
          55
        ],
        "content": "static bool eval(mpq_srcptr q, double d)\n  {  __GMPXX_TMPQ_D;    return mpq_cmp (q, temp) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1017,
          2
        ],
        "end_point": [
          1018,
          55
        ],
        "content": "static bool eval(double d, mpq_srcptr q)\n  {  __GMPXX_TMPQ_D;    return mpq_cmp (temp, q) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1019,
          2
        ],
        "end_point": [
          1020,
          33
        ],
        "content": "static bool eval(mpq_srcptr q, mpz_srcptr z)\n  { return mpq_cmp_z(q, z) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1021,
          2
        ],
        "end_point": [
          1022,
          33
        ],
        "content": "static bool eval(mpz_srcptr z, mpq_srcptr q)\n  { return mpq_cmp_z(q, z) > 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1024,
          2
        ],
        "end_point": [
          1024,
          76
        ],
        "content": "static bool eval(mpf_srcptr f, mpf_srcptr g) { return mpf_cmp(f, g) < 0; }",
        "lines": 1,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1026,
          2
        ],
        "end_point": [
          1027,
          34
        ],
        "content": "static bool eval(mpf_srcptr f, unsigned long int l)\n  { return mpf_cmp_ui(f, l) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1028,
          2
        ],
        "end_point": [
          1029,
          34
        ],
        "content": "static bool eval(unsigned long int l, mpf_srcptr f)\n  { return mpf_cmp_ui(f, l) > 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1030,
          2
        ],
        "end_point": [
          1031,
          34
        ],
        "content": "static bool eval(mpf_srcptr f, signed long int l)\n  { return mpf_cmp_si(f, l) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1032,
          2
        ],
        "end_point": [
          1033,
          34
        ],
        "content": "static bool eval(signed long int l, mpf_srcptr f)\n  { return mpf_cmp_si(f, l) > 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1034,
          2
        ],
        "end_point": [
          1035,
          33
        ],
        "content": "static bool eval(mpf_srcptr f, double d)\n  { return mpf_cmp_d(f, d) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1036,
          2
        ],
        "end_point": [
          1037,
          33
        ],
        "content": "static bool eval(double d, mpf_srcptr f)\n  { return mpf_cmp_d(f, d) > 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1038,
          2
        ],
        "end_point": [
          1039,
          33
        ],
        "content": "static bool eval(mpf_srcptr f, mpz_srcptr z)\n  { return mpf_cmp_z(f, z) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1040,
          2
        ],
        "end_point": [
          1041,
          33
        ],
        "content": "static bool eval(mpz_srcptr z, mpf_srcptr f)\n  { return mpf_cmp_z(f, z) > 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1042,
          2
        ],
        "end_point": [
          1043,
          48
        ],
        "content": "static bool eval(mpf_srcptr f, mpq_srcptr q)\n  { return __gmp_cmp_function::eval(f, q) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1044,
          2
        ],
        "end_point": [
          1045,
          48
        ],
        "content": "static bool eval(mpq_srcptr q, mpf_srcptr f)\n  { return __gmp_cmp_function::eval(q, f) < 0; }",
        "lines": 2,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          1054,
          0
        ],
        "end_point": [
          1058,
          59
        ],
        "content": "struct __gmp_unary_increment\n{\n  static void eval(mpz_ptr z) { mpz_add_ui(z, z, 1); }\n  static void eval(mpq_ptr q)\n  { mpz_add(mpq_numref(q), mpq_numref(q), mpq_denref(q)); }",
        "lines": 5,
        "depth": 9,
        "decorators": [
          "struct __gmp_unary_increment\n{\n  static void eval(mpz_ptr z) { mpz_add_ui(z, z, 1); }",
          "struct",
          "__gmp_unary_increment",
          "{\n  static void eval(mpz_ptr z) { mpz_add_ui(z, z, 1); }",
          "{",
          "static void eval(mpz_ptr z) { mpz_add_ui(z, z, 1);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z) {",
          "eval",
          "(mpz_ptr z)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ")",
          "{",
          "mpz_add_ui",
          "(z, z, 1)",
          "(",
          "z",
          "z",
          ",",
          "z",
          "z",
          ", 1",
          ",",
          "1",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          1059,
          2
        ],
        "end_point": [
          1059,
          54
        ],
        "content": "static void eval(mpf_ptr f) { mpf_add_ui(f, f, 1); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1062,
          0
        ],
        "end_point": [
          1066,
          59
        ],
        "content": "struct __gmp_unary_decrement\n{\n  static void eval(mpz_ptr z) { mpz_sub_ui(z, z, 1); }\n  static void eval(mpq_ptr q)\n  { mpz_sub(mpq_numref(q), mpq_numref(q), mpq_denref(q)); }",
        "lines": 5,
        "depth": 9,
        "decorators": [
          "struct __gmp_unary_decrement\n{\n  static void eval(mpz_ptr z) { mpz_sub_ui(z, z, 1); }",
          "struct",
          "__gmp_unary_decrement",
          "{\n  static void eval(mpz_ptr z) { mpz_sub_ui(z, z, 1); }",
          "{",
          "static void eval(mpz_ptr z) { mpz_sub_ui(z, z, 1);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z) {",
          "eval",
          "(mpz_ptr z)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ")",
          "{",
          "mpz_sub_ui",
          "(z, z, 1)",
          "(",
          "z",
          "z",
          ",",
          "z",
          "z",
          ", 1",
          ",",
          "1",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          1067,
          2
        ],
        "end_point": [
          1067,
          54
        ],
        "content": "static void eval(mpf_ptr f) { mpf_sub_ui(f, f, 1); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1070,
          0
        ],
        "end_point": [
          1073,
          62
        ],
        "content": "struct __gmp_abs_function\n{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_abs(z, w); }\n  static void eval(mpq_ptr q, mpq_srcptr r) { mpq_abs(q, r); }",
        "lines": 4,
        "depth": 9,
        "decorators": [
          "struct __gmp_abs_function\n{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_abs(z, w); }",
          "struct",
          "__gmp_abs_function",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_abs(z, w); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w) { mpz_abs(z, w);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w) {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ")",
          "{",
          "mpz_abs",
          "(z, w)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          1074,
          2
        ],
        "end_point": [
          1074,
          62
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g) { mpf_abs(f, g); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1092,
          0
        ],
        "end_point": [
          1095,
          63
        ],
        "content": "struct __gmp_sqrt_function\n{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_sqrt(z, w); }\n  static void eval(mpf_ptr f, mpf_srcptr g) { mpf_sqrt(f, g); }",
        "lines": 4,
        "depth": 9,
        "decorators": [
          "struct __gmp_sqrt_function\n{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_sqrt(z, w); }",
          "struct",
          "__gmp_sqrt_function",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w) { mpz_sqrt(z, w); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w) { mpz_sqrt(z, w);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w) {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ")",
          "{",
          "mpz_sqrt",
          "(z, w)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          1098,
          0
        ],
        "end_point": [
          1121,
          3
        ],
        "content": "struct __gmp_hypot_function\n{\n  static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)\n  {\n    mpf_t temp;\n    mpf_init2(temp, mpf_get_prec(f));\n    mpf_mul(temp, g, g);\n    mpf_mul(f, h, h);\n    mpf_add(f, f, temp);\n    mpf_sqrt(f, f);\n    mpf_clear(temp);\n  }\n\n  static void eval(mpf_ptr f, mpf_srcptr g, unsigned long int l)\n  {\n    mpf_t temp;\n    mpf_init2(temp, mpf_get_prec(f));\n    mpf_mul(temp, g, g);\n    mpf_set_ui(f, l);\n    mpf_mul_ui(f, f, l);\n    mpf_add(f, f, temp);\n    mpf_clear(temp);\n    mpf_sqrt(f, f);\n  }",
        "lines": 24,
        "depth": 10,
        "decorators": [
          "struct __gmp_hypot_function\n{\n  static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)\n  {\n    mpf_t temp;\n    mpf_init2(temp, mpf_get_prec(f));\n    mpf_mul(temp, g, g);\n    mpf_mul(f, h, h);\n    mpf_add(f, f, temp);\n    mpf_sqrt(f, f);\n    mpf_clear(temp);\n  }",
          "struct",
          "__gmp_hypot_function",
          "{\n  static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)\n  {\n    mpf_t temp;\n    mpf_init2(temp, mpf_get_prec(f));\n    mpf_mul(temp, g, g);\n    mpf_mul(f, h, h);\n    mpf_add(f, f, temp);\n    mpf_sqrt(f, f);\n    mpf_clear(temp);\n  }",
          "{",
          "static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)\n  {\n    mpf_t temp;",
          "static",
          "static",
          "void",
          "eval",
          "(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)",
          "(",
          "mpf_ptr f",
          "mpf_ptr",
          "f",
          ",",
          "mpf_srcptr g",
          "mpf_srcptr",
          "g",
          ",",
          "mpf_srcptr h",
          "mpf_srcptr",
          "h",
          ")",
          "{\n    mpf_t temp",
          "{",
          "mpf_t",
          "temp",
          ";",
          "mpf_init2(temp, mpf_get_prec(f));",
          "mpf_init2(temp, mpf_get_prec(f))",
          "mpf_init2",
          "(",
          "temp,",
          "temp",
          ",",
          "mpf_get_prec(f)",
          "mpf_get_prec",
          "(f)",
          "(f)",
          "(",
          "f",
          "f",
          ")",
          ")",
          ";",
          "mpf_mul(temp, g, g);",
          "mpf_mul(temp, g, g)",
          "mpf_mul",
          "(",
          "temp",
          "temp",
          ", g, g",
          ",",
          "g",
          ",",
          "g",
          ")",
          ";",
          "mpf_mul(f, h, h);",
          "mpf_mul(f, h, h)",
          "mpf_mul",
          "(",
          "f, h,",
          "f",
          ",",
          "h",
          ",",
          "h",
          "h",
          ")",
          ";",
          "mpf_add(f, f, temp);",
          "mpf_add(f, f, temp)",
          "mpf_add",
          "(",
          "f, f,",
          "f",
          ",",
          "f",
          ",",
          "temp",
          "temp",
          ")",
          ";",
          "mpf_sqrt(f, f);",
          "mpf_sqrt(f, f)",
          "mpf_sqrt",
          "(",
          "f,",
          "f",
          ",",
          "f",
          "f",
          ")",
          ";",
          "mpf_clear(temp);",
          "mpf_clear(temp)",
          "mpf_clear",
          "(",
          "temp",
          "temp",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          1122,
          2
        ],
        "end_point": [
          1123,
          20
        ],
        "content": "static void eval(mpf_ptr f, unsigned long int l, mpf_srcptr g)\n  { eval(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1124,
          2
        ],
        "end_point": [
          1125,
          36
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, signed long int l)\n  { eval(f, g, __gmpxx_abs_ui(l)); }",
        "lines": 2,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1126,
          2
        ],
        "end_point": [
          1127,
          20
        ],
        "content": "static void eval(mpf_ptr f, signed long int l, mpf_srcptr g)\n  { eval(f, g, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1128,
          2
        ],
        "end_point": [
          1138,
          3
        ],
        "content": "static void eval(mpf_ptr f, mpf_srcptr g, double d)\n  {\n    mpf_t temp;\n    mpf_init2(temp, mpf_get_prec(f));\n    mpf_mul(temp, g, g);\n    mpf_set_d(f, d);\n    mpf_mul(f, f, f);\n    mpf_add(f, f, temp);\n    mpf_sqrt(f, f);\n    mpf_clear(temp);\n  }",
        "lines": 11,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1139,
          2
        ],
        "end_point": [
          1140,
          20
        ],
        "content": "static void eval(mpf_ptr f, double d, mpf_srcptr g)\n  { eval(f, g, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1143,
          0
        ],
        "end_point": [
          1146,
          54
        ],
        "content": "struct __gmp_sgn_function\n{\n  static int eval(mpz_srcptr z) { return mpz_sgn(z); }\n  static int eval(mpq_srcptr q) { return mpq_sgn(q); }",
        "lines": 4,
        "depth": 9,
        "decorators": [
          "struct __gmp_sgn_function\n{\n  static int eval(mpz_srcptr z) { return mpz_sgn(z); }",
          "struct",
          "__gmp_sgn_function",
          "{\n  static int eval(mpz_srcptr z) { return mpz_sgn(z); }",
          "{",
          "static int eval(mpz_srcptr z) { return mpz_sgn(z);",
          "static",
          "static",
          "int",
          "eval(mpz_srcptr z) { return",
          "eval",
          "(mpz_srcptr z)",
          "(",
          "mpz_srcptr z",
          "mpz_srcptr",
          "z",
          ")",
          "{",
          "return",
          "mpz_sgn",
          "(z)",
          "(",
          "z",
          "z",
          ")",
          ";",
          "}",
          "static",
          "static",
          "int",
          "int"
        ]
      },
      {
        "start_point": [
          1147,
          2
        ],
        "end_point": [
          1147,
          54
        ],
        "content": "static int eval(mpf_srcptr f) { return mpf_sgn(f); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          1150,
          0
        ],
        "end_point": [
          1155,
          26
        ],
        "content": "struct __gmp_gcd_function\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_gcd(z, w, v); }\n  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)\n  { mpz_gcd_ui(z, w, l); }",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "struct __gmp_gcd_function\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_gcd(z, w, v); }",
          "struct",
          "__gmp_gcd_function",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_gcd(z, w, v); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_gcd(z, w, v);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ",",
          "mpz_srcptr v",
          "mpz_srcptr",
          "v",
          ")",
          "{",
          "mpz_gcd",
          "(z, w, v)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ",",
          "v",
          "v",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          1156,
          2
        ],
        "end_point": [
          1157,
          20
        ],
        "content": "static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)\n  { eval(z, w, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1158,
          2
        ],
        "end_point": [
          1159,
          36
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)\n  { eval(z, w, __gmpxx_abs_ui(l)); }",
        "lines": 2,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1160,
          2
        ],
        "end_point": [
          1161,
          20
        ],
        "content": "static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)\n  { eval(z, w, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1162,
          2
        ],
        "end_point": [
          1163,
          47
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, double d)\n  {  __GMPXX_TMPZ_D;    mpz_gcd (z, w, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1164,
          2
        ],
        "end_point": [
          1165,
          20
        ],
        "content": "static void eval(mpz_ptr z, double d, mpz_srcptr w)\n  { eval(z, w, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1168,
          0
        ],
        "end_point": [
          1173,
          26
        ],
        "content": "struct __gmp_lcm_function\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_lcm(z, w, v); }\n  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)\n  { mpz_lcm_ui(z, w, l); }",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "struct __gmp_lcm_function\n{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_lcm(z, w, v); }",
          "struct",
          "__gmp_lcm_function",
          "{\n  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_lcm(z, w, v); }",
          "{",
          "static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  { mpz_lcm(z, w, v);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)\n  {",
          "eval",
          "(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "mpz_srcptr w",
          "mpz_srcptr",
          "w",
          ",",
          "mpz_srcptr v",
          "mpz_srcptr",
          "v",
          ")",
          "{",
          "mpz_lcm",
          "(z, w, v)",
          "(",
          "z",
          "z",
          ",",
          "w",
          "w",
          ",",
          "v",
          "v",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          1174,
          2
        ],
        "end_point": [
          1175,
          20
        ],
        "content": "static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)\n  { eval(z, w, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1176,
          2
        ],
        "end_point": [
          1177,
          36
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)\n  { eval(z, w, __gmpxx_abs_ui(l)); }",
        "lines": 2,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1178,
          2
        ],
        "end_point": [
          1179,
          20
        ],
        "content": "static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)\n  { eval(z, w, l); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1180,
          2
        ],
        "end_point": [
          1181,
          47
        ],
        "content": "static void eval(mpz_ptr z, mpz_srcptr w, double d)\n  {  __GMPXX_TMPZ_D;    mpz_lcm (z, w, temp); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1182,
          2
        ],
        "end_point": [
          1183,
          20
        ],
        "content": "static void eval(mpz_ptr z, double d, mpz_srcptr w)\n  { eval(z, w, d); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1186,
          0
        ],
        "end_point": [
          1191,
          28
        ],
        "content": "struct __gmp_rand_function\n{\n  static void eval(mpz_ptr z, gmp_randstate_t s, mp_bitcnt_t l)\n  { mpz_urandomb(z, s, l); }\n  static void eval(mpz_ptr z, gmp_randstate_t s, mpz_srcptr w)\n  { mpz_urandomm(z, s, w); }",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "struct __gmp_rand_function\n{\n  static void eval(mpz_ptr z, gmp_randstate_t s, mp_bitcnt_t l)\n  { mpz_urandomb(z, s, l); }",
          "struct",
          "__gmp_rand_function",
          "{\n  static void eval(mpz_ptr z, gmp_randstate_t s, mp_bitcnt_t l)\n  { mpz_urandomb(z, s, l); }",
          "{",
          "static void eval(mpz_ptr z, gmp_randstate_t s, mp_bitcnt_t l)\n  { mpz_urandomb(z, s, l);",
          "static",
          "static",
          "void",
          "eval(mpz_ptr z, gmp_randstate_t s, mp_bitcnt_t l)\n  {",
          "eval",
          "(mpz_ptr z, gmp_randstate_t s, mp_bitcnt_t l)",
          "(",
          "mpz_ptr z",
          "mpz_ptr",
          "z",
          ",",
          "gmp_randstate_t s",
          "gmp_randstate_t",
          "s",
          ",",
          "mp_bitcnt_t l",
          "mp_bitcnt_t",
          "l",
          ")",
          "{",
          "mpz_urandomb",
          "(z, s, l)",
          "(",
          "z",
          "z",
          ",",
          "s",
          "s",
          ",",
          "l",
          "l",
          ")",
          ";",
          "}",
          "static",
          "static",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          1192,
          2
        ],
        "end_point": [
          1193,
          31
        ],
        "content": "static void eval(mpf_ptr f, gmp_randstate_t s, mp_bitcnt_t prec)\n  { mpf_urandomb(f, s, prec); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          2354,
          2
        ],
        "end_point": [
          2366,
          3
        ],
        "content": "void eval(typename __gmp_resolve_expr<T>::ptr_type p) const\n  {\n    if(p != expr.val2.__get_mp())\n    {\n      __gmp_set_expr(p, expr.val1);\n      Op::eval(p, p, expr.val2.__get_mp());\n    }\n    else\n    {\n      __gmp_temp<T> temp(expr.val1, p);\n      Op::eval(p, temp.__get_mp(), expr.val2.__get_mp());\n    }\n  }",
        "lines": 13,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          2389,
          2
        ],
        "end_point": [
          2401,
          3
        ],
        "content": "void eval(typename __gmp_resolve_expr<T>::ptr_type p) const\n  {\n    if(p != expr.val1.__get_mp())\n    {\n      __gmp_set_expr(p, expr.val2);\n      Op::eval(p, expr.val1.__get_mp(), p);\n    }\n    else\n    {\n      __gmp_temp<T> temp(expr.val2, p);\n      Op::eval(p, expr.val1.__get_mp(), temp.__get_mp());\n    }\n  }",
        "lines": 13,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          2424,
          2
        ],
        "end_point": [
          2436,
          3
        ],
        "content": "void eval(typename __gmp_resolve_expr<T>::ptr_type p) const\n  {\n    if(p != expr.val2.__get_mp())\n    {\n      __gmp_set_expr(p, expr.val1);\n      Op::eval(p, p, expr.val2.__get_mp());\n    }\n    else\n    {\n      __gmp_temp<T> temp(expr.val1, p);\n      Op::eval(p, temp.__get_mp(), expr.val2.__get_mp());\n    }\n  }",
        "lines": 13,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          2461,
          2
        ],
        "end_point": [
          2465,
          3
        ],
        "content": "void eval(typename __gmp_resolve_expr<T>::ptr_type p) const\n  {\n    expr.val1.eval(p);\n    Op::eval(p, p, expr.val2);\n  }",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          2482,
          2
        ],
        "end_point": [
          2486,
          3
        ],
        "content": "void eval(typename __gmp_resolve_expr<T>::ptr_type p) const\n  {\n    expr.val2.eval(p);\n    Op::eval(p, expr.val1, p);\n  }",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          2507,
          2
        ],
        "end_point": [
          2512,
          3
        ],
        "content": "void eval(typename __gmp_resolve_expr<T>::ptr_type p) const\n  {\n    __gmp_temp<T> temp2(expr.val2, p);\n    expr.val1.eval(p);\n    Op::eval(p, p, temp2.__get_mp());\n  }",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          2535,
          2
        ],
        "end_point": [
          2540,
          3
        ],
        "content": "void eval(typename __gmp_resolve_expr<T>::ptr_type p) const\n  {\n    __gmp_temp<T> temp1(expr.val1, p);\n    expr.val2.eval(p);\n    Op::eval(p, temp1.__get_mp(), p);\n  }",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          2563,
          2
        ],
        "end_point": [
          2568,
          3
        ],
        "content": "void eval(typename __gmp_resolve_expr<T>::ptr_type p) const\n  {\n    __gmp_temp<T> temp2(expr.val2, p);\n    expr.val1.eval(p);\n    Op::eval(p, p, temp2.__get_mp());\n  }",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          3151,
          2
        ],
        "end_point": [
          3151,
          75
        ],
        "content": "void eval(mpz_ptr z) const { __gmp_rand_function::eval(z, state, bits); }",
        "lines": 1,
        "depth": 7,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          3163,
          2
        ],
        "end_point": [
          3164,
          61
        ],
        "content": "void eval(mpz_ptr z) const\n  { __gmp_rand_function::eval(z, state, range.get_mpz_t()); }",
        "lines": 2,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          3176,
          2
        ],
        "end_point": [
          3180,
          3
        ],
        "content": "void eval(mpf_ptr f) const\n  {\n    __gmp_rand_function::eval(f, state,\n\t(bits>0) ? bits : mpf_get_prec(f));\n  }",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "void"
        ]
      }
    ],
    "__gmp_alloc_cstring": {
      "start_point": [
        1206,
        0
      ],
      "end_point": [
        1215,
        3
      ],
      "content": "struct __gmp_alloc_cstring\n{\n  char *str;\n  __gmp_alloc_cstring(char *s) { str = s; }\n  ~__gmp_alloc_cstring()\n  {\n    __gmp_freefunc_t freefunc;\n    mp_get_memory_functions (NULL, NULL, &freefunc);\n    (*freefunc) (str, std::strlen(str)+1);\n  }",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "struct __gmp_alloc_cstring\n{\n  char *str;\n  __gmp_alloc_cstring(char *s) { str = s; }",
        "struct",
        "__gmp_alloc_cstring",
        "{\n  char *str;\n  __gmp_alloc_cstring(char *s) { str = s; }",
        "{",
        "char *str;",
        "char",
        "*str",
        "*",
        "str",
        ";",
        "__gmp_alloc_cstring(char *s) { str = s;",
        "__gmp_alloc_cstring(char *s)",
        "__gmp_alloc_cstring",
        "(",
        "char *",
        "char",
        "*",
        "*",
        "s",
        "s",
        ")",
        "{ str =",
        "{",
        "str",
        "=",
        "s",
        ";",
        "}",
        "~",
        "~"
      ]
    },
    "std": {
      "start_point": [
        1302,
        0
      ],
      "end_point": [
        1310,
        3
      ],
      "content": "namespace std {\n  template <class T, class U, class V, class W>\n  struct common_type <__gmp_expr<T, U>, __gmp_expr<V, W> >\n  {\n  private:\n    typedef typename __gmp_resolve_expr<T, V>::value_type X;\n  public:\n    typedef __gmp_expr<X, X> type;\n  }",
      "lines": 9,
      "depth": 12,
      "decorators": null
    },
    "val": {
      "start_point": [
        1351,
        2
      ],
      "end_point": [
        1351,
        43
      ],
      "content": "__gmp_unary_expr(const T &v) : val(v) { }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "__gmp_unary_expr(const T &v)",
        "__gmp_unary_expr",
        "(",
        "const T",
        "const",
        "const",
        "T",
        "&v",
        "&",
        "v",
        ")",
        ":",
        ":"
      ]
    },
    "assign_ui": {
      "start_point": [
        1435,
        2
      ],
      "end_point": [
        1441,
        3
      ],
      "content": "void assign_ui(unsigned long l)\n  {\n    if (__GMPXX_CONSTANT_TRUE(l == 0))\n      mp->_mp_size = 0;\n    else\n      mpz_set_ui(mp, l);\n  }",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "assign_si": {
      "start_point": [
        1442,
        2
      ],
      "end_point": [
        1453,
        3
      ],
      "content": "void assign_si(signed long l)\n  {\n    if (__GMPXX_CONSTANT_TRUE(l >= 0))\n      assign_ui(l);\n    else if (__GMPXX_CONSTANT_TRUE(l <= 0))\n      {\n\tassign_ui(-static_cast<unsigned long>(l));\n\tmpz_neg(mp, mp);\n      }\n    else\n      mpz_set_si(mp, l);\n  }",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "assign_d": {
      "start_point": [
        1454,
        2
      ],
      "end_point": [
        1457,
        3
      ],
      "content": "void assign_d (double d)\n  {\n    mpz_set_d (mp, d);\n  }",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "init_ui": {
      "start_point": [
        1459,
        2
      ],
      "end_point": [
        1465,
        3
      ],
      "content": "void init_ui(unsigned long l)\n  {\n    if (__GMPXX_CONSTANT_TRUE(l == 0))\n      mpz_init(mp);\n    else\n      mpz_init_set_ui(mp, l);\n  }",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "init_si": {
      "start_point": [
        1466,
        2
      ],
      "end_point": [
        1477,
        3
      ],
      "content": "void init_si(signed long l)\n  {\n    if (__GMPXX_CONSTANT_TRUE(l >= 0))\n      init_ui(l);\n    else if (__GMPXX_CONSTANT_TRUE(l <= 0))\n      {\n\tinit_ui(-static_cast<unsigned long>(l));\n\tmpz_neg(mp, mp);\n      }\n    else\n      mpz_init_set_si(mp, l);\n  }",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "init_d": {
      "start_point": [
        1478,
        2
      ],
      "end_point": [
        1481,
        3
      ],
      "content": "void init_d (double d)\n  {\n    mpz_init_set_d (mp, d);\n  }",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "__gmp_expr": {
      "start_point": [
        1520,
        2
      ],
      "end_point": [
        1520,
        60
      ],
      "content": "explicit __gmp_expr(mpz_srcptr z) { mpz_init_set(mp, z); }",
      "lines": 1,
      "depth": 6,
      "decorators": [
        "explicit"
      ]
    },
    "swap": [
      {
        "start_point": [
          1524,
          2
        ],
        "end_point": [
          1524,
          70
        ],
        "content": "void swap(__gmp_expr& z) __GMPXX_NOEXCEPT { std::swap(*mp, *z.mp); }",
        "lines": 1,
        "depth": 9,
        "decorators": [
          "void",
          "swap(__gmp_expr& z)"
        ]
      },
      {
        "start_point": [
          1701,
          2
        ],
        "end_point": [
          1701,
          70
        ],
        "content": "void swap(__gmp_expr& q) __GMPXX_NOEXCEPT { std::swap(*mp, *q.mp); }",
        "lines": 1,
        "depth": 9,
        "decorators": [
          "void",
          "swap(__gmp_expr& q)"
        ]
      }
    ],
    "set_str": [
      {
        "start_point": [
          1553,
          2
        ],
        "end_point": [
          1554,
          38
        ],
        "content": "int set_str(const char *s, int base)\n  { return mpz_set_str(mp, s, base); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          1555,
          2
        ],
        "end_point": [
          1556,
          46
        ],
        "content": "int set_str(const std::string &s, int base)\n  { return mpz_set_str(mp, s.c_str(), base); }",
        "lines": 2,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          1732,
          2
        ],
        "end_point": [
          1733,
          38
        ],
        "content": "int set_str(const char *s, int base)\n  { return mpq_set_str(mp, s, base); }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          1734,
          2
        ],
        "end_point": [
          1735,
          46
        ],
        "content": "int set_str(const std::string &s, int base)\n  { return mpq_set_str(mp, s.c_str(), base); }",
        "lines": 2,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "__get_mp": [
      {
        "start_point": [
          1564,
          2
        ],
        "end_point": [
          1564,
          44
        ],
        "content": "mpz_srcptr __get_mp() const { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpz_srcptr"
        ]
      },
      {
        "start_point": [
          1565,
          2
        ],
        "end_point": [
          1565,
          35
        ],
        "content": "mpz_ptr __get_mp() { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpz_ptr"
        ]
      },
      {
        "start_point": [
          1756,
          2
        ],
        "end_point": [
          1756,
          44
        ],
        "content": "mpq_srcptr __get_mp() const { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpq_srcptr"
        ]
      },
      {
        "start_point": [
          1757,
          2
        ],
        "end_point": [
          1757,
          35
        ],
        "content": "mpq_ptr __get_mp() { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpq_ptr"
        ]
      },
      {
        "start_point": [
          1960,
          2
        ],
        "end_point": [
          1960,
          44
        ],
        "content": "mpf_srcptr __get_mp() const { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpf_srcptr"
        ]
      },
      {
        "start_point": [
          1961,
          2
        ],
        "end_point": [
          1961,
          35
        ],
        "content": "mpf_ptr __get_mp() { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpf_ptr"
        ]
      }
    ],
    "get_mpz_t": [
      {
        "start_point": [
          1566,
          2
        ],
        "end_point": [
          1566,
          45
        ],
        "content": "mpz_srcptr get_mpz_t() const { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpz_srcptr"
        ]
      },
      {
        "start_point": [
          1567,
          2
        ],
        "end_point": [
          1567,
          36
        ],
        "content": "mpz_ptr get_mpz_t() { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpz_ptr"
        ]
      }
    ],
    "get_si": [
      {
        "start_point": [
          1569,
          2
        ],
        "end_point": [
          1569,
          59
        ],
        "content": "signed long int get_si() const { return mpz_get_si(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "signed long int",
          "signed",
          "long",
          "int"
        ]
      },
      {
        "start_point": [
          1965,
          2
        ],
        "end_point": [
          1965,
          59
        ],
        "content": "signed long int get_si() const { return mpf_get_si(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "signed long int",
          "signed",
          "long",
          "int"
        ]
      }
    ],
    "get_ui": [
      {
        "start_point": [
          1570,
          2
        ],
        "end_point": [
          1570,
          61
        ],
        "content": "unsigned long int get_ui() const { return mpz_get_ui(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "unsigned long int",
          "unsigned",
          "long",
          "int"
        ]
      },
      {
        "start_point": [
          1966,
          2
        ],
        "end_point": [
          1966,
          61
        ],
        "content": "unsigned long int get_ui() const { return mpf_get_ui(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "unsigned long int",
          "unsigned",
          "long",
          "int"
        ]
      }
    ],
    "get_d": [
      {
        "start_point": [
          1571,
          2
        ],
        "end_point": [
          1571,
          48
        ],
        "content": "double get_d() const { return mpz_get_d(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "double"
        ]
      },
      {
        "start_point": [
          1766,
          2
        ],
        "end_point": [
          1766,
          48
        ],
        "content": "double get_d() const { return mpq_get_d(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "double"
        ]
      },
      {
        "start_point": [
          1967,
          2
        ],
        "end_point": [
          1967,
          48
        ],
        "content": "double get_d() const { return mpf_get_d(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "double"
        ]
      }
    ],
    "fits_sint_p": [
      {
        "start_point": [
          1575,
          2
        ],
        "end_point": [
          1575,
          58
        ],
        "content": "bool fits_sint_p() const { return mpz_fits_sint_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          1971,
          2
        ],
        "end_point": [
          1971,
          58
        ],
        "content": "bool fits_sint_p() const { return mpf_fits_sint_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ],
    "fits_uint_p": [
      {
        "start_point": [
          1576,
          2
        ],
        "end_point": [
          1576,
          58
        ],
        "content": "bool fits_uint_p() const { return mpz_fits_uint_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          1972,
          2
        ],
        "end_point": [
          1972,
          58
        ],
        "content": "bool fits_uint_p() const { return mpf_fits_uint_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ],
    "fits_sshort_p": [
      {
        "start_point": [
          1577,
          2
        ],
        "end_point": [
          1577,
          62
        ],
        "content": "bool fits_sshort_p() const { return mpz_fits_sshort_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          1973,
          2
        ],
        "end_point": [
          1973,
          62
        ],
        "content": "bool fits_sshort_p() const { return mpf_fits_sshort_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ],
    "fits_ushort_p": [
      {
        "start_point": [
          1578,
          2
        ],
        "end_point": [
          1578,
          62
        ],
        "content": "bool fits_ushort_p() const { return mpz_fits_ushort_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          1974,
          2
        ],
        "end_point": [
          1974,
          62
        ],
        "content": "bool fits_ushort_p() const { return mpf_fits_ushort_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ],
    "fits_slong_p": [
      {
        "start_point": [
          1579,
          2
        ],
        "end_point": [
          1579,
          60
        ],
        "content": "bool fits_slong_p() const { return mpz_fits_slong_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          1975,
          2
        ],
        "end_point": [
          1975,
          60
        ],
        "content": "bool fits_slong_p() const { return mpf_fits_slong_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ],
    "fits_ulong_p": [
      {
        "start_point": [
          1580,
          2
        ],
        "end_point": [
          1580,
          60
        ],
        "content": "bool fits_ulong_p() const { return mpz_fits_ulong_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          1976,
          2
        ],
        "end_point": [
          1976,
          60
        ],
        "content": "bool fits_ulong_p() const { return mpf_fits_ulong_p(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ],
    "get_num": {
      "start_point": [
        1747,
        2
      ],
      "end_point": [
        1748,
        66
      ],
      "content": "const mpz_class & get_num() const\n  { return reinterpret_cast<const mpz_class &>(*mpq_numref(mp)); }",
      "lines": 2,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "mpz_class",
        "&",
        "&"
      ]
    },
    "get_den": {
      "start_point": [
        1751,
        2
      ],
      "end_point": [
        1752,
        66
      ],
      "content": "const mpz_class & get_den() const\n  { return reinterpret_cast<const mpz_class &>(*mpq_denref(mp)); }",
      "lines": 2,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "mpz_class",
        "&",
        "&"
      ]
    },
    "get_mpq_t": [
      {
        "start_point": [
          1758,
          2
        ],
        "end_point": [
          1758,
          45
        ],
        "content": "mpq_srcptr get_mpq_t() const { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpq_srcptr"
        ]
      },
      {
        "start_point": [
          1759,
          2
        ],
        "end_point": [
          1759,
          36
        ],
        "content": "mpq_ptr get_mpq_t() { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpq_ptr"
        ]
      }
    ],
    "get_num_mpz_t": [
      {
        "start_point": [
          1761,
          2
        ],
        "end_point": [
          1761,
          61
        ],
        "content": "mpz_srcptr get_num_mpz_t() const { return mpq_numref(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "mpz_srcptr"
        ]
      },
      {
        "start_point": [
          1762,
          2
        ],
        "end_point": [
          1762,
          52
        ],
        "content": "mpz_ptr get_num_mpz_t() { return mpq_numref(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "mpz_ptr"
        ]
      }
    ],
    "get_den_mpz_t": [
      {
        "start_point": [
          1763,
          2
        ],
        "end_point": [
          1763,
          61
        ],
        "content": "mpz_srcptr get_den_mpz_t() const { return mpq_denref(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "mpz_srcptr"
        ]
      },
      {
        "start_point": [
          1764,
          2
        ],
        "end_point": [
          1764,
          52
        ],
        "content": "mpz_ptr get_den_mpz_t() { return mpq_denref(mp); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "mpz_ptr"
        ]
      }
    ],
    "get_mpf_t": [
      {
        "start_point": [
          1962,
          2
        ],
        "end_point": [
          1962,
          45
        ],
        "content": "mpf_srcptr get_mpf_t() const { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpf_srcptr"
        ]
      },
      {
        "start_point": [
          1963,
          2
        ],
        "end_point": [
          1963,
          36
        ],
        "content": "mpf_ptr get_mpf_t() { return mp; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "mpf_ptr"
        ]
      }
    ],
    "get_val1": [
      {
        "start_point": [
          2367,
          2
        ],
        "end_point": [
          2367,
          58
        ],
        "content": "const val1_type & get_val1() const { return expr.val1; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val1_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2402,
          2
        ],
        "end_point": [
          2402,
          58
        ],
        "content": "const val1_type & get_val1() const { return expr.val1; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val1_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2437,
          2
        ],
        "end_point": [
          2437,
          58
        ],
        "content": "const val1_type & get_val1() const { return expr.val1; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val1_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2466,
          2
        ],
        "end_point": [
          2466,
          58
        ],
        "content": "const val1_type & get_val1() const { return expr.val1; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val1_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2487,
          2
        ],
        "end_point": [
          2487,
          58
        ],
        "content": "const val1_type & get_val1() const { return expr.val1; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val1_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2513,
          2
        ],
        "end_point": [
          2513,
          58
        ],
        "content": "const val1_type & get_val1() const { return expr.val1; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val1_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2541,
          2
        ],
        "end_point": [
          2541,
          58
        ],
        "content": "const val1_type & get_val1() const { return expr.val1; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val1_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2569,
          2
        ],
        "end_point": [
          2569,
          58
        ],
        "content": "const val1_type & get_val1() const { return expr.val1; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val1_type",
          "&",
          "&"
        ]
      }
    ],
    "get_val2": [
      {
        "start_point": [
          2368,
          2
        ],
        "end_point": [
          2368,
          58
        ],
        "content": "const val2_type & get_val2() const { return expr.val2; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val2_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2403,
          2
        ],
        "end_point": [
          2403,
          58
        ],
        "content": "const val2_type & get_val2() const { return expr.val2; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val2_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2438,
          2
        ],
        "end_point": [
          2438,
          58
        ],
        "content": "const val2_type & get_val2() const { return expr.val2; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val2_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2467,
          2
        ],
        "end_point": [
          2467,
          58
        ],
        "content": "const val2_type & get_val2() const { return expr.val2; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val2_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2488,
          2
        ],
        "end_point": [
          2488,
          58
        ],
        "content": "const val2_type & get_val2() const { return expr.val2; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val2_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2514,
          2
        ],
        "end_point": [
          2514,
          58
        ],
        "content": "const val2_type & get_val2() const { return expr.val2; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val2_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2542,
          2
        ],
        "end_point": [
          2542,
          58
        ],
        "content": "const val2_type & get_val2() const { return expr.val2; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val2_type",
          "&",
          "&"
        ]
      },
      {
        "start_point": [
          2570,
          2
        ],
        "end_point": [
          2570,
          58
        ],
        "content": "const val2_type & get_val2() const { return expr.val2; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "const",
          "const",
          "val2_type",
          "&",
          "&"
        ]
      }
    ],
    "get_prec": [
      {
        "start_point": [
          2369,
          2
        ],
        "end_point": [
          2374,
          3
        ],
        "content": "mp_bitcnt_t get_prec() const\n  {\n    mp_bitcnt_t prec1 = expr.val1.get_prec(),\n      prec2 = expr.val2.get_prec();\n    return (prec1 > prec2) ? prec1 : prec2;\n  }",
        "lines": 6,
        "depth": 8,
        "decorators": [
          "mp_bitcnt_t"
        ]
      },
      {
        "start_point": [
          2404,
          2
        ],
        "end_point": [
          2409,
          3
        ],
        "content": "mp_bitcnt_t get_prec() const\n  {\n    mp_bitcnt_t prec1 = expr.val1.get_prec(),\n      prec2 = expr.val2.get_prec();\n    return (prec1 > prec2) ? prec1 : prec2;\n  }",
        "lines": 6,
        "depth": 8,
        "decorators": [
          "mp_bitcnt_t"
        ]
      },
      {
        "start_point": [
          2439,
          2
        ],
        "end_point": [
          2444,
          3
        ],
        "content": "mp_bitcnt_t get_prec() const\n  {\n    mp_bitcnt_t prec1 = expr.val1.get_prec(),\n      prec2 = expr.val2.get_prec();\n    return (prec1 > prec2) ? prec1 : prec2;\n  }",
        "lines": 6,
        "depth": 8,
        "decorators": [
          "mp_bitcnt_t"
        ]
      },
      {
        "start_point": [
          2468,
          2
        ],
        "end_point": [
          2468,
          63
        ],
        "content": "mp_bitcnt_t get_prec() const { return expr.val1.get_prec(); }",
        "lines": 1,
        "depth": 7,
        "decorators": [
          "mp_bitcnt_t"
        ]
      },
      {
        "start_point": [
          2489,
          2
        ],
        "end_point": [
          2489,
          63
        ],
        "content": "mp_bitcnt_t get_prec() const { return expr.val2.get_prec(); }",
        "lines": 1,
        "depth": 7,
        "decorators": [
          "mp_bitcnt_t"
        ]
      },
      {
        "start_point": [
          2515,
          2
        ],
        "end_point": [
          2520,
          3
        ],
        "content": "mp_bitcnt_t get_prec() const\n  {\n    mp_bitcnt_t prec1 = expr.val1.get_prec(),\n      prec2 = expr.val2.get_prec();\n    return (prec1 > prec2) ? prec1 : prec2;\n  }",
        "lines": 6,
        "depth": 8,
        "decorators": [
          "mp_bitcnt_t"
        ]
      },
      {
        "start_point": [
          2543,
          2
        ],
        "end_point": [
          2548,
          3
        ],
        "content": "mp_bitcnt_t get_prec() const\n  {\n    mp_bitcnt_t prec1 = expr.val1.get_prec(),\n      prec2 = expr.val2.get_prec();\n    return (prec1 > prec2) ? prec1 : prec2;\n  }",
        "lines": 6,
        "depth": 8,
        "decorators": [
          "mp_bitcnt_t"
        ]
      },
      {
        "start_point": [
          2571,
          2
        ],
        "end_point": [
          2576,
          3
        ],
        "content": "mp_bitcnt_t get_prec() const\n  {\n    mp_bitcnt_t prec1 = expr.val1.get_prec(),\n      prec2 = expr.val2.get_prec();\n    return (prec1 > prec2) ? prec1 : prec2;\n  }",
        "lines": 6,
        "depth": 8,
        "decorators": [
          "mp_bitcnt_t"
        ]
      },
      {
        "start_point": [
          3152,
          2
        ],
        "end_point": [
          3152,
          65
        ],
        "content": "mp_bitcnt_t get_prec() const { return mpf_get_default_prec(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "mp_bitcnt_t"
        ]
      },
      {
        "start_point": [
          3165,
          2
        ],
        "end_point": [
          3165,
          65
        ],
        "content": "mp_bitcnt_t get_prec() const { return mpf_get_default_prec(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "mp_bitcnt_t"
        ]
      },
      {
        "start_point": [
          3181,
          2
        ],
        "end_point": [
          3187,
          3
        ],
        "content": "mp_bitcnt_t get_prec() const\n  {\n    if (bits == 0)\n      return mpf_get_default_prec();\n    else\n      return bits;\n  }",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "mp_bitcnt_t"
        ]
      }
    ],
    "__GMPF_DEFINE_COMPOUND_OPERATOR": [
      {
        "start_point": [
          3140,
          0
        ],
        "end_point": [
          3140,
          30
        ],
        "content": "class __gmp_urandomb_value { }",
        "lines": 1,
        "depth": 3,
        "decorators": null
      },
      {
        "start_point": [
          3141,
          0
        ],
        "end_point": [
          3141,
          30
        ],
        "content": "class __gmp_urandomm_value { }",
        "lines": 1,
        "depth": 3,
        "decorators": null
      }
    ],
    "seed": [
      {
        "start_point": [
          3196,
          0
        ],
        "end_point": [
          3252,
          1
        ],
        "content": "class gmp_randclass\n{\nprivate:\n  gmp_randstate_t state;\n\n  // copy construction and assignment not allowed\n  gmp_randclass(const gmp_randclass &);\n  void operator=(const gmp_randclass &);\npublic:\n  // constructors and destructor\n  gmp_randclass(gmp_randalg_t alg, unsigned long int size)\n  {\n    switch (alg)\n      {\n      case GMP_RAND_ALG_LC: // no other cases for now\n      default:\n\tgmp_randinit(state, alg, size);\n\tbreak;\n      }\n  }\n\n  // gmp_randinit_default\n  gmp_randclass(__gmp_randinit_default_t* f) { f(state); }\n\n  // gmp_randinit_lc_2exp\n  gmp_randclass(__gmp_randinit_lc_2exp_t* f,\n\t\tmpz_class z, unsigned long int l1, mp_bitcnt_t l2)\n  { f(state, z.get_mpz_t(), l1, l2); }\n\n  // gmp_randinit_lc_2exp_size\n  gmp_randclass(__gmp_randinit_lc_2exp_size_t* f,\n\t\tmp_bitcnt_t size)\n  {\n    if (f (state, size) == 0)\n      throw std::length_error (\"gmp_randinit_lc_2exp_size\");\n  }\n\n  ~gmp_randclass() { gmp_randclear(state); }\n\n  // initialize\n  void seed(); // choose a random seed some way (?)\n  void seed(unsigned long int s) { gmp_randseed_ui(state, s); }\n  void seed(const mpz_class &z) { gmp_randseed(state, z.get_mpz_t()); }\n\n  // get random number\n  __gmp_expr<mpz_t, __gmp_urandomb_value> get_z_bits(mp_bitcnt_t l)\n  { return __gmp_expr<mpz_t, __gmp_urandomb_value>(state, l); }\n  __gmp_expr<mpz_t, __gmp_urandomb_value> get_z_bits(const mpz_class &z)\n  { return get_z_bits(z.get_ui()); }\n  // FIXME: z.get_bitcnt_t() ?\n\n  __gmp_expr<mpz_t, __gmp_urandomm_value> get_z_range(const mpz_class &z)\n  { return __gmp_expr<mpz_t, __gmp_urandomm_value>(state, z); }\n\n  __gmp_expr<mpf_t, __gmp_urandomb_value> get_f(mp_bitcnt_t prec = 0)\n  { return __gmp_expr<mpf_t, __gmp_urandomb_value>(state, prec); }\n}",
        "lines": 57,
        "depth": 10,
        "decorators": [
          "class",
          "gmp_randclass",
          "{\nprivate:\n  gmp_randstate_t state;\n\n  // copy construction and assignment not allowed\n  gmp_randclass(const gmp_randclass &);\n  void operator=(const gmp_randclass &);\npublic:\n  // constructors and destructor\n  gmp_randclass(gmp_randalg_t alg, unsigned long int size)\n  {\n    switch (alg)\n      {\n      case GMP_RAND_ALG_LC: // no other cases for now\n      default:\n\tgmp_randinit(state, alg, size);\n\tbreak;\n      }\n  }\n\n  // gmp_randinit_default\n  gmp_randclass(__gmp_randinit_default_t* f) { f(state); }\n\n  // gmp_randinit_lc_2exp\n  gmp_randclass(__gmp_randinit_lc_2exp_t* f,\n\t\tmpz_class z, unsigned long int l1, mp_bitcnt_t l2)\n  { f(state, z.get_mpz_t(), l1, l2); }\n\n  // gmp_randinit_lc_2exp_size\n  gmp_randclass(__gmp_randinit_lc_2exp_size_t* f,\n\t\tmp_bitcnt_t size)\n  {\n    if (f (state, size) == 0)\n      throw std::length_error (\"gmp_randinit_lc_2exp_size\");\n  }\n\n  ~gmp_randclass() { gmp_randclear(state); }\n\n  // initialize\n  void seed(); // choose a random seed some way (?)\n  void seed(unsigned long int s) { gmp_randseed_ui(state, s); }\n  void seed(const mpz_class &z) { gmp_randseed(state, z.get_mpz_t()); }\n\n  // get random number\n  __gmp_expr<mpz_t, __gmp_urandomb_value> get_z_bits(mp_bitcnt_t l)\n  { return __gmp_expr<mpz_t, __gmp_urandomb_value>(state, l); }\n  __gmp_expr<mpz_t, __gmp_urandomb_value> get_z_bits(const mpz_class &z)\n  { return get_z_bits(z.get_ui()); }\n  // FIXME: z.get_bitcnt_t() ?\n\n  __gmp_expr<mpz_t, __gmp_urandomm_value> get_z_range(const mpz_class &z)\n  { return __gmp_expr<mpz_t, __gmp_urandomm_value>(state, z); }\n\n  __gmp_expr<mpf_t, __gmp_urandomb_value> get_f(mp_bitcnt_t prec = 0)\n  { return __gmp_expr<mpf_t, __gmp_urandomb_value>(state, prec); }\n}",
          "{",
          "private:\n  gmp_randstate_t state;",
          "private",
          ":",
          "gmp_randstate_t state;",
          "gmp_randstate_t",
          "state",
          "state",
          ";",
          "// copy construction and assignment not allowed",
          "gmp_randclass(const gmp_randclass &)",
          "gmp_randclass",
          "(",
          "const gmp_randclass",
          "const",
          "const",
          "gmp_randclass",
          "&",
          "&",
          ")",
          ";",
          "void operator=(const gmp_randclass &);",
          "void",
          "operator=(const gmp_randclass &)",
          "operator",
          "=",
          "(const gmp_randclass &)",
          "(",
          "const gmp_randclass",
          "const",
          "const",
          "gmp_randclass",
          "&",
          "&",
          ")",
          "",
          ";",
          "public:\n  // constructors and destructor\n  gmp_randclass(gmp_randalg_t alg, unsigned long int size)",
          "public",
          ":",
          "// constructors and destructor",
          "gmp_randclass(gmp_randalg_t alg, unsigned long int size)",
          "gmp_randclass(gmp_randalg_t alg, unsigned long int size)",
          "gmp_randclass",
          "(gmp_randalg_t alg, unsigned long int size)",
          "(",
          "gmp_randalg_t",
          "alg",
          "alg",
          ",",
          "unsigned",
          "long int size",
          "long",
          "int",
          "size",
          ")",
          "",
          "{\n    switch (alg)\n      {\n      case GMP_RAND_ALG_LC: // no other cases for now\n      default:\n\tgmp_randinit(state, alg, size);\n\tbreak;\n      }\n  }",
          "{",
          "switch (alg)\n      {\n      case GMP_RAND_ALG_LC: // no other cases for now\n      default:\n\tgmp_randinit(state, alg, size);\n\tbreak;\n      }",
          "switch",
          "(alg)",
          "(",
          "alg",
          ")",
          "{\n      case GMP_RAND_ALG_LC: // no other cases for now\n      default:\n\tgmp_randinit(state, alg, size);\n\tbreak;\n      }",
          "{",
          "case GMP_RAND_ALG_LC:",
          "case",
          "GMP_RAND_ALG_LC",
          ":",
          "// no other cases for now",
          "default:\n\tgmp_randinit(state, alg, size);\n\tbreak;",
          "default",
          ":",
          "gmp_randinit(state, alg, size);",
          "gmp_randinit(state, alg, size)",
          "gmp_randinit",
          "(state, alg, size)",
          "(",
          "state",
          ",",
          "alg",
          ",",
          "size",
          ")",
          ";",
          "break;",
          "break",
          ";",
          "}",
          "}",
          "// gmp_randinit_default",
          "gmp_randclass(__gmp_randinit_default_t* f)",
          "gmp_randclass(__gmp_randinit_default_t* f)",
          "gmp_randclass",
          "(__gmp_randinit_default_t* f)",
          "(",
          "__gmp_randinit_default_t* f",
          "__gmp_randinit_default_t",
          "*",
          "f",
          ")",
          "",
          "{ f(state); }",
          "{",
          "f(state);",
          "f(state)",
          "f",
          "(state)",
          "(",
          "state",
          ")",
          ";",
          "}",
          "// gmp_randinit_lc_2exp",
          "gmp_randclass(__gmp_randinit_lc_2exp_t* f,\n\t\tmpz_class z, unsigned long int l1, mp_bitcnt_t l2)",
          "gmp_randclass(__gmp_randinit_lc_2exp_t* f,\n\t\tmpz_class z, unsigned long int l1, mp_bitcnt_t l2)",
          "gmp_randclass",
          "(__gmp_randinit_lc_2exp_t* f,\n\t\tmpz_class z, unsigned long int l1, mp_bitcnt_t l2)",
          "(",
          "__gmp_randinit_lc_2exp_t* f",
          "__gmp_randinit_lc_2exp_t",
          "*",
          "f",
          ",",
          "mpz_class",
          "z",
          "z",
          ",",
          "unsigned",
          "long int l1",
          "long",
          "int",
          "l1",
          ",",
          "mp_bitcnt_t",
          "l2",
          "l2",
          ")",
          "",
          "{ f(state, z.get_mpz_t(), l1, l2); }",
          "{",
          "f(state, z.get_mpz_t(), l1, l2);",
          "f(state, z.get_mpz_t(), l1, l2)",
          "f",
          "(state, z.get_mpz_t(), l1, l2)",
          "(",
          "state",
          ",",
          "z.get_mpz_t()",
          "z.get_mpz_t",
          "z",
          ".",
          "get_mpz_t",
          "()",
          "(",
          ")",
          ",",
          "l1",
          ",",
          "l2",
          ")",
          ";",
          "}",
          "// gmp_randinit_lc_2exp_size",
          "gmp_randclass(__gmp_randinit_lc_2exp_size_t* f,\n\t\tmp_bitcnt_t size)",
          "gmp_randclass(__gmp_randinit_lc_2exp_size_t* f,\n\t\tmp_bitcnt_t size)",
          "gmp_randclass",
          "(__gmp_randinit_lc_2exp_size_t* f,\n\t\tmp_bitcnt_t size)",
          "(",
          "__gmp_randinit_lc_2exp_size_t* f",
          "__gmp_randinit_lc_2exp_size_t",
          "*",
          "f",
          ",",
          "mp_bitcnt_t",
          "size",
          "size",
          ")",
          "",
          "{\n    if (f (state, size) == 0)\n      throw std::length_error (\"gmp_randinit_lc_2exp_size\");\n  }",
          "{",
          "if (f (state, size) == 0)\n      throw std::length_error (\"gmp_randinit_lc_2exp_size\");",
          "if",
          "(f (state, size) == 0)",
          "(",
          "f (state, size) == 0",
          "f (state, size)",
          "f",
          "(state, size)",
          "(",
          "state",
          ",",
          "size",
          ")",
          "==",
          "0",
          ")",
          "throw",
          "throw",
          "std::length_error (\"gmp_randinit_lc_2exp_size\");",
          "std",
          ":",
          ":",
          ":",
          "length_error (\"gmp_randinit_lc_2exp_size\");",
          "length_error (\"gmp_randinit_lc_2exp_size\")",
          "length_error",
          "(\"gmp_randinit_lc_2exp_size\")",
          "(",
          "\"gmp_randinit_lc_2exp_size\"",
          "\"",
          "\"",
          ")",
          ";",
          "}",
          "~gmp_randclass()",
          "~gmp_randclass()",
          "~",
          "gmp_randclass()",
          "gmp_randclass",
          "()",
          "(",
          ")",
          "",
          "{ gmp_randclear(state); }",
          "{",
          "gmp_randclear(state);",
          "gmp_randclear(state)",
          "gmp_randclear",
          "(state)",
          "(",
          "state",
          ")",
          ";",
          "}",
          "// initialize",
          "void seed();",
          "void"
        ]
      },
      {
        "start_point": [
          3237,
          2
        ],
        "end_point": [
          3237,
          63
        ],
        "content": "void seed(unsigned long int s) { gmp_randseed_ui(state, s); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          3238,
          2
        ],
        "end_point": [
          3238,
          71
        ],
        "content": "void seed(const mpz_class &z) { gmp_randseed(state, z.get_mpz_t()); }",
        "lines": 1,
        "depth": 8,
        "decorators": [
          "void"
        ]
      }
    ],
    "min": [
      {
        "start_point": [
          3257,
          0
        ],
        "end_point": [
          3368,
          1
        ],
        "content": "namespace std {\n  template <> class numeric_limits<mpz_class>\n  {\n  public:\n    static const bool is_specialized = true;\n    static mpz_class min() { return mpz_class(); }\n    static mpz_class max() { return mpz_class(); }\n    static mpz_class lowest() { return mpz_class(); }\n    static const int digits = 0;\n    static const int digits10 = 0;\n    static const int max_digits10 = 0;\n    static const bool is_signed = true;\n    static const bool is_integer = true;\n    static const bool is_exact = true;\n    static const int radix = 2;\n    static mpz_class epsilon() { return mpz_class(); }\n    static mpz_class round_error() { return mpz_class(); }\n    static const int min_exponent = 0;\n    static const int min_exponent10 = 0;\n    static const int max_exponent = 0;\n    static const int max_exponent10 = 0;\n    static const bool has_infinity = false;\n    static const bool has_quiet_NaN = false;\n    static const bool has_signaling_NaN = false;\n    static const float_denorm_style has_denorm = denorm_absent;\n    static const bool has_denorm_loss = false;\n    static mpz_class infinity() { return mpz_class(); }\n    static mpz_class quiet_NaN() { return mpz_class(); }\n    static mpz_class signaling_NaN() { return mpz_class(); }\n    static mpz_class denorm_min() { return mpz_class(); }\n    static const bool is_iec559 = false;\n    static const bool is_bounded = false;\n    static const bool is_modulo = false;\n    static const bool traps = false;\n    static const bool tinyness_before = false;\n    static const float_round_style round_style = round_toward_zero;\n  };\n\n  template <> class numeric_limits<mpq_class>\n  {\n  public:\n    static const bool is_specialized = true;\n    static mpq_class min() { return mpq_class(); }\n    static mpq_class max() { return mpq_class(); }\n    static mpq_class lowest() { return mpq_class(); }\n    static const int digits = 0;\n    static const int digits10 = 0;\n    static const int max_digits10 = 0;\n    static const bool is_signed = true;\n    static const bool is_integer = false;\n    static const bool is_exact = true;\n    static const int radix = 2;\n    static mpq_class epsilon() { return mpq_class(); }\n    static mpq_class round_error() { return mpq_class(); }\n    static const int min_exponent = 0;\n    static const int min_exponent10 = 0;\n    static const int max_exponent = 0;\n    static const int max_exponent10 = 0;\n    static const bool has_infinity = false;\n    static const bool has_quiet_NaN = false;\n    static const bool has_signaling_NaN = false;\n    static const float_denorm_style has_denorm = denorm_absent;\n    static const bool has_denorm_loss = false;\n    static mpq_class infinity() { return mpq_class(); }\n    static mpq_class quiet_NaN() { return mpq_class(); }\n    static mpq_class signaling_NaN() { return mpq_class(); }\n    static mpq_class denorm_min() { return mpq_class(); }\n    static const bool is_iec559 = false;\n    static const bool is_bounded = false;\n    static const bool is_modulo = false;\n    static const bool traps = false;\n    static const bool tinyness_before = false;\n    static const float_round_style round_style = round_toward_zero;\n  };\n\n  template <> class numeric_limits<mpf_class>\n  {\n  public:\n    static const bool is_specialized = true;\n    static mpf_class min() { return mpf_class(); }\n    static mpf_class max() { return mpf_class(); }\n    static mpf_class lowest() { return mpf_class(); }\n    static const int digits = 0;\n    static const int digits10 = 0;\n    static const int max_digits10 = 0;\n    static const bool is_signed = true;\n    static const bool is_integer = false;\n    static const bool is_exact = false;\n    static const int radix = 2;\n    static mpf_class epsilon() { return mpf_class(); }\n    static mpf_class round_error() { return mpf_class(); }\n    static const int min_exponent = 0;\n    static const int min_exponent10 = 0;\n    static const int max_exponent = 0;\n    static const int max_exponent10 = 0;\n    static const bool has_infinity = false;\n    static const bool has_quiet_NaN = false;\n    static const bool has_signaling_NaN = false;\n    static const float_denorm_style has_denorm = denorm_absent;\n    static const bool has_denorm_loss = false;\n    static mpf_class infinity() { return mpf_class(); }\n    static mpf_class quiet_NaN() { return mpf_class(); }\n    static mpf_class signaling_NaN() { return mpf_class(); }\n    static mpf_class denorm_min() { return mpf_class(); }\n    static const bool is_iec559 = false;\n    static const bool is_bounded = false;\n    static const bool is_modulo = false;\n    static const bool traps = false;\n    static const bool tinyness_before = false;\n    static const float_round_style round_style = round_indeterminate;\n  };\n}",
        "lines": 112,
        "depth": 9,
        "decorators": [
          "namespace",
          "std",
          "{\n  template <> class numeric_limits<mpz_class>\n  {\n  public:\n    static const bool is_specialized = true;\n    static mpz_class min() { return mpz_class(); }\n    static mpz_class max() { return mpz_class(); }\n    static mpz_class lowest() { return mpz_class(); }\n    static const int digits = 0;\n    static const int digits10 = 0;\n    static const int max_digits10 = 0;\n    static const bool is_signed = true;\n    static const bool is_integer = true;\n    static const bool is_exact = true;\n    static const int radix = 2;\n    static mpz_class epsilon() { return mpz_class(); }\n    static mpz_class round_error() { return mpz_class(); }\n    static const int min_exponent = 0;\n    static const int min_exponent10 = 0;\n    static const int max_exponent = 0;\n    static const int max_exponent10 = 0;\n    static const bool has_infinity = false;\n    static const bool has_quiet_NaN = false;\n    static const bool has_signaling_NaN = false;\n    static const float_denorm_style has_denorm = denorm_absent;\n    static const bool has_denorm_loss = false;\n    static mpz_class infinity() { return mpz_class(); }\n    static mpz_class quiet_NaN() { return mpz_class(); }\n    static mpz_class signaling_NaN() { return mpz_class(); }\n    static mpz_class denorm_min() { return mpz_class(); }\n    static const bool is_iec559 = false;\n    static const bool is_bounded = false;\n    static const bool is_modulo = false;\n    static const bool traps = false;\n    static const bool tinyness_before = false;\n    static const float_round_style round_style = round_toward_zero;\n  };\n\n  template <> class numeric_limits<mpq_class>\n  {\n  public:\n    static const bool is_specialized = true;\n    static mpq_class min() { return mpq_class(); }\n    static mpq_class max() { return mpq_class(); }\n    static mpq_class lowest() { return mpq_class(); }\n    static const int digits = 0;\n    static const int digits10 = 0;\n    static const int max_digits10 = 0;\n    static const bool is_signed = true;\n    static const bool is_integer = false;\n    static const bool is_exact = true;\n    static const int radix = 2;\n    static mpq_class epsilon() { return mpq_class(); }\n    static mpq_class round_error() { return mpq_class(); }\n    static const int min_exponent = 0;\n    static const int min_exponent10 = 0;\n    static const int max_exponent = 0;\n    static const int max_exponent10 = 0;\n    static const bool has_infinity = false;\n    static const bool has_quiet_NaN = false;\n    static const bool has_signaling_NaN = false;\n    static const float_denorm_style has_denorm = denorm_absent;\n    static const bool has_denorm_loss = false;\n    static mpq_class infinity() { return mpq_class(); }\n    static mpq_class quiet_NaN() { return mpq_class(); }\n    static mpq_class signaling_NaN() { return mpq_class(); }\n    static mpq_class denorm_min() { return mpq_class(); }\n    static const bool is_iec559 = false;\n    static const bool is_bounded = false;\n    static const bool is_modulo = false;\n    static const bool traps = false;\n    static const bool tinyness_before = false;\n    static const float_round_style round_style = round_toward_zero;\n  };\n\n  template <> class numeric_limits<mpf_class>\n  {\n  public:\n    static const bool is_specialized = true;\n    static mpf_class min() { return mpf_class(); }\n    static mpf_class max() { return mpf_class(); }\n    static mpf_class lowest() { return mpf_class(); }\n    static const int digits = 0;\n    static const int digits10 = 0;\n    static const int max_digits10 = 0;\n    static const bool is_signed = true;\n    static const bool is_integer = false;\n    static const bool is_exact = false;\n    static const int radix = 2;\n    static mpf_class epsilon() { return mpf_class(); }\n    static mpf_class round_error() { return mpf_class(); }\n    static const int min_exponent = 0;\n    static const int min_exponent10 = 0;\n    static const int max_exponent = 0;\n    static const int max_exponent10 = 0;\n    static const bool has_infinity = false;\n    static const bool has_quiet_NaN = false;\n    static const bool has_signaling_NaN = false;\n    static const float_denorm_style has_denorm = denorm_absent;\n    static const bool has_denorm_loss = false;\n    static mpf_class infinity() { return mpf_class(); }\n    static mpf_class quiet_NaN() { return mpf_class(); }\n    static mpf_class signaling_NaN() { return mpf_class(); }\n    static mpf_class denorm_min() { return mpf_class(); }\n    static const bool is_iec559 = false;\n    static const bool is_bounded = false;\n    static const bool is_modulo = false;\n    static const bool traps = false;\n    static const bool tinyness_before = false;\n    static const float_round_style round_style = round_indeterminate;\n  };\n}",
          "{",
          "template <> class numeric_limits<mpz_class>",
          "template <> class numeric_limits<mpz_class",
          "template <> class numeric_limits",
          "template",
          "<",
          "> class",
          ">",
          "class",
          "numeric_limits",
          "<",
          "mpz_class",
          ">",
          "{\n  public:\n    static const bool is_specialized = true;\n    static mpz_class min() { return mpz_class(); }\n    static mpz_class max() { return mpz_class(); }\n    static mpz_class lowest() { return mpz_class(); }\n    static const int digits = 0;\n    static const int digits10 = 0;\n    static const int max_digits10 = 0;\n    static const bool is_signed = true;\n    static const bool is_integer = true;\n    static const bool is_exact = true;\n    static const int radix = 2;\n    static mpz_class epsilon() { return mpz_class(); }\n    static mpz_class round_error() { return mpz_class(); }\n    static const int min_exponent = 0;\n    static const int min_exponent10 = 0;\n    static const int max_exponent = 0;\n    static const int max_exponent10 = 0;\n    static const bool has_infinity = false;\n    static const bool has_quiet_NaN = false;\n    static const bool has_signaling_NaN = false;\n    static const float_denorm_style has_denorm = denorm_absent;\n    static const bool has_denorm_loss = false;\n    static mpz_class infinity() { return mpz_class(); }\n    static mpz_class quiet_NaN() { return mpz_class(); }\n    static mpz_class signaling_NaN() { return mpz_class(); }\n    static mpz_class denorm_min() { return mpz_class(); }\n    static const bool is_iec559 = false;\n    static const bool is_bounded = false;\n    static const bool is_modulo = false;\n    static const bool traps = false;\n    static const bool tinyness_before = false;\n    static const float_round_style round_style = round_toward_zero;\n  }",
          "{",
          "public:\n    static",
          "public",
          ":",
          "static",
          "static",
          "",
          "const bool is_specialized = true;",
          "const",
          "const",
          "bool",
          "is_specialized = true",
          "is_specialized",
          "=",
          "true",
          ";",
          "static",
          "static",
          "mpz_class"
        ]
      },
      {
        "start_point": [
          3262,
          4
        ],
        "end_point": [
          3262,
          50
        ],
        "content": "static mpz_class min() { return mpz_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpz_class"
        ]
      },
      {
        "start_point": [
          3299,
          4
        ],
        "end_point": [
          3299,
          50
        ],
        "content": "static mpq_class min() { return mpq_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpq_class"
        ]
      },
      {
        "start_point": [
          3336,
          4
        ],
        "end_point": [
          3336,
          50
        ],
        "content": "static mpf_class min() { return mpf_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpf_class"
        ]
      }
    ],
    "max": [
      {
        "start_point": [
          3263,
          4
        ],
        "end_point": [
          3263,
          50
        ],
        "content": "static mpz_class max() { return mpz_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpz_class"
        ]
      },
      {
        "start_point": [
          3300,
          4
        ],
        "end_point": [
          3300,
          50
        ],
        "content": "static mpq_class max() { return mpq_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpq_class"
        ]
      },
      {
        "start_point": [
          3337,
          4
        ],
        "end_point": [
          3337,
          50
        ],
        "content": "static mpf_class max() { return mpf_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpf_class"
        ]
      }
    ],
    "lowest": [
      {
        "start_point": [
          3264,
          4
        ],
        "end_point": [
          3264,
          53
        ],
        "content": "static mpz_class lowest() { return mpz_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpz_class"
        ]
      },
      {
        "start_point": [
          3301,
          4
        ],
        "end_point": [
          3301,
          53
        ],
        "content": "static mpq_class lowest() { return mpq_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpq_class"
        ]
      },
      {
        "start_point": [
          3338,
          4
        ],
        "end_point": [
          3338,
          53
        ],
        "content": "static mpf_class lowest() { return mpf_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpf_class"
        ]
      }
    ],
    "epsilon": [
      {
        "start_point": [
          3272,
          4
        ],
        "end_point": [
          3272,
          54
        ],
        "content": "static mpz_class epsilon() { return mpz_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpz_class"
        ]
      },
      {
        "start_point": [
          3309,
          4
        ],
        "end_point": [
          3309,
          54
        ],
        "content": "static mpq_class epsilon() { return mpq_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpq_class"
        ]
      },
      {
        "start_point": [
          3346,
          4
        ],
        "end_point": [
          3346,
          54
        ],
        "content": "static mpf_class epsilon() { return mpf_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpf_class"
        ]
      }
    ],
    "round_error": [
      {
        "start_point": [
          3273,
          4
        ],
        "end_point": [
          3273,
          58
        ],
        "content": "static mpz_class round_error() { return mpz_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpz_class"
        ]
      },
      {
        "start_point": [
          3310,
          4
        ],
        "end_point": [
          3310,
          58
        ],
        "content": "static mpq_class round_error() { return mpq_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpq_class"
        ]
      },
      {
        "start_point": [
          3347,
          4
        ],
        "end_point": [
          3347,
          58
        ],
        "content": "static mpf_class round_error() { return mpf_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpf_class"
        ]
      }
    ],
    "infinity": [
      {
        "start_point": [
          3283,
          4
        ],
        "end_point": [
          3283,
          55
        ],
        "content": "static mpz_class infinity() { return mpz_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpz_class"
        ]
      },
      {
        "start_point": [
          3320,
          4
        ],
        "end_point": [
          3320,
          55
        ],
        "content": "static mpq_class infinity() { return mpq_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpq_class"
        ]
      },
      {
        "start_point": [
          3357,
          4
        ],
        "end_point": [
          3357,
          55
        ],
        "content": "static mpf_class infinity() { return mpf_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpf_class"
        ]
      }
    ],
    "quiet_NaN": [
      {
        "start_point": [
          3284,
          4
        ],
        "end_point": [
          3284,
          56
        ],
        "content": "static mpz_class quiet_NaN() { return mpz_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpz_class"
        ]
      },
      {
        "start_point": [
          3321,
          4
        ],
        "end_point": [
          3321,
          56
        ],
        "content": "static mpq_class quiet_NaN() { return mpq_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpq_class"
        ]
      },
      {
        "start_point": [
          3358,
          4
        ],
        "end_point": [
          3358,
          56
        ],
        "content": "static mpf_class quiet_NaN() { return mpf_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpf_class"
        ]
      }
    ],
    "signaling_NaN": [
      {
        "start_point": [
          3285,
          4
        ],
        "end_point": [
          3285,
          60
        ],
        "content": "static mpz_class signaling_NaN() { return mpz_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpz_class"
        ]
      },
      {
        "start_point": [
          3322,
          4
        ],
        "end_point": [
          3322,
          60
        ],
        "content": "static mpq_class signaling_NaN() { return mpq_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpq_class"
        ]
      },
      {
        "start_point": [
          3359,
          4
        ],
        "end_point": [
          3359,
          60
        ],
        "content": "static mpf_class signaling_NaN() { return mpf_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpf_class"
        ]
      }
    ],
    "denorm_min": [
      {
        "start_point": [
          3286,
          4
        ],
        "end_point": [
          3286,
          57
        ],
        "content": "static mpz_class denorm_min() { return mpz_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpz_class"
        ]
      },
      {
        "start_point": [
          3323,
          4
        ],
        "end_point": [
          3323,
          57
        ],
        "content": "static mpq_class denorm_min() { return mpq_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpq_class"
        ]
      },
      {
        "start_point": [
          3360,
          4
        ],
        "end_point": [
          3360,
          57
        ],
        "content": "static mpf_class denorm_min() { return mpf_class(); }",
        "lines": 1,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "mpf_class"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/invalid.c": {
    "__gmp_invalid_operation": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "void\n__gmp_invalid_operation (void)\n{\n  raise (SIGFPE);\n  abort ();\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/longlong.h": {},
  "gmp/gmp-6.1.2/memory.c": {
    "__gmp_default_allocate": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void *\n__gmp_default_allocate (size_t size)\n{\n  void *ret;\n#ifdef DEBUG\n  size_t req_size = size;\n  size += 2 * GMP_LIMB_BYTES;\n#endif\n  ret = malloc (size);\n  if (ret == 0)\n    {\n      fprintf (stderr, \"GNU MP: Cannot allocate memory (size=%lu)\\n\", (long) size);\n      abort ();\n    }\n\n#ifdef DEBUG\n  {\n    mp_ptr p = ret;\n    p++;\n    p[-1] = (0xdeadbeef << 31) + 0xdeafdeed;\n    if (req_size % GMP_LIMB_BYTES == 0)\n      p[req_size / GMP_LIMB_BYTES] = ~((0xdeadbeef << 31) + 0xdeafdeed);\n    ret = p;\n  }\n#endif\n  return ret;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void",
        "*\n__gmp_default_allocate (size_t size)",
        "*"
      ]
    },
    "__gmp_default_reallocate": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void *\n__gmp_default_reallocate (void *oldptr, size_t old_size, size_t new_size)\n{\n  void *ret;\n\n#ifdef DEBUG\n  size_t req_size = new_size;\n\n  if (old_size != 0)\n    {\n      mp_ptr p = oldptr;\n      if (p[-1] != (0xdeadbeef << 31) + 0xdeafdeed)\n\t{\n\t  fprintf (stderr, \"gmp: (realloc) data clobbered before allocation block\\n\");\n\t  abort ();\n\t}\n      if (old_size % GMP_LIMB_BYTES == 0)\n\tif (p[old_size / GMP_LIMB_BYTES] != ~((0xdeadbeef << 31) + 0xdeafdeed))\n\t  {\n\t    fprintf (stderr, \"gmp: (realloc) data clobbered after allocation block\\n\");\n\t    abort ();\n\t  }\n      oldptr = p - 1;\n    }\n\n  new_size += 2 * GMP_LIMB_BYTES;\n#endif\n\n  ret = realloc (oldptr, new_size);\n  if (ret == 0)\n    {\n      fprintf (stderr, \"GNU MP: Cannot reallocate memory (old_size=%lu new_size=%lu)\\n\", (long) old_size, (long) new_size);\n      abort ();\n    }\n\n#ifdef DEBUG\n  {\n    mp_ptr p = ret;\n    p++;\n    p[-1] = (0xdeadbeef << 31) + 0xdeafdeed;\n    if (req_size % GMP_LIMB_BYTES == 0)\n      p[req_size / GMP_LIMB_BYTES] = ~((0xdeadbeef << 31) + 0xdeafdeed);\n    ret = p;\n  }\n#endif\n  return ret;\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "void",
        "*\n__gmp_default_reallocate (void *oldptr, size_t old_size, size_t new_size)",
        "*"
      ]
    },
    "__gmp_default_free": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\n__gmp_default_free (void *blk_ptr, size_t blk_size)\n{\n#ifdef DEBUG\n  {\n    mp_ptr p = blk_ptr;\n    if (blk_size != 0)\n      {\n\tif (p[-1] != (0xdeadbeef << 31) + 0xdeafdeed)\n\t  {\n\t    fprintf (stderr, \"gmp: (free) data clobbered before allocation block\\n\");\n\t    abort ();\n\t  }\n\tif (blk_size % GMP_LIMB_BYTES == 0)\n\t  if (p[blk_size / GMP_LIMB_BYTES] != ~((0xdeadbeef << 31) + 0xdeafdeed))\n\t    {\n\t      fprintf (stderr, \"gmp: (free) data clobbered after allocation block\\n\");\n\t      abort ();\n\t    }\n      }\n    blk_ptr = p - 1;\n  }\n#endif\n  free (blk_ptr);\n}",
      "lines": 25,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mp_bpl.c": {},
  "gmp/gmp-6.1.2/mp_clz_tab.c": {},
  "gmp/gmp-6.1.2/mp_dv_tab.c": {},
  "gmp/gmp-6.1.2/mp_get_fns.c": {},
  "gmp/gmp-6.1.2/mp_minv_tab.c": {},
  "gmp/gmp-6.1.2/mp_set_fns.c": {},
  "gmp/gmp-6.1.2/nextprime.c": {
    "gmp_nextprime": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "unsigned long int\ngmp_nextprime (gmp_primesieve_t *ps)\n{\n  unsigned long p, d, pi;\n  unsigned char *sp;\n  static unsigned char addtab[] =\n    { 2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,4,8,6,4,6,2,4,6,2,6,6,4,\n      2,4,6,2,6,4,2,4,2,10,2,10 };\n  unsigned char *addp = addtab;\n  unsigned long ai;\n\n  /* Look for already sieved primes.  A sentinel at the end of the sieving\n     area allows us to use a very simple loop here.  */\n  d = ps->d;\n  sp = ps->s + d;\n  while (*sp != 0)\n    sp++;\n  if (sp != ps->s + SIEVESIZE)\n    {\n      d = sp - ps->s;\n      ps->d = d + 1;\n      return ps->s0 + 2 * d;\n    }\n\n  /* Handle the number 2 separately.  */\n  if (ps->s0 < 3)\n    {\n      ps->s0 = 3 - 2 * SIEVESIZE; /* Tricky */\n      return 2;\n    }\n\n  /* Exhausted computed primes.  Resieve, then call ourselves recursively.  */\n\n#if 0\n  for (sp = ps->s; sp < ps->s + SIEVESIZE; sp++)\n    *sp = 0;\n#else\n  memset (ps->s, 0, SIEVESIZE);\n#endif\n\n  ps->s0 += 2 * SIEVESIZE;\n\n  /* Update sqrt_s0 as needed.  */\n  while ((ps->sqrt_s0 + 1) * (ps->sqrt_s0 + 1) <= ps->s0 + 2 * SIEVESIZE - 1)\n    ps->sqrt_s0++;\n\n  pi = ((ps->s0 + 3) / 2) % 3;\n  if (pi > 0)\n    pi = 3 - pi;\n  if (ps->s0 + 2 * pi <= 3)\n    pi += 3;\n  sp = ps->s + pi;\n  while (sp < ps->s + SIEVESIZE)\n    {\n      *sp = 1, sp += 3;\n    }\n\n  pi = ((ps->s0 + 5) / 2) % 5;\n  if (pi > 0)\n    pi = 5 - pi;\n  if (ps->s0 + 2 * pi <= 5)\n    pi += 5;\n  sp = ps->s + pi;\n  while (sp < ps->s + SIEVESIZE)\n    {\n      *sp = 1, sp += 5;\n    }\n\n  pi = ((ps->s0 + 7) / 2) % 7;\n  if (pi > 0)\n    pi = 7 - pi;\n  if (ps->s0 + 2 * pi <= 7)\n    pi += 7;\n  sp = ps->s + pi;\n  while (sp < ps->s + SIEVESIZE)\n    {\n      *sp = 1, sp += 7;\n    }\n\n  p = 11;\n  ai = 0;\n  while (p <= ps->sqrt_s0)\n    {\n      pi = ((ps->s0 + p) / 2) % p;\n      if (pi > 0)\n\tpi = p - pi;\n      if (ps->s0 + 2 * pi <= p)\n\t  pi += p;\n      sp = ps->s + pi;\n      while (sp < ps->s + SIEVESIZE)\n\t{\n\t  *sp = 1, sp += p;\n\t}\n      p += addp[ai];\n      ai = (ai + 1) % 48;\n    }\n  ps->d = 0;\n  return gmp_nextprime (ps);\n}",
      "lines": 99,
      "depth": 13,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    },
    "gmp_init_primesieve": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\ngmp_init_primesieve (gmp_primesieve_t *ps)\n{\n  ps->s0 = 0;\n  ps->sqrt_s0 = 0;\n  ps->d = SIEVESIZE;\n  ps->s[SIEVESIZE] = 0;\t\t/* sentinel */\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/primesieve.c": {
    "bit_to_n": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        80,
        48
      ],
      "content": "static mp_limb_t\nbit_to_n (mp_limb_t bit) { return (bit*3+4)|1; }",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "id_to_n": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        85,
        50
      ],
      "content": "static mp_limb_t\nid_to_n  (mp_limb_t id)  { return id*3+1+(id&1); }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "n_to_bit": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        89,
        47
      ],
      "content": "static mp_limb_t\nn_to_bit (mp_limb_t n) { return ((n-5)|1)/3U; }",
      "lines": 2,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "primesieve_size": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        93,
        73
      ],
      "content": "static mp_size_t\nprimesieve_size (mp_limb_t n) { return n_to_bit(n) / GMP_LIMB_BITS + 1; }",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "first_block_primesieve": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void\nfirst_block_primesieve (mp_ptr bit_array, mp_limb_t n)\n{\n  mp_size_t bits, limbs;\n\n  ASSERT (n > 4);\n\n  bits  = n_to_bit(n);\n  limbs = bits / GMP_LIMB_BITS + 1;\n\n  /* FIXME: We can skip 5 too, filling with a 5-part pattern. */\n  MPN_ZERO (bit_array, limbs);\n  bit_array[0] = SIEVE_SEED;\n\n  if ((bits + 1) % GMP_LIMB_BITS != 0)\n    bit_array[limbs-1] |= MP_LIMB_T_MAX << ((bits + 1) % GMP_LIMB_BITS);\n\n  if (n > SEED_LIMIT) {\n    mp_limb_t mask, index, i;\n\n    ASSERT (n > 49);\n\n    mask = 1;\n    index = 0;\n    i = 1;\n    do {\n      if ((bit_array[index] & mask) == 0)\n\t{\n\t  mp_size_t step, lindex;\n\t  mp_limb_t lmask;\n\t  unsigned  maskrot;\n\n\t  step = id_to_n(i);\n/*\t  lindex = n_to_bit(id_to_n(i)*id_to_n(i)); */\n\t  lindex = i*(step+1)-1+(-(i&1)&(i+1));\n/*\t  lindex = i*(step+1+(i&1))-1+(i&1); */\n\t  if (lindex > bits)\n\t    break;\n\n\t  step <<= 1;\n\t  maskrot = step % GMP_LIMB_BITS;\n\n\t  lmask = CNST_LIMB(1) << (lindex % GMP_LIMB_BITS);\n\t  do {\n\t    bit_array[lindex / GMP_LIMB_BITS] |= lmask;\n\t    lmask = lmask << maskrot | lmask >> (GMP_LIMB_BITS - maskrot);\n\t    lindex += step;\n\t  } while (lindex <= bits);\n\n/*\t  lindex = n_to_bit(id_to_n(i)*bit_to_n(i)); */\n\t  lindex = i*(i*3+6)+(i&1);\n\n\t  lmask = CNST_LIMB(1) << (lindex % GMP_LIMB_BITS);\n\t  for ( ; lindex <= bits; lindex += step) {\n\t    bit_array[lindex / GMP_LIMB_BITS] |= lmask;\n\t    lmask = lmask << maskrot | lmask >> (GMP_LIMB_BITS - maskrot);\n\t  };\n\t}\n      mask = mask << 1 | mask >> (GMP_LIMB_BITS-1);\n      index += mask & 1;\n      i++;\n    } while (1);\n  }\n}",
      "lines": 64,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "block_resieve": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static void\nblock_resieve (mp_ptr bit_array, mp_size_t limbs, mp_limb_t offset,\n\t\t      mp_srcptr sieve, mp_limb_t sieve_bits)\n{\n  mp_size_t bits, step;\n\n  ASSERT (limbs > 0);\n\n  bits = limbs * GMP_LIMB_BITS - 1;\n\n  /* FIXME: We can skip 5 too, filling with a 5-part pattern. */\n  MPN_ZERO (bit_array, limbs);\n\n  LOOP_ON_SIEVE_BEGIN(step,0,sieve_bits,0,sieve);\n  {\n    mp_size_t lindex;\n    mp_limb_t lmask;\n    unsigned  maskrot;\n\n/*  lindex = n_to_bit(id_to_n(i)*id_to_n(i)); */\n    lindex = __i*(step+1)-1+(-(__i&1)&(__i+1));\n/*  lindex = __i*(step+1+(__i&1))-1+(__i&1); */\n    if (lindex > bits + offset)\n      break;\n\n    step <<= 1;\n    maskrot = step % GMP_LIMB_BITS;\n\n    if (lindex < offset)\n      lindex += step * ((offset - lindex - 1) / step + 1);\n\n    lindex -= offset;\n\n    lmask = CNST_LIMB(1) << (lindex % GMP_LIMB_BITS);\n    for ( ; lindex <= bits; lindex += step) {\n      bit_array[lindex / GMP_LIMB_BITS] |= lmask;\n      lmask = lmask << maskrot | lmask >> (GMP_LIMB_BITS - maskrot);\n    };\n\n/*  lindex = n_to_bit(id_to_n(i)*bit_to_n(i)); */\n    lindex = __i*(__i*3+6)+(__i&1);\n    if (lindex > bits + offset)\n      continue;\n\n    if (lindex < offset)\n      lindex += step * ((offset - lindex - 1) / step + 1);\n\n    lindex -= offset;\n\n    lmask = CNST_LIMB(1) << (lindex % GMP_LIMB_BITS);\n    for ( ; lindex <= bits; lindex += step) {\n      bit_array[lindex / GMP_LIMB_BITS] |= lmask;\n      lmask = lmask << maskrot | lmask >> (GMP_LIMB_BITS - maskrot);\n    };\n  }\n  LOOP_ON_SIEVE_END;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gmp_primesieve": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "mp_limb_t\ngmp_primesieve (mp_ptr bit_array, mp_limb_t n)\n{\n  mp_size_t size;\n  mp_limb_t bits;\n\n  ASSERT (n > 4);\n\n  bits = n_to_bit(n);\n  size = bits / GMP_LIMB_BITS + 1;\n\n  if (size > BLOCK_SIZE * 2) {\n    mp_size_t off;\n    off = BLOCK_SIZE + (size % BLOCK_SIZE);\n    first_block_primesieve (bit_array, id_to_n (off * GMP_LIMB_BITS));\n    for ( ; off < size; off += BLOCK_SIZE)\n      block_resieve (bit_array + off, BLOCK_SIZE, off * GMP_LIMB_BITS, bit_array, off * GMP_LIMB_BITS - 1);\n  } else {\n    first_block_primesieve (bit_array, n);\n  }\n\n  if ((bits + 1) % GMP_LIMB_BITS != 0)\n    bit_array[size-1] |= MP_LIMB_T_MAX << ((bits + 1) % GMP_LIMB_BITS);\n\n\n  return size * GMP_LIMB_BITS - mpn_popcount (bit_array, size);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/tal-debug.c": {
    "__gmp_tmp_debug_mark": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\n__gmp_tmp_debug_mark (const char *file, int line,\n                      struct tmp_debug_t **markp, struct tmp_debug_t *mark,\n                      const char *decl_name, const char *mark_name)\n{\n  if (strcmp (mark_name, decl_name) != 0)\n    {\n      __gmp_assert_header (file, line);\n      fprintf (stderr, \"GNU MP: TMP_MARK(%s) but TMP_DECL(%s) is in scope\\n\",\n               mark_name, decl_name);\n      abort ();\n    }\n\n  if (*markp != NULL)\n    {\n      __gmp_assert_header (file, line);\n      fprintf (stderr, \"GNU MP: Repeat of TMP_MARK(%s)\\n\", mark_name);\n      if (mark->file != NULL && mark->file[0] != '\\0' && mark->line != -1)\n        {\n          __gmp_assert_header (mark->file, mark->line);\n          fprintf (stderr, \"previous was here\\n\");\n        }\n      abort ();\n    }\n\n  *markp = mark;\n  mark->file = file;\n  mark->line = line;\n  mark->list = NULL;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "__gmp_tmp_debug_alloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void *\n__gmp_tmp_debug_alloc (const char *file, int line, int dummy,\n                       struct tmp_debug_t **markp,\n                       const char *decl_name, size_t size)\n{\n  struct tmp_debug_t        *mark = *markp;\n  struct tmp_debug_entry_t  *p;\n\n  ASSERT_ALWAYS (size >= 1);\n\n  if (mark == NULL)\n    {\n      __gmp_assert_header (file, line);\n      fprintf (stderr, \"GNU MP: TMP_ALLOC without TMP_MARK(%s)\\n\", decl_name);\n      abort ();\n    }\n\n  p = __GMP_ALLOCATE_FUNC_TYPE (1, struct tmp_debug_entry_t);\n  p->size = size;\n  p->block = (*__gmp_allocate_func) (size);\n  p->next = mark->list;\n  mark->list = p;\n  return p->block;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "void",
        "*\n__gmp_tmp_debug_alloc (const char *file, int line, int dummy,\n                       struct tmp_debug_t **markp,\n                       const char *decl_name, size_t size)",
        "*"
      ]
    },
    "__gmp_tmp_debug_free": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "void\n__gmp_tmp_debug_free (const char *file, int line, int dummy,\n                      struct tmp_debug_t **markp,\n                      const char *decl_name, const char *free_name)\n{\n  struct tmp_debug_t        *mark = *markp;\n  struct tmp_debug_entry_t  *p, *next;\n\n  if (mark == NULL)\n    {\n      __gmp_assert_header (file, line);\n      fprintf (stderr, \"GNU MP: TMP_FREE(%s) without TMP_MARK(%s)\\n\",\n               free_name, decl_name);\n      abort ();\n    }\n\n  if (strcmp (free_name, decl_name) != 0)\n    {\n      __gmp_assert_header (file, line);\n      fprintf (stderr, \"GNU MP: TMP_FREE(%s) when TMP_DECL(%s) is in scope\\n\",\n               free_name, decl_name);\n      abort ();\n    }\n\n  p = mark->list;\n  while (p != NULL)\n    {\n      next = p->next;\n      (*__gmp_free_func) (p->block, p->size);\n      __GMP_FREE_FUNC_TYPE (p, 1, struct tmp_debug_entry_t);\n      p = next;\n    }\n\n  *markp = NULL;\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tal-notreent.c": {
    "__gmp_tmp_alloc": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\n__gmp_tmp_alloc (unsigned long size)\n{\n  void *that;\n\n  ASSERT ((size % __TMP_ALIGN) == 0);\n  ASSERT (((unsigned) current->alloc_point % __TMP_ALIGN) == 0);\n\n  if (size > (char *) current->end - (char *) current->alloc_point)\n    {\n      void *chunk;\n      tmp_stack *header;\n      unsigned long chunk_size;\n      unsigned long now;\n\n      /* Allocate a chunk that makes the total current allocation somewhat\n\t larger than the maximum allocation ever.  If size is very large, we\n\t allocate that much.  */\n\n      now = current_total_allocation + size;\n      if (now > max_total_allocation)\n\t{\n\t  /* We need more temporary memory than ever before.  Increase\n\t     for future needs.  */\n\t  now = (now * 3 / 2 + __TMP_ALIGN - 1) & -__TMP_ALIGN;\n\t  chunk_size = now - current_total_allocation + HSIZ;\n\t  current_total_allocation = now;\n\t  max_total_allocation = current_total_allocation;\n\t}\n      else\n\t{\n\t  chunk_size = max_total_allocation - current_total_allocation + HSIZ;\n\t  current_total_allocation = max_total_allocation;\n\t}\n\n      chunk = (*__gmp_allocate_func) (chunk_size);\n      header = (tmp_stack *) chunk;\n      header->end = (char *) chunk + chunk_size;\n      header->alloc_point = (char *) chunk + HSIZ;\n      header->prev = current;\n      current = header;\n    }\n\n  that = current->alloc_point;\n  current->alloc_point = (char *) that + size;\n  ASSERT (((unsigned) that % __TMP_ALIGN) == 0);\n  return that;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "void",
        "*\n__gmp_tmp_alloc (unsigned long size)",
        "*"
      ]
    },
    "__gmp_tmp_mark": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\n__gmp_tmp_mark (struct tmp_marker *mark)\n{\n  mark->which_chunk = current;\n  mark->alloc_point = current->alloc_point;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "__gmp_tmp_free": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\n__gmp_tmp_free (struct tmp_marker *mark)\n{\n  while (mark->which_chunk != current)\n    {\n      tmp_stack *tmp;\n\n      tmp = current;\n      current = tmp->prev;\n      current_total_allocation -= (((char *) (tmp->end) - (char *) tmp) - HSIZ);\n      (*__gmp_free_func) (tmp, (char *) tmp->end - (char *) tmp);\n    }\n  current->alloc_point = mark->alloc_point;\n}",
      "lines": 14,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tal-reent.c": {
    "__gmp_tmp_reentrant_alloc": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void *\n__gmp_tmp_reentrant_alloc (struct tmp_reentrant_t **markp, size_t size)\n{\n  char    *p;\n  size_t  total_size;\n\n#define P   ((struct tmp_reentrant_t *) p)\n\n  total_size = size + HSIZ;\n  p = (char *) (*__gmp_allocate_func) (total_size);\n  P->size = total_size;\n  P->next = *markp;\n  *markp = P;\n  return p + HSIZ;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void",
        "*\n__gmp_tmp_reentrant_alloc (struct tmp_reentrant_t **markp, size_t size)",
        "*"
      ]
    },
    "__gmp_tmp_reentrant_free": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\n__gmp_tmp_reentrant_free (struct tmp_reentrant_t *mark)\n{\n  struct tmp_reentrant_t  *next;\n\n  while (mark != NULL)\n    {\n      next = mark->next;\n      (*__gmp_free_func) ((char *) mark, mark->size);\n      mark = next;\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/version.c": {},
  "gmp/gmp-6.1.2/demos/factorize.c": {
    "factor_init": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\nfactor_init (struct factors *factors)\n{\n  factors->p = malloc (1);\n  factors->e = malloc (1);\n  factors->nfactors = 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "factor_clear": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nfactor_clear (struct factors *factors)\n{\n  int i;\n\n  for (i = 0; i < factors->nfactors; i++)\n    mpz_clear (factors->p[i]);\n\n  free (factors->p);\n  free (factors->e);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "factor_insert": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nfactor_insert (struct factors *factors, mpz_t prime)\n{\n  long    nfactors  = factors->nfactors;\n  mpz_t         *p  = factors->p;\n  unsigned long *e  = factors->e;\n  long i, j;\n\n  /* Locate position for insert new or increment e.  */\n  for (i = nfactors - 1; i >= 0; i--)\n    {\n      if (mpz_cmp (p[i], prime) <= 0)\n\tbreak;\n    }\n\n  if (i < 0 || mpz_cmp (p[i], prime) != 0)\n    {\n      p = realloc (p, (nfactors + 1) * sizeof p[0]);\n      e = realloc (e, (nfactors + 1) * sizeof e[0]);\n\n      mpz_init (p[nfactors]);\n      for (j = nfactors - 1; j > i; j--)\n\t{\n\t  mpz_set (p[j + 1], p[j]);\n\t  e[j + 1] = e[j];\n\t}\n      mpz_set (p[i + 1], prime);\n      e[i + 1] = 1;\n\n      factors->p = p;\n      factors->e = e;\n      factors->nfactors = nfactors + 1;\n    }\n  else\n    {\n      e[i] += 1;\n    }\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "factor_insert_ui": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\nfactor_insert_ui (struct factors *factors, unsigned long prime)\n{\n  mpz_t pz;\n\n  mpz_init_set_ui (pz, prime);\n  factor_insert (factors, pz);\n  mpz_clear (pz);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "factor_using_division": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\nfactor_using_division (mpz_t t, struct factors *factors)\n{\n  mpz_t q;\n  unsigned long int p;\n  int i;\n\n  if (flag_verbose > 0)\n    {\n      printf (\"[trial division] \");\n    }\n\n  mpz_init (q);\n\n  p = mpz_scan1 (t, 0);\n  mpz_fdiv_q_2exp (t, t, p);\n  while (p)\n    {\n      factor_insert_ui (factors, 2);\n      --p;\n    }\n\n  p = 3;\n  for (i = 1; i <= PRIMES_PTAB_ENTRIES;)\n    {\n      if (! mpz_divisible_ui_p (t, p))\n\t{\n\t  p += primes_diff[i++];\n\t  if (mpz_cmp_ui (t, p * p) < 0)\n\t    break;\n\t}\n      else\n\t{\n\t  mpz_tdiv_q_ui (t, t, p);\n\t  factor_insert_ui (factors, p);\n\t}\n    }\n\n  mpz_clear (q);\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mp_millerrabin": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "static int\nmp_millerrabin (mpz_srcptr n, mpz_srcptr nm1, mpz_ptr x, mpz_ptr y,\n\t\tmpz_srcptr q, unsigned long int k)\n{\n  unsigned long int i;\n\n  mpz_powm (y, x, q, n);\n\n  if (mpz_cmp_ui (y, 1) == 0 || mpz_cmp (y, nm1) == 0)\n    return 1;\n\n  for (i = 1; i < k; i++)\n    {\n      mpz_powm_ui (y, y, 2, n);\n      if (mpz_cmp (y, nm1) == 0)\n\treturn 1;\n      if (mpz_cmp_ui (y, 1) == 0)\n\treturn 0;\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mp_prime_p": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "int\nmp_prime_p (mpz_t n)\n{\n  int k, r, is_prime;\n  mpz_t q, a, nm1, tmp;\n  struct factors factors;\n\n  if (mpz_cmp_ui (n, 1) <= 0)\n    return 0;\n\n  /* We have already casted out small primes. */\n  if (mpz_cmp_ui (n, (long) FIRST_OMITTED_PRIME * FIRST_OMITTED_PRIME) < 0)\n    return 1;\n\n  mpz_inits (q, a, nm1, tmp, NULL);\n\n  /* Precomputation for Miller-Rabin.  */\n  mpz_sub_ui (nm1, n, 1);\n\n  /* Find q and k, where q is odd and n = 1 + 2**k * q.  */\n  k = mpz_scan1 (nm1, 0);\n  mpz_tdiv_q_2exp (q, nm1, k);\n\n  mpz_set_ui (a, 2);\n\n  /* Perform a Miller-Rabin test, finds most composites quickly.  */\n  if (!mp_millerrabin (n, nm1, a, tmp, q, k))\n    {\n      is_prime = 0;\n      goto ret2;\n    }\n\n  if (flag_prove_primality)\n    {\n      /* Factor n-1 for Lucas.  */\n      mpz_set (tmp, nm1);\n      factor (tmp, &factors);\n    }\n\n  /* Loop until Lucas proves our number prime, or Miller-Rabin proves our\n     number composite.  */\n  for (r = 0; r < PRIMES_PTAB_ENTRIES; r++)\n    {\n      int i;\n\n      if (flag_prove_primality)\n\t{\n\t  is_prime = 1;\n\t  for (i = 0; i < factors.nfactors && is_prime; i++)\n\t    {\n\t      mpz_divexact (tmp, nm1, factors.p[i]);\n\t      mpz_powm (tmp, a, tmp, n);\n\t      is_prime = mpz_cmp_ui (tmp, 1) != 0;\n\t    }\n\t}\n      else\n\t{\n\t  /* After enough Miller-Rabin runs, be content. */\n\t  is_prime = (r == MR_REPS - 1);\n\t}\n\n      if (is_prime)\n\tgoto ret1;\n\n      mpz_add_ui (a, a, primes_diff[r]);\t/* Establish new base.  */\n\n      if (!mp_millerrabin (n, nm1, a, tmp, q, k))\n\t{\n\t  is_prime = 0;\n\t  goto ret1;\n\t}\n    }\n\n  fprintf (stderr, \"Lucas prime test failure.  This should not happen\\n\");\n  abort ();\n\n ret1:\n  if (flag_prove_primality)\n    factor_clear (&factors);\n ret2:\n  mpz_clears (q, a, nm1, tmp, NULL);\n\n  return is_prime;\n}",
      "lines": 84,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "factor_using_pollard_rho": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "void\nfactor_using_pollard_rho (mpz_t n, unsigned long a, struct factors *factors)\n{\n  mpz_t x, z, y, P;\n  mpz_t t, t2;\n  unsigned long long k, l, i;\n\n  if (flag_verbose > 0)\n    {\n      printf (\"[pollard-rho (%lu)] \", a);\n    }\n\n  mpz_inits (t, t2, NULL);\n  mpz_init_set_si (y, 2);\n  mpz_init_set_si (x, 2);\n  mpz_init_set_si (z, 2);\n  mpz_init_set_ui (P, 1);\n  k = 1;\n  l = 1;\n\n  while (mpz_cmp_ui (n, 1) != 0)\n    {\n      for (;;)\n\t{\n\t  do\n\t    {\n\t      mpz_mul (t, x, x);\n\t      mpz_mod (x, t, n);\n\t      mpz_add_ui (x, x, a);\n\n\t      mpz_sub (t, z, x);\n\t      mpz_mul (t2, P, t);\n\t      mpz_mod (P, t2, n);\n\n\t      if (k % 32 == 1)\n\t\t{\n\t\t  mpz_gcd (t, P, n);\n\t\t  if (mpz_cmp_ui (t, 1) != 0)\n\t\t    goto factor_found;\n\t\t  mpz_set (y, x);\n\t\t}\n\t    }\n\t  while (--k != 0);\n\n\t  mpz_set (z, x);\n\t  k = l;\n\t  l = 2 * l;\n\t  for (i = 0; i < k; i++)\n\t    {\n\t      mpz_mul (t, x, x);\n\t      mpz_mod (x, t, n);\n\t      mpz_add_ui (x, x, a);\n\t    }\n\t  mpz_set (y, x);\n\t}\n\n    factor_found:\n      do\n\t{\n\t  mpz_mul (t, y, y);\n\t  mpz_mod (y, t, n);\n\t  mpz_add_ui (y, y, a);\n\n\t  mpz_sub (t, z, y);\n\t  mpz_gcd (t, t, n);\n\t}\n      while (mpz_cmp_ui (t, 1) == 0);\n\n      mpz_divexact (n, n, t);\t/* divide by t, before t is overwritten */\n\n      if (!mp_prime_p (t))\n\t{\n\t  if (flag_verbose > 0)\n\t    {\n\t      printf (\"[composite factor--restarting pollard-rho] \");\n\t    }\n\t  factor_using_pollard_rho (t, a + 1, factors);\n\t}\n      else\n\t{\n\t  factor_insert (factors, t);\n\t}\n\n      if (mp_prime_p (n))\n\t{\n\t  factor_insert (factors, n);\n\t  break;\n\t}\n\n      mpz_mod (x, x, n);\n      mpz_mod (z, z, n);\n      mpz_mod (y, y, n);\n    }\n\n  mpz_clears (P, t2, t, z, x, y, NULL);\n}",
      "lines": 96,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "factor": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "void\nfactor (mpz_t t, struct factors *factors)\n{\n  factor_init (factors);\n\n  if (mpz_sgn (t) != 0)\n    {\n      factor_using_division (t, factors);\n\n      if (mpz_cmp_ui (t, 1) != 0)\n\t{\n\t  if (flag_verbose > 0)\n\t    {\n\t      printf (\"[is number prime?] \");\n\t    }\n\t  if (mp_prime_p (t))\n\t    factor_insert (factors, t);\n\t  else\n\t    factor_using_pollard_rho (t, 1, factors);\n\t}\n    }\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        446,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  mpz_t t;\n  int i, j, k;\n  struct factors factors;\n\n  while (argc > 1)\n    {\n      if (!strcmp (argv[1], \"-v\"))\n\tflag_verbose = 1;\n      else if (!strcmp (argv[1], \"-w\"))\n\tflag_prove_primality = 0;\n      else\n\tbreak;\n\n      argv++;\n      argc--;\n    }\n\n  mpz_init (t);\n  if (argc > 1)\n    {\n      for (i = 1; i < argc; i++)\n\t{\n\t  mpz_set_str (t, argv[i], 0);\n\n\t  gmp_printf (\"%Zd:\", t);\n\t  factor (t, &factors);\n\n\t  for (j = 0; j < factors.nfactors; j++)\n\t    for (k = 0; k < factors.e[j]; k++)\n\t      gmp_printf (\" %Zd\", factors.p[j]);\n\n\t  puts (\"\");\n\t  factor_clear (&factors);\n\t}\n    }\n  else\n    {\n      for (;;)\n\t{\n\t  mpz_inp_str (t, stdin, 0);\n\t  if (feof (stdin))\n\t    break;\n\n\t  gmp_printf (\"%Zd:\", t);\n\t  factor (t, &factors);\n\n\t  for (j = 0; j < factors.nfactors; j++)\n\t    for (k = 0; k < factors.e[j]; k++)\n\t      gmp_printf (\" %Zd\", factors.p[j]);\n\n\t  puts (\"\");\n\t  factor_clear (&factors);\n\t}\n    }\n\n  exit (0);\n}",
      "lines": 60,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/isprime.c": {
    "print_usage_and_exit": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "void\nprint_usage_and_exit ()\n{\n  fprintf (stderr, \"usage: %s -q nnn\\n\", progname);\n  fprintf (stderr, \"usage: %s nnn ...\\n\", progname);\n  exit (-1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t n;\n  int i;\n\n  progname = argv[0];\n\n  if (argc < 2)\n    print_usage_and_exit ();\n\n  mpz_init (n);\n\n  if (argc == 3 && strcmp (argv[1], \"-q\") == 0)\n    {\n      if (mpz_set_str (n, argv[2], 0) != 0)\n\tprint_usage_and_exit ();\n      exit (mpz_probab_prime_p (n, 25) == 0);\n    }\n\n  for (i = 1; i < argc; i++)\n    {\n      int class;\n      if (mpz_set_str (n, argv[i], 0) != 0)\n\tprint_usage_and_exit ();\n      class = mpz_probab_prime_p (n, 25);\n      mpz_out_str (stdout, 10, n);\n      if (class == 0)\n\tputs (\" is composite\");\n      else if (class == 1)\n\tputs (\" is a probable prime\");\n      else /* class == 2 */\n\tputs (\" is a prime\");\n    }\n  exit (0);\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/pexpr.c": {
    "cputime": [
      {
        "start_point": [
          141,
          0
        ],
        "end_point": [
          148,
          1
        ],
        "content": "int\ncputime (void)\n{\n  struct rusage rus;\n\n  getrusage (0, &rus);\n  return rus.ru_utime.tv_sec * 1000 + rus.ru_utime.tv_usec / 1000;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          151,
          0
        ],
        "end_point": [
          157,
          1
        ],
        "content": "int\ncputime (void)\n{\n  if (CLOCKS_PER_SEC < 100000)\n    return clock () * 1000 / CLOCKS_PER_SEC;\n  return clock () / (CLOCKS_PER_SEC / 1000);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          159,
          0
        ],
        "end_point": [
          163,
          1
        ],
        "content": "int\ncputime (void)\n{\n  return 0;\n}",
        "lines": 5,
        "depth": 5,
        "decorators": [
          "int"
        ]
      }
    ],
    "stack_downwards_helper": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "int\nstack_downwards_helper (char *xp)\n{\n  char  y;\n  return &y < xp;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "stack_downwards_p": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nstack_downwards_p (void)\n{\n  char  x;\n  return stack_downwards_helper (&x);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "setup_error_handler": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "void\nsetup_error_handler (void)\n{\n#if HAVE_SIGACTION\n  struct sigaction act;\n  act.sa_handler = cleanup_and_exit;\n  sigemptyset (&(act.sa_mask));\n#define SIGNAL(sig)  sigaction (sig, &act, NULL)\n#else\n  struct { int sa_flags; } act;\n#define SIGNAL(sig)  signal (sig, cleanup_and_exit)\n#endif\n  act.sa_flags = 0;\n\n  /* Set up a stack for signal handling.  A typical cause of error is stack\n     overflow, and in such situation a signal can not be delivered on the\n     overflown stack.  */\n#if HAVE_SIGALTSTACK\n  {\n    /* AIX uses stack_t, MacOS uses struct sigaltstack, various other\n       systems have both. */\n#if HAVE_STACK_T\n    stack_t s;\n#else\n    struct sigaltstack s;\n#endif\n    s.ss_sp = malloc (SIGSTKSZ);\n    s.ss_size = SIGSTKSZ;\n    s.ss_flags = 0;\n    if (sigaltstack (&s, NULL) != 0)\n      perror(\"sigaltstack\");\n    act.sa_flags = SA_ONSTACK;\n  }\n#else\n#if HAVE_SIGSTACK\n  {\n    struct sigstack s;\n    s.ss_sp = malloc (SIGSTKSZ);\n    if (stack_downwards_p ())\n      s.ss_sp += SIGSTKSZ;\n    s.ss_onstack = 0;\n    if (sigstack (&s, NULL) != 0)\n      perror(\"sigstack\");\n    act.sa_flags = SA_ONSTACK;\n  }\n#else\n#endif\n#endif\n\n#ifdef LIMIT_RESOURCE_USAGE\n  {\n    struct rlimit limit;\n\n    limit.rlim_cur = limit.rlim_max = 0;\n    setrlimit (RLIMIT_CORE, &limit);\n\n    limit.rlim_cur = 3;\n    limit.rlim_max = 4;\n    setrlimit (RLIMIT_CPU, &limit);\n\n    limit.rlim_cur = limit.rlim_max = 16 * 1024 * 1024;\n    setrlimit (RLIMIT_DATA, &limit);\n\n    getrlimit (RLIMIT_STACK, &limit);\n    limit.rlim_cur = 4 * 1024 * 1024;\n    setrlimit (RLIMIT_STACK, &limit);\n\n    SIGNAL (SIGXCPU);\n  }\n#endif /* LIMIT_RESOURCE_USAGE */\n\n  SIGNAL (SIGILL);\n  SIGNAL (SIGSEGV);\n#ifdef SIGBUS /* not in mingw */\n  SIGNAL (SIGBUS);\n#endif\n  SIGNAL (SIGFPE);\n  SIGNAL (SIGABRT);\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        485,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  struct expr *e;\n  int i;\n  mpz_t r;\n  int errcode = 0;\n  char *str;\n  int base = 10;\n\n  setup_error_handler ();\n\n  gmp_randinit (rstate, GMP_RAND_ALG_LC, 128);\n\n  {\n#if HAVE_GETTIMEOFDAY\n    struct timeval tv;\n    gettimeofday (&tv, NULL);\n    gmp_randseed_ui (rstate, tv.tv_sec + tv.tv_usec);\n#else\n    time_t t;\n    time (&t);\n    gmp_randseed_ui (rstate, t);\n#endif\n  }\n\n  mpz_init (r);\n\n  while (argc > 1 && argv[1][0] == '-')\n    {\n      char *arg = argv[1];\n\n      if (arg[1] >= '0' && arg[1] <= '9')\n\tbreak;\n\n      if (arg[1] == 't')\n\tprint_timing = 1;\n      else if (arg[1] == 'b' && arg[2] >= '0' && arg[2] <= '9')\n\t{\n\t  base = atoi (arg + 2);\n\t  if (base < 2 || base > 62)\n\t    {\n\t      fprintf (stderr, \"error: invalid output base\\n\");\n\t      exit (-1);\n\t    }\n\t}\n      else if (arg[1] == 'b' && arg[2] == 0)\n\tbase = 2;\n      else if (arg[1] == 'x' && arg[2] == 0)\n\tbase = 16;\n      else if (arg[1] == 'X' && arg[2] == 0)\n\tbase = -16;\n      else if (arg[1] == 'o' && arg[2] == 0)\n\tbase = 8;\n      else if (arg[1] == 'd' && arg[2] == 0)\n\tbase = 10;\n      else if (arg[1] == 'v' && arg[2] == 0)\n\t{\n\t  printf (\"pexpr linked to gmp %s\\n\", __gmp_version);\n\t}\n      else if (strcmp (arg, \"-html\") == 0)\n\t{\n\t  flag_html = 1;\n\t  newline = \"<br>\";\n\t}\n      else if (strcmp (arg, \"-wml\") == 0)\n\t{\n\t  flag_wml = 1;\n\t  newline = \"<br/>\";\n\t}\n      else if (strcmp (arg, \"-split\") == 0)\n\t{\n\t  flag_splitup_output = 1;\n\t}\n      else if (strcmp (arg, \"-noprint\") == 0)\n\t{\n\t  flag_print = 0;\n\t}\n      else\n\t{\n\t  fprintf (stderr, \"error: unknown option `%s'\\n\", arg);\n\t  exit (-1);\n\t}\n      argv++;\n      argc--;\n    }\n\n  for (i = 1; i < argc; i++)\n    {\n      int s;\n      int jmpval;\n\n      /* Set up error handler for parsing expression.  */\n      jmpval = setjmp (errjmpbuf);\n      if (jmpval != 0)\n\t{\n\t  fprintf (stderr, \"error: %s%s\\n\", error, newline);\n\t  fprintf (stderr, \"       %s%s\\n\", argv[i], newline);\n\t  if (! flag_html)\n\t    {\n\t      /* ??? Dunno how to align expression position with arrow in\n\t\t HTML ??? */\n\t      fprintf (stderr, \"       \");\n\t      for (s = jmpval - (long) argv[i]; --s >= 0; )\n\t\tputc (' ', stderr);\n\t      fprintf (stderr, \"^\\n\");\n\t    }\n\n\t  errcode |= 1;\n\t  continue;\n\t}\n\n      str = expr (argv[i], &e);\n\n      if (str[0] != 0)\n\t{\n\t  fprintf (stderr,\n\t\t   \"error: garbage where end of expression expected%s\\n\",\n\t\t   newline);\n\t  fprintf (stderr, \"       %s%s\\n\", argv[i], newline);\n\t  if (! flag_html)\n\t    {\n\t      /* ??? Dunno how to align expression position with arrow in\n\t\t HTML ??? */\n\t      fprintf (stderr, \"        \");\n\t      for (s = str - argv[i]; --s; )\n\t\tputc (' ', stderr);\n\t      fprintf (stderr, \"^\\n\");\n\t    }\n\n\t  errcode |= 1;\n\t  free_expr (e);\n\t  continue;\n\t}\n\n      /* Set up error handler for evaluating expression.  */\n      if (setjmp (errjmpbuf))\n\t{\n\t  fprintf (stderr, \"error: %s%s\\n\", error, newline);\n\t  fprintf (stderr, \"       %s%s\\n\", argv[i], newline);\n\t  if (! flag_html)\n\t    {\n\t      /* ??? Dunno how to align expression position with arrow in\n\t\t HTML ??? */\n\t      fprintf (stderr, \"       \");\n\t      for (s = str - argv[i]; --s >= 0; )\n\t\tputc (' ', stderr);\n\t      fprintf (stderr, \"^\\n\");\n\t    }\n\n\t  errcode |= 2;\n\t  continue;\n\t}\n\n      if (print_timing)\n\t{\n\t  int t;\n\t  TIME (t, mpz_eval_expr (r, e));\n\t  printf (\"computation took %d ms%s\\n\", t, newline);\n\t}\n      else\n\tmpz_eval_expr (r, e);\n\n      if (flag_print)\n\t{\n\t  size_t out_len;\n\t  char *tmp, *s;\n\n\t  out_len = mpz_sizeinbase (r, base >= 0 ? base : -base) + 2;\n#ifdef LIMIT_RESOURCE_USAGE\n\t  if (out_len > 100000)\n\t    {\n\t      printf (\"result is about %ld digits, not printing it%s\\n\",\n\t\t      (long) out_len - 3, newline);\n\t      exit (-2);\n\t    }\n#endif\n\t  tmp = malloc (out_len);\n\n\t  if (print_timing)\n\t    {\n\t      int t;\n\t      printf (\"output conversion \");\n\t      TIME (t, mpz_get_str (tmp, base, r));\n\t      printf (\"took %d ms%s\\n\", t, newline);\n\t    }\n\t  else\n\t    mpz_get_str (tmp, base, r);\n\n\t  out_len = strlen (tmp);\n\t  if (flag_splitup_output)\n\t    {\n\t      for (s = tmp; out_len > 80; s += 80)\n\t\t{\n\t\t  fwrite (s, 1, 80, stdout);\n\t\t  printf (\"%s\\n\", newline);\n\t\t  out_len -= 80;\n\t\t}\n\n\t      fwrite (s, 1, out_len, stdout);\n\t    }\n\t  else\n\t    {\n\t      fwrite (tmp, 1, out_len, stdout);\n\t    }\n\n\t  free (tmp);\n\t  printf (\"%s\\n\", newline);\n\t}\n      else\n\t{\n\t  printf (\"result is approximately %ld digits%s\\n\",\n\t\t  (long) mpz_sizeinbase (r, base >= 0 ? base : -base),\n\t\t  newline);\n\t}\n\n      free_expr (e);\n    }\n\n  mpz_clear (r);\n\n  exit (errcode);\n}",
      "lines": 223,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "expr": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "char *\nexpr (char *str, expr_t *e)\n{\n  expr_t e2;\n\n  str = skipspace (str);\n  if (str[0] == '+')\n    {\n      str = term (str + 1, e);\n    }\n  else if (str[0] == '-')\n    {\n      str = term (str + 1, e);\n      makeexp (e, NEG, *e, NULL);\n    }\n  else if (str[0] == '~')\n    {\n      str = term (str + 1, e);\n      makeexp (e, NOT, *e, NULL);\n    }\n  else\n    {\n      str = term (str, e);\n    }\n\n  for (;;)\n    {\n      str = skipspace (str);\n      switch (str[0])\n\t{\n\tcase 'p':\n\t  if (match (\"plus\", str))\n\t    {\n\t      str = term (str + 4, &e2);\n\t      makeexp (e, PLUS, *e, e2);\n\t    }\n\t  else\n\t    return str;\n\t  break;\n\tcase 'm':\n\t  if (match (\"minus\", str))\n\t    {\n\t      str = term (str + 5, &e2);\n\t      makeexp (e, MINUS, *e, e2);\n\t    }\n\t  else\n\t    return str;\n\t  break;\n\tcase '+':\n\t  str = term (str + 1, &e2);\n\t  makeexp (e, PLUS, *e, e2);\n\t  break;\n\tcase '-':\n\t  str = term (str + 1, &e2);\n\t  makeexp (e, MINUS, *e, e2);\n\t  break;\n\tdefault:\n\t  return str;\n\t}\n    }\n}",
      "lines": 61,
      "depth": 15,
      "decorators": [
        "char",
        "*\nexpr (char *str, expr_t *e)",
        "*"
      ]
    },
    "term": {
      "start_point": [
        549,
        0
      ],
      "end_point": [
        634,
        1
      ],
      "content": "char *\nterm (char *str, expr_t *e)\n{\n  expr_t e2;\n\n  str = power (str, e);\n  for (;;)\n    {\n      str = skipspace (str);\n      switch (str[0])\n\t{\n\tcase 'm':\n\t  if (match (\"mul\", str))\n\t    {\n\t      str = power (str + 3, &e2);\n\t      makeexp (e, MULT, *e, e2);\n\t      break;\n\t    }\n\t  if (match (\"mod\", str))\n\t    {\n\t      str = power (str + 3, &e2);\n\t      makeexp (e, MOD, *e, e2);\n\t      break;\n\t    }\n\t  return str;\n\tcase 'd':\n\t  if (match (\"div\", str))\n\t    {\n\t      str = power (str + 3, &e2);\n\t      makeexp (e, DIV, *e, e2);\n\t      break;\n\t    }\n\t  return str;\n\tcase 'r':\n\t  if (match (\"rem\", str))\n\t    {\n\t      str = power (str + 3, &e2);\n\t      makeexp (e, REM, *e, e2);\n\t      break;\n\t    }\n\t  return str;\n\tcase 'i':\n\t  if (match (\"invmod\", str))\n\t    {\n\t      str = power (str + 6, &e2);\n\t      makeexp (e, REM, *e, e2);\n\t      break;\n\t    }\n\t  return str;\n\tcase 't':\n\t  if (match (\"times\", str))\n\t    {\n\t      str = power (str + 5, &e2);\n\t      makeexp (e, MULT, *e, e2);\n\t      break;\n\t    }\n\t  if (match (\"thru\", str))\n\t    {\n\t      str = power (str + 4, &e2);\n\t      makeexp (e, DIV, *e, e2);\n\t      break;\n\t    }\n\t  if (match (\"through\", str))\n\t    {\n\t      str = power (str + 7, &e2);\n\t      makeexp (e, DIV, *e, e2);\n\t      break;\n\t    }\n\t  return str;\n\tcase '*':\n\t  str = power (str + 1, &e2);\n\t  makeexp (e, MULT, *e, e2);\n\t  break;\n\tcase '/':\n\t  str = power (str + 1, &e2);\n\t  makeexp (e, DIV, *e, e2);\n\t  break;\n\tcase '%':\n\t  str = power (str + 1, &e2);\n\t  makeexp (e, MOD, *e, e2);\n\t  break;\n\tdefault:\n\t  return str;\n\t}\n    }\n}",
      "lines": 86,
      "depth": 15,
      "decorators": [
        "char",
        "*\nterm (char *str, expr_t *e)",
        "*"
      ]
    },
    "power": {
      "start_point": [
        636,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "char *\npower (char *str, expr_t *e)\n{\n  expr_t e2;\n\n  str = factor (str, e);\n  while (str[0] == '!')\n    {\n      str++;\n      makeexp (e, FAC, *e, NULL);\n    }\n  str = skipspace (str);\n  if (str[0] == '^')\n    {\n      str = power (str + 1, &e2);\n      makeexp (e, POW, *e, e2);\n    }\n  return str;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "char",
        "*\npower (char *str, expr_t *e)",
        "*"
      ]
    },
    "match": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        669,
        1
      ],
      "content": "int\nmatch (char *s, char *str)\n{\n  char *ostr = str;\n  int i;\n\n  for (i = 0; s[i] != 0; i++)\n    {\n      if (str[i] != s[i])\n\treturn 0;\n    }\n  str = skipspace (str + i);\n  return str - ostr;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "matchp": {
      "start_point": [
        671,
        0
      ],
      "end_point": [
        686,
        1
      ],
      "content": "int\nmatchp (char *s, char *str)\n{\n  char *ostr = str;\n  int i;\n\n  for (i = 0; s[i] != 0; i++)\n    {\n      if (str[i] != s[i])\n\treturn 0;\n    }\n  str = skipspace (str + i);\n  if (str[0] == '(')\n    return str - ostr + 1;\n  return 0;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "factor": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        852,
        1
      ],
      "content": "char *\nfactor (char *str, expr_t *e)\n{\n  expr_t e1, e2;\n\n  str = skipspace (str);\n\n  if (isalpha (str[0]))\n    {\n      int i;\n      int cnt;\n\n      for (i = 0; fns[i].op != NOP; i++)\n\t{\n\t  if (fns[i].arity == 1)\n\t    {\n\t      cnt = matchp (fns[i].spelling, str);\n\t      if (cnt != 0)\n\t\t{\n\t\t  str = expr (str + cnt, &e1);\n\t\t  str = skipspace (str);\n\t\t  if (str[0] != ')')\n\t\t    {\n\t\t      error = \"expected `)'\";\n\t\t      longjmp (errjmpbuf, (int) (long) str);\n\t\t    }\n\t\t  makeexp (e, fns[i].op, e1, NULL);\n\t\t  return str + 1;\n\t\t}\n\t    }\n\t}\n\n      for (i = 0; fns[i].op != NOP; i++)\n\t{\n\t  if (fns[i].arity != 1)\n\t    {\n\t      cnt = matchp (fns[i].spelling, str);\n\t      if (cnt != 0)\n\t\t{\n\t\t  str = expr (str + cnt, &e1);\n\t\t  str = skipspace (str);\n\n\t\t  if (str[0] != ',')\n\t\t    {\n\t\t      error = \"expected `,' and another operand\";\n\t\t      longjmp (errjmpbuf, (int) (long) str);\n\t\t    }\n\n\t\t  str = skipspace (str + 1);\n\t\t  str = expr (str, &e2);\n\t\t  str = skipspace (str);\n\n\t\t  if (fns[i].arity == 0)\n\t\t    {\n\t\t      while (str[0] == ',')\n\t\t\t{\n\t\t\t  makeexp (&e1, fns[i].op, e1, e2);\n\t\t\t  str = skipspace (str + 1);\n\t\t\t  str = expr (str, &e2);\n\t\t\t  str = skipspace (str);\n\t\t\t}\n\t\t    }\n\n\t\t  if (str[0] != ')')\n\t\t    {\n\t\t      error = \"expected `)'\";\n\t\t      longjmp (errjmpbuf, (int) (long) str);\n\t\t    }\n\n\t\t  makeexp (e, fns[i].op, e1, e2);\n\t\t  return str + 1;\n\t\t}\n\t    }\n\t}\n    }\n\n  if (str[0] == '(')\n    {\n      str = expr (str + 1, e);\n      str = skipspace (str);\n      if (str[0] != ')')\n\t{\n\t  error = \"expected `)'\";\n\t  longjmp (errjmpbuf, (int) (long) str);\n\t}\n      str++;\n    }\n  else if (str[0] >= '0' && str[0] <= '9')\n    {\n      expr_t res;\n      char *s, *sc;\n\n      res = malloc (sizeof (struct expr));\n      res -> op = LIT;\n      mpz_init (res->operands.val);\n\n      s = str;\n      while (isalnum (str[0]))\n\tstr++;\n      sc = malloc (str - s + 1);\n      memcpy (sc, s, str - s);\n      sc[str - s] = 0;\n\n      mpz_set_str (res->operands.val, sc, 0);\n      *e = res;\n      free (sc);\n    }\n  else\n    {\n      error = \"operand expected\";\n      longjmp (errjmpbuf, (int) (long) str);\n    }\n  return str;\n}",
      "lines": 114,
      "depth": 20,
      "decorators": [
        "char",
        "*\nfactor (char *str, expr_t *e)",
        "*"
      ]
    },
    "skipspace": {
      "start_point": [
        854,
        0
      ],
      "end_point": [
        860,
        1
      ],
      "content": "char *\nskipspace (char *str)\n{\n  while (str[0] == ' ')\n    str++;\n  return str;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nskipspace (char *str)",
        "*"
      ]
    },
    "makeexp": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        874,
        1
      ],
      "content": "void\nmakeexp (expr_t *r, enum op_t op, expr_t lhs, expr_t rhs)\n{\n  expr_t res;\n  res = malloc (sizeof (struct expr));\n  res -> op = op;\n  res -> operands.ops.lhs = lhs;\n  res -> operands.ops.rhs = rhs;\n  *r = res;\n  return;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "free_expr": {
      "start_point": [
        877,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "void\nfree_expr (expr_t e)\n{\n  if (e->op != LIT)\n    {\n      free_expr (e->operands.ops.lhs);\n      if (e->operands.ops.rhs != NULL)\n\tfree_expr (e->operands.ops.rhs);\n    }\n  else\n    {\n      mpz_clear (e->operands.val);\n    }\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpz_eval_expr": {
      "start_point": [
        893,
        0
      ],
      "end_point": [
        1306,
        1
      ],
      "content": "void\nmpz_eval_expr (mpz_ptr r, expr_t e)\n{\n  mpz_t lhs, rhs;\n\n  switch (e->op)\n    {\n    case LIT:\n      mpz_set (r, e->operands.val);\n      return;\n    case PLUS:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_add (r, lhs, rhs);\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n    case MINUS:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_sub (r, lhs, rhs);\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n    case MULT:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_mul (r, lhs, rhs);\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n    case DIV:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_fdiv_q (r, lhs, rhs);\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n    case MOD:\n      mpz_init (rhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_abs (rhs, rhs);\n      mpz_eval_mod_expr (r, e->operands.ops.lhs, rhs);\n      mpz_clear (rhs);\n      return;\n    case REM:\n      /* Check if lhs operand is POW expression and optimize for that case.  */\n      if (e->operands.ops.lhs->op == POW)\n\t{\n\t  mpz_t powlhs, powrhs;\n\t  mpz_init (powlhs);\n\t  mpz_init (powrhs);\n\t  mpz_init (rhs);\n\t  mpz_eval_expr (powlhs, e->operands.ops.lhs->operands.ops.lhs);\n\t  mpz_eval_expr (powrhs, e->operands.ops.lhs->operands.ops.rhs);\n\t  mpz_eval_expr (rhs, e->operands.ops.rhs);\n\t  mpz_powm (r, powlhs, powrhs, rhs);\n\t  if (mpz_cmp_si (rhs, 0L) < 0)\n\t    mpz_neg (r, r);\n\t  mpz_clear (powlhs);\n\t  mpz_clear (powrhs);\n\t  mpz_clear (rhs);\n\t  return;\n\t}\n\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_fdiv_r (r, lhs, rhs);\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n#if __GNU_MP_VERSION >= 2\n    case INVMOD:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_invert (r, lhs, rhs);\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n#endif\n    case POW:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      if (mpz_cmpabs_ui (lhs, 1) <= 0)\n\t{\n\t  /* For 0^rhs and 1^rhs, we just need to verify that\n\t     rhs is well-defined.  For (-1)^rhs we need to\n\t     determine (rhs mod 2).  For simplicity, compute\n\t     (rhs mod 2) for all three cases.  */\n\t  expr_t two, et;\n\t  two = malloc (sizeof (struct expr));\n\t  two -> op = LIT;\n\t  mpz_init_set_ui (two->operands.val, 2L);\n\t  makeexp (&et, MOD, e->operands.ops.rhs, two);\n\t  e->operands.ops.rhs = et;\n\t}\n\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      if (mpz_cmp_si (rhs, 0L) == 0)\n\t/* x^0 is 1 */\n\tmpz_set_ui (r, 1L);\n      else if (mpz_cmp_si (lhs, 0L) == 0)\n\t/* 0^y (where y != 0) is 0 */\n\tmpz_set_ui (r, 0L);\n      else if (mpz_cmp_ui (lhs, 1L) == 0)\n\t/* 1^y is 1 */\n\tmpz_set_ui (r, 1L);\n      else if (mpz_cmp_si (lhs, -1L) == 0)\n\t/* (-1)^y just depends on whether y is even or odd */\n\tmpz_set_si (r, (mpz_get_ui (rhs) & 1) ? -1L : 1L);\n      else if (mpz_cmp_si (rhs, 0L) < 0)\n\t/* x^(-n) is 0 */\n\tmpz_set_ui (r, 0L);\n      else\n\t{\n\t  unsigned long int cnt;\n\t  unsigned long int y;\n\t  /* error if exponent does not fit into an unsigned long int.  */\n\t  if (mpz_cmp_ui (rhs, ~(unsigned long int) 0) > 0)\n\t    goto pow_err;\n\n\t  y = mpz_get_ui (rhs);\n\t  /* x^y == (x/(2^c))^y * 2^(c*y) */\n#if __GNU_MP_VERSION >= 2\n\t  cnt = mpz_scan1 (lhs, 0);\n#else\n\t  cnt = 0;\n#endif\n\t  if (cnt != 0)\n\t    {\n\t      if (y * cnt / cnt != y)\n\t\tgoto pow_err;\n\t      mpz_tdiv_q_2exp (lhs, lhs, cnt);\n\t      mpz_pow_ui (r, lhs, y);\n\t      mpz_mul_2exp (r, r, y * cnt);\n\t    }\n\t  else\n\t    mpz_pow_ui (r, lhs, y);\n\t}\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n    pow_err:\n      error = \"result of `pow' operator too large\";\n      mpz_clear (lhs); mpz_clear (rhs);\n      longjmp (errjmpbuf, 1);\n    case GCD:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_gcd (r, lhs, rhs);\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n#if __GNU_MP_VERSION > 2 || __GNU_MP_VERSION_MINOR >= 1\n    case LCM:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_lcm (r, lhs, rhs);\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n#endif\n    case AND:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_and (r, lhs, rhs);\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n    case IOR:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_ior (r, lhs, rhs);\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n#if __GNU_MP_VERSION > 2 || __GNU_MP_VERSION_MINOR >= 1\n    case XOR:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      mpz_xor (r, lhs, rhs);\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n#endif\n    case NEG:\n      mpz_eval_expr (r, e->operands.ops.lhs);\n      mpz_neg (r, r);\n      return;\n    case NOT:\n      mpz_eval_expr (r, e->operands.ops.lhs);\n      mpz_com (r, r);\n      return;\n    case SQRT:\n      mpz_init (lhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      if (mpz_sgn (lhs) < 0)\n\t{\n\t  error = \"cannot take square root of negative numbers\";\n\t  mpz_clear (lhs);\n\t  longjmp (errjmpbuf, 1);\n\t}\n      mpz_sqrt (r, lhs);\n      return;\n#if __GNU_MP_VERSION > 2 || __GNU_MP_VERSION_MINOR >= 1\n    case ROOT:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      if (mpz_sgn (rhs) <= 0)\n\t{\n\t  error = \"cannot take non-positive root orders\";\n\t  mpz_clear (lhs); mpz_clear (rhs);\n\t  longjmp (errjmpbuf, 1);\n\t}\n      if (mpz_sgn (lhs) < 0 && (mpz_get_ui (rhs) & 1) == 0)\n\t{\n\t  error = \"cannot take even root orders of negative numbers\";\n\t  mpz_clear (lhs); mpz_clear (rhs);\n\t  longjmp (errjmpbuf, 1);\n\t}\n\n      {\n\tunsigned long int nth = mpz_get_ui (rhs);\n\tif (mpz_cmp_ui (rhs, ~(unsigned long int) 0) > 0)\n\t  {\n\t    /* If we are asked to take an awfully large root order, cheat and\n\t       ask for the largest order we can pass to mpz_root.  This saves\n\t       some error prone special cases.  */\n\t    nth = ~(unsigned long int) 0;\n\t  }\n\tmpz_root (r, lhs, nth);\n      }\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n#endif\n    case FAC:\n      mpz_eval_expr (r, e->operands.ops.lhs);\n      if (mpz_size (r) > 1)\n\t{\n\t  error = \"result of `!' operator too large\";\n\t  longjmp (errjmpbuf, 1);\n\t}\n      mpz_fac_ui (r, mpz_get_ui (r));\n      return;\n#if __GNU_MP_VERSION >= 2\n    case POPCNT:\n      mpz_eval_expr (r, e->operands.ops.lhs);\n      { long int cnt;\n\tcnt = mpz_popcount (r);\n\tmpz_set_si (r, cnt);\n      }\n      return;\n    case HAMDIST:\n      { long int cnt;\n\tmpz_init (lhs); mpz_init (rhs);\n\tmpz_eval_expr (lhs, e->operands.ops.lhs);\n\tmpz_eval_expr (rhs, e->operands.ops.rhs);\n\tcnt = mpz_hamdist (lhs, rhs);\n\tmpz_clear (lhs); mpz_clear (rhs);\n\tmpz_set_si (r, cnt);\n      }\n      return;\n#endif\n    case LOG2:\n      mpz_eval_expr (r, e->operands.ops.lhs);\n      { unsigned long int cnt;\n\tif (mpz_sgn (r) <= 0)\n\t  {\n\t    error = \"logarithm of non-positive number\";\n\t    longjmp (errjmpbuf, 1);\n\t  }\n\tcnt = mpz_sizeinbase (r, 2);\n\tmpz_set_ui (r, cnt - 1);\n      }\n      return;\n    case LOG:\n      { unsigned long int cnt;\n\tmpz_init (lhs); mpz_init (rhs);\n\tmpz_eval_expr (lhs, e->operands.ops.lhs);\n\tmpz_eval_expr (rhs, e->operands.ops.rhs);\n\tif (mpz_sgn (lhs) <= 0)\n\t  {\n\t    error = \"logarithm of non-positive number\";\n\t    mpz_clear (lhs); mpz_clear (rhs);\n\t    longjmp (errjmpbuf, 1);\n\t  }\n\tif (mpz_cmp_ui (rhs, 256) >= 0)\n\t  {\n\t    error = \"logarithm base too large\";\n\t    mpz_clear (lhs); mpz_clear (rhs);\n\t    longjmp (errjmpbuf, 1);\n\t  }\n\tcnt = mpz_sizeinbase (lhs, mpz_get_ui (rhs));\n\tmpz_set_ui (r, cnt - 1);\n\tmpz_clear (lhs); mpz_clear (rhs);\n      }\n      return;\n    case FERMAT:\n      {\n\tunsigned long int t;\n\tmpz_init (lhs);\n\tmpz_eval_expr (lhs, e->operands.ops.lhs);\n\tt = (unsigned long int) 1 << mpz_get_ui (lhs);\n\tif (mpz_cmp_ui (lhs, ~(unsigned long int) 0) > 0 || t == 0)\n\t  {\n\t    error = \"too large Mersenne number index\";\n\t    mpz_clear (lhs);\n\t    longjmp (errjmpbuf, 1);\n\t  }\n\tmpz_set_ui (r, 1);\n\tmpz_mul_2exp (r, r, t);\n\tmpz_add_ui (r, r, 1);\n\tmpz_clear (lhs);\n      }\n      return;\n    case MERSENNE:\n      mpz_init (lhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      if (mpz_cmp_ui (lhs, ~(unsigned long int) 0) > 0)\n\t{\n\t  error = \"too large Mersenne number index\";\n\t  mpz_clear (lhs);\n\t  longjmp (errjmpbuf, 1);\n\t}\n      mpz_set_ui (r, 1);\n      mpz_mul_2exp (r, r, mpz_get_ui (lhs));\n      mpz_sub_ui (r, r, 1);\n      mpz_clear (lhs);\n      return;\n    case FIBONACCI:\n      { mpz_t t;\n\tunsigned long int n, i;\n\tmpz_init (lhs);\n\tmpz_eval_expr (lhs, e->operands.ops.lhs);\n\tif (mpz_sgn (lhs) <= 0 || mpz_cmp_si (lhs, 1000000000) > 0)\n\t  {\n\t    error = \"Fibonacci index out of range\";\n\t    mpz_clear (lhs);\n\t    longjmp (errjmpbuf, 1);\n\t  }\n\tn = mpz_get_ui (lhs);\n\tmpz_clear (lhs);\n\n#if __GNU_MP_VERSION > 2 || __GNU_MP_VERSION_MINOR >= 1\n\tmpz_fib_ui (r, n);\n#else\n\tmpz_init_set_ui (t, 1);\n\tmpz_set_ui (r, 1);\n\n\tif (n <= 2)\n\t  mpz_set_ui (r, 1);\n\telse\n\t  {\n\t    for (i = 3; i <= n; i++)\n\t      {\n\t\tmpz_add (t, t, r);\n\t\tmpz_swap (t, r);\n\t      }\n\t  }\n\tmpz_clear (t);\n#endif\n      }\n      return;\n    case RANDOM:\n      {\n\tunsigned long int n;\n\tmpz_init (lhs);\n\tmpz_eval_expr (lhs, e->operands.ops.lhs);\n\tif (mpz_sgn (lhs) <= 0 || mpz_cmp_si (lhs, 1000000000) > 0)\n\t  {\n\t    error = \"random number size out of range\";\n\t    mpz_clear (lhs);\n\t    longjmp (errjmpbuf, 1);\n\t  }\n\tn = mpz_get_ui (lhs);\n\tmpz_clear (lhs);\n\tmpz_urandomb (r, rstate, n);\n      }\n      return;\n    case NEXTPRIME:\n      {\n\tmpz_eval_expr (r, e->operands.ops.lhs);\n\tmpz_nextprime (r, r);\n      }\n      return;\n    case BINOM:\n      mpz_init (lhs); mpz_init (rhs);\n      mpz_eval_expr (lhs, e->operands.ops.lhs);\n      mpz_eval_expr (rhs, e->operands.ops.rhs);\n      {\n\tunsigned long int k;\n\tif (mpz_cmp_ui (rhs, ~(unsigned long int) 0) > 0)\n\t  {\n\t    error = \"k too large in (n over k) expression\";\n\t    mpz_clear (lhs); mpz_clear (rhs);\n\t    longjmp (errjmpbuf, 1);\n\t  }\n\tk = mpz_get_ui (rhs);\n\tmpz_bin_ui (r, lhs, k);\n      }\n      mpz_clear (lhs); mpz_clear (rhs);\n      return;\n    case TIMING:\n      {\n\tint t0;\n\tt0 = cputime ();\n\tmpz_eval_expr (r, e->operands.ops.lhs);\n\tprintf (\"time: %d\\n\", cputime () - t0);\n      }\n      return;\n    default:\n      abort ();\n    }\n}",
      "lines": 414,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "mpz_eval_mod_expr": {
      "start_point": [
        1309,
        0
      ],
      "end_point": [
        1360,
        1
      ],
      "content": "void\nmpz_eval_mod_expr (mpz_ptr r, expr_t e, mpz_ptr mod)\n{\n  mpz_t lhs, rhs;\n\n  switch (e->op)\n    {\n      case POW:\n\tmpz_init (lhs); mpz_init (rhs);\n\tmpz_eval_mod_expr (lhs, e->operands.ops.lhs, mod);\n\tmpz_eval_expr (rhs, e->operands.ops.rhs);\n\tmpz_powm (r, lhs, rhs, mod);\n\tmpz_clear (lhs); mpz_clear (rhs);\n\treturn;\n      case PLUS:\n\tmpz_init (lhs); mpz_init (rhs);\n\tmpz_eval_mod_expr (lhs, e->operands.ops.lhs, mod);\n\tmpz_eval_mod_expr (rhs, e->operands.ops.rhs, mod);\n\tmpz_add (r, lhs, rhs);\n\tif (mpz_cmp_si (r, 0L) < 0)\n\t  mpz_add (r, r, mod);\n\telse if (mpz_cmp (r, mod) >= 0)\n\t  mpz_sub (r, r, mod);\n\tmpz_clear (lhs); mpz_clear (rhs);\n\treturn;\n      case MINUS:\n\tmpz_init (lhs); mpz_init (rhs);\n\tmpz_eval_mod_expr (lhs, e->operands.ops.lhs, mod);\n\tmpz_eval_mod_expr (rhs, e->operands.ops.rhs, mod);\n\tmpz_sub (r, lhs, rhs);\n\tif (mpz_cmp_si (r, 0L) < 0)\n\t  mpz_add (r, r, mod);\n\telse if (mpz_cmp (r, mod) >= 0)\n\t  mpz_sub (r, r, mod);\n\tmpz_clear (lhs); mpz_clear (rhs);\n\treturn;\n      case MULT:\n\tmpz_init (lhs); mpz_init (rhs);\n\tmpz_eval_mod_expr (lhs, e->operands.ops.lhs, mod);\n\tmpz_eval_mod_expr (rhs, e->operands.ops.rhs, mod);\n\tmpz_mul (r, lhs, rhs);\n\tmpz_mod (r, r, mod);\n\tmpz_clear (lhs); mpz_clear (rhs);\n\treturn;\n      default:\n\tmpz_init (lhs);\n\tmpz_eval_expr (lhs, e);\n\tmpz_mod (r, lhs, mod);\n\tmpz_clear (lhs);\n\treturn;\n    }\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "cleanup_and_exit": {
      "start_point": [
        1362,
        0
      ],
      "end_point": [
        1379,
        1
      ],
      "content": "void\ncleanup_and_exit (int sig)\n{\n  switch (sig) {\n#ifdef LIMIT_RESOURCE_USAGE\n  case SIGXCPU:\n    printf (\"expression took too long to evaluate%s\\n\", newline);\n    break;\n#endif\n  case SIGFPE:\n    printf (\"divide by zero%s\\n\", newline);\n    break;\n  default:\n    printf (\"expression required too much memory to evaluate%s\\n\", newline);\n    break;\n  }\n  exit (-2);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/primes.c": {
    "report": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nreport (mpz_t prime)\n{\n  total_primes += 1;\n  if (flag_print)\n    {\n      mpz_out_str (stdout, 10, prime);\n      printf (\"\\n\");\n    }\n  if (flag_maxgap)\n    {\n      static unsigned long prev_prime_low = 0;\n      unsigned long gap;\n      if (prev_prime_low != 0)\n\t{\n\t  gap = mpz_get_ui (prime) - prev_prime_low;\n\t  if (maxgap < gap)\n\t    maxgap = gap;\n\t}\n      prev_prime_low = mpz_get_ui (prime);\n    }\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *progname = argv[0];\n  mpz_t fr, to;\n  mpz_t fr2, to2;\n  unsigned long sieve_lim;\n  unsigned long est_n_primes;\n  unsigned char *s;\n  mpz_t tmp;\n  mpz_t siev_sqr_lim;\n\n  while (argc != 1)\n    {\n      if (strcmp (argv[1], \"-c\") == 0)\n\t{\n\t  flag_count = 1;\n\t  argv++;\n\t  argc--;\n\t}\n      else if (strcmp (argv[1], \"-p\") == 0)\n\t{\n\t  flag_print = 2;\n\t  argv++;\n\t  argc--;\n\t}\n      else if (strcmp (argv[1], \"-g\") == 0)\n\t{\n\t  flag_maxgap = 1;\n\t  argv++;\n\t  argc--;\n\t}\n      else\n\tbreak;\n    }\n\n  if (flag_count || flag_maxgap)\n    flag_print--;\t\t/* clear unless an explicit -p  */\n\n  mpz_init (fr);\n  mpz_init (to);\n  mpz_init (fr2);\n  mpz_init (to2);\n\n  if (argc == 3)\n    {\n      mpz_set_str (fr, argv[1], 0);\n      if (argv[2][0] == '+')\n\t{\n\t  mpz_set_str (to, argv[2] + 1, 0);\n\t  mpz_add (to, to, fr);\n\t}\n      else\n\tmpz_set_str (to, argv[2], 0);\n    }\n  else if (argc == 2)\n    {\n      mpz_set_ui (fr, 0);\n      mpz_set_str (to, argv[1], 0);\n    }\n  else\n    {\n      fprintf (stderr, \"usage: %s [-c] [-p] [-g] [from [+]]to\\n\", progname);\n      exit (1);\n    }\n\n  mpz_set (fr2, fr);\n  if (mpz_cmp_ui (fr2, 3) < 0)\n    {\n      mpz_set_ui (fr2, 2);\n      report (fr2);\n      mpz_set_ui (fr2, 3);\n    }\n  mpz_setbit (fr2, 0);\t\t\t\t/* make odd */\n  mpz_sub_ui (to2, to, 1);\n  mpz_setbit (to2, 0);\t\t\t\t/* make odd */\n\n  mpz_init (tmp);\n  mpz_init (siev_sqr_lim);\n\n  mpz_sqrt (tmp, to2);\n#define SIEVE_LIMIT 10000000\n  if (mpz_cmp_ui (tmp, SIEVE_LIMIT) < 0)\n    {\n      sieve_lim = mpz_get_ui (tmp);\n    }\n  else\n    {\n      sieve_lim = SIEVE_LIMIT;\n      mpz_sub (tmp, to2, fr2);\n      if (mpz_cmp_ui (tmp, sieve_lim) < 0)\n\tsieve_lim = mpz_get_ui (tmp);\t/* limit sieving for small ranges */\n    }\n  mpz_set_ui (siev_sqr_lim, sieve_lim + 1);\n  mpz_mul_ui (siev_sqr_lim, siev_sqr_lim, sieve_lim + 1);\n\n  est_n_primes = (size_t) (sieve_lim / log((double) sieve_lim) * 1.13) + 10;\n  primes = malloc (est_n_primes * sizeof primes[0]);\n  make_primelist (sieve_lim);\n  assert (est_n_primes >= n_primes);\n\n#if DEBUG\n  printf (\"sieve_lim = %lu\\n\", sieve_lim);\n  printf (\"n_primes = %lu (3..%u)\\n\",\n\t  n_primes, primes[n_primes - 1].prime);\n#endif\n\n#define S (1 << 15)\t\t/* FIXME: Figure out L1 cache size */\n  s = malloc (S/2);\n  while (mpz_cmp (fr2, to2) <= 0)\n    {\n      unsigned long rsize;\n      rsize = S;\n      mpz_add_ui (tmp, fr2, rsize);\n      if (mpz_cmp (tmp, to2) > 0)\n\t{\n\t  mpz_sub (tmp, to2, fr2);\n\t  rsize = mpz_get_ui (tmp) + 2;\n\t}\n#if DEBUG\n      printf (\"Sieving region [\"); mpz_out_str (stdout, 10, fr2);\n      printf (\",\"); mpz_add_ui (tmp, fr2, rsize - 2);\n      mpz_out_str (stdout, 10, tmp); printf (\"]\\n\");\n#endif\n      sieve_region (s, fr2, rsize);\n      find_primes (s, fr2, rsize / 2, siev_sqr_lim);\n\n      mpz_add_ui (fr2, fr2, S);\n    }\n  free (s);\n\n  if (flag_count)\n    printf (\"Pi(interval) = %lu\\n\", total_primes);\n\n  if (flag_maxgap)\n    printf (\"max gap: %lu\\n\", maxgap);\n\n  return 0;\n}",
      "lines": 139,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "sieve_region": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "void\nsieve_region (unsigned char *s, mpz_t fr, unsigned long rsize)\n{\n  unsigned long ssize = rsize / 2;\n  unsigned long start, start2, prime;\n  unsigned long i;\n  mpz_t tmp;\n\n  mpz_init (tmp);\n\n#if 0\n  /* initialize sieving array */\n  for (ii = 0; ii < (ssize + sizeof (long) - 1) / sizeof (long); ii++)\n    ((long *) s) [ii] = ~0L;\n#else\n  {\n    long k;\n    long *se = (long *) (s + ((ssize + sizeof (long) - 1) & -sizeof (long)));\n    for (k = -((ssize + sizeof (long) - 1) / sizeof (long)); k < 0; k++)\n      se[k] = ~0L;\n  }\n#endif\n\n  for (i = 0; i < n_primes; i++)\n    {\n      prime = primes[i].prime;\n\n      if (primes[i].rem >= 0)\n\t{\n\t  start2 = primes[i].rem;\n\t}\n      else\n\t{\n\t  mpz_set_ui (tmp, prime);\n\t  mpz_mul_ui (tmp, tmp, prime);\n\t  if (mpz_cmp (fr, tmp) <= 0)\n\t    {\n\t      mpz_sub (tmp, tmp, fr);\n\t      if (mpz_cmp_ui (tmp, 2 * ssize) > 0)\n\t\tbreak;\t\t/* avoid overflow at next line, also speedup */\n\t      start = mpz_get_ui (tmp);\n\t    }\n\t  else\n\t    {\n\t      start = (prime - mpz_tdiv_ui (fr, prime)) % prime;\n\t      if (start % 2 != 0)\n\t\tstart += prime;\t\t/* adjust if even divisible */\n\t    }\n\t  start2 = start / 2;\n\t}\n\n#if 0\n      for (ii = start2; ii < ssize; ii += prime)\n\ts[ii] = 0;\n      primes[i].rem = ii - ssize;\n#else\n      {\n\tlong k;\n\tunsigned char *se = s + ssize; /* point just beyond sieving range */\n\tfor (k = start2 - ssize; k < 0; k += prime)\n\t  se[k] = 0;\n\tprimes[i].rem = k;\n      }\n#endif\n    }\n  mpz_clear (tmp);\n}",
      "lines": 67,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "find_primes": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "void\nfind_primes (unsigned char *s, mpz_t  fr, unsigned long ssize,\n\t     mpz_t siev_sqr_lim)\n{\n  unsigned long j, ij;\n  mpz_t tmp;\n\n  mpz_init (tmp);\n  for (j = 0; j < (ssize + sizeof (long) - 1) / sizeof (long); j++)\n    {\n      if (((long *) s) [j] != 0)\n\t{\n\t  for (ij = 0; ij < sizeof (long); ij++)\n\t    {\n\t      if (s[j * sizeof (long) + ij] != 0)\n\t\t{\n\t\t  if (j * sizeof (long) + ij >= ssize)\n\t\t    goto out;\n\t\t  mpz_add_ui (tmp, fr, (j * sizeof (long) + ij) * 2);\n\t\t  if (mpz_cmp (tmp, siev_sqr_lim) < 0 ||\n\t\t      mpz_probab_prime_p (tmp, 10))\n\t\t    report (tmp);\n\t\t}\n\t    }\n\t}\n    }\n out:\n  mpz_clear (tmp);\n}",
      "lines": 29,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "make_primelist": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "void\nmake_primelist (unsigned long maxprime)\n{\n#if 1\n  unsigned char *s;\n  unsigned long ssize = maxprime / 2;\n  unsigned long i, ii, j;\n\n  s = malloc (ssize);\n  memset (s, ~0, ssize);\n  for (i = 3; ; i += 2)\n    {\n      unsigned long isqr = i * i;\n      if (isqr >= maxprime)\n\tbreak;\n      if (s[i * i / 2 - 1] == 0)\n\tcontinue;\t\t\t\t/* only sieve with primes */\n      for (ii = i * i / 2 - 1; ii < ssize; ii += i)\n\ts[ii] = 0;\n    }\n  n_primes = 0;\n  for (j = 0; j < ssize; j++)\n    {\n      if (s[j] != 0)\n\t{\n\t  primes[n_primes].prime = j * 2 + 3;\n\t  primes[n_primes].rem = -1;\n\t  n_primes++;\n\t}\n    }\n  /* FIXME: This should not be needed if fencepost errors were fixed... */\n  if (primes[n_primes - 1].prime > maxprime)\n    n_primes--;\n  free (s);\n#else\n  unsigned long i;\n  n_primes = 0;\n  for (i = 3; i <= maxprime; i += 2)\n    {\n      if (i < 7 || (i % 3 != 0 && i % 5 != 0 && i % 7 != 0))\n\t{\n\t  primes[n_primes].prime = i;\n\t  primes[n_primes].rem = -1;\n\t  n_primes++;\n\t}\n    }\n#endif\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/primes.h": {},
  "gmp/gmp-6.1.2/demos/qcn.c": {
    "prime_p": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nprime_p (unsigned long n)\n{\n  unsigned long  i, limit;\n\n  if (n == 2)\n    return 1;\n  if (n < 2 || !(n&1))\n    return 0;\n\n  limit = (unsigned long) floor (sqrt ((double) n));\n  for (i = 3; i <= limit; i+=2)\n    if ((n % i) == 0)\n      return 0;\n\n  return 1;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "qcn_estimate": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "double\nqcn_estimate (mpz_t d)\n{\n  double  h;\n  unsigned long  p;\n\n  /* p=2 */\n  h = sqrt (-mpz_get_d (d)) / M_PI\n    * 2.0 / (2.0 - mpz_kronecker_ui (d, 2));\n\n  if (mpz_cmp_si (d, -3) == 0)       h *= 3;\n  else if (mpz_cmp_si (d, -4) == 0)  h *= 2;\n\n  for (p = 3; p <= p_limit; p += 2)\n    if (prime_p (p))\n      h *= (double) p / (double) (p - mpz_kronecker_ui (d, p));\n\n  return h;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "qcn_str": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\nqcn_str (char *num)\n{\n  mpz_t  z;\n\n  mpz_init_set_str (z, num, 0);\n\n  if (mpz_sgn (z) >= 0)\n    {\n      mpz_out_str (stdout, 0, z);\n      printf (\" is not supported (negatives only)\\n\");\n    }\n  else if (mpz_fdiv_ui (z, 4) != 0 && mpz_fdiv_ui (z, 4) != 1)\n    {\n      mpz_out_str (stdout, 0, z);\n      printf (\" is not a discriminant (must == 0 or 1 mod 4)\\n\");\n    }\n  else\n    {\n      printf (\"h(\");\n      mpz_out_str (stdout, 0, z);\n      printf (\") approx %.1f\\n\", qcn_estimate (z));\n    }\n  mpz_clear (z);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int  i;\n  int  saw_number = 0;\n\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], \"-p\") == 0)\n\t{\n\t  i++;\n\t  if (i >= argc)\n\t    {\n\t      fprintf (stderr, \"Missing argument to -p\\n\");\n\t      exit (1);\n\t    }\n\t  p_limit = atoi (argv[i]);\n\t}\n      else\n\t{\n\t  qcn_str (argv[i]);\n\t  saw_number = 1;\n\t}\n    }\n\n  if (! saw_number)\n    {\n      /* some default output */\n      qcn_str (\"-85702502803\");           /* is 16259   */\n      qcn_str (\"-328878692999\");          /* is 1499699 */\n      qcn_str (\"-928185925902146563\");    /* is 52739552 */\n      qcn_str (\"-84148631888752647283\");  /* is 496652272 */\n      return 0;\n    }\n\n  return 0;\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/calc/calc-common.h": {},
  "gmp/gmp-6.1.2/demos/calc/calc.c": {
    "calc_help": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\ncalc_help (void)\n{\n  printf (\"Examples:\\n\");\n  printf (\"    2+3*4        expressions are evaluated\\n\");\n  printf (\"    x=5^6        variables a to z can be set and used\\n\");\n  printf (\"Operators:\\n\");\n  printf (\"    + - *        arithmetic\\n\");\n  printf (\"    / %%          division and remainder (rounding towards negative infinity)\\n\");\n  printf (\"    ^            exponentiation\\n\");\n  printf (\"    !            factorial\\n\");\n  printf (\"    << >>        left and right shifts\\n\");\n  printf (\"    <= >= >      \\\\ comparisons, giving 1 if true, 0 if false\\n\");\n  printf (\"    == != <      /\\n\");\n  printf (\"    && ||        logical and/or, giving 1 if true, 0 if false\\n\");\n  printf (\"Functions:\\n\");\n  printf (\"    abs(n)       absolute value\\n\");\n  printf (\"    bin(n,m)     binomial coefficient\\n\");\n  printf (\"    fib(n)       fibonacci number\\n\");\n  printf (\"    gcd(a,b,..)  greatest common divisor\\n\");\n  printf (\"    kron(a,b)    kronecker symbol\\n\");\n  printf (\"    lcm(a,b,..)  least common multiple\\n\");\n  printf (\"    lucnum(n)    lucas number\\n\");\n  printf (\"    nextprime(n) next prime after n\\n\");\n  printf (\"    powm(b,e,m)  modulo powering, b^e%%m\\n\");\n  printf (\"    root(n,r)    r-th root\\n\");\n  printf (\"    sqrt(n)      square root\\n\");\n  printf (\"Other:\\n\");\n  printf (\"    hex          \\\\ set hex or decimal for input and output\\n\");\n  printf (\"    decimal      /   (\\\"0x\\\" can be used for hex too)\\n\");\n  printf (\"    quit         exit program (EOF works too)\\n\");\n  printf (\"    ;            statements are separated with a ; or newline\\n\");\n  printf (\"    \\\\            continue expressions with \\\\ before newline\\n\");\n  printf (\"    # xxx        comments are # though to newline\\n\");\n  printf (\"Hex numbers must be entered in upper case, to distinguish them from the\\n\");\n  printf (\"variables a to f (like in bc).\\n\");\n}",
      "lines": 37,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "yytnamerr": {
      "start_point": [
        1219,
        0
      ],
      "end_point": [
        1256,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1267,
        0
      ],
      "end_point": [
        1396,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULL, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULL;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULL, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 130,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        2208,
        0
      ],
      "end_point": [
        2253,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int  i;\n\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], \"--readline\") == 0)\n        calc_option_readline = 1;\n      else if (strcmp (argv[i], \"--noreadline\") == 0)\n        calc_option_readline = 0;\n      else if (strcmp (argv[i], \"--help\") == 0)\n        {\n          printf (\"Usage: calc [--option]...\\n\");\n          printf (\"  --readline    use readline\\n\");\n          printf (\"  --noreadline  don't use readline\\n\");\n          printf (\"  --help        this message\\n\");\n          printf (\"Readline is only available when compiled in,\\n\");\n          printf (\"and in that case it's the default on a tty.\\n\");\n          exit (0);\n        }\n      else\n        {\n          fprintf (stderr, \"Unrecognised option: %s\\n\", argv[i]);\n          exit (1);\n        }\n    }\n\n#if WITH_READLINE\n  calc_init_readline ();\n#else\n  if (calc_option_readline == 1)\n    {\n      fprintf (stderr, \"Readline support not available\\n\");\n      exit (1);\n    }\n#endif\n\n  for (i = 0; i < numberof (variable); i++)\n    mpz_init (variable[i]);\n\n  for (i = 0; i < numberof (stack); i++)\n    mpz_init (stack[i]);\n\n  return yyparse ();\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/calc/calc.h": {},
  "gmp/gmp-6.1.2/demos/calc/calc.y": {
    "calc_help": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\ncalc_help (void)\n{\n  printf (\"Examples:\\n\");\n  printf (\"    2+3*4        expressions are evaluated\\n\");\n  printf (\"    x=5^6        variables a to z can be set and used\\n\");\n  printf (\"Operators:\\n\");\n  printf (\"    + - *        arithmetic\\n\");\n  printf (\"    / %%          division and remainder (rounding towards negative infinity)\\n\");\n  printf (\"    ^            exponentiation\\n\");\n  printf (\"    !            factorial\\n\");\n  printf (\"    << >>        left and right shifts\\n\");\n  printf (\"    <= >= >      \\\\ comparisons, giving 1 if true, 0 if false\\n\");\n  printf (\"    == != <      /\\n\");\n  printf (\"    && ||        logical and/or, giving 1 if true, 0 if false\\n\");\n  printf (\"Functions:\\n\");\n  printf (\"    abs(n)       absolute value\\n\");\n  printf (\"    bin(n,m)     binomial coefficient\\n\");\n  printf (\"    fib(n)       fibonacci number\\n\");\n  printf (\"    gcd(a,b,..)  greatest common divisor\\n\");\n  printf (\"    kron(a,b)    kronecker symbol\\n\");\n  printf (\"    lcm(a,b,..)  least common multiple\\n\");\n  printf (\"    lucnum(n)    lucas number\\n\");\n  printf (\"    nextprime(n) next prime after n\\n\");\n  printf (\"    powm(b,e,m)  modulo powering, b^e%%m\\n\");\n  printf (\"    root(n,r)    r-th root\\n\");\n  printf (\"    sqrt(n)      square root\\n\");\n  printf (\"Other:\\n\");\n  printf (\"    hex          \\\\ set hex or decimal for input and output\\n\");\n  printf (\"    decimal      /   (\\\"0x\\\" can be used for hex too)\\n\");\n  printf (\"    quit         exit program (EOF works too)\\n\");\n  printf (\"    ;            statements are separated with a ; or newline\\n\");\n  printf (\"    \\\\            continue expressions with \\\\ before newline\\n\");\n  printf (\"    # xxx        comments are # though to newline\\n\");\n  printf (\"Hex numbers must be entered in upper case, to distinguish them from the\\n\");\n  printf (\"variables a to f (like in bc).\\n\");\n}",
      "lines": 37,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "token": [
      {
        "start_point": [
          171,
          15
        ],
        "end_point": [
          172,
          41
        ],
        "content": "statement EOS\n  | error EOS { sp = stack[0]; yyerrok; }",
        "lines": 2,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          204,
          6
        ],
        "end_point": [
          205,
          69
        ],
        "content": "e LSHIFT e  { CHECK_UI (\"Shift count\", sp);\n                    sp--; mpz_mul_2exp (sp, sp, mpz_get_ui (sp+1)); }",
        "lines": 2,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          206,
          6
        ],
        "end_point": [
          207,
          72
        ],
        "content": "e RSHIFT e  { CHECK_UI (\"Shift count\", sp);\n                    sp--; mpz_fdiv_q_2exp (sp, sp, mpz_get_ui (sp+1)); }",
        "lines": 2,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          213,
          6
        ],
        "end_point": [
          213,
          69
        ],
        "content": "e LE  e     { sp--; mpz_set_ui (sp, mpz_cmp (sp, sp+1) <= 0); }",
        "lines": 1,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          214,
          6
        ],
        "end_point": [
          214,
          69
        ],
        "content": "e EQ  e     { sp--; mpz_set_ui (sp, mpz_cmp (sp, sp+1) == 0); }",
        "lines": 1,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          215,
          6
        ],
        "end_point": [
          215,
          69
        ],
        "content": "e NE  e     { sp--; mpz_set_ui (sp, mpz_cmp (sp, sp+1) != 0); }",
        "lines": 1,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          216,
          6
        ],
        "end_point": [
          216,
          69
        ],
        "content": "e GE  e     { sp--; mpz_set_ui (sp, mpz_cmp (sp, sp+1) >= 0); }",
        "lines": 1,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          219,
          6
        ],
        "end_point": [
          219,
          76
        ],
        "content": "e LAND e    { sp--; mpz_set_ui (sp, mpz_sgn (sp) && mpz_sgn (sp+1)); }",
        "lines": 1,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          220,
          6
        ],
        "end_point": [
          220,
          76
        ],
        "content": "e LOR e     { sp--; mpz_set_ui (sp, mpz_sgn (sp) || mpz_sgn (sp+1)); }",
        "lines": 1,
        "depth": 10,
        "decorators": null
      }
    ],
    "main": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int  i;\n\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], \"--readline\") == 0)\n        calc_option_readline = 1;\n      else if (strcmp (argv[i], \"--noreadline\") == 0)\n        calc_option_readline = 0;\n      else if (strcmp (argv[i], \"--help\") == 0)\n        {\n          printf (\"Usage: calc [--option]...\\n\");\n          printf (\"  --readline    use readline\\n\");\n          printf (\"  --noreadline  don't use readline\\n\");\n          printf (\"  --help        this message\\n\");\n          printf (\"Readline is only available when compiled in,\\n\");\n          printf (\"and in that case it's the default on a tty.\\n\");\n          exit (0);\n        }\n      else\n        {\n          fprintf (stderr, \"Unrecognised option: %s\\n\", argv[i]);\n          exit (1);\n        }\n    }\n\n#if WITH_READLINE\n  calc_init_readline ();\n#else\n  if (calc_option_readline == 1)\n    {\n      fprintf (stderr, \"Readline support not available\\n\");\n      exit (1);\n    }\n#endif\n\n  for (i = 0; i < numberof (variable); i++)\n    mpz_init (variable[i]);\n\n  for (i = 0; i < numberof (stack); i++)\n    mpz_init (stack[i]);\n\n  return yyparse ();\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/calc/calclex.c": {
    "yy_get_next_buffer": {
      "start_point": [
        944,
        0
      ],
      "end_point": [
        1072,
        2
      ],
      "content": "static int yy_get_next_buffer()\n#endif\n\t{\n\tchar *dest = yy_current_buffer->yy_ch_buf;\n\tchar *source = yytext_ptr;\n\tint number_to_move, i;\n\tint ret_val;\n\n\tif ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( yy_current_buffer->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tyy_current_buffer->yy_n_chars = yy_n_chars = 0;\n\n\telse\n\t\t{\n\t\tint num_to_read =\n\t\t\tyy_current_buffer->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n#ifdef YY_USES_REJECT\n\t\t\tYY_FATAL_ERROR(\n\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );\n#else\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = yy_current_buffer;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyy_flex_realloc( (void *) b->yy_ch_buf,\n\t\t\t\t\t\t\t b->yy_buf_size + 2 );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = yy_current_buffer->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n#endif\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),\n\t\t\tyy_n_chars, num_to_read );\n\n\t\tyy_current_buffer->yy_n_chars = yy_n_chars;\n\t\t}\n\n\tif ( yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart( yyin );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tyy_current_buffer->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tyy_n_chars += number_to_move;\n\tyy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tyy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyytext_ptr = &yy_current_buffer->yy_ch_buf[0];\n\n\treturn ret_val;\n\t}",
      "lines": 129,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        1080,
        0
      ],
      "end_point": [
        1106,
        2
      ],
      "content": "static yy_state_type yy_get_previous_state()\n#endif\n\t{\n\tyy_state_type yy_current_state;\n\tchar *yy_cp;\n\n\tyy_current_state = yy_start;\n\n\tfor ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )\n\t\t{\n\t\tYY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\tyy_last_accepting_state = yy_current_state;\n\t\t\tyy_last_accepting_cpos = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 39 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n\t}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_load_buffer_state": {
      "start_point": [
        1316,
        0
      ],
      "end_point": [
        1323,
        2
      ],
      "content": "void yy_load_buffer_state()\n#endif\n\t{\n\tyy_n_chars = yy_current_buffer->yy_n_chars;\n\tyytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;\n\tyyin = yy_current_buffer->yy_input_file;\n\tyy_hold_char = *yy_c_buf_p;\n\t}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "yy_pop_state": {
      "start_point": [
        1572,
        0
      ],
      "end_point": [
        1579,
        2
      ],
      "content": "static void yy_pop_state()\n#endif\n\t{\n\tif ( --yy_start_stack_ptr < 0 )\n\t\tYY_FATAL_ERROR( \"start-condition stack underflow\" );\n\n\tBEGIN(yy_start_stack[yy_start_stack_ptr]);\n\t}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_top_state": {
      "start_point": [
        1587,
        0
      ],
      "end_point": [
        1591,
        2
      ],
      "content": "static int yy_top_state()\n#endif\n\t{\n\treturn yy_start_stack[yy_start_stack_ptr - 1];\n\t}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        1701,
        0
      ],
      "end_point": [
        1705,
        2
      ],
      "content": "int main()\n\t{\n\tyylex();\n\treturn 0;\n\t}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "yywrap": {
      "start_point": [
        1710,
        0
      ],
      "end_point": [
        1714,
        1
      ],
      "content": "int\nyywrap ()\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/calc/calclex.l": {
    "yywrap": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\nyywrap ()\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/calc/calcread.c": {
    "calc_completion_entry": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char *\ncalc_completion_entry (const char *text, int state)\n{\n  static int  index, len;\n  char  *name;\n\n  if (!state)\n    {\n      index = 0;\n      len = strlen (text);\n    }\n  TRACE (printf (\"calc_completion_entry %s %d, index=%d len=%d\\n\",\n\t\t text, state, index, len));\n  while ((name = calc_keywords[index].name) != NULL)\n    {\n      index++;\n      if (memcmp (name, text, len) == 0)\n\treturn (strdup (name));\n    }\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "char",
        "*\ncalc_completion_entry (const char *text, int state)",
        "*"
      ]
    },
    "calc_init_readline": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\ncalc_init_readline (void)\n{\n  /* By default use readline when the input is a tty.  It's a bit contrary\n     to the GNU interface conventions to make the behaviour depend on where\n     the input is coming from, but this is pretty convenient.  */\n  if (calc_option_readline == -1)\n    {\n      calc_option_readline = isatty (fileno (stdin));\n      TRACE (printf (\"calc_option_readline %d\\n\", calc_option_readline));\n    }\n\n  if (calc_option_readline)\n    {\n      printf (\"GNU MP demo calculator program, gmp version %s\\n\", gmp_version);\n      printf (\"Type \\\"help\\\" for help.\\n\");\n      rl_readline_name = \"gmp-calc\";\n      rl_completion_entry_function = calc_completion_entry;\n    }\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "calc_input": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\ncalc_input (char *buf, size_t max_size)\n{\n  if (calc_option_readline)\n    {\n      static char    *line = NULL;\n      static size_t  line_size = 0;\n      static size_t  upto = 0;\n      size_t         copy_size;\n\n      if (upto >= line_size)\n\t{\n\t  if (line != NULL)\n\t    free (line);\n\n\t  line = readline (calc_more_input ? \"more> \" : \"> \");\n\t  calc_more_input = 1;\n\t  if (line == NULL)\n\t    return 0;\n\t  TRACE (printf (\"readline: %s\\n\", line));\n\n\t  if (line[0] != '\\0')\n\t    add_history (line);\n\n\t  line_size = strlen (line);\n\t  line[line_size] = '\\n';\n\t  line_size++;\n\t  upto = 0;\n\t}\n\n      copy_size = MIN (line_size-upto, max_size);\n      memcpy (buf, line+upto, copy_size);\n      upto += copy_size;\n      return copy_size;\n    }\n  else\n    {\n      /* not readline */\n      return fread (buf, 1, max_size, stdin);\n    }\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "input": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "int\ninput (void)\n{\n  char  c;\n  if (calc_input (&c, 1) != 1)\n    return EOF;\n  else\n    return (int) c;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/expr/expr-impl.h": {},
  "gmp/gmp-6.1.2/demos/expr/expr.c": {
    "lookahead": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static int\nlookahead (struct mpexpr_parse_t *p, int prefix)\n{\n  const struct mpexpr_operator_t  *op, *op_found;\n  size_t  oplen, oplen_found, wlen;\n  int     i;\n\n  /* skip white space */\n  while (p->elen > 0 && isasciispace (*p->e))\n    p->e++, p->elen--;\n\n  if (p->elen == 0)\n    {\n      TRACE (printf (\"lookahead EOF\\n\"));\n      p->token = TOKEN_EOF;\n      return 1;\n    }\n\n  DATA_SPACE ();\n\n  /* Get extent of whole word. */\n  for (wlen = 0; wlen < p->elen; wlen++)\n    if (! isasciicsym (p->e[wlen]))\n      break;\n\n  TRACE (printf (\"lookahead at: \\\"%.*s\\\" length %u, word %u\\n\",\n\t\t (int) p->elen, p->e, p->elen, wlen));\n\n  op_found = NULL;\n  oplen_found = 0;\n  for (op = p->table; op->name != NULL; op++)\n    {\n      if (op->type == MPEXPR_TYPE_NEW_TABLE)\n\t{\n\t  printf (\"new\\n\");\n\t  op = (struct mpexpr_operator_t *) op->name - 1;\n\t  continue;\n\t}\n\n      oplen = strlen (op->name);\n      if (! ((WHOLEWORD (op) ? wlen == oplen : p->elen >= oplen)\n\t     && memcmp (p->e, op->name, oplen) == 0))\n\tcontinue;\n\n      /* Shorter matches don't replace longer previous ones. */\n      if (op_found && oplen < oplen_found)\n\tcontinue;\n\n      /* On a match of equal length to a previous one, the old match isn't\n\t replaced if it has the preferred prefix, and if it doesn't then\n\t it's not replaced if the new one also doesn't.  */\n      if (op_found && oplen == oplen_found\n\t  && ((op_found->type & MPEXPR_TYPE_PREFIX) == prefix\n\t      || (op->type & MPEXPR_TYPE_PREFIX) != prefix))\n\tcontinue;\n\n      /* This is now either the first match seen, or a longer than previous\n\t match, or an equal to previous one but with a preferred prefix. */\n      op_found = op;\n      oplen_found = oplen;\n    }\n\n  if (op_found)\n    {\n      p->e += oplen_found, p->elen -= oplen_found;\n\n      if (op_found->type == MPEXPR_TYPE_VARIABLE)\n\t{\n\t  if (p->elen == 0)\n\t    ERROR (\"end of string expecting a variable\",\n\t\t   MPEXPR_RESULT_PARSE_ERROR);\n\t  i = p->e[0] - 'a';\n\t  if (i < 0 || i >= MPEXPR_VARIABLES)\n\t    ERROR (\"bad variable name\", MPEXPR_RESULT_BAD_VARIABLE);\n\t  goto variable;\n\t}\n\n      if (op_found->precedence == 0)\n\t{\n\t  TRACE (printf (\"lookahead function: %s\\n\", op_found->name));\n\t  p->token = TOKEN_FUNCTION;\n\t  p->token_op = op_found;\n\t  return 1;\n\t}\n      else\n\t{\n\t  TRACE (printf (\"lookahead operator: %s\\n\", op_found->name));\n\t  p->token = TOKEN_OPERATOR;\n\t  p->token_op = op_found;\n\t  return 1;\n\t}\n    }\n\n  oplen = (*p->mpX_number) (SP+1, p->e, p->elen, p->base);\n  if (oplen != 0)\n    {\n      p->e += oplen, p->elen -= oplen;\n      p->token = TOKEN_VALUE;\n      DATA_PUSH ();\n      TRACE (MPX_TRACE (\"lookahead number\", SP));\n      return 1;\n    }\n\n  /* Maybe an unprefixed one character variable */\n  i = p->e[0] - 'a';\n  if (wlen == 1 && i >= 0 && i < MPEXPR_VARIABLES)\n    {\n    variable:\n      p->e++, p->elen--;\n      if (p->var[i] == NULL)\n\tERROR (\"NULL variable\", MPEXPR_RESULT_BAD_VARIABLE);\n      TRACE (printf (\"lookahead variable: var[%d] = \", i);\n\t     MPX_TRACE (\"\", p->var[i]));\n      p->token = TOKEN_VALUE;\n      DATA_PUSH ();\n      (*p->mpX_set) (SP, p->var[i]);\n      return 1;\n    }\n\n  ERROR (\"no token matched\", MPEXPR_RESULT_PARSE_ERROR);\n\n done:\n  return 0;\n}",
      "lines": 124,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpexpr_evaluate": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        833,
        1
      ],
      "content": "int\nmpexpr_evaluate (struct mpexpr_parse_t *p)\n{\n  void *(*allocate_func) (size_t);\n  void *(*reallocate_func) (void *, size_t, size_t);\n  void (*free_func) (void *, size_t);\n\n  mp_get_memory_functions (&allocate_func, &reallocate_func, &free_func);\n\n  TRACE (printf (\"mpexpr_evaluate() base %d \\\"%.*s\\\"\\n\",\n\t\t p->base, (int) p->elen, p->e));\n\n  /* \"done\" is a special sentinel at the bottom of the control stack,\n     precedence -1 is lower than any normal operator.  */\n  {\n    static const struct mpexpr_operator_t  operator_done\n      = { \"DONE\", NULL, MPEXPR_TYPE_DONE, -1 };\n\n    p->control_alloc = 20;\n    p->control_stack = ALLOCATE_FUNC_TYPE (p->control_alloc,\n\t\t\t\t\t   struct mpexpr_control_t);\n    p->control_top = 0;\n    CP->op = &operator_done;\n    CP->argcount = 1;\n  }\n\n  p->data_inited = 0;\n  p->data_alloc = 20;\n  p->data_stack = ALLOCATE_FUNC_TYPE (p->data_alloc, union mpX_t);\n  p->data_top = -1;\n\n  p->error_code = MPEXPR_RESULT_OK;\n\n\n another_expr_lookahead:\n  LOOKAHEAD (MPEXPR_TYPE_PREFIX);\n  TRACE (printf (\"another expr\\n\"));\n\n  /*another_expr:*/\n  switch (p->token) {\n  case TOKEN_VALUE:\n    goto another_operator_lookahead;\n\n  case TOKEN_OPERATOR:\n    TRACE (printf (\"operator %s\\n\", p->token_op->name));\n    if (! (p->token_op->type & MPEXPR_TYPE_PREFIX))\n      ERROR (\"expected a prefix operator\", MPEXPR_RESULT_PARSE_ERROR);\n\n    CONTROL_PUSH (p->token_op, 1);\n    goto another_expr_lookahead;\n\n  case TOKEN_FUNCTION:\n    CONTROL_PUSH (p->token_op, 1);\n\n    if (p->token_op->type & MPEXPR_TYPE_CONSTANT)\n      goto apply_control_lookahead;\n\n    LOOKAHEAD (MPEXPR_TYPE_PREFIX);\n    if (! (p->token == TOKEN_OPERATOR\n\t   && p->token_op->type == MPEXPR_TYPE_OPENPAREN))\n      ERROR (\"expected open paren for function\", MPEXPR_RESULT_PARSE_ERROR);\n\n    TRACE (printf (\"open paren for function \\\"%s\\\"\\n\", CP->op->name));\n\n    if ((CP->op->type & MPEXPR_TYPE_MASK_ARGCOUNT) == MPEXPR_TYPE_NARY(0))\n      {\n\tLOOKAHEAD (0);\n\tif (! (p->token == TOKEN_OPERATOR\n\t       && p->token_op->type == MPEXPR_TYPE_CLOSEPAREN))\n\t  ERROR (\"expected close paren for 0ary function\",\n\t\t MPEXPR_RESULT_PARSE_ERROR);\n\tgoto apply_control_lookahead;\n      }\n\n    goto another_expr_lookahead;\n  }\n  ERROR (\"unrecognised start of expression\", MPEXPR_RESULT_PARSE_ERROR);\n\n\n another_operator_lookahead:\n  LOOKAHEAD (0);\n another_operator:\n  TRACE (printf (\"another operator maybe: %s\\n\", TOKEN_NAME(p->token)));\n\n  switch (p->token) {\n  case TOKEN_EOF:\n    goto apply_control;\n\n  case TOKEN_OPERATOR:\n    /* The next operator is compared to the one on top of the control stack.\n       If the next is lower precedence, or the same precedence and not\n       right-associative, then reduce using the control stack and look at\n       the next operator again later.  */\n\n#define PRECEDENCE_TEST_REDUCE(tprec,cprec,ttype,ctype)                 \\\n    ((tprec) < (cprec)                                                  \\\n     || ((tprec) == (cprec) && ! ((ttype) & MPEXPR_TYPE_RIGHTASSOC)))\n\n    if (PRECEDENCE_TEST_REDUCE (p->token_op->precedence, CP->op->precedence,\n\t\t\t\tp->token_op->type,       CP->op->type))\n      {\n\tTRACE (printf (\"defer operator: %s (prec %d vs %d, type 0x%X)\\n\",\n\t\t       p->token_op->name,\n\t\t       p->token_op->precedence, CP->op->precedence,\n\t\t       p->token_op->type));\n\tgoto apply_control;\n      }\n\n    /* An argsep is a binary operator, but is never pushed on the control\n       stack, it just accumulates an extra argument for a function. */\n    if (p->token_op->type == MPEXPR_TYPE_ARGSEP)\n      {\n\tif (CP->op->precedence != 0)\n\t  ERROR (\"ARGSEP not in a function call\", MPEXPR_RESULT_PARSE_ERROR);\n\n\tTRACE (printf (\"argsep for function \\\"%s\\\"(%d)\\n\",\n\t\t       CP->op->name, CP->argcount));\n\n#define IS_PAIRWISE(type)                                               \\\n\t(((type) & (MPEXPR_TYPE_MASK_ARGCOUNT | MPEXPR_TYPE_PAIRWISE))  \\\n\t == (MPEXPR_TYPE_BINARY | MPEXPR_TYPE_PAIRWISE))\n\n\tif (IS_PAIRWISE (CP->op->type) && CP->argcount >= 2)\n\t  {\n\t    TRACE (printf (\"    will reduce pairwise now\\n\"));\n\t    CP->argcount--;\n\t    CONTROL_PUSH (CP->op, 2);\n\t    goto apply_control;\n\t  }\n\n\tCP->argcount++;\n\tgoto another_expr_lookahead;\n      }\n\n    switch (p->token_op->type & MPEXPR_TYPE_MASK_ARGCOUNT) {\n    case MPEXPR_TYPE_NARY(1):\n      /* Postfix unary operators can always be applied immediately.  The\n\t easiest way to do this is just push it on the control stack and go\n\t to the normal control stack reduction code. */\n\n      TRACE (printf (\"postfix unary operator: %s\\n\", p->token_op->name));\n      if (p->token_op->type & MPEXPR_TYPE_PREFIX)\n\tERROR (\"prefix unary operator used postfix\",\n\t       MPEXPR_RESULT_PARSE_ERROR);\n      CONTROL_PUSH (p->token_op, 1);\n      goto apply_control_lookahead;\n\n    case MPEXPR_TYPE_NARY(2):\n      CONTROL_PUSH (p->token_op, 2);\n      goto another_expr_lookahead;\n\n    case MPEXPR_TYPE_NARY(3):\n      CONTROL_PUSH (p->token_op, 1);\n      goto another_expr_lookahead;\n    }\n\n    TRACE (printf (\"unrecognised operator \\\"%s\\\" type: 0x%X\",\n\t\t   CP->op->name, CP->op->type));\n    ERROR (\"\", MPEXPR_RESULT_PARSE_ERROR);\n    break;\n\n  default:\n    TRACE (printf (\"expecting an operator, got token %d\", p->token));\n    ERROR (\"\", MPEXPR_RESULT_PARSE_ERROR);\n  }\n\n\n apply_control_lookahead:\n  LOOKAHEAD (0);\n apply_control:\n  /* Apply the top element CP of the control stack.  Data values are SP,\n     SP-1, etc.  Result is left as stack top SP after popping consumed\n     values.\n\n     The use of sp as a duplicate of SP will help compilers that can't\n     otherwise recognise the various uses of SP as common subexpressions.  */\n\n  TRACE (printf (\"apply control: nested %d, \\\"%s\\\" 0x%X, %d args\\n\",\n\t\t p->control_top, CP->op->name, CP->op->type, CP->argcount));\n\n  TRACE (printf (\"apply 0x%X-ary\\n\",\n\t\t CP->op->type & MPEXPR_TYPE_MASK_ARGCOUNT));\n  switch (CP->op->type & MPEXPR_TYPE_MASK_ARGCOUNT) {\n  case MPEXPR_TYPE_NARY(0):\n    {\n      mpX_ptr  sp;\n      DATA_SPACE ();\n      DATA_PUSH ();\n      sp = SP;\n      switch (CP->op->type & MPEXPR_TYPE_MASK_ARGSTYLE) {\n      case 0:\n\t(* (mpexpr_fun_0ary_t) CP->op->fun) (sp);\n\tbreak;\n      case MPEXPR_TYPE_RESULT_INT:\n\t(*p->mpX_set_si) (sp, (long) (* (mpexpr_fun_i_0ary_t) CP->op->fun) ());\n\tbreak;\n      default:\n\tERROR (\"unrecognised 0ary argument calling style\",\n\t       MPEXPR_RESULT_BAD_TABLE);\n      }\n    }\n    break;\n\n  case MPEXPR_TYPE_NARY(1):\n    {\n      mpX_ptr  sp = SP;\n      CHECK_ARGCOUNT (\"unary\", 1);\n      TRACE (MPX_TRACE (\"before\", sp));\n\n      switch (CP->op->type & MPEXPR_TYPE_MASK_SPECIAL) {\n      case 0:\n\t/* not a special */\n\tbreak;\n\n      case MPEXPR_TYPE_DONE & MPEXPR_TYPE_MASK_SPECIAL:\n\tTRACE (printf (\"special done\\n\"));\n\tgoto done;\n\n      case MPEXPR_TYPE_LOGICAL_NOT & MPEXPR_TYPE_MASK_SPECIAL:\n\tTRACE (printf (\"special logical not\\n\"));\n\t(*p->mpX_set_si)\n\t  (sp, (long) ((* (mpexpr_fun_i_unary_t) CP->op->fun) (sp) == 0));\n\tgoto apply_control_done;\n\n      case MPEXPR_TYPE_CLOSEPAREN & MPEXPR_TYPE_MASK_SPECIAL:\n\tCONTROL_POP ();\n\tif (CP->op->type == MPEXPR_TYPE_OPENPAREN)\n\t  {\n\t    TRACE (printf (\"close paren matching open paren\\n\"));\n\t    CONTROL_POP ();\n\t    goto another_operator;\n\t  }\n\tif (CP->op->precedence == 0)\n\t  {\n\t    TRACE (printf (\"close paren for function\\n\"));\n\t    goto apply_control;\n\t  }\n\tERROR (\"unexpected close paren\", MPEXPR_RESULT_PARSE_ERROR);\n\n      default:\n\tTRACE (printf (\"unrecognised special unary operator 0x%X\",\n\t\t       CP->op->type & MPEXPR_TYPE_MASK_SPECIAL));\n\tERROR (\"\", MPEXPR_RESULT_BAD_TABLE);\n      }\n\n      switch (CP->op->type & MPEXPR_TYPE_MASK_ARGSTYLE) {\n      case 0:\n\t(* (mpexpr_fun_unary_t) CP->op->fun) (sp, sp);\n\tbreak;\n      case MPEXPR_TYPE_LAST_UI:\n\tCHECK_UI (sp);\n\t(* (mpexpr_fun_unary_ui_t) CP->op->fun)\n\t  (sp, (*p->mpX_get_ui) (sp));\n\tbreak;\n      case MPEXPR_TYPE_RESULT_INT:\n\t(*p->mpX_set_si)\n\t  (sp, (long) (* (mpexpr_fun_i_unary_t) CP->op->fun) (sp));\n\tbreak;\n      case MPEXPR_TYPE_RESULT_INT | MPEXPR_TYPE_LAST_UI:\n\tCHECK_UI (sp);\n\t(*p->mpX_set_si)\n\t  (sp,\n\t   (long) (* (mpexpr_fun_i_unary_ui_t) CP->op->fun)\n\t   ((*p->mpX_get_ui) (sp)));\n\tbreak;\n      default:\n\tERROR (\"unrecognised unary argument calling style\",\n\t       MPEXPR_RESULT_BAD_TABLE);\n      }\n    }\n    break;\n\n  case MPEXPR_TYPE_NARY(2):\n    {\n      mpX_ptr  sp;\n\n      /* pairwise functions are allowed to have just one argument */\n      if ((CP->op->type & MPEXPR_TYPE_PAIRWISE)\n\t  && CP->op->precedence == 0\n\t  && CP->argcount == 1)\n\tgoto apply_control_done;\n\n      CHECK_ARGCOUNT (\"binary\", 2);\n      DATA_POP (1);\n      sp = SP;\n      TRACE (MPX_TRACE (\"lhs\", sp);\n\t     MPX_TRACE (\"rhs\", sp+1));\n\n      if (CP->op->type & MPEXPR_TYPE_MASK_CMP)\n\t{\n\t  int  type = CP->op->type;\n\t  int  cmp = (* (mpexpr_fun_i_binary_t) CP->op->fun)\n\t    (sp, sp+1);\n\t  (*p->mpX_set_si)\n\t    (sp,\n\t     (long)\n\t     ((  (cmp  < 0) & ((type & MPEXPR_TYPE_MASK_CMP_LT) != 0))\n\t      | ((cmp == 0) & ((type & MPEXPR_TYPE_MASK_CMP_EQ) != 0))\n\t      | ((cmp  > 0) & ((type & MPEXPR_TYPE_MASK_CMP_GT) != 0))));\n\t  goto apply_control_done;\n\t}\n\n      switch (CP->op->type & MPEXPR_TYPE_MASK_SPECIAL) {\n      case 0:\n\t/* not a special */\n\tbreak;\n\n      case MPEXPR_TYPE_QUESTION & MPEXPR_TYPE_MASK_SPECIAL:\n\tERROR (\"'?' without ':'\", MPEXPR_RESULT_PARSE_ERROR);\n\n      case MPEXPR_TYPE_COLON & MPEXPR_TYPE_MASK_SPECIAL:\n\tTRACE (printf (\"special colon\\n\"));\n\tCONTROL_POP ();\n\tif (CP->op->type != MPEXPR_TYPE_QUESTION)\n\t  ERROR (\"':' without '?'\", MPEXPR_RESULT_PARSE_ERROR);\n\n\tCP->argcount--;\n\tDATA_POP (1);\n\tsp--;\n\tTRACE (MPX_TRACE (\"query\", sp);\n\t       MPX_TRACE (\"true\",  sp+1);\n\t       MPX_TRACE (\"false\", sp+2));\n\t(*p->mpX_set)\n\t  (sp, (* (mpexpr_fun_i_unary_t) CP->op->fun) (sp)\n\t   ? sp+1 : sp+2);\n\tgoto apply_control_done;\n\n      case MPEXPR_TYPE_LOGICAL_AND & MPEXPR_TYPE_MASK_SPECIAL:\n\tTRACE (printf (\"special logical and\\n\"));\n\t(*p->mpX_set_si)\n\t  (sp,\n\t   (long)\n\t   ((* (mpexpr_fun_i_unary_t) CP->op->fun) (sp)\n\t    && (* (mpexpr_fun_i_unary_t) CP->op->fun) (sp+1)));\n\tgoto apply_control_done;\n\n      case MPEXPR_TYPE_LOGICAL_OR & MPEXPR_TYPE_MASK_SPECIAL:\n\tTRACE (printf (\"special logical and\\n\"));\n\t(*p->mpX_set_si)\n\t  (sp,\n\t   (long)\n\t   ((* (mpexpr_fun_i_unary_t) CP->op->fun) (sp)\n\t    || (* (mpexpr_fun_i_unary_t) CP->op->fun) (sp+1)));\n\tgoto apply_control_done;\n\n      case MPEXPR_TYPE_MAX & MPEXPR_TYPE_MASK_SPECIAL:\n\tTRACE (printf (\"special max\\n\"));\n\tif ((* (mpexpr_fun_i_binary_t) CP->op->fun) (sp, sp+1) < 0)\n\t  (*p->mpX_swap) (sp, sp+1);\n\tgoto apply_control_done;\n      case MPEXPR_TYPE_MIN & MPEXPR_TYPE_MASK_SPECIAL:\n\tTRACE (printf (\"special min\\n\"));\n\tif ((* (mpexpr_fun_i_binary_t) CP->op->fun) (sp, sp+1) > 0)\n\t  (*p->mpX_swap) (sp, sp+1);\n\tgoto apply_control_done;\n\n      default:\n\tERROR (\"unrecognised special binary operator\",\n\t       MPEXPR_RESULT_BAD_TABLE);\n      }\n\n      switch (CP->op->type & MPEXPR_TYPE_MASK_ARGSTYLE) {\n      case 0:\n\t(* (mpexpr_fun_binary_t) CP->op->fun) (sp, sp, sp+1);\n\tbreak;\n      case MPEXPR_TYPE_LAST_UI:\n\tCHECK_UI (sp+1);\n\t(* (mpexpr_fun_binary_ui_t) CP->op->fun)\n\t  (sp, sp, (*p->mpX_get_ui) (sp+1));\n\tbreak;\n      case MPEXPR_TYPE_RESULT_INT:\n\t(*p->mpX_set_si)\n\t  (sp,\n\t   (long) (* (mpexpr_fun_i_binary_t) CP->op->fun) (sp, sp+1));\n\tbreak;\n      case MPEXPR_TYPE_LAST_UI | MPEXPR_TYPE_RESULT_INT:\n\tCHECK_UI (sp+1);\n\t(*p->mpX_set_si)\n\t  (sp,\n\t   (long) (* (mpexpr_fun_i_binary_ui_t) CP->op->fun)\n\t   (sp, (*p->mpX_get_ui) (sp+1)));\n\tbreak;\n      default:\n\tERROR (\"unrecognised binary argument calling style\",\n\t       MPEXPR_RESULT_BAD_TABLE);\n      }\n    }\n    break;\n\n  case MPEXPR_TYPE_NARY(3):\n    {\n      mpX_ptr  sp;\n\n      CHECK_ARGCOUNT (\"ternary\", 3);\n      DATA_POP (2);\n      sp = SP;\n      TRACE (MPX_TRACE (\"arg1\", sp);\n\t     MPX_TRACE (\"arg2\", sp+1);\n\t     MPX_TRACE (\"arg3\", sp+1));\n\n      switch (CP->op->type & MPEXPR_TYPE_MASK_ARGSTYLE) {\n      case 0:\n\t(* (mpexpr_fun_ternary_t) CP->op->fun) (sp, sp, sp+1, sp+2);\n\tbreak;\n      case MPEXPR_TYPE_LAST_UI:\n\tCHECK_UI (sp+2);\n\t(* (mpexpr_fun_ternary_ui_t) CP->op->fun)\n\t  (sp, sp, sp+1, (*p->mpX_get_ui) (sp+2));\n\tbreak;\n      case MPEXPR_TYPE_RESULT_INT:\n\t(*p->mpX_set_si)\n\t  (sp,\n\t   (long) (* (mpexpr_fun_i_ternary_t) CP->op->fun)\n\t   (sp, sp+1, sp+2));\n\tbreak;\n      case MPEXPR_TYPE_LAST_UI | MPEXPR_TYPE_RESULT_INT:\n\tCHECK_UI (sp+2);\n\t(*p->mpX_set_si)\n\t  (sp,\n\t   (long) (* (mpexpr_fun_i_ternary_ui_t) CP->op->fun)\n\t   (sp, sp+1, (*p->mpX_get_ui) (sp+2)));\n\tbreak;\n      default:\n\tERROR (\"unrecognised binary argument calling style\",\n\t       MPEXPR_RESULT_BAD_TABLE);\n      }\n    }\n    break;\n\n  default:\n    TRACE (printf (\"unrecognised operator type: 0x%X\\n\", CP->op->type));\n    ERROR (\"\", MPEXPR_RESULT_PARSE_ERROR);\n  }\n\n apply_control_done:\n  TRACE (MPX_TRACE (\"result\", SP));\n  CONTROL_POP ();\n  goto another_operator;\n\n done:\n  if (p->error_code == MPEXPR_RESULT_OK)\n    {\n      if (p->data_top != 0)\n\t{\n\t  TRACE (printf (\"data stack want top at 0, got %d\\n\", p->data_top));\n\t  p->error_code = MPEXPR_RESULT_PARSE_ERROR;\n\t}\n      else\n\t(*p->mpX_set_or_swap) (p->res, SP);\n    }\n\n  {\n    int  i;\n    for (i = 0; i < p->data_inited; i++)\n      {\n\tTRACE (printf (\"clear %d\\n\", i));\n\t(*p->mpX_clear) (p->data_stack+i);\n      }\n  }\n\n  FREE_FUNC_TYPE (p->data_stack, p->data_alloc, union mpX_t);\n  FREE_FUNC_TYPE (p->control_stack, p->control_alloc, struct mpexpr_control_t);\n\n  return p->error_code;\n}",
      "lines": 465,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/expr/expr.h": {},
  "gmp/gmp-6.1.2/demos/expr/exprf.c": {
    "e_mpf_sgn": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static int\ne_mpf_sgn (mpf_srcptr x)\n{\n  return mpf_sgn (x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpf_expr": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "int\nmpf_expr (mpf_ptr res, int base, const char *e, ...)\n{\n  mpf_srcptr  var[MPEXPR_VARIABLES];\n  va_list     ap;\n  int         ret;\n  va_start (ap, e);\n\n  TRACE (printf (\"mpf_expr(): base %d, %s\\n\", base, e));\n  ret = mpexpr_va_to_var ((void **) var, ap);\n  va_end (ap);\n\n  if (ret != MPEXPR_RESULT_OK)\n    return ret;\n\n  return mpf_expr_a (mpf_expr_standard_table, res, base,\n\t\t     mpf_get_prec (res), e, strlen(e), var);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/expr/exprfa.c": {
    "e_mpf_number": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static size_t\ne_mpf_number (mpf_ptr res, const char *e, size_t elen, int base)\n{\n  char    *edup;\n  size_t  i, ret, extra=0;\n  int     mant_base, exp_base;\n  void    *(*allocate_func) (size_t);\n  void    (*free_func) (void *, size_t);\n\n  TRACE (printf (\"mpf_number base=%d \\\"%.*s\\\"\\n\", base, (int) elen, e));\n\n  /* mpf_set_str doesn't currently accept 0x for hex in base==0, so do it\n     here instead.  FIXME: Would prefer to let mpf_set_str handle this.  */\n  if (base == 0 && elen >= 2 && e[0] == '0' && (e[1] == 'x' || e[1] == 'X'))\n    {\n      base = 16;\n      extra = 2;\n      e += extra;\n      elen -= extra;\n    }\n\n  if (base == 0)\n    mant_base = 10;\n  else if (base < 0)\n    mant_base = -base;\n  else\n    mant_base = base;\n\n  /* exponent in decimal if base is negative */\n  if (base < 0)\n    exp_base = 10;\n  else if (base == 0)\n    exp_base = 10;\n  else\n    exp_base = base;\n\n#define IS_EXPONENT(c) \\\n  (c == '@' || (base <= 10 && base >= -10 && (e[i] == 'e' || e[i] == 'E')))\n\n  i = 0;\n  for (;;)\n    {\n      if (i >= elen)\n        goto parsed;\n      if (e[i] == '.')\n        break;\n      if (IS_EXPONENT (e[i]))\n        goto exponent;\n      if (! isasciidigit_in_base (e[i], mant_base))\n        goto parsed;\n      i++;\n    }\n\n  /* fraction */\n  i++;\n  for (;;)\n    {\n      if (i >= elen)\n        goto parsed;\n      if (IS_EXPONENT (e[i]))\n        goto exponent;\n      if (! isasciidigit_in_base (e[i], mant_base))\n        goto parsed;\n      i++;\n    }\n\n exponent:\n  i++;\n  if (i >= elen)\n    goto parsed;\n  if (e[i] == '-')\n    i++;\n  for (;;)\n    {\n      if (i >= elen)\n        goto parsed;\n      if (! isasciidigit_in_base (e[i], exp_base))\n        break;\n      i++;\n    }\n\n parsed:\n  TRACE (printf (\"  parsed i=%u \\\"%.*s\\\"\\n\", i, (int) i, e));\n\n  mp_get_memory_functions (&allocate_func, NULL, &free_func);\n  edup = (*allocate_func) (i+1);\n  memcpy (edup, e, i);\n  edup[i] = '\\0';\n\n  if (mpf_set_str (res, edup, base) == 0)\n    ret = i + extra;\n  else\n    ret = 0;\n\n  (*free_func) (edup, i+1);\n  return ret;\n}",
      "lines": 97,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "e_mpf_ulong_p": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static int\ne_mpf_ulong_p (mpf_srcptr f)\n{\n  return mpf_integer_p (f) && mpf_fits_ulong_p (f);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "e_mpf_set_or_swap": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static void\ne_mpf_set_or_swap (mpf_ptr w, mpf_ptr x)\n{\n  if (mpf_get_prec (w) == mpf_get_prec (x))\n    mpf_swap (w, x);\n  else\n    mpf_set (w, x);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpf_expr_a": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nmpf_expr_a (const struct mpexpr_operator_t *table,\n            mpf_ptr res, int base, unsigned long prec,\n            const char *e, size_t elen,\n            mpf_srcptr var[26])\n{\n  struct mpexpr_parse_t  p;\n\n  p.table = table;\n  p.res = (mpX_ptr) res;\n  p.base = base;\n  p.prec = prec;\n  p.e = e;\n  p.elen = elen;\n  p.var = (mpX_srcptr *) var;\n\n  p.mpX_clear       = (mpexpr_fun_one_t)      mpf_clear;\n  p.mpX_ulong_p     = (mpexpr_fun_i_unary_t)  e_mpf_ulong_p;\n  p.mpX_get_ui      = (mpexpr_fun_get_ui_t)   mpf_get_ui;\n  p.mpX_init        = (mpexpr_fun_unary_ui_t) mpf_init2;\n  p.mpX_number      = (mpexpr_fun_number_t)   e_mpf_number;\n  p.mpX_set         = (mpexpr_fun_unary_t)    mpf_set;\n  p.mpX_set_or_swap = (mpexpr_fun_unary_t)    e_mpf_set_or_swap;\n  p.mpX_set_si      = (mpexpr_fun_set_si_t)   mpf_set_si;\n  p.mpX_swap        = (mpexpr_fun_swap_t)     mpf_swap;\n\n  return mpexpr_evaluate (&p);\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/expr/exprq.c": {
    "e_mpq_pow_ui": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static void\ne_mpq_pow_ui (mpq_ptr r, mpq_srcptr b, unsigned long e)\n{\n  mpz_pow_ui (mpq_numref(r), mpq_numref(b), e);\n  mpz_pow_ui (mpq_denref(r), mpq_denref(b), e);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "e_mpq_sgn": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\ne_mpq_sgn (mpq_srcptr x)\n{\n  return mpq_sgn (x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "e_mpq_equal": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static int\ne_mpq_equal (mpq_srcptr x, mpq_srcptr y)\n{\n  return mpq_equal (x, y) != 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "e_mpq_notequal": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\ne_mpq_notequal (mpq_srcptr x, mpq_srcptr y)\n{\n  return ! mpq_equal (x, y);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "e_mpq_num": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static void\ne_mpq_num (mpq_ptr w, mpq_srcptr x)\n{\n  if (w != x)\n    mpz_set (mpq_numref(w), mpq_numref(x));\n  mpz_set_ui (mpq_denref(w), 1L);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "e_mpq_den": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static void\ne_mpq_den (mpq_ptr w, mpq_srcptr x)\n{\n  if (w == x)\n    mpz_swap (mpq_numref(w), mpq_denref(w));\n  else\n    mpz_set (mpq_numref(w), mpq_denref(x));\n  mpz_set_ui (mpq_denref(w), 1L);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpq_expr": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "int\nmpq_expr (mpq_ptr res, int base, const char *e, ...)\n{\n  mpq_srcptr  var[MPEXPR_VARIABLES];\n  va_list     ap;\n  int         ret;\n  va_start (ap, e);\n\n  TRACE (printf (\"mpq_expr(): base %d, %s\\n\", base, e));\n  ret = mpexpr_va_to_var ((void **) var, ap);\n  va_end (ap);\n\n  if (ret != MPEXPR_RESULT_OK)\n    return ret;\n\n  return mpq_expr_a (mpq_expr_standard_table, res, base, e, strlen(e), var);\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/expr/exprqa.c": {
    "e_mpq_ulong_p": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\ne_mpq_ulong_p (mpq_srcptr q)\n{\n  return mpz_fits_ulong_p (mpq_numref (q))\n    && mpz_cmp_ui (mpq_denref (q), 1L) == 0;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "e_mpq_get_ui_fits": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\ne_mpq_get_ui_fits (mpq_srcptr q)\n{\n  return mpz_get_ui (mpq_numref (q));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "e_mpq_set_si1": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ne_mpq_set_si1 (mpq_ptr q, long num)\n{\n  mpq_set_si (q, num, 1L);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "e_mpq_number": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static size_t\ne_mpq_number (mpq_ptr res, const char *e, size_t elen, int base)\n{\n  mpz_set_ui (mpq_denref (res), 1L);\n  return mpexpr_mpz_number (mpq_numref (res), e, elen, base);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "e_mpq_init": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\ne_mpq_init (mpq_ptr q, unsigned long prec)\n{\n  mpq_init (q);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpq_expr_a": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int\nmpq_expr_a (const struct mpexpr_operator_t *table,\n            mpq_ptr res, int base,\n            const char *e, size_t elen,\n            mpq_srcptr var[26])\n{\n  struct mpexpr_parse_t  p;\n\n  p.table = table;\n  p.res = (mpX_ptr) res;\n  p.base = base;\n  p.e = e;\n  p.elen = elen;\n  p.var = (mpX_srcptr *) var;\n\n  p.mpX_clear       = (mpexpr_fun_one_t)      mpq_clear;\n  p.mpX_ulong_p     = (mpexpr_fun_i_unary_t)  e_mpq_ulong_p;\n  p.mpX_get_ui      = (mpexpr_fun_get_ui_t)   e_mpq_get_ui_fits;\n  p.mpX_init        = (mpexpr_fun_unary_ui_t) e_mpq_init;\n  p.mpX_number      = (mpexpr_fun_number_t)   e_mpq_number;\n  p.mpX_set         = (mpexpr_fun_unary_t)    mpq_set;\n  p.mpX_set_or_swap = (mpexpr_fun_unary_t)    mpq_swap;\n  p.mpX_set_si      = (mpexpr_fun_set_si_t)   e_mpq_set_si1;\n  p.mpX_swap        = (mpexpr_fun_swap_t)     mpq_swap;\n\n  return mpexpr_evaluate (&p);\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/expr/exprv.c": {
    "mpexpr_va_to_var": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\nmpexpr_va_to_var (void *var[], va_list ap)\n{\n  int   i = 0;\n  void  *v;\n\n  for (;;)\n    {\n      v = va_arg (ap, void *);\n      if (v == NULL)\n\tbreak;\n      if (i >= MPEXPR_VARIABLES)\n\treturn MPEXPR_RESULT_BAD_VARIABLE;\n      var[i++] = v;\n    }\n\n  while (i < MPEXPR_VARIABLES)\n    var[i++] = NULL;\n\n  return MPEXPR_RESULT_OK;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/expr/exprz.c": {
    "e_mpz_sgn": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static int\ne_mpz_sgn (mpz_srcptr x)\n{\n  return mpz_sgn (x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "e_mpz_odd_p": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static int\ne_mpz_odd_p (mpz_srcptr x)\n{\n  return mpz_odd_p (x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "e_mpz_even_p": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\ne_mpz_even_p (mpz_srcptr x)\n{\n  return mpz_even_p (x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "e_mpz_hamdist": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static void\ne_mpz_hamdist (mpz_ptr w, mpz_srcptr x, mpz_srcptr y)\n{\n  mpz_set_ui (w, mpz_hamdist (x, y));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "e_mpz_popcount": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static void\ne_mpz_popcount (mpz_ptr w, mpz_srcptr x)\n{\n  mpz_set_ui (w, mpz_popcount (x));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "e_mpz_scan0": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static void\ne_mpz_scan0 (mpz_ptr w, mpz_srcptr x, unsigned long start)\n{\n  mpz_set_ui (w, mpz_scan0 (x, start));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "e_mpz_scan1": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\ne_mpz_scan1 (mpz_ptr w, mpz_srcptr x, unsigned long start)\n{\n  mpz_set_ui (w, mpz_scan1 (x, start));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "e_mpz_setbit": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static void\ne_mpz_setbit (mpz_ptr w, mpz_srcptr x, unsigned long n)\n{\n  if (w != x)\n    mpz_set (w, x);\n  mpz_setbit (w, n);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "e_mpz_clrbit": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static void\ne_mpz_clrbit (mpz_ptr w, mpz_srcptr x, unsigned long n)\n{\n  if (w != x)\n    mpz_set (w, x);\n  mpz_clrbit (w, n);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_expr": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "int\nmpz_expr (mpz_ptr res, int base, const char *e, ...)\n{\n  mpz_srcptr  var[MPEXPR_VARIABLES];\n  va_list     ap;\n  int         ret;\n  va_start (ap, e);\n\n  TRACE (printf (\"mpz_expr(): base %d, %s\\n\", base, e));\n  ret = mpexpr_va_to_var ((void **) var, ap);\n  va_end (ap);\n\n  if (ret != MPEXPR_RESULT_OK)\n    return ret;\n\n  return mpz_expr_a (mpz_expr_standard_table, res, base, e, strlen(e), var);\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/expr/exprza.c": {
    "mpexpr_mpz_number": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "size_t\nmpexpr_mpz_number (mpz_ptr res, const char *e, size_t elen, int base)\n{\n  char    *edup;\n  size_t  i, ret;\n  int     base_effective = (base == 0 ? 10 : base);\n  void    *(*allocate_func) (size_t);\n  void    (*free_func) (void *, size_t);\n\n  i = 0;\n  if (e[i] == '0')\n    {\n      i++;\n      if (e[i] == 'x' || e[i] == 'b')\n        i++;\n    }\n\n  for ( ; i < elen; i++)\n    if (! isasciidigit_in_base (e[i], base_effective))\n      break;\n\n  mp_get_memory_functions (&allocate_func, NULL, &free_func);\n  edup = (*allocate_func) (i+1);\n  memcpy (edup, e, i);\n  edup[i] = '\\0';\n\n  if (mpz_set_str (res, edup, base) == 0)\n    ret = i;\n  else\n    ret = 0;\n\n  (*free_func) (edup, i+1);\n  return ret;\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    },
    "e_mpz_init": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\ne_mpz_init (mpz_ptr z, unsigned long prec)\n{\n  mpz_init (z);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_expr_a": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\nmpz_expr_a (const struct mpexpr_operator_t *table,\n            mpz_ptr res, int base,\n            const char *e, size_t elen,\n            mpz_srcptr var[26])\n{\n  struct mpexpr_parse_t  p;\n\n  p.table = table;\n  p.res = (mpX_ptr) res;\n  p.base = base;\n  p.e = e;\n  p.elen = elen;\n  p.var = (mpX_srcptr *) var;\n\n  p.mpX_clear       = (mpexpr_fun_one_t)      mpz_clear;\n  p.mpX_ulong_p     = (mpexpr_fun_i_unary_t)  mpz_fits_ulong_p;\n  p.mpX_get_ui      = (mpexpr_fun_get_ui_t)   mpz_get_ui;\n  p.mpX_init        = (mpexpr_fun_unary_ui_t) e_mpz_init;\n  p.mpX_number      = (mpexpr_fun_number_t)   mpexpr_mpz_number;\n  p.mpX_set         = (mpexpr_fun_unary_t)    mpz_set;\n  p.mpX_set_or_swap = (mpexpr_fun_unary_t)    mpz_swap;\n  p.mpX_set_si      = (mpexpr_fun_set_si_t)   mpz_set_si;\n  p.mpX_swap        = (mpexpr_fun_swap_t)     mpz_swap;\n\n  return mpexpr_evaluate (&p);\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/expr/run-expr.c": {
    "run_expr": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\nrun_expr (int type, int base, unsigned long prec, char *str)\n{\n  int  outbase = (base == 0 ? 10 : base);\n  int  ret;\n\n  switch (type) {\n  case 'z':\n  default:\n    {\n      mpz_t  res, var_a, var_b;\n\n      mpz_init (res);\n      mpz_init_set_ui (var_a, 55L);\n      mpz_init_set_ui (var_b, 99L);\n\n      ret = mpz_expr (res, base, str, var_a, var_b, NULL);\n      printf (\"\\\"%s\\\" base %d: \", str, base);\n      if (ret == MPEXPR_RESULT_OK)\n        {\n          printf (\"result \");\n          mpz_out_str (stdout, outbase, res);\n          printf (\"\\n\");\n        }\n      else\n        printf (\"invalid (return code %d)\\n\", ret);\n\n      mpz_clear (res);\n      mpz_clear (var_a);\n      mpz_clear (var_b);\n    }\n    break;\n\n  case 'q':\n    {\n      mpq_t  res, var_a, var_b;\n\n      mpq_init (res);\n      mpq_init (var_a);\n      mpq_init (var_b);\n\n      mpq_set_ui (var_a, 55L, 1);\n      mpq_set_ui (var_b, 99L, 1);\n\n      ret = mpq_expr (res, base, str, var_a, var_b, NULL);\n      printf (\"\\\"%s\\\" base %d: \", str, base);\n      if (ret == MPEXPR_RESULT_OK)\n        {\n          printf (\"result \");\n          mpq_out_str (stdout, outbase, res);\n          printf (\"\\n\");\n        }\n      else\n        printf (\"invalid (return code %d)\\n\", ret);\n\n      mpq_clear (res);\n      mpq_clear (var_a);\n      mpq_clear (var_b);\n    }\n    break;\n\n  case 'f':\n    {\n      mpf_t  res, var_a, var_b;\n\n      mpf_init2 (res, prec);\n      mpf_init_set_ui (var_a, 55L);\n      mpf_init_set_ui (var_b, 99L);\n\n      ret = mpf_expr (res, base, str, var_a, var_b, NULL);\n      printf (\"\\\"%s\\\" base %d: \", str, base);\n      if (ret == MPEXPR_RESULT_OK)\n        {\n          printf (\"result \");\n          mpf_out_str (stdout, outbase, (size_t) 0, res);\n          printf (\"\\n\");\n        }\n      else\n        printf (\"invalid (return code %d)\\n\", ret);\n\n      mpf_clear (res);\n      mpf_clear (var_a);\n      mpf_clear (var_b);\n    }\n    break;\n  }\n}",
      "lines": 87,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int            type = 'z';\n  int            base = 0;\n  unsigned long  prec = 64;\n  int            seen_expr = 0;\n  int            opt;\n  char           *arg;\n\n  for (;;)\n    {\n      argv++;\n      arg = argv[0];\n      if (arg == NULL)\n        break;\n\n      if (arg[0] == '-')\n        {\n          for (;;)\n            {\n              arg++;\n              opt = arg[0];\n\n              switch (opt) {\n              case '\\0':\n                goto end_opt;\n\n              case 'f':\n              case 'q':\n              case 'z':\n                type = opt;\n                break;\n\n              case 'b':\n                arg++;\n                if (arg[0] == '\\0')\n                  {\n                    argv++;\n                    arg = argv[0];\n                    if (arg == NULL)\n                      {\n                      need_arg:\n                        fprintf (stderr, \"Need argument for -%c\\n\", opt);\n                        exit (1);\n                      }\n                  }\n                base = atoi (arg);\n                goto end_opt;\n\n              case 'p':\n                arg++;\n                if (arg[0] == '\\0')\n                  {\n                    argv++;\n                    arg = argv[0];\n                    if (arg == NULL)\n                      goto need_arg;\n                  }\n                prec = atoi (arg);\n                goto end_opt;\n\n              case '-':\n                arg++;\n                if (arg[0] != '\\0')\n                  {\n                    /* no \"--foo\" options */\n                    fprintf (stderr, \"Unrecognised option --%s\\n\", arg);\n                    exit (1);\n                  }\n                /* stop option interpretation at \"--\" */\n                for (;;)\n                  {\n                    argv++;\n                    arg = argv[0];\n                    if (arg == NULL)\n                      goto done;\n                    run_expr (type, base, prec, arg);\n                    seen_expr = 1;\n                  }\n\n              default:\n                fprintf (stderr, \"Unrecognised option -%c\\n\", opt);\n                exit (1);\n              }\n            }\n        end_opt:\n          ;\n        }\n      else\n        {\n          run_expr (type, base, prec, arg);\n          seen_expr = 1;\n        }\n    }\n\n done:\n  if (! seen_expr)\n    {\n      printf (\"Usage: %s [-z] [-q] [-f] [-p prec] [-b base] expression...\\n\", argv[0]);\n      exit (1);\n    }\n\n  return 0;\n}",
      "lines": 105,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/demos/expr/t-expr.c": {
    "check_z": {
      "start_point": [
        273,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "void\ncheck_z (void)\n{\n  const struct data_t  *data;\n  mpz_t  a, b, got, want;\n  int    l, i, ret;\n\n  mpz_init (got);\n  mpz_init (want);\n  mpz_init_set_ui (a, 55);\n  mpz_init_set_ui (b, 99);\n\n  for (l = 0; l < numberof (list_z); l++)\n    {\n      data = list_z[l].data;\n\n      for (i = 0; i < list_z[l].num; i++)\n        {\n          if (option_trace)\n            printf (\"mpz_expr \\\"%s\\\"\\n\", data[i].expr);\n\n          ret = mpz_expr (got, data[i].base, data[i].expr, a, b, NULL);\n\n          if (data[i].want == NULL)\n            {\n              /* expect to fail */\n              if (ret == MPEXPR_RESULT_OK)\n                {\n                  printf (\"mpz_expr wrong return value, got %d, expected failure\\n\", ret);\n                  goto error;\n                }\n            }\n          else\n            {\n              if (mpz_set_str (want, data[i].want, 0) != 0)\n                {\n                  printf (\"Cannot parse wanted value string\\n\");\n                  goto error;\n                }\n              if (ret != MPEXPR_RESULT_OK)\n                {\n                  printf (\"mpz_expr failed unexpectedly\\n\");\n                  printf (\"   return value %d\\n\", ret);\n                  goto error;\n                }\n              if (mpz_cmp (got, want) != 0)\n                {\n                  printf (\"mpz_expr wrong result\\n\");\n                  printf (\"   got  \"); mpz_out_str (stdout, 10, got);\n                  printf (\"\\n\");\n                  printf (\"   want \"); mpz_out_str (stdout, 10, want);\n                  printf (\"\\n\");\n                  goto error;\n                }\n            }\n        }\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (got);\n  mpz_clear (want);\n  return;\n\n error:\n  printf (\"   base %d\\n\", data[i].base);\n  printf (\"   expr \\\"%s\\\"\\n\", data[i].expr);\n  if (data[i].want != NULL)\n    printf (\"   want \\\"%s\\\"\\n\", data[i].want);\n  abort ();\n}",
      "lines": 70,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "check_q": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "void\ncheck_q (void)\n{\n  const struct data_t  *data;\n  mpq_t  a, b, got, want;\n  int    l, i, ret;\n\n  mpq_init (got);\n  mpq_init (want);\n  mpq_init (a);\n  mpq_init (b);\n\n  mpq_set_ui (a, 55, 1);\n  mpq_set_ui (b, 99, 1);\n\n  for (l = 0; l < numberof (list_q); l++)\n    {\n      data = list_q[l].data;\n\n      for (i = 0; i < list_q[l].num; i++)\n        {\n          if (option_trace)\n            printf (\"mpq_expr \\\"%s\\\"\\n\", data[i].expr);\n\n          ret = mpq_expr (got, data[i].base, data[i].expr, a, b, NULL);\n\n          if (data[i].want == NULL)\n            {\n              /* expect to fail */\n              if (ret == MPEXPR_RESULT_OK)\n                {\n                  printf (\"mpq_expr wrong return value, got %d, expected failure\\n\", ret);\n                  goto error;\n                }\n            }\n          else\n            {\n              if (mpz_set_str (mpq_numref(want), data[i].want, 0) != 0)\n                {\n                  printf (\"Cannot parse wanted value string\\n\");\n                  goto error;\n                }\n              mpz_set_ui (mpq_denref(want), 1);\n\n              if (ret != MPEXPR_RESULT_OK)\n                {\n                  printf (\"mpq_expr failed unexpectedly\\n\");\n                  printf (\"   return value %d\\n\", ret);\n                  goto error;\n                }\n              if (mpq_cmp (got, want) != 0)\n                {\n                  printf (\"mpq_expr wrong result\\n\");\n                  printf (\"   got  \"); mpq_out_str (stdout, 10, got);\n                  printf (\"\\n\");\n                  printf (\"   want \"); mpq_out_str (stdout, 10, want);\n                  printf (\"\\n\");\n                  goto error;\n                }\n            }\n        }\n    }\n  mpq_clear (a);\n  mpq_clear (b);\n  mpq_clear (got);\n  mpq_clear (want);\n  return;\n\n error:\n  printf (\"   base %d\\n\", data[i].base);\n  printf (\"   expr \\\"%s\\\"\\n\", data[i].expr);\n  if (data[i].want != NULL)\n    printf (\"   want \\\"%s\\\"\\n\", data[i].want);\n  abort ();\n}",
      "lines": 75,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "check_f": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        492,
        1
      ],
      "content": "void\ncheck_f (void)\n{\n  const struct data_t  *data;\n  mpf_t  a, b, got, want;\n  int    l, i, ret;\n\n  mpf_set_default_prec (200L);\n\n  mpf_init (got);\n  mpf_init (want);\n  mpf_init_set_ui (a, 55);\n  mpf_init_set_ui (b, 99);\n\n  for (l = 0; l < numberof (list_f); l++)\n    {\n      data = list_f[l].data;\n\n      for (i = 0; i < list_f[l].num; i++)\n        {\n          if (option_trace)\n            printf (\"mpf_expr \\\"%s\\\"\\n\", data[i].expr);\n\n          ret = mpf_expr (got, data[i].base, data[i].expr, a, b, NULL);\n\n          if (data[i].want == NULL)\n            {\n              /* expect to fail */\n              if (ret == MPEXPR_RESULT_OK)\n                {\n                  printf (\"mpf_expr wrong return value, got %d, expected failure\\n\", ret);\n                  goto error;\n                }\n            }\n          else\n            {\n              if (mpf_set_str (want, data[i].want, 0) != 0)\n                {\n                  printf (\"Cannot parse wanted value string\\n\");\n                  goto error;\n                }\n\n              if (ret != MPEXPR_RESULT_OK)\n                {\n                  printf (\"mpf_expr failed unexpectedly\\n\");\n                  printf (\"   return value %d\\n\", ret);\n                  goto error;\n                }\n              if (mpf_cmp (got, want) != 0)\n                {\n                  printf (\"mpf_expr wrong result\\n\");\n                  printf (\"   got  \"); mpf_out_str (stdout, 10, 20, got);\n                  printf (\"\\n\");\n                  printf (\"   want \"); mpf_out_str (stdout, 10, 20, want);\n                  printf (\"\\n\");\n                  goto error;\n                }\n            }\n        }\n    }\n  mpf_clear (a);\n  mpf_clear (b);\n  mpf_clear (got);\n  mpf_clear (want);\n  return;\n\n error:\n  printf (\"   base %d\\n\", data[i].base);\n  printf (\"   expr \\\"%s\\\"\\n\", data[i].expr);\n  if (data[i].want != NULL)\n    printf (\"   want \\\"%s\\\"\\n\", data[i].want);\n  abort ();\n}",
      "lines": 73,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        509,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  if (argc >= 2)\n    option_trace = 1;\n\n  check_z ();\n  check_q ();\n  check_f ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/mini-gmp.c": {
    "gmp_die": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static void\ngmp_die (const char *msg)\n{\n  fprintf (stderr, \"%s\\n\", msg);\n  abort();\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gmp_default_alloc": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void *\ngmp_default_alloc (size_t size)\n{\n  void *p;\n\n  assert (size > 0);\n\n  p = malloc (size);\n  if (!p)\n    gmp_die(\"gmp_default_alloc: Virtual memory exhausted.\");\n\n  return p;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ngmp_default_alloc (size_t size)",
        "*"
      ]
    },
    "gmp_default_realloc": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "static void *\ngmp_default_realloc (void *old, size_t old_size, size_t new_size)\n{\n  void * p;\n\n  p = realloc (old, new_size);\n\n  if (!p)\n    gmp_die(\"gmp_default_realloc: Virtual memory exhausted.\");\n\n  return p;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ngmp_default_realloc (void *old, size_t old_size, size_t new_size)",
        "*"
      ]
    },
    "gmp_default_free": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static void\ngmp_default_free (void *p, size_t size)\n{\n  free (p);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mp_get_memory_functions": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "void\nmp_get_memory_functions (void *(**alloc_func) (size_t),\n\t\t\t void *(**realloc_func) (void *, size_t, size_t),\n\t\t\t void (**free_func) (void *, size_t))\n{\n  if (alloc_func)\n    *alloc_func = gmp_allocate_func;\n\n  if (realloc_func)\n    *realloc_func = gmp_reallocate_func;\n\n  if (free_func)\n    *free_func = gmp_free_func;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mp_set_memory_functions": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "void\nmp_set_memory_functions (void *(*alloc_func) (size_t),\n\t\t\t void *(*realloc_func) (void *, size_t, size_t),\n\t\t\t void (*free_func) (void *, size_t))\n{\n  if (!alloc_func)\n    alloc_func = gmp_default_alloc;\n  if (!realloc_func)\n    realloc_func = gmp_default_realloc;\n  if (!free_func)\n    free_func = gmp_default_free;\n\n  gmp_allocate_func = alloc_func;\n  gmp_reallocate_func = realloc_func;\n  gmp_free_func = free_func;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "gmp_xalloc_limbs": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "static mp_ptr\ngmp_xalloc_limbs (mp_size_t size)\n{\n  return (mp_ptr) gmp_xalloc (size * sizeof (mp_limb_t));\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_ptr"
      ]
    },
    "gmp_xrealloc_limbs": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static mp_ptr\ngmp_xrealloc_limbs (mp_ptr old, mp_size_t size)\n{\n  assert (size > 0);\n  return (mp_ptr) (*gmp_reallocate_func) (old, 0, size * sizeof (mp_limb_t));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_ptr"
      ]
    },
    "mpn_copyi": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "void\nmpn_copyi (mp_ptr d, mp_srcptr s, mp_size_t n)\n{\n  mp_size_t i;\n  for (i = 0; i < n; i++)\n    d[i] = s[i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpn_copyd": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "void\nmpn_copyd (mp_ptr d, mp_srcptr s, mp_size_t n)\n{\n  while (--n >= 0)\n    d[n] = s[n];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpn_cmp": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "int\nmpn_cmp (mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  while (--n >= 0)\n    {\n      if (ap[n] != bp[n])\n\treturn ap[n] > bp[n] ? 1 : -1;\n    }\n  return 0;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpn_cmp4": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "static int\nmpn_cmp4 (mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)\n{\n  if (an != bn)\n    return an < bn ? -1 : 1;\n  else\n    return mpn_cmp (ap, bp, an);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpn_normalized_size": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static mp_size_t\nmpn_normalized_size (mp_srcptr xp, mp_size_t n)\n{\n  while (n > 0 && xp[n-1] == 0)\n    --n;\n  return n;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_zero_p": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "int\nmpn_zero_p(mp_srcptr rp, mp_size_t n)\n{\n  return mpn_normalized_size (rp, n) == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mpn_zero": {
      "start_point": [
        388,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "void\nmpn_zero (mp_ptr rp, mp_size_t n)\n{\n  while (--n >= 0)\n    rp[n] = 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpn_add_1": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "mp_limb_t\nmpn_add_1 (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b)\n{\n  mp_size_t i;\n\n  assert (n > 0);\n  i = 0;\n  do\n    {\n      mp_limb_t r = ap[i] + b;\n      /* Carry out */\n      b = (r < b);\n      rp[i] = r;\n    }\n  while (++i < n);\n\n  return b;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_add_n": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "mp_limb_t\nmpn_add_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  mp_size_t i;\n  mp_limb_t cy;\n\n  for (i = 0, cy = 0; i < n; i++)\n    {\n      mp_limb_t a, b, r;\n      a = ap[i]; b = bp[i];\n      r = a + cy;\n      cy = (r < cy);\n      r += b;\n      cy += (r < b);\n      rp[i] = r;\n    }\n  return cy;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_add": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "mp_limb_t\nmpn_add (mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)\n{\n  mp_limb_t cy;\n\n  assert (an >= bn);\n\n  cy = mpn_add_n (rp, ap, bp, bn);\n  if (an > bn)\n    cy = mpn_add_1 (rp + bn, ap + bn, an - bn, cy);\n  return cy;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_sub_1": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "mp_limb_t\nmpn_sub_1 (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b)\n{\n  mp_size_t i;\n\n  assert (n > 0);\n\n  i = 0;\n  do\n    {\n      mp_limb_t a = ap[i];\n      /* Carry out */\n      mp_limb_t cy = a < b;\n      rp[i] = a - b;\n      b = cy;\n    }\n  while (++i < n);\n\n  return b;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_sub_n": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "mp_limb_t\nmpn_sub_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  mp_size_t i;\n  mp_limb_t cy;\n\n  for (i = 0, cy = 0; i < n; i++)\n    {\n      mp_limb_t a, b;\n      a = ap[i]; b = bp[i];\n      b += cy;\n      cy = (b < cy);\n      cy += (a < b);\n      rp[i] = a - b;\n    }\n  return cy;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_sub": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        496,
        1
      ],
      "content": "mp_limb_t\nmpn_sub (mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)\n{\n  mp_limb_t cy;\n\n  assert (an >= bn);\n\n  cy = mpn_sub_n (rp, ap, bp, bn);\n  if (an > bn)\n    cy = mpn_sub_1 (rp + bn, ap + bn, an - bn, cy);\n  return cy;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mul_1": {
      "start_point": [
        498,
        0
      ],
      "end_point": [
        519,
        1
      ],
      "content": "mp_limb_t\nmpn_mul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl;\n\n  assert (n >= 1);\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      gmp_umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_addmul_1": {
      "start_point": [
        521,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "mp_limb_t\nmpn_addmul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl, rl;\n\n  assert (n >= 1);\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      gmp_umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      rl = *rp;\n      lpl = rl + lpl;\n      cl += lpl < rl;\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_submul_1": {
      "start_point": [
        547,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "mp_limb_t\nmpn_submul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl, rl;\n\n  assert (n >= 1);\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      gmp_umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      rl = *rp;\n      lpl = rl - lpl;\n      cl += lpl > rl;\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mul": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        594,
        1
      ],
      "content": "mp_limb_t\nmpn_mul (mp_ptr rp, mp_srcptr up, mp_size_t un, mp_srcptr vp, mp_size_t vn)\n{\n  assert (un >= vn);\n  assert (vn >= 1);\n\n  /* We first multiply by the low order limb. This result can be\n     stored, not added, to rp. We also avoid a loop for zeroing this\n     way. */\n\n  rp[un] = mpn_mul_1 (rp, up, un, vp[0]);\n\n  /* Now accumulate the product of up[] and the next higher limb from\n     vp[]. */\n\n  while (--vn >= 1)\n    {\n      rp += 1, vp += 1;\n      rp[un] = mpn_addmul_1 (rp, up, un, vp[0]);\n    }\n  return rp[un];\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mul_n": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        600,
        1
      ],
      "content": "void\nmpn_mul_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  mpn_mul (rp, ap, n, bp, n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_sqr": {
      "start_point": [
        602,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "void\nmpn_sqr (mp_ptr rp, mp_srcptr ap, mp_size_t n)\n{\n  mpn_mul (rp, ap, n, ap, n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_lshift": {
      "start_point": [
        608,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "mp_limb_t\nmpn_lshift (mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)\n{\n  mp_limb_t high_limb, low_limb;\n  unsigned int tnc;\n  mp_limb_t retval;\n\n  assert (n >= 1);\n  assert (cnt >= 1);\n  assert (cnt < GMP_LIMB_BITS);\n\n  up += n;\n  rp += n;\n\n  tnc = GMP_LIMB_BITS - cnt;\n  low_limb = *--up;\n  retval = low_limb >> tnc;\n  high_limb = (low_limb << cnt);\n\n  while (--n != 0)\n    {\n      low_limb = *--up;\n      *--rp = high_limb | (low_limb >> tnc);\n      high_limb = (low_limb << cnt);\n    }\n  *--rp = high_limb;\n\n  return retval;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_rshift": {
      "start_point": [
        638,
        0
      ],
      "end_point": [
        663,
        1
      ],
      "content": "mp_limb_t\nmpn_rshift (mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)\n{\n  mp_limb_t high_limb, low_limb;\n  unsigned int tnc;\n  mp_limb_t retval;\n\n  assert (n >= 1);\n  assert (cnt >= 1);\n  assert (cnt < GMP_LIMB_BITS);\n\n  tnc = GMP_LIMB_BITS - cnt;\n  high_limb = *up++;\n  retval = (high_limb << tnc);\n  low_limb = high_limb >> cnt;\n\n  while (--n != 0)\n    {\n      high_limb = *up++;\n      *rp++ = low_limb | (high_limb << tnc);\n      low_limb = high_limb >> cnt;\n    }\n  *rp = low_limb;\n\n  return retval;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_common_scan": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        683,
        1
      ],
      "content": "static mp_bitcnt_t\nmpn_common_scan (mp_limb_t limb, mp_size_t i, mp_srcptr up, mp_size_t un,\n\t\t mp_limb_t ux)\n{\n  unsigned cnt;\n\n  assert (ux == 0 || ux == GMP_LIMB_MAX);\n  assert (0 <= i && i <= un );\n\n  while (limb == 0)\n    {\n      i++;\n      if (i == un)\n\treturn (ux == 0 ? ~(mp_bitcnt_t) 0 : un * GMP_LIMB_BITS);\n      limb = ux ^ up[i];\n    }\n  gmp_ctz (cnt, limb);\n  return (mp_bitcnt_t) i * GMP_LIMB_BITS + cnt;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_bitcnt_t"
      ]
    },
    "mpn_scan1": {
      "start_point": [
        685,
        0
      ],
      "end_point": [
        693,
        1
      ],
      "content": "mp_bitcnt_t\nmpn_scan1 (mp_srcptr ptr, mp_bitcnt_t bit)\n{\n  mp_size_t i;\n  i = bit / GMP_LIMB_BITS;\n\n  return mpn_common_scan ( ptr[i] & (GMP_LIMB_MAX << (bit % GMP_LIMB_BITS)),\n\t\t\t  i, ptr, i, 0);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpn_scan0": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "mp_bitcnt_t\nmpn_scan0 (mp_srcptr ptr, mp_bitcnt_t bit)\n{\n  mp_size_t i;\n  i = bit / GMP_LIMB_BITS;\n\n  return mpn_common_scan (~ptr[i] & (GMP_LIMB_MAX << (bit % GMP_LIMB_BITS)),\n\t\t\t  i, ptr, i, GMP_LIMB_MAX);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpn_com": {
      "start_point": [
        705,
        0
      ],
      "end_point": [
        710,
        1
      ],
      "content": "void\nmpn_com (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  while (--n >= 0)\n    *rp++ = ~ *up++;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_neg": {
      "start_point": [
        712,
        0
      ],
      "end_point": [
        725,
        1
      ],
      "content": "mp_limb_t\nmpn_neg (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  while (*up == 0)\n    {\n      *rp = 0;\n      if (!--n)\n\treturn 0;\n      ++up; ++rp;\n    }\n  *rp = - *up;\n  mpn_com (++rp, ++up, --n);\n  return 1;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_invert_3by2": {
      "start_point": [
        734,
        0
      ],
      "end_point": [
        838,
        1
      ],
      "content": "mp_limb_t\nmpn_invert_3by2 (mp_limb_t u1, mp_limb_t u0)\n{\n  mp_limb_t r, p, m, ql;\n  unsigned ul, uh, qh;\n\n  assert (u1 >= GMP_LIMB_HIGHBIT);\n\n  /* For notation, let b denote the half-limb base, so that B = b^2.\n     Split u1 = b uh + ul. */\n  ul = u1 & GMP_LLIMB_MASK;\n  uh = u1 >> (GMP_LIMB_BITS / 2);\n\n  /* Approximation of the high half of quotient. Differs from the 2/1\n     inverse of the half limb uh, since we have already subtracted\n     u0. */\n  qh = ~u1 / uh;\n\n  /* Adjust to get a half-limb 3/2 inverse, i.e., we want\n\n     qh' = floor( (b^3 - 1) / u) - b = floor ((b^3 - b u - 1) / u\n         = floor( (b (~u) + b-1) / u),\n\n     and the remainder\n\n     r = b (~u) + b-1 - qh (b uh + ul)\n       = b (~u - qh uh) + b-1 - qh ul\n\n     Subtraction of qh ul may underflow, which implies adjustments.\n     But by normalization, 2 u >= B > qh ul, so we need to adjust by\n     at most 2.\n  */\n\n  r = ((~u1 - (mp_limb_t) qh * uh) << (GMP_LIMB_BITS / 2)) | GMP_LLIMB_MASK;\n\n  p = (mp_limb_t) qh * ul;\n  /* Adjustment steps taken from udiv_qrnnd_c */\n  if (r < p)\n    {\n      qh--;\n      r += u1;\n      if (r >= u1) /* i.e. we didn't get carry when adding to r */\n\tif (r < p)\n\t  {\n\t    qh--;\n\t    r += u1;\n\t  }\n    }\n  r -= p;\n\n  /* Low half of the quotient is\n\n       ql = floor ( (b r + b-1) / u1).\n\n     This is a 3/2 division (on half-limbs), for which qh is a\n     suitable inverse. */\n\n  p = (r >> (GMP_LIMB_BITS / 2)) * qh + r;\n  /* Unlike full-limb 3/2, we can add 1 without overflow. For this to\n     work, it is essential that ql is a full mp_limb_t. */\n  ql = (p >> (GMP_LIMB_BITS / 2)) + 1;\n\n  /* By the 3/2 trick, we don't need the high half limb. */\n  r = (r << (GMP_LIMB_BITS / 2)) + GMP_LLIMB_MASK - ql * u1;\n\n  if (r >= (p << (GMP_LIMB_BITS / 2)))\n    {\n      ql--;\n      r += u1;\n    }\n  m = ((mp_limb_t) qh << (GMP_LIMB_BITS / 2)) + ql;\n  if (r >= u1)\n    {\n      m++;\n      r -= u1;\n    }\n\n  /* Now m is the 2/1 invers of u1. If u0 > 0, adjust it to become a\n     3/2 inverse. */\n  if (u0 > 0)\n    {\n      mp_limb_t th, tl;\n      r = ~r;\n      r += u0;\n      if (r < u0)\n\t{\n\t  m--;\n\t  if (r >= u1)\n\t    {\n\t      m--;\n\t      r -= u1;\n\t    }\n\t  r -= u1;\n\t}\n      gmp_umul_ppmm (th, tl, u0, m);\n      r += th;\n      if (r < th)\n\t{\n\t  m--;\n\t  m -= ((r > u1) | ((r == u1) & (tl > u0)));\n\t}\n    }\n\n  return m;\n}",
      "lines": 105,
      "depth": 15,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_div_qr_1_invert": {
      "start_point": [
        850,
        0
      ],
      "end_point": [
        860,
        1
      ],
      "content": "static void\nmpn_div_qr_1_invert (struct gmp_div_inverse *inv, mp_limb_t d)\n{\n  unsigned shift;\n\n  assert (d > 0);\n  gmp_clz (shift, d);\n  inv->shift = shift;\n  inv->d1 = d << shift;\n  inv->di = mpn_invert_limb (inv->d1);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_2_invert": {
      "start_point": [
        862,
        0
      ],
      "end_point": [
        879,
        1
      ],
      "content": "static void\nmpn_div_qr_2_invert (struct gmp_div_inverse *inv,\n\t\t     mp_limb_t d1, mp_limb_t d0)\n{\n  unsigned shift;\n\n  assert (d1 > 0);\n  gmp_clz (shift, d1);\n  inv->shift = shift;\n  if (shift > 0)\n    {\n      d1 = (d1 << shift) | (d0 >> (GMP_LIMB_BITS - shift));\n      d0 <<= shift;\n    }\n  inv->d1 = d1;\n  inv->d0 = d0;\n  inv->di = mpn_invert_3by2 (d1, d0);\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_invert": {
      "start_point": [
        881,
        0
      ],
      "end_point": [
        910,
        1
      ],
      "content": "static void\nmpn_div_qr_invert (struct gmp_div_inverse *inv,\n\t\t   mp_srcptr dp, mp_size_t dn)\n{\n  assert (dn > 0);\n\n  if (dn == 1)\n    mpn_div_qr_1_invert (inv, dp[0]);\n  else if (dn == 2)\n    mpn_div_qr_2_invert (inv, dp[1], dp[0]);\n  else\n    {\n      unsigned shift;\n      mp_limb_t d1, d0;\n\n      d1 = dp[dn-1];\n      d0 = dp[dn-2];\n      assert (d1 > 0);\n      gmp_clz (shift, d1);\n      inv->shift = shift;\n      if (shift > 0)\n\t{\n\t  d1 = (d1 << shift) | (d0 >> (GMP_LIMB_BITS - shift));\n\t  d0 = (d0 << shift) | (dp[dn-3] >> (GMP_LIMB_BITS - shift));\n\t}\n      inv->d1 = d1;\n      inv->d0 = d0;\n      inv->di = mpn_invert_3by2 (d1, d0);\n    }\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_1_preinv": {
      "start_point": [
        914,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "static mp_limb_t\nmpn_div_qr_1_preinv (mp_ptr qp, mp_srcptr np, mp_size_t nn,\n\t\t     const struct gmp_div_inverse *inv)\n{\n  mp_limb_t d, di;\n  mp_limb_t r;\n  mp_ptr tp = NULL;\n\n  if (inv->shift > 0)\n    {\n      tp = gmp_xalloc_limbs (nn);\n      r = mpn_lshift (tp, np, nn, inv->shift);\n      np = tp;\n    }\n  else\n    r = 0;\n\n  d = inv->d1;\n  di = inv->di;\n  while (--nn >= 0)\n    {\n      mp_limb_t q;\n\n      gmp_udiv_qrnnd_preinv (q, r, r, np[nn], d, di);\n      if (qp)\n\tqp[nn] = q;\n    }\n  if (inv->shift > 0)\n    gmp_free (tp);\n\n  return r >> inv->shift;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_div_qr_1": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        975,
        1
      ],
      "content": "static mp_limb_t\nmpn_div_qr_1 (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_limb_t d)\n{\n  assert (d > 0);\n\n  /* Special case for powers of two. */\n  if ((d & (d-1)) == 0)\n    {\n      mp_limb_t r = np[0] & (d-1);\n      if (qp)\n\t{\n\t  if (d <= 1)\n\t    mpn_copyi (qp, np, nn);\n\t  else\n\t    {\n\t      unsigned shift;\n\t      gmp_ctz (shift, d);\n\t      mpn_rshift (qp, np, nn, shift);\n\t    }\n\t}\n      return r;\n    }\n  else\n    {\n      struct gmp_div_inverse inv;\n      mpn_div_qr_1_invert (&inv, d);\n      return mpn_div_qr_1_preinv (qp, np, nn, &inv);\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_div_qr_2_preinv": {
      "start_point": [
        977,
        0
      ],
      "end_point": [
        1026,
        1
      ],
      "content": "static void\nmpn_div_qr_2_preinv (mp_ptr qp, mp_ptr rp, mp_srcptr np, mp_size_t nn,\n\t\t     const struct gmp_div_inverse *inv)\n{\n  unsigned shift;\n  mp_size_t i;\n  mp_limb_t d1, d0, di, r1, r0;\n  mp_ptr tp;\n\n  assert (nn >= 2);\n  shift = inv->shift;\n  d1 = inv->d1;\n  d0 = inv->d0;\n  di = inv->di;\n\n  if (shift > 0)\n    {\n      tp = gmp_xalloc_limbs (nn);\n      r1 = mpn_lshift (tp, np, nn, shift);\n      np = tp;\n    }\n  else\n    r1 = 0;\n\n  r0 = np[nn - 1];\n\n  i = nn - 2;\n  do\n    {\n      mp_limb_t n0, q;\n      n0 = np[i];\n      gmp_udiv_qr_3by2 (q, r1, r0, r1, r0, n0, d1, d0, di);\n\n      if (qp)\n\tqp[i] = q;\n    }\n  while (--i >= 0);\n\n  if (shift > 0)\n    {\n      assert ((r0 << (GMP_LIMB_BITS - shift)) == 0);\n      r0 = (r0 >> shift) | (r1 << (GMP_LIMB_BITS - shift));\n      r1 >>= shift;\n\n      gmp_free (tp);\n    }\n\n  rp[1] = r1;\n  rp[0] = r0;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_2": {
      "start_point": [
        1029,
        0
      ],
      "end_point": [
        1038,
        1
      ],
      "content": "static void\nmpn_div_qr_2 (mp_ptr qp, mp_ptr rp, mp_srcptr np, mp_size_t nn,\n\t      mp_limb_t d1, mp_limb_t d0)\n{\n  struct gmp_div_inverse inv;\n  assert (nn >= 2);\n\n  mpn_div_qr_2_invert (&inv, d1, d0);\n  mpn_div_qr_2_preinv (qp, rp, np, nn, &inv);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_pi1": {
      "start_point": [
        1041,
        0
      ],
      "end_point": [
        1102,
        1
      ],
      "content": "static void\nmpn_div_qr_pi1 (mp_ptr qp,\n\t\tmp_ptr np, mp_size_t nn, mp_limb_t n1,\n\t\tmp_srcptr dp, mp_size_t dn,\n\t\tmp_limb_t dinv)\n{\n  mp_size_t i;\n\n  mp_limb_t d1, d0;\n  mp_limb_t cy, cy1;\n  mp_limb_t q;\n\n  assert (dn > 2);\n  assert (nn >= dn);\n\n  d1 = dp[dn - 1];\n  d0 = dp[dn - 2];\n\n  assert ((d1 & GMP_LIMB_HIGHBIT) != 0);\n  /* Iteration variable is the index of the q limb.\n   *\n   * We divide <n1, np[dn-1+i], np[dn-2+i], np[dn-3+i],..., np[i]>\n   * by            <d1,          d0,        dp[dn-3],  ..., dp[0] >\n   */\n\n  i = nn - dn;\n  do\n    {\n      mp_limb_t n0 = np[dn-1+i];\n\n      if (n1 == d1 && n0 == d0)\n\t{\n\t  q = GMP_LIMB_MAX;\n\t  mpn_submul_1 (np+i, dp, dn, q);\n\t  n1 = np[dn-1+i];\t/* update n1, last loop's value will now be invalid */\n\t}\n      else\n\t{\n\t  gmp_udiv_qr_3by2 (q, n1, n0, n1, n0, np[dn-2+i], d1, d0, dinv);\n\n\t  cy = mpn_submul_1 (np + i, dp, dn-2, q);\n\n\t  cy1 = n0 < cy;\n\t  n0 = n0 - cy;\n\t  cy = n1 < cy1;\n\t  n1 = n1 - cy1;\n\t  np[dn-2+i] = n0;\n\n\t  if (cy != 0)\n\t    {\n\t      n1 += d1 + mpn_add_n (np + i, np + i, dp, dn - 1);\n\t      q--;\n\t    }\n\t}\n\n      if (qp)\n\tqp[i] = q;\n    }\n  while (--i >= 0);\n\n  np[dn - 1] = n1;\n}",
      "lines": 62,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_preinv": {
      "start_point": [
        1104,
        0
      ],
      "end_point": [
        1136,
        1
      ],
      "content": "static void\nmpn_div_qr_preinv (mp_ptr qp, mp_ptr np, mp_size_t nn,\n\t\t   mp_srcptr dp, mp_size_t dn,\n\t\t   const struct gmp_div_inverse *inv)\n{\n  assert (dn > 0);\n  assert (nn >= dn);\n\n  if (dn == 1)\n    np[0] = mpn_div_qr_1_preinv (qp, np, nn, inv);\n  else if (dn == 2)\n    mpn_div_qr_2_preinv (qp, np, np, nn, inv);\n  else\n    {\n      mp_limb_t nh;\n      unsigned shift;\n\n      assert (inv->d1 == dp[dn-1]);\n      assert (inv->d0 == dp[dn-2]);\n      assert ((inv->d1 & GMP_LIMB_HIGHBIT) != 0);\n\n      shift = inv->shift;\n      if (shift > 0)\n\tnh = mpn_lshift (np, np, nn, shift);\n      else\n\tnh = 0;\n\n      mpn_div_qr_pi1 (qp, np, nn, nh, dp, dn, inv->di);\n\n      if (shift > 0)\n\tgmp_assert_nocarry (mpn_rshift (np, np, dn, shift));\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr": {
      "start_point": [
        1138,
        0
      ],
      "end_point": [
        1157,
        1
      ],
      "content": "static void\nmpn_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)\n{\n  struct gmp_div_inverse inv;\n  mp_ptr tp = NULL;\n\n  assert (dn > 0);\n  assert (nn >= dn);\n\n  mpn_div_qr_invert (&inv, dp, dn);\n  if (dn > 2 && inv.shift > 0)\n    {\n      tp = gmp_xalloc_limbs (dn);\n      gmp_assert_nocarry (mpn_lshift (tp, dp, dn, inv.shift));\n      dp = tp;\n    }\n  mpn_div_qr_preinv (qp, np, nn, dp, dn, &inv);\n  if (tp)\n    gmp_free (tp);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_base_power_of_two_p": {
      "start_point": [
        1161,
        0
      ],
      "end_point": [
        1176,
        1
      ],
      "content": "static unsigned\nmpn_base_power_of_two_p (unsigned b)\n{\n  switch (b)\n    {\n    case 2: return 1;\n    case 4: return 2;\n    case 8: return 3;\n    case 16: return 4;\n    case 32: return 5;\n    case 64: return 6;\n    case 128: return 7;\n    case 256: return 8;\n    default: return 0;\n    }\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "mpn_get_base_info": {
      "start_point": [
        1186,
        0
      ],
      "end_point": [
        1199,
        1
      ],
      "content": "static void\nmpn_get_base_info (struct mpn_base_info *info, mp_limb_t b)\n{\n  mp_limb_t m;\n  mp_limb_t p;\n  unsigned exp;\n\n  m = GMP_LIMB_MAX / b;\n  for (exp = 1, p = b; p <= m; exp++)\n    p *= b;\n\n  info->exp = exp;\n  info->bb = p;\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_limb_size_in_base_2": {
      "start_point": [
        1201,
        0
      ],
      "end_point": [
        1209,
        1
      ],
      "content": "static mp_bitcnt_t\nmpn_limb_size_in_base_2 (mp_limb_t u)\n{\n  unsigned shift;\n\n  assert (u > 0);\n  gmp_clz (shift, u);\n  return GMP_LIMB_BITS - shift;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "mp_bitcnt_t"
      ]
    },
    "mpn_get_str_bits": {
      "start_point": [
        1211,
        0
      ],
      "end_point": [
        1238,
        1
      ],
      "content": "static size_t\nmpn_get_str_bits (unsigned char *sp, unsigned bits, mp_srcptr up, mp_size_t un)\n{\n  unsigned char mask;\n  size_t sn, j;\n  mp_size_t i;\n  unsigned shift;\n\n  sn = ((un - 1) * GMP_LIMB_BITS + mpn_limb_size_in_base_2 (up[un-1])\n\t+ bits - 1) / bits;\n\n  mask = (1U << bits) - 1;\n\n  for (i = 0, j = sn, shift = 0; j-- > 0;)\n    {\n      unsigned char digit = up[i] >> shift;\n\n      shift += bits;\n\n      if (shift >= GMP_LIMB_BITS && ++i < un)\n\t{\n\t  shift -= GMP_LIMB_BITS;\n\t  digit |= up[i] << (bits - shift);\n\t}\n      sp[j] = digit & mask;\n    }\n  return sn;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "mpn_limb_get_str": {
      "start_point": [
        1242,
        0
      ],
      "end_point": [
        1261,
        1
      ],
      "content": "static size_t\nmpn_limb_get_str (unsigned char *sp, mp_limb_t w,\n\t\t  const struct gmp_div_inverse *binv)\n{\n  mp_size_t i;\n  for (i = 0; w > 0; i++)\n    {\n      mp_limb_t h, l, r;\n\n      h = w >> (GMP_LIMB_BITS - binv->shift);\n      l = w << binv->shift;\n\n      gmp_udiv_qrnnd_preinv (w, r, h, l, binv->d1, binv->di);\n      assert ( (r << (GMP_LIMB_BITS - binv->shift)) == 0);\n      r >>= binv->shift;\n\n      sp[i] = r;\n    }\n  return i;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "mpn_get_str_other": {
      "start_point": [
        1263,
        0
      ],
      "end_point": [
        1305,
        1
      ],
      "content": "static size_t\nmpn_get_str_other (unsigned char *sp,\n\t\t   int base, const struct mpn_base_info *info,\n\t\t   mp_ptr up, mp_size_t un)\n{\n  struct gmp_div_inverse binv;\n  size_t sn;\n  size_t i;\n\n  mpn_div_qr_1_invert (&binv, base);\n\n  sn = 0;\n\n  if (un > 1)\n    {\n      struct gmp_div_inverse bbinv;\n      mpn_div_qr_1_invert (&bbinv, info->bb);\n\n      do\n\t{\n\t  mp_limb_t w;\n\t  size_t done;\n\t  w = mpn_div_qr_1_preinv (up, up, un, &bbinv);\n\t  un -= (up[un-1] == 0);\n\t  done = mpn_limb_get_str (sp + sn, w, &binv);\n\n\t  for (sn += done; done < info->exp; done++)\n\t    sp[sn++] = 0;\n\t}\n      while (un > 1);\n    }\n  sn += mpn_limb_get_str (sp + sn, up[0], &binv);\n\n  /* Reverse order */\n  for (i = 0; 2*i + 1 < sn; i++)\n    {\n      unsigned char t = sp[i];\n      sp[i] = sp[sn - i - 1];\n      sp[sn - i - 1] = t;\n    }\n\n  return sn;\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "mpn_get_str": {
      "start_point": [
        1307,
        0
      ],
      "end_point": [
        1325,
        1
      ],
      "content": "size_t\nmpn_get_str (unsigned char *sp, int base, mp_ptr up, mp_size_t un)\n{\n  unsigned bits;\n\n  assert (un > 0);\n  assert (up[un-1] > 0);\n\n  bits = mpn_base_power_of_two_p (base);\n  if (bits)\n    return mpn_get_str_bits (sp, bits, up, un);\n  else\n    {\n      struct mpn_base_info info;\n\n      mpn_get_base_info (&info, base);\n      return mpn_get_str_other (sp, base, &info, up, un);\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    },
    "mpn_set_str_bits": {
      "start_point": [
        1327,
        0
      ],
      "end_point": [
        1356,
        1
      ],
      "content": "static mp_size_t\nmpn_set_str_bits (mp_ptr rp, const unsigned char *sp, size_t sn,\n\t\t  unsigned bits)\n{\n  mp_size_t rn;\n  size_t j;\n  unsigned shift;\n\n  for (j = sn, rn = 0, shift = 0; j-- > 0; )\n    {\n      if (shift == 0)\n\t{\n\t  rp[rn++] = sp[j];\n\t  shift += bits;\n\t}\n      else\n\t{\n\t  rp[rn-1] |= (mp_limb_t) sp[j] << shift;\n\t  shift += bits;\n\t  if (shift >= GMP_LIMB_BITS)\n\t    {\n\t      shift -= GMP_LIMB_BITS;\n\t      if (shift > 0)\n\t\trp[rn++] = (mp_limb_t) sp[j] >> (bits - shift);\n\t    }\n\t}\n    }\n  rn = mpn_normalized_size (rp, rn);\n  return rn;\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_set_str_other": {
      "start_point": [
        1360,
        0
      ],
      "end_point": [
        1396,
        1
      ],
      "content": "static mp_size_t\nmpn_set_str_other (mp_ptr rp, const unsigned char *sp, size_t sn,\n\t\t   mp_limb_t b, const struct mpn_base_info *info)\n{\n  mp_size_t rn;\n  mp_limb_t w;\n  unsigned k;\n  size_t j;\n\n  assert (sn > 0);\n\n  k = 1 + (sn - 1) % info->exp;\n\n  j = 0;\n  w = sp[j++];\n  while (--k != 0)\n    w = w * b + sp[j++];\n\n  rp[0] = w;\n\n  for (rn = 1; j < sn;)\n    {\n      mp_limb_t cy;\n\n      w = sp[j++];\n      for (k = 1; k < info->exp; k++)\n\tw = w * b + sp[j++];\n\n      cy = mpn_mul_1 (rp, rp, rn, info->bb);\n      cy += mpn_add_1 (rp, rp, rn, w);\n      if (cy > 0)\n\trp[rn++] = cy;\n    }\n  assert (j == sn);\n\n  return rn;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_set_str": {
      "start_point": [
        1398,
        0
      ],
      "end_point": [
        1416,
        1
      ],
      "content": "mp_size_t\nmpn_set_str (mp_ptr rp, const unsigned char *sp, size_t sn, int base)\n{\n  unsigned bits;\n\n  if (sn == 0)\n    return 0;\n\n  bits = mpn_base_power_of_two_p (base);\n  if (bits)\n    return mpn_set_str_bits (rp, sp, sn, bits);\n  else\n    {\n      struct mpn_base_info info;\n\n      mpn_get_base_info (&info, base);\n      return mpn_set_str_other (rp, sp, sn, base, &info);\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpz_init": {
      "start_point": [
        1420,
        0
      ],
      "end_point": [
        1428,
        1
      ],
      "content": "void\nmpz_init (mpz_t r)\n{\n  static const mp_limb_t dummy_limb = 0xc1a0;\n\n  r->_mp_alloc = 0;\n  r->_mp_size = 0;\n  r->_mp_d = (mp_ptr) &dummy_limb;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpz_init2": {
      "start_point": [
        1432,
        0
      ],
      "end_point": [
        1443,
        1
      ],
      "content": "void\nmpz_init2 (mpz_t r, mp_bitcnt_t bits)\n{\n  mp_size_t rn;\n\n  bits -= (bits != 0);\t\t/* Round down, except if 0 */\n  rn = 1 + bits / GMP_LIMB_BITS;\n\n  r->_mp_alloc = rn;\n  r->_mp_size = 0;\n  r->_mp_d = gmp_xalloc_limbs (rn);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpz_clear": {
      "start_point": [
        1445,
        0
      ],
      "end_point": [
        1450,
        1
      ],
      "content": "void\nmpz_clear (mpz_t r)\n{\n  if (r->_mp_alloc)\n    gmp_free (r->_mp_d);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_realloc": {
      "start_point": [
        1452,
        0
      ],
      "end_point": [
        1467,
        1
      ],
      "content": "static mp_ptr\nmpz_realloc (mpz_t r, mp_size_t size)\n{\n  size = GMP_MAX (size, 1);\n\n  if (r->_mp_alloc)\n    r->_mp_d = gmp_xrealloc_limbs (r->_mp_d, size);\n  else\n    r->_mp_d = gmp_xalloc_limbs (size);\n  r->_mp_alloc = size;\n\n  if (GMP_ABS (r->_mp_size) > size)\n    r->_mp_size = 0;\n\n  return r->_mp_d;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_ptr"
      ]
    },
    "mpz_set_si": {
      "start_point": [
        1475,
        0
      ],
      "end_point": [
        1485,
        1
      ],
      "content": "void\nmpz_set_si (mpz_t r, signed long int x)\n{\n  if (x >= 0)\n    mpz_set_ui (r, x);\n  else /* (x < 0) */\n    {\n      r->_mp_size = -1;\n      MPZ_REALLOC (r, 1)[0] = GMP_NEG_CAST (unsigned long int, x);\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpz_set_ui": {
      "start_point": [
        1487,
        0
      ],
      "end_point": [
        1497,
        1
      ],
      "content": "void\nmpz_set_ui (mpz_t r, unsigned long int x)\n{\n  if (x > 0)\n    {\n      r->_mp_size = 1;\n      MPZ_REALLOC (r, 1)[0] = x;\n    }\n  else\n    r->_mp_size = 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpz_set": {
      "start_point": [
        1499,
        0
      ],
      "end_point": [
        1514,
        1
      ],
      "content": "void\nmpz_set (mpz_t r, const mpz_t x)\n{\n  /* Allow the NOP r == x */\n  if (r != x)\n    {\n      mp_size_t n;\n      mp_ptr rp;\n\n      n = GMP_ABS (x->_mp_size);\n      rp = MPZ_REALLOC (r, n);\n\n      mpn_copyi (rp, x->_mp_d, n);\n      r->_mp_size = x->_mp_size;\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpz_init_set_si": {
      "start_point": [
        1516,
        0
      ],
      "end_point": [
        1521,
        1
      ],
      "content": "void\nmpz_init_set_si (mpz_t r, signed long int x)\n{\n  mpz_init (r);\n  mpz_set_si (r, x);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_init_set_ui": {
      "start_point": [
        1523,
        0
      ],
      "end_point": [
        1528,
        1
      ],
      "content": "void\nmpz_init_set_ui (mpz_t r, unsigned long int x)\n{\n  mpz_init (r);\n  mpz_set_ui (r, x);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_init_set": {
      "start_point": [
        1530,
        0
      ],
      "end_point": [
        1535,
        1
      ],
      "content": "void\nmpz_init_set (mpz_t r, const mpz_t x)\n{\n  mpz_init (r);\n  mpz_set (r, x);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fits_slong_p": {
      "start_point": [
        1537,
        0
      ],
      "end_point": [
        1548,
        1
      ],
      "content": "int\nmpz_fits_slong_p (const mpz_t u)\n{\n  mp_size_t us = u->_mp_size;\n\n  if (us == 1)\n    return u->_mp_d[0] < GMP_LIMB_HIGHBIT;\n  else if (us == -1)\n    return u->_mp_d[0] <= GMP_LIMB_HIGHBIT;\n  else\n    return (us == 0);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_fits_ulong_p": {
      "start_point": [
        1550,
        0
      ],
      "end_point": [
        1556,
        1
      ],
      "content": "int\nmpz_fits_ulong_p (const mpz_t u)\n{\n  mp_size_t us = u->_mp_size;\n\n  return (us == (us > 0));\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mpz_get_si": {
      "start_point": [
        1558,
        0
      ],
      "end_point": [
        1566,
        1
      ],
      "content": "long int\nmpz_get_si (const mpz_t u)\n{\n  if (u->_mp_size < 0)\n    /* This expression is necessary to properly handle 0x80000000 */\n    return -1 - (long) ((u->_mp_d[0] - 1) & ~GMP_LIMB_HIGHBIT);\n  else\n    return (long) (mpz_get_ui (u) & ~GMP_LIMB_HIGHBIT);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "long int",
        "long",
        "int"
      ]
    },
    "mpz_get_ui": {
      "start_point": [
        1568,
        0
      ],
      "end_point": [
        1572,
        1
      ],
      "content": "unsigned long int\nmpz_get_ui (const mpz_t u)\n{\n  return u->_mp_size == 0 ? 0 : u->_mp_d[0];\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    },
    "mpz_size": {
      "start_point": [
        1574,
        0
      ],
      "end_point": [
        1578,
        1
      ],
      "content": "size_t\nmpz_size (const mpz_t u)\n{\n  return GMP_ABS (u->_mp_size);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "mpz_getlimbn": {
      "start_point": [
        1580,
        0
      ],
      "end_point": [
        1587,
        1
      ],
      "content": "mp_limb_t\nmpz_getlimbn (const mpz_t u, mp_size_t n)\n{\n  if (n >= 0 && n < GMP_ABS (u->_mp_size))\n    return u->_mp_d[n];\n  else\n    return 0;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpz_realloc2": {
      "start_point": [
        1589,
        0
      ],
      "end_point": [
        1593,
        1
      ],
      "content": "void\nmpz_realloc2 (mpz_t x, mp_bitcnt_t n)\n{\n  mpz_realloc (x, 1 + (n - (n != 0)) / GMP_LIMB_BITS);\n}",
      "lines": 5,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpz_limbs_read": {
      "start_point": [
        1595,
        0
      ],
      "end_point": [
        1599,
        1
      ],
      "content": "mp_srcptr\nmpz_limbs_read (mpz_srcptr x)\n{\n  return x->_mp_d;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "mp_srcptr"
      ]
    },
    "mpz_limbs_modify": {
      "start_point": [
        1601,
        0
      ],
      "end_point": [
        1606,
        1
      ],
      "content": "mp_ptr\nmpz_limbs_modify (mpz_t x, mp_size_t n)\n{\n  assert (n > 0);\n  return MPZ_REALLOC (x, n);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "mp_ptr"
      ]
    },
    "mpz_limbs_write": {
      "start_point": [
        1608,
        0
      ],
      "end_point": [
        1612,
        1
      ],
      "content": "mp_ptr\nmpz_limbs_write (mpz_t x, mp_size_t n)\n{\n  return mpz_limbs_modify (x, n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_ptr"
      ]
    },
    "mpz_limbs_finish": {
      "start_point": [
        1614,
        0
      ],
      "end_point": [
        1620,
        1
      ],
      "content": "void\nmpz_limbs_finish (mpz_t x, mp_size_t xs)\n{\n  mp_size_t xn;\n  xn = mpn_normalized_size (x->_mp_d, GMP_ABS (xs));\n  x->_mp_size = xs < 0 ? -xn : xn;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_roinit_n": {
      "start_point": [
        1622,
        0
      ],
      "end_point": [
        1629,
        1
      ],
      "content": "mpz_srcptr\nmpz_roinit_n (mpz_t x, mp_srcptr xp, mp_size_t xs)\n{\n  x->_mp_alloc = 0;\n  x->_mp_d = (mp_ptr) xp;\n  mpz_limbs_finish (x, xs);\n  return x;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "mpz_srcptr"
      ]
    },
    "mpz_set_d": {
      "start_point": [
        1633,
        0
      ],
      "end_point": [
        1682,
        1
      ],
      "content": "void\nmpz_set_d (mpz_t r, double x)\n{\n  int sign;\n  mp_ptr rp;\n  mp_size_t rn, i;\n  double B;\n  double Bi;\n  mp_limb_t f;\n\n  /* x != x is true when x is a NaN, and x == x * 0.5 is true when x is\n     zero or infinity. */\n  if (x != x || x == x * 0.5)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  sign = x < 0.0 ;\n  if (sign)\n    x = - x;\n\n  if (x < 1.0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n  B = 2.0 * (double) GMP_LIMB_HIGHBIT;\n  Bi = 1.0 / B;\n  for (rn = 1; x >= B; rn++)\n    x *= Bi;\n\n  rp = MPZ_REALLOC (r, rn);\n\n  f = (mp_limb_t) x;\n  x -= f;\n  assert (x < 1.0);\n  i = rn-1;\n  rp[i] = f;\n  while (--i >= 0)\n    {\n      x = B * x;\n      f = (mp_limb_t) x;\n      x -= f;\n      assert (x < 1.0);\n      rp[i] = f;\n    }\n\n  r->_mp_size = sign ? - rn : rn;\n}",
      "lines": 50,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_init_set_d": {
      "start_point": [
        1684,
        0
      ],
      "end_point": [
        1689,
        1
      ],
      "content": "void\nmpz_init_set_d (mpz_t r, double x)\n{\n  mpz_init (r);\n  mpz_set_d (r, x);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_get_d": {
      "start_point": [
        1691,
        0
      ],
      "end_point": [
        1711,
        1
      ],
      "content": "double\nmpz_get_d (const mpz_t u)\n{\n  mp_size_t un;\n  double x;\n  double B = 2.0 * (double) GMP_LIMB_HIGHBIT;\n\n  un = GMP_ABS (u->_mp_size);\n\n  if (un == 0)\n    return 0.0;\n\n  x = u->_mp_d[--un];\n  while (un > 0)\n    x = B*x + u->_mp_d[--un];\n\n  if (u->_mp_size < 0)\n    x = -x;\n\n  return x;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "mpz_cmpabs_d": {
      "start_point": [
        1713,
        0
      ],
      "end_point": [
        1752,
        1
      ],
      "content": "int\nmpz_cmpabs_d (const mpz_t x, double d)\n{\n  mp_size_t xn;\n  double B, Bi;\n  mp_size_t i;\n\n  xn = x->_mp_size;\n  d = GMP_ABS (d);\n\n  if (xn != 0)\n    {\n      xn = GMP_ABS (xn);\n\n      B = 2.0 * (double) GMP_LIMB_HIGHBIT;\n      Bi = 1.0 / B;\n\n      /* Scale d so it can be compared with the top limb. */\n      for (i = 1; i < xn; i++)\n\td *= Bi;\n\n      if (d >= B)\n\treturn -1;\n\n      /* Compare floor(d) to top limb, subtract and cancel when equal. */\n      for (i = xn; i-- > 0;)\n\t{\n\t  mp_limb_t f, xl;\n\n\t  f = (mp_limb_t) d;\n\t  xl = x->_mp_d[i];\n\t  if (xl > f)\n\t    return 1;\n\t  else if (xl < f)\n\t    return -1;\n\t  d = B * (d - f);\n\t}\n    }\n  return - (d > 0.0);\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmp_d": {
      "start_point": [
        1754,
        0
      ],
      "end_point": [
        1771,
        1
      ],
      "content": "int\nmpz_cmp_d (const mpz_t x, double d)\n{\n  if (x->_mp_size < 0)\n    {\n      if (d >= 0.0)\n\treturn -1;\n      else\n\treturn -mpz_cmpabs_d (x, d);\n    }\n  else\n    {\n      if (d < 0.0)\n\treturn 1;\n      else\n\treturn mpz_cmpabs_d (x, d);\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpz_sgn": {
      "start_point": [
        1775,
        0
      ],
      "end_point": [
        1779,
        1
      ],
      "content": "int\nmpz_sgn (const mpz_t u)\n{\n  return GMP_CMP (u->_mp_size, 0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmp_si": {
      "start_point": [
        1781,
        0
      ],
      "end_point": [
        1794,
        1
      ],
      "content": "int\nmpz_cmp_si (const mpz_t u, long v)\n{\n  mp_size_t usize = u->_mp_size;\n\n  if (usize < -1)\n    return -1;\n  else if (v >= 0)\n    return mpz_cmp_ui (u, v);\n  else if (usize >= 0)\n    return 1;\n  else /* usize == -1 */\n    return GMP_CMP (GMP_NEG_CAST (mp_limb_t, v), u->_mp_d[0]);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmp_ui": {
      "start_point": [
        1796,
        0
      ],
      "end_point": [
        1807,
        1
      ],
      "content": "int\nmpz_cmp_ui (const mpz_t u, unsigned long v)\n{\n  mp_size_t usize = u->_mp_size;\n\n  if (usize > 1)\n    return 1;\n  else if (usize < 0)\n    return -1;\n  else\n    return GMP_CMP (mpz_get_ui (u), v);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmp": {
      "start_point": [
        1809,
        0
      ],
      "end_point": [
        1821,
        1
      ],
      "content": "int\nmpz_cmp (const mpz_t a, const mpz_t b)\n{\n  mp_size_t asize = a->_mp_size;\n  mp_size_t bsize = b->_mp_size;\n\n  if (asize != bsize)\n    return (asize < bsize) ? -1 : 1;\n  else if (asize >= 0)\n    return mpn_cmp (a->_mp_d, b->_mp_d, asize);\n  else\n    return mpn_cmp (b->_mp_d, a->_mp_d, -asize);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmpabs_ui": {
      "start_point": [
        1823,
        0
      ],
      "end_point": [
        1830,
        1
      ],
      "content": "int\nmpz_cmpabs_ui (const mpz_t u, unsigned long v)\n{\n  if (GMP_ABS (u->_mp_size) > 1)\n    return 1;\n  else\n    return GMP_CMP (mpz_get_ui (u), v);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmpabs": {
      "start_point": [
        1832,
        0
      ],
      "end_point": [
        1837,
        1
      ],
      "content": "int\nmpz_cmpabs (const mpz_t u, const mpz_t v)\n{\n  return mpn_cmp4 (u->_mp_d, GMP_ABS (u->_mp_size),\n\t\t   v->_mp_d, GMP_ABS (v->_mp_size));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_abs": {
      "start_point": [
        1839,
        0
      ],
      "end_point": [
        1844,
        1
      ],
      "content": "void\nmpz_abs (mpz_t r, const mpz_t u)\n{\n  mpz_set (r, u);\n  r->_mp_size = GMP_ABS (r->_mp_size);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_neg": {
      "start_point": [
        1846,
        0
      ],
      "end_point": [
        1851,
        1
      ],
      "content": "void\nmpz_neg (mpz_t r, const mpz_t u)\n{\n  mpz_set (r, u);\n  r->_mp_size = -r->_mp_size;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpz_swap": {
      "start_point": [
        1853,
        0
      ],
      "end_point": [
        1859,
        1
      ],
      "content": "void\nmpz_swap (mpz_t u, mpz_t v)\n{\n  MP_SIZE_T_SWAP (u->_mp_size, v->_mp_size);\n  MP_SIZE_T_SWAP (u->_mp_alloc, v->_mp_alloc);\n  MP_PTR_SWAP (u->_mp_d, v->_mp_d);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpz_abs_add_ui": {
      "start_point": [
        1865,
        0
      ],
      "end_point": [
        1886,
        1
      ],
      "content": "static mp_size_t\nmpz_abs_add_ui (mpz_t r, const mpz_t a, unsigned long b)\n{\n  mp_size_t an;\n  mp_ptr rp;\n  mp_limb_t cy;\n\n  an = GMP_ABS (a->_mp_size);\n  if (an == 0)\n    {\n      MPZ_REALLOC (r, 1)[0] = b;\n      return b > 0;\n    }\n\n  rp = MPZ_REALLOC (r, an + 1);\n\n  cy = mpn_add_1 (rp, a->_mp_d, an, b);\n  rp[an] = cy;\n  an += cy;\n\n  return an;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpz_abs_sub_ui": {
      "start_point": [
        1890,
        0
      ],
      "end_point": [
        1912,
        1
      ],
      "content": "static mp_size_t\nmpz_abs_sub_ui (mpz_t r, const mpz_t a, unsigned long b)\n{\n  mp_size_t an = GMP_ABS (a->_mp_size);\n  mp_ptr rp;\n\n  if (an == 0)\n    {\n      MPZ_REALLOC (r, 1)[0] = b;\n      return -(b > 0);\n    }\n  rp = MPZ_REALLOC (r, an);\n  if (an == 1 && a->_mp_d[0] < b)\n    {\n      rp[0] = b - a->_mp_d[0];\n      return -1;\n    }\n  else\n    {\n      gmp_assert_nocarry (mpn_sub_1 (rp, a->_mp_d, an, b));\n      return mpn_normalized_size (rp, an);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpz_add_ui": {
      "start_point": [
        1914,
        0
      ],
      "end_point": [
        1921,
        1
      ],
      "content": "void\nmpz_add_ui (mpz_t r, const mpz_t a, unsigned long b)\n{\n  if (a->_mp_size >= 0)\n    r->_mp_size = mpz_abs_add_ui (r, a, b);\n  else\n    r->_mp_size = -mpz_abs_sub_ui (r, a, b);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_sub_ui": {
      "start_point": [
        1923,
        0
      ],
      "end_point": [
        1930,
        1
      ],
      "content": "void\nmpz_sub_ui (mpz_t r, const mpz_t a, unsigned long b)\n{\n  if (a->_mp_size < 0)\n    r->_mp_size = -mpz_abs_add_ui (r, a, b);\n  else\n    r->_mp_size = mpz_abs_sub_ui (r, a, b);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_ui_sub": {
      "start_point": [
        1932,
        0
      ],
      "end_point": [
        1939,
        1
      ],
      "content": "void\nmpz_ui_sub (mpz_t r, unsigned long a, const mpz_t b)\n{\n  if (b->_mp_size < 0)\n    r->_mp_size = mpz_abs_add_ui (r, b, a);\n  else\n    r->_mp_size = -mpz_abs_sub_ui (r, b, a);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_abs_add": {
      "start_point": [
        1941,
        0
      ],
      "end_point": [
        1961,
        1
      ],
      "content": "static mp_size_t\nmpz_abs_add (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t an = GMP_ABS (a->_mp_size);\n  mp_size_t bn = GMP_ABS (b->_mp_size);\n  mp_ptr rp;\n  mp_limb_t cy;\n\n  if (an < bn)\n    {\n      MPZ_SRCPTR_SWAP (a, b);\n      MP_SIZE_T_SWAP (an, bn);\n    }\n\n  rp = MPZ_REALLOC (r, an + 1);\n  cy = mpn_add (rp, a->_mp_d, an, b->_mp_d, bn);\n\n  rp[an] = cy;\n\n  return an + cy;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpz_abs_sub": {
      "start_point": [
        1963,
        0
      ],
      "end_point": [
        1986,
        1
      ],
      "content": "static mp_size_t\nmpz_abs_sub (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t an = GMP_ABS (a->_mp_size);\n  mp_size_t bn = GMP_ABS (b->_mp_size);\n  int cmp;\n  mp_ptr rp;\n\n  cmp = mpn_cmp4 (a->_mp_d, an, b->_mp_d, bn);\n  if (cmp > 0)\n    {\n      rp = MPZ_REALLOC (r, an);\n      gmp_assert_nocarry (mpn_sub (rp, a->_mp_d, an, b->_mp_d, bn));\n      return mpn_normalized_size (rp, an);\n    }\n  else if (cmp < 0)\n    {\n      rp = MPZ_REALLOC (r, bn);\n      gmp_assert_nocarry (mpn_sub (rp, b->_mp_d, bn, a->_mp_d, an));\n      return -mpn_normalized_size (rp, bn);\n    }\n  else\n    return 0;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpz_add": {
      "start_point": [
        1988,
        0
      ],
      "end_point": [
        1999,
        1
      ],
      "content": "void\nmpz_add (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t rn;\n\n  if ( (a->_mp_size ^ b->_mp_size) >= 0)\n    rn = mpz_abs_add (r, a, b);\n  else\n    rn = mpz_abs_sub (r, a, b);\n\n  r->_mp_size = a->_mp_size >= 0 ? rn : - rn;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_sub": {
      "start_point": [
        2001,
        0
      ],
      "end_point": [
        2012,
        1
      ],
      "content": "void\nmpz_sub (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t rn;\n\n  if ( (a->_mp_size ^ b->_mp_size) >= 0)\n    rn = mpz_abs_sub (r, a, b);\n  else\n    rn = mpz_abs_add (r, a, b);\n\n  r->_mp_size = a->_mp_size >= 0 ? rn : - rn;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_mul_si": {
      "start_point": [
        2016,
        0
      ],
      "end_point": [
        2026,
        1
      ],
      "content": "void\nmpz_mul_si (mpz_t r, const mpz_t u, long int v)\n{\n  if (v < 0)\n    {\n      mpz_mul_ui (r, u, GMP_NEG_CAST (unsigned long int, v));\n      mpz_neg (r, r);\n    }\n  else\n    mpz_mul_ui (r, u, (unsigned long int) v);\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "mpz_mul_ui": {
      "start_point": [
        2028,
        0
      ],
      "end_point": [
        2051,
        1
      ],
      "content": "void\nmpz_mul_ui (mpz_t r, const mpz_t u, unsigned long int v)\n{\n  mp_size_t un, us;\n  mp_ptr tp;\n  mp_limb_t cy;\n\n  us = u->_mp_size;\n\n  if (us == 0 || v == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  un = GMP_ABS (us);\n\n  tp = MPZ_REALLOC (r, un + 1);\n  cy = mpn_mul_1 (tp, u->_mp_d, un, v);\n  tp[un] = cy;\n\n  un += (cy > 0);\n  r->_mp_size = (us < 0) ? - un : un;\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_mul": {
      "start_point": [
        2053,
        0
      ],
      "end_point": [
        2089,
        1
      ],
      "content": "void\nmpz_mul (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  int sign;\n  mp_size_t un, vn, rn;\n  mpz_t t;\n  mp_ptr tp;\n\n  un = u->_mp_size;\n  vn = v->_mp_size;\n\n  if (un == 0 || vn == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  sign = (un ^ vn) < 0;\n\n  un = GMP_ABS (un);\n  vn = GMP_ABS (vn);\n\n  mpz_init2 (t, (un + vn) * GMP_LIMB_BITS);\n\n  tp = t->_mp_d;\n  if (un >= vn)\n    mpn_mul (tp, u->_mp_d, un, v->_mp_d, vn);\n  else\n    mpn_mul (tp, v->_mp_d, vn, u->_mp_d, un);\n\n  rn = un + vn;\n  rn -= tp[rn-1] == 0;\n\n  t->_mp_size = sign ? - rn : rn;\n  mpz_swap (r, t);\n  mpz_clear (t);\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_mul_2exp": {
      "start_point": [
        2091,
        0
      ],
      "end_point": [
        2123,
        1
      ],
      "content": "void\nmpz_mul_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t bits)\n{\n  mp_size_t un, rn;\n  mp_size_t limbs;\n  unsigned shift;\n  mp_ptr rp;\n\n  un = GMP_ABS (u->_mp_size);\n  if (un == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  limbs = bits / GMP_LIMB_BITS;\n  shift = bits % GMP_LIMB_BITS;\n\n  rn = un + limbs + (shift > 0);\n  rp = MPZ_REALLOC (r, rn);\n  if (shift > 0)\n    {\n      mp_limb_t cy = mpn_lshift (rp + limbs, u->_mp_d, un, shift);\n      rp[rn-1] = cy;\n      rn -= (cy == 0);\n    }\n  else\n    mpn_copyd (rp + limbs, u->_mp_d, un);\n\n  mpn_zero (rp, limbs);\n\n  r->_mp_size = (u->_mp_size < 0) ? - rn : rn;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpz_addmul_ui": {
      "start_point": [
        2125,
        0
      ],
      "end_point": [
        2133,
        1
      ],
      "content": "void\nmpz_addmul_ui (mpz_t r, const mpz_t u, unsigned long int v)\n{\n  mpz_t t;\n  mpz_init (t);\n  mpz_mul_ui (t, u, v);\n  mpz_add (r, r, t);\n  mpz_clear (t);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_submul_ui": {
      "start_point": [
        2135,
        0
      ],
      "end_point": [
        2143,
        1
      ],
      "content": "void\nmpz_submul_ui (mpz_t r, const mpz_t u, unsigned long int v)\n{\n  mpz_t t;\n  mpz_init (t);\n  mpz_mul_ui (t, u, v);\n  mpz_sub (r, r, t);\n  mpz_clear (t);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_addmul": {
      "start_point": [
        2145,
        0
      ],
      "end_point": [
        2153,
        1
      ],
      "content": "void\nmpz_addmul (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mpz_t t;\n  mpz_init (t);\n  mpz_mul (t, u, v);\n  mpz_add (r, r, t);\n  mpz_clear (t);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_submul": {
      "start_point": [
        2155,
        0
      ],
      "end_point": [
        2163,
        1
      ],
      "content": "void\nmpz_submul (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mpz_t t;\n  mpz_init (t);\n  mpz_mul (t, u, v);\n  mpz_sub (r, r, t);\n  mpz_clear (t);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_div_qr": {
      "start_point": [
        2170,
        0
      ],
      "end_point": [
        2280,
        1
      ],
      "content": "static int\nmpz_div_qr (mpz_t q, mpz_t r,\n\t    const mpz_t n, const mpz_t d, enum mpz_div_round_mode mode)\n{\n  mp_size_t ns, ds, nn, dn, qs;\n  ns = n->_mp_size;\n  ds = d->_mp_size;\n\n  if (ds == 0)\n    gmp_die(\"mpz_div_qr: Divide by zero.\");\n\n  if (ns == 0)\n    {\n      if (q)\n\tq->_mp_size = 0;\n      if (r)\n\tr->_mp_size = 0;\n      return 0;\n    }\n\n  nn = GMP_ABS (ns);\n  dn = GMP_ABS (ds);\n\n  qs = ds ^ ns;\n\n  if (nn < dn)\n    {\n      if (mode == GMP_DIV_CEIL && qs >= 0)\n\t{\n\t  /* q = 1, r = n - d */\n\t  if (r)\n\t    mpz_sub (r, n, d);\n\t  if (q)\n\t    mpz_set_ui (q, 1);\n\t}\n      else if (mode == GMP_DIV_FLOOR && qs < 0)\n\t{\n\t  /* q = -1, r = n + d */\n\t  if (r)\n\t    mpz_add (r, n, d);\n\t  if (q)\n\t    mpz_set_si (q, -1);\n\t}\n      else\n\t{\n\t  /* q = 0, r = d */\n\t  if (r)\n\t    mpz_set (r, n);\n\t  if (q)\n\t    q->_mp_size = 0;\n\t}\n      return 1;\n    }\n  else\n    {\n      mp_ptr np, qp;\n      mp_size_t qn, rn;\n      mpz_t tq, tr;\n\n      mpz_init_set (tr, n);\n      np = tr->_mp_d;\n\n      qn = nn - dn + 1;\n\n      if (q)\n\t{\n\t  mpz_init2 (tq, qn * GMP_LIMB_BITS);\n\t  qp = tq->_mp_d;\n\t}\n      else\n\tqp = NULL;\n\n      mpn_div_qr (qp, np, nn, d->_mp_d, dn);\n\n      if (qp)\n\t{\n\t  qn -= (qp[qn-1] == 0);\n\n\t  tq->_mp_size = qs < 0 ? -qn : qn;\n\t}\n      rn = mpn_normalized_size (np, dn);\n      tr->_mp_size = ns < 0 ? - rn : rn;\n\n      if (mode == GMP_DIV_FLOOR && qs < 0 && rn != 0)\n\t{\n\t  if (q)\n\t    mpz_sub_ui (tq, tq, 1);\n\t  if (r)\n\t    mpz_add (tr, tr, d);\n\t}\n      else if (mode == GMP_DIV_CEIL && qs >= 0 && rn != 0)\n\t{\n\t  if (q)\n\t    mpz_add_ui (tq, tq, 1);\n\t  if (r)\n\t    mpz_sub (tr, tr, d);\n\t}\n\n      if (q)\n\t{\n\t  mpz_swap (tq, q);\n\t  mpz_clear (tq);\n\t}\n      if (r)\n\tmpz_swap (tr, r);\n\n      mpz_clear (tr);\n\n      return rn != 0;\n    }\n}",
      "lines": 111,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpz_cdiv_qr": {
      "start_point": [
        2282,
        0
      ],
      "end_point": [
        2286,
        1
      ],
      "content": "void\nmpz_cdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, r, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_qr": {
      "start_point": [
        2288,
        0
      ],
      "end_point": [
        2292,
        1
      ],
      "content": "void\nmpz_fdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, r, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_tdiv_qr": {
      "start_point": [
        2294,
        0
      ],
      "end_point": [
        2298,
        1
      ],
      "content": "void\nmpz_tdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, r, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_cdiv_q": {
      "start_point": [
        2300,
        0
      ],
      "end_point": [
        2304,
        1
      ],
      "content": "void\nmpz_cdiv_q (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, NULL, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_q": {
      "start_point": [
        2306,
        0
      ],
      "end_point": [
        2310,
        1
      ],
      "content": "void\nmpz_fdiv_q (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, NULL, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_tdiv_q": {
      "start_point": [
        2312,
        0
      ],
      "end_point": [
        2316,
        1
      ],
      "content": "void\nmpz_tdiv_q (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, NULL, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_cdiv_r": {
      "start_point": [
        2318,
        0
      ],
      "end_point": [
        2322,
        1
      ],
      "content": "void\nmpz_cdiv_r (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_r": {
      "start_point": [
        2324,
        0
      ],
      "end_point": [
        2328,
        1
      ],
      "content": "void\nmpz_fdiv_r (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_tdiv_r": {
      "start_point": [
        2330,
        0
      ],
      "end_point": [
        2334,
        1
      ],
      "content": "void\nmpz_tdiv_r (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_mod": {
      "start_point": [
        2336,
        0
      ],
      "end_point": [
        2340,
        1
      ],
      "content": "void\nmpz_mod (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, d->_mp_size >= 0 ? GMP_DIV_FLOOR : GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_div_q_2exp": {
      "start_point": [
        2342,
        0
      ],
      "end_point": [
        2394,
        1
      ],
      "content": "static void\nmpz_div_q_2exp (mpz_t q, const mpz_t u, mp_bitcnt_t bit_index,\n\t\tenum mpz_div_round_mode mode)\n{\n  mp_size_t un, qn;\n  mp_size_t limb_cnt;\n  mp_ptr qp;\n  int adjust;\n\n  un = u->_mp_size;\n  if (un == 0)\n    {\n      q->_mp_size = 0;\n      return;\n    }\n  limb_cnt = bit_index / GMP_LIMB_BITS;\n  qn = GMP_ABS (un) - limb_cnt;\n  bit_index %= GMP_LIMB_BITS;\n\n  if (mode == ((un > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR)) /* un != 0 here. */\n    /* Note: Below, the final indexing at limb_cnt is valid because at\n       that point we have qn > 0. */\n    adjust = (qn <= 0\n\t      || !mpn_zero_p (u->_mp_d, limb_cnt)\n\t      || (u->_mp_d[limb_cnt]\n\t\t  & (((mp_limb_t) 1 << bit_index) - 1)));\n  else\n    adjust = 0;\n\n  if (qn <= 0)\n    qn = 0;\n  else\n    {\n      qp = MPZ_REALLOC (q, qn);\n\n      if (bit_index != 0)\n\t{\n\t  mpn_rshift (qp, u->_mp_d + limb_cnt, qn, bit_index);\n\t  qn -= qp[qn - 1] == 0;\n\t}\n      else\n\t{\n\t  mpn_copyi (qp, u->_mp_d + limb_cnt, qn);\n\t}\n    }\n\n  q->_mp_size = qn;\n\n  if (adjust)\n    mpz_add_ui (q, q, 1);\n  if (un < 0)\n    mpz_neg (q, q);\n}",
      "lines": 53,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_div_r_2exp": {
      "start_point": [
        2396,
        0
      ],
      "end_point": [
        2464,
        1
      ],
      "content": "static void\nmpz_div_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t bit_index,\n\t\tenum mpz_div_round_mode mode)\n{\n  mp_size_t us, un, rn;\n  mp_ptr rp;\n  mp_limb_t mask;\n\n  us = u->_mp_size;\n  if (us == 0 || bit_index == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n  rn = (bit_index + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  assert (rn > 0);\n\n  rp = MPZ_REALLOC (r, rn);\n  un = GMP_ABS (us);\n\n  mask = GMP_LIMB_MAX >> (rn * GMP_LIMB_BITS - bit_index);\n\n  if (rn > un)\n    {\n      /* Quotient (with truncation) is zero, and remainder is\n\t non-zero */\n      if (mode == ((us > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR)) /* us != 0 here. */\n\t{\n\t  /* Have to negate and sign extend. */\n\t  mp_size_t i;\n\n\t  gmp_assert_nocarry (! mpn_neg (rp, u->_mp_d, un));\n\t  for (i = un; i < rn - 1; i++)\n\t    rp[i] = GMP_LIMB_MAX;\n\n\t  rp[rn-1] = mask;\n\t  us = -us;\n\t}\n      else\n\t{\n\t  /* Just copy */\n\t  if (r != u)\n\t    mpn_copyi (rp, u->_mp_d, un);\n\n\t  rn = un;\n\t}\n    }\n  else\n    {\n      if (r != u)\n\tmpn_copyi (rp, u->_mp_d, rn - 1);\n\n      rp[rn-1] = u->_mp_d[rn-1] & mask;\n\n      if (mode == ((us > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR)) /* us != 0 here. */\n\t{\n\t  /* If r != 0, compute 2^{bit_count} - r. */\n\t  mpn_neg (rp, rp, rn);\n\n\t  rp[rn-1] &= mask;\n\n\t  /* us is not used for anything else, so we can modify it\n\t     here to indicate flipped sign. */\n\t  us = -us;\n\t}\n    }\n  rn = mpn_normalized_size (rp, rn);\n  r->_mp_size = us < 0 ? -rn : rn;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_cdiv_q_2exp": {
      "start_point": [
        2466,
        0
      ],
      "end_point": [
        2470,
        1
      ],
      "content": "void\nmpz_cdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_q_2exp (r, u, cnt, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_q_2exp": {
      "start_point": [
        2472,
        0
      ],
      "end_point": [
        2476,
        1
      ],
      "content": "void\nmpz_fdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_q_2exp (r, u, cnt, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_tdiv_q_2exp": {
      "start_point": [
        2478,
        0
      ],
      "end_point": [
        2482,
        1
      ],
      "content": "void\nmpz_tdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_q_2exp (r, u, cnt, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_cdiv_r_2exp": {
      "start_point": [
        2484,
        0
      ],
      "end_point": [
        2488,
        1
      ],
      "content": "void\nmpz_cdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_r_2exp (r, u, cnt, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_r_2exp": {
      "start_point": [
        2490,
        0
      ],
      "end_point": [
        2494,
        1
      ],
      "content": "void\nmpz_fdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_r_2exp (r, u, cnt, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_tdiv_r_2exp": {
      "start_point": [
        2496,
        0
      ],
      "end_point": [
        2500,
        1
      ],
      "content": "void\nmpz_tdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_r_2exp (r, u, cnt, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_divexact": {
      "start_point": [
        2502,
        0
      ],
      "end_point": [
        2506,
        1
      ],
      "content": "void\nmpz_divexact (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  gmp_assert_nocarry (mpz_div_qr (q, NULL, n, d, GMP_DIV_TRUNC));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_divisible_p": {
      "start_point": [
        2508,
        0
      ],
      "end_point": [
        2512,
        1
      ],
      "content": "int\nmpz_divisible_p (const mpz_t n, const mpz_t d)\n{\n  return mpz_div_qr (NULL, NULL, n, d, GMP_DIV_TRUNC) == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mpz_congruent_p": {
      "start_point": [
        2514,
        0
      ],
      "end_point": [
        2530,
        1
      ],
      "content": "int\nmpz_congruent_p (const mpz_t a, const mpz_t b, const mpz_t m)\n{\n  mpz_t t;\n  int res;\n\n  /* a == b (mod 0) iff a == b */\n  if (mpz_sgn (m) == 0)\n    return (mpz_cmp (a, b) == 0);\n\n  mpz_init (t);\n  mpz_sub (t, a, b);\n  res = mpz_divisible_p (t, m);\n  mpz_clear (t);\n\n  return res;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_div_qr_ui": {
      "start_point": [
        2532,
        0
      ],
      "end_point": [
        2586,
        1
      ],
      "content": "static unsigned long\nmpz_div_qr_ui (mpz_t q, mpz_t r,\n\t       const mpz_t n, unsigned long d, enum mpz_div_round_mode mode)\n{\n  mp_size_t ns, qn;\n  mp_ptr qp;\n  mp_limb_t rl;\n  mp_size_t rs;\n\n  ns = n->_mp_size;\n  if (ns == 0)\n    {\n      if (q)\n\tq->_mp_size = 0;\n      if (r)\n\tr->_mp_size = 0;\n      return 0;\n    }\n\n  qn = GMP_ABS (ns);\n  if (q)\n    qp = MPZ_REALLOC (q, qn);\n  else\n    qp = NULL;\n\n  rl = mpn_div_qr_1 (qp, n->_mp_d, qn, d);\n  assert (rl < d);\n\n  rs = rl > 0;\n  rs = (ns < 0) ? -rs : rs;\n\n  if (rl > 0 && ( (mode == GMP_DIV_FLOOR && ns < 0)\n\t\t  || (mode == GMP_DIV_CEIL && ns >= 0)))\n    {\n      if (q)\n\tgmp_assert_nocarry (mpn_add_1 (qp, qp, qn, 1));\n      rl = d - rl;\n      rs = -rs;\n    }\n\n  if (r)\n    {\n      MPZ_REALLOC (r, 1)[0] = rl;\n      r->_mp_size = rs;\n    }\n  if (q)\n    {\n      qn -= (qp[qn-1] == 0);\n      assert (qn == 0 || qp[qn-1] > 0);\n\n      q->_mp_size = (ns < 0) ? - qn : qn;\n    }\n\n  return rl;\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_cdiv_qr_ui": {
      "start_point": [
        2588,
        0
      ],
      "end_point": [
        2592,
        1
      ],
      "content": "unsigned long\nmpz_cdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, r, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_fdiv_qr_ui": {
      "start_point": [
        2594,
        0
      ],
      "end_point": [
        2598,
        1
      ],
      "content": "unsigned long\nmpz_fdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, r, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_tdiv_qr_ui": {
      "start_point": [
        2600,
        0
      ],
      "end_point": [
        2604,
        1
      ],
      "content": "unsigned long\nmpz_tdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, r, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_cdiv_q_ui": {
      "start_point": [
        2606,
        0
      ],
      "end_point": [
        2610,
        1
      ],
      "content": "unsigned long\nmpz_cdiv_q_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_fdiv_q_ui": {
      "start_point": [
        2612,
        0
      ],
      "end_point": [
        2616,
        1
      ],
      "content": "unsigned long\nmpz_fdiv_q_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_tdiv_q_ui": {
      "start_point": [
        2618,
        0
      ],
      "end_point": [
        2622,
        1
      ],
      "content": "unsigned long\nmpz_tdiv_q_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_cdiv_r_ui": {
      "start_point": [
        2624,
        0
      ],
      "end_point": [
        2628,
        1
      ],
      "content": "unsigned long\nmpz_cdiv_r_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_fdiv_r_ui": {
      "start_point": [
        2629,
        0
      ],
      "end_point": [
        2633,
        1
      ],
      "content": "unsigned long\nmpz_fdiv_r_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_tdiv_r_ui": {
      "start_point": [
        2634,
        0
      ],
      "end_point": [
        2638,
        1
      ],
      "content": "unsigned long\nmpz_tdiv_r_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_cdiv_ui": {
      "start_point": [
        2640,
        0
      ],
      "end_point": [
        2644,
        1
      ],
      "content": "unsigned long\nmpz_cdiv_ui (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_fdiv_ui": {
      "start_point": [
        2646,
        0
      ],
      "end_point": [
        2650,
        1
      ],
      "content": "unsigned long\nmpz_fdiv_ui (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_tdiv_ui": {
      "start_point": [
        2652,
        0
      ],
      "end_point": [
        2656,
        1
      ],
      "content": "unsigned long\nmpz_tdiv_ui (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_mod_ui": {
      "start_point": [
        2658,
        0
      ],
      "end_point": [
        2662,
        1
      ],
      "content": "unsigned long\nmpz_mod_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_divexact_ui": {
      "start_point": [
        2664,
        0
      ],
      "end_point": [
        2668,
        1
      ],
      "content": "void\nmpz_divexact_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  gmp_assert_nocarry (mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_TRUNC));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_divisible_ui_p": {
      "start_point": [
        2670,
        0
      ],
      "end_point": [
        2674,
        1
      ],
      "content": "int\nmpz_divisible_ui_p (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_TRUNC) == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mpn_gcd_11": {
      "start_point": [
        2678,
        0
      ],
      "end_point": [
        2719,
        1
      ],
      "content": "static mp_limb_t\nmpn_gcd_11 (mp_limb_t u, mp_limb_t v)\n{\n  unsigned shift;\n\n  assert ( (u | v) > 0);\n\n  if (u == 0)\n    return v;\n  else if (v == 0)\n    return u;\n\n  gmp_ctz (shift, u | v);\n\n  u >>= shift;\n  v >>= shift;\n\n  if ( (u & 1) == 0)\n    MP_LIMB_T_SWAP (u, v);\n\n  while ( (v & 1) == 0)\n    v >>= 1;\n\n  while (u != v)\n    {\n      if (u > v)\n\t{\n\t  u -= v;\n\t  do\n\t    u >>= 1;\n\t  while ( (u & 1) == 0);\n\t}\n      else\n\t{\n\t  v -= u;\n\t  do\n\t    v >>= 1;\n\t  while ( (v & 1) == 0);\n\t}\n    }\n  return u << shift;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpz_gcd_ui": {
      "start_point": [
        2721,
        0
      ],
      "end_point": [
        2742,
        1
      ],
      "content": "unsigned long\nmpz_gcd_ui (mpz_t g, const mpz_t u, unsigned long v)\n{\n  mp_size_t un;\n\n  if (v == 0)\n    {\n      if (g)\n\tmpz_abs (g, u);\n    }\n  else\n    {\n      un = GMP_ABS (u->_mp_size);\n      if (un != 0)\n\tv = mpn_gcd_11 (mpn_div_qr_1 (NULL, u->_mp_d, un, v), v);\n\n      if (g)\n\tmpz_set_ui (g, v);\n    }\n\n  return v;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_make_odd": {
      "start_point": [
        2744,
        0
      ],
      "end_point": [
        2755,
        1
      ],
      "content": "static mp_bitcnt_t\nmpz_make_odd (mpz_t r)\n{\n  mp_bitcnt_t shift;\n\n  assert (r->_mp_size > 0);\n  /* Count trailing zeros, equivalent to mpn_scan1, because we know that there is a 1 */\n  shift = mpn_common_scan (r->_mp_d[0], 0, r->_mp_d, 0, 0);\n  mpz_tdiv_q_2exp (r, r, shift);\n\n  return shift;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_bitcnt_t"
      ]
    },
    "mpz_gcd": {
      "start_point": [
        2757,
        0
      ],
      "end_point": [
        2818,
        1
      ],
      "content": "void\nmpz_gcd (mpz_t g, const mpz_t u, const mpz_t v)\n{\n  mpz_t tu, tv;\n  mp_bitcnt_t uz, vz, gz;\n\n  if (u->_mp_size == 0)\n    {\n      mpz_abs (g, v);\n      return;\n    }\n  if (v->_mp_size == 0)\n    {\n      mpz_abs (g, u);\n      return;\n    }\n\n  mpz_init (tu);\n  mpz_init (tv);\n\n  mpz_abs (tu, u);\n  uz = mpz_make_odd (tu);\n  mpz_abs (tv, v);\n  vz = mpz_make_odd (tv);\n  gz = GMP_MIN (uz, vz);\n\n  if (tu->_mp_size < tv->_mp_size)\n    mpz_swap (tu, tv);\n\n  mpz_tdiv_r (tu, tu, tv);\n  if (tu->_mp_size == 0)\n    {\n      mpz_swap (g, tv);\n    }\n  else\n    for (;;)\n      {\n\tint c;\n\n\tmpz_make_odd (tu);\n\tc = mpz_cmp (tu, tv);\n\tif (c == 0)\n\t  {\n\t    mpz_swap (g, tu);\n\t    break;\n\t  }\n\tif (c < 0)\n\t  mpz_swap (tu, tv);\n\n\tif (tv->_mp_size == 1)\n\t  {\n\t    mp_limb_t vl = tv->_mp_d[0];\n\t    mp_limb_t ul = mpz_tdiv_ui (tu, vl);\n\t    mpz_set_ui (g, mpn_gcd_11 (ul, vl));\n\t    break;\n\t  }\n\tmpz_sub (tu, tu, tv);\n      }\n  mpz_clear (tu);\n  mpz_clear (tv);\n  mpz_mul_2exp (g, g, gz);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mpz_gcdext": {
      "start_point": [
        2820,
        0
      ],
      "end_point": [
        3000,
        1
      ],
      "content": "void\nmpz_gcdext (mpz_t g, mpz_t s, mpz_t t, const mpz_t u, const mpz_t v)\n{\n  mpz_t tu, tv, s0, s1, t0, t1;\n  mp_bitcnt_t uz, vz, gz;\n  mp_bitcnt_t power;\n\n  if (u->_mp_size == 0)\n    {\n      /* g = 0 u + sgn(v) v */\n      signed long sign = mpz_sgn (v);\n      mpz_abs (g, v);\n      if (s)\n\tmpz_set_ui (s, 0);\n      if (t)\n\tmpz_set_si (t, sign);\n      return;\n    }\n\n  if (v->_mp_size == 0)\n    {\n      /* g = sgn(u) u + 0 v */\n      signed long sign = mpz_sgn (u);\n      mpz_abs (g, u);\n      if (s)\n\tmpz_set_si (s, sign);\n      if (t)\n\tmpz_set_ui (t, 0);\n      return;\n    }\n\n  mpz_init (tu);\n  mpz_init (tv);\n  mpz_init (s0);\n  mpz_init (s1);\n  mpz_init (t0);\n  mpz_init (t1);\n\n  mpz_abs (tu, u);\n  uz = mpz_make_odd (tu);\n  mpz_abs (tv, v);\n  vz = mpz_make_odd (tv);\n  gz = GMP_MIN (uz, vz);\n\n  uz -= gz;\n  vz -= gz;\n\n  /* Cofactors corresponding to odd gcd. gz handled later. */\n  if (tu->_mp_size < tv->_mp_size)\n    {\n      mpz_swap (tu, tv);\n      MPZ_SRCPTR_SWAP (u, v);\n      MPZ_PTR_SWAP (s, t);\n      MP_BITCNT_T_SWAP (uz, vz);\n    }\n\n  /* Maintain\n   *\n   * u = t0 tu + t1 tv\n   * v = s0 tu + s1 tv\n   *\n   * where u and v denote the inputs with common factors of two\n   * eliminated, and det (s0, t0; s1, t1) = 2^p. Then\n   *\n   * 2^p tu =  s1 u - t1 v\n   * 2^p tv = -s0 u + t0 v\n   */\n\n  /* After initial division, tu = q tv + tu', we have\n   *\n   * u = 2^uz (tu' + q tv)\n   * v = 2^vz tv\n   *\n   * or\n   *\n   * t0 = 2^uz, t1 = 2^uz q\n   * s0 = 0,    s1 = 2^vz\n   */\n\n  mpz_setbit (t0, uz);\n  mpz_tdiv_qr (t1, tu, tu, tv);\n  mpz_mul_2exp (t1, t1, uz);\n\n  mpz_setbit (s1, vz);\n  power = uz + vz;\n\n  if (tu->_mp_size > 0)\n    {\n      mp_bitcnt_t shift;\n      shift = mpz_make_odd (tu);\n      mpz_mul_2exp (t0, t0, shift);\n      mpz_mul_2exp (s0, s0, shift);\n      power += shift;\n\n      for (;;)\n\t{\n\t  int c;\n\t  c = mpz_cmp (tu, tv);\n\t  if (c == 0)\n\t    break;\n\n\t  if (c < 0)\n\t    {\n\t      /* tv = tv' + tu\n\t       *\n\t       * u = t0 tu + t1 (tv' + tu) = (t0 + t1) tu + t1 tv'\n\t       * v = s0 tu + s1 (tv' + tu) = (s0 + s1) tu + s1 tv' */\n\n\t      mpz_sub (tv, tv, tu);\n\t      mpz_add (t0, t0, t1);\n\t      mpz_add (s0, s0, s1);\n\n\t      shift = mpz_make_odd (tv);\n\t      mpz_mul_2exp (t1, t1, shift);\n\t      mpz_mul_2exp (s1, s1, shift);\n\t    }\n\t  else\n\t    {\n\t      mpz_sub (tu, tu, tv);\n\t      mpz_add (t1, t0, t1);\n\t      mpz_add (s1, s0, s1);\n\n\t      shift = mpz_make_odd (tu);\n\t      mpz_mul_2exp (t0, t0, shift);\n\t      mpz_mul_2exp (s0, s0, shift);\n\t    }\n\t  power += shift;\n\t}\n    }\n\n  /* Now tv = odd part of gcd, and -s0 and t0 are corresponding\n     cofactors. */\n\n  mpz_mul_2exp (tv, tv, gz);\n  mpz_neg (s0, s0);\n\n  /* 2^p g = s0 u + t0 v. Eliminate one factor of two at a time. To\n     adjust cofactors, we need u / g and v / g */\n\n  mpz_divexact (s1, v, tv);\n  mpz_abs (s1, s1);\n  mpz_divexact (t1, u, tv);\n  mpz_abs (t1, t1);\n\n  while (power-- > 0)\n    {\n      /* s0 u + t0 v = (s0 - v/g) u - (t0 + u/g) v */\n      if (mpz_odd_p (s0) || mpz_odd_p (t0))\n\t{\n\t  mpz_sub (s0, s0, s1);\n\t  mpz_add (t0, t0, t1);\n\t}\n      mpz_divexact_ui (s0, s0, 2);\n      mpz_divexact_ui (t0, t0, 2);\n    }\n\n  /* Arrange so that |s| < |u| / 2g */\n  mpz_add (s1, s0, s1);\n  if (mpz_cmpabs (s0, s1) > 0)\n    {\n      mpz_swap (s0, s1);\n      mpz_sub (t0, t0, t1);\n    }\n  if (u->_mp_size < 0)\n    mpz_neg (s0, s0);\n  if (v->_mp_size < 0)\n    mpz_neg (t0, t0);\n\n  mpz_swap (g, tv);\n  if (s)\n    mpz_swap (s, s0);\n  if (t)\n    mpz_swap (t, t0);\n\n  mpz_clear (tu);\n  mpz_clear (tv);\n  mpz_clear (s0);\n  mpz_clear (s1);\n  mpz_clear (t0);\n  mpz_clear (t1);\n}",
      "lines": 181,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mpz_lcm": {
      "start_point": [
        3002,
        0
      ],
      "end_point": [
        3021,
        1
      ],
      "content": "void\nmpz_lcm (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mpz_t g;\n\n  if (u->_mp_size == 0 || v->_mp_size == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  mpz_init (g);\n\n  mpz_gcd (g, u, v);\n  mpz_divexact (g, u, g);\n  mpz_mul (r, g, v);\n\n  mpz_clear (g);\n  mpz_abs (r, r);\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_lcm_ui": {
      "start_point": [
        3023,
        0
      ],
      "end_point": [
        3036,
        1
      ],
      "content": "void\nmpz_lcm_ui (mpz_t r, const mpz_t u, unsigned long v)\n{\n  if (v == 0 || u->_mp_size == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  v /= mpz_gcd_ui (NULL, u, v);\n  mpz_mul_ui (r, u, v);\n\n  mpz_abs (r, r);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_invert": {
      "start_point": [
        3038,
        0
      ],
      "end_point": [
        3068,
        1
      ],
      "content": "int\nmpz_invert (mpz_t r, const mpz_t u, const mpz_t m)\n{\n  mpz_t g, tr;\n  int invertible;\n\n  if (u->_mp_size == 0 || mpz_cmpabs_ui (m, 1) <= 0)\n    return 0;\n\n  mpz_init (g);\n  mpz_init (tr);\n\n  mpz_gcdext (g, tr, NULL, u, m);\n  invertible = (mpz_cmp_ui (g, 1) == 0);\n\n  if (invertible)\n    {\n      if (tr->_mp_size < 0)\n\t{\n\t  if (m->_mp_size >= 0)\n\t    mpz_add (tr, tr, m);\n\t  else\n\t    mpz_sub (tr, tr, m);\n\t}\n      mpz_swap (r, tr);\n    }\n\n  mpz_clear (g);\n  mpz_clear (tr);\n  return invertible;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "mpz_pow_ui": {
      "start_point": [
        3073,
        0
      ],
      "end_point": [
        3092,
        1
      ],
      "content": "void\nmpz_pow_ui (mpz_t r, const mpz_t b, unsigned long e)\n{\n  unsigned long bit;\n  mpz_t tr;\n  mpz_init_set_ui (tr, 1);\n\n  bit = GMP_ULONG_HIGHBIT;\n  do\n    {\n      mpz_mul (tr, tr, tr);\n      if (e & bit)\n\tmpz_mul (tr, tr, b);\n      bit >>= 1;\n    }\n  while (bit > 0);\n\n  mpz_swap (r, tr);\n  mpz_clear (tr);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_ui_pow_ui": {
      "start_point": [
        3094,
        0
      ],
      "end_point": [
        3099,
        1
      ],
      "content": "void\nmpz_ui_pow_ui (mpz_t r, unsigned long blimb, unsigned long e)\n{\n  mpz_t b;\n  mpz_pow_ui (r, mpz_roinit_n (b, &blimb, 1), e);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_powm": {
      "start_point": [
        3101,
        0
      ],
      "end_point": [
        3204,
        1
      ],
      "content": "void\nmpz_powm (mpz_t r, const mpz_t b, const mpz_t e, const mpz_t m)\n{\n  mpz_t tr;\n  mpz_t base;\n  mp_size_t en, mn;\n  mp_srcptr mp;\n  struct gmp_div_inverse minv;\n  unsigned shift;\n  mp_ptr tp = NULL;\n\n  en = GMP_ABS (e->_mp_size);\n  mn = GMP_ABS (m->_mp_size);\n  if (mn == 0)\n    gmp_die (\"mpz_powm: Zero modulo.\");\n\n  if (en == 0)\n    {\n      mpz_set_ui (r, 1);\n      return;\n    }\n\n  mp = m->_mp_d;\n  mpn_div_qr_invert (&minv, mp, mn);\n  shift = minv.shift;\n\n  if (shift > 0)\n    {\n      /* To avoid shifts, we do all our reductions, except the final\n\t one, using a *normalized* m. */\n      minv.shift = 0;\n\n      tp = gmp_xalloc_limbs (mn);\n      gmp_assert_nocarry (mpn_lshift (tp, mp, mn, shift));\n      mp = tp;\n    }\n\n  mpz_init (base);\n\n  if (e->_mp_size < 0)\n    {\n      if (!mpz_invert (base, b, m))\n\tgmp_die (\"mpz_powm: Negative exponent and non-invertible base.\");\n    }\n  else\n    {\n      mp_size_t bn;\n      mpz_abs (base, b);\n\n      bn = base->_mp_size;\n      if (bn >= mn)\n\t{\n\t  mpn_div_qr_preinv (NULL, base->_mp_d, base->_mp_size, mp, mn, &minv);\n\t  bn = mn;\n\t}\n\n      /* We have reduced the absolute value. Now take care of the\n\t sign. Note that we get zero represented non-canonically as\n\t m. */\n      if (b->_mp_size < 0)\n\t{\n\t  mp_ptr bp = MPZ_REALLOC (base, mn);\n\t  gmp_assert_nocarry (mpn_sub (bp, mp, mn, bp, bn));\n\t  bn = mn;\n\t}\n      base->_mp_size = mpn_normalized_size (base->_mp_d, bn);\n    }\n  mpz_init_set_ui (tr, 1);\n\n  while (--en >= 0)\n    {\n      mp_limb_t w = e->_mp_d[en];\n      mp_limb_t bit;\n\n      bit = GMP_LIMB_HIGHBIT;\n      do\n\t{\n\t  mpz_mul (tr, tr, tr);\n\t  if (w & bit)\n\t    mpz_mul (tr, tr, base);\n\t  if (tr->_mp_size > mn)\n\t    {\n\t      mpn_div_qr_preinv (NULL, tr->_mp_d, tr->_mp_size, mp, mn, &minv);\n\t      tr->_mp_size = mpn_normalized_size (tr->_mp_d, mn);\n\t    }\n\t  bit >>= 1;\n\t}\n      while (bit > 0);\n    }\n\n  /* Final reduction */\n  if (tr->_mp_size >= mn)\n    {\n      minv.shift = shift;\n      mpn_div_qr_preinv (NULL, tr->_mp_d, tr->_mp_size, mp, mn, &minv);\n      tr->_mp_size = mpn_normalized_size (tr->_mp_d, mn);\n    }\n  if (tp)\n    gmp_free (tp);\n\n  mpz_swap (r, tr);\n  mpz_clear (tr);\n  mpz_clear (base);\n}",
      "lines": 104,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "mpz_powm_ui": {
      "start_point": [
        3206,
        0
      ],
      "end_point": [
        3211,
        1
      ],
      "content": "void\nmpz_powm_ui (mpz_t r, const mpz_t b, unsigned long elimb, const mpz_t m)\n{\n  mpz_t e;\n  mpz_powm (r, b, mpz_roinit_n (e, &elimb, 1), m);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_rootrem": {
      "start_point": [
        3214,
        0
      ],
      "end_point": [
        3272,
        1
      ],
      "content": "void\nmpz_rootrem (mpz_t x, mpz_t r, const mpz_t y, unsigned long z)\n{\n  int sgn;\n  mpz_t t, u;\n\n  sgn = y->_mp_size < 0;\n  if ((~z & sgn) != 0)\n    gmp_die (\"mpz_rootrem: Negative argument, with even root.\");\n  if (z == 0)\n    gmp_die (\"mpz_rootrem: Zeroth root.\");\n\n  if (mpz_cmpabs_ui (y, 1) <= 0) {\n    if (x)\n      mpz_set (x, y);\n    if (r)\n      r->_mp_size = 0;\n    return;\n  }\n\n  mpz_init (u);\n  mpz_init (t);\n  mpz_setbit (t, mpz_sizeinbase (y, 2) / z + 1);\n\n  if (z == 2) /* simplify sqrt loop: z-1 == 1 */\n    do {\n      mpz_swap (u, t);\t\t\t/* u = x */\n      mpz_tdiv_q (t, y, u);\t\t/* t = y/x */\n      mpz_add (t, t, u);\t\t/* t = y/x + x */\n      mpz_tdiv_q_2exp (t, t, 1);\t/* x'= (y/x + x)/2 */\n    } while (mpz_cmpabs (t, u) < 0);\t/* |x'| < |x| */\n  else /* z != 2 */ {\n    mpz_t v;\n\n    mpz_init (v);\n    if (sgn)\n      mpz_neg (t, t);\n\n    do {\n      mpz_swap (u, t);\t\t\t/* u = x */\n      mpz_pow_ui (t, u, z - 1);\t\t/* t = x^(z-1) */\n      mpz_tdiv_q (t, y, t);\t\t/* t = y/x^(z-1) */\n      mpz_mul_ui (v, u, z - 1);\t\t/* v = x*(z-1) */\n      mpz_add (t, t, v);\t\t/* t = y/x^(z-1) + x*(z-1) */\n      mpz_tdiv_q_ui (t, t, z);\t\t/* x'=(y/x^(z-1) + x*(z-1))/z */\n    } while (mpz_cmpabs (t, u) < 0);\t/* |x'| < |x| */\n\n    mpz_clear (v);\n  }\n\n  if (r) {\n    mpz_pow_ui (t, u, z);\n    mpz_sub (r, y, t);\n  }\n  if (x)\n    mpz_swap (x, u);\n  mpz_clear (u);\n  mpz_clear (t);\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "mpz_root": {
      "start_point": [
        3274,
        0
      ],
      "end_point": [
        3286,
        1
      ],
      "content": "int\nmpz_root (mpz_t x, const mpz_t y, unsigned long z)\n{\n  int res;\n  mpz_t r;\n\n  mpz_init (r);\n  mpz_rootrem (x, r, y, z);\n  res = r->_mp_size == 0;\n  mpz_clear (r);\n\n  return res;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mpz_sqrtrem": {
      "start_point": [
        3289,
        0
      ],
      "end_point": [
        3293,
        1
      ],
      "content": "void\nmpz_sqrtrem (mpz_t s, mpz_t r, const mpz_t u)\n{\n  mpz_rootrem (s, r, u, 2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_sqrt": {
      "start_point": [
        3295,
        0
      ],
      "end_point": [
        3299,
        1
      ],
      "content": "void\nmpz_sqrt (mpz_t s, const mpz_t u)\n{\n  mpz_rootrem (s, NULL, u, 2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_perfect_square_p": {
      "start_point": [
        3301,
        0
      ],
      "end_point": [
        3308,
        1
      ],
      "content": "int\nmpz_perfect_square_p (const mpz_t u)\n{\n  if (u->_mp_size <= 0)\n    return (u->_mp_size == 0);\n  else\n    return mpz_root (NULL, u, 2);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mpn_perfect_square_p": {
      "start_point": [
        3310,
        0
      ],
      "end_point": [
        3318,
        1
      ],
      "content": "int\nmpn_perfect_square_p (mp_srcptr p, mp_size_t n)\n{\n  mpz_t t;\n\n  assert (n > 0);\n  assert (p [n-1] != 0);\n  return mpz_root (NULL, mpz_roinit_n (t, p, n), 2);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpn_sqrtrem": {
      "start_point": [
        3320,
        0
      ],
      "end_point": [
        3341,
        1
      ],
      "content": "mp_size_t\nmpn_sqrtrem (mp_ptr sp, mp_ptr rp, mp_srcptr p, mp_size_t n)\n{\n  mpz_t s, r, u;\n  mp_size_t res;\n\n  assert (n > 0);\n  assert (p [n-1] != 0);\n\n  mpz_init (r);\n  mpz_init (s);\n  mpz_rootrem (s, r, mpz_roinit_n (u, p, n), 2);\n\n  assert (s->_mp_size == (n+1)/2);\n  mpn_copyd (sp, s->_mp_d, s->_mp_size);\n  mpz_clear (s);\n  res = r->_mp_size;\n  if (rp)\n    mpn_copyd (rp, r->_mp_d, res);\n  mpz_clear (r);\n  return res;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpz_fac_ui": {
      "start_point": [
        3345,
        0
      ],
      "end_point": [
        3351,
        1
      ],
      "content": "void\nmpz_fac_ui (mpz_t x, unsigned long n)\n{\n  mpz_set_ui (x, n + (n == 0));\n  while (n > 2)\n    mpz_mul_ui (x, x, --n);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_bin_uiui": {
      "start_point": [
        3353,
        0
      ],
      "end_point": [
        3371,
        1
      ],
      "content": "void\nmpz_bin_uiui (mpz_t r, unsigned long n, unsigned long k)\n{\n  mpz_t t;\n\n  mpz_set_ui (r, k <= n);\n\n  if (k > (n >> 1))\n    k = (k <= n) ? n - k : 0;\n\n  mpz_init (t);\n  mpz_fac_ui (t, k);\n\n  for (; k > 0; k--)\n      mpz_mul_ui (r, r, n--);\n\n  mpz_divexact (r, r, t);\n  mpz_clear (t);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gmp_millerrabin": {
      "start_point": [
        3375,
        0
      ],
      "end_point": [
        3399,
        1
      ],
      "content": "static int\ngmp_millerrabin (const mpz_t n, const mpz_t nm1, mpz_t y,\n\t\t const mpz_t q, mp_bitcnt_t k)\n{\n  assert (k > 0);\n\n  /* Caller must initialize y to the base. */\n  mpz_powm (y, y, q, n);\n\n  if (mpz_cmp_ui (y, 1) == 0 || mpz_cmp (y, nm1) == 0)\n    return 1;\n\n  while (--k > 0)\n    {\n      mpz_powm_ui (y, y, 2, n);\n      if (mpz_cmp (y, nm1) == 0)\n\treturn 1;\n      /* y == 1 means that the previous y was a non-trivial square root\n\t of 1 (mod n). y == 0 means that n is a power of the base.\n\t In either case, n is not prime. */\n      if (mpz_cmp_ui (y, 1) <= 0)\n\treturn 0;\n    }\n  return 0;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpz_probab_prime_p": {
      "start_point": [
        3408,
        0
      ],
      "end_point": [
        3467,
        1
      ],
      "content": "int\nmpz_probab_prime_p (const mpz_t n, int reps)\n{\n  mpz_t nm1;\n  mpz_t q;\n  mpz_t y;\n  mp_bitcnt_t k;\n  int is_prime;\n  int j;\n\n  /* Note that we use the absolute value of n only, for compatibility\n     with the real GMP. */\n  if (mpz_even_p (n))\n    return (mpz_cmpabs_ui (n, 2) == 0) ? 2 : 0;\n\n  /* Above test excludes n == 0 */\n  assert (n->_mp_size != 0);\n\n  if (mpz_cmpabs_ui (n, 64) < 0)\n    return (GMP_PRIME_MASK >> (n->_mp_d[0] >> 1)) & 2;\n\n  if (mpz_gcd_ui (NULL, n, GMP_PRIME_PRODUCT) != 1)\n    return 0;\n\n  /* All prime factors are >= 31. */\n  if (mpz_cmpabs_ui (n, 31*31) < 0)\n    return 2;\n\n  /* Use Miller-Rabin, with a deterministic sequence of bases, a[j] =\n     j^2 + j + 41 using Euler's polynomial. We potentially stop early,\n     if a[j] >= n - 1. Since n >= 31*31, this can happen only if reps >\n     30 (a[30] == 971 > 31*31 == 961). */\n\n  mpz_init (nm1);\n  mpz_init (q);\n  mpz_init (y);\n\n  /* Find q and k, where q is odd and n = 1 + 2**k * q.  */\n  nm1->_mp_size = mpz_abs_sub_ui (nm1, n, 1);\n  k = mpz_scan1 (nm1, 0);\n  mpz_tdiv_q_2exp (q, nm1, k);\n\n  for (j = 0, is_prime = 1; is_prime & (j < reps); j++)\n    {\n      mpz_set_ui (y, (unsigned long) j*j+j+41);\n      if (mpz_cmp (y, nm1) >= 0)\n\t{\n\t  /* Don't try any further bases. This \"early\" break does not affect\n\t     the result for any reasonable reps value (<=5000 was tested) */\n\t  assert (j >= 30);\n\t  break;\n\t}\n      is_prime = gmp_millerrabin (n, nm1, y, q, k);\n    }\n  mpz_clear (nm1);\n  mpz_clear (q);\n  mpz_clear (y);\n\n  return is_prime;\n}",
      "lines": 60,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "mpz_tstbit": {
      "start_point": [
        3494,
        0
      ],
      "end_point": [
        3525,
        1
      ],
      "content": "int\nmpz_tstbit (const mpz_t d, mp_bitcnt_t bit_index)\n{\n  mp_size_t limb_index;\n  unsigned shift;\n  mp_size_t ds;\n  mp_size_t dn;\n  mp_limb_t w;\n  int bit;\n\n  ds = d->_mp_size;\n  dn = GMP_ABS (ds);\n  limb_index = bit_index / GMP_LIMB_BITS;\n  if (limb_index >= dn)\n    return ds < 0;\n\n  shift = bit_index % GMP_LIMB_BITS;\n  w = d->_mp_d[limb_index];\n  bit = (w >> shift) & 1;\n\n  if (ds < 0)\n    {\n      /* d < 0. Check if any of the bits below is set: If so, our bit\n\t must be complemented. */\n      if (shift > 0 && (w << (GMP_LIMB_BITS - shift)) > 0)\n\treturn bit ^ 1;\n      while (--limb_index >= 0)\n\tif (d->_mp_d[limb_index] > 0)\n\t  return bit ^ 1;\n    }\n  return bit;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "mpz_abs_add_bit": {
      "start_point": [
        3527,
        0
      ],
      "end_point": [
        3566,
        1
      ],
      "content": "static void\nmpz_abs_add_bit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  mp_size_t dn, limb_index;\n  mp_limb_t bit;\n  mp_ptr dp;\n\n  dn = GMP_ABS (d->_mp_size);\n\n  limb_index = bit_index / GMP_LIMB_BITS;\n  bit = (mp_limb_t) 1 << (bit_index % GMP_LIMB_BITS);\n\n  if (limb_index >= dn)\n    {\n      mp_size_t i;\n      /* The bit should be set outside of the end of the number.\n\t We have to increase the size of the number. */\n      dp = MPZ_REALLOC (d, limb_index + 1);\n\n      dp[limb_index] = bit;\n      for (i = dn; i < limb_index; i++)\n\tdp[i] = 0;\n      dn = limb_index + 1;\n    }\n  else\n    {\n      mp_limb_t cy;\n\n      dp = d->_mp_d;\n\n      cy = mpn_add_1 (dp + limb_index, dp + limb_index, dn - limb_index, bit);\n      if (cy > 0)\n\t{\n\t  dp = MPZ_REALLOC (d, dn + 1);\n\t  dp[dn++] = cy;\n\t}\n    }\n\n  d->_mp_size = (d->_mp_size < 0) ? - dn : dn;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_abs_sub_bit": {
      "start_point": [
        3568,
        0
      ],
      "end_point": [
        3587,
        1
      ],
      "content": "static void\nmpz_abs_sub_bit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  mp_size_t dn, limb_index;\n  mp_ptr dp;\n  mp_limb_t bit;\n\n  dn = GMP_ABS (d->_mp_size);\n  dp = d->_mp_d;\n\n  limb_index = bit_index / GMP_LIMB_BITS;\n  bit = (mp_limb_t) 1 << (bit_index % GMP_LIMB_BITS);\n\n  assert (limb_index < dn);\n\n  gmp_assert_nocarry (mpn_sub_1 (dp + limb_index, dp + limb_index,\n\t\t\t\t dn - limb_index, bit));\n  dn = mpn_normalized_size (dp, dn);\n  d->_mp_size = (d->_mp_size < 0) ? - dn : dn;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_setbit": {
      "start_point": [
        3589,
        0
      ],
      "end_point": [
        3599,
        1
      ],
      "content": "void\nmpz_setbit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  if (!mpz_tstbit (d, bit_index))\n    {\n      if (d->_mp_size >= 0)\n\tmpz_abs_add_bit (d, bit_index);\n      else\n\tmpz_abs_sub_bit (d, bit_index);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_clrbit": {
      "start_point": [
        3601,
        0
      ],
      "end_point": [
        3611,
        1
      ],
      "content": "void\nmpz_clrbit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  if (mpz_tstbit (d, bit_index))\n    {\n      if (d->_mp_size >= 0)\n\tmpz_abs_sub_bit (d, bit_index);\n      else\n\tmpz_abs_add_bit (d, bit_index);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_combit": {
      "start_point": [
        3613,
        0
      ],
      "end_point": [
        3620,
        1
      ],
      "content": "void\nmpz_combit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  if (mpz_tstbit (d, bit_index) ^ (d->_mp_size < 0))\n    mpz_abs_sub_bit (d, bit_index);\n  else\n    mpz_abs_add_bit (d, bit_index);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_com": {
      "start_point": [
        3622,
        0
      ],
      "end_point": [
        3627,
        1
      ],
      "content": "void\nmpz_com (mpz_t r, const mpz_t u)\n{\n  mpz_neg (r, u);\n  mpz_sub_ui (r, r, 1);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_and": {
      "start_point": [
        3629,
        0
      ],
      "end_point": [
        3699,
        1
      ],
      "content": "void\nmpz_and (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, rn, i;\n  mp_ptr up, vp, rp;\n\n  mp_limb_t ux, vx, rx;\n  mp_limb_t uc, vc, rc;\n  mp_limb_t ul, vl, rl;\n\n  un = GMP_ABS (u->_mp_size);\n  vn = GMP_ABS (v->_mp_size);\n  if (un < vn)\n    {\n      MPZ_SRCPTR_SWAP (u, v);\n      MP_SIZE_T_SWAP (un, vn);\n    }\n  if (vn == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  uc = u->_mp_size < 0;\n  vc = v->_mp_size < 0;\n  rc = uc & vc;\n\n  ux = -uc;\n  vx = -vc;\n  rx = -rc;\n\n  /* If the smaller input is positive, higher limbs don't matter. */\n  rn = vx ? un : vn;\n\n  rp = MPZ_REALLOC (r, rn + (mp_size_t) rc);\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  i = 0;\n  do\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ vx) + vc;\n      vc = vl < vc;\n\n      rl = ( (ul & vl) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  while (++i < vn);\n  assert (vc == 0);\n\n  for (; i < rn; i++)\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      rl = ( (ul & vx) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  if (rc)\n    rp[rn++] = rc;\n  else\n    rn = mpn_normalized_size (rp, rn);\n\n  r->_mp_size = rx ? -rn : rn;\n}",
      "lines": 71,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpz_ior": {
      "start_point": [
        3701,
        0
      ],
      "end_point": [
        3772,
        1
      ],
      "content": "void\nmpz_ior (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, rn, i;\n  mp_ptr up, vp, rp;\n\n  mp_limb_t ux, vx, rx;\n  mp_limb_t uc, vc, rc;\n  mp_limb_t ul, vl, rl;\n\n  un = GMP_ABS (u->_mp_size);\n  vn = GMP_ABS (v->_mp_size);\n  if (un < vn)\n    {\n      MPZ_SRCPTR_SWAP (u, v);\n      MP_SIZE_T_SWAP (un, vn);\n    }\n  if (vn == 0)\n    {\n      mpz_set (r, u);\n      return;\n    }\n\n  uc = u->_mp_size < 0;\n  vc = v->_mp_size < 0;\n  rc = uc | vc;\n\n  ux = -uc;\n  vx = -vc;\n  rx = -rc;\n\n  /* If the smaller input is negative, by sign extension higher limbs\n     don't matter. */\n  rn = vx ? vn : un;\n\n  rp = MPZ_REALLOC (r, rn + (mp_size_t) rc);\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  i = 0;\n  do\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ vx) + vc;\n      vc = vl < vc;\n\n      rl = ( (ul | vl) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  while (++i < vn);\n  assert (vc == 0);\n\n  for (; i < rn; i++)\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      rl = ( (ul | vx) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  if (rc)\n    rp[rn++] = rc;\n  else\n    rn = mpn_normalized_size (rp, rn);\n\n  r->_mp_size = rx ? -rn : rn;\n}",
      "lines": 72,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpz_xor": {
      "start_point": [
        3774,
        0
      ],
      "end_point": [
        3841,
        1
      ],
      "content": "void\nmpz_xor (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, i;\n  mp_ptr up, vp, rp;\n\n  mp_limb_t ux, vx, rx;\n  mp_limb_t uc, vc, rc;\n  mp_limb_t ul, vl, rl;\n\n  un = GMP_ABS (u->_mp_size);\n  vn = GMP_ABS (v->_mp_size);\n  if (un < vn)\n    {\n      MPZ_SRCPTR_SWAP (u, v);\n      MP_SIZE_T_SWAP (un, vn);\n    }\n  if (vn == 0)\n    {\n      mpz_set (r, u);\n      return;\n    }\n\n  uc = u->_mp_size < 0;\n  vc = v->_mp_size < 0;\n  rc = uc ^ vc;\n\n  ux = -uc;\n  vx = -vc;\n  rx = -rc;\n\n  rp = MPZ_REALLOC (r, un + (mp_size_t) rc);\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  i = 0;\n  do\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ vx) + vc;\n      vc = vl < vc;\n\n      rl = (ul ^ vl ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  while (++i < vn);\n  assert (vc == 0);\n\n  for (; i < un; i++)\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      rl = (ul ^ ux) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  if (rc)\n    rp[un++] = rc;\n  else\n    un = mpn_normalized_size (rp, un);\n\n  r->_mp_size = rx ? -un : un;\n}",
      "lines": 68,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "gmp_popcount_limb": {
      "start_point": [
        3843,
        0
      ],
      "end_point": [
        3858,
        1
      ],
      "content": "static unsigned\ngmp_popcount_limb (mp_limb_t x)\n{\n  unsigned c;\n\n  /* Do 16 bits at a time, to avoid limb-sized constants. */\n  for (c = 0; x > 0; x >>= 16)\n    {\n      unsigned w = ((x >> 1) & 0x5555) + (x & 0x5555);\n      w = ((w >> 2) & 0x3333) + (w & 0x3333);\n      w = ((w >> 4) & 0x0f0f) + (w & 0x0f0f);\n      w = (w >> 8) + (w & 0x00ff);\n      c += w;\n    }\n  return c;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "mpn_popcount": {
      "start_point": [
        3860,
        0
      ],
      "end_point": [
        3870,
        1
      ],
      "content": "mp_bitcnt_t\nmpn_popcount (mp_srcptr p, mp_size_t n)\n{\n  mp_size_t i;\n  mp_bitcnt_t c;\n\n  for (c = 0, i = 0; i < n; i++)\n    c += gmp_popcount_limb (p[i]);\n\n  return c;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpz_popcount": {
      "start_point": [
        3872,
        0
      ],
      "end_point": [
        3883,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_popcount (const mpz_t u)\n{\n  mp_size_t un;\n\n  un = u->_mp_size;\n\n  if (un < 0)\n    return ~(mp_bitcnt_t) 0;\n\n  return mpn_popcount (u->_mp_d, un);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpz_hamdist": {
      "start_point": [
        3885,
        0
      ],
      "end_point": [
        3934,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_hamdist (const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, i;\n  mp_limb_t uc, vc, ul, vl, comp;\n  mp_srcptr up, vp;\n  mp_bitcnt_t c;\n\n  un = u->_mp_size;\n  vn = v->_mp_size;\n\n  if ( (un ^ vn) < 0)\n    return ~(mp_bitcnt_t) 0;\n\n  comp = - (uc = vc = (un < 0));\n  if (uc)\n    {\n      assert (vn < 0);\n      un = -un;\n      vn = -vn;\n    }\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  if (un < vn)\n    MPN_SRCPTR_SWAP (up, un, vp, vn);\n\n  for (i = 0, c = 0; i < vn; i++)\n    {\n      ul = (up[i] ^ comp) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ comp) + vc;\n      vc = vl < vc;\n\n      c += gmp_popcount_limb (ul ^ vl);\n    }\n  assert (vc == 0);\n\n  for (; i < un; i++)\n    {\n      ul = (up[i] ^ comp) + uc;\n      uc = ul < uc;\n\n      c += gmp_popcount_limb (ul ^ comp);\n    }\n\n  return c;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpz_scan1": {
      "start_point": [
        3936,
        0
      ],
      "end_point": [
        3970,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_scan1 (const mpz_t u, mp_bitcnt_t starting_bit)\n{\n  mp_ptr up;\n  mp_size_t us, un, i;\n  mp_limb_t limb, ux;\n\n  us = u->_mp_size;\n  un = GMP_ABS (us);\n  i = starting_bit / GMP_LIMB_BITS;\n\n  /* Past the end there's no 1 bits for u>=0, or an immediate 1 bit\n     for u<0. Notice this test picks up any u==0 too. */\n  if (i >= un)\n    return (us >= 0 ? ~(mp_bitcnt_t) 0 : starting_bit);\n\n  up = u->_mp_d;\n  ux = 0;\n  limb = up[i];\n\n  if (starting_bit != 0)\n    {\n      if (us < 0)\n\t{\n\t  ux = mpn_zero_p (up, i);\n\t  limb = ~ limb + ux;\n\t  ux = - (mp_limb_t) (limb >= ux);\n\t}\n\n      /* Mask to 0 all bits before starting_bit, thus ignoring them. */\n      limb &= (GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS));\n    }\n\n  return mpn_common_scan (limb, i, up, un, ux);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpz_scan0": {
      "start_point": [
        3972,
        0
      ],
      "end_point": [
        3999,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_scan0 (const mpz_t u, mp_bitcnt_t starting_bit)\n{\n  mp_ptr up;\n  mp_size_t us, un, i;\n  mp_limb_t limb, ux;\n\n  us = u->_mp_size;\n  ux = - (mp_limb_t) (us >= 0);\n  un = GMP_ABS (us);\n  i = starting_bit / GMP_LIMB_BITS;\n\n  /* When past end, there's an immediate 0 bit for u>=0, or no 0 bits for\n     u<0.  Notice this test picks up all cases of u==0 too. */\n  if (i >= un)\n    return (ux ? starting_bit : ~(mp_bitcnt_t) 0);\n\n  up = u->_mp_d;\n  limb = up[i] ^ ux;\n\n  if (ux == 0)\n    limb -= mpn_zero_p (up, i); /* limb = ~(~limb + zero_p) */\n\n  /* Mask all bits before starting_bit, thus ignoring them. */\n  limb &= (GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS));\n\n  return mpn_common_scan (limb, i, up, un, ux);\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpz_sizeinbase": {
      "start_point": [
        4004,
        0
      ],
      "end_point": [
        4055,
        1
      ],
      "content": "size_t\nmpz_sizeinbase (const mpz_t u, int base)\n{\n  mp_size_t un;\n  mp_srcptr up;\n  mp_ptr tp;\n  mp_bitcnt_t bits;\n  struct gmp_div_inverse bi;\n  size_t ndigits;\n\n  assert (base >= 2);\n  assert (base <= 36);\n\n  un = GMP_ABS (u->_mp_size);\n  if (un == 0)\n    return 1;\n\n  up = u->_mp_d;\n\n  bits = (un - 1) * GMP_LIMB_BITS + mpn_limb_size_in_base_2 (up[un-1]);\n  switch (base)\n    {\n    case 2:\n      return bits;\n    case 4:\n      return (bits + 1) / 2;\n    case 8:\n      return (bits + 2) / 3;\n    case 16:\n      return (bits + 3) / 4;\n    case 32:\n      return (bits + 4) / 5;\n      /* FIXME: Do something more clever for the common case of base\n\t 10. */\n    }\n\n  tp = gmp_xalloc_limbs (un);\n  mpn_copyi (tp, up, un);\n  mpn_div_qr_1_invert (&bi, base);\n\n  ndigits = 0;\n  do\n    {\n      ndigits++;\n      mpn_div_qr_1_preinv (tp, tp, un, &bi);\n      un -= (tp[un-1] == 0);\n    }\n  while (un > 0);\n\n  gmp_free (tp);\n  return ndigits;\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "mpz_get_str": {
      "start_point": [
        4057,
        0
      ],
      "end_point": [
        4120,
        1
      ],
      "content": "char *\nmpz_get_str (char *sp, int base, const mpz_t u)\n{\n  unsigned bits;\n  const char *digits;\n  mp_size_t un;\n  size_t i, sn;\n\n  if (base >= 0)\n    {\n      digits = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    }\n  else\n    {\n      base = -base;\n      digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    }\n  if (base <= 1)\n    base = 10;\n  if (base > 36)\n    return NULL;\n\n  sn = 1 + mpz_sizeinbase (u, base);\n  if (!sp)\n    sp = (char *) gmp_xalloc (1 + sn);\n\n  un = GMP_ABS (u->_mp_size);\n\n  if (un == 0)\n    {\n      sp[0] = '0';\n      sp[1] = '\\0';\n      return sp;\n    }\n\n  i = 0;\n\n  if (u->_mp_size < 0)\n    sp[i++] = '-';\n\n  bits = mpn_base_power_of_two_p (base);\n\n  if (bits)\n    /* Not modified in this case. */\n    sn = i + mpn_get_str_bits ((unsigned char *) sp + i, bits, u->_mp_d, un);\n  else\n    {\n      struct mpn_base_info info;\n      mp_ptr tp;\n\n      mpn_get_base_info (&info, base);\n      tp = gmp_xalloc_limbs (un);\n      mpn_copyi (tp, u->_mp_d, un);\n\n      sn = i + mpn_get_str_other ((unsigned char *) sp + i, base, &info, tp, un);\n      gmp_free (tp);\n    }\n\n  for (; i < sn; i++)\n    sp[i] = digits[(unsigned char) sp[i]];\n\n  sp[sn] = '\\0';\n  return sp;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmpz_get_str (char *sp, int base, const mpz_t u)",
        "*"
      ]
    },
    "mpz_set_str": {
      "start_point": [
        4122,
        0
      ],
      "end_point": [
        4224,
        1
      ],
      "content": "int\nmpz_set_str (mpz_t r, const char *sp, int base)\n{\n  unsigned bits;\n  mp_size_t rn, alloc;\n  mp_ptr rp;\n  size_t dn;\n  int sign;\n  unsigned char *dp;\n\n  assert (base == 0 || (base >= 2 && base <= 36));\n\n  while (isspace( (unsigned char) *sp))\n    sp++;\n\n  sign = (*sp == '-');\n  sp += sign;\n\n  if (base == 0)\n    {\n      if (sp[0] == '0')\n\t{\n\t  if (sp[1] == 'x' || sp[1] == 'X')\n\t    {\n\t      base = 16;\n\t      sp += 2;\n\t    }\n\t  else if (sp[1] == 'b' || sp[1] == 'B')\n\t    {\n\t      base = 2;\n\t      sp += 2;\n\t    }\n\t  else\n\t    base = 8;\n\t}\n      else\n\tbase = 10;\n    }\n\n  if (!*sp)\n    {\n      r->_mp_size = 0;\n      return -1;\n    }\n  dp = (unsigned char *) gmp_xalloc (strlen (sp));\n\n  for (dn = 0; *sp; sp++)\n    {\n      unsigned digit;\n\n      if (isspace ((unsigned char) *sp))\n\tcontinue;\n      else if (*sp >= '0' && *sp <= '9')\n\tdigit = *sp - '0';\n      else if (*sp >= 'a' && *sp <= 'z')\n\tdigit = *sp - 'a' + 10;\n      else if (*sp >= 'A' && *sp <= 'Z')\n\tdigit = *sp - 'A' + 10;\n      else\n\tdigit = base; /* fail */\n\n      if (digit >= (unsigned) base)\n\t{\n\t  gmp_free (dp);\n\t  r->_mp_size = 0;\n\t  return -1;\n\t}\n\n      dp[dn++] = digit;\n    }\n\n  if (!dn)\n    {\n      gmp_free (dp);\n      r->_mp_size = 0;\n      return -1;\n    }\n  bits = mpn_base_power_of_two_p (base);\n\n  if (bits > 0)\n    {\n      alloc = (dn * bits + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n      rp = MPZ_REALLOC (r, alloc);\n      rn = mpn_set_str_bits (rp, dp, dn, bits);\n    }\n  else\n    {\n      struct mpn_base_info info;\n      mpn_get_base_info (&info, base);\n      alloc = (dn + info.exp - 1) / info.exp;\n      rp = MPZ_REALLOC (r, alloc);\n      rn = mpn_set_str_other (rp, dp, dn, base, &info);\n      /* Normalization, needed for all-zero input. */\n      assert (rn > 0);\n      rn -= rp[rn-1] == 0;\n    }\n  assert (rn <= alloc);\n  gmp_free (dp);\n\n  r->_mp_size = sign ? - rn : rn;\n\n  return 0;\n}",
      "lines": 103,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "mpz_init_set_str": {
      "start_point": [
        4226,
        0
      ],
      "end_point": [
        4231,
        1
      ],
      "content": "int\nmpz_init_set_str (mpz_t r, const char *sp, int base)\n{\n  mpz_init (r);\n  return mpz_set_str (r, sp, base);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "mpz_out_str": {
      "start_point": [
        4233,
        0
      ],
      "end_point": [
        4244,
        1
      ],
      "content": "size_t\nmpz_out_str (FILE *stream, int base, const mpz_t x)\n{\n  char *str;\n  size_t len;\n\n  str = mpz_get_str (NULL, base, x);\n  len = strlen (str);\n  len = fwrite (str, 1, len, stream);\n  gmp_free (str);\n  return len;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "gmp_detect_endian": {
      "start_point": [
        4247,
        0
      ],
      "end_point": [
        4253,
        1
      ],
      "content": "static int\ngmp_detect_endian (void)\n{\n  static const int i = 2;\n  const unsigned char *p = (const unsigned char *) &i;\n  return 1 - *p;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpz_import": {
      "start_point": [
        4256,
        0
      ],
      "end_point": [
        4322,
        1
      ],
      "content": "void\nmpz_import (mpz_t r, size_t count, int order, size_t size, int endian,\n\t    size_t nails, const void *src)\n{\n  const unsigned char *p;\n  ptrdiff_t word_step;\n  mp_ptr rp;\n  mp_size_t rn;\n\n  /* The current (partial) limb. */\n  mp_limb_t limb;\n  /* The number of bytes already copied to this limb (starting from\n     the low end). */\n  size_t bytes;\n  /* The index where the limb should be stored, when completed. */\n  mp_size_t i;\n\n  if (nails != 0)\n    gmp_die (\"mpz_import: Nails not supported.\");\n\n  assert (order == 1 || order == -1);\n  assert (endian >= -1 && endian <= 1);\n\n  if (endian == 0)\n    endian = gmp_detect_endian ();\n\n  p = (unsigned char *) src;\n\n  word_step = (order != endian) ? 2 * size : 0;\n\n  /* Process bytes from the least significant end, so point p at the\n     least significant word. */\n  if (order == 1)\n    {\n      p += size * (count - 1);\n      word_step = - word_step;\n    }\n\n  /* And at least significant byte of that word. */\n  if (endian == 1)\n    p += (size - 1);\n\n  rn = (size * count + sizeof(mp_limb_t) - 1) / sizeof(mp_limb_t);\n  rp = MPZ_REALLOC (r, rn);\n\n  for (limb = 0, bytes = 0, i = 0; count > 0; count--, p += word_step)\n    {\n      size_t j;\n      for (j = 0; j < size; j++, p -= (ptrdiff_t) endian)\n\t{\n\t  limb |= (mp_limb_t) *p << (bytes++ * CHAR_BIT);\n\t  if (bytes == sizeof(mp_limb_t))\n\t    {\n\t      rp[i++] = limb;\n\t      bytes = 0;\n\t      limb = 0;\n\t    }\n\t}\n    }\n  assert (i + (bytes > 0) == rn);\n  if (limb != 0)\n    rp[i++] = limb;\n  else\n    i = mpn_normalized_size (rp, i);\n\n  r->_mp_size = i;\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mpz_export": {
      "start_point": [
        4324,
        0
      ],
      "end_point": [
        4411,
        1
      ],
      "content": "void *\nmpz_export (void *r, size_t *countp, int order, size_t size, int endian,\n\t    size_t nails, const mpz_t u)\n{\n  size_t count;\n  mp_size_t un;\n\n  if (nails != 0)\n    gmp_die (\"mpz_import: Nails not supported.\");\n\n  assert (order == 1 || order == -1);\n  assert (endian >= -1 && endian <= 1);\n  assert (size > 0 || u->_mp_size == 0);\n\n  un = u->_mp_size;\n  count = 0;\n  if (un != 0)\n    {\n      size_t k;\n      unsigned char *p;\n      ptrdiff_t word_step;\n      /* The current (partial) limb. */\n      mp_limb_t limb;\n      /* The number of bytes left to to in this limb. */\n      size_t bytes;\n      /* The index where the limb was read. */\n      mp_size_t i;\n\n      un = GMP_ABS (un);\n\n      /* Count bytes in top limb. */\n      limb = u->_mp_d[un-1];\n      assert (limb != 0);\n\n      k = 0;\n      do {\n\tk++; limb >>= CHAR_BIT;\n      } while (limb != 0);\n\n      count = (k + (un-1) * sizeof (mp_limb_t) + size - 1) / size;\n\n      if (!r)\n\tr = gmp_xalloc (count * size);\n\n      if (endian == 0)\n\tendian = gmp_detect_endian ();\n\n      p = (unsigned char *) r;\n\n      word_step = (order != endian) ? 2 * size : 0;\n\n      /* Process bytes from the least significant end, so point p at the\n\t least significant word. */\n      if (order == 1)\n\t{\n\t  p += size * (count - 1);\n\t  word_step = - word_step;\n\t}\n\n      /* And at least significant byte of that word. */\n      if (endian == 1)\n\tp += (size - 1);\n\n      for (bytes = 0, i = 0, k = 0; k < count; k++, p += word_step)\n\t{\n\t  size_t j;\n\t  for (j = 0; j < size; j++, p -= (ptrdiff_t) endian)\n\t    {\n\t      if (bytes == 0)\n\t\t{\n\t\t  if (i < un)\n\t\t    limb = u->_mp_d[i++];\n\t\t  bytes = sizeof (mp_limb_t);\n\t\t}\n\t      *p = limb;\n\t      limb >>= CHAR_BIT;\n\t      bytes--;\n\t    }\n\t}\n      assert (i == un);\n      assert (k == count);\n    }\n\n  if (countp)\n    *countp = count;\n\n  return r;\n}",
      "lines": 88,
      "depth": 16,
      "decorators": [
        "void",
        "*\nmpz_export (void *r, size_t *countp, int order, size_t size, int endian,\n\t    size_t nails, const mpz_t u)",
        "*"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/mini-gmp.h": {},
  "gmp/gmp-6.1.2/mini-gmp/tests/hex-random.c": {
    "mkseed": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static void\nmkseed (mpz_t seed)\n{\n  FILE *f = fopen (\"/dev/urandom\", \"rb\");\n  if (f)\n    {\n      unsigned char buf[6];\n      size_t res;\n\n      setbuf (f, NULL);\n      res = fread (buf, sizeof(buf), 1, f);\n      fclose (f);\n\n      if (res == 1)\n\t{\n\t  mpz_import (seed, sizeof(buf), 1, 1, 0, 0, buf);\n\t  return;\n\t}\n    }\n\n#ifdef __unix__\n  {\n    struct timeval tv;\n    mpz_t usec;\n    mpz_init (usec);\n\n    gettimeofday (&tv, NULL);\n    mpz_set_ui (seed, tv.tv_sec);\n    mpz_set_ui (usec, tv.tv_usec);\n    /* usec fits in 20 bits, shift left to make it 48 bits. */\n    mpz_mul_2exp (usec, usec, 28);\n    mpz_xor (seed, seed, usec);\n\n    mpz_clear (usec);\n  }\n#else\n  mpz_set_ui (seed, time (NULL));\n#endif\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hex_random_init": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void\nhex_random_init (void)\n{\n  mpz_t seed;\n  char *env_seed;\n\n  mpz_init (seed);\n\n  env_seed = getenv (\"GMP_CHECK_RANDOMIZE\");\n  if (env_seed && env_seed[0])\n    {\n      mpz_set_str (seed, env_seed, 0);\n      if (mpz_cmp_ui (seed, 0) != 0)\n\tgmp_printf (\"Re-seeding with GMP_CHECK_RANDOMIZE=%Zd\\n\", seed);\n      else\n\t{\n\t  mkseed (seed);\n\t  gmp_printf (\"Seed GMP_CHECK_RANDOMIZE=%Zd (include this in bug reports)\\n\", seed);\n\t}\n      fflush (stdout);\n    }\n  else\n    mpz_set_ui (seed, 4711);\n\n  gmp_randinit_default (state);\n  gmp_randseed (state, seed);\n\n  mpz_clear (seed);\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "hex_urandomb": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "char *\nhex_urandomb (unsigned long bits)\n{\n  char *res;\n  mpz_t x;\n\n  mpz_init (x);\n  mpz_urandomb (x, state, bits);\n  gmp_asprintf (&res, \"%Zx\", x);\n  mpz_clear (x);\n  return res;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "char",
        "*\nhex_urandomb (unsigned long bits)",
        "*"
      ]
    },
    "hex_rrandomb": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "char *\nhex_rrandomb (unsigned long bits)\n{\n  char *res;\n  mpz_t x;\n\n  mpz_init (x);\n  mpz_rrandomb (x, state, bits);\n  gmp_asprintf (&res, \"%Zx\", x);\n  mpz_clear (x);\n  return res;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "char",
        "*\nhex_rrandomb (unsigned long bits)",
        "*"
      ]
    },
    "hex_rrandomb_export": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "char *\nhex_rrandomb_export (void *dst, size_t *countp,\n\t\t     int order, size_t size, int endian, unsigned long bits)\n{\n  char *res;\n  mpz_t x;\n  mpz_init (x);\n  mpz_rrandomb (x, state, bits);\n  gmp_asprintf (&res, \"%Zx\", x);\n  mpz_export (dst, countp, order, size, endian, 0, x);\n  mpz_clear (x);\n  return res;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "char",
        "*\nhex_rrandomb_export (void *dst, size_t *countp,\n\t\t     int order, size_t size, int endian, unsigned long bits)",
        "*"
      ]
    },
    "hex_random_op2": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "void hex_random_op2 (enum hex_random_op op,  unsigned long maxbits,\n\t\t     char **ap, char **rp)\n{\n  mpz_t a, r;\n  unsigned long abits;\n  unsigned signs;\n\n  mpz_init (a);\n  mpz_init (r);\n\n  abits = gmp_urandomb_ui (state, 32) % maxbits;\n\n  mpz_rrandomb (a, state, abits);\n\n  signs = gmp_urandomb_ui (state, 1);\n  if (signs & 1)\n    mpz_neg (a, a);\n\n  switch (op)\n    {\n    default:\n      abort ();\n    case OP_SQR:\n      mpz_mul (r, a, a);\n      break;\n    }\n\n  gmp_asprintf (ap, \"%Zx\", a);\n  gmp_asprintf (rp, \"%Zx\", r);\n\n  mpz_clear (a);\n  mpz_clear (r);\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "hex_random_op3": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "void\nhex_random_op3 (enum hex_random_op op,  unsigned long maxbits,\n\t\tchar **ap, char **bp, char **rp)\n{\n  mpz_t a, b, r;\n  unsigned long abits, bbits;\n  unsigned signs;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (r);\n\n  abits = gmp_urandomb_ui (state, 32) % maxbits;\n  bbits = gmp_urandomb_ui (state, 32) % maxbits;\n\n  mpz_rrandomb (a, state, abits);\n  mpz_rrandomb (b, state, bbits);\n\n  signs = gmp_urandomb_ui (state, 3);\n  if (signs & 1)\n    mpz_neg (a, a);\n  if (signs & 2)\n    mpz_neg (b, b);\n\n  switch (op)\n    {\n    default:\n      abort ();\n    case OP_ADD:\n      mpz_add (r, a, b);\n      break;\n    case OP_SUB:\n      mpz_sub (r, a, b);\n      break;\n    case OP_MUL:\n      mpz_mul (r, a, b);\n      break;\n    case OP_GCD:\n      if (signs & 4)\n\t{\n\t  /* Produce a large gcd */\n\t  unsigned long gbits = gmp_urandomb_ui (state, 32) % maxbits;\n\t  mpz_rrandomb (r, state, gbits);\n\t  mpz_mul (a, a, r);\n\t  mpz_mul (b, b, r);\n\t}\n      mpz_gcd (r, a, b);\n      break;\n    case OP_LCM:\n      if (signs & 4)\n\t{\n\t  /* Produce a large gcd */\n\t  unsigned long gbits = gmp_urandomb_ui (state, 32) % maxbits;\n\t  mpz_rrandomb (r, state, gbits);\n\t  mpz_mul (a, a, r);\n\t  mpz_mul (b, b, r);\n\t}\n      mpz_lcm (r, a, b);\n      break;\n    case OP_AND:\n      mpz_and (r, a, b);\n      break;\n    case OP_IOR:\n      mpz_ior (r, a, b);\n      break;\n    case OP_XOR:\n      mpz_xor (r, a, b);\n      break;\n    }\n\n  gmp_asprintf (ap, \"%Zx\", a);\n  gmp_asprintf (bp, \"%Zx\", b);\n  gmp_asprintf (rp, \"%Zx\", r);\n\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (r);\n}",
      "lines": 78,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "hex_random_op4": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "void\nhex_random_op4 (enum hex_random_op op, unsigned long maxbits,\n\t\tchar **ap, char **bp, char **cp, char **dp)\n{\n  mpz_t a, b, c, d;\n  unsigned long abits, bbits;\n  unsigned signs;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (c);\n  mpz_init (d);\n\n  if (op == OP_POWM)\n    {\n      unsigned long cbits;\n      abits = gmp_urandomb_ui (state, 32) % maxbits;\n      bbits = 1 + gmp_urandomb_ui (state, 32) % maxbits;\n      cbits = 2 + gmp_urandomb_ui (state, 32) % maxbits;\n\n      mpz_rrandomb (a, state, abits);\n      mpz_rrandomb (b, state, bbits);\n      mpz_rrandomb (c, state, cbits);\n\n      signs = gmp_urandomb_ui (state, 3);\n      if (signs & 1)\n\tmpz_neg (a, a);\n      if (signs & 2)\n\t{\n\t  mpz_t g;\n\n\t  /* If we negate the exponent, must make sure that gcd(a, c) = 1 */\n\t  if (mpz_sgn (a) == 0)\n\t    mpz_set_ui (a, 1);\n\t  else\n\t    {\n\t      mpz_init (g);\n\n\t      for (;;)\n\t\t{\n\t\t  mpz_gcd (g, a, c);\n\t\t  if (mpz_cmp_ui (g, 1) == 0)\n\t\t    break;\n\t\t  mpz_divexact (a, a, g);\n\t\t}\n\t      mpz_clear (g);\n\t    }\n\t  mpz_neg (b, b);\n\t}\n      if (signs & 4)\n\tmpz_neg (c, c);\n\n      mpz_powm (d, a, b, c);\n    }\n  else\n    {\n      unsigned long qbits;\n      bbits = 1 + gmp_urandomb_ui (state, 32) % maxbits;\n      qbits = gmp_urandomb_ui (state, 32) % maxbits;\n      abits = bbits + qbits;\n      if (abits > 30)\n\tabits -= 30;\n      else\n\tabits = 0;\n\n      mpz_rrandomb (a, state, abits);\n      mpz_rrandomb (b, state, bbits);\n\n      signs = gmp_urandomb_ui (state, 2);\n      if (signs & 1)\n\tmpz_neg (a, a);\n      if (signs & 2)\n\tmpz_neg (b, b);\n\n      switch (op)\n\t{\n\tdefault:\n\t  abort ();\n\tcase OP_CDIV:\n\t  mpz_cdiv_qr (c, d, a, b);\n\t  break;\n\tcase OP_FDIV:\n\t  mpz_fdiv_qr (c, d, a, b);\n\t  break;\n\tcase OP_TDIV:\n\t  mpz_tdiv_qr (c, d, a, b);\n\t  break;\n\t}\n    }\n  gmp_asprintf (ap, \"%Zx\", a);\n  gmp_asprintf (bp, \"%Zx\", b);\n  gmp_asprintf (cp, \"%Zx\", c);\n  gmp_asprintf (dp, \"%Zx\", d);\n\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (c);\n  mpz_clear (d);\n}",
      "lines": 99,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "hex_random_bit_op": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "void\nhex_random_bit_op (enum hex_random_op op, unsigned long maxbits,\n\t\t   char **ap, unsigned long *b, char **rp)\n{\n  mpz_t a, r;\n  unsigned long abits, bbits;\n  unsigned signs;\n\n  mpz_init (a);\n  mpz_init (r);\n\n  abits = gmp_urandomb_ui (state, 32) % maxbits;\n  bbits = gmp_urandomb_ui (state, 32) % (maxbits + 100);\n\n  mpz_rrandomb (a, state, abits);\n\n  signs = gmp_urandomb_ui (state, 1);\n  if (signs & 1)\n    mpz_neg (a, a);\n\n  switch (op)\n    {\n    default:\n      abort ();\n\n    case OP_SETBIT:\n      mpz_set (r, a);\n      mpz_setbit (r, bbits);\n      break;\n    case OP_CLRBIT:\n      mpz_set (r, a);\n      mpz_clrbit (r, bbits);\n      break;\n    case OP_COMBIT:\n      mpz_set (r, a);\n      mpz_combit (r, bbits);\n      break;\n    case OP_CDIV_Q_2:\n      mpz_cdiv_q_2exp (r, a, bbits);\n      break;\n    case OP_CDIV_R_2:\n      mpz_cdiv_r_2exp (r, a, bbits);\n      break;\n    case OP_FDIV_Q_2:\n      mpz_fdiv_q_2exp (r, a, bbits);\n      break;\n    case OP_FDIV_R_2:\n      mpz_fdiv_r_2exp (r, a, bbits);\n      break;\n    case OP_TDIV_Q_2:\n      mpz_tdiv_q_2exp (r, a, bbits);\n      break;\n    case OP_TDIV_R_2:\n      mpz_tdiv_r_2exp (r, a, bbits);\n      break;\n    }\n\n  gmp_asprintf (ap, \"%Zx\", a);\n  *b = bbits;\n  gmp_asprintf (rp, \"%Zx\", r);\n\n  mpz_clear (a);\n  mpz_clear (r);\n}",
      "lines": 64,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "hex_random_scan_op": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "void\nhex_random_scan_op (enum hex_random_op op, unsigned long maxbits,\n\t\t    char **ap, unsigned long *b, unsigned long *r)\n{\n  mpz_t a;\n  unsigned long abits, bbits;\n  unsigned signs;\n\n  mpz_init (a);\n\n  abits = gmp_urandomb_ui (state, 32) % maxbits;\n  bbits = gmp_urandomb_ui (state, 32) % (maxbits + 100);\n\n  mpz_rrandomb (a, state, abits);\n\n  signs = gmp_urandomb_ui (state, 1);\n  if (signs & 1)\n    mpz_neg (a, a);\n\n  switch (op)\n    {\n    default:\n      abort ();\n\n    case OP_SCAN0:\n      *r = mpz_scan0 (a, bbits);\n      break;\n    case OP_SCAN1:\n      *r = mpz_scan1 (a, bbits);\n      break;\n    }\n  gmp_asprintf (ap, \"%Zx\", a);\n  *b = bbits;\n\n  mpz_clear (a);\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "hex_random_str_op": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        482,
        1
      ],
      "content": "void\nhex_random_str_op (unsigned long maxbits,\n\t\t   int base, char **ap, char **rp)\n{\n  mpz_t a;\n  unsigned long abits;\n  unsigned signs;\n\n  mpz_init (a);\n\n  abits = gmp_urandomb_ui (state, 32) % maxbits;\n\n  mpz_rrandomb (a, state, abits);\n\n  signs = gmp_urandomb_ui (state, 2);\n  if (signs & 1)\n    mpz_neg (a, a);\n\n  *ap = mpz_get_str (NULL, 16, a);\n  *rp = mpz_get_str (NULL, base, a);\n\n  mpz_clear (a);\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/hex-random.h": {},
  "gmp/gmp-6.1.2/mini-gmp/tests/mini-random.c": {
    "set_str": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static void\nset_str (mpz_t r, const char *s)\n{\n  if (mpz_set_str (r, s, 16) != 0)\n    {\n      fprintf (stderr, \"mpz_set_str failed on input %s\\n\", s);\n      abort ();\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mini_urandomb": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void\nmini_urandomb (mpz_t r, unsigned long bits)\n{\n  char *s;\n  s = hex_urandomb (bits);\n  set_str (r, s);\n  free (s);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mini_rrandomb": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\nmini_rrandomb (mpz_t r, unsigned long bits)\n{\n  char *s;\n  s = hex_rrandomb (bits);\n  set_str (r, s);\n  free (s);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mini_rrandomb_export": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\nmini_rrandomb_export (mpz_t r, void *dst, size_t *countp,\n\t\t      int order, size_t size, int endian, unsigned long bits)\n{\n  char *s;\n  s = hex_rrandomb_export (dst, countp, order, size, endian, bits);\n  set_str (r, s);\n  free (s);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mini_random_op2": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "void\nmini_random_op2 (enum hex_random_op op, unsigned long maxbits,\n\t\t mpz_t a, mpz_t r)\n{\n  char *ap;\n  char *rp;\n\n  hex_random_op2 (op, maxbits, &ap, &rp);\n  set_str (a, ap);\n  set_str (r, rp);\n\n  free (ap);\n  free (rp);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mini_random_op3": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nmini_random_op3 (enum hex_random_op op, unsigned long maxbits,\n\t\t mpz_t a, mpz_t b, mpz_t r)\n{\n  char *ap;\n  char *bp;\n  char *rp;\n\n  hex_random_op3 (op, maxbits, &ap, &bp, &rp);\n  set_str (a, ap);\n  set_str (b, bp);\n  set_str (r, rp);\n\n  free (ap);\n  free (bp);\n  free (rp);\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mini_random_op4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void\nmini_random_op4 (enum hex_random_op op, unsigned long maxbits,\n\t\t mpz_t a, mpz_t b, mpz_t c, mpz_t d)\n{\n  char *ap;\n  char *bp;\n  char *cp;\n  char *dp;\n\n  hex_random_op4 (op, maxbits, &ap, &bp, &cp, &dp);\n  set_str (a, ap);\n  set_str (b, bp);\n  set_str (c, cp);\n  set_str (d, dp);\n\n  free (ap);\n  free (bp);\n  free (cp);\n  free (dp);\n}",
      "lines": 20,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mini_random_bit_op": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\nmini_random_bit_op (enum hex_random_op op, unsigned long maxbits,\n\t\t\t mpz_t a, mp_bitcnt_t *b, mpz_t r)\n{\n  char *ap;\n  char *rp;\n\n  hex_random_bit_op (op, maxbits, &ap, b, &rp);\n  set_str (a, ap);\n  set_str (r, rp);\n\n  free (ap);\n  free (rp);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mini_random_scan_op": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "void\nmini_random_scan_op (enum hex_random_op op, unsigned long maxbits,\n\t\t     mpz_t a, mp_bitcnt_t *b, mp_bitcnt_t *r)\n{\n  char *ap;\n\n  hex_random_scan_op (op, maxbits, &ap, b, r);\n  set_str (a, ap);\n\n  free (ap);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/mini-random.h": {},
  "gmp/gmp-6.1.2/mini-gmp/tests/t-add.c": {
    "testmain": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t a, b, res, ref;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (res);\n  mpz_init (ref);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_random_op3 (OP_ADD, MAXBITS, a, b, ref);\n      mpz_add (res, a, b);\n      if (mpz_cmp (res, ref))\n\t{\n\t  fprintf (stderr, \"mpz_add failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (res);\n  mpz_clear (ref);\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-aorsmul.c": {
    "testmain": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t a, b, res, ref;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init_set_ui (res, 5);\n  mpz_init (ref);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_random_op3 (OP_MUL, MAXBITS, a, b, ref);\n      if (i & 1) {\n\tmpz_add (ref, ref, res);\n\tif (mpz_fits_ulong_p (b))\n\t  mpz_addmul_ui (res, a, mpz_get_ui (b));\n\telse\n\t  mpz_addmul (res, a, b);\n      } else {\n\tmpz_sub (ref, res, ref);\n\tif (mpz_fits_ulong_p (b))\n\t  mpz_submul_ui (res, a, mpz_get_ui (b));\n\telse\n\t  mpz_submul (res, a, b);\n      }\n      if (mpz_cmp (res, ref))\n\t{\n\t  if (i & 1)\n\t    fprintf (stderr, \"mpz_addmul failed:\\n\");\n\t  else\n\t    fprintf (stderr, \"mpz_submul failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (res);\n  mpz_clear (ref);\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-bitops.c": {
    "testmain": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t a, res, ref;\n  mp_bitcnt_t b;\n\n  mpz_init (a);\n  mpz_init (res);\n  mpz_init (ref);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_random_bit_op (OP_SETBIT, MAXBITS, a, &b, ref);\n      mpz_set (res, a);\n      mpz_setbit (res, b);\n      if (mpz_cmp (res, ref))\n\t{\n\t  fprintf (stderr, \"mpz_setbit failed:\\n\");\n\t  dump (\"a\", a);\n\t  fprintf (stderr, \"b: %lu\\n\", b);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n      if (!mpz_tstbit (res, b))\n\t{\n\t  fprintf (stderr, \"mpz_tstbit failed (after mpz_setbit):\\n\");\n\t  dump (\"res\", a);\n\t  fprintf (stderr, \"b: %lu\\n\", b);\n\t  abort ();\n\t}\n      mini_random_bit_op (OP_CLRBIT, MAXBITS, a, &b, ref);\n      mpz_set (res, a);\n      mpz_clrbit (res, b);\n      if (mpz_cmp (res, ref))\n\t{\n\t  fprintf (stderr, \"mpz_clrbit failed:\\n\");\n\t  dump (\"a\", a);\n\t  fprintf (stderr, \"b: %lu\\n\", b);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n      if (mpz_tstbit (res, b))\n\t{\n\t  fprintf (stderr, \"mpz_tstbit failed (after mpz_clrbit):\\n\");\n\t  dump (\"res\", a);\n\t  fprintf (stderr, \"b: %lu\\n\", b);\n\t  abort ();\n\t}\n      mini_random_bit_op (OP_COMBIT, MAXBITS, a, &b, ref);\n      mpz_set (res, a);\n      mpz_combit (res, b);\n      if (mpz_cmp (res, ref))\n\t{\n\t  fprintf (stderr, \"mpz_combit failed:\\n\");\n\t  dump (\"a\", a);\n\t  fprintf (stderr, \"b: %lu\\n\", b);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n      if (mpz_tstbit (res, b) == mpz_tstbit (a, b))\n\t{\n\t  fprintf (stderr, \"mpz_tstbit failed (after mpz_combit):\\n\");\n\t  dump (\"res\", a);\n\t  fprintf (stderr, \"b: %lu\\n\", b);\n\t  abort ();\n\t}\n    }\n  mpz_clear (a);\n  mpz_clear (res);\n  mpz_clear (ref);\n}",
      "lines": 75,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-cmp_d.c": {
    "check_one": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\ncheck_one (const char *name, mpz_srcptr x, double y, int cmp, int cmpabs)\n{\n  int   got;\n\n  got = mpz_cmp_d (x, y);\n  if (SGN(got) != cmp)\n    {\n      unsigned i;\n      printf    (\"mpz_cmp_d wrong (from %s)\\n\", name);\n      printf    (\"  got  %d\\n\", got);\n      printf    (\"  want %d\\n\", cmp);\n    fail:\n      printf (\"  x=\");\n      mpz_out_str (stdout, 10, x);\n      printf    (\"\\n  y %g\\n\", y);\n      printf (\"  x=0x\");\n      mpz_out_str (stdout, -16, x);\n      printf    (\"\\n  y %g\\n\", y);\n      printf    (\"  y\");\n      for (i = 0; i < sizeof(y); i++)\n        printf (\" %02X\", (unsigned) ((unsigned char *) &y)[i]);\n      printf (\"\\n\");\n      abort ();\n    }\n\n  got = mpz_cmpabs_d (x, y);\n  if (SGN(got) != cmpabs)\n    {\n      printf    (\"mpz_cmpabs_d wrong\\n\");\n      printf    (\"  got  %d\\n\", got);\n      printf    (\"  want %d\\n\", cmpabs);\n      goto fail;\n    }\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *x;\n    double      y;\n    int         cmp, cmpabs;\n\n  } data[] = {\n\n    {  \"0\",  0.0,  0,  0 },\n\n    {  \"1\",  0.0,  1,  1 },\n    { \"-1\",  0.0, -1,  1 },\n\n    {  \"1\",  0.5,  1,  1 },\n    { \"-1\", -0.5, -1,  1 },\n\n    {  \"0\",  1.0, -1, -1 },\n    {  \"0\", -1.0,  1, -1 },\n\n    {  \"0x1000000000000000000000000000000000000000000000000\", 1.0,  1, 1 },\n    { \"-0x1000000000000000000000000000000000000000000000000\", 1.0, -1, 1 },\n\n    {  \"0\",  1e100, -1, -1 },\n    {  \"0\", -1e100,  1, -1 },\n\n    {  \"2\",  1.5,   1,  1 },\n    {  \"2\", -1.5,   1,  1 },\n    { \"-2\",  1.5,  -1,  1 },\n    { \"-2\", -1.5,  -1,  1 },\n  };\n\n  mpz_t    x;\n  unsigned i;\n\n  mpz_init (x);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (x, data[i].x, 0);\n      check_one (\"check_data\", x, data[i].y, data[i].cmp, data[i].cmpabs);\n    }\n\n  mpz_clear (x);\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_onebits": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\ncheck_onebits (void)\n{\n  mpz_t   x, x2;\n  double  y;\n  int     i;\n\n  mpz_init_set_ui (x, 0L);\n  mpz_init (x2);\n\n  for (i = 0; i < 512; i++)\n    {\n      mpz_mul_2exp (x, x, 1);\n      mpz_add_ui (x, x, 1L);\n\n      y = mpz_get_d (x);\n      mpz_set_d (x2, y);\n\n      /* stop if any truncation is occurring */\n      if (mpz_cmp (x, x2) != 0)\n        break;\n\n      check_one (\"check_onebits\", x, y, 0, 0);\n      check_one (\"check_onebits\", x, -y, 1, 0);\n      mpz_neg (x, x);\n      check_one (\"check_onebits\", x, y, -1, 0);\n      check_one (\"check_onebits\", x, -y, 0, 0);\n      mpz_neg (x, x);\n    }\n\n  mpz_clear (x);\n  mpz_clear (x2);\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_low_z_one": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "void\ncheck_low_z_one (void)\n{\n  mpz_t          x;\n  double         y;\n  unsigned long  i;\n\n  mpz_init (x);\n\n  /* FIXME: It'd be better to base this on the float format. */\n#if defined (__vax) || defined (__vax__)\n#define LIM 127\t\t\t/* vax fp numbers have limited range */\n#else\n#define LIM 512\n#endif\n\n  for (i = 1; i < LIM; i++)\n    {\n      mpz_set_ui (x, 1L);\n      mpz_mul_2exp (x, x, i);\n      y = mpz_get_d (x);\n\n      check_one (\"check_low_z_one\", x, y,   0, 0);\n      check_one (\"check_low_z_one\", x, -y,  1, 0);\n      mpz_neg (x, x);\n      check_one (\"check_low_z_one\", x, y,  -1, 0);\n      check_one (\"check_low_z_one\", x, -y,  0, 0);\n      mpz_neg (x, x);\n\n      mpz_sub_ui (x, x, 1);\n\n      check_one (\"check_low_z_one\", x, y,  -1, -1);\n      check_one (\"check_low_z_one\", x, -y,  1, -1);\n      mpz_neg (x, x);\n      check_one (\"check_low_z_one\", x, y,  -1, -1);\n      check_one (\"check_low_z_one\", x, -y,  1, -1);\n      mpz_neg (x, x);\n\n      mpz_add_ui (x, x, 2);\n\n      check_one (\"check_low_z_one\", x, y,   1, 1);\n      check_one (\"check_low_z_one\", x, -y,  1, 1);\n      mpz_neg (x, x);\n      check_one (\"check_low_z_one\", x, y,  -1, 1);\n      check_one (\"check_low_z_one\", x, -y, -1, 1);\n      mpz_neg (x, x);\n    }\n\n  mpz_clear (x);\n}",
      "lines": 50,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_one_2exp": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "void\ncheck_one_2exp (void)\n{\n  double           e;\n  mpz_t            x;\n  volatile double  y;\n  int              i;\n\n  mpz_init (x);\n\n  e = 1.0;\n  for (i = 0; i < 128; i++)\n    {\n      e /= 2.0;\n      y = 1.0 + e;\n      if (y == 1.0)\n        break;\n\n      mpz_set_ui (x, 1L);\n      check_one (\"check_one_2exp\", x,  y, -1, -1);\n      check_one (\"check_one_2exp\", x, -y,  1, -1);\n\n      mpz_set_si (x, -1L);\n      check_one (\"check_one_2exp\", x,  y, -1, -1);\n      check_one (\"check_one_2exp\", x, -y,  1, -1);\n    }\n\n  mpz_clear (x);\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_infinity": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "void\ncheck_infinity (void)\n{\n  mpz_t   x;\n  double  y = HUGE_VAL;\n  if (y != 2*y)\n    return;\n\n  mpz_init (x);\n\n  /* 0 cmp inf */\n  mpz_set_ui (x, 0L);\n  check_one (\"check_infinity\", x,  y, -1, -1);\n  check_one (\"check_infinity\", x, -y,  1, -1);\n\n  /* 123 cmp inf */\n  mpz_set_ui (x, 123L);\n  check_one (\"check_infinity\", x,  y, -1, -1);\n  check_one (\"check_infinity\", x, -y,  1, -1);\n\n  /* -123 cmp inf */\n  mpz_set_si (x, -123L);\n  check_one (\"check_infinity\", x,  y, -1, -1);\n  check_one (\"check_infinity\", x, -y,  1, -1);\n\n  /* 2^5000 cmp inf */\n  mpz_set_ui (x, 1L);\n  mpz_mul_2exp (x, x, 5000L);\n  check_one (\"check_infinity\", x,  y, -1, -1);\n  check_one (\"check_infinity\", x, -y,  1, -1);\n\n  /* -2^5000 cmp inf */\n  mpz_neg (x, x);\n  check_one (\"check_infinity\", x,  y, -1, -1);\n  check_one (\"check_infinity\", x, -y,  1, -1);\n\n  mpz_clear (x);\n}",
      "lines": 38,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void\ntestmain (int argc, char *argv[])\n{\n  check_data ();\n  check_onebits ();\n  check_low_z_one ();\n  check_one_2exp ();\n  check_infinity ();\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-comb.c": {
    "try_mpz_bin_uiui": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\ntry_mpz_bin_uiui (mpz_srcptr want, unsigned long n, unsigned long k)\n{\n  mpz_t  got;\n\n  mpz_init (got);\n  mpz_bin_uiui (got, n, k);\n  if (mpz_cmp (got, want) != 0)\n    {\n      printf (\"mpz_bin_uiui wrong\\n\");\n      printf (\"  n=%lu\\n\", n);\n      printf (\"  k=%lu\\n\", k);\n      printf (\"  got=\"); mpz_out_str (stdout, 10, got); printf (\"\\n\");\n      printf (\"  want=\"); mpz_out_str (stdout, 10, want); printf (\"\\n\");\n      abort();\n    }\n  mpz_clear (got);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "bin_smallexaustive": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\nbin_smallexaustive (unsigned int count)\n{\n  mpz_t          want;\n  unsigned long  n, k;\n\n  mpz_init (want);\n\n  for (n = 0; n < count; n++)\n    {\n      mpz_set_ui (want, 1);\n      for (k = 0; k <= n; k++)\n\t{\n\t  try_mpz_bin_uiui (want, n, k);\n\t  mpz_mul_ui (want, want, n - k);\n\t  mpz_fdiv_q_ui (want, want, k + 1);\n\t}\n      try_mpz_bin_uiui (want, n, k);\n    }\n\n  mpz_clear (want);\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fac_smallexaustive": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "void\nfac_smallexaustive (unsigned int limit)\n{\n  mpz_t          f, r;\n  unsigned long  n;\n  mpz_init_set_si (f, 1);  /* 0! = 1 */\n  mpz_init (r);\n\n  for (n = 0; n < limit; n++)\n    {\n      mpz_fac_ui (r, n);\n\n      if (mpz_cmp (f, r) != 0)\n        {\n          printf (\"mpz_fac_ui(%lu) wrong\\n\", n);\n          printf (\"  got  \"); mpz_out_str (stdout, 10, r); printf(\"\\n\");\n          printf (\"  want \"); mpz_out_str (stdout, 10, f); printf(\"\\n\");\n          abort ();\n        }\n\n      mpz_mul_ui (f, f, n+1);  /* (n+1)! = n! * (n+1) */\n    }\n\n  mpz_clear (f);\n  mpz_clear (r);\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "checkWilson": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void checkWilson (mpz_t f, unsigned long n)\n{\n  unsigned long m;\n\n  mpz_fac_ui (f, n - 1);\n  m = mpz_fdiv_ui (f, n);\n  if ( m != n - 1)\n    {\n      printf (\"mpz_fac_ui(%lu) wrong\\n\", n - 1);\n      printf (\"  Wilson's theorem not verified: got %lu, expected %lu.\\n\",m ,n - 1);\n      abort ();\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "checkprimes": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void\ncheckprimes (unsigned long p1, unsigned long p2, unsigned long p3)\n{\n  mpz_t          b, f;\n\n  if (p1 - 1 != p2 - 1 + p3 - 1)\n    {\n      printf (\"checkprimes(%lu, %lu, %lu) wrong\\n\", p1, p2, p3);\n      printf (\" %lu - 1 != %lu - 1 + %lu - 1 \\n\", p1, p2, p3);\n      abort ();\n    }\n\n  mpz_init (b);\n  mpz_init (f);\n\n  checkWilson (b, p1); /* b = (p1-1)! */\n  checkWilson (f, p2); /* f = (p2-1)! */\n  mpz_divexact (b, b, f);\n  checkWilson (f, p3); /* f = (p3-1)! */\n  mpz_divexact (b, b, f); /* b = (p1-1)!/((p2-1)!(p3-1)!) */\n  mpz_bin_uiui (f, p1 - 1, p2 - 1);\n  if (mpz_cmp (f, b) != 0)\n    {\n      printf (\"checkprimes(%lu, %lu, %lu) wrong\\n\", p1, p2, p3);\n      printf (\"  got  \"); mpz_out_str (stdout, 10, b); printf(\"\\n\");\n      printf (\"  want \"); mpz_out_str (stdout, 10, f); printf(\"\\n\");\n      abort ();\n    }\n\n  mpz_clear (b);\n  mpz_clear (f);\n\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "void\ntestmain (int argc, char *argv[])\n{\n  unsigned long  limit = 128;\n\n  if (argc > 1 && argv[1][0] == 'x')\n    limit = ~ limit;\n  else if (argc > 1)\n    limit = atoi (argv[1]);\n\n  checkprimes(1009, 733, 277);\n  fac_smallexaustive (limit);\n  bin_smallexaustive (limit);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-cong.c": {
    "check_one": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\ncheck_one (mpz_srcptr a, mpz_srcptr c, mpz_srcptr d, int want)\n{\n  int   got;\n  int   swap;\n\n  for (swap = 0; swap <= 1; swap++)\n    {\n      got = (mpz_congruent_p (a, c, d) != 0);\n      if (want != got)\n\t{\n\t  printf (\"mpz_congruent_p wrong\\n\");\n\t  printf (\"   expected %d got %d\\n\", want, got);\n\t  dump (\"\t a\", a);\n\t  dump (\"\t c\", c);\n\t  dump (\"\t d\", d);\n\t  abort ();\n\t}\n\n#if 0\n      if (mpz_fits_ulong_p (c) && mpz_fits_ulong_p (d))\n\t{\n\t  unsigned long\t uc = mpz_get_ui (c);\n\t  unsigned long\t ud = mpz_get_ui (d);\n\t  got = (mpz_congruent_ui_p (a, uc, ud) != 0);\n\t  if (want != got)\n\t    {\n\t      printf\t(\"mpz_congruent_ui_p wrong\\n\");\n\t      printf\t(\"   expected %d got %d\\n\", want, got);\n\t      dump (\"   a\", a);\n\t      printf\t(\"   c=%lu\\n\", uc);\n\t      printf\t(\"   d=%lu\\n\", ud);\n\t      abort ();\n\t    }\n\t}\n#endif\n      MPZ_SRCPTR_SWAP (a, c);\n    }\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char *a;\n    const char *c;\n    const char *d;\n    int        want;\n\n  } data[] = {\n\n    /* strict equality mod 0 */\n    { \"0\", \"0\", \"0\", 1 },\n    { \"11\", \"11\", \"0\", 1 },\n    { \"3\", \"11\", \"0\", 0 },\n\n    /* anything congruent mod 1 */\n    { \"0\", \"0\", \"1\", 1 },\n    { \"1\", \"0\", \"1\", 1 },\n    { \"0\", \"1\", \"1\", 1 },\n    { \"123\", \"456\", \"1\", 1 },\n    { \"0x123456789123456789\", \"0x987654321987654321\", \"1\", 1 },\n\n    /* csize==1, dsize==2 changing to 1 after stripping 2s */\n    { \"0x3333333333333333\",  \"0x33333333\",\n      \"0x180000000\", 1 },\n    { \"0x33333333333333333333333333333333\", \"0x3333333333333333\",\n      \"0x18000000000000000\", 1 },\n\n    /* another dsize==2 becoming 1, with opposite signs this time */\n    {  \"0x444444441\",\n      \"-0x22222221F\",\n       \"0x333333330\", 1 },\n    {  \"0x44444444444444441\",\n      \"-0x2222222222222221F\",\n       \"0x33333333333333330\", 1 },\n  };\n\n  mpz_t   a, c, d;\n  unsigned   i;\n\n  mpz_init (a);\n  mpz_init (c);\n  mpz_init (d);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (a, data[i].a, 0);\n      mpz_set_str_or_abort (c, data[i].c, 0);\n      mpz_set_str_or_abort (d, data[i].d, 0);\n      check_one (a, c, d, data[i].want);\n    }\n\n  mpz_clear (a);\n  mpz_clear (c);\n  mpz_clear (d);\n}",
      "lines": 57,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "void\ncheck_random (int argc, char *argv[])\n{\n  mpz_t   a, c, d, ra, rc;\n  int     i;\n  int     want;\n  int     reps = 10000;\n  mpz_t bs;\n  unsigned long size_range, size;\n\n  if (argc >= 2)\n    reps = atoi (argv[1]);\n\n  mpz_init (bs);\n\n  mpz_init (a);\n  mpz_init (c);\n  mpz_init (d);\n  mpz_init (ra);\n  mpz_init (rc);\n\n  for (i = 0; i < reps; i++)\n    {\n      mini_urandomb (bs, 32);\n      size_range = mpz_get_ui (bs) % 13 + 1; /* 0..8192 bit operands */\n\n      mini_urandomb (bs, size_range);\n      size = mpz_get_ui (bs);\n      mini_rrandomb (a, size);\n\n      mini_urandomb (bs, 32);\n      size_range = mpz_get_ui (bs) % 13 + 1; /* 0..8192 bit operands */\n\n      mini_urandomb (bs, size_range);\n      size = mpz_get_ui (bs);\n      mini_rrandomb (c, size);\n\n      do\n\t{\n\t  mini_urandomb (bs, 32);\n\t  size_range = mpz_get_ui (bs) % 13 + 1; /* 0..8192 bit operands */\n\n\t  mini_urandomb (bs, size_range);\n\t  size = mpz_get_ui (bs);\n\t  mini_rrandomb (d, size);\n\t}\n      while (mpz_sgn(d) == 0);\n\n      mini_urandomb (bs, 3);\n      if (mpz_tstbit (bs, 0))\n\tmpz_neg (a, a);\n      if (mpz_tstbit (bs, 1))\n\tmpz_neg (c, c);\n      if (mpz_tstbit (bs, 2))\n\tmpz_neg (d, d);\n\n      mpz_fdiv_r (ra, a, d);\n      mpz_fdiv_r (rc, c, d);\n\n      want = (mpz_cmp (ra, rc) == 0);\n      check_one (a, c, d, want);\n\n      mpz_sub (ra, ra, rc);\n      mpz_sub (a, a, ra);\n      check_one (a, c, d, 1);\n\n    }\n\n  mpz_clear (bs);\n\n  mpz_clear (a);\n  mpz_clear (c);\n  mpz_clear (d);\n  mpz_clear (ra);\n  mpz_clear (rc);\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "void\ntestmain (int argc, char *argv[])\n{\n  check_data ();\n  check_random (argc, argv);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-div.c": {
    "testmain": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t a, b, q, r, rq, rr;\n  int div_p;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (r);\n  mpz_init (q);\n  mpz_init (rr);\n  mpz_init (rq);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      unsigned j;\n      for (j = 0; j < 3; j++)\n\t{\n\t  static const enum hex_random_op ops[3] = { OP_CDIV, OP_FDIV, OP_TDIV };\n\t  static const char name[3] = { 'c', 'f', 't'};\n\t  static div_qr_func * const div_qr [3] =\n\t    {\n\t      mpz_cdiv_qr, mpz_fdiv_qr, mpz_tdiv_qr\n\t    };\n\t  static div_qr_ui_func  *div_qr_ui[3] =\n\t    {\n\t      mpz_cdiv_qr_ui, mpz_fdiv_qr_ui, mpz_tdiv_qr_ui\n\t    };\n\t  static div_func * const div_q [3] =\n\t    {\n\t      mpz_cdiv_q, mpz_fdiv_q, mpz_tdiv_q\n\t    };\n\t  static div_x_ui_func  *div_q_ui[3] =\n\t    {\n\t      mpz_cdiv_q_ui, mpz_fdiv_q_ui, mpz_tdiv_q_ui\n\t    };\n\t  static div_func * const div_r [3] =\n\t    {\n\t      mpz_cdiv_r, mpz_fdiv_r, mpz_tdiv_r\n\t    };\n\t  static div_x_ui_func  *div_r_ui[3] =\n\t    {\n\t      mpz_cdiv_r_ui, mpz_fdiv_r_ui, mpz_tdiv_r_ui\n\t    };\n\t  static div_ui_func  *div_ui[3] =\n\t    {\n\t      mpz_cdiv_ui, mpz_fdiv_ui, mpz_tdiv_ui\n\t    };\n\n\t  mini_random_op4 (ops[j], MAXBITS, a, b, rq, rr);\n\t  div_qr[j] (q, r, a, b);\n\t  if (mpz_cmp (r, rr) || mpz_cmp (q, rq))\n\t    {\n\t      fprintf (stderr, \"mpz_%cdiv_qr failed:\\n\", name[j]);\n\t      dump (\"a\", a);\n\t      dump (\"b\", b);\n\t      dump (\"r   \", r);\n\t      dump (\"rref\", rr);\n\t      dump (\"q   \", q);\n\t      dump (\"qref\", rq);\n\t      abort ();\n\t    }\n\t  mpz_set_si (q, -5);\n\t  div_q[j] (q, a, b);\n\t  if (mpz_cmp (q, rq))\n\t    {\n\t      fprintf (stderr, \"mpz_%cdiv_q failed:\\n\", name[j]);\n\t      dump (\"a\", a);\n\t      dump (\"b\", b);\n\t      dump (\"q   \", q);\n\t      dump (\"qref\", rq);\n\t      abort ();\n\t    }\n\t  mpz_set_ui (r, ~5);\n\t  div_r[j] (r, a, b);\n\t  if (mpz_cmp (r, rr))\n\t    {\n\t      fprintf (stderr, \"mpz_%cdiv_r failed:\\n\", name[j]);\n\t      dump (\"a\", a);\n\t      dump (\"b\", b);\n\t      dump (\"r   \", r);\n\t      dump (\"rref\", rr);\n\t      abort ();\n\t    }\n\n\t  if (j == 0)\t\t/* do this once, not for all roundings */\n\t    {\n\t      div_p = mpz_divisible_p (a, b);\n\t      if ((mpz_sgn (r) == 0) ^ (div_p != 0))\n\t\t{\n\t\t  fprintf (stderr, \"mpz_divisible_p failed:\\n\");\n\t\t  dump (\"a\", a);\n\t\t  dump (\"b\", b);\n\t\t  dump (\"r   \", r);\n\t\t  abort ();\n\t\t}\n\t    }\n\n\t  if (j == 0 && mpz_sgn (b) < 0)  /* ceil, negative divisor */\n\t    {\n\t      mpz_mod (r, a, b);\n\t      if (mpz_cmp (r, rr))\n\t\t{\n\t\t  fprintf (stderr, \"mpz_mod failed:\\n\");\n\t\t  dump (\"a\", a);\n\t\t  dump (\"b\", b);\n\t\t  dump (\"r   \", r);\n\t\t  dump (\"rref\", rr);\n\t\t  abort ();\n\t\t}\n\t    }\n\n\t  if (j == 1 && mpz_sgn (b) > 0) /* floor, positive divisor */\n\t    {\n\t      mpz_mod (r, a, b);\n\t      if (mpz_cmp (r, rr))\n\t\t{\n\t\t  fprintf (stderr, \"mpz_mod failed:\\n\");\n\t\t  dump (\"a\", a);\n\t\t  dump (\"b\", b);\n\t\t  dump (\"r   \", r);\n\t\t  dump (\"rref\", rr);\n\t\t  abort ();\n\t\t}\n\t    }\n\n\t  if (mpz_fits_ulong_p (b))\n\t    {\n\t      mp_limb_t rl;\n\n\t      rl = div_qr_ui[j] (q, r, a, mpz_get_ui (b));\n\t      if (rl != mpz_get_ui (rr)\n\t\t  || mpz_cmp (r, rr) || mpz_cmp (q, rq))\n\t\t{\n\t\t  fprintf (stderr, \"mpz_%cdiv_qr_ui failed:\\n\", name[j]);\n\t\t  dump (\"a\", a);\n\t\t  dump (\"b\", b);\n\t\t  fprintf(stderr, \"rl   = %lx\\n\", rl);\n\t\t  dump (\"r   \", r);\n\t\t  dump (\"rref\", rr);\n\t\t  dump (\"q   \", q);\n\t\t  dump (\"qref\", rq);\n\t\t  abort ();\n\t\t}\n\n\t      mpz_set_si (q, 3);\n\t      rl = div_q_ui[j] (q, a, mpz_get_ui (b));\n\t      if (rl != mpz_get_ui (rr) || mpz_cmp (q, rq))\n\t\t{\n\t\t  fprintf (stderr, \"mpz_%cdiv_q_ui failed:\\n\", name[j]);\n\t\t  dump (\"a\", a);\n\t\t  dump (\"b\", b);\n\t\t  fprintf(stderr, \"rl   = %lx\\n\", rl);\n\t\t  dump (\"rref\", rr);\n\t\t  dump (\"q   \", q);\n\t\t  dump (\"qref\", rq);\n\t\t  abort ();\n\t\t}\n\n\t      mpz_set_ui (r, 7);\n\t      rl = div_r_ui[j] (r, a, mpz_get_ui (b));\n\t      if (rl != mpz_get_ui (rr) || mpz_cmp (r, rr))\n\t\t{\n\t\t  fprintf (stderr, \"mpz_%cdiv_qr_ui failed:\\n\", name[j]);\n\t\t  dump (\"a\", a);\n\t\t  dump (\"b\", b);\n\t\t  fprintf(stderr, \"rl   = %lx\\n\", rl);\n\t\t  dump (\"r   \", r);\n\t\t  dump (\"rref\", rr);\n\t\t  abort ();\n\t\t}\n\n\t      rl = div_ui[j] (a, mpz_get_ui (b));\n\t      if (rl != mpz_get_ui (rr))\n\t\t{\n\t\t  fprintf (stderr, \"mpz_%cdiv_qr_ui failed:\\n\", name[j]);\n\t\t  dump (\"a\", a);\n\t\t  dump (\"b\", b);\n\t\t  fprintf(stderr, \"rl   = %lx\\n\", rl);\n\t\t  dump (\"rref\", rr);\n\t\t  abort ();\n\t\t}\n\n\t      if (j == 0)\t/* do this once, not for all roundings */\n\t\t{\n\t\t  div_p = mpz_divisible_ui_p (a, mpz_get_ui (b));\n\t\t  if ((mpz_sgn (r) == 0) ^ (div_p != 0))\n\t\t    {\n\t\t      fprintf (stderr, \"mpz_divisible_ui_p failed:\\n\");\n\t\t      dump (\"a\", a);\n\t\t      dump (\"b\", b);\n\t\t      dump (\"r   \", r);\n\t\t      abort ();\n\t\t    }\n\t\t}\n\n\t      if (j == 1)\t/* floor */\n\t\t{\n\t\t  mpz_mod_ui (r, a, mpz_get_ui (b));\n\t\t  if (mpz_cmp (r, rr))\n\t\t    {\n\t\t      fprintf (stderr, \"mpz_mod failed:\\n\");\n\t\t      dump (\"a\", a);\n\t\t      dump (\"b\", b);\n\t\t      dump (\"r   \", r);\n\t\t      dump (\"rref\", rr);\n\t\t      abort ();\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (r);\n  mpz_clear (q);\n  mpz_clear (rr);\n  mpz_clear (rq);\n}",
      "lines": 220,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-div_2exp.c": {
    "testmain": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t a, res, ref;\n  mp_bitcnt_t b;\n\n  mpz_init (a);\n  mpz_init (res);\n  mpz_init (ref);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      unsigned j;\n      for (j = 0; j < 6; j++)\n\t{\n\t  static const enum hex_random_op ops[6] =\n\t    {\n\t      OP_CDIV_Q_2, OP_CDIV_R_2,\n\t      OP_FDIV_Q_2, OP_FDIV_R_2,\n\t      OP_TDIV_Q_2, OP_TDIV_R_2\n\t    };\n\t  static const char *name[6] =\n\t    {\n\t      \"cdiv_q\", \"cdiv_r\",\n\t      \"fdiv_q\", \"fdiv_r\",\n\t      \"tdiv_q\", \"tdiv_r\"\n\t    };\n\t  static div_func * const div [6] =\n\t    {\n\t      mpz_cdiv_q_2exp, mpz_cdiv_r_2exp,\n\t      mpz_fdiv_q_2exp, mpz_fdiv_r_2exp,\n\t      mpz_tdiv_q_2exp, mpz_tdiv_r_2exp\n\t    };\n\n\t  mini_random_bit_op (ops[j], MAXBITS, a, &b, ref);\n\t  div[j] (res, a, b);\n\t  if (mpz_cmp (ref, res))\n\t    {\n\t      fprintf (stderr, \"mpz_%s_2exp failed:\\n\", name[j]);\n\t      dump (\"a\", a);\n\t      fprintf (stderr, \"b: %lu\\n\", b);\n\t      dump (\"r\", res);\n\t      dump (\"ref\", ref);\n\t      abort ();\n\t    }\n\t}\n    }\n  mpz_clear (a);\n  mpz_clear (res);\n  mpz_clear (ref);\n}",
      "lines": 52,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-double.c": {
    "testmain": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t x;\n\n  for (i = 0; values[i].s; i++)\n    {\n      char *s;\n      mpz_init_set_d (x, values[i].d);\n      s = mpz_get_str (NULL, 16, x);\n      if (strcmp (s, values[i].s) != 0)\n\t{\n\t  fprintf (stderr, \"mpz_set_d failed:\\n\"\n\t\t   \"d = %.20g\\n\"\n\t\t   \"s = %s\\n\"\n\t\t   \"r = %s\\n\",\n\t\t   values[i].d, s, values[i].s);\n\t  abort ();\n\t}\n      testfree (s);\n      mpz_clear (x);\n    }\n\n  mpz_init (x);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      /* Use volatile, to avoid extended precision in floating point\n\t registers, e.g., on m68k and 80387. */\n      volatile double d, f;\n      unsigned long m;\n      int e;\n\n      mini_rrandomb (x, GMP_LIMB_BITS);\n      m = mpz_get_ui (x);\n      mini_urandomb (x, 8);\n      e = mpz_get_ui (x) - 100;\n\n      d = ldexp ((double) m, e);\n      mpz_set_d (x, d);\n      f = mpz_get_d (x);\n      if (f != floor (d))\n\t{\n\t  fprintf (stderr, \"mpz_set_d/mpz_get_d failed:\\n\");\n\t  goto dumperror;\n\t}\n      if ((f == d) ? (mpz_cmp_d (x, d) != 0) : (mpz_cmp_d (x, d) >= 0))\n\t{\n\t  fprintf (stderr, \"mpz_cmp_d (x, d) failed:\\n\");\n\t  goto dumperror;\n\t}\n      f = d + 1.0;\n      if (f > d && ! (mpz_cmp_d (x, f) < 0))\n\t{\n\t  fprintf (stderr, \"mpz_cmp_d (x, f) failed:\\n\");\n\t  goto dumperror;\n\t}\n\n      d = - d;\n\n      mpz_set_d (x, d);\n      f = mpz_get_d (x);\n      if (f != ceil (d))\n\t{\n\t  fprintf (stderr, \"mpz_set_d/mpz_get_d failed:\\n\");\n\tdumperror:\n\t  dump (\"x\", x);\n\t  fprintf (stderr, \"m = %lx, e = %i\\n\", m, e);\n\t  fprintf (stderr, \"d = %.15g\\n\", d);\n\t  fprintf (stderr, \"f = %.15g\\n\", f);\n\t  fprintf (stderr, \"f - d = %.5g\\n\", f - d);\n\t  abort ();\n\t}\n      if ((f == d) ? (mpz_cmp_d (x, d) != 0) : (mpz_cmp_d (x, d) <= 0))\n\t{\n\t  fprintf (stderr, \"mpz_cmp_d (x, d) failed:\\n\");\n\t  goto dumperror;\n\t}\n      f = d - 1.0;\n      if (f < d && ! (mpz_cmp_d (x, f) > 0))\n\t{\n\t  fprintf (stderr, \"mpz_cmp_d (x, f) failed:\\n\");\n\t  goto dumperror;\n\t}\n    }\n\n  mpz_clear (x);\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-gcd.c": {
    "gcdext_valid_p": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static int\ngcdext_valid_p (const mpz_t a, const mpz_t b,\n\t\tconst mpz_t g, const mpz_t s, const mpz_t t)\n{\n  mpz_t ta, tb, r;\n\n  /* It's not clear that gcd(0,0) is well defined, but we allow it and\n     require that gcd(0,0) = 0. */\n  if (mpz_sgn (g) < 0)\n    return 0;\n\n  if (mpz_sgn (a) == 0)\n    {\n      /* Must have g == abs (b). Any value for s is in some sense \"correct\",\n\t but it makes sense to require that s == 0. */\n      return mpz_cmpabs (g, b) == 0 && mpz_sgn (s) == 0;\n    }\n  else if (mpz_sgn (b) == 0)\n    {\n      /* Must have g == abs (a), s == sign (a) */\n      return mpz_cmpabs (g, a) == 0 && mpz_cmp_si (s, mpz_sgn (a)) == 0;\n    }\n\n  if (mpz_sgn (g) <= 0)\n    return 0;\n\n  mpz_init (ta);\n  mpz_init (tb);\n  mpz_init (r);\n\n  mpz_mul (ta, s, a);\n  mpz_mul (tb, t, b);\n  mpz_add (ta, ta, tb);\n\n  if (mpz_cmp (ta, g) != 0)\n    {\n    fail:\n      mpz_clear (ta);\n      mpz_clear (tb);\n      mpz_clear (r);\n      return 0;\n    }\n  mpz_tdiv_qr (ta, r, a, g);\n  if (mpz_sgn (r) != 0)\n    goto fail;\n\n  mpz_tdiv_qr (tb, r, b, g);\n  if (mpz_sgn (r) != 0)\n    goto fail;\n\n  /* Require that 2 |s| < |b/g|, or |s| == 1. */\n  if (mpz_cmpabs_ui (s, 1) > 0)\n    {\n      mpz_mul_2exp (r, s, 1);\n      if (mpz_cmpabs (r, tb) > 0)\n\tgoto fail;\n    }\n\n  /* Require that 2 |t| < |a/g| or |t| == 1*/\n  if (mpz_cmpabs_ui (t, 1) > 0)\n    {\n      mpz_mul_2exp (r, t, 1);\n      if (mpz_cmpabs (r, ta) > 0)\n\treturn 0;\n    }\n\n  mpz_clear (ta);\n  mpz_clear (tb);\n  mpz_clear (r);\n\n  return 1;\n}",
      "lines": 72,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testmain": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t a, b, g, s, t;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (g);\n  mpz_init (s);\n  mpz_init (t);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_random_op3 (OP_GCD, MAXBITS, a, b, s);\n      mpz_gcd (g, a, b);\n      if (mpz_cmp (g, s))\n\t{\n\t  fprintf (stderr, \"mpz_gcd failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", g);\n\t  dump (\"ref\", s);\n\t  abort ();\n\t}\n    }\n\n  for (i = 0; i < COUNT; i++)\n    {\n      unsigned flags;\n      mini_urandomb (a, 32);\n      flags = mpz_get_ui (a);\n      mini_rrandomb (a, MAXBITS);\n      mini_rrandomb (b, MAXBITS);\n\n      if (flags % 37 == 0)\n\tmpz_mul (a, a, b);\n      if (flags % 37 == 1)\n\tmpz_mul (b, a, b);\n\n      if (flags & 1)\n\tmpz_neg (a, a);\n      if (flags & 2)\n\tmpz_neg (b, b);\n\n      mpz_gcdext (g, s, t, a, b);\n      if (!gcdext_valid_p (a, b, g, s, t))\n\t{\n\t  fprintf (stderr, \"mpz_gcdext failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"g\", g);\n\t  dump (\"s\", s);\n\t  dump (\"t\", t);\n\t  abort ();\n\t}\n\n      mpz_gcd (s, a, b);\n      if (mpz_cmp (g, s))\n\t{\n\t  fprintf (stderr, \"mpz_gcd failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", g);\n\t  dump (\"ref\", s);\n\t  abort ();\n\t}\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (g);\n  mpz_clear (s);\n  mpz_clear (t);\n}",
      "lines": 74,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-import.c": {
    "dump_bytes": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void\ndump_bytes (const char *label, const unsigned char *s, size_t n)\n{\n  size_t i;\n  fprintf (stderr, \"%s:\", label);\n  for (i = 0; i < n; i++)\n    {\n      if (i && (i % 16) == 0)\n\tfprintf (stderr, \"\\n\");\n      fprintf (stderr, \" %02x\", s[i]);\n    }\n  fprintf (stderr, \"\\n\");\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned char input[MAX_WORDS * MAX_WORD_SIZE];\n  unsigned char output[MAX_WORDS * MAX_WORD_SIZE + 2];\n  size_t count, in_count, out_count, size;\n  int endian, order;\n\n  mpz_t a, res;\n\n  mpz_init (a);\n  mpz_init (res);\n\n  for (size = 0; size <= MAX_WORD_SIZE; size++)\n    for (count = 0; count <= MAX_WORDS; count++)\n      for (endian = -1; endian <= 1; endian++)\n\tfor (order = -1; order <= 1; order += 2)\n\t  {\n\t    mini_rrandomb_export (a, input, &in_count,\n\t\t\t\t  order, size, endian, size*count * 8);\n\t    mpz_import (res, in_count, order, size, endian, 0, input);\n\t    if (mpz_cmp (a, res))\n\t      {\n\t\tfprintf (stderr, \"mpz_import failed:\\n\"\n\t\t\t \"in_count %lu, out_count %lu, endian = %d, order = %d\\n\",\n\t\t\t (unsigned long) in_count, (unsigned long) out_count, endian, order);\n\t\tdump (\"a\", a);\n\t\tdump (\"res\", res);\n\t\tabort ();\n\t      }\n\t    output[0] = 17;\n\t    output[1+in_count*size] = 17;\n\n\t    mpz_export (output+1, &out_count, order, size, endian, 0, a);\n\t    if (out_count != in_count\n\t\t|| memcmp (output+1, input, in_count * size)\n\t\t|| output[0] != 17\n\t\t|| output[1+in_count*size] != 17)\n\t      {\n\t\tfprintf (stderr, \"mpz_export failed:\\n\"\n\t\t\t \"in_count %lu, out_count %lu, endian = %d, order = %d\\n\",\n\t\t\t (unsigned long) in_count, (unsigned long) out_count, endian, order);\n\t\tdump_bytes (\"input\", input, in_count * size);\n\t\tdump_bytes (\"output\", output+1, out_count * size);\n\t\tif (output[0] != 17)\n\t\t  fprintf (stderr, \"Overwrite at -1, value %02x\\n\", output[0]);\n\t\tif (output[1+in_count*size] != 17)\n\t\t  fprintf (stderr, \"Overwrite at %lu, value %02x\\n\",\n\t\t\t   (unsigned long) (in_count*size), output[1+in_count*size]);\n\n\t\tabort ();\n\t      }\n\t  }\n  mpz_clear (a);\n  mpz_clear (res);\n}",
      "lines": 56,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-invert.c": {
    "test_2by1": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static void\ntest_2by1(const mpz_t u)\n{\n  mpz_t m, p, t;\n\n  mpz_init (m);\n  mpz_init (p);\n  mpz_init (t);\n\n  assert (mpz_size (u) == 1);\n\n  mpz_set_ui (m, mpn_invert_limb (u->_mp_d[0]));\n  mpz_setbit (m, GMP_LIMB_BITS);\n\n  mpz_mul (p, m, u);\n\n  mpz_set_ui (t, 0);\n  mpz_setbit (t, 2* GMP_LIMB_BITS);\n  mpz_sub (t, t, p);\n\n  /* Should have 0 < B^2 - m u <= u */\n  if (mpz_sgn (t) <= 0 || mpz_cmp (t, u) > 0)\n    {\n      fprintf (stderr, \"mpn_invert_limb failed:\\n\");\n      dump (\"u\", u);\n      dump (\"m\", m);\n      dump (\"p\", p);\n      dump (\"t\", t);\n      abort ();\n    }\n  mpz_clear (m);\n  mpz_clear (p);\n  mpz_clear (t);\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_3by2": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static void\ntest_3by2(const mpz_t u)\n{\n  mpz_t m, p, t;\n\n  mpz_init (m);\n  mpz_init (p);\n  mpz_init (t);\n\n  assert (mpz_size (u) == 2);\n\n  mpz_set_ui (m, mpn_invert_3by2 (u->_mp_d[1], u[0]._mp_d[0]));\n\n  mpz_setbit (m, GMP_LIMB_BITS);\n\n  mpz_mul (p, m, u);\n\n  mpz_set_ui (t, 0);\n  mpz_setbit (t, 3 * GMP_LIMB_BITS);\n  mpz_sub (t, t, p);\n\n  /* Should have 0 < B^3 - m u <= u */\n  if (mpz_sgn (t) <= 0 || mpz_cmp (t, u) > 0)\n    {\n      fprintf (stderr, \"mpn_invert_3by2 failed:\\n\");\n      dump (\"u\", u);\n      dump (\"m\", m);\n      dump (\"p\", p);\n      dump (\"t\", t);\n      abort ();\n    }\n  mpz_clear (m);\n  mpz_clear (p);\n  mpz_clear (t);\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t u, m, p, t;\n\n  mpz_init (u);\n  mpz_init (m);\n  mpz_init (p);\n  mpz_init (t);\n\n  /* These values trigger 32-bit overflow of ql in mpn_invert_3by2. */\n  if (GMP_LIMB_BITS == 64)\n    {\n      mpz_set_str (u, \"80007fff3ffe0000\", 16);\n      test_2by1 (u);\n      mpz_set_str (u, \"80007fff3ffe000000000000000003ff\", 16);\n      test_3by2 (u);\n    }\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_urandomb (u, GMP_LIMB_BITS);\n      mpz_setbit (u, GMP_LIMB_BITS -1);\n\n      test_2by1 (u);\n    }\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_urandomb (u, 2*GMP_LIMB_BITS);\n      mpz_setbit (u, 2*GMP_LIMB_BITS -1);\n\n      test_3by2 (u);\n    }\n\n  mpz_clear (u);\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-lcm.c": {
    "testmain": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t a, b, g, s;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (g);\n  mpz_init (s);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_random_op3 (OP_LCM, MAXBITS, a, b, s);\n      mpz_lcm (g, a, b);\n      if (mpz_cmp (g, s))\n\t{\n\t  fprintf (stderr, \"mpz_lcm failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", g);\n\t  dump (\"ref\", s);\n\t  abort ();\n\t}\n      if (mpz_fits_ulong_p (b))\n\t{\n\t  mpz_set_si (g, 0);\n\t  mpz_lcm_ui (g, a, mpz_get_ui (b));\n\t  if (mpz_cmp (g, s))\n\t    {\n\t      fprintf (stderr, \"mpz_lcm_ui failed:\\n\");\n\t      dump (\"a\", a);\n\t      dump (\"b\", b);\n\t      dump (\"r\", g);\n\t      dump (\"ref\", s);\n\t      abort ();\n\t    }\n\t}\n    }\n\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (g);\n  mpz_clear (s);\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-limbs.c": {
    "my_mpz_mul": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\nmy_mpz_mul (mpz_t r, mpz_srcptr a,  mpz_srcptr b)\n{\n  mp_limb_t *tp;\n  mp_size_t tn, an, bn;\n\n  an = mpz_size (a);\n  bn = mpz_size (b);\n\n  assert (an > 0);\n  assert (bn > 0);\n\n  tn = an + bn;\n  tp = mpz_limbs_write (r, tn);\n  if (an > bn)\n    mpn_mul (tp, mpz_limbs_read (a), an, mpz_limbs_read (b), bn);\n  else\n    mpn_mul (tp, mpz_limbs_read (b), bn, mpz_limbs_read (a), an);\n\n  if (mpz_sgn (a) != mpz_sgn(b))\n    tn = - tn;\n\n  mpz_limbs_finish (r, tn);\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t a, b, res, ref;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (res);\n  mpz_init (ref);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_random_op3 (OP_MUL, MAXBITS, a, b, ref);\n      if (mpz_sgn(ref) == 0)\n\t/* my_mpz_mul requires a != 0, b != 0 */\n\tcontinue;\n      my_mpz_mul (res, a, b);\n      if (mpz_cmp (res, ref))\n\t{\n\t  fprintf (stderr, \"my_mpz_mul failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n      /* The following test exploits a side-effect of my_mpz_mul: res\n\t points to a buffer with at least an+bn limbs, and the limbs\n\t above the result are zeroed. */\n      if (mpz_size (b) > 0 && mpz_getlimbn (res, mpz_size(a)) != mpz_limbs_read (res) [mpz_size(a)])\n\t{\n\t  fprintf (stderr, \"getlimbn - limbs_read differ.\\n\");\n\t  abort ();\n\t}\n      if ((i % 4 == 0) && mpz_size (res) > 1)\n\t{\n\t  mpz_realloc2 (res, 1);\n\t  if (mpz_cmp_ui (res, 0))\n\t    {\n\t      fprintf (stderr, \"mpz_realloc2 did not clear res.\\n\");\n\t      abort ();\n\t    }\n\t  mpz_limbs_finish (ref, 0);\n\t  if (mpz_cmp_d (ref, 0))\n\t    {\n\t      fprintf (stderr, \"mpz_limbs_finish did not clear res.\\n\");\n\t      abort ();\n\t    }\n\t}\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (res);\n  mpz_clear (ref);\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-logops.c": {
    "testlogops": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void\ntestlogops (int count)\n{\n  int i;\n  mpz_t a, b, res, ref;\n  mp_bitcnt_t c;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (res);\n  mpz_init (ref);\n\n  for (i = 0; i < count; i++)\n    {\n      mini_random_op3 (OP_AND, MAXBITS, a, b, ref);\n      mpz_and (res, a, b);\n      if (mpz_cmp (res, ref))\n\t{\n\t  fprintf (stderr, \"mpz_and failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n\n      mini_random_op3 (OP_IOR, MAXBITS, a, b, ref);\n      mpz_ior (res, a, b);\n      if (mpz_cmp (res, ref))\n\t{\n\t  fprintf (stderr, \"mpz_ior failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n\n      mini_random_op3 (OP_XOR, MAXBITS, a, b, ref);\n      mpz_xor (res, a, b);\n      if (mpz_cmp (res, ref))\n\t{\n\t  fprintf (stderr, \"mpz_xor failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n\n      if (i % 8) {\n\tc = 0;\n\tmpz_mul_2exp (res, res, i % 8);\n      } else if (mpz_sgn (res) >= 0) {\n\tc = mpz_odd_p (res) != 0;\n\tmpz_tdiv_q_2exp (res, res, 1);\n      } else {\n\tc = (~ (mp_bitcnt_t) 0) - 3;\n\tmpz_set_ui (res, 11 << ((i >> 3)%4)); /* set 3 bits */\n      }\n\n      if (mpz_popcount (res) + c != mpz_hamdist (a, b))\n\t{\n\t  fprintf (stderr, \"mpz_popcount(r) + %lu and mpz_hamdist(a,b) differ:\\n\", c);\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", res);\n\t  fprintf (stderr, \"mpz_popcount(r) = %lu:\\n\", mpz_popcount (res));\n\t  fprintf (stderr, \"mpz_hamdist(a,b) = %lu:\\n\", mpz_hamdist (a, b));\n\t  abort ();\n\t}\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (res);\n  mpz_clear (ref);\n}",
      "lines": 77,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  testhalves (COUNT*2/3, testlogops);\n  testlogops (COUNT/3);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-mul.c": {
    "testmain": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t a, b, res, res_ui, ref, tz;\n  mp_limb_t t[2*MAXLIMBS];\n  mp_size_t an;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (res);\n  mpz_init (res_ui);\n  mpz_init (ref);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_random_op3 (OP_MUL, MAXBITS, a, b, ref);\n      mpz_mul (res, a, b);\n      if (mpz_cmp (res, ref))\n\t{\n\t  fprintf (stderr, \"mpz_mul failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n      if (mpz_size (a) == mpz_size (b))\n\t{\n\t  memset (t, 0x55, sizeof(t));\n\t  an = mpz_size (a);\n\t  if (an > 0)\n\t    {\n\t      mpn_mul_n (t, a->_mp_d, b->_mp_d, an);\n\n\t      mpz_roinit_n (tz, t, 2*an);\n\t      if (mpz_cmpabs (tz, ref))\n\t\t{\n\t\t  fprintf (stderr, \"mpn_mul_n failed:\\n\");\n\t\t  dump (\"a\", a);\n\t\t  dump (\"b\", b);\n\t\t  dump (\"ref\", ref);\n\t\t  abort ();\n\t\t}\n\t    }\n\t}\n      if (mpz_fits_slong_p (b)) {\n\tmpz_mul_si (res_ui, a, mpz_get_si (b));\n\tif (mpz_cmp (res_ui, ref))\n\t  {\n\t    fprintf (stderr, \"mpz_mul_si failed:\\n\");\n\t    dump (\"a\", a);\n\t    dump (\"b\", b);\n\t    dump (\"r\", res_ui);\n\t    dump (\"ref\", ref);\n\t    abort ();\n\t  }\n      }\n      mini_random_op2 (OP_SQR, MAXBITS, a, ref);\n      an = mpz_size (a);\n      if (an > 0)\n\t{\n\t  memset (t, 0x33, sizeof(t));\n\t  mpn_sqr (t, mpz_limbs_read (a), an);\n\n\t  mpz_roinit_n (tz, t, 2*an);\n\t  if (mpz_cmp (tz, ref))\n\t    {\n\t      fprintf (stderr, \"mpn (squaring) failed:\\n\");\n\t      dump (\"a\", a);\n\t      dump (\"ref\", ref);\n\t      abort ();\n\t    }\n\t}\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (res);\n  mpz_clear (res_ui);\n  mpz_clear (ref);\n}",
      "lines": 81,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-powm.c": {
    "testmain": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t b, e, m, res, ref;\n\n  mpz_init (b);\n  mpz_init (e);\n  mpz_init (m);\n  mpz_init (res);\n  mpz_init (ref);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_random_op4 (OP_POWM, MAXBITS, b, e, m, ref);\n      mpz_powm (res, b, e, m);\n      if (mpz_cmp (res, ref))\n\t{\n\t  fprintf (stderr, \"mpz_powm failed:\\n\");\n\t  dump (\"b\", b);\n\t  dump (\"e\", e);\n\t  dump (\"m\", m);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n    }\n  mpz_clear (b);\n  mpz_clear (e);\n  mpz_clear (m);\n  mpz_clear (res);\n  mpz_clear (ref);\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-pprime_p.c": {
    "isprime": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static int\nisprime (unsigned long int t)\n{\n  unsigned long int q, r, d;\n\n  if (t < 32)\n    return (0xa08a28acUL >> t) & 1;\n  if ((t & 1) == 0)\n    return 0;\n\n  if (t % 3 == 0)\n    return 0;\n  if (t % 5 == 0)\n    return 0;\n  if (t % 7 == 0)\n    return 0;\n\n  for (d = 11;;)\n    {\n      q = t / d;\n      r = t - q * d;\n      if (q < d)\n\treturn 1;\n      if (r == 0)\n\tbreak;\n      d += 2;\n      q = t / d;\n      r = t - q * d;\n      if (q < d)\n\treturn 1;\n      if (r == 0)\n\tbreak;\n      d += 4;\n    }\n  return 0;\n}",
      "lines": 36,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_one": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static void\ncheck_one (mpz_srcptr n, int want)\n{\n  int  got;\n\n  got = mpz_probab_prime_p (n, 25);\n\n  /* \"definitely prime\" is fine if we only wanted \"probably prime\" */\n  if (got == 2 && want == 1)\n    want = 2;\n\n  if (got != want)\n    {\n      printf (\"mpz_probab_prime_p\\n\");\n      dump   (\"  n    \", n);\n      printf (\"  got =%d\", got);\n      printf (\"  want=%d\\n\", want);\n      abort ();\n    }\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_pn": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\ncheck_pn (mpz_ptr n, int want)\n{\n  check_one (n, want);\n  mpz_neg (n, n);\n  check_one (n, want);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_small": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static void\ncheck_small (void)\n{\n  mpz_t  n;\n  long   i;\n\n  mpz_init (n);\n\n  for (i = 0; i < 1700; i++)\n    {\n      mpz_set_si (n, i);\n      check_pn (n, isprime (i));\n    }\n\n  mpz_clear (n);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_composites": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\ncheck_composites (void)\n{\n  int i;\n  int reps = 1000;\n  mpz_t a, b, n, bs;\n  unsigned long size_range, size;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (n);\n  mpz_init (bs);\n\n  for (i = 0; i < reps; i++)\n    {\n      mini_urandomb (bs, 16);\n      size_range = mpz_get_ui (bs) % 10 + 1; /* 0..1024 bit operands */\n\n      mini_urandomb (bs, size_range);\n      size = mpz_get_ui (bs);\n      mini_rrandomb (a, size);\n\n      mini_urandomb (bs, size_range);\n      size = mpz_get_ui (bs);\n      mini_rrandomb (b, size);\n\n      /* Exclude trivial factors */\n      if (mpz_cmp_ui (a, 1) == 0)\n\tmpz_set_ui (a, 2);\n      if (mpz_cmp_ui (b, 1) == 0)\n\tmpz_set_ui (b, 2);\n\n      mpz_mul (n, a, b);\n\n      check_pn (n, 0);\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (n);\n  mpz_clear (bs);\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_primes": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static void\ncheck_primes (void)\n{\n  static const char * const primes[] = {\n    \"2\", \"17\", \"65537\",\n    /* diffie-hellman-group1-sha1, also \"Well known group 2\" in RFC\n       2412, 2^1024 - 2^960 - 1 + 2^64 * { [2^894 pi] + 129093 } */\n    \"0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\"\n    \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\"\n    \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\"\n    \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\"\n    \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381\"\n    \"FFFFFFFFFFFFFFFF\",\n    NULL\n  };\n\n  mpz_t n;\n  int i;\n\n  mpz_init (n);\n\n  for (i = 0; primes[i]; i++)\n    {\n      mpz_set_str_or_abort (n, primes[i], 0);\n      check_one (n, 1);\n    }\n  mpz_clear (n);\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void\ntestmain (int argc, char *argv[])\n{\n  check_small ();\n  check_composites ();\n  check_primes ();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-reuse.c": {
    "mpz_xinvert": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\nmpz_xinvert (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  int res;\n  res = mpz_invert (r, a, b);\n  if (res == 0)\n    mpz_set_ui (r, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        624,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  int pass, reps = COUNT;\n  mpz_t in1, in2, in3;\n  unsigned long int in2i;\n  mp_size_t size;\n  mpz_t res1, res2, res3;\n  mpz_t ref1, ref2, ref3;\n  mpz_t t;\n  unsigned long int r1, r2;\n  long failures = 0;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n\n  mpz_init (bs);\n\n  mpz_init (in1);\n  mpz_init (in2);\n  mpz_init (in3);\n  mpz_init (ref1);\n  mpz_init (ref2);\n  mpz_init (ref3);\n  mpz_init (res1);\n  mpz_init (res2);\n  mpz_init (res3);\n  mpz_init (t);\n\n  for (pass = 1; pass <= reps; pass++)\n    {\n      mini_urandomb (bs, 32);\n      size_range = mpz_get_ui (bs) % 12 + 2;\n\n      mini_urandomb (bs, size_range);\n      size = mpz_get_ui (bs);\n      mini_rrandomb (in1, size);\n\n      mini_urandomb (bs, size_range);\n      size = mpz_get_ui (bs);\n      mini_rrandomb (in2, size);\n\n      mini_urandomb (bs, size_range);\n      size = mpz_get_ui (bs);\n      mini_rrandomb (in3, size);\n\n      mini_urandomb (bs, 3);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (in1, in1);\n      if ((bsi & 2) != 0)\n\tmpz_neg (in2, in2);\n      if ((bsi & 4) != 0)\n\tmpz_neg (in3, in3);\n\n      for (i = 0; i < sizeof (dss_funcs) / sizeof (dss_func); i++)\n\t{\n\t  if (dss_funcs[i] == 0)\n\t    continue;\n\t  if (dss_func_division[i] && mpz_sgn (in2) == 0)\n\t    continue;\n\n\t  (dss_funcs[i]) (ref1, in1, in2);\n\t  mpz_check_format (ref1);\n\n\t  mpz_set (res1, in1);\n\t  (dss_funcs[i]) (res1, res1, in2);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL (dss, i, in1, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  (dss_funcs[i]) (res1, in1, res1);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL (dss, i, in1, in2, NULL);\n\t}\n\n      for (i = 0; i < sizeof (ddss_div_funcs) / sizeof (ddss_div_func); i++)\n\t{\n\t  if (ddss_div_funcs[i] == 0)\n\t    continue;\n\t  if (mpz_sgn (in2) == 0)\n\t    continue;\n\n\t  (ddss_div_funcs[i]) (ref1, ref2, in1, in2);\n\t  mpz_check_format (ref1);\n\t  mpz_check_format (ref2);\n\n\t  mpz_set (res1, in1);\n\t  (ddss_div_funcs[i]) (res1, res2, res1, in2);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL (ddss_div, i, in1, in2, NULL);\n\n\t  mpz_set (res2, in1);\n\t  (ddss_div_funcs[i]) (res1, res2, res2, in2);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL (ddss_div, i, in1, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  (ddss_div_funcs[i]) (res1, res2, in1, res1);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL (ddss_div, i, in1, in2, NULL);\n\n\t  mpz_set (res2, in2);\n\t  (ddss_div_funcs[i]) (res1, res2, in1, res2);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL (ddss_div, i, in1, in2, NULL);\n\t}\n\n      for (i = 0; i < sizeof (ds_funcs) / sizeof (ds_func); i++)\n\t{\n\t  if (ds_funcs[i] == 0)\n\t    continue;\n\t  if (strcmp (ds_func_names[i], \"mpz_sqrt\") == 0\n\t      && mpz_sgn (in1) < 0)\n\t    continue;\n\n\t  (ds_funcs[i]) (ref1, in1);\n\t  mpz_check_format (ref1);\n\n\t  mpz_set (res1, in1);\n\t  (ds_funcs[i]) (res1, res1);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL (ds, i, in1, in2, NULL);\n\t}\n\n      in2i = mpz_get_ui (in2);\n\n      for (i = 0; i < sizeof (dsi_funcs) / sizeof (dsi_func); i++)\n\t{\n\t  if (dsi_funcs[i] == 0)\n\t    continue;\n\t  if (strcmp (dsi_func_names[i], \"mpz_fdiv_q_2exp\") == 0)\n\t    /* Limit exponent to something reasonable for the division\n\t       functions.  Without this, we'd  normally shift things off\n\t       the end and just generate the trivial values 1, 0, -1.  */\n\t    in2i %= 0x1000;\n\t  if (strcmp (dsi_func_names[i], \"mpz_mul_2exp\") == 0)\n\t    /* Limit exponent more for mpz_mul_2exp to save time.  */\n\t    in2i %= 0x100;\n\t  if (strcmp (dsi_func_names[i], \"mpz_pow_ui\") == 0)\n\t    /* Limit exponent yet more for mpz_pow_ui to save time.  */\n\t    in2i %= 0x10;\n\n\t  (dsi_funcs[i]) (ref1, in1, in2i);\n\t  mpz_check_format (ref1);\n\n\t  mpz_set (res1, in1);\n\t  (dsi_funcs[i]) (res1, res1, in2i);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL (dsi, i, in1, in2, NULL);\n\t}\n\n      if (in2i != 0)\t  /* Don't divide by 0.  */\n\t{\n\t  for (i = 0; i < sizeof (dsi_div_funcs) / sizeof (dsi_div_funcs); i++)\n\t    {\n\t      r1 = (dsi_div_funcs[i]) (ref1, in1, in2i);\n\t      mpz_check_format (ref1);\n\n\t      mpz_set (res1, in1);\n\t      r2 = (dsi_div_funcs[i]) (res1, res1, in2i);\n\t      mpz_check_format (res1);\n\t      if (mpz_cmp (ref1, res1) != 0 || r1 != r2)\n\t\tFAIL (dsi_div, i, in1, in2, NULL);\n\t    }\n\n\t  for (i = 0; i < sizeof (ddsi_div_funcs) / sizeof (ddsi_div_funcs); i++)\n\t    {\n\t      r1 = (ddsi_div_funcs[i]) (ref1, ref2, in1, in2i);\n\t      mpz_check_format (ref1);\n\n\t      mpz_set (res1, in1);\n\t      r2 = (ddsi_div_funcs[i]) (res1, res2, res1, in2i);\n\t      mpz_check_format (res1);\n\t      if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0 || r1 != r2)\n\t\tFAIL (ddsi_div, i, in1, in2, NULL);\n\n\t      mpz_set (res2, in1);\n\t      (ddsi_div_funcs[i]) (res1, res2, res2, in2i);\n\t      mpz_check_format (res1);\n\t      if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0 || r1 != r2)\n\t\tFAIL (ddsi_div, i, in1, in2, NULL);\n\t    }\n\t}\n\n      if (mpz_sgn (in1) >= 0)\n\t{\n\t  mpz_sqrtrem (ref1, ref2, in1);\n\t  mpz_check_format (ref1);\n\t  mpz_check_format (ref2);\n\n\t  mpz_set (res1, in1);\n\t  mpz_sqrtrem (res1, res2, res1);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL2 (mpz_sqrtrem, in1, NULL, NULL);\n\n\t  mpz_set (res2, in1);\n\t  mpz_sqrtrem (res1, res2, res2);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL2 (mpz_sqrtrem, in1, NULL, NULL);\n\t}\n\n      if (mpz_sgn (in1) >= 0)\n\t{\n\t  mpz_root (ref1, in1, in2i % 0x1000 + 1);\n\t  mpz_check_format (ref1);\n\n\t  mpz_set (res1, in1);\n\t  mpz_root (res1, res1, in2i % 0x1000 + 1);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_root, in1, in2, NULL);\n\t}\n\n      if (mpz_sgn (in1) >= 0)\n\t{\n\t  mpz_rootrem (ref1, ref2, in1, in2i % 0x1000 + 1);\n\t  mpz_check_format (ref1);\n\t  mpz_check_format (ref2);\n\n\t  mpz_set (res1, in1);\n\t  mpz_rootrem (res1, res2, res1, in2i % 0x1000 + 1);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL2 (mpz_rootrem, in1, in2, NULL);\n\n\t  mpz_set (res2, in1);\n\t  mpz_rootrem (res1, res2, res2, in2i % 0x1000 + 1);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL2 (mpz_rootrem, in1, in2, NULL);\n\t}\n\n      if (pass < reps / 2)\t/* run fewer tests since gcdext lots of time */\n\t{\n\t  mpz_gcdext (ref1, ref2, ref3, in1, in2);\n\t  mpz_check_format (ref1);\n\t  mpz_check_format (ref2);\n\t  mpz_check_format (ref3);\n\n\t  mpz_set (res1, in1);\n\t  mpz_gcdext (res1, res2, res3, res1, in2);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  mpz_check_format (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res2, in1);\n\t  mpz_gcdext (res1, res2, res3, res2, in2);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  mpz_check_format (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res3, in1);\n\t  mpz_gcdext (res1, res2, res3, res3, in2);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  mpz_check_format (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  mpz_gcdext (res1, res2, res3, in1, res1);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  mpz_check_format (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res2, in2);\n\t  mpz_gcdext (res1, res2, res3, in1, res2);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  mpz_check_format (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res3, in2);\n\t  mpz_gcdext (res1, res2, res3, in1, res3);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  mpz_check_format (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res1, in1);\n\t  mpz_gcdext (res1, res2, NULL, res1, in2);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res2, in1);\n\t  mpz_gcdext (res1, res2, NULL, res2, in2);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  mpz_gcdext (res1, res2, NULL, in1, res1);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res2, in2);\n\t  mpz_gcdext (res1, res2, NULL, in1, res2);\n\t  mpz_check_format (res1);\n\t  mpz_check_format (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\t}\n\n      /* Don't run mpz_powm for huge exponents or when undefined.  */\n      if (mpz_sizeinbase (in2, 2) < 250 && mpz_sgn (in3) != 0\n\t  && (mpz_sgn (in2) >= 0 || mpz_invert (t, in1, in3)))\n\t{\n\t  mpz_powm (ref1, in1, in2, in3);\n\t  mpz_check_format (ref1);\n\n\t  mpz_set (res1, in1);\n\t  mpz_powm (res1, res1, in2, in3);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_powm, in1, in2, in3);\n\n\t  mpz_set (res1, in2);\n\t  mpz_powm (res1, in1, res1, in3);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_powm, in1, in2, in3);\n\n\t  mpz_set (res1, in3);\n\t  mpz_powm (res1, in1, in2, res1);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_powm, in1, in2, in3);\n\t}\n\n      /* Don't run mpz_powm_ui when undefined.  */\n      if (mpz_sgn (in3) != 0)\n\t{\n\t  mpz_powm_ui (ref1, in1, in2i, in3);\n\t  mpz_check_format (ref1);\n\n\t  mpz_set (res1, in1);\n\t  mpz_powm_ui (res1, res1, in2i, in3);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_powm_ui, in1, in2, in3);\n\n\t  mpz_set (res1, in3);\n\t  mpz_powm_ui (res1, in1, in2i, res1);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_powm_ui, in1, in2, in3);\n\t}\n\n      {\n\tr1 = mpz_gcd_ui (ref1, in1, in2i);\n\tmpz_check_format (ref1);\n\n\tmpz_set (res1, in1);\n\tr2 = mpz_gcd_ui (res1, res1, in2i);\n\tmpz_check_format (res1);\n\tif (mpz_cmp (ref1, res1) != 0)\n\t  FAIL2 (mpz_gcd_ui, in1, in2, NULL);\n      }\n#if 0\n      if (mpz_cmp_ui (in2, 1L) > 0 && mpz_sgn (in1) != 0)\n\t{\n\t  /* Test mpz_remove */\n\t  mpz_remove (ref1, in1, in2);\n\t  mpz_check_format (ref1);\n\n\t  mpz_set (res1, in1);\n\t  mpz_remove (res1, res1, in2);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_remove, in1, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  mpz_remove (res1, in1, res1);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_remove, in1, in2, NULL);\n\t}\n#endif\n      if (mpz_sgn (in2) != 0)\n\t{\n\t  /* Test mpz_divexact */\n\t  mpz_mul (t, in1, in2);\n\t  mpz_divexact (ref1, t, in2);\n\t  mpz_check_format (ref1);\n\n\t  mpz_set (res1, t);\n\t  mpz_divexact (res1, res1, in2);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_divexact, t, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  mpz_divexact (res1, t, res1);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_divexact, t, in2, NULL);\n\t}\n\n#if 0\n      if (mpz_sgn (in2) > 0)\n\t{\n\t  /* Test mpz_divexact_gcd, same as mpz_divexact */\n\t  mpz_mul (t, in1, in2);\n\t  mpz_divexact_gcd (ref1, t, in2);\n\t  mpz_check_format (ref1);\n\n\t  mpz_set (res1, t);\n\t  mpz_divexact_gcd (res1, res1, in2);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_divexact_gcd, t, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  mpz_divexact_gcd (res1, t, res1);\n\t  mpz_check_format (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_divexact_gcd, t, in2, NULL);\n\t}\n#endif\n    }\n\n  if (failures != 0)\n    {\n      fprintf (stderr, \"mpz/reuse: %ld error%s\\n\", failures, \"s\" + (failures == 1));\n      exit (1);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (in1);\n  mpz_clear (in2);\n  mpz_clear (in3);\n  mpz_clear (ref1);\n  mpz_clear (ref2);\n  mpz_clear (ref3);\n  mpz_clear (res1);\n  mpz_clear (res2);\n  mpz_clear (res3);\n  mpz_clear (t);\n}",
      "lines": 481,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "dump3": {
      "start_point": [
        626,
        0
      ],
      "end_point": [
        642,
        1
      ],
      "content": "void\ndump3 (const char *name, mpz_t in1, mpz_t in2, mpz_t in3)\n{\n  printf (\"failure in %s (\", name);\n  mpz_out_str (stdout, -16, in1);\n  if (in2 != NULL)\n    {\n      printf (\" \");\n      mpz_out_str (stdout, -16, in2);\n    }\n  if (in3 != NULL)\n    {\n      printf (\" \");\n      mpz_out_str (stdout, -16, in3);\n    }\n  printf (\")\\n\");\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_check_format": {
      "start_point": [
        644,
        0
      ],
      "end_point": [
        662,
        1
      ],
      "content": "void\nmpz_check_format (const mpz_t x)\n{\n  mp_size_t n = x ->_mp_size;\n  if (n < 0)\n    n = - n;\n\n  if (n > x->_mp_alloc)\n    {\n      fprintf (stderr, \"mpz_t size exceeds allocation!\\n\");\n      abort ();\n    }\n\n  if (n > 0 && x->_mp_d[n-1] == 0)\n    {\n      fprintf (stderr, \"Unnormalized mpz_t!\\n\");\n      abort ();\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-root.c": {
    "rootrem_valid_p": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\nrootrem_valid_p (const mpz_t u, const mpz_t s, const mpz_t r, unsigned long z)\n{\n  mpz_t t;\n\n  mpz_init (t);\n  if (mpz_fits_ulong_p (s))\n    mpz_ui_pow_ui (t, mpz_get_ui (s), z);\n  else\n    mpz_pow_ui (t, s, z);\n  mpz_sub (t, u, t);\n  if ((mpz_sgn (t) != mpz_sgn(u) && mpz_sgn (t) != 0) || mpz_cmp (t, r) != 0)\n    {\n      mpz_clear (t);\n      return 0;\n    }\n  if (mpz_sgn (s) > 0)\n    mpz_add_ui (t, s, 1);\n  else\n    mpz_sub_ui (t, s, 1);\n  mpz_pow_ui (t, t, z);\n  if (mpz_cmpabs (t, u) <= 0)\n    {\n      mpz_clear (t);\n      return 0;\n    }\n\n  mpz_clear (t);\n  return 1;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testmain": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  unsigned long e;\n  mpz_t u, s, r, bs;\n\n  mpz_init (u);\n  mpz_init (s);\n  mpz_init (r);\n  mpz_init (bs);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_rrandomb (u, MAXBITS);\n      mini_rrandomb (bs, 12);\n      e = mpz_getlimbn (bs, 0) % mpz_sizeinbase (u, 2) + 1;\n      if ((e & 1) && (mpz_getlimbn (bs, 0) & (1L<<10)))\n\tmpz_neg (u, u);\n      mpz_rootrem (s, r, u, e);\n\n      if (!rootrem_valid_p (u, s, r, e))\n\t{\n\t  fprintf (stderr, \"mpz_rootrem(%lu-th) failed:\\n\", e);\n\t  dump (\"u\", u);\n\t  dump (\"root\", s);\n\t  dump (\"rem\", r);\n\t  abort ();\n\t}\n    }\n  mpz_clear (bs);\n  mpz_clear (u);\n  mpz_clear (s);\n  mpz_clear (r);\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-scan.c": {
    "testmain": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t a;\n  mp_bitcnt_t b, res, ref;\n\n  mpz_init (a);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_random_scan_op (OP_SCAN0, MAXBITS, a, &b, &ref);\n      res = mpz_scan0 (a, b);\n      if (res != ref)\n\t{\n\t  fprintf (stderr, \"mpz_scan0 failed:\\n\");\n\t  dump (\"a\", a);\n\t  fprintf (stderr, \"b: %lu\\n\", b);\n\t  fprintf (stderr, \"r: %lu\\n\", res);\n\t  fprintf (stderr, \"ref: %lu\\n\", ref);\n\t  abort ();\n\t}\n      if (mpz_sgn (a) > 0 && ref < mpz_sizeinbase (a, 2))\n\t{\n\t  res = mpn_scan0 (a->_mp_d, b);\n\t  if (res != ref)\n\t    {\n\t      fprintf (stderr, \"mpn_scan0 failed:\\n\");\n\t      dump (\"a\", a);\n\t      fprintf (stderr, \"b: %lu\\n\", b);\n\t      fprintf (stderr, \"r: %lu\\n\", res);\n\t      fprintf (stderr, \"ref: %lu\\n\", ref);\n\t      abort ();\n\t    }\n\t}\n      mini_random_scan_op (OP_SCAN1, MAXBITS, a, &b, &ref);\n      res = mpz_scan1 (a, b);\n      if (res != ref)\n\t{\n\t  fprintf (stderr, \"mpz_scan1 failed:\\n\");\n\t  dump (\"a\", a);\n\t  fprintf (stderr, \"b: %lu\\n\", b);\n\t  fprintf (stderr, \"r: %lu\\n\", res);\n\t  fprintf (stderr, \"ref: %lu\\n\", ref);\n\t  abort ();\n\t}\n      if (mpz_sgn (a) > 0 && ref != ~ (mp_bitcnt_t) 0)\n\t{\n\t  res = mpn_scan1 (a->_mp_d, b);\n\t  if (res != ref)\n\t    {\n\t      fprintf (stderr, \"mpn_scan1 failed:\\n\");\n\t      dump (\"a\", a);\n\t      fprintf (stderr, \"b: %lu\\n\", b);\n\t      fprintf (stderr, \"r: %lu\\n\", res);\n\t      fprintf (stderr, \"ref: %lu\\n\", ref);\n\t      abort ();\n\t    }\n\t}\n    }\n  mpz_clear (a);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-signed.c": {
    "check_si": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ncheck_si (const mpz_t sz, long si)\n{\n  mpz_t t;\n\n  /* Checks on sz/si */\n  if ((mpz_cmp_si (sz, si)) != 0)\n    {\n      printf (\"mpz_cmp_si (sz, %ld) != 0.\\n\", si);\n      return 0;\n    }\n  if (mpz_get_si (sz) != si)\n    {\n      printf (\"mpz_get_si (sz) != %ld.\\n\", si);\n      return 0;\n    }\n\n  mpz_init_set_si (t, si);\n\n  if (mpz_cmp (t, sz) != 0)\n    {\n      printf (\"mpz_init_set_si (%ld) failed.\\n\", si);\n      printf (\" got=\"); mpz_out_str (stdout, 10, t); printf (\"\\n\");\n      return 0;\n    }\n\n  mpz_clear (t);\n  return 1;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "check_si_cmp": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\ncheck_si_cmp (const mpz_t sz, const mpz_t oz, long si, long oi, int c)\n{\n  if (mpz_cmp (sz, oz) != c)\n    {\n      printf (\"mpz_cmp (sz, oz) != %i.\\n\", c);\n      goto fail;\n    }\n\n  if (mpz_fits_slong_p (sz))\n    {\n      if (!check_si (sz, si))\n\tgoto fail;\n      if (mpz_cmp_si (oz, si) != -c)\n\t{\n\t  printf (\"mpz_cmp_si (oz, %ld) != %i.\\n\", si, -c);\n\t  goto fail;\n\t}\n    }\n  else\n    {\n      if (mpz_cmp_si (sz, si) != c)\n\t{\n\t  printf (\"mpz_cmp_si (sz, %ld) != %i.\\n\", si, c);\n\t  goto fail;\n\t}\n      if (mpz_cmp_si (sz, -c) != c)\n\t{\n\t  printf (\"mpz_cmp_si (sz, %i) != %i.\\n\", -c, c);\n\t  goto fail;\n\t}\n    }\n  if (mpz_fits_slong_p (oz)) \n    {\n      if (!check_si (oz, oi))\n\tgoto fail;\n      if (mpz_cmp_si (sz, oi) != c)\n\t{\n\t  printf (\"mpz_cmp_si (sz, %ld) != %i.\\n\", oi, c);\n\t  goto fail;\n\t}\n    }\n  return;\n\n fail:\n  printf (\" sz=\"); mpz_out_str (stdout, 10, sz); printf (\"\\n\");\n  printf (\" si=%ld\\n\", si);\n  printf (\" oz=\"); mpz_out_str (stdout, 10, oz); printf (\"\\n\");\n  printf (\" oi=%ld\\n\", si);\n  abort ();\n}",
      "lines": 51,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "try_op_si": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\ntry_op_si (int c)\n{\n  long  si, oi;\n  mpz_t sz, oz;\n  unsigned overflow_count;\n\n  si = c;\n  mpz_init_set_si (sz, si);\n\n  oi = si;\n  mpz_init_set (oz, sz);\n\n  /* To get a few tests with operands straddling the border, don't\n     stop at the very first operand exceeding a signed long. */\n  for (overflow_count = 0; overflow_count < 10; )\n    {\n      /* c * 2^k */\n      mpz_mul_2exp (sz, sz, 1);\n      if (mpz_fits_slong_p (sz))\n\tsi *= 2;\n      else\n\toverflow_count++;\n\n      check_si_cmp (sz, oz, si, oi, c);\n    \n      /* c * (2^k + 1) */\n      if (c == -1)\n\tmpz_sub_ui (oz, sz, 1);\n      else\n\tmpz_add_ui (oz, sz, 1);\n      if (mpz_fits_slong_p (oz))\n\toi = si + c;      \n      else \n\toverflow_count++;\n      check_si_cmp (oz, sz, oi, si, c);\n\n      /* c * (2^K - 1) */\n      mpz_mul_si (oz, sz, 2*c);\n      if (c == -1)\n\tmpz_ui_sub (oz, 1, oz); /* oz = sz * 2 + 1 */\n      else\n\tmpz_sub_ui (oz, oz, 1); /* oz = sz * 2 - 1 */\n      if (mpz_fits_slong_p (oz))\n\toi = (si - c) * 2 + c; \n      else \n\toverflow_count++;\n      \n      check_si_cmp (oz, sz, oi, si, c);\n    };\n  \n  mpz_clear (sz);\n  mpz_clear (oz);\n}",
      "lines": 54,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "try_fits_slong_p": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "void \ntry_fits_slong_p (void)\n{\n  mpz_t x;\n  mpz_init_set_si (x, LONG_MAX);\n  if (!mpz_fits_slong_p (x))\n    {\n      printf (\"mpz_fits_slong_p (LONG_MAX) false!\\n\");\n      abort ();\n    }\n  mpz_add_ui (x, x, 1);\n  if (mpz_fits_slong_p (x))\n    {\n      printf (\"mpz_fits_slong_p (LONG_MAX + 1) true!\\n\");\n      abort ();\n    }\n  mpz_set_si (x, LONG_MIN);\n  if (!mpz_fits_slong_p (x))\n    {\n      printf (\"mpz_fits_slong_p (LONG_MIN) false!\\n\");\n      abort ();\n    }\n  mpz_sub_ui (x, x, 1);\n  if (mpz_fits_slong_p (x))\n    {\n      printf (\"mpz_fits_slong_p (LONG_MIN - 1) true!\\n\");\n      abort ();\n    }\n\n  mpz_clear (x);\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "void\ntestmain (int argc, char *argv[])\n{\n  try_fits_slong_p ();\n  try_op_si (-1);\n  try_op_si (1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-sqrt.c": {
    "sqrtrem_valid_p": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\nsqrtrem_valid_p (const mpz_t u, const mpz_t s, const mpz_t r)\n{\n  mpz_t t;\n\n  mpz_init (t);\n  mpz_mul (t, s, s);\n  mpz_sub (t, u, t);\n  if (mpz_sgn (t) < 0 || mpz_cmp (t, r) != 0)\n    {\n      mpz_clear (t);\n      return 0;\n    }\n  mpz_add_ui (t, s, 1);\n  mpz_mul (t, t, t);\n  if (mpz_cmp (t, u) <= 0)\n    {\n      mpz_clear (t);\n      return 0;\n    }\n\n  mpz_clear (t);\n  return 1;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpz_mpn_sqrtrem": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\nmpz_mpn_sqrtrem (mpz_t s, mpz_t r, const mpz_t u)\n{\n  mp_limb_t *sp, *rp;\n  mp_size_t un, sn, ret;\n\n  un = mpz_size (u);\n\n  mpz_xor (s, s, u);\n  sn = (un + 1) / 2;\n  sp = mpz_limbs_write (s, sn + 1);\n  sp [sn] = 11;\n\n  if (un & 1)\n    rp = NULL; /* Exploits the fact that r already is correct. */\n  else {\n    mpz_add (r, u, s);\n    rp = mpz_limbs_write (r, un + 1);\n    rp [un] = 19;\n  }\n\n  ret = mpn_sqrtrem (sp, rp, mpz_limbs_read (u), un);\n\n  if (sp [sn] != 11)\n    {\n      fprintf (stderr, \"mpn_sqrtrem buffer overrun on sp.\\n\");\n      abort ();\n    }\n  if (un & 1) {\n    if ((ret != 0) != (mpz_size (r) != 0)) {\n      fprintf (stderr, \"mpn_sqrtrem wrong return value with NULL.\\n\");\n      abort ();\n    }\n  } else {\n    mpz_limbs_finish (r, ret);\n    if (ret != mpz_size (r)) {\n      fprintf (stderr, \"mpn_sqrtrem wrong return value.\\n\");\n      abort ();\n    }\n    if (rp [un] != 19)\n      {\n\tfprintf (stderr, \"mpn_sqrtrem buffer overrun on rp.\\n\");\n\tabort ();\n      }\n  }\n\n  mpz_limbs_finish (s, (un + 1) / 2);\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t u, s, r;\n\n  mpz_init (s);\n  mpz_init (r);\n\n  mpz_init_set_si (u, -1);\n  if (mpz_perfect_square_p (u))\n    {\n      fprintf (stderr, \"mpz_perfect_square_p failed on -1.\\n\");\n      abort ();\n    }\n\n  if (!mpz_perfect_square_p (s))\n    {\n      fprintf (stderr, \"mpz_perfect_square_p failed on 0.\\n\");\n      abort ();\n    }\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_rrandomb (u, MAXBITS - (i & 0xFF));\n      mpz_sqrtrem (s, r, u);\n\n      if (!sqrtrem_valid_p (u, s, r))\n\t{\n\t  fprintf (stderr, \"mpz_sqrtrem failed:\\n\");\n\t  dump (\"u\", u);\n\t  dump (\"sqrt\", s);\n\t  dump (\"rem\", r);\n\t  abort ();\n\t}\n\n      mpz_mpn_sqrtrem (s, r, u);\n\n      if (!sqrtrem_valid_p (u, s, r))\n\t{\n\t  fprintf (stderr, \"mpn_sqrtrem failed:\\n\");\n\t  dump (\"u\", u);\n\t  dump (\"sqrt\", s);\n\t  dump (\"rem\", r);\n\t  abort ();\n\t}\n\n      if (mpz_sgn (r) == 0) {\n\tmpz_neg (u, u);\n\tmpz_sub_ui (u, u, 1);\n      }\n\n      if ((mpz_sgn (u) <= 0 || (i & 1)) ?\n\t  mpz_perfect_square_p (u) :\n\t  mpn_perfect_square_p (mpz_limbs_read (u), mpz_size (u)))\n\t{\n\t  fprintf (stderr, \"mp%s_perfect_square_p failed on non square:\\n\",\n\t\t   (mpz_sgn (u) <= 0 || (i & 1)) ? \"z\" : \"n\");\n\t  dump (\"u\", u);\n\t  abort ();\n\t}\n\n      mpz_mul (u, s, s);\n      if (!((mpz_sgn (u) <= 0 || (i & 1)) ?\n\t    mpz_perfect_square_p (u) :\n\t    mpn_perfect_square_p (mpz_limbs_read (u), mpz_size (u))))\n\t{\n\t  fprintf (stderr, \"mp%s_perfect_square_p failed on square:\\n\",\n\t\t   (mpz_sgn (u) <= 0 || (i & 1)) ? \"z\" : \"n\");\n\t  dump (\"u\", u);\n\t  abort ();\n\t}\n\n    }\n  mpz_clear (u);\n  mpz_clear (s);\n  mpz_clear (r);\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-str.c": {
    "test_small": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static void\ntest_small (void)\n{\n  struct {\n    const char *input;\n    const char *decimal;\n  } data[] = {\n    { \"183407\", \"183407\" },\n    { \" 763959\", \"763959 \" },\n    { \"9 81999\", \"981999\" },\n    { \"10\\t7398 \", \"107398\" },\n    { \"-9585 44\", \"-00958544\" },\n    { \"-0\", \"0000\" },\n    { \" -000  \", \"0\" },\n    { \"0704436\", \"231710\" },\n    /* Check the case of large number of leading zeros. */\n    { \"0000000000000000000000000\", \"0000000000000000000000000\" },\n    { \"000000000000000000000000704436\", \"000000000000000000000000231710\" },\n    { \" 02503517\", \"689999\" },\n    { \"0 1312143\", \"365667\" },\n    { \"-03 274062\", \"-882738\" },\n    { \"012\\t242\", \"005282\" },\n    { \"0b11010111110010001111\", \"883855\" },\n    { \" 0b11001010010100001\", \"103585\" },\n    { \"-0b101010110011101111\", \"-175343\" },\n    { \"0b 1111111011011100110\", \"521958\" },\n    { \"0b1 1111110111001000011\", \"1044035\" },\n    { \" 0x53dfc\", \"343548\" },\n    { \"0xfA019\", \"1024025\" },\n    { \"0x 642d1\", \"410321\" },\n    { \"0x5 8067\", \"360551\" },\n    { \"-0xd6Be6\", \"-879590\" },\n    { \"\\t0B1110000100000000011\", \"460803\" },\n    { \"0B\\t1111110010010100101\", \"517285\" },\n    { \"0B1\\t010111101101110100\", \"359284\" },\n    { \"-0B101\\t1001101111111001\", \"-367609\" },\n    { \"0B10001001010111110000\", \"562672\" },\n    { \"0Xe4B7e\", \"936830\" },\n    { \"0X1E4bf\", \"124095\" },\n    { \"-0Xfdb90\", \"-1039248\" },\n    { \"0X7fc47\", \"523335\" },\n    { \"0X8167c\", \"530044\" },\n    /* Some invalid inputs */\n    { \"\", NULL },\n    { \"0x\", NULL },\n    { \"0b\", NULL },\n    { \"0z\", NULL },\n    { \"-\", NULL },\n    { \"-0x \", NULL },\n    { \"0|1\", NULL },\n    { \"4+4\", NULL },\n    { \"0ab\", NULL },\n    { \"10x0\", NULL },\n    { \"0xxab\", NULL },\n    { \"ab\", NULL },\n    { \"0%#\", NULL },\n    { \"$foo\", NULL },\n    { NULL, NULL }\n  };\n  unsigned i;\n  mpz_t a, b;\n  mpz_init (b);\n\n  for (i = 0; data[i].input; i++)\n    {\n      int res = mpz_init_set_str (a, data[i].input, 0);\n      if (data[i].decimal)\n\t{\n\t  if (res != 0)\n\t    {\n\t      fprintf (stderr, \"mpz_set_str returned -1, input: %s\\n\",\n\t\t       data[i].input);\n\t      abort ();\n\t    }\n\t  if (mpz_set_str (b, data[i].decimal, 10) != 0)\n\t    {\n\t      fprintf (stderr, \"mpz_set_str returned -1, decimal input: %s\\n\",\n\t\t       data[i].input);\n\t      abort ();\n\t    }\n\t  if (mpz_cmp (a, b) != 0)\n\t    {\n\t      fprintf (stderr, \"mpz_set_str failed for input: %s\\n\",\n\t\t       data[i].input);\n\n\t      dump (\"got\", a);\n\t      dump (\"ref\", b);\n\t      abort ();\n\t    }\n\t}\n      else if (res != -1)\n\t{\n\t  fprintf (stderr, \"mpz_set_str returned %d, invalid input: %s\\n\",\n\t\t   res, data[i].input);\n\t  abort ();\n\t}\n      mpz_clear (a);\n    }\n\n  mpz_clear (b);\n}",
      "lines": 101,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "testmain": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  char *ap;\n  char *bp;\n  char *rp;\n  size_t bn, rn, arn;\n\n  mpz_t a, b;\n\n  FILE *tmp;\n\n  test_small ();\n\n  mpz_init (a);\n  mpz_init (b);\n\n  tmp = tmpfile ();\n  if (!tmp)\n    fprintf (stderr,\n\t     \"Failed to create temporary file. Skipping mpz_out_str tests.\\n\");\n\n  for (i = 0; i < COUNT; i++)\n    {\n      int base;\n      for (base = 0; base <= 36; base += 1 + (base == 0))\n\t{\n\t  hex_random_str_op (MAXBITS, i&1 ? base: -base, &ap, &rp);\n\t  if (mpz_set_str (a, ap, 16) != 0)\n\t    {\n\t      fprintf (stderr, \"mpz_set_str failed on input %s\\n\", ap);\n\t      abort ();\n\t    }\n\n\t  rn = strlen (rp);\n\t  arn = rn - (rp[0] == '-');\n\n\t  bn = mpz_sizeinbase (a, base ? base : 10);\n\t  if (bn < arn || bn > (arn + 1))\n\t    {\n\t      fprintf (stderr, \"mpz_sizeinbase failed:\\n\");\n\t      dump (\"a\", a);\n\t      fprintf (stderr, \"r = %s\\n\", rp);\n\t      fprintf (stderr, \"  base %d, correct size %u, got %u\\n\",\n\t\t       base, (unsigned) arn, (unsigned)bn);\n\t      abort ();\n\t    }\n\t  bp = mpz_get_str (NULL, i&1 ? base: -base, a);\n\t  if (strcmp (bp, rp))\n\t    {\n\t      fprintf (stderr, \"mpz_get_str failed:\\n\");\n\t      dump (\"a\", a);\n\t      fprintf (stderr, \"b = %s\\n\", bp);\n\t      fprintf (stderr, \"  base = %d\\n\", base);\n\t      fprintf (stderr, \"r = %s\\n\", rp);\n\t      abort ();\n\t    }\n\n\t  /* Just a few tests with file i/o. */\n\t  if (tmp && i < 20)\n\t    {\n\t      size_t tn;\n\t      rewind (tmp);\n\t      tn = mpz_out_str (tmp, i&1 ? base: -base, a);\n\t      if (tn != rn)\n\t\t{\n\t\t  fprintf (stderr, \"mpz_out_str, bad return value:\\n\");\n\t\t  dump (\"a\", a);\n\t\t  fprintf (stderr, \"r = %s\\n\", rp);\n\t\t  fprintf (stderr, \"  base %d, correct size %u, got %u\\n\",\n\t\t\t   base, (unsigned) rn, (unsigned)tn);\n\t\t  abort ();\n\t\t}\n\t      rewind (tmp);\n\t      memset (bp, 0, rn);\n\t      tn = fread (bp, 1, rn, tmp);\n\t      if (tn != rn)\n\t\t{\n\t\t  fprintf (stderr,\n\t\t\t   \"fread failed, expected %lu bytes, got only %lu.\\n\",\n\t\t\t   (unsigned long) rn, (unsigned long) tn);\n\t\t  abort ();\n\t\t}\n\n\t      if (memcmp (bp, rp, rn) != 0)\n\t\t{\n\t\t  fprintf (stderr, \"mpz_out_str failed:\\n\");\n\t\t  dump (\"a\", a);\n\t\t  fprintf (stderr, \"b = %s\\n\", bp);\n\t\t  fprintf (stderr, \"  base = %d\\n\", base);\n\t\t  fprintf (stderr, \"r = %s\\n\", rp);\n\t\t  abort ();\n\t\t}\n\t    }\n\n\t  mpz_set_str (b, rp, base);\n\n\t  if (mpz_cmp (a, b))\n\t    {\n\t      fprintf (stderr, \"mpz_set_str failed:\\n\");\n\t      fprintf (stderr, \"r = %s\\n\", rp);\n\t      fprintf (stderr, \"  base = %d\\n\", base);\n\t      fprintf (stderr, \"r = %s\\n\", ap);\n\t      fprintf (stderr, \"  base = 16\\n\");\n\t      dump (\"b\", b);\n\t      dump (\"r\", a);\n\t      abort ();\n\t    }\n\n\t  /* Test mpn interface */\n\t  if (base && mpz_sgn (a))\n\t    {\n\t      size_t i;\n\t      const char *absr;\n\t      mp_limb_t t[MAXLIMBS];\n\t      mp_size_t tn = mpz_size (a);\n\n\t      assert (tn <= MAXLIMBS);\n\t      mpn_copyi (t, a->_mp_d, tn);\n\n\t      bn = mpn_get_str ((unsigned char *) bp, base, t, tn);\n\t      if (bn != arn)\n\t\t{\n\t\t  fprintf (stderr, \"mpn_get_str failed:\\n\");\n\t\t  fprintf (stderr, \"returned length: %lu (bad)\\n\", (unsigned long) bn);\n\t\t  fprintf (stderr, \"expected: %lu\\n\", (unsigned long) arn);\n\t\t  fprintf (stderr, \"  base = %d\\n\", base);\n\t\t  fprintf (stderr, \"r = %s\\n\", ap);\n\t\t  fprintf (stderr, \"  base = 16\\n\");\n\t\t  dump (\"b\", b);\n\t\t  dump (\"r\", a);\n\t\t  abort ();\n\t\t}\n\t      absr = rp + (rp[0] == '-');\n\n\t      for (i = 0; i < bn; i++)\n\t\t{\n\t\t  unsigned char digit = absr[i];\n\t\t  unsigned value;\n\t\t  if (digit >= '0' && digit <= '9')\n\t\t    value = digit - '0';\n\t\t  else if (digit >= 'a' && digit <= 'z')\n\t\t    value = digit - 'a' + 10;\n\t\t  else if (digit >= 'A' && digit <= 'Z')\n\t\t    value = digit - 'A' + 10;\n\t\t  else\n\t\t    {\n\t\t      fprintf (stderr, \"Internal error in test.\\n\");\n\t\t      abort();\n\t\t    }\n\t\t  if (bp[i] != value)\n\t\t    {\n\t\t      fprintf (stderr, \"mpn_get_str failed:\\n\");\n\t\t      fprintf (stderr, \"digit %lu: %d (bad)\\n\", (unsigned long) i, bp[i]);\n\t\t      fprintf (stderr, \"expected: %d\\n\", value);\n\t\t      fprintf (stderr, \"  base = %d\\n\", base);\n\t\t      fprintf (stderr, \"r = %s\\n\", ap);\n\t\t      fprintf (stderr, \"  base = 16\\n\");\n\t\t      dump (\"b\", b);\n\t\t      dump (\"r\", a);\n\t\t      abort ();\n\t\t    }\n\t\t}\n\t      tn = mpn_set_str (t, (unsigned char *) bp, bn, base);\n\t      if (tn != mpz_size (a) || mpn_cmp (t, a->_mp_d, tn))\n\t\t{\n\t\t  fprintf (stderr, \"mpn_set_str failed:\\n\");\n\t\t  fprintf (stderr, \"r = %s\\n\", rp);\n\t\t  fprintf (stderr, \"  base = %d\\n\", base);\n\t\t  fprintf (stderr, \"r = %s\\n\", ap);\n\t\t  fprintf (stderr, \"  base = 16\\n\");\n\t\t  dump (\"r\", a);\n\t\t  abort ();\n\t\t}\n\t    }\n\t  free (ap);\n\t  free (rp);\n\t  testfree (bp);\n\t}\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n}",
      "lines": 184,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/t-sub.c": {
    "testmain": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\ntestmain (int argc, char **argv)\n{\n  unsigned i;\n  mpz_t a, b, res, res_ui, ref;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (res);\n  mpz_init (res_ui);\n  mpz_init (ref);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mini_random_op3 (OP_SUB, MAXBITS, a, b, ref);\n      mpz_sub (res, a, b);\n      if (mpz_cmp (res, ref))\n\t{\n\t  fprintf (stderr, \"mpz_sub failed:\\n\");\n\t  dump (\"a\", a);\n\t  dump (\"b\", b);\n\t  dump (\"r\", res);\n\t  dump (\"ref\", ref);\n\t  abort ();\n\t}\n      if (mpz_fits_ulong_p (a)) {\n\tmpz_ui_sub (res_ui, mpz_get_ui (a), b);\n\tif (mpz_cmp (res_ui, ref))\n\t  {\n\t    fprintf (stderr, \"mpz_ui_sub failed:\\n\");\n\t    dump (\"a\", a);\n\t    dump (\"b\", b);\n\t    dump (\"r\", res_ui);\n\t    dump (\"ref\", ref);\n\t    abort ();\n\t  }\n      }\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (res);\n  mpz_clear (res_ui);\n  mpz_clear (ref);\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/testutils.c": {
    "block_init": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static void *\nblock_init (size_t *block, size_t size)\n{\n  char *p;\n  *block++ = size;\n\n  p = (char *) block;\n  memcpy (p + size, block_end, sizeof(block_end));\n\n  total_alloc += size;\n  return p;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nblock_init (size_t *block, size_t size)",
        "*"
      ]
    },
    "block_check": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static size_t *\nblock_check  (void *p)\n{\n  size_t *block = (size_t *) p - 1;\n  size_t size = block[0];\n\n  if (memcmp ((char *)p + size, block_end, sizeof(block_end)) != 0)\n    {\n      fprintf (stderr, \"red zone overwritten.\\n\");\n      abort ();\n    }\n  total_alloc -= size;\n  return block;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t",
        "*\nblock_check  (void *p)",
        "*"
      ]
    },
    "tu_alloc": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void *\ntu_alloc (size_t size)\n{\n  size_t *block = (size_t *) malloc (sizeof(size_t) + size + sizeof(block_end));\n  if (!block)\n    {\n      fprintf (stderr, \"Virtual memory exhausted.\\n\");\n      abort ();\n    }\n\n  return block_init (block, size);\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ntu_alloc (size_t size)",
        "*"
      ]
    },
    "tu_realloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static void *\ntu_realloc (void *p, size_t old_size, size_t new_size)\n{\n  size_t *block = block_check (p);\n  block = (size_t *) realloc (block, sizeof(size_t) + new_size + sizeof(block_end));\n  if (!block)\n    {\n      fprintf (stderr, \"Virtual memory exhausted.\\n\");\n      abort ();\n    }\n\n  return block_init (block, new_size);\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ntu_realloc (void *p, size_t old_size, size_t new_size)",
        "*"
      ]
    },
    "tu_free": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static void\ntu_free (void *p, size_t old_size)\n{\n  free (block_check (p));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "testfree": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\ntestfree (void *p)\n{\n  void (*freefunc) (void *, size_t);\n  mp_get_memory_functions (NULL, NULL, &freefunc);\n\n  freefunc (p, 0);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  hex_random_init ();\n\n  mp_set_memory_functions (tu_alloc, tu_realloc, tu_free);\n\n  /* Currently, t-comb seems to be the only program accepting any\n     arguments. It might make sense to parse common arguments here. */\n  testmain (argc, argv);\n\n  if (total_alloc != 0)\n    {\n      fprintf (stderr, \"Memory leaked: %lu bytes.\\n\",\n\t       (unsigned long) total_alloc);\n      abort ();\n    }\n  return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "testhalves": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\ntesthalves (int count, void (*tested_fun) (int))\n{\n  void (*freefunc) (void *, size_t);\n  void *(*reallocfunc) (void *, size_t, size_t);\n  void *(*allocfunc) (size_t);\n  size_t initial_alloc;\n\n  mp_get_memory_functions (&allocfunc, &reallocfunc, &freefunc);\n  initial_alloc = total_alloc;\n  (*tested_fun) (count / 2);\n  if (initial_alloc != total_alloc)\n    {\n      fprintf (stderr, \"First half, memory leaked: %lu bytes.\\n\",\n\t       (unsigned long) total_alloc - initial_alloc);\n      abort ();\n    }\n  mp_set_memory_functions (NULL, NULL, NULL);\n  (*tested_fun) (count / 2);\n  mp_set_memory_functions (allocfunc, reallocfunc, freefunc);\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "dump": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "void\ndump (const char *label, const mpz_t x)\n{\n  char *buf = mpz_get_str (NULL, 16, x);\n  fprintf (stderr, \"%s: %s\\n\", label, buf);\n  testfree (buf);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpz_set_str_or_abort": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nmpz_set_str_or_abort (mpz_ptr z, const char *str, int base)\n{\n  if (mpz_set_str (z, str, base) != 0)\n    {\n      fprintf (stderr, \"ERROR: mpz_set_str failed\\n\");\n      fprintf (stderr, \"   str  = \\\"%s\\\"\\n\", str);\n      fprintf (stderr, \"   base = %d\\n\", base);\n      abort();\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mini-gmp/tests/testutils.h": {},
  "gmp/gmp-6.1.2/mpf/abs.c": {
    "mpf_abs": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nmpf_abs (mpf_ptr r, mpf_srcptr u)\n{\n  mp_size_t size;\n\n  size = ABS (u->_mp_size);\n  if (r != u)\n    {\n      mp_size_t prec;\n      mp_ptr rp, up;\n\n      prec = r->_mp_prec + 1;\t/* lie not to lose precision in assignment */\n      rp = r->_mp_d;\n      up = u->_mp_d;\n\n      if (size > prec)\n\t{\n\t  up += size - prec;\n\t  size = prec;\n\t}\n\n      MPN_COPY (rp, up, size);\n      r->_mp_exp = u->_mp_exp;\n    }\n  r->_mp_size = size;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/add.c": {
    "mpf_add": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void\nmpf_add (mpf_ptr r, mpf_srcptr u, mpf_srcptr v)\n{\n  mp_srcptr up, vp;\n  mp_ptr rp, tp;\n  mp_size_t usize, vsize, rsize;\n  mp_size_t prec;\n  mp_exp_t uexp;\n  mp_size_t ediff;\n  mp_limb_t cy;\n  int negate;\n  TMP_DECL;\n\n  usize = u->_mp_size;\n  vsize = v->_mp_size;\n\n  /* Handle special cases that don't work in generic code below.  */\n  if (usize == 0)\n    {\n    set_r_v_maybe:\n      if (r != v)\n        mpf_set (r, v);\n      return;\n    }\n  if (vsize == 0)\n    {\n      v = u;\n      goto set_r_v_maybe;\n    }\n\n  /* If signs of U and V are different, perform subtraction.  */\n  if ((usize ^ vsize) < 0)\n    {\n      __mpf_struct v_negated;\n      v_negated._mp_size = -vsize;\n      v_negated._mp_exp = v->_mp_exp;\n      v_negated._mp_d = v->_mp_d;\n      mpf_sub (r, u, &v_negated);\n      return;\n    }\n\n  TMP_MARK;\n\n  /* Signs are now known to be the same.  */\n  negate = usize < 0;\n\n  /* Make U be the operand with the largest exponent.  */\n  if (u->_mp_exp < v->_mp_exp)\n    {\n      mpf_srcptr t;\n      t = u; u = v; v = t;\n      usize = u->_mp_size;\n      vsize = v->_mp_size;\n    }\n\n  usize = ABS (usize);\n  vsize = ABS (vsize);\n  up = u->_mp_d;\n  vp = v->_mp_d;\n  rp = r->_mp_d;\n  prec = r->_mp_prec;\n  uexp = u->_mp_exp;\n  ediff = u->_mp_exp - v->_mp_exp;\n\n  /* If U extends beyond PREC, ignore the part that does.  */\n  if (usize > prec)\n    {\n      up += usize - prec;\n      usize = prec;\n    }\n\n  /* If V extends beyond PREC, ignore the part that does.\n     Note that this may make vsize negative.  */\n  if (vsize + ediff > prec)\n    {\n      vp += vsize + ediff - prec;\n      vsize = prec - ediff;\n    }\n\n#if 0\n  /* Locate the least significant non-zero limb in (the needed parts\n     of) U and V, to simplify the code below.  */\n  while (up[0] == 0)\n    up++, usize--;\n  while (vp[0] == 0)\n    vp++, vsize--;\n#endif\n\n  /* Allocate temp space for the result.  Allocate\n     just vsize + ediff later???  */\n  tp = TMP_ALLOC_LIMBS (prec);\n\n  if (ediff >= prec)\n    {\n      /* V completely cancelled.  */\n      if (rp != up)\n\tMPN_COPY_INCR (rp, up, usize);\n      rsize = usize;\n    }\n  else\n    {\n      /* uuuu     |  uuuu     |  uuuu     |  uuuu     |  uuuu    */\n      /* vvvvvvv  |  vv       |    vvvvv  |    v      |       vv */\n\n      if (usize > ediff)\n\t{\n\t  /* U and V partially overlaps.  */\n\t  if (vsize + ediff <= usize)\n\t    {\n\t      /* uuuu     */\n\t      /*   v      */\n\t      mp_size_t size;\n\t      size = usize - ediff - vsize;\n\t      MPN_COPY (tp, up, size);\n\t      cy = mpn_add (tp + size, up + size, usize - size, vp, vsize);\n\t      rsize = usize;\n\t    }\n\t  else\n\t    {\n\t      /* uuuu     */\n\t      /*   vvvvv  */\n\t      mp_size_t size;\n\t      size = vsize + ediff - usize;\n\t      MPN_COPY (tp, vp, size);\n\t      cy = mpn_add (tp + size, up, usize, vp + size, usize - ediff);\n\t      rsize = vsize + ediff;\n\t    }\n\t}\n      else\n\t{\n\t  /* uuuu     */\n\t  /*      vv  */\n\t  mp_size_t size;\n\t  size = vsize + ediff - usize;\n\t  MPN_COPY (tp, vp, vsize);\n\t  MPN_ZERO (tp + vsize, ediff - usize);\n\t  MPN_COPY (tp + size, up, usize);\n\t  cy = 0;\n\t  rsize = size + usize;\n\t}\n\n      MPN_COPY (rp, tp, rsize);\n      rp[rsize] = cy;\n      rsize += cy;\n      uexp += cy;\n    }\n\n  r->_mp_size = negate ? -rsize : rsize;\n  r->_mp_exp = uexp;\n  TMP_FREE;\n}",
      "lines": 151,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/add_ui.c": {
    "mpf_add_ui": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\nmpf_add_ui (mpf_ptr sum, mpf_srcptr u, unsigned long int v)\n{\n  mp_srcptr up = u->_mp_d;\n  mp_ptr sump = sum->_mp_d;\n  mp_size_t usize, sumsize;\n  mp_size_t prec = sum->_mp_prec;\n  mp_exp_t uexp = u->_mp_exp;\n\n  usize = u->_mp_size;\n  if (usize <= 0)\n    {\n      if (usize == 0)\n\t{\n\t  mpf_set_ui (sum, v);\n\t  return;\n\t}\n      else\n\t{\n\t  __mpf_struct u_negated;\n\t  u_negated._mp_size = -usize;\n\t  u_negated._mp_exp = u->_mp_exp;\n\t  u_negated._mp_d = u->_mp_d;\n\t  mpf_sub_ui (sum, &u_negated, v);\n\t  sum->_mp_size = -(sum->_mp_size);\n\t  return;\n\t}\n    }\n\n  if (v == 0)\n    {\n    sum_is_u:\n      if (u != sum)\n\t{\n\t  sumsize = MIN (usize, prec + 1);\n\t  MPN_COPY (sum->_mp_d, up + usize - sumsize, sumsize);\n\t  sum->_mp_size = sumsize;\n\t  sum->_mp_exp = u->_mp_exp;\n\t}\n      return;\n    }\n\n  if (uexp > 0)\n    {\n      /* U >= 1.  */\n      if (uexp > prec)\n\t{\n\t  /* U >> V, V is not part of final result.  */\n\t  goto sum_is_u;\n\t}\n      else\n\t{\n\t  /* U's \"limb point\" is somewhere between the first limb\n\t     and the PREC:th limb.\n\t     Both U and V are part of the final result.  */\n\t  if (uexp > usize)\n\t    {\n\t      /*   uuuuuu0000. */\n\t      /* +          v. */\n\t      /* We begin with moving U to the top of SUM, to handle\n\t\t samevar(U,SUM).  */\n\t      MPN_COPY_DECR (sump + uexp - usize, up, usize);\n\t      sump[0] = v;\n\t      MPN_ZERO (sump + 1, uexp - usize - 1);\n#if 0 /* What is this??? */\n\t      if (sum == u)\n\t\tMPN_COPY (sum->_mp_d, sump, uexp);\n#endif\n\t      sum->_mp_size = uexp;\n\t      sum->_mp_exp = uexp;\n\t    }\n\t  else\n\t    {\n\t      /*   uuuuuu.uuuu */\n\t      /* +      v.     */\n\t      mp_limb_t cy_limb;\n\t      if (usize > prec)\n\t\t{\n\t\t  /* Ignore excess limbs in U.  */\n\t\t  up += usize - prec;\n\t\t  usize -= usize - prec; /* Eq. usize = prec */\n\t\t}\n\t      if (sump != up)\n\t\tMPN_COPY_INCR (sump, up, usize - uexp);\n\t      cy_limb = mpn_add_1 (sump + usize - uexp, up + usize - uexp,\n\t\t\t\t   uexp, (mp_limb_t) v);\n\t      sump[usize] = cy_limb;\n\t      sum->_mp_size = usize + cy_limb;\n\t      sum->_mp_exp = uexp + cy_limb;\n\t    }\n\t}\n    }\n  else\n    {\n      /* U < 1, so V > U for sure.  */\n      /* v.         */\n      /*  .0000uuuu */\n      if ((-uexp) >= prec)\n\t{\n\t  sump[0] = v;\n\t  sum->_mp_size = 1;\n\t  sum->_mp_exp = 1;\n\t}\n      else\n\t{\n\t  if (usize + (-uexp) + 1 > prec)\n\t    {\n\t      /* Ignore excess limbs in U.  */\n\t      up += usize + (-uexp) + 1 - prec;\n\t      usize -= usize + (-uexp) + 1 - prec;\n\t    }\n\t  if (sump != up)\n\t    MPN_COPY_INCR (sump, up, usize);\n\t  MPN_ZERO (sump + usize, -uexp);\n\t  sump[usize + (-uexp)] = v;\n\t  sum->_mp_size = usize + (-uexp) + 1;\n\t  sum->_mp_exp = 1;\n\t}\n    }\n}",
      "lines": 120,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/ceilfloor.c": {
    "mpf_ceil_or_floor": {
      "start_point": [
        42,
        17
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static void\nmpf_ceil_or_floor (mpf_ptr r, mpf_srcptr u, int dir)\n{\n  mp_ptr     rp, up, p;\n  mp_size_t  size, asize, prec;\n  mp_exp_t   exp;\n\n  size = SIZ(u);\n  if (size == 0)\n    {\n    zero:\n      SIZ(r) = 0;\n      EXP(r) = 0;\n      return;\n    }\n\n  rp = PTR(r);\n  exp = EXP(u);\n  if (exp <= 0)\n    {\n      /* u is only a fraction */\n      if ((size ^ dir) < 0)\n        goto zero;\n      rp[0] = 1;\n      EXP(r) = 1;\n      SIZ(r) = dir;\n      return;\n    }\n  EXP(r) = exp;\n\n  up = PTR(u);\n  asize = ABS (size);\n  up += asize;\n\n  /* skip fraction part of u */\n  asize = MIN (asize, exp);\n\n  /* don't lose precision in the copy */\n  prec = PREC (r) + 1;\n\n  /* skip excess over target precision */\n  asize = MIN (asize, prec);\n\n  up -= asize;\n\n  if ((size ^ dir) >= 0)\n    {\n      /* rounding direction matches sign, must increment if ignored part is\n         non-zero */\n      for (p = PTR(u); p != up; p++)\n        {\n          if (*p != 0)\n            {\n              if (mpn_add_1 (rp, up, asize, CNST_LIMB(1)))\n                {\n                  /* was all 0xFF..FFs, which have become zeros, giving just\n                     a carry */\n                  rp[0] = 1;\n                  asize = 1;\n                  EXP(r)++;\n                }\n              SIZ(r) = (size >= 0 ? asize : -asize);\n              return;\n            }\n        }\n    }\n\n  SIZ(r) = (size >= 0 ? asize : -asize);\n  if (rp != up)\n    MPN_COPY_INCR (rp, up, asize);\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpf_ceil": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void\nmpf_ceil (mpf_ptr r, mpf_srcptr u)\n{\n  mpf_ceil_or_floor (r, u, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpf_floor": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "void\nmpf_floor (mpf_ptr r, mpf_srcptr u)\n{\n  mpf_ceil_or_floor (r, u, -1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/clear.c": {
    "mpf_clear": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\nmpf_clear (mpf_ptr x)\n{\n  __GMP_FREE_FUNC_LIMBS (PTR(x), PREC(x) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/clears.c": {
    "mpf_clears": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nmpf_clears (mpf_ptr x, ...)\n{\n  va_list  ap;\n\n  va_start (ap, x);\n\n  while (x != NULL)\n    {\n      __GMP_FREE_FUNC_LIMBS (PTR(x), PREC(x) + 1);\n      x = va_arg (ap, mpf_ptr);\n    }\n\n  va_end (ap);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/cmp.c": {
    "mpf_cmp": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int\nmpf_cmp (mpf_srcptr u, mpf_srcptr v) __GMP_NOTHROW\n{\n  mp_srcptr up, vp;\n  mp_size_t usize, vsize;\n  mp_exp_t uexp, vexp;\n  int cmp;\n  int usign;\n\n  usize = SIZ(u);\n  vsize = SIZ(v);\n  usign = usize >= 0 ? 1 : -1;\n\n  /* 1. Are the signs different?  */\n  if ((usize ^ vsize) >= 0)\n    {\n      /* U and V are both non-negative or both negative.  */\n      if (usize == 0)\n\t/* vsize >= 0 */\n\treturn -(vsize != 0);\n      if (vsize == 0)\n\t/* usize >= 0 */\n\treturn usize != 0;\n      /* Fall out.  */\n    }\n  else\n    {\n      /* Either U or V is negative, but not both.  */\n      return usign;\n    }\n\n  /* U and V have the same sign and are both non-zero.  */\n\n  uexp = EXP(u);\n  vexp = EXP(v);\n\n  /* 2. Are the exponents different?  */\n  if (uexp > vexp)\n    return usign;\n  if (uexp < vexp)\n    return -usign;\n\n  usize = ABS (usize);\n  vsize = ABS (vsize);\n\n  up = PTR (u);\n  vp = PTR (v);\n\n#define STRICT_MPF_NORMALIZATION 0\n#if ! STRICT_MPF_NORMALIZATION\n  /* Ignore zeroes at the low end of U and V.  */\n  do {\n    mp_limb_t tl;\n    tl = up[0];\n    MPN_STRIP_LOW_ZEROS_NOT_ZERO (up, usize, tl);\n    tl = vp[0];\n    MPN_STRIP_LOW_ZEROS_NOT_ZERO (vp, vsize, tl);\n  } while (0);\n#endif\n\n  if (usize > vsize)\n    {\n      cmp = mpn_cmp (up + usize - vsize, vp, vsize);\n      /* if (cmp == 0) */\n      /*\treturn usign; */\n      ++cmp;\n    }\n  else if (vsize > usize)\n    {\n      cmp = mpn_cmp (up, vp + vsize - usize, usize);\n      /* if (cmp == 0) */\n      /*\treturn -usign; */\n    }\n  else\n    {\n      cmp = mpn_cmp (up, vp, usize);\n      if (cmp == 0)\n\treturn 0;\n    }\n  return cmp > 0 ? usign : -usign;\n}",
      "lines": 81,
      "depth": 12,
      "decorators": [
        "int",
        "mpf_cmp (mpf_srcptr u, mpf_srcptr v)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/cmp_d.c": {
    "mpf_cmp_d": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nmpf_cmp_d (mpf_srcptr f, double d)\n{\n  mp_limb_t  darray[LIMBS_PER_DOUBLE];\n  mpf_t      df;\n\n  /* d=NaN has no sensible return value, so raise an exception.\n     d=Inf or -Inf is always bigger than z.  */\n  DOUBLE_NAN_INF_ACTION (d,\n                         __gmp_invalid_operation (),\n                         return (d < 0.0 ? 1 : -1));\n\n  if (d == 0.0)\n    return SIZ(f);\n\n  PTR(df) = darray;\n  SIZ(df) = (d >= 0.0 ? LIMBS_PER_DOUBLE : -LIMBS_PER_DOUBLE);\n  EXP(df) = __gmp_extract_double (darray, ABS(d));\n\n  return mpf_cmp (f, df);\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/cmp_si.c": {
    "mpf_cmp_si": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "int\nmpf_cmp_si (mpf_srcptr u, long int vval) __GMP_NOTHROW\n{\n  mp_srcptr up;\n  mp_size_t usize;\n  mp_exp_t uexp;\n  mp_limb_t ulimb;\n  int usign;\n  unsigned long abs_vval;\n\n  usize = SIZ (u);\n\n  /* 1. Are the signs different?  */\n  if ((usize < 0) == (vval < 0)) /* don't use xor, type size may differ */\n    {\n      /* U and V are both non-negative or both negative.  */\n      if (usize == 0)\n\t/* vval >= 0 */\n\treturn -(vval != 0);\n      if (vval == 0)\n\t/* usize >= 0 */\n\treturn usize != 0;\n      /* Fall out.  */\n    }\n  else\n    {\n      /* Either U or V is negative, but not both.  */\n      return usize >= 0 ? 1 : -1;\n    }\n\n  /* U and V have the same sign and are both non-zero.  */\n\n  /* 2. Are the exponents different (V's exponent == 1)?  */\n  uexp = EXP (u);\n  usign = usize >= 0 ? 1 : -1;\n  usize = ABS (usize);\n  abs_vval = ABS_CAST (unsigned long, vval);\n\n#if GMP_NAIL_BITS != 0\n  if (uexp != 1 + (abs_vval > GMP_NUMB_MAX))\n    return (uexp < 1 + (abs_vval > GMP_NUMB_MAX)) ? -usign : usign;\n#else\n  if (uexp != 1)\n    return (uexp < 1) ? -usign : usign;\n#endif\n\n  up = PTR (u);\n\n  ASSERT (usize > 0);\n  ulimb = up[--usize];\n#if GMP_NAIL_BITS != 0\n  if (uexp == 2)\n    {\n      if ((ulimb >> GMP_NAIL_BITS) != 0)\n\treturn usign;\n      ulimb = (ulimb << GMP_NUMB_BITS);\n      if (usize != 0) ulimb |= up[--usize];\n    }\n#endif\n\n  /* 3. Compare the most significant mantissa limb with V.  */\n  if (ulimb != abs_vval)\n    return (ulimb < abs_vval) ? -usign : usign;\n\n  /* Ignore zeroes at the low end of U.  */\n  for (; *up == 0; ++up)\n    --usize;\n\n  /* 4. Now, if the number of limbs are different, we have a difference\n     since we have made sure the trailing limbs are not zero.  */\n  if (usize > 0)\n    return usign;\n\n  /* Wow, we got zero even if we tried hard to avoid it.  */\n  return 0;\n}",
      "lines": 76,
      "depth": 12,
      "decorators": [
        "int",
        "mpf_cmp_si (mpf_srcptr u, long int vval)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/cmp_ui.c": {
    "mpf_cmp_ui": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nmpf_cmp_ui (mpf_srcptr u, unsigned long int vval) __GMP_NOTHROW\n{\n  mp_srcptr up;\n  mp_size_t usize;\n  mp_exp_t uexp;\n  mp_limb_t ulimb;\n\n  usize = SIZ (u);\n\n  /* 1. Is U negative?  */\n  if (usize < 0)\n    return -1;\n  /* We rely on usize being non-negative in the code that follows.  */\n\n  if (vval == 0)\n    return usize != 0;\n\n  /* 2. Are the exponents different (V's exponent == 1)?  */\n  uexp = EXP (u);\n\n#if GMP_NAIL_BITS != 0\n  if (uexp != 1 + (vval > GMP_NUMB_MAX))\n    return (uexp < 1 + (vval > GMP_NUMB_MAX)) ? -1 : 1;\n#else\n  if (uexp != 1)\n    return (uexp < 1) ? -1 : 1;\n#endif\n\n  up = PTR (u);\n\n  ASSERT (usize > 0);\n  ulimb = up[--usize];\n#if GMP_NAIL_BITS != 0\n  if (uexp == 2)\n    {\n      if ((ulimb >> GMP_NAIL_BITS) != 0)\n\treturn 1;\n      ulimb = (ulimb << GMP_NUMB_BITS);\n      if (usize != 0) ulimb |= up[--usize];\n    }\n#endif\n\n  /* 3. Compare the most significant mantissa limb with V.  */\n  if (ulimb != vval)\n    return (ulimb < vval) ? -1 : 1;\n\n  /* Ignore zeroes at the low end of U.  */\n  for (; *up == 0; ++up)\n    --usize;\n\n  /* 4. Now, if the number of limbs are different, we have a difference\n     since we have made sure the trailing limbs are not zero.  */\n  return (usize > 0);\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "int",
        "mpf_cmp_ui (mpf_srcptr u, unsigned long int vval)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/cmp_z.c": {
    "mpf_cmp_z": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmpf_cmp_z (mpf_srcptr u, mpz_srcptr v) __GMP_NOTHROW\n{\n  mpf_t vf;\n  mp_size_t size;\n\n  SIZ (vf) = size = SIZ (v);\n  EXP (vf) = size = ABS (size);\n  /* PREC (vf) = size; */ \n  PTR (vf) = PTR (v);\n\n  return mpf_cmp (u, vf);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int",
        "mpf_cmp_z (mpf_srcptr u, mpz_srcptr v)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/div.c": {
    "mpf_div": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void\nmpf_div (mpf_ptr r, mpf_srcptr u, mpf_srcptr v)\n{\n  mp_srcptr up, vp;\n  mp_ptr rp, tp, new_vp;\n  mp_size_t usize, vsize, rsize, prospective_rsize, tsize, zeros;\n  mp_size_t sign_quotient, prec, high_zero, chop;\n  mp_exp_t rexp;\n  int copy_u;\n  TMP_DECL;\n\n  usize = SIZ(u);\n  vsize = SIZ(v);\n\n  if (UNLIKELY (vsize == 0))\n    DIVIDE_BY_ZERO;\n\n  if (usize == 0)\n    {\n      SIZ(r) = 0;\n      EXP(r) = 0;\n      return;\n    }\n\n  sign_quotient = usize ^ vsize;\n  usize = ABS (usize);\n  vsize = ABS (vsize);\n  prec = PREC(r);\n\n  TMP_MARK;\n  rexp = EXP(u) - EXP(v) + 1;\n\n  rp = PTR(r);\n  up = PTR(u);\n  vp = PTR(v);\n\n  prospective_rsize = usize - vsize + 1; /* quot from using given u,v sizes */\n  rsize = prec + 1;\t\t\t /* desired quot */\n\n  zeros = rsize - prospective_rsize;\t /* padding u to give rsize */\n  copy_u = (zeros > 0 || rp == up);\t /* copy u if overlap or padding */\n\n  chop = MAX (-zeros, 0);\t\t /* negative zeros means shorten u */\n  up += chop;\n  usize -= chop;\n  zeros += chop;\t\t\t /* now zeros >= 0 */\n\n  tsize = usize + zeros;\t\t /* size for possible copy of u */\n\n  /* copy and possibly extend u if necessary */\n  if (copy_u)\n    {\n      tp = TMP_ALLOC_LIMBS (tsize + 1);\t/* +1 for mpn_div_q's scratch needs */\n      MPN_ZERO (tp, zeros);\n      MPN_COPY (tp+zeros, up, usize);\n      up = tp;\n      usize = tsize;\n    }\n  else\n    {\n      tp = TMP_ALLOC_LIMBS (usize + 1);\n    }\n\n  /* ensure divisor doesn't overlap quotient */\n  if (rp == vp)\n    {\n      new_vp = TMP_ALLOC_LIMBS (vsize);\n      MPN_COPY (new_vp, vp, vsize);\n      vp = new_vp;\n    }\n\n  ASSERT (usize-vsize+1 == rsize);\n  mpn_div_q (rp, up, usize, vp, vsize, tp);\n\n  /* strip possible zero high limb */\n  high_zero = (rp[rsize-1] == 0);\n  rsize -= high_zero;\n  rexp -= high_zero;\n\n  SIZ(r) = sign_quotient >= 0 ? rsize : -rsize;\n  EXP(r) = rexp;\n  TMP_FREE;\n}",
      "lines": 83,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/div_2exp.c": {
    "mpf_div_2exp": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\nmpf_div_2exp (mpf_ptr r, mpf_srcptr u, mp_bitcnt_t exp)\n{\n  mp_srcptr up;\n  mp_ptr rp = r->_mp_d;\n  mp_size_t usize;\n  mp_size_t abs_usize;\n  mp_size_t prec = r->_mp_prec;\n  mp_exp_t uexp = u->_mp_exp;\n\n  usize = u->_mp_size;\n\n  if (UNLIKELY (usize == 0))\n    {\n      r->_mp_size = 0;\n      r->_mp_exp = 0;\n      return;\n    }\n\n  abs_usize = ABS (usize);\n  up = u->_mp_d;\n\n  if (exp % GMP_NUMB_BITS == 0)\n    {\n      prec++;\t\t\t/* retain more precision here as we don't need\n\t\t\t\t   to account for carry-out here */\n      if (abs_usize > prec)\n\t{\n\t  up += abs_usize - prec;\n\t  abs_usize = prec;\n\t}\n      if (rp != up)\n\tMPN_COPY_INCR (rp, up, abs_usize);\n      r->_mp_exp = uexp - exp / GMP_NUMB_BITS;\n    }\n  else\n    {\n      mp_limb_t cy_limb;\n      mp_size_t adj;\n      if (abs_usize > prec)\n\t{\n\t  up += abs_usize - prec;\n\t  abs_usize = prec;\n\t  /* Use mpn_rshift since mpn_lshift operates downwards, and we\n\t     therefore would clobber part of U before using that part, in case\n\t     R is the same variable as U.  */\n\t  cy_limb = mpn_rshift (rp + 1, up, abs_usize, exp % GMP_NUMB_BITS);\n\t  rp[0] = cy_limb;\n\t  adj = rp[abs_usize] != 0;\n\t}\n      else\n\t{\n\t  cy_limb = mpn_lshift (rp, up, abs_usize,\n\t\t\t\tGMP_NUMB_BITS - exp % GMP_NUMB_BITS);\n\t  rp[abs_usize] = cy_limb;\n\t  adj = cy_limb != 0;\n\t}\n\n      abs_usize += adj;\n      r->_mp_exp = uexp - exp / GMP_NUMB_BITS - 1 + adj;\n    }\n  r->_mp_size = usize >= 0 ? abs_usize : -abs_usize;\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/div_ui.c": {
    "mpf_div_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\nmpf_div_ui (mpf_ptr r, mpf_srcptr u, unsigned long int v)\n{\n  mp_srcptr up;\n  mp_ptr rp, tp, rtp;\n  mp_size_t usize;\n  mp_size_t rsize, tsize;\n  mp_size_t sign_quotient;\n  mp_size_t prec;\n  mp_limb_t q_limb;\n  mp_exp_t rexp;\n  TMP_DECL;\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (v > GMP_NUMB_MAX)\n    {\n      mpf_t vf;\n      mp_limb_t vl[2];\n      SIZ(vf) = 2;\n      EXP(vf) = 2;\n      PTR(vf) = vl;\n      vl[0] = v & GMP_NUMB_MASK;\n      vl[1] = v >> GMP_NUMB_BITS;\n      mpf_div (r, u, vf);\n      return;\n    }\n#endif\n\n  if (UNLIKELY (v == 0))\n    DIVIDE_BY_ZERO;\n\n  usize = u->_mp_size;\n\n  if (usize == 0)\n    {\n      r->_mp_size = 0;\n      r->_mp_exp = 0;\n      return;\n    }\n\n  sign_quotient = usize;\n  usize = ABS (usize);\n  prec = r->_mp_prec;\n\n  TMP_MARK;\n\n  rp = r->_mp_d;\n  up = u->_mp_d;\n\n  tsize = 1 + prec;\n  tp = TMP_ALLOC_LIMBS (tsize + 1);\n\n  if (usize > tsize)\n    {\n      up += usize - tsize;\n      usize = tsize;\n      rtp = tp;\n    }\n  else\n    {\n      MPN_ZERO (tp, tsize - usize);\n      rtp = tp + (tsize - usize);\n    }\n\n  /* Move the dividend to the remainder.  */\n  MPN_COPY (rtp, up, usize);\n\n  mpn_divmod_1 (rp, tp, tsize, (mp_limb_t) v);\n  q_limb = rp[tsize - 1];\n\n  rsize = tsize - (q_limb == 0);\n  rexp = u->_mp_exp - (q_limb == 0);\n  r->_mp_size = sign_quotient >= 0 ? rsize : -rsize;\n  r->_mp_exp = rexp;\n  TMP_FREE;\n}",
      "lines": 76,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/dump.c": {
    "mpf_dump": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\nmpf_dump (mpf_srcptr u)\n{\n  mp_exp_t exp;\n  char *str;\n\n  str = mpf_get_str (0, &exp, 10, 0, u);\n  if (str[0] == '-')\n    printf (\"-0.%se%ld\\n\", str + 1, exp);\n  else\n    printf (\"0.%se%ld\\n\", str, exp);\n  (*__gmp_free_func) (str, strlen (str) + 1);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/eq.c": {
    "mpf_eq": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "int\nmpf_eq (mpf_srcptr u, mpf_srcptr v, mp_bitcnt_t n_bits)\n{\n  mp_srcptr up, vp, p;\n  mp_size_t usize, vsize, minsize, maxsize, n_limbs, i, size;\n  mp_exp_t uexp, vexp;\n  mp_limb_t diff;\n  int cnt;\n\n  uexp = u->_mp_exp;\n  vexp = v->_mp_exp;\n\n  usize = u->_mp_size;\n  vsize = v->_mp_size;\n\n  /* 1. Are the signs different?  */\n  if ((usize ^ vsize) >= 0)\n    {\n      /* U and V are both non-negative or both negative.  */\n      if (usize == 0)\n\treturn vsize == 0;\n      if (vsize == 0)\n\treturn 0;\n\n      /* Fall out.  */\n    }\n  else\n    {\n      /* Either U or V is negative, but not both.  */\n      return 0;\n    }\n\n  /* U and V have the same sign and are both non-zero.  */\n\n  /* 2. Are the exponents different?  */\n  if (uexp != vexp)\n    return 0;\n\n  usize = ABS (usize);\n  vsize = ABS (vsize);\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  up += usize;\t\t\t/* point just above most significant limb */\n  vp += vsize;\t\t\t/* point just above most significant limb */\n\n  count_leading_zeros (cnt, up[-1]);\n  if ((vp[-1] >> (GMP_LIMB_BITS - 1 - cnt)) != 1)\n    return 0;\t\t\t/* msb positions different */\n\n  n_bits += cnt - GMP_NAIL_BITS;\n  n_limbs = (n_bits + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;\n\n  usize = MIN (usize, n_limbs);\n  vsize = MIN (vsize, n_limbs);\n\n#if 0\n  /* Ignore zeros at the low end of U and V.  */\n  while (up[0] == 0)\n    up++, usize--;\n  while (vp[0] == 0)\n    vp++, vsize--;\n#endif\n\n  minsize = MIN (usize, vsize);\n  maxsize = usize + vsize - minsize;\n\n  up -= minsize;\t\t/* point at most significant common limb */\n  vp -= minsize;\t\t/* point at most significant common limb */\n\n  /* Compare the most significant part which has explicit limbs for U and V. */\n  for (i = minsize - 1; i > 0; i--)\n    {\n      if (up[i] != vp[i])\n\treturn 0;\n    }\n\n  n_bits -= (maxsize - 1) * GMP_NUMB_BITS;\n\n  size = maxsize - minsize;\n  if (size != 0)\n    {\n      if (up[0] != vp[0])\n\treturn 0;\n\n      /* Now either U or V has its limbs consumed, i.e, continues with an\n\t infinite number of implicit zero limbs.  Check that the other operand\n\t has just zeros in the corresponding, relevant part.  */\n\n      if (usize > vsize)\n\tp = up - size;\n      else\n\tp = vp - size;\n\n      for (i = size - 1; i > 0; i--)\n\t{\n\t  if (p[i] != 0)\n\t    return 0;\n\t}\n\n      diff = p[0];\n    }\n  else\n    {\n      /* Both U or V has its limbs consumed.  */\n\n      diff = up[0] ^ vp[0];\n    }\n\n  if (n_bits < GMP_NUMB_BITS)\n    diff >>= GMP_NUMB_BITS - n_bits;\n\n  return diff == 0;\n}",
      "lines": 115,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/fits_s.h": {
    "FUNCTION": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nFUNCTION (mpf_srcptr f) __GMP_NOTHROW\n{\n  mp_size_t  fs, fn;\n  mp_srcptr  fp;\n  mp_exp_t   exp;\n  mp_limb_t  fl;\n\n  exp = EXP(f);\n  if (exp < 1)\n    return 1;  /* -1 < f < 1 truncates to zero, so fits */\n\n  fs = SIZ (f);\n  fp = PTR(f);\n  fn = ABS (fs);\n\n  if (exp == 1)\n    {\n      fl = fp[fn-1];\n    }\n#if GMP_NAIL_BITS != 0\n  else if (exp == 2 && MAXIMUM > GMP_NUMB_MAX)\n    {\n      fl = fp[fn-1];\n      if ((fl >> GMP_NAIL_BITS) != 0)\n\treturn 0;\n      fl = (fl << GMP_NUMB_BITS);\n      if (fn >= 2)\n        fl |= fp[fn-2];\n    }\n#endif\n  else\n    return 0;\n\n  return fl <= (fs >= 0 ? (mp_limb_t) MAXIMUM : - (mp_limb_t) MINIMUM);\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "int",
        "FUNCTION (mpf_srcptr f)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/fits_sint.c": {},
  "gmp/gmp-6.1.2/mpf/fits_slong.c": {},
  "gmp/gmp-6.1.2/mpf/fits_sshort.c": {},
  "gmp/gmp-6.1.2/mpf/fits_u.h": {
    "FUNCTION": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nFUNCTION (mpf_srcptr f) __GMP_NOTHROW\n{\n  mp_size_t  fn;\n  mp_srcptr  fp;\n  mp_exp_t   exp;\n  mp_limb_t  fl;\n\n  exp = EXP(f);\n  if (exp < 1)\n    return 1;  /* -1 < f < 1 truncates to zero, so fits */\n\n  fn = SIZ(f);\n  if (fn < 0) /* zero catched by exp == 0 */\n    return 0; /* negatives don't fit */\n\n  fp = PTR(f);\n\n  if (exp == 1)\n    {\n      fl = fp[fn-1];\n    }\n#if GMP_NAIL_BITS != 0\n  else if (exp == 2 && MAXIMUM > GMP_NUMB_MAX)\n    {\n      fl = fp[fn-1];\n      if ((fl >> GMP_NAIL_BITS) != 0)\n\treturn 0;\n      fl = (fl << GMP_NUMB_BITS);\n      if (fn >= 2)\n        fl |= fp[fn-2];\n    }\n#endif\n  else\n    return 0;\n\n  return fl <= MAXIMUM;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "int",
        "FUNCTION (mpf_srcptr f)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/fits_uint.c": {},
  "gmp/gmp-6.1.2/mpf/fits_ulong.c": {},
  "gmp/gmp-6.1.2/mpf/fits_ushort.c": {},
  "gmp/gmp-6.1.2/mpf/get_d.c": {
    "mpf_get_d": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "double\nmpf_get_d (mpf_srcptr src)\n{\n  mp_size_t  size, abs_size;\n  long       exp;\n\n  size = SIZ (src);\n  if (UNLIKELY (size == 0))\n    return 0.0;\n\n  abs_size = ABS (size);\n  exp = (EXP (src) - abs_size) * GMP_NUMB_BITS;\n  return mpn_get_d (PTR (src), abs_size, size, exp);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "double"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/get_dfl_prec.c": {
    "mpf_get_default_prec": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "mp_bitcnt_t\nmpf_get_default_prec (void) __GMP_NOTHROW\n{\n  return __GMPF_PREC_TO_BITS (__gmp_default_fp_limb_precision);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_bitcnt_t",
        "mpf_get_default_prec (void)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/get_d_2exp.c": {
    "mpf_get_d_2exp": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "double\nmpf_get_d_2exp (signed long int *exp2, mpf_srcptr src)\n{\n  mp_size_t size, abs_size;\n  mp_srcptr ptr;\n  int cnt;\n  long exp;\n\n  size = SIZ(src);\n  if (UNLIKELY (size == 0))\n    {\n      *exp2 = 0;\n      return 0.0;\n    }\n\n  ptr = PTR(src);\n  abs_size = ABS (size);\n  count_leading_zeros (cnt, ptr[abs_size - 1]);\n  cnt -= GMP_NAIL_BITS;\n\n  exp = EXP(src) * GMP_NUMB_BITS - cnt;\n  *exp2 = exp;\n\n  return mpn_get_d (ptr, abs_size, (mp_size_t) 0,\n                    (long) - (abs_size * GMP_NUMB_BITS - cnt));\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "double"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/get_prc.c": {
    "mpf_get_prec": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "mp_bitcnt_t\nmpf_get_prec (mpf_srcptr x) __GMP_NOTHROW\n{\n  return __GMPF_PREC_TO_BITS (x->_mp_prec);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "mp_bitcnt_t",
        "mpf_get_prec (mpf_srcptr x)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/get_si.c": {
    "mpf_get_si": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "long\nmpf_get_si (mpf_srcptr f) __GMP_NOTHROW\n{\n  mp_exp_t exp;\n  mp_size_t size, abs_size;\n  mp_srcptr fp;\n  mp_limb_t fl;\n\n  exp = EXP (f);\n  size = SIZ (f);\n  fp = PTR (f);\n\n  /* fraction alone truncates to zero\n     this also covers zero, since we have exp==0 for zero */\n  if (exp <= 0)\n    return 0L;\n\n  /* there are some limbs above the radix point */\n\n  fl = 0;\n  abs_size = ABS (size);\n  if (abs_size >= exp)\n    fl = fp[abs_size-exp];\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS\n  if (exp > 1 && abs_size+1 >= exp)\n    fl |= fp[abs_size - exp + 1] << GMP_NUMB_BITS;\n#endif\n\n  if (size > 0)\n    return fl & LONG_MAX;\n  else\n    /* this form necessary to correctly handle -0x80..00 */\n    return -1 - (long) ((fl - 1) & LONG_MAX);\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "long",
        "long",
        "mpf_get_si (mpf_srcptr f)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/get_str.c": {
    "mpn_pow_1_highpart": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static mp_size_t\nmpn_pow_1_highpart (mp_ptr rp, mp_size_t *ignp,\n\t\t    mp_limb_t base, unsigned long exp,\n\t\t    mp_size_t prec, mp_ptr tp)\n{\n  mp_size_t ign;\t\t/* counts number of ignored low limbs in r */\n  mp_size_t off;\t\t/* keeps track of offset where value starts */\n  mp_ptr passed_rp = rp;\n  mp_size_t rn;\n  int cnt;\n  int i;\n\n  if (exp == 0)\n    {\n      rp[0] = 1;\n      *ignp = 0;\n      return 1;\n    }\n\n  rp[0] = base;\n  rn = 1;\n  off = 0;\n  ign = 0;\n  count_leading_zeros (cnt, exp);\n  for (i = GMP_LIMB_BITS - cnt - 2; i >= 0; i--)\n    {\n      mpn_sqr (tp, rp + off, rn);\n      rn = 2 * rn;\n      rn -= tp[rn - 1] == 0;\n      ign <<= 1;\n\n      off = 0;\n      if (rn > prec)\n\t{\n\t  ign += rn - prec;\n\t  off = rn - prec;\n\t  rn = prec;\n\t}\n      MP_PTR_SWAP (rp, tp);\n\n      if (((exp >> i) & 1) != 0)\n\t{\n\t  mp_limb_t cy;\n\t  cy = mpn_mul_1 (rp, rp + off, rn, base);\n\t  rp[rn] = cy;\n\t  rn += cy != 0;\n\t  off = 0;\n\t}\n    }\n\n  if (rn > prec)\n    {\n      ASSERT (rn == prec + 1);\n\n      ign += rn - prec;\n      rp += rn - prec;\n      rn = prec;\n    }\n\n  /* With somewhat less than 50% probability, we can skip this copy.  */\n  if (passed_rp != rp + off)\n    MPN_COPY_INCR (passed_rp, rp + off, rn);\n  *ignp = ign;\n  return rn;\n}",
      "lines": 65,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpf_get_str": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "char *\nmpf_get_str (char *dbuf, mp_exp_t *exp, int base, size_t n_digits, mpf_srcptr u)\n{\n  mp_exp_t ue;\n  mp_size_t n_limbs_needed;\n  size_t max_digits;\n  mp_ptr up, pp, tp;\n  mp_size_t un, pn, tn;\n  unsigned char *tstr;\n  mp_exp_t exp_in_base;\n  size_t n_digits_computed;\n  mp_size_t i;\n  const char *num_to_text;\n  size_t alloc_size = 0;\n  char *dp;\n  TMP_DECL;\n\n  up = PTR(u);\n  un = ABSIZ(u);\n  ue = EXP(u);\n\n  if (base >= 0)\n    {\n      num_to_text = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n      if (base <= 1)\n\tbase = 10;\n      else if (base > 36)\n\t{\n\t  num_to_text = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\t  if (base > 62)\n\t    return NULL;\n\t}\n    }\n  else\n    {\n      base = -base;\n      if (base <= 1)\n\tbase = 10;\n      else if (base > 36)\n\treturn NULL;\n      num_to_text = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    }\n\n  MPF_SIGNIFICANT_DIGITS (max_digits, base, PREC(u));\n  if (n_digits == 0 || n_digits > max_digits)\n    n_digits = max_digits;\n\n  if (dbuf == 0)\n    {\n      /* We didn't get a string from the user.  Allocate one (and return\n\t a pointer to it) with space for `-' and terminating null.  */\n      alloc_size = n_digits + 2;\n      dbuf = (char *) (*__gmp_allocate_func) (n_digits + 2);\n    }\n\n  if (un == 0)\n    {\n      *exp = 0;\n      *dbuf = 0;\n      n_digits = 0;\n      goto done;\n    }\n\n  TMP_MARK;\n\n  /* Allocate temporary digit space.  We can't put digits directly in the user\n     area, since we generate more digits than requested.  (We allocate\n     2 * GMP_LIMB_BITS extra bytes because of the digit block nature of the\n     conversion.)  */\n  tstr = (unsigned char *) TMP_ALLOC (n_digits + 2 * GMP_LIMB_BITS + 3);\n\n  LIMBS_PER_DIGIT_IN_BASE (n_limbs_needed, n_digits, base);\n\n  if (un > n_limbs_needed)\n    {\n      up += un - n_limbs_needed;\n      un = n_limbs_needed;\n    }\n\n  TMP_ALLOC_LIMBS_2 (pp, 2 * n_limbs_needed + 4,\n\t\t     tp, 2 * n_limbs_needed + 4);\n\n  if (ue <= n_limbs_needed)\n    {\n      /* We need to multiply number by base^n to get an n_digits integer part.  */\n      mp_size_t n_more_limbs_needed, ign, off;\n      unsigned long e;\n\n      n_more_limbs_needed = n_limbs_needed - ue;\n      DIGITS_IN_BASE_PER_LIMB (e, n_more_limbs_needed, base);\n\n      pn = mpn_pow_1_highpart (pp, &ign, (mp_limb_t) base, e, n_limbs_needed + 1, tp);\n      if (un > pn)\n\tmpn_mul (tp, up, un, pp, pn);\t/* FIXME: mpn_mul_highpart */\n      else\n\tmpn_mul (tp, pp, pn, up, un);\t/* FIXME: mpn_mul_highpart */\n      tn = un + pn;\n      tn -= tp[tn - 1] == 0;\n      off = un - ue - ign;\n      if (off < 0)\n\t{\n\t  MPN_COPY_DECR (tp - off, tp, tn);\n\t  MPN_ZERO (tp, -off);\n\t  tn -= off;\n\t  off = 0;\n\t}\n      n_digits_computed = mpn_get_str (tstr, base, tp + off, tn - off);\n\n      exp_in_base = n_digits_computed - e;\n    }\n  else\n    {\n      /* We need to divide number by base^n to get an n_digits integer part.  */\n      mp_size_t n_less_limbs_needed, ign, off, xn;\n      unsigned long e;\n      mp_ptr dummyp, xp;\n\n      n_less_limbs_needed = ue - n_limbs_needed;\n      DIGITS_IN_BASE_PER_LIMB (e, n_less_limbs_needed, base);\n\n      pn = mpn_pow_1_highpart (pp, &ign, (mp_limb_t) base, e, n_limbs_needed + 1, tp);\n\n      xn = n_limbs_needed + (n_less_limbs_needed-ign);\n      xp = TMP_ALLOC_LIMBS (xn);\n      off = xn - un;\n      MPN_ZERO (xp, off);\n      MPN_COPY (xp + off, up, un);\n\n      dummyp = TMP_ALLOC_LIMBS (pn);\n      mpn_tdiv_qr (tp, dummyp, (mp_size_t) 0, xp, xn, pp, pn);\n      tn = xn - pn + 1;\n      tn -= tp[tn - 1] == 0;\n      n_digits_computed = mpn_get_str (tstr, base, tp, tn);\n\n      exp_in_base = n_digits_computed + e;\n    }\n\n  /* We should normally have computed too many digits.  Round the result\n     at the point indicated by n_digits.  */\n  if (n_digits_computed > n_digits)\n    {\n      size_t i;\n      /* Round the result.  */\n      if (tstr[n_digits] * 2 >= base)\n\t{\n\t  n_digits_computed = n_digits;\n\t  for (i = n_digits - 1;; i--)\n\t    {\n\t      unsigned int x;\n\t      x = ++(tstr[i]);\n\t      if (x != base)\n\t\tbreak;\n\t      n_digits_computed--;\n\t      if (i == 0)\n\t\t{\n\t\t  /* We had something like `bbbbbbb...bd', where 2*d >= base\n\t\t     and `b' denotes digit with significance base - 1.\n\t\t     This rounds up to `1', increasing the exponent.  */\n\t\t  tstr[0] = 1;\n\t\t  n_digits_computed = 1;\n\t\t  exp_in_base++;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n\n  /* We might have fewer digits than requested as a result of rounding above,\n     (i.e. 0.999999 => 1.0) or because we have a number that simply doesn't\n     need many digits in this base (e.g., 0.125 in base 10).  */\n  if (n_digits > n_digits_computed)\n    n_digits = n_digits_computed;\n\n  /* Remove trailing 0.  There can be many zeros.  */\n  while (n_digits != 0 && tstr[n_digits - 1] == 0)\n    n_digits--;\n\n  dp = dbuf + (SIZ(u) < 0);\n\n  /* Translate to ASCII and copy to result string.  */\n  for (i = 0; i < n_digits; i++)\n    dp[i] = num_to_text[tstr[i]];\n  dp[n_digits] = 0;\n\n  *exp = exp_in_base;\n\n  if (SIZ(u) < 0)\n    {\n      dbuf[0] = '-';\n      n_digits++;\n    }\n\n  TMP_FREE;\n\n done:\n  /* If the string was alloced then resize it down to the actual space\n     required.  */\n  if (alloc_size != 0)\n    {\n      __GMP_REALLOCATE_FUNC_MAYBE_TYPE (dbuf, alloc_size, n_digits + 1, char);\n    }\n\n  return dbuf;\n}",
      "lines": 204,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmpf_get_str (char *dbuf, mp_exp_t *exp, int base, size_t n_digits, mpf_srcptr u)",
        "*"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/get_ui.c": {
    "mpf_get_ui": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "unsigned long\nmpf_get_ui (mpf_srcptr f) __GMP_NOTHROW\n{\n  mp_size_t size;\n  mp_exp_t exp;\n  mp_srcptr fp;\n  mp_limb_t fl;\n\n  exp = EXP (f);\n  size = SIZ (f);\n  fp = PTR (f);\n\n  fl = 0;\n  if (exp > 0)\n    {\n      /* there are some limbs above the radix point */\n\n      size = ABS (size);\n      if (size >= exp)\n        fl = fp[size-exp];\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS\n      if (exp > 1 && size+1 >= exp)\n        fl += (fp[size-exp+1] << GMP_NUMB_BITS);\n#endif\n    }\n\n  return (unsigned long) fl;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long",
        "mpf_get_ui (mpf_srcptr f)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/init.c": {
    "mpf_init": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void\nmpf_init (mpf_ptr r)\n{\n  mp_size_t prec = __gmp_default_fp_limb_precision;\n  r->_mp_size = 0;\n  r->_mp_exp = 0;\n  r->_mp_prec = prec;\n  r->_mp_d = __GMP_ALLOCATE_FUNC_LIMBS (prec + 1);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/init2.c": {
    "mpf_init2": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\nmpf_init2 (mpf_ptr r, mp_bitcnt_t prec_in_bits)\n{\n  mp_size_t prec;\n\n  prec = __GMPF_BITS_TO_PREC (prec_in_bits);\n  r->_mp_size = 0;\n  r->_mp_exp = 0;\n  r->_mp_prec = prec;\n  r->_mp_d = __GMP_ALLOCATE_FUNC_LIMBS (prec + 1);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/inits.c": {
    "mpf_inits": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nmpf_inits (mpf_ptr x, ...)\n{\n  va_list  ap;\n\n  va_start (ap, x);\n\n  while (x != NULL)\n    {\n      mpf_init (x);\n      x = va_arg (ap, mpf_ptr);\n    }\n\n  va_end (ap);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/inp_str.c": {
    "mpf_inp_str": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "size_t\nmpf_inp_str (mpf_ptr rop, FILE *stream, int base)\n{\n  char *str;\n  size_t alloc_size, str_size;\n  int c;\n  int res;\n  size_t nread;\n\n  if (stream == 0)\n    stream = stdin;\n\n  alloc_size = 100;\n  str = (char *) (*__gmp_allocate_func) (alloc_size);\n  str_size = 0;\n  nread = 0;\n\n  /* Skip whitespace.  */\n  do\n    {\n      c = getc (stream);\n      nread++;\n    }\n  while (isspace (c));\n\n  for (;;)\n    {\n      if (str_size >= alloc_size)\n\t{\n\t  size_t old_alloc_size = alloc_size;\n\t  alloc_size = alloc_size * 3 / 2;\n\t  str = (char *) (*__gmp_reallocate_func) (str, old_alloc_size, alloc_size);\n\t}\n      if (c == EOF || isspace (c))\n\tbreak;\n      str[str_size++] = c;\n      c = getc (stream);\n    }\n  ungetc (c, stream);\n  nread--;\n\n  if (str_size >= alloc_size)\n    {\n      size_t old_alloc_size = alloc_size;\n      alloc_size = alloc_size * 3 / 2;\n      str = (char *) (*__gmp_reallocate_func) (str, old_alloc_size, alloc_size);\n    }\n  str[str_size] = 0;\n\n  res = mpf_set_str (rop, str, base);\n  (*__gmp_free_func) (str, alloc_size);\n\n  if (res == -1)\n    return 0;\t\t\t/* error */\n\n  return str_size + nread;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/int_p.c": {
    "mpf_integer_p": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmpf_integer_p (mpf_srcptr f) __GMP_NOTHROW\n{\n  mp_srcptr fp;\n  mp_exp_t exp;\n  mp_size_t size;\n\n  size = SIZ (f);\n  exp = EXP (f);\n  if (exp <= 0)\n    return (size == 0);  /* zero is an integer,\n\t\t\t    others have only fraction limbs */\n  size = ABS (size);\n\n  /* Ignore zeroes at the low end of F.  */\n  for (fp = PTR (f); *fp == 0; ++fp)\n    --size;\n\n  /* no fraction limbs */\n  return size <= exp;\n}",
      "lines": 21,
      "depth": 7,
      "decorators": [
        "int",
        "mpf_integer_p (mpf_srcptr f)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/iset.c": {
    "mpf_init_set": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\nmpf_init_set (mpf_ptr r, mpf_srcptr s)\n{\n  mp_ptr rp, sp;\n  mp_size_t ssize, size;\n  mp_size_t prec;\n\n  prec = __gmp_default_fp_limb_precision;\n  r->_mp_d = __GMP_ALLOCATE_FUNC_LIMBS (prec + 1);\n  r->_mp_prec = prec;\n\n  prec++;\t\t/* lie not to lose precision in assignment */\n  ssize = s->_mp_size;\n  size = ABS (ssize);\n\n  rp = r->_mp_d;\n  sp = s->_mp_d;\n\n  if (size > prec)\n    {\n      sp += size - prec;\n      size = prec;\n    }\n\n  r->_mp_exp = s->_mp_exp;\n  r->_mp_size = ssize >= 0 ? size : -size;\n\n  MPN_COPY (rp, sp, size);\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/iset_d.c": {
    "mpf_init_set_d": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void\nmpf_init_set_d (mpf_ptr r, double val)\n{\n  mp_size_t prec = __gmp_default_fp_limb_precision;\n  r->_mp_prec = prec;\n  r->_mp_d = __GMP_ALLOCATE_FUNC_LIMBS (prec + 1);\n\n  mpf_set_d (r, val);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/iset_si.c": {
    "mpf_init_set_si": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\nmpf_init_set_si (mpf_ptr r, long int val)\n{\n  mp_size_t prec = __gmp_default_fp_limb_precision;\n  mp_size_t size;\n  mp_limb_t vl;\n\n  r->_mp_prec = prec;\n  r->_mp_d = __GMP_ALLOCATE_FUNC_LIMBS (prec + 1);\n\n  vl = (mp_limb_t) ABS_CAST (unsigned long int, val);\n\n  r->_mp_d[0] = vl & GMP_NUMB_MASK;\n  size = vl != 0;\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS\n  vl >>= GMP_NUMB_BITS;\n  r->_mp_d[1] = vl;\n  size += (vl != 0);\n#endif\n\n  r->_mp_exp = size;\n  r->_mp_size = val >= 0 ? size : -size;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/iset_str.c": {
    "mpf_init_set_str": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmpf_init_set_str (mpf_ptr r, const char *s, int base)\n{\n  mp_size_t prec = __gmp_default_fp_limb_precision;\n  r->_mp_size = 0;\n  r->_mp_exp = 0;\n  r->_mp_prec = prec;\n  r->_mp_d = __GMP_ALLOCATE_FUNC_LIMBS (prec + 1);\n\n  return mpf_set_str (r, s, base);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/iset_ui.c": {
    "mpf_init_set_ui": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\nmpf_init_set_ui (mpf_ptr r, unsigned long int val)\n{\n  mp_size_t prec = __gmp_default_fp_limb_precision;\n  mp_size_t size;\n\n  r->_mp_prec = prec;\n  r->_mp_d = __GMP_ALLOCATE_FUNC_LIMBS (prec + 1);\n  r->_mp_d[0] = val & GMP_NUMB_MASK;\n  size = (val != 0);\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS\n  val >>= GMP_NUMB_BITS;\n  r->_mp_d[1] = val;\n  size += (val != 0);\n#endif\n\n  r->_mp_size = size;\n  r->_mp_exp = size;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/mul.c": {
    "mpf_mul": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nmpf_mul (mpf_ptr r, mpf_srcptr u, mpf_srcptr v)\n{\n  mp_srcptr up, vp;\n  mp_size_t usize, vsize;\n  mp_size_t sign_product;\n  mp_size_t prec = r->_mp_prec;\n\n  usize = u->_mp_size;\n  vsize = v->_mp_size;\n  sign_product = usize ^ vsize;\n\n  usize = ABS (usize);\n  vsize = ABS (vsize);\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n  if (usize > prec)\n    {\n      up += usize - prec;\n      usize = prec;\n    }\n  if (vsize > prec)\n    {\n      vp += vsize - prec;\n      vsize = prec;\n    }\n\n  if (usize == 0 || vsize == 0)\n    {\n      r->_mp_size = 0;\n      r->_mp_exp = 0;\t\t/* ??? */\n    }\n  else\n    {\n      mp_size_t rsize;\n      mp_limb_t cy_limb;\n      mp_ptr rp, tp;\n      mp_size_t adj;\n      TMP_DECL;\n\n      TMP_MARK;\n      rsize = usize + vsize;\n      tp = TMP_ALLOC_LIMBS (rsize);\n      cy_limb = (usize >= vsize\n\t\t ? mpn_mul (tp, up, usize, vp, vsize)\n\t\t : mpn_mul (tp, vp, vsize, up, usize));\n\n      adj = cy_limb == 0;\n      rsize -= adj;\n      prec++;\n      if (rsize > prec)\n\t{\n\t  tp += rsize - prec;\n\t  rsize = prec;\n\t}\n      rp = r->_mp_d;\n      MPN_COPY (rp, tp, rsize);\n      r->_mp_exp = u->_mp_exp + v->_mp_exp - adj;\n      r->_mp_size = sign_product >= 0 ? rsize : -rsize;\n\n      TMP_FREE;\n    }\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/mul_2exp.c": {
    "mpf_mul_2exp": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\nmpf_mul_2exp (mpf_ptr r, mpf_srcptr u, mp_bitcnt_t exp)\n{\n  mp_srcptr up;\n  mp_ptr rp = r->_mp_d;\n  mp_size_t usize;\n  mp_size_t abs_usize;\n  mp_size_t prec = r->_mp_prec;\n  mp_exp_t uexp = u->_mp_exp;\n\n  usize = u->_mp_size;\n\n  if (UNLIKELY (usize == 0))\n    {\n      r->_mp_size = 0;\n      r->_mp_exp = 0;\n      return;\n    }\n\n  abs_usize = ABS (usize);\n  up = u->_mp_d;\n\n  if (exp % GMP_NUMB_BITS == 0)\n    {\n      prec++;\t\t\t/* retain more precision here as we don't need\n\t\t\t\t   to account for carry-out here */\n      if (abs_usize > prec)\n\t{\n\t  up += abs_usize - prec;\n\t  abs_usize = prec;\n\t}\n      if (rp != up)\n\tMPN_COPY_INCR (rp, up, abs_usize);\n      r->_mp_exp = uexp + exp / GMP_NUMB_BITS;\n    }\n  else\n    {\n      mp_limb_t cy_limb;\n      mp_size_t adj;\n      if (abs_usize > prec)\n\t{\n\t  up += abs_usize - prec;\n\t  abs_usize = prec;\n\t  /* Use mpn_rshift since mpn_lshift operates downwards, and we\n\t     therefore would clobber part of U before using that part, in case\n\t     R is the same variable as U.  */\n\t  cy_limb = mpn_rshift (rp + 1, up, abs_usize,\n\t\t\t\tGMP_NUMB_BITS - exp % GMP_NUMB_BITS);\n\t  rp[0] = cy_limb;\n\t  adj = rp[abs_usize] != 0;\n\t}\n      else\n\t{\n\t  cy_limb = mpn_lshift (rp, up, abs_usize, exp % GMP_NUMB_BITS);\n\t  rp[abs_usize] = cy_limb;\n\t  adj = cy_limb != 0;\n\t}\n\n      abs_usize += adj;\n      r->_mp_exp = uexp + exp / GMP_NUMB_BITS + adj;\n    }\n  r->_mp_size = usize >= 0 ? abs_usize : -abs_usize;\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/mul_ui.c": {
    "mpf_mul_ui": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\nmpf_mul_ui (mpf_ptr r, mpf_srcptr u, unsigned long int v)\n{\n  mp_srcptr up;\n  mp_size_t usize;\n  mp_size_t size;\n  mp_size_t prec, excess;\n  mp_limb_t cy_limb, vl, cbit, cin;\n  mp_ptr rp;\n\n  usize = u->_mp_size;\n  if (UNLIKELY (v == 0) || UNLIKELY (usize == 0))\n    {\n      r->_mp_size = 0;\n      r->_mp_exp = 0;\n      return;\n    }\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (v > GMP_NUMB_MAX)\n    {\n      mpf_t     vf;\n      mp_limb_t vp[2];\n      vp[0] = v & GMP_NUMB_MASK;\n      vp[1] = v >> GMP_NUMB_BITS;\n      PTR(vf) = vp;\n      SIZ(vf) = 2;\n      ASSERT_CODE (PREC(vf) = 2);\n      EXP(vf) = 2;\n      mpf_mul (r, u, vf);\n      return;\n    }\n#endif\n\n  size = ABS (usize);\n  prec = r->_mp_prec;\n  up = u->_mp_d;\n  vl = v;\n  excess = size - prec;\n  cin = 0;\n\n  if (excess > 0)\n    {\n      /* up is bigger than desired rp, shorten it to prec limbs and\n         determine a carry-in */\n\n      mp_limb_t  vl_shifted = vl << GMP_NAIL_BITS;\n      mp_limb_t  hi, lo, next_lo, sum;\n      mp_size_t  i;\n\n      /* high limb of top product */\n      i = excess - 1;\n      umul_ppmm (cin, lo, up[i], vl_shifted);\n\n      /* and carry bit out of products below that, if any */\n      for (;;)\n        {\n          i--;\n          if (i < 0)\n            break;\n\n          umul_ppmm (hi, next_lo, up[i], vl_shifted);\n          lo >>= GMP_NAIL_BITS;\n          ADDC_LIMB (cbit, sum, hi, lo);\n          cin += cbit;\n          lo = next_lo;\n\n          /* Continue only if the sum is GMP_NUMB_MAX.  GMP_NUMB_MAX is the\n             only value a carry from below can propagate across.  If we've\n             just seen the carry out (ie. cbit!=0) then sum!=GMP_NUMB_MAX,\n             so this test stops us for that case too.  */\n          if (LIKELY (sum != GMP_NUMB_MAX))\n            break;\n        }\n\n      up += excess;\n      size = prec;\n    }\n\n  rp = r->_mp_d;\n#if HAVE_NATIVE_mpn_mul_1c\n  cy_limb = mpn_mul_1c (rp, up, size, vl, cin);\n#else\n  cy_limb = mpn_mul_1 (rp, up, size, vl);\n  __GMPN_ADD_1 (cbit, rp, rp, size, cin);\n  cy_limb += cbit;\n#endif\n  rp[size] = cy_limb;\n  cy_limb = cy_limb != 0;\n  r->_mp_exp = u->_mp_exp + cy_limb;\n  size += cy_limb;\n  r->_mp_size = usize >= 0 ? size : -size;\n}",
      "lines": 93,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/neg.c": {
    "mpf_neg": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\nmpf_neg (mpf_ptr r, mpf_srcptr u)\n{\n  mp_size_t size;\n\n  size = -u->_mp_size;\n  if (r != u)\n    {\n      mp_size_t prec;\n      mp_size_t asize;\n      mp_ptr rp, up;\n\n      prec = r->_mp_prec + 1;\t/* lie not to lose precision in assignment */\n      asize = ABS (size);\n      rp = r->_mp_d;\n      up = u->_mp_d;\n\n      if (asize > prec)\n\t{\n\t  up += asize - prec;\n\t  asize = prec;\n\t}\n\n      MPN_COPY (rp, up, asize);\n      r->_mp_exp = u->_mp_exp;\n      size = size >= 0 ? asize : -asize;\n    }\n  r->_mp_size = size;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/out_str.c": {
    "mpf_out_str": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "size_t\nmpf_out_str (FILE *stream, int base, size_t n_digits, mpf_srcptr op)\n{\n  char *str;\n  mp_exp_t exp;\n  size_t written;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  if (base == 0)\n    base = 10;\n  if (n_digits == 0)\n    MPF_SIGNIFICANT_DIGITS (n_digits, base, op->_mp_prec);\n\n  if (stream == 0)\n    stream = stdout;\n\n  /* Consider these changes:\n     * Don't allocate memory here for huge n_digits; pass NULL to mpf_get_str.\n     * Make mpf_get_str allocate extra space when passed NULL, to avoid\n       allocating two huge string buffers.\n     * Implement more/other allocation reductions tricks.  */\n\n  str = (char *) TMP_ALLOC (n_digits + 2); /* extra for minus sign and \\0 */\n\n  mpf_get_str (str, &exp, base, n_digits, op);\n  n_digits = strlen (str);\n\n  written = 0;\n\n  /* Write sign */\n  if (str[0] == '-')\n    {\n      str++;\n      fputc ('-', stream);\n      written = 1;\n      n_digits--;\n    }\n\n  {\n    const char  *point = GMP_DECIMAL_POINT;\n    size_t      pointlen = strlen (point);\n    putc ('0', stream);\n    fwrite (point, 1, pointlen, stream);\n    written += pointlen + 1;\n  }\n\n  /* Write mantissa */\n  {\n    size_t fwret;\n    fwret = fwrite (str, 1, n_digits, stream);\n    written += fwret;\n  }\n\n  /* Write exponent */\n  {\n    int fpret;\n    fpret = fprintf (stream, (base <= 10 ? \"e%ld\" : \"@%ld\"), exp);\n    written += fpret;\n  }\n\n  TMP_FREE;\n  return ferror (stream) ? 0 : written;\n}",
      "lines": 65,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/pow_ui.c": {
    "mpf_pow_ui": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "void\nmpf_pow_ui (mpf_ptr r, mpf_srcptr b, unsigned long int e)\n{\n  mpf_t t;\n  int cnt;\n\n  if (e <= 1)\n    {\n      if (e == 0)\n\tmpf_set_ui (r, 1);\n      else\n\tmpf_set (r, b);\n      return;\n    }\n\n  count_leading_zeros (cnt, (mp_limb_t) e);\n  cnt = GMP_LIMB_BITS - 1 - cnt;\n\n  /* Increase computation precision as a function of the exponent.  Adding\n     log2(popcount(e) + log2(e)) bits should be sufficient, but we add log2(e),\n     i.e. much more.  With mpf's rounding of precision to whole limbs, this\n     will be excessive only when limbs are artificially small.  */\n  mpf_init2 (t, mpf_get_prec (r) + cnt);\n\n  mpf_set (t, b);\t\t/* consume most significant bit */\n  while (--cnt > 0)\n    {\n      mpf_mul (t, t, t);\n      if ((e >> cnt) & 1)\n\tmpf_mul (t, t, b);\n    }\n\n  /* Do the last iteration specially in order to save a copy operation.  */\n  if (e & 1)\n    {\n      mpf_mul (t, t, t);\n      mpf_mul (r, t, b);\n    }\n  else\n    {\n      mpf_mul (r, t, t);\n    }\n\n  mpf_clear (t);\n}",
      "lines": 45,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/random2.c": {
    "mpf_random2": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\nmpf_random2 (mpf_ptr x, mp_size_t xs, mp_exp_t exp)\n{\n  mp_size_t xn;\n  mp_size_t prec;\n  mp_limb_t elimb;\n\n  xn = ABS (xs);\n  prec = PREC(x);\n\n  if (xn == 0)\n    {\n      EXP(x) = 0;\n      SIZ(x) = 0;\n      return;\n    }\n\n  if (xn > prec + 1)\n    xn = prec + 1;\n\n  /* General random mantissa.  */\n  mpn_random2 (PTR(x), xn);\n\n  /* Generate random exponent.  */\n  _gmp_rand (&elimb, RANDS, GMP_NUMB_BITS);\n  exp = ABS (exp);\n  exp = elimb % (2 * exp + 1) - exp;\n\n  EXP(x) = exp;\n  SIZ(x) = xs < 0 ? -xn : xn;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/reldiff.c": {
    "mpf_reldiff": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\nmpf_reldiff (mpf_t rdiff, mpf_srcptr x, mpf_srcptr y)\n{\n  if (UNLIKELY (SIZ(x) == 0))\n    {\n      mpf_set_ui (rdiff, (unsigned long int) (mpf_sgn (y) != 0));\n    }\n  else\n    {\n      mp_size_t dprec;\n      mpf_t d;\n      TMP_DECL;\n\n      TMP_MARK;\n      dprec = PREC(rdiff) + ABSIZ(x);\n      ASSERT (PREC(rdiff)+1 == dprec - ABSIZ(x) + 1);\n\n      PREC(d) = dprec;\n      PTR(d) = TMP_ALLOC_LIMBS (dprec + 1);\n\n      mpf_sub (d, x, y);\n      SIZ(d) = ABSIZ(d);\n      mpf_div (rdiff, d, x);\n\n      TMP_FREE;\n    }\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/set.c": {
    "mpf_set": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\nmpf_set (mpf_ptr r, mpf_srcptr u)\n{\n  mp_ptr rp, up;\n  mp_size_t size, asize;\n  mp_size_t prec;\n\n  prec = r->_mp_prec + 1;\t\t/* lie not to lose precision in assignment */\n  size = u->_mp_size;\n  asize = ABS (size);\n  rp = r->_mp_d;\n  up = u->_mp_d;\n\n  if (asize > prec)\n    {\n      up += asize - prec;\n      asize = prec;\n    }\n\n  r->_mp_exp = u->_mp_exp;\n  r->_mp_size = size >= 0 ? asize : -asize;\n  MPN_COPY_INCR (rp, up, asize);\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/set_d.c": {
    "mpf_set_d": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nmpf_set_d (mpf_ptr r, double d)\n{\n  int negative;\n\n  DOUBLE_NAN_INF_ACTION (d,\n                         __gmp_invalid_operation (),\n                         __gmp_invalid_operation ());\n\n  if (UNLIKELY (d == 0))\n    {\n      SIZ(r) = 0;\n      EXP(r) = 0;\n      return;\n    }\n  negative = d < 0;\n  d = ABS (d);\n\n  SIZ(r) = negative ? -LIMBS_PER_DOUBLE : LIMBS_PER_DOUBLE;\n  EXP(r) = __gmp_extract_double (PTR(r), d);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/set_dfl_prec.c": {
    "mpf_set_default_prec": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\nmpf_set_default_prec (mp_bitcnt_t prec_in_bits) __GMP_NOTHROW\n{\n  __gmp_default_fp_limb_precision = __GMPF_BITS_TO_PREC (prec_in_bits);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "mpf_set_default_prec (mp_bitcnt_t prec_in_bits)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/set_prc.c": {
    "mpf_set_prec": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\nmpf_set_prec (mpf_ptr x, mp_bitcnt_t new_prec_in_bits)\n{\n  mp_size_t  old_prec, new_prec, new_prec_plus1;\n  mp_size_t  size, sign;\n  mp_ptr     xp;\n\n  new_prec = __GMPF_BITS_TO_PREC (new_prec_in_bits);\n  old_prec = PREC(x);\n\n  /* do nothing if already the right precision */\n  if (new_prec == old_prec)\n    return;\n\n  PREC(x) = new_prec;\n  new_prec_plus1 = new_prec + 1;\n\n  /* retain most significant limbs */\n  sign = SIZ(x);\n  size = ABS (sign);\n  xp = PTR(x);\n  if (size > new_prec_plus1)\n    {\n      SIZ(x) = (sign >= 0 ? new_prec_plus1 : -new_prec_plus1);\n      MPN_COPY_INCR (xp, xp + size - new_prec_plus1, new_prec_plus1);\n    }\n\n  PTR(x) = __GMP_REALLOCATE_FUNC_LIMBS (xp, old_prec+1, new_prec_plus1);\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/set_prc_raw.c": {
    "mpf_set_prec_raw": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\nmpf_set_prec_raw (mpf_ptr x, mp_bitcnt_t prec_in_bits) __GMP_NOTHROW\n{\n  x->_mp_prec = __GMPF_BITS_TO_PREC (prec_in_bits);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "mpf_set_prec_raw (mpf_ptr x, mp_bitcnt_t prec_in_bits)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/set_q.c": {
    "mpf_set_q": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void\nmpf_set_q (mpf_t r, mpq_srcptr q)\n{\n  mp_srcptr np, dp;\n  mp_size_t prec, nsize, dsize, qsize, prospective_qsize, tsize, zeros;\n  mp_size_t sign_quotient, high_zero;\n  mp_ptr qp, tp, remp;\n  mp_exp_t exp;\n  TMP_DECL;\n\n  ASSERT (SIZ(&q->_mp_den) > 0);  /* canonical q */\n\n  nsize = SIZ (&q->_mp_num);\n  dsize = SIZ (&q->_mp_den);\n\n  if (UNLIKELY (nsize == 0))\n    {\n      SIZ (r) = 0;\n      EXP (r) = 0;\n      return;\n    }\n\n  TMP_MARK;\n\n  prec = PREC (r);\n  qp = PTR (r);\n\n  sign_quotient = nsize;\n  nsize = ABS (nsize);\n  np = PTR (&q->_mp_num);\n  dp = PTR (&q->_mp_den);\n\n  prospective_qsize = nsize - dsize + 1;  /* q from using given n,d sizes */\n  exp = prospective_qsize;                /* ie. number of integer limbs */\n  qsize = prec + 1;                       /* desired q */\n\n  zeros = qsize - prospective_qsize;   /* n zeros to get desired qsize */\n  tsize = nsize + zeros;               /* possible copy of n */\n\n  if (WANT_TMP_DEBUG)\n    {\n      /* separate alloc blocks, for malloc debugging */\n      remp = TMP_ALLOC_LIMBS (dsize);\n      tp = NULL;\n      if (zeros > 0)\n        tp = TMP_ALLOC_LIMBS (tsize);\n    }\n  else\n    {\n      /* one alloc with a conditionalized size, for efficiency */\n      mp_size_t size = dsize + (zeros > 0 ? tsize : 0);\n      remp = TMP_ALLOC_LIMBS (size);\n      tp = remp + dsize;\n    }\n\n  if (zeros > 0)\n    {\n      /* pad n with zeros into temporary space */\n      MPN_ZERO (tp, zeros);\n      MPN_COPY (tp+zeros, np, nsize);\n      np = tp;\n      nsize = tsize;\n    }\n  else\n    {\n      /* shorten n to get desired qsize */\n      nsize += zeros;\n      np -= zeros;\n    }\n\n  ASSERT (nsize-dsize+1 == qsize);\n  mpn_tdiv_qr (qp, remp, (mp_size_t) 0, np, nsize, dp, dsize);\n\n  /* strip possible zero high limb */\n  high_zero = (qp[qsize-1] == 0);\n  qsize -= high_zero;\n  exp -= high_zero;\n\n  EXP (r) = exp;\n  SIZ (r) = sign_quotient >= 0 ? qsize : -qsize;\n\n  TMP_FREE;\n}",
      "lines": 83,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/set_si.c": {
    "mpf_set_si": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\nmpf_set_si (mpf_ptr dest, long val)\n{\n  mp_size_t size;\n  mp_limb_t vl;\n\n  vl = (mp_limb_t) ABS_CAST (unsigned long int, val);\n\n  dest->_mp_d[0] = vl & GMP_NUMB_MASK;\n  size = vl != 0;\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS\n  vl >>= GMP_NUMB_BITS;\n  dest->_mp_d[1] = vl;\n  size += (vl != 0);\n#endif\n\n  dest->_mp_exp = size;\n  dest->_mp_size = val >= 0 ? size : -size;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/set_str.c": {
    "mpn_pow_1_highpart": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static mp_size_t\nmpn_pow_1_highpart (mp_ptr rp, mp_size_t *ignp,\n\t\t    mp_limb_t base, mp_exp_t exp,\n\t\t    mp_size_t prec, mp_ptr tp)\n{\n  mp_size_t ign;\t\t/* counts number of ignored low limbs in r */\n  mp_size_t off;\t\t/* keeps track of offset where value starts */\n  mp_ptr passed_rp = rp;\n  mp_size_t rn;\n  int cnt;\n  int i;\n\n  rp[0] = base;\n  rn = 1;\n  off = 0;\n  ign = 0;\n  count_leading_zeros (cnt, exp);\n  for (i = GMP_LIMB_BITS - cnt - 2; i >= 0; i--)\n    {\n      mpn_sqr (tp, rp + off, rn);\n      rn = 2 * rn;\n      rn -= tp[rn - 1] == 0;\n      ign <<= 1;\n\n      off = 0;\n      if (rn > prec)\n\t{\n\t  ign += rn - prec;\n\t  off = rn - prec;\n\t  rn = prec;\n\t}\n      MP_PTR_SWAP (rp, tp);\n\n      if (((exp >> i) & 1) != 0)\n\t{\n\t  mp_limb_t cy;\n\t  cy = mpn_mul_1 (rp, rp + off, rn, base);\n\t  rp[rn] = cy;\n\t  rn += cy != 0;\n\t  off = 0;\n\t}\n    }\n\n  if (rn > prec)\n    {\n      ign += rn - prec;\n      rp += rn - prec;\n      rn = prec;\n    }\n\n  MPN_COPY_INCR (passed_rp, rp + off, rn);\n  *ignp = ign;\n  return rn;\n}",
      "lines": 54,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpf_set_str": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "int\nmpf_set_str (mpf_ptr x, const char *str, int base)\n{\n  size_t str_size;\n  char *s, *begs;\n  size_t i, j;\n  int c;\n  int negative;\n  char *dotpos = 0;\n  const char *expptr;\n  int exp_base;\n  const char  *point = GMP_DECIMAL_POINT;\n  size_t      pointlen = strlen (point);\n  const unsigned char *digit_value;\n  TMP_DECL;\n\n  c = (unsigned char) *str;\n\n  /* Skip whitespace.  */\n  while (isspace (c))\n    c = (unsigned char) *++str;\n\n  negative = 0;\n  if (c == '-')\n    {\n      negative = 1;\n      c = (unsigned char) *++str;\n    }\n\n  /* Default base to decimal.  */\n  if (base == 0)\n    base = 10;\n\n  exp_base = base;\n\n  if (base < 0)\n    {\n      exp_base = 10;\n      base = -base;\n    }\n\n  digit_value = digit_value_tab;\n  if (base > 36)\n    {\n      /* For bases > 36, use the collating sequence\n\t 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.  */\n      digit_value += 208;\n      if (base > 62)\n\treturn -1;\t\t/* too large base */\n    }\n\n  /* Require at least one digit, possibly after an initial decimal point.  */\n  if (digit_value[c] >= base)\n    {\n      /* not a digit, must be a decimal point */\n      for (i = 0; i < pointlen; i++)\n\tif (str[i] != point[i])\n\t  return -1;\n      if (digit_value[(unsigned char) str[pointlen]] >= base)\n\treturn -1;\n    }\n\n  /* Locate exponent part of the input.  Look from the right of the string,\n     since the exponent is usually a lot shorter than the mantissa.  */\n  expptr = NULL;\n  str_size = strlen (str);\n  for (i = str_size - 1; i > 0; i--)\n    {\n      c = (unsigned char) str[i];\n      if (c == '@' || (base <= 10 && (c == 'e' || c == 'E')))\n\t{\n\t  expptr = str + i + 1;\n\t  str_size = i;\n\t  break;\n\t}\n    }\n\n  TMP_MARK;\n  s = begs = (char *) TMP_ALLOC (str_size + 1);\n\n  /* Loop through mantissa, converting it from ASCII to raw byte values.  */\n  for (i = 0; i < str_size; i++)\n    {\n      c = (unsigned char) *str;\n      if (!isspace (c))\n\t{\n\t  int dig;\n\n\t  for (j = 0; j < pointlen; j++)\n\t    if (str[j] != point[j])\n\t      goto not_point;\n\t  if (1)\n\t    {\n\t      if (dotpos != 0)\n\t\t{\n\t\t  /* already saw a decimal point, another is invalid */\n\t\t  TMP_FREE;\n\t\t  return -1;\n\t\t}\n\t      dotpos = s;\n\t      str += pointlen - 1;\n\t      i += pointlen - 1;\n\t    }\n\t  else\n\t    {\n\t    not_point:\n\t      dig = digit_value[c];\n\t      if (dig >= base)\n\t\t{\n\t\t  TMP_FREE;\n\t\t  return -1;\n\t\t}\n\t      *s++ = dig;\n\t    }\n\t}\n      c = (unsigned char) *++str;\n    }\n\n  str_size = s - begs;\n\n  {\n    long exp_in_base;\n    mp_size_t ra, ma, rn, mn;\n    int cnt;\n    mp_ptr mp, tp, rp;\n    mp_exp_t exp_in_limbs;\n    mp_size_t prec = PREC(x) + 1;\n    int divflag;\n    mp_size_t madj, radj;\n\n#if 0\n    size_t n_chars_needed;\n\n    /* This breaks things like 0.000...0001.  To safely ignore superfluous\n       digits, we need to skip over leading zeros.  */\n    /* Just consider the relevant leading digits of the mantissa.  */\n    LIMBS_PER_DIGIT_IN_BASE (n_chars_needed, prec, base);\n    if (str_size > n_chars_needed)\n      str_size = n_chars_needed;\n#endif\n\n    LIMBS_PER_DIGIT_IN_BASE (ma, str_size, base);\n    mp = TMP_ALLOC_LIMBS (ma);\n    mn = mpn_set_str (mp, (unsigned char *) begs, str_size, base);\n\n    if (mn == 0)\n      {\n\tSIZ(x) = 0;\n\tEXP(x) = 0;\n\tTMP_FREE;\n\treturn 0;\n      }\n\n    madj = 0;\n    /* Ignore excess limbs in MP,MSIZE.  */\n    if (mn > prec)\n      {\n\tmadj = mn - prec;\n\tmp += mn - prec;\n\tmn = prec;\n      }\n\n    if (expptr != 0)\n      {\n\t/* Scan and convert the exponent, in base exp_base.  */\n\tlong dig, minus, plusminus;\n\tc = (unsigned char) *expptr;\n\tminus = -(long) (c == '-');\n\tplusminus = minus | -(long) (c == '+');\n\texpptr -= plusminus;\t\t\t/* conditional increment */\n\tc = (unsigned char) *expptr++;\n\tdig = digit_value[c];\n\tif (dig >= exp_base)\n\t  {\n\t    TMP_FREE;\n\t    return -1;\n\t  }\n\texp_in_base = dig;\n\tc = (unsigned char) *expptr++;\n\tdig = digit_value[c];\n\twhile (dig < exp_base)\n\t  {\n\t    exp_in_base = exp_in_base * exp_base;\n\t    exp_in_base += dig;\n\t    c = (unsigned char) *expptr++;\n\t    dig = digit_value[c];\n\t  }\n\texp_in_base = (exp_in_base ^ minus) - minus; /* conditional negation */\n      }\n    else\n      exp_in_base = 0;\n    if (dotpos != 0)\n      exp_in_base -= s - dotpos;\n    divflag = exp_in_base < 0;\n    exp_in_base = ABS (exp_in_base);\n\n    if (exp_in_base == 0)\n      {\n\tMPN_COPY (PTR(x), mp, mn);\n\tSIZ(x) = negative ? -mn : mn;\n\tEXP(x) = mn + madj;\n\tTMP_FREE;\n\treturn 0;\n      }\n\n    ra = 2 * (prec + 1);\n    rp = TMP_ALLOC_LIMBS (ra);\n    tp = TMP_ALLOC_LIMBS (ra);\n    rn = mpn_pow_1_highpart (rp, &radj, (mp_limb_t) base, exp_in_base, prec, tp);\n\n    if (divflag)\n      {\n#if 0\n\t/* FIXME: Should use mpn_div_q here.  */\n\t...\n\tmpn_div_q (tp, mp, mn, rp, rn, scratch);\n\t...\n#else\n\tmp_ptr qp;\n\tmp_limb_t qlimb;\n\tif (mn < rn)\n\t  {\n\t    /* Pad out MP,MSIZE for current divrem semantics.  */\n\t    mp_ptr tmp = TMP_ALLOC_LIMBS (rn + 1);\n\t    MPN_ZERO (tmp, rn - mn);\n\t    MPN_COPY (tmp + rn - mn, mp, mn);\n\t    mp = tmp;\n\t    madj -= rn - mn;\n\t    mn = rn;\n\t  }\n\tif ((rp[rn - 1] & GMP_NUMB_HIGHBIT) == 0)\n\t  {\n\t    mp_limb_t cy;\n\t    count_leading_zeros (cnt, rp[rn - 1]);\n\t    cnt -= GMP_NAIL_BITS;\n\t    mpn_lshift (rp, rp, rn, cnt);\n\t    cy = mpn_lshift (mp, mp, mn, cnt);\n\t    if (cy)\n\t      mp[mn++] = cy;\n\t  }\n\n\tqp = TMP_ALLOC_LIMBS (prec + 1);\n\tqlimb = mpn_divrem (qp, prec - (mn - rn), mp, mn, rp, rn);\n\ttp = qp;\n\texp_in_limbs = qlimb + (mn - rn) + (madj - radj);\n\trn = prec;\n\tif (qlimb != 0)\n\t  {\n\t    tp[prec] = qlimb;\n\t    /* Skip the least significant limb not to overrun the destination\n\t       variable.  */\n\t    tp++;\n\t  }\n#endif\n      }\n    else\n      {\n\ttp = TMP_ALLOC_LIMBS (rn + mn);\n\tif (rn > mn)\n\t  mpn_mul (tp, rp, rn, mp, mn);\n\telse\n\t  mpn_mul (tp, mp, mn, rp, rn);\n\trn += mn;\n\trn -= tp[rn - 1] == 0;\n\texp_in_limbs = rn + madj + radj;\n\n\tif (rn > prec)\n\t  {\n\t    tp += rn - prec;\n\t    rn = prec;\n\t    exp_in_limbs += 0;\n\t  }\n      }\n\n    MPN_COPY (PTR(x), tp, rn);\n    SIZ(x) = negative ? -rn : rn;\n    EXP(x) = exp_in_limbs;\n    TMP_FREE;\n    return 0;\n  }\n}",
      "lines": 281,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/set_ui.c": {
    "mpf_set_ui": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nmpf_set_ui (mpf_ptr f, unsigned long val)\n{\n  mp_size_t size;\n\n  f->_mp_d[0] = val & GMP_NUMB_MASK;\n  size = val != 0;\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS\n  val >>= GMP_NUMB_BITS;\n  f->_mp_d[1] = val;\n  size += (val != 0);\n#endif\n\n  f->_mp_exp = f->_mp_size = size;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/set_z.c": {
    "mpf_set_z": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\nmpf_set_z (mpf_ptr r, mpz_srcptr u)\n{\n  mp_ptr rp, up;\n  mp_size_t size, asize;\n  mp_size_t prec;\n\n  prec = PREC (r) + 1;\n  size = SIZ (u);\n  asize = ABS (size);\n  rp = PTR (r);\n  up = PTR (u);\n\n  EXP (r) = asize;\n\n  if (asize > prec)\n    {\n      up += asize - prec;\n      asize = prec;\n    }\n\n  SIZ (r) = size >= 0 ? asize : -asize;\n  MPN_COPY (rp, up, asize);\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/size.c": {
    "mpf_size": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "size_t\nmpf_size (mpf_srcptr f) __GMP_NOTHROW\n{\n  return __GMP_ABS (f->_mp_size);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "size_t",
        "mpf_size (mpf_srcptr f)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/sqrt.c": {
    "mpf_sqrt": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\nmpf_sqrt (mpf_ptr r, mpf_srcptr u)\n{\n  mp_size_t usize;\n  mp_ptr up, tp;\n  mp_size_t prec, tsize;\n  mp_exp_t uexp, expodd;\n  TMP_DECL;\n\n  usize = u->_mp_size;\n  if (UNLIKELY (usize <= 0))\n    {\n      if (usize < 0)\n        SQRT_OF_NEGATIVE;\n      r->_mp_size = 0;\n      r->_mp_exp = 0;\n      return;\n    }\n\n  TMP_MARK;\n\n  uexp = u->_mp_exp;\n  prec = r->_mp_prec;\n  up = u->_mp_d;\n\n  expodd = (uexp & 1);\n  tsize = 2 * prec - expodd;\n  r->_mp_size = prec;\n  r->_mp_exp = (uexp + expodd) / 2;    /* ceil(uexp/2) */\n\n  /* root size is ceil(tsize/2), this will be our desired \"prec\" limbs */\n  ASSERT ((tsize + 1) / 2 == prec);\n\n  tp = TMP_ALLOC_LIMBS (tsize);\n\n  if (usize > tsize)\n    {\n      up += usize - tsize;\n      usize = tsize;\n      MPN_COPY (tp, up, tsize);\n    }\n  else\n    {\n      MPN_ZERO (tp, tsize - usize);\n      MPN_COPY (tp + (tsize - usize), up, usize);\n    }\n\n  mpn_sqrtrem (r->_mp_d, NULL, tp, tsize);\n\n  TMP_FREE;\n}",
      "lines": 51,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/sqrt_ui.c": {
    "mpf_sqrt_ui": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "void\nmpf_sqrt_ui (mpf_ptr r, unsigned long int u)\n{\n  mp_size_t rsize, zeros;\n  mp_ptr tp;\n  mp_size_t prec;\n  TMP_DECL;\n\n  if (UNLIKELY (u <= 1))\n    {\n      SIZ (r) = EXP (r) = u;\n      *PTR (r) = u;\n      return;\n    }\n\n  TMP_MARK;\n\n  prec = PREC (r);\n  zeros = 2 * prec - 2;\n  rsize = zeros + 1 + U2;\n\n  tp = TMP_ALLOC_LIMBS (rsize);\n\n  MPN_ZERO (tp, zeros);\n  tp[zeros] = u & GMP_NUMB_MASK;\n\n#if U2\n  {\n    mp_limb_t uhigh = u >> GMP_NUMB_BITS;\n    tp[zeros + 1] = uhigh;\n    rsize -= (uhigh == 0);\n  }\n#endif\n\n  mpn_sqrtrem (PTR (r), NULL, tp, rsize);\n\n  SIZ (r) = prec;\n  EXP (r) = 1;\n  TMP_FREE;\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/sub.c": {
    "mpf_sub": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "void\nmpf_sub (mpf_ptr r, mpf_srcptr u, mpf_srcptr v)\n{\n  mp_srcptr up, vp;\n  mp_ptr rp, tp;\n  mp_size_t usize, vsize, rsize;\n  mp_size_t prec;\n  mp_exp_t exp;\n  mp_size_t ediff;\n  int negate;\n  TMP_DECL;\n\n  usize = SIZ (u);\n  vsize = SIZ (v);\n\n  /* Handle special cases that don't work in generic code below.  */\n  if (usize == 0)\n    {\n      mpf_neg (r, v);\n      return;\n    }\n  if (vsize == 0)\n    {\n      if (r != u)\n        mpf_set (r, u);\n      return;\n    }\n\n  /* If signs of U and V are different, perform addition.  */\n  if ((usize ^ vsize) < 0)\n    {\n      __mpf_struct v_negated;\n      v_negated._mp_size = -vsize;\n      v_negated._mp_exp = EXP (v);\n      v_negated._mp_d = PTR (v);\n      mpf_add (r, u, &v_negated);\n      return;\n    }\n\n  TMP_MARK;\n\n  /* Signs are now known to be the same.  */\n  negate = usize < 0;\n\n  /* Make U be the operand with the largest exponent.  */\n  if (EXP (u) < EXP (v))\n    {\n      mpf_srcptr t;\n      t = u; u = v; v = t;\n      negate ^= 1;\n      usize = SIZ (u);\n      vsize = SIZ (v);\n    }\n\n  usize = ABS (usize);\n  vsize = ABS (vsize);\n  up = PTR (u);\n  vp = PTR (v);\n  rp = PTR (r);\n  prec = PREC (r) + 1;\n  exp = EXP (u);\n  ediff = exp - EXP (v);\n\n  /* If ediff is 0 or 1, we might have a situation where the operands are\n     extremely close.  We need to scan the operands from the most significant\n     end ignore the initial parts that are equal.  */\n  if (ediff <= 1)\n    {\n      if (ediff == 0)\n\t{\n\t  /* Skip leading limbs in U and V that are equal.  */\n\t      /* This loop normally exits immediately.  Optimize for that.  */\n\t      while (up[usize - 1] == vp[vsize - 1])\n\t\t{\n\t\t  usize--;\n\t\t  vsize--;\n\t\t  exp--;\n\n\t\t  if (usize == 0)\n\t\t    {\n                      /* u cancels high limbs of v, result is rest of v */\n\t\t      negate ^= 1;\n                    cancellation:\n                      /* strip high zeros before truncating to prec */\n                      while (vsize != 0 && vp[vsize - 1] == 0)\n                        {\n                          vsize--;\n                          exp--;\n                        }\n\t\t      if (vsize > prec)\n\t\t\t{\n\t\t\t  vp += vsize - prec;\n\t\t\t  vsize = prec;\n\t\t\t}\n                      MPN_COPY_INCR (rp, vp, vsize);\n                      rsize = vsize;\n                      goto done;\n\t\t    }\n\t\t  if (vsize == 0)\n\t\t    {\n                      vp = up;\n                      vsize = usize;\n                      goto cancellation;\n\t\t    }\n\t\t}\n\n\t  if (up[usize - 1] < vp[vsize - 1])\n\t    {\n\t      /* For simplicity, swap U and V.  Note that since the loop above\n\t\t wouldn't have exited unless up[usize - 1] and vp[vsize - 1]\n\t\t were non-equal, this if-statement catches all cases where U\n\t\t is smaller than V.  */\n\t      MPN_SRCPTR_SWAP (up,usize, vp,vsize);\n\t      negate ^= 1;\n\t      /* negating ediff not necessary since it is 0.  */\n\t    }\n\n\t  /* Check for\n\t     x+1 00000000 ...\n\t      x  ffffffff ... */\n\t  if (up[usize - 1] != vp[vsize - 1] + 1)\n\t    goto general_case;\n\t  usize--;\n\t  vsize--;\n\t  exp--;\n\t}\n      else /* ediff == 1 */\n\t{\n\t  /* Check for\n\t     1 00000000 ...\n\t     0 ffffffff ... */\n\n\t  if (up[usize - 1] != 1 || vp[vsize - 1] != GMP_NUMB_MAX\n\t      || (usize >= 2 && up[usize - 2] != 0))\n\t    goto general_case;\n\n\t  usize--;\n\t  exp--;\n\t}\n\n      /* Skip sequences of 00000000/ffffffff */\n      while (vsize != 0 && usize != 0 && up[usize - 1] == 0\n\t     && vp[vsize - 1] == GMP_NUMB_MAX)\n\t{\n\t  usize--;\n\t  vsize--;\n\t  exp--;\n\t}\n\n      if (usize == 0)\n\t{\n\t  while (vsize != 0 && vp[vsize - 1] == GMP_NUMB_MAX)\n\t    {\n\t      vsize--;\n\t      exp--;\n\t    }\n\t}\n      else if (usize > prec - 1)\n\t{\n\t  up += usize - (prec - 1);\n\t  usize = prec - 1;\n\t}\n      if (vsize > prec - 1)\n\t{\n\t  vp += vsize - (prec - 1);\n\t  vsize = prec - 1;\n\t}\n\n      tp = TMP_ALLOC_LIMBS (prec);\n      {\n\tmp_limb_t cy_limb;\n\tif (vsize == 0)\n\t  {\n\t    MPN_COPY (tp, up, usize);\n\t    tp[usize] = 1;\n\t    rsize = usize + 1;\n\t    exp++;\n\t    goto normalized;\n\t  }\n\tif (usize == 0)\n\t  {\n\t    cy_limb = mpn_neg (tp, vp, vsize);\n\t    rsize = vsize;\n\t  }\n\telse if (usize >= vsize)\n\t  {\n\t    /* uuuu     */\n\t    /* vv       */\n\t    mp_size_t size;\n\t    size = usize - vsize;\n\t    MPN_COPY (tp, up, size);\n\t    cy_limb = mpn_sub_n (tp + size, up + size, vp, vsize);\n\t    rsize = usize;\n\t  }\n\telse /* (usize < vsize) */\n\t  {\n\t    /* uuuu     */\n\t    /* vvvvvvv  */\n\t    mp_size_t size;\n\t    size = vsize - usize;\n\t    cy_limb = mpn_neg (tp, vp, size);\n\t    cy_limb = mpn_sub_nc (tp + size, up, vp + size, usize, cy_limb);\n\t    rsize = vsize;\n\t  }\n\tif (cy_limb == 0)\n\t  {\n\t    tp[rsize] = 1;\n\t    rsize++;\n\t    exp++;\n\t    goto normalized;\n\t  }\n\tgoto normalize;\n      }\n    }\n\ngeneral_case:\n  /* If U extends beyond PREC, ignore the part that does.  */\n  if (usize > prec)\n    {\n      up += usize - prec;\n      usize = prec;\n    }\n\n  /* If V extends beyond PREC, ignore the part that does.\n     Note that this may make vsize negative.  */\n  if (vsize + ediff > prec)\n    {\n      vp += vsize + ediff - prec;\n      vsize = prec - ediff;\n    }\n\n  if (ediff >= prec)\n    {\n      /* V completely cancelled.  */\n      if (rp != up)\n\tMPN_COPY (rp, up, usize);\n      rsize = usize;\n    }\n  else\n    {\n      /* Allocate temp space for the result.  Allocate\n\t just vsize + ediff later???  */\n      tp = TMP_ALLOC_LIMBS (prec);\n\n      /* Locate the least significant non-zero limb in (the needed\n\t parts of) U and V, to simplify the code below.  */\n      for (;;)\n\t{\n\t  if (vsize == 0)\n\t    {\n\t      MPN_COPY (rp, up, usize);\n\t      rsize = usize;\n\t      goto done;\n\t    }\n\t  if (vp[0] != 0)\n\t    break;\n\t  vp++, vsize--;\n\t}\n      for (;;)\n\t{\n\t  if (usize == 0)\n\t    {\n\t      MPN_COPY (rp, vp, vsize);\n\t      rsize = vsize;\n\t      negate ^= 1;\n\t      goto done;\n\t    }\n\t  if (up[0] != 0)\n\t    break;\n\t  up++, usize--;\n\t}\n\n      /* uuuu     |  uuuu     |  uuuu     |  uuuu     |  uuuu    */\n      /* vvvvvvv  |  vv       |    vvvvv  |    v      |       vv */\n\n      if (usize > ediff)\n\t{\n\t  /* U and V partially overlaps.  */\n\t  if (ediff == 0)\n\t    {\n\t      /* Have to compare the leading limbs of u and v\n\t\t to determine whether to compute u - v or v - u.  */\n\t      if (usize >= vsize)\n\t\t{\n\t\t  /* uuuu     */\n\t\t  /* vv       */\n\t\t  mp_size_t size;\n\t\t  size = usize - vsize;\n\t\t  MPN_COPY (tp, up, size);\n\t\t  mpn_sub_n (tp + size, up + size, vp, vsize);\n\t\t  rsize = usize;\n\t\t}\n\t      else /* (usize < vsize) */\n\t\t{\n\t\t  /* uuuu     */\n\t\t  /* vvvvvvv  */\n\t\t  mp_size_t size;\n\t\t  size = vsize - usize;\n\t\t  ASSERT_CARRY (mpn_neg (tp, vp, size));\n\t\t  mpn_sub_nc (tp + size, up, vp + size, usize, CNST_LIMB (1));\n\t\t  rsize = vsize;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if (vsize + ediff <= usize)\n\t\t{\n\t\t  /* uuuu     */\n\t\t  /*   v      */\n\t\t  mp_size_t size;\n\t\t  size = usize - ediff - vsize;\n\t\t  MPN_COPY (tp, up, size);\n\t\t  mpn_sub (tp + size, up + size, usize - size, vp, vsize);\n\t\t  rsize = usize;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* uuuu     */\n\t\t  /*   vvvvv  */\n\t\t  mp_size_t size;\n\t\t  rsize = vsize + ediff;\n\t\t  size = rsize - usize;\n\t\t  ASSERT_CARRY (mpn_neg (tp, vp, size));\n\t\t  mpn_sub (tp + size, up, usize, vp + size, usize - ediff);\n\t\t  /* Should we use sub_nc then sub_1? */\n\t\t  MPN_DECR_U (tp + size, usize, CNST_LIMB (1));\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  /* uuuu     */\n\t  /*      vv  */\n\t  mp_size_t size, i;\n\t  size = vsize + ediff - usize;\n\t  ASSERT_CARRY (mpn_neg (tp, vp, vsize));\n\t  for (i = vsize; i < size; i++)\n\t    tp[i] = GMP_NUMB_MAX;\n\t  mpn_sub_1 (tp + size, up, usize, (mp_limb_t) 1);\n\t  rsize = size + usize;\n\t}\n\n    normalize:\n      /* Full normalize.  Optimize later.  */\n      while (rsize != 0 && tp[rsize - 1] == 0)\n\t{\n\t  rsize--;\n\t  exp--;\n\t}\n    normalized:\n      MPN_COPY (rp, tp, rsize);\n    }\n\n done:\n  TMP_FREE;\n  if (rsize == 0) {\n    SIZ (r) = 0;\n    EXP (r) = 0;\n  } else {\n    SIZ (r) = negate ? -rsize : rsize;\n    EXP (r) = exp;\n  }\n}",
      "lines": 363,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/sub_ui.c": {
    "mpf_sub_ui": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\nmpf_sub_ui (mpf_ptr sum, mpf_srcptr u, unsigned long int v)\n{\n  __mpf_struct vv;\n  mp_limb_t vl;\n\n  if (v == 0)\n    {\n      mpf_set (sum, u);\n      return;\n    }\n\n  vl = v;\n  vv._mp_size = 1;\n  vv._mp_d = &vl;\n  vv._mp_exp = 1;\n  mpf_sub (sum, u, &vv);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/swap.c": {
    "mpf_swap": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\nmpf_swap (mpf_ptr u, mpf_ptr v) __GMP_NOTHROW\n{\n  mp_ptr tptr;\n  mp_size_t tprec;\n  mp_size_t tsiz;\n  mp_exp_t  texp;\n\n  tprec = PREC(u);\n  PREC(u) = PREC(v);\n  PREC(v) = tprec;\n\n  tsiz = SIZ(u);\n  SIZ(u) = SIZ(v);\n  SIZ(v) = tsiz;\n\n  texp = EXP(u);\n  EXP(u) = EXP(v);\n  EXP(v) = texp;\n\n  tptr = PTR(u);\n  PTR(u) = PTR(v);\n  PTR(v) = tptr;\n}",
      "lines": 24,
      "depth": 7,
      "decorators": [
        "void",
        "mpf_swap (mpf_ptr u, mpf_ptr v)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/trunc.c": {
    "mpf_trunc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\nmpf_trunc (mpf_ptr r, mpf_srcptr u)\n{\n  mp_ptr     rp;\n  mp_srcptr  up;\n  mp_size_t  size, asize, prec;\n  mp_exp_t   exp;\n\n  exp = EXP(u);\n  size = SIZ(u);\n  if (size == 0 || exp <= 0)\n    {\n      /* u is only a fraction */\n      SIZ(r) = 0;\n      EXP(r) = 0;\n      return;\n    }\n\n  up = PTR(u);\n  EXP(r) = exp;\n  asize = ABS (size);\n  up += asize;\n\n  /* skip fraction part of u */\n  asize = MIN (asize, exp);\n\n  /* don't lose precision in the copy */\n  prec = PREC(r) + 1;\n\n  /* skip excess over target precision */\n  asize = MIN (asize, prec);\n\n  up -= asize;\n  rp = PTR(r);\n  SIZ(r) = (size >= 0 ? asize : -asize);\n  if (rp != up)\n    MPN_COPY_INCR (rp, up, asize);\n}",
      "lines": 38,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/ui_div.c": {
    "mpf_ui_div": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\nmpf_ui_div (mpf_ptr r, unsigned long int u, mpf_srcptr v)\n{\n  mp_srcptr vp;\n  mp_ptr rp, tp, remp, new_vp;\n  mp_size_t vsize;\n  mp_size_t rsize, prospective_rsize, zeros, tsize, high_zero;\n  mp_size_t sign_quotient;\n  mp_size_t prec;\n  mp_exp_t rexp;\n  TMP_DECL;\n\n  vsize = v->_mp_size;\n  sign_quotient = vsize;\n\n  if (UNLIKELY (vsize == 0))\n    DIVIDE_BY_ZERO;\n\n  if (UNLIKELY (u == 0))\n    {\n      r->_mp_size = 0;\n      r->_mp_exp = 0;\n      return;\n    }\n\n  vsize = ABS (vsize);\n  prec = r->_mp_prec;\n\n  TMP_MARK;\n  rexp = 1 - v->_mp_exp + 1;\n\n  rp = r->_mp_d;\n  vp = v->_mp_d;\n\n  prospective_rsize = 1 - vsize + 1;    /* quot from using given u,v sizes */\n  rsize = prec + 1;                     /* desired quot size */\n\n  zeros = rsize - prospective_rsize;    /* padding u to give rsize */\n  tsize = 1 + zeros;                    /* u with zeros */\n\n  if (WANT_TMP_DEBUG)\n    {\n      /* separate alloc blocks, for malloc debugging */\n      remp = TMP_ALLOC_LIMBS (vsize);\n      tp = TMP_ALLOC_LIMBS (tsize);\n      new_vp = NULL;\n      if (rp == vp)\n        new_vp = TMP_ALLOC_LIMBS (vsize);\n    }\n  else\n    {\n      /* one alloc with calculated size, for efficiency */\n      mp_size_t size = vsize + tsize + (rp == vp ? vsize : 0);\n      remp = TMP_ALLOC_LIMBS (size);\n      tp = remp + vsize;\n      new_vp = tp + tsize;\n    }\n\n  /* ensure divisor doesn't overlap quotient */\n  if (rp == vp)\n    {\n      MPN_COPY (new_vp, vp, vsize);\n      vp = new_vp;\n    }\n\n  MPN_ZERO (tp, tsize-1);\n\n  tp[tsize - 1] = u & GMP_NUMB_MASK;\n#if BITS_PER_ULONG > GMP_NUMB_BITS\n  if (u > GMP_NUMB_MAX)\n    {\n      /* tsize-vsize+1 == rsize, so tsize >= rsize.  rsize == prec+1 >= 2,\n         so tsize >= 2, hence there's room for 2-limb u with nails */\n      ASSERT (tsize >= 2);\n      tp[tsize - 1] = u >> GMP_NUMB_BITS;\n      tp[tsize - 2] = u & GMP_NUMB_MASK;\n      rexp++;\n    }\n#endif\n\n  ASSERT (tsize-vsize+1 == rsize);\n  mpn_tdiv_qr (rp, remp, (mp_size_t) 0, tp, tsize, vp, vsize);\n\n  /* strip possible zero high limb */\n  high_zero = (rp[rsize-1] == 0);\n  rsize -= high_zero;\n  rexp -= high_zero;\n\n  r->_mp_size = sign_quotient >= 0 ? rsize : -rsize;\n  r->_mp_exp = rexp;\n  TMP_FREE;\n}",
      "lines": 92,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/ui_sub.c": {
    "mpf_ui_sub": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "void\nmpf_ui_sub (mpf_ptr r, unsigned long int u, mpf_srcptr v)\n{\n#if 1\n  __mpf_struct uu;\n  mp_limb_t ul;\n\n  if (u == 0)\n    {\n      mpf_neg (r, v);\n      return;\n    }\n\n  ul = u;\n  uu._mp_size = 1;\n  uu._mp_d = &ul;\n  uu._mp_exp = 1;\n  mpf_sub (r, &uu, v);\n\n#else\n  mp_srcptr up, vp;\n  mp_ptr rp, tp;\n  mp_size_t usize, vsize, rsize;\n  mp_size_t prec;\n  mp_exp_t uexp;\n  mp_size_t ediff;\n  int negate;\n  mp_limb_t ulimb;\n  TMP_DECL;\n\n  vsize = v->_mp_size;\n\n  /* Handle special cases that don't work in generic code below.  */\n  if (u == 0)\n    {\n      mpf_neg (r, v);\n      return;\n    }\n  if (vsize == 0)\n    {\n      mpf_set_ui (r, u);\n      return;\n    }\n\n  /* If signs of U and V are different, perform addition.  */\n  if (vsize < 0)\n    {\n      __mpf_struct v_negated;\n      v_negated._mp_size = -vsize;\n      v_negated._mp_exp = v->_mp_exp;\n      v_negated._mp_d = v->_mp_d;\n      mpf_add_ui (r, &v_negated, u);\n      return;\n    }\n\n  /* Signs are now known to be the same.  */\n  ASSERT (vsize > 0);\n  ulimb = u;\n  /* Make U be the operand with the largest exponent.  */\n  negate = 1 < v->_mp_exp;\n  prec = r->_mp_prec + negate;\n  rp = r->_mp_d;\n  if (negate)\n    {\n      usize = vsize;\n      vsize = 1;\n      up = v->_mp_d;\n      vp = &ulimb;\n      uexp = v->_mp_exp;\n      ediff = uexp - 1;\n\n      /* If U extends beyond PREC, ignore the part that does.  */\n      if (usize > prec)\n\t{\n\t  up += usize - prec;\n\t  usize = prec;\n\t}\n      ASSERT (ediff > 0);\n    }\n  else\n    {\n      vp = v->_mp_d;\n      ediff = 1 - v->_mp_exp;\n  /* Ignore leading limbs in U and V that are equal.  Doing\n     this helps increase the precision of the result.  */\n      if (ediff == 0 && ulimb == vp[vsize - 1])\n\t{\n\t  usize = 0;\n\t  vsize--;\n\t  uexp = 0;\n\t  /* Note that V might now have leading zero limbs.\n\t     In that case we have to adjust uexp.  */\n\t  for (;;)\n\t    {\n\t      if (vsize == 0) {\n\t\trsize = 0;\n\t\tuexp = 0;\n\t\tgoto done;\n\t      }\n\t      if ( vp[vsize - 1] != 0)\n\t\tbreak;\n\t      vsize--, uexp--;\n\t    }\n\t}\n      else\n\t{\n\t  usize = 1;\n\t  uexp = 1;\n\t  up = &ulimb;\n\t}\n      ASSERT (usize <= prec);\n    }\n\n  if (ediff >= prec)\n    {\n      /* V completely cancelled.  */\n      if (rp != up)\n\tMPN_COPY (rp, up, usize);\n      rsize = usize;\n    }\n  else\n    {\n  /* If V extends beyond PREC, ignore the part that does.\n     Note that this can make vsize neither zero nor negative.  */\n  if (vsize + ediff > prec)\n    {\n      vp += vsize + ediff - prec;\n      vsize = prec - ediff;\n    }\n\n      /* Locate the least significant non-zero limb in (the needed\n\t parts of) U and V, to simplify the code below.  */\n      ASSERT (vsize > 0);\n      for (;;)\n\t{\n\t  if (vp[0] != 0)\n\t    break;\n\t  vp++, vsize--;\n\t  if (vsize == 0)\n\t    {\n\t      MPN_COPY (rp, up, usize);\n\t      rsize = usize;\n\t      goto done;\n\t    }\n\t}\n      for (;;)\n\t{\n\t  if (usize == 0)\n\t    {\n\t      MPN_COPY (rp, vp, vsize);\n\t      rsize = vsize;\n\t      negate ^= 1;\n\t      goto done;\n\t    }\n\t  if (up[0] != 0)\n\t    break;\n\t  up++, usize--;\n\t}\n\n      ASSERT (usize > 0 && vsize > 0);\n      TMP_MARK;\n\n      tp = TMP_ALLOC_LIMBS (prec);\n\n      /* uuuu     |  uuuu     |  uuuu     |  uuuu     |  uuuu    */\n      /* vvvvvvv  |  vv       |    vvvvv  |    v      |       vv */\n\n      if (usize > ediff)\n\t{\n\t  /* U and V partially overlaps.  */\n\t  if (ediff == 0)\n\t    {\n\t      ASSERT (usize == 1 && vsize >= 1 && ulimb == *up); /* usize is 1>ediff, vsize >= 1 */\n\t      if (1 < vsize)\n\t\t{\n\t\t  /* u        */\n\t\t  /* vvvvvvv  */\n\t\t  rsize = vsize;\n\t\t  vsize -= 1;\n\t\t  /* mpn_cmp (up, vp + vsize - usize, usize) > 0 */\n\t\t  if (ulimb > vp[vsize])\n\t\t    {\n\t\t      tp[vsize] = ulimb - vp[vsize] - 1;\n\t\t      ASSERT_CARRY (mpn_neg (tp, vp, vsize));\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* vvvvvvv  */  /* Swap U and V. */\n\t\t      /* u        */\n\t\t      MPN_COPY (tp, vp, vsize);\n\t\t      tp[vsize] = vp[vsize] - ulimb;\n\t\t      negate = 1;\n\t\t    }\n\t\t}\n\t      else /* vsize == usize == 1 */\n\t\t{\n\t\t  /* u     */\n\t\t  /* v     */\n\t\t  rsize = 1;\n\t\t  negate = ulimb < vp[0];\n\t\t  tp[0] = negate ? vp[0] - ulimb: ulimb - vp[0];\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      ASSERT (vsize + ediff <= usize);\n\t      ASSERT (vsize == 1 && usize >= 2 && ulimb == *vp);\n\t\t{\n\t\t  /* uuuu     */\n\t\t  /*   v      */\n\t\t  mp_size_t size;\n\t\t  size = usize - ediff - 1;\n\t\t  MPN_COPY (tp, up, size);\n\t\t  ASSERT_NOCARRY (mpn_sub_1 (tp + size, up + size, usize - size, ulimb));\n\t\t  rsize = usize;\n\t\t}\n\t\t/* Other cases are not possible */\n\t\t/* uuuu     */\n\t\t/*   vvvvv  */\n\t    }\n\t}\n      else\n\t{\n\t  /* uuuu     */\n\t  /*      vv  */\n\t  mp_size_t size, i;\n\t  ASSERT_CARRY (mpn_neg (tp, vp, vsize));\n\t  rsize = vsize + ediff;\n\t  size = rsize - usize;\n\t  for (i = vsize; i < size; i++)\n\t    tp[i] = GMP_NUMB_MAX;\n\t  ASSERT_NOCARRY (mpn_sub_1 (tp + size, up, usize, CNST_LIMB (1)));\n\t}\n\n      /* Full normalize.  Optimize later.  */\n      while (rsize != 0 && tp[rsize - 1] == 0)\n\t{\n\t  rsize--;\n\t  uexp--;\n\t}\n      MPN_COPY (rp, tp, rsize);\n      TMP_FREE;\n    }\n\n done:\n  r->_mp_size = negate ? -rsize : rsize;\n  r->_mp_exp = uexp;\n#endif\n}",
      "lines": 249,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpf/urandomb.c": {
    "mpf_urandomb": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\nmpf_urandomb (mpf_t rop, gmp_randstate_t rstate, mp_bitcnt_t nbits)\n{\n  mp_ptr rp;\n  mp_size_t nlimbs;\n  mp_exp_t exp;\n  mp_size_t prec;\n\n  rp = PTR (rop);\n  nlimbs = BITS_TO_LIMBS (nbits);\n  prec = PREC (rop);\n\n  if (nlimbs > prec + 1 || nlimbs == 0)\n    {\n      nlimbs = prec + 1;\n      nbits = nlimbs * GMP_NUMB_BITS;\n    }\n\n  _gmp_rand (rp, rstate, nbits);\n\n  /* If nbits isn't a multiple of GMP_NUMB_BITS, shift up.  */\n  if (nbits % GMP_NUMB_BITS != 0)\n    mpn_lshift (rp, rp, nlimbs, GMP_NUMB_BITS - nbits % GMP_NUMB_BITS);\n\n  exp = 0;\n  while (nlimbs != 0 && rp[nlimbs - 1] == 0)\n    {\n      nlimbs--;\n      exp--;\n    }\n  EXP (rop) = exp;\n  SIZ (rop) = nlimbs;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/alpha/dive_1.c": {
    "mpn_divexact_1": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void\nmpn_divexact_1 (mp_ptr dst, mp_srcptr src, mp_size_t size, mp_limb_t divisor)\n{\n  mp_limb_t  inverse, lshift_mask, s, sr, s_next, c, h, x, y, q, dummy;\n  unsigned   rshift, lshift;\n\n  ASSERT (size >= 1);\n  ASSERT (divisor != 0);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (dst, src, size));\n  ASSERT_MPN (src, size);\n  ASSERT_LIMB (divisor);\n\n  s_next = *src++;   /* src[0] */\n\n  rshift = 0;\n  lshift_mask = 0;\n  if ((divisor & 1) == 0)\n    {\n      count_trailing_zeros (rshift, divisor);\n      lshift_mask = MP_LIMB_T_MAX;\n      divisor >>= rshift;\n    }\n\n  binvert_limb (inverse, divisor);\n  lshift = 64 - rshift;\n\n  c = 0;\n  h = 0;\n  sr = s_next >> rshift;\n\n  size--;\n  if (LIKELY (size != 0))\n    {\n      do\n        {\n          s_next = *src++;      /* src[i+1] */\n          s = sr | ((s_next << lshift) & lshift_mask);\n          x = s - c;\n          c = s < c;\n          sr = s_next >> rshift;\n\n          y = x - h;\n          c += (x < h);\n          q = y * inverse;\n          *dst++ = q;\n          umul_ppmm (h, dummy, q, divisor);\n\n          size--;\n        }\n      while (size != 0);\n    }\n\n  x = sr - c;\n  y = x - h;\n  q = y * inverse;\n  *dst = q;         /* dst[size-1] */\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/alpha/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/alpha/ev5/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/alpha/ev6/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/alpha/ev6/nails/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/arm/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/arm/v6/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/arm/v7a/cora15/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/arm/v7a/cora7/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/arm/v7a/cora8/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/arm/v7a/cora9/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/arm64/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/cray/add_n.c": {
    "mpn_add_n": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "mp_limb_t\nmpn_add_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_limb_t cy[n];\n  mp_limb_t a, b, r, s0, c0, c1;\n  mp_size_t i;\n  int more_carries;\n\n  /* Main add loop.  Generate a raw output sum in rp[] and a carry vector\n     in cy[].  */\n#pragma _CRI ivdep\n  for (i = 0; i < n; i++)\n    {\n      a = up[i];\n      b = vp[i];\n      s0 = a + b;\n      rp[i] = s0;\n      c0 = ((a & b) | ((a | b) & ~s0)) >> 63;\n      cy[i] = c0;\n    }\n  /* Carry add loop.  Add the carry vector cy[] to the raw sum rp[] and\n     store the new sum back to rp[0].  If this generates further carry, set\n     more_carries.  */\n  more_carries = 0;\n#pragma _CRI ivdep\n  for (i = 1; i < n; i++)\n    {\n      r = rp[i];\n      c0 = cy[i - 1];\n      s0 = r + c0;\n      rp[i] = s0;\n      c0 = (r & ~s0) >> 63;\n      more_carries += c0;\n    }\n  /* If that second loop generated carry, handle that in scalar loop.  */\n  if (more_carries)\n    {\n      mp_limb_t cyrec = 0;\n      /* Look for places where rp[k] is zero and cy[k-1] is non-zero.\n\t These are where we got a recurrency carry.  */\n      for (i = 1; i < n; i++)\n\t{\n\t  r = rp[i];\n\t  c0 = (r == 0 && cy[i - 1] != 0);\n\t  s0 = r + cyrec;\n\t  rp[i] = s0;\n\t  c1 = (r & ~s0) >> 63;\n\t  cyrec = c0 | c1;\n\t}\n      return cyrec | cy[n - 1];\n    }\n\n  return cy[n - 1];\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/cray/hamdist.c": {
    "mpn_hamdist": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "unsigned long int\nmpn_hamdist (mp_srcptr p1, mp_srcptr p2, mp_size_t n)\n{\n  unsigned long int result = 0;\n  mp_size_t i;\n  for (i = 0; i < n; i++)\n    result += _popcnt (p1[i] ^ p2[i]);\n  return result;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/lshift.c": {
    "mpn_lshift": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "mp_limb_t\nmpn_lshift (mp_ptr wp, mp_srcptr up, mp_size_t n, unsigned int cnt)\n{\n  unsigned sh_1, sh_2;\n  mp_size_t i;\n  mp_limb_t retval;\n\n  sh_1 = cnt;\n  sh_2 = GMP_LIMB_BITS - sh_1;\n  retval = up[n - 1] >> sh_2;\n\n#pragma _CRI ivdep\n  for (i = n - 1; i > 0; i--)\n    {\n#if 1\n      wp[i] = (up[i] << sh_1) | (up[i - 1] >> sh_2);\n#else\n      /* This is the recommended way, but at least on SV1 it is slower.  */\n      wp[i] = _dshiftl (up[i], up[i - 1], sh_1);\n#endif\n    }\n\n  wp[0] = up[0] << sh_1;\n  return retval;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/popcount.c": {
    "mpn_popcount": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "unsigned long int\nmpn_popcount (mp_srcptr p, mp_size_t n)\n{\n  unsigned long int result = 0;\n  mp_size_t i;\n  for (i = 0; i < n; i++)\n    result += _popcnt (p[i]);\n  return result;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/rshift.c": {
    "mpn_rshift": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "mp_limb_t\nmpn_rshift (mp_ptr wp, mp_srcptr up, mp_size_t n, unsigned int cnt)\n{\n  unsigned sh_1, sh_2;\n  mp_size_t i;\n  mp_limb_t retval;\n\n  sh_1 = cnt;\n  sh_2 = GMP_LIMB_BITS - sh_1;\n  retval = up[0] << sh_2;\n\n#pragma _CRI ivdep\n  for (i = 0; i < n - 1; i++)\n    {\n#if 1\n      wp[i] = (up[i] >> sh_1) | (up[i + 1] << sh_2);\n#else\n      /* This is the recommended way, but at least on SV1 it is slower.  */\n      wp[i] = _dshiftr (up[i + 1], up[i], sh_1);\n#endif\n    }\n\n  wp[n - 1] = up[n - 1] >> sh_1;\n  return retval;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/sub_n.c": {
    "mpn_sub_n": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "mp_limb_t\nmpn_sub_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_limb_t cy[n];\n  mp_limb_t a, b, r, s0, c0, c1;\n  mp_size_t i;\n  int more_carries;\n\n  /* Main subtract loop.  Generate a raw output difference in rp[] and a\n     borrow vector in cy[].  */\n#pragma _CRI ivdep\n  for (i = 0; i < n; i++)\n    {\n      a = up[i];\n      b = vp[i];\n      s0 = a - b;\t\t/* a = s0 + b */\n      rp[i] = s0;\n      c0 = ((s0 & b) | ((s0 | b) & ~a)) >> 63;\n      cy[i] = c0;\n    }\n  /* Borrow subtract loop.  Subtract the borrow vector cy[] from the raw\n     difference rp[] and store the new difference back to rp[0].  If this\n     generates further borrow, set more_carries.  */\n  more_carries = 0;\n#pragma _CRI ivdep\n  for (i = 1; i < n; i++)\n    {\n      r = rp[i];\n      c0 = cy[i - 1];\n      s0 = r - c0;\t\t/* r = s0 + c0 */\n      rp[i] = s0;\n      c0 = (s0 & ~r) >> 63;\n      more_carries += c0;\n    }\n  /* If that second loop generated borrow, handle that in scalar loop.  */\n  if (more_carries)\n    {\n      mp_limb_t cyrec = 0;\n      /* Look for places where rp[k] contains just ones and cy[k-1] is\n\t non-zero.  These are where we got a recurrency borrow.  */\n      for (i = 1; i < n; i++)\n\t{\n\t  r = rp[i];\n\t  c0 = (~r == 0 && cy[i - 1] != 0);\n\t  s0 = r - cyrec;\n\t  rp[i] = s0;\n\t  c1 = (s0 & ~r) >> 63;\n\t  cyrec = c0 | c1;\n\t}\n      return cyrec | cy[n - 1];\n    }\n\n  return cy[n - 1];\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/cfp/addmul_1.c": {
    "mpn_addmul_1": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "mp_limb_t\nmpn_addmul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t limb)\n{\n  mp_limb_t p0[n], p1[n], tp[n];\n  mp_limb_t cy_limb;\n\n  GMPN_MULWW (p1, p0, up, &n, &limb);\n  cy_limb = mpn_add_n (tp, rp, p0, n);\n  rp[0] = tp[0];\n  if (n != 1)\n    cy_limb += mpn_add_n (rp + 1, tp + 1, p1, n - 1);\n  cy_limb += p1[n - 1];\n\n  return cy_limb;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/cfp/mul_1.c": {
    "mpn_mul_1": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "mp_limb_t\nmpn_mul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t limb)\n{\n  mp_limb_t p0[n], p1[n];\n  mp_limb_t cy_limb;\n\n  GMPN_MULWW (p1, p0, up, &n, &limb);\n  rp[0] = p0[0];\n  cy_limb = p1[n - 1];\n  if (n != 1)\n    cy_limb += mpn_add_n (rp + 1, p0 + 1, p1, n - 1);\n\n  return cy_limb;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/cfp/submul_1.c": {
    "mpn_submul_1": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "mp_limb_t\nmpn_submul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t limb)\n{\n  mp_limb_t p0[n], p1[n], tp[n];\n  mp_limb_t cy_limb;\n\n  GMPN_MULWW (p1, p0, up, &n, &limb);\n  cy_limb = mpn_sub_n (tp, rp, p0, n);\n  rp[0] = tp[0];\n  if (n != 1)\n    cy_limb += mpn_sub_n (rp + 1, tp + 1, p1, n - 1);\n  cy_limb += p1[n - 1];\n\n  return cy_limb;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/ieee/addmul_1.c": {
    "mpn_addmul_1": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "mp_limb_t\nmpn_addmul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t cy[n];\n  mp_limb_t a, b, r, s0, s1, c0, c1;\n  mp_size_t i;\n  int more_carries;\n\n  if (up == rp)\n    {\n      /* The algorithm used below cannot handle overlap.  Handle it here by\n\t making a temporary copy of the source vector, then call ourselves.  */\n      mp_limb_t xp[n];\n      MPN_COPY (xp, up, n);\n      return mpn_addmul_1 (rp, xp, n, vl);\n    }\n\n  a = up[0] * vl;\n  r = rp[0];\n  s0 = a + r;\n  rp[0] = s0;\n  c0 = ((a & r) | ((a | r) & ~s0)) >> 63;\n  cy[0] = c0;\n\n  /* Main multiply loop.  Generate a raw accumulated output product in rp[]\n     and a carry vector in cy[].  */\n#pragma _CRI ivdep\n  for (i = 1; i < n; i++)\n    {\n      a = up[i] * vl;\n      b = _int_mult_upper (up[i - 1], vl);\n      s0 = a + b;\n      c0 = ((a & b) | ((a | b) & ~s0)) >> 63;\n      r = rp[i];\n      s1 = s0 + r;\n      rp[i] = s1;\n      c1 = ((s0 & r) | ((s0 | r) & ~s1)) >> 63;\n      cy[i] = c0 + c1;\n    }\n  /* Carry add loop.  Add the carry vector cy[] to the raw result rp[] and\n     store the new result back to rp[].  */\n  more_carries = 0;\n#pragma _CRI ivdep\n  for (i = 1; i < n; i++)\n    {\n      r = rp[i];\n      c0 = cy[i - 1];\n      s0 = r + c0;\n      rp[i] = s0;\n      c0 = (r & ~s0) >> 63;\n      more_carries += c0;\n    }\n  /* If that second loop generated carry, handle that in scalar loop.  */\n  if (more_carries)\n    {\n      mp_limb_t cyrec = 0;\n      /* Look for places where rp[k] == 0 and cy[k-1] == 1 or\n\t rp[k] == 1 and cy[k-1] == 2.\n\t These are where we got a recurrency carry.  */\n      for (i = 1; i < n; i++)\n\t{\n\t  r = rp[i];\n\t  c0 = r < cy[i - 1];\n\t  s0 = r + cyrec;\n\t  rp[i] = s0;\n\t  c1 = (r & ~s0) >> 63;\n\t  cyrec = c0 | c1;\n\t}\n      return _int_mult_upper (up[n - 1], vl) + cyrec + cy[n - 1];\n    }\n\n  return _int_mult_upper (up[n - 1], vl) + cy[n - 1];\n}",
      "lines": 73,
      "depth": 14,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/ieee/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/cray/ieee/invert_limb.c": {
    "mpn_invert_limb": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "mp_limb_t\nmpn_invert_limb (mp_limb_t d)\n{\n  mp_limb_t z, z2l, z2h, tl, th;\n  mp_limb_t xh, xl;\n  mp_limb_t zh, zl;\n\n#if GMP_LIMB_BITS == 32\n  z = approx_tab[(d >> 23) - 0x100] << 6;\t/* z < 2^16 */\n\n  z2l = z * z;\t\t\t\t\t/* z2l < 2^32 */\n  umul_ppmm (th, tl, z2l, d);\n  z = (z << 17) - (th << 1);\n#endif\n#if GMP_LIMB_BITS == 64\n  z = approx_tab[(d >> 55) - 0x100] << 6;\t/* z < 2^16 */\n\n  z2l = z * z;\t\t\t\t\t/* z2l < 2^32 */\n  th = z2l * (d >> 32);\t\t\t\t/* th < 2^64 */\n  z = (z << 17) - (th >> 31);\t\t\t/* z < 2^32 */\n\n  z2l = z * z;\n  umul_ppmm (th, tl, z2l, d);\n  z = (z << 33) - (th << 1);\n#endif\n\n  umul_ppmm (z2h, z2l, z, z);\n  umul_ppmm (th, tl, z2h, d);\n  umul_ppmm (xh, xl, z2l, d);\n  tl += xh;\n  th += tl < xh;\n  th = (th << 2) | (tl >> GMP_LIMB_BITS - 2);\n  tl = tl << 2;\n  sub_ddmmss (zh, zl, z << 2, 0, th, tl);\n\n  umul_ppmm (xh, xl, d, zh);\n  xh += d;\t\t/* add_ssaaaa (xh, xl, xh, xl, d, 0); */\n  if (~xh != 0)\n    {\n      add_ssaaaa (xh, xl, xh, xl, 0, d);\n      zh++;\n    }\n\n  add_ssaaaa (xh, xl, xh, xl, 0, d);\n  if (xh != 0)\n    zh++;\n\n  return zh;\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/ieee/mul_1.c": {
    "mpn_mul_1": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "mp_limb_t\nmpn_mul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t cy[n];\n  mp_limb_t a, b, r, s0, s1, c0, c1;\n  mp_size_t i;\n  int more_carries;\n\n  if (up == rp)\n    {\n      /* The algorithm used below cannot handle overlap.  Handle it here by\n\t making a temporary copy of the source vector, then call ourselves.  */\n      mp_limb_t xp[n];\n      MPN_COPY (xp, up, n);\n      return mpn_mul_1 (rp, xp, n, vl);\n    }\n\n  a = up[0] * vl;\n  rp[0] = a;\n  cy[0] = 0;\n\n  /* Main multiply loop.  Generate a raw accumulated output product in rp[]\n     and a carry vector in cy[].  */\n#pragma _CRI ivdep\n  for (i = 1; i < n; i++)\n    {\n      a = up[i] * vl;\n      b = _int_mult_upper (up[i - 1], vl);\n      s0 = a + b;\n      c0 = ((a & b) | ((a | b) & ~s0)) >> 63;\n      rp[i] = s0;\n      cy[i] = c0;\n    }\n  /* Carry add loop.  Add the carry vector cy[] to the raw sum rp[] and\n     store the new sum back to rp[0].  */\n  more_carries = 0;\n#pragma _CRI ivdep\n  for (i = 2; i < n; i++)\n    {\n      r = rp[i];\n      c0 = cy[i - 1];\n      s0 = r + c0;\n      rp[i] = s0;\n      c0 = (r & ~s0) >> 63;\n      more_carries += c0;\n    }\n  /* If that second loop generated carry, handle that in scalar loop.  */\n  if (more_carries)\n    {\n      mp_limb_t cyrec = 0;\n      /* Look for places where rp[k] is zero and cy[k-1] is non-zero.\n\t These are where we got a recurrency carry.  */\n      for (i = 2; i < n; i++)\n\t{\n\t  r = rp[i];\n\t  c0 = (r == 0 && cy[i - 1] != 0);\n\t  s0 = r + cyrec;\n\t  rp[i] = s0;\n\t  c1 = (r & ~s0) >> 63;\n\t  cyrec = c0 | c1;\n\t}\n      return _int_mult_upper (up[n - 1], vl) + cyrec + cy[n - 1];\n    }\n\n  return _int_mult_upper (up[n - 1], vl) + cy[n - 1];\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/ieee/mul_basecase.c": {
    "mpn_mul_basecase": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void\nmpn_mul_basecase (mp_ptr rp,\n\t\t  mp_srcptr up, mp_size_t un,\n\t\t  mp_srcptr vp, mp_size_t vn)\n{\n  mp_limb_t cy[un + vn];\n  mp_limb_t vl;\n  mp_limb_t a, b, r, s0, s1, c0, c1;\n  mp_size_t i, j;\n  int more_carries;\n\n  for (i = 0; i < un + vn; i++)\n    {\n      rp[i] = 0;\n      cy[i] = 0;\n    }\n\n#pragma _CRI novector\n  for (j = 0; j < vn; j++)\n    {\n      vl = vp[j];\n\n      a = up[0] * vl;\n      r = rp[j];\n      s0 = a + r;\n      rp[j] = s0;\n      c0 = ((a & r) | ((a | r) & ~s0)) >> 63;\n      cy[j] += c0;\n\n#pragma _CRI ivdep\n      for (i = 1; i < un; i++)\n\t{\n\t  a = up[i] * vl;\n\t  b = _int_mult_upper (up[i - 1], vl);\n\t  s0 = a + b;\n\t  c0 = ((a & b) | ((a | b) & ~s0)) >> 63;\n\t  r = rp[j + i];\n\t  s1 = s0 + r;\n\t  rp[j + i] = s1;\n\t  c1 = ((s0 & r) | ((s0 | r) & ~s1)) >> 63;\n\t  cy[j + i] += c0 + c1;\n\t}\n      rp[j + un] = _int_mult_upper (up[un - 1], vl);\n    }\n\n  more_carries = 0;\n#pragma _CRI ivdep\n  for (i = 1; i < un + vn; i++)\n    {\n      r = rp[i];\n      c0 = cy[i - 1];\n      s0 = r + c0;\n      rp[i] = s0;\n      c0 = (r & ~s0) >> 63;\n      more_carries += c0;\n    }\n  /* If that second loop generated carry, handle that in scalar loop.  */\n  if (more_carries)\n    {\n      mp_limb_t cyrec = 0;\n      for (i = 1; i < un + vn; i++)\n\t{\n\t  r = rp[i];\n\t  c0 = (r < cy[i - 1]);\n\t  s0 = r + cyrec;\n\t  rp[i] = s0;\n\t  c1 = (r & ~s0) >> 63;\n\t  cyrec = c0 | c1;\n\t}\n    }\n}",
      "lines": 71,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/ieee/sqr_basecase.c": {
    "mpn_sqr_basecase": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void\nmpn_sqr_basecase (mp_ptr rp,\n\t\t  mp_srcptr up, mp_size_t un)\n{\n  mp_limb_t cy[un + un];\n  mp_limb_t ul;\n  mp_limb_t a, b, r, s0, s1, c0, c1;\n  mp_size_t i, j;\n  int more_carries;\n\n  for (i = 0; i < un + un; i++)\n    {\n      rp[i] = 0;\n      cy[i] = 0;\n    }\n\n#pragma _CRI novector\n  for (j = 0; j < un; j++)\n    {\n      ul = up[j];\n\n      a = up[0] * ul;\n      r = rp[j];\n      s0 = a + r;\n      rp[j] = s0;\n      c0 = ((a & r) | ((a | r) & ~s0)) >> 63;\n      cy[j] += c0;\n\n#pragma _CRI ivdep\n      for (i = 1; i < un; i++)\n\t{\n\t  a = up[i] * ul;\n\t  b = _int_mult_upper (up[i - 1], ul);\n\t  s0 = a + b;\n\t  c0 = ((a & b) | ((a | b) & ~s0)) >> 63;\n\t  r = rp[j + i];\n\t  s1 = s0 + r;\n\t  rp[j + i] = s1;\n\t  c1 = ((s0 & r) | ((s0 | r) & ~s1)) >> 63;\n\t  cy[j + i] += c0 + c1;\n\t}\n      rp[j + un] = _int_mult_upper (up[un - 1], ul);\n    }\n\n  more_carries = 0;\n#pragma _CRI ivdep\n  for (i = 1; i < un + un; i++)\n    {\n      r = rp[i];\n      c0 = cy[i - 1];\n      s0 = r + c0;\n      rp[i] = s0;\n      c0 = (r & ~s0) >> 63;\n      more_carries += c0;\n    }\n  /* If that second loop generated carry, handle that in scalar loop.  */\n  if (more_carries)\n    {\n      mp_limb_t cyrec = 0;\n      for (i = 1; i < un + un; i++)\n\t{\n\t  r = rp[i];\n\t  c0 = (r < cy[i - 1]);\n\t  s0 = r + cyrec;\n\t  rp[i] = s0;\n\t  c1 = (r & ~s0) >> 63;\n\t  cyrec = c0 | c1;\n\t}\n    }\n}",
      "lines": 70,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/cray/ieee/submul_1.c": {
    "mpn_submul_1": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "mp_limb_t\nmpn_submul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t cy[n];\n  mp_limb_t a, b, r, s0, s1, c0, c1;\n  mp_size_t i;\n  int more_carries;\n\n  if (up == rp)\n    {\n      /* The algorithm used below cannot handle overlap.  Handle it here by\n\t making a temporary copy of the source vector, then call ourselves.  */\n      mp_limb_t xp[n];\n      MPN_COPY (xp, up, n);\n      return mpn_submul_1 (rp, xp, n, vl);\n    }\n\n  a = up[0] * vl;\n  r = rp[0];\n  s0 = r - a;\n  rp[0] = s0;\n  c1 = ((s0 & a) | ((s0 | a) & ~r)) >> 63;\n  cy[0] = c1;\n\n  /* Main multiply loop.  Generate a raw accumulated output product in rp[]\n     and a carry vector in cy[].  */\n#pragma _CRI ivdep\n  for (i = 1; i < n; i++)\n    {\n      a = up[i] * vl;\n      b = _int_mult_upper (up[i - 1], vl);\n      s0 = a + b;\n      c0 = ((a & b) | ((a | b) & ~s0)) >> 63;\n      r = rp[i];\n      s1 = r - s0;\n      rp[i] = s1;\n      c1 = ((s1 & s0) | ((s1 | s0) & ~r)) >> 63;\n      cy[i] = c0 + c1;\n    }\n  /* Carry subtract loop.  Subtract the carry vector cy[] from the raw result\n     rp[] and store the new result back to rp[].  */\n  more_carries = 0;\n#pragma _CRI ivdep\n  for (i = 1; i < n; i++)\n    {\n      r = rp[i];\n      c0 = cy[i - 1];\n      s0 = r - c0;\n      rp[i] = s0;\n      c0 = (s0 & ~r) >> 63;\n      more_carries += c0;\n    }\n  /* If that second loop generated carry, handle that in scalar loop.  */\n  if (more_carries)\n    {\n      mp_limb_t cyrec = 0;\n      /* Look for places where rp[k] == ~0 and cy[k-1] == 1 or\n\t rp[k] == ~1 and cy[k-1] == 2.\n\t These are where we got a recurrency carry.  */\n      for (i = 1; i < n; i++)\n\t{\n\t  r = rp[i];\n\t  c0 = ~r < cy[i - 1];\n\t  s0 = r - cyrec;\n\t  rp[i] = s0;\n\t  c1 = (s0 & ~r) >> 63;\n\t  cyrec = c0 | c1;\n\t}\n      return _int_mult_upper (up[n - 1], vl) + cyrec + cy[n - 1];\n    }\n\n  return _int_mult_upper (up[n - 1], vl) + cy[n - 1];\n}",
      "lines": 73,
      "depth": 14,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/add.c": {},
  "gmp/gmp-6.1.2/mpn/generic/addmul_1.c": {
    "mpn_addmul_1": [
      {
        "start_point": [
          40,
          0
        ],
        "end_point": [
          65,
          1
        ],
        "content": "mp_limb_t\nmpn_addmul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl, rl;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      rl = *rp;\n      lpl = rl + lpl;\n      cl += lpl < rl;\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}",
        "lines": 26,
        "depth": 10,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          71,
          0
        ],
        "end_point": [
          101,
          1
        ],
        "content": "mp_limb_t\nmpn_addmul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t shifted_vl, ul, rl, lpl, hpl, prev_hpl, cl, xl, c1, c2, c3;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT_MPN (rp, n);\n  ASSERT_MPN (up, n);\n  ASSERT_LIMB (vl);\n\n  shifted_vl = vl << GMP_NAIL_BITS;\n  cl = 0;\n  prev_hpl = 0;\n  do\n    {\n      ul = *up++;\n      rl = *rp;\n      umul_ppmm (hpl, lpl, ul, shifted_vl);\n      lpl >>= GMP_NAIL_BITS;\n      ADDC_LIMB (c1, xl, prev_hpl, lpl);\n      ADDC_LIMB (c2, xl, xl, rl);\n      ADDC_LIMB (c3, xl, xl, cl);\n      cl = c1 + c2 + c3;\n      *rp++ = xl;\n      prev_hpl = hpl;\n    }\n  while (--n != 0);\n\n  return prev_hpl + cl;\n}",
        "lines": 31,
        "depth": 9,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          107,
          0
        ],
        "end_point": [
          136,
          1
        ],
        "content": "mp_limb_t\nmpn_addmul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t shifted_vl, ul, rl, lpl, hpl, prev_hpl, xw, cl, xl;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT_MPN (rp, n);\n  ASSERT_MPN (up, n);\n  ASSERT_LIMB (vl);\n\n  shifted_vl = vl << GMP_NAIL_BITS;\n  cl = 0;\n  prev_hpl = 0;\n  do\n    {\n      ul = *up++;\n      rl = *rp;\n      umul_ppmm (hpl, lpl, ul, shifted_vl);\n      lpl >>= GMP_NAIL_BITS;\n      xw = prev_hpl + lpl + rl + cl;\n      cl = xw >> GMP_NUMB_BITS;\n      xl = xw & GMP_NUMB_MASK;\n      *rp++ = xl;\n      prev_hpl = hpl;\n    }\n  while (--n != 0);\n\n  return prev_hpl + cl;\n}",
        "lines": 30,
        "depth": 10,
        "decorators": [
          "mp_limb_t"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/add_1.c": {},
  "gmp/gmp-6.1.2/mpn/generic/add_err1_n.c": {
    "mpn_add_err1_n": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "mp_limb_t\nmpn_add_err1_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n\t\tmp_ptr ep, mp_srcptr yp,\n                mp_size_t n, mp_limb_t cy)\n{\n  mp_limb_t el, eh, ul, vl, yl, zl, rl, sl, cy1, cy2;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, vp, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 2, up, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 2, vp, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 2, yp, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 2, rp, n));\n\n  yp += n - 1;\n  el = eh = 0;\n\n  do\n    {\n      yl = *yp--;\n      ul = *up++;\n      vl = *vp++;\n\n      /* ordinary add_n */\n      ADDC_LIMB (cy1, sl, ul, vl);\n      ADDC_LIMB (cy2, rl, sl, cy);\n      cy = cy1 | cy2;\n      *rp++ = rl;\n\n      /* update (eh:el) */\n      zl = (-cy) & yl;\n      el += zl;\n      eh += el < zl;\n    }\n  while (--n);\n\n#if GMP_NAIL_BITS != 0\n  eh = (eh << GMP_NAIL_BITS) + (el >> GMP_NUMB_BITS);\n  el &= GMP_NUMB_MASK;\n#endif\n\n  ep[0] = el;\n  ep[1] = eh;\n\n  return cy;\n}",
      "lines": 48,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/add_err2_n.c": {
    "mpn_add_err2_n": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "mp_limb_t\nmpn_add_err2_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n                mp_ptr ep, mp_srcptr yp1, mp_srcptr yp2,\n                mp_size_t n, mp_limb_t cy)\n{\n  mp_limb_t el1, eh1, el2, eh2, ul, vl, yl1, yl2, zl1, zl2, rl, sl, cy1, cy2;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, vp, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp1, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp2, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 4, up, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 4, vp, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 4, yp1, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 4, yp2, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 4, rp, n));\n\n  yp1 += n - 1;\n  yp2 += n - 1;\n  el1 = eh1 = 0;\n  el2 = eh2 = 0;\n\n  do\n    {\n      yl1 = *yp1--;\n      yl2 = *yp2--;\n      ul = *up++;\n      vl = *vp++;\n\n      /* ordinary add_n */\n      ADDC_LIMB (cy1, sl, ul, vl);\n      ADDC_LIMB (cy2, rl, sl, cy);\n      cy = cy1 | cy2;\n      *rp++ = rl;\n\n      /* update (eh1:el1) */\n      zl1 = (-cy) & yl1;\n      el1 += zl1;\n      eh1 += el1 < zl1;\n\n      /* update (eh2:el2) */\n      zl2 = (-cy) & yl2;\n      el2 += zl2;\n      eh2 += el2 < zl2;\n    }\n  while (--n);\n\n#if GMP_NAIL_BITS != 0\n  eh1 = (eh1 << GMP_NAIL_BITS) + (el1 >> GMP_NUMB_BITS);\n  el1 &= GMP_NUMB_MASK;\n  eh2 = (eh2 << GMP_NAIL_BITS) + (el2 >> GMP_NUMB_BITS);\n  el2 &= GMP_NUMB_MASK;\n#endif\n\n  ep[0] = el1;\n  ep[1] = eh1;\n  ep[2] = el2;\n  ep[3] = eh2;\n\n  return cy;\n}",
      "lines": 62,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/add_err3_n.c": {
    "mpn_add_err3_n": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "mp_limb_t\nmpn_add_err3_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n                mp_ptr ep, mp_srcptr yp1, mp_srcptr yp2, mp_srcptr yp3,\n                mp_size_t n, mp_limb_t cy)\n{\n  mp_limb_t el1, eh1, el2, eh2, el3, eh3, ul, vl, yl1, yl2, yl3, zl1, zl2, zl3, rl, sl, cy1, cy2;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, vp, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp1, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp2, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp3, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, up, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, vp, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, yp1, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, yp2, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, yp3, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, rp, n));\n\n  yp1 += n - 1;\n  yp2 += n - 1;\n  yp3 += n - 1;\n  el1 = eh1 = 0;\n  el2 = eh2 = 0;\n  el3 = eh3 = 0;\n\n  do\n    {\n      yl1 = *yp1--;\n      yl2 = *yp2--;\n      yl3 = *yp3--;\n      ul = *up++;\n      vl = *vp++;\n\n      /* ordinary add_n */\n      ADDC_LIMB (cy1, sl, ul, vl);\n      ADDC_LIMB (cy2, rl, sl, cy);\n      cy = cy1 | cy2;\n      *rp++ = rl;\n\n      /* update (eh1:el1) */\n      zl1 = (-cy) & yl1;\n      el1 += zl1;\n      eh1 += el1 < zl1;\n\n      /* update (eh2:el2) */\n      zl2 = (-cy) & yl2;\n      el2 += zl2;\n      eh2 += el2 < zl2;\n\n      /* update (eh3:el3) */\n      zl3 = (-cy) & yl3;\n      el3 += zl3;\n      eh3 += el3 < zl3;\n    }\n  while (--n);\n\n#if GMP_NAIL_BITS != 0\n  eh1 = (eh1 << GMP_NAIL_BITS) + (el1 >> GMP_NUMB_BITS);\n  el1 &= GMP_NUMB_MASK;\n  eh2 = (eh2 << GMP_NAIL_BITS) + (el2 >> GMP_NUMB_BITS);\n  el2 &= GMP_NUMB_MASK;\n  eh3 = (eh3 << GMP_NAIL_BITS) + (el3 >> GMP_NUMB_BITS);\n  el3 &= GMP_NUMB_MASK;\n#endif\n\n  ep[0] = el1;\n  ep[1] = eh1;\n  ep[2] = el2;\n  ep[3] = eh2;\n  ep[4] = el3;\n  ep[5] = eh3;\n\n  return cy;\n}",
      "lines": 76,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/add_n.c": {
    "mpn_add_n": [
      {
        "start_point": [
          36,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "mp_limb_t\nmpn_add_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_limb_t ul, vl, sl, rl, cy, cy1, cy2;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_INCR_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_INCR_P (rp, vp, n));\n\n  cy = 0;\n  do\n    {\n      ul = *up++;\n      vl = *vp++;\n      sl = ul + vl;\n      cy1 = sl < ul;\n      rl = sl + cy;\n      cy2 = rl < sl;\n      cy = cy1 | cy2;\n      *rp++ = rl;\n    }\n  while (--n != 0);\n\n  return cy;\n}",
        "lines": 25,
        "depth": 9,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          66,
          0
        ],
        "end_point": [
          87,
          1
        ],
        "content": "mp_limb_t\nmpn_add_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_limb_t ul, vl, rl, cy;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_INCR_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_INCR_P (rp, vp, n));\n\n  cy = 0;\n  do\n    {\n      ul = *up++;\n      vl = *vp++;\n      rl = ul + vl + cy;\n      cy = rl >> GMP_NUMB_BITS;\n      *rp++ = rl & GMP_NUMB_MASK;\n    }\n  while (--n != 0);\n\n  return cy;\n}",
        "lines": 22,
        "depth": 9,
        "decorators": [
          "mp_limb_t"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/add_n_sub_n.c": {
    "mpn_add_n_sub_n": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "mp_limb_t\nmpn_add_n_sub_n (mp_ptr r1p, mp_ptr r2p, mp_srcptr s1p, mp_srcptr s2p, mp_size_t n)\n{\n  mp_limb_t acyn, acyo;\t\t/* carry for add */\n  mp_limb_t scyn, scyo;\t\t/* carry for subtract */\n  mp_size_t off;\t\t/* offset in operands */\n  mp_size_t this_n;\t\t/* size of current chunk */\n\n  /* We alternatingly add and subtract in chunks that fit into the (L1)\n     cache.  Since the chunks are several hundred limbs, the function call\n     overhead is insignificant, but we get much better locality.  */\n\n  /* We have three variant of the inner loop, the proper loop is chosen\n     depending on whether r1 or r2 are the same operand as s1 or s2.  */\n\n  if (r1p != s1p && r1p != s2p)\n    {\n      /* r1 is not identical to either input operand.  We can therefore write\n\t to r1 directly, without using temporary storage.  */\n      acyo = 0;\n      scyo = 0;\n      for (off = 0; off < n; off += PART_SIZE)\n\t{\n\t  this_n = MIN (n - off, PART_SIZE);\n#if HAVE_NATIVE_mpn_add_nc\n\t  acyo = mpn_add_nc (r1p + off, s1p + off, s2p + off, this_n, acyo);\n#else\n\t  acyn = mpn_add_n (r1p + off, s1p + off, s2p + off, this_n);\n\t  acyo = acyn + mpn_add_1 (r1p + off, r1p + off, this_n, acyo);\n#endif\n#if HAVE_NATIVE_mpn_sub_nc\n\t  scyo = mpn_sub_nc (r2p + off, s1p + off, s2p + off, this_n, scyo);\n#else\n\t  scyn = mpn_sub_n (r2p + off, s1p + off, s2p + off, this_n);\n\t  scyo = scyn + mpn_sub_1 (r2p + off, r2p + off, this_n, scyo);\n#endif\n\t}\n    }\n  else if (r2p != s1p && r2p != s2p)\n    {\n      /* r2 is not identical to either input operand.  We can therefore write\n\t to r2 directly, without using temporary storage.  */\n      acyo = 0;\n      scyo = 0;\n      for (off = 0; off < n; off += PART_SIZE)\n\t{\n\t  this_n = MIN (n - off, PART_SIZE);\n#if HAVE_NATIVE_mpn_sub_nc\n\t  scyo = mpn_sub_nc (r2p + off, s1p + off, s2p + off, this_n, scyo);\n#else\n\t  scyn = mpn_sub_n (r2p + off, s1p + off, s2p + off, this_n);\n\t  scyo = scyn + mpn_sub_1 (r2p + off, r2p + off, this_n, scyo);\n#endif\n#if HAVE_NATIVE_mpn_add_nc\n\t  acyo = mpn_add_nc (r1p + off, s1p + off, s2p + off, this_n, acyo);\n#else\n\t  acyn = mpn_add_n (r1p + off, s1p + off, s2p + off, this_n);\n\t  acyo = acyn + mpn_add_1 (r1p + off, r1p + off, this_n, acyo);\n#endif\n\t}\n    }\n  else\n    {\n      /* r1 and r2 are identical to s1 and s2 (r1==s1 and r2==s2 or vice versa)\n\t Need temporary storage.  */\n      mp_limb_t tp[PART_SIZE];\n      acyo = 0;\n      scyo = 0;\n      for (off = 0; off < n; off += PART_SIZE)\n\t{\n\t  this_n = MIN (n - off, PART_SIZE);\n#if HAVE_NATIVE_mpn_add_nc\n\t  acyo = mpn_add_nc (tp, s1p + off, s2p + off, this_n, acyo);\n#else\n\t  acyn = mpn_add_n (tp, s1p + off, s2p + off, this_n);\n\t  acyo = acyn + mpn_add_1 (tp, tp, this_n, acyo);\n#endif\n#if HAVE_NATIVE_mpn_sub_nc\n\t  scyo = mpn_sub_nc (r2p + off, s1p + off, s2p + off, this_n, scyo);\n#else\n\t  scyn = mpn_sub_n (r2p + off, s1p + off, s2p + off, this_n);\n\t  scyo = scyn + mpn_sub_1 (r2p + off, r2p + off, this_n, scyo);\n#endif\n\t  MPN_COPY (r1p + off, tp, this_n);\n\t}\n    }\n\n  return 2 * acyo + scyo;\n}",
      "lines": 89,
      "depth": 16,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "main": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr r1p, r2p, s1p, s2p;\n  double t;\n  mp_size_t n;\n\n  n = strtol (argv[1], 0, 0);\n\n  r1p = malloc (n * GMP_LIMB_BYTES);\n  r2p = malloc (n * GMP_LIMB_BYTES);\n  s1p = malloc (n * GMP_LIMB_BYTES);\n  s2p = malloc (n * GMP_LIMB_BYTES);\n  TIME (t,(mpn_add_n(r1p,s1p,s2p,n),mpn_sub_n(r1p,s1p,s2p,n)));\n  printf (\"              separate add and sub: %.3f\\n\", t);\n  TIME (t,mpn_add_n_sub_n(r1p,r2p,s1p,s2p,n));\n  printf (\"combined addsub separate variables: %.3f\\n\", t);\n  TIME (t,mpn_add_n_sub_n(r1p,r2p,r1p,s2p,n));\n  printf (\"        combined addsub r1 overlap: %.3f\\n\", t);\n  TIME (t,mpn_add_n_sub_n(r1p,r2p,r1p,s2p,n));\n  printf (\"        combined addsub r2 overlap: %.3f\\n\", t);\n  TIME (t,mpn_add_n_sub_n(r1p,r2p,r1p,r2p,n));\n  printf (\"          combined addsub in-place: %.3f\\n\", t);\n\n  return 0;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/bdiv_dbm1c.c": {
    "mpn_bdiv_dbm1c": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "mp_limb_t\nmpn_bdiv_dbm1c (mp_ptr qp, mp_srcptr ap, mp_size_t n, mp_limb_t bd, mp_limb_t h)\n{\n  mp_limb_t a, p0, p1, cy;\n  mp_size_t i;\n\n  for (i = 0; i < n; i++)\n    {\n      a = ap[i];\n      umul_ppmm (p1, p0, a, bd << GMP_NAIL_BITS);\n      p0 >>= GMP_NAIL_BITS;\n      cy = h < p0;\n      h = (h - p0) & GMP_NUMB_MASK;\n      qp[i] = h;\n      h = h - p1 - cy;\n    }\n\n  return h;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/bdiv_q.c": {
    "mpn_bdiv_q": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nmpn_bdiv_q (mp_ptr qp,\n\t    mp_srcptr np, mp_size_t nn,\n\t    mp_srcptr dp, mp_size_t dn,\n\t    mp_ptr tp)\n{\n  mp_limb_t di;\n\n  if (BELOW_THRESHOLD (dn, DC_BDIV_Q_THRESHOLD))\n    {\n      MPN_COPY (tp, np, nn);\n      binvert_limb (di, dp[0]);  di = -di;\n      mpn_sbpi1_bdiv_q (qp, tp, nn, dp, dn, di);\n    }\n  else if (BELOW_THRESHOLD (dn, MU_BDIV_Q_THRESHOLD))\n    {\n      MPN_COPY (tp, np, nn);\n      binvert_limb (di, dp[0]);  di = -di;\n      mpn_dcpi1_bdiv_q (qp, tp, nn, dp, dn, di);\n    }\n  else\n    {\n      mpn_mu_bdiv_q (qp, np, nn, dp, dn, tp);\n    }\n  return;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpn_bdiv_q_itch": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "mp_size_t\nmpn_bdiv_q_itch (mp_size_t nn, mp_size_t dn)\n{\n  if (BELOW_THRESHOLD (dn, MU_BDIV_Q_THRESHOLD))\n    return nn;\n  else\n    return mpn_mu_bdiv_q_itch (nn, dn);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/bdiv_qr.c": {
    "mpn_bdiv_qr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "mp_limb_t\nmpn_bdiv_qr (mp_ptr qp, mp_ptr rp,\n\t     mp_srcptr np, mp_size_t nn,\n\t     mp_srcptr dp, mp_size_t dn,\n\t     mp_ptr tp)\n{\n  mp_limb_t di;\n  mp_limb_t rh;\n\n  ASSERT (nn > dn);\n  if (BELOW_THRESHOLD (dn, DC_BDIV_QR_THRESHOLD) ||\n      BELOW_THRESHOLD (nn - dn, DC_BDIV_QR_THRESHOLD))\n    {\n      MPN_COPY (tp, np, nn);\n      binvert_limb (di, dp[0]);  di = -di;\n      rh = mpn_sbpi1_bdiv_qr (qp, tp, nn, dp, dn, di);\n      MPN_COPY (rp, tp + nn - dn, dn);\n    }\n  else if (BELOW_THRESHOLD (dn, MU_BDIV_QR_THRESHOLD))\n    {\n      MPN_COPY (tp, np, nn);\n      binvert_limb (di, dp[0]);  di = -di;\n      rh = mpn_dcpi1_bdiv_qr (qp, tp, nn, dp, dn, di);\n      MPN_COPY (rp, tp + nn - dn, dn);\n    }\n  else\n    {\n      rh = mpn_mu_bdiv_qr (qp, rp, np, nn, dp, dn, tp);\n    }\n\n  return rh;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_bdiv_qr_itch": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "mp_size_t\nmpn_bdiv_qr_itch (mp_size_t nn, mp_size_t dn)\n{\n  if (BELOW_THRESHOLD (dn, MU_BDIV_QR_THRESHOLD))\n    return nn;\n  else\n    return  mpn_mu_bdiv_qr_itch (nn, dn);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/bdiv_q_1.c": {
    "mpn_pi1_bdiv_q_1": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "mp_limb_t\nmpn_pi1_bdiv_q_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t d,\n\t\t  mp_limb_t di, int shift)\n{\n  mp_size_t  i;\n  mp_limb_t  c, h, l, u, u_next, dummy;\n\n  ASSERT (n >= 1);\n  ASSERT (d != 0);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT_MPN (up, n);\n  ASSERT_LIMB (d);\n\n  d <<= GMP_NAIL_BITS;\n\n  if (shift != 0)\n    {\n      c = 0;\n\n      u = up[0];\n      rp--;\n      for (i = 1; i < n; i++)\n\t{\n\t  u_next = up[i];\n\t  u = ((u >> shift) | (u_next << (GMP_NUMB_BITS-shift))) & GMP_NUMB_MASK;\n\n\t  SUBC_LIMB (c, l, u, c);\n\n\t  l = (l * di) & GMP_NUMB_MASK;\n\t  rp[i] = l;\n\n\t  umul_ppmm (h, dummy, l, d);\n\t  c += h;\n\t  u = u_next;\n\t}\n\n      u = u >> shift;\n      l = u - c;\n      l = (l * di) & GMP_NUMB_MASK;\n      rp[i] = l;\n    }\n  else\n    {\n      u = up[0];\n      l = (u * di) & GMP_NUMB_MASK;\n      rp[0] = l;\n      c = 0;\n\n      for (i = 1; i < n; i++)\n\t{\n\t  umul_ppmm (h, dummy, l, d);\n\t  c += h;\n\n\t  u = up[i];\n\t  SUBC_LIMB (c, l, u, c);\n\n\t  l = (l * di) & GMP_NUMB_MASK;\n\t  rp[i] = l;\n\t}\n    }\n\n  return c;\n}",
      "lines": 63,
      "depth": 16,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_bdiv_q_1": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "mp_limb_t\nmpn_bdiv_q_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t d)\n{\n  mp_limb_t di;\n  int shift;\n\n  ASSERT (n >= 1);\n  ASSERT (d != 0);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT_MPN (up, n);\n  ASSERT_LIMB (d);\n\n  if ((d & 1) == 0)\n    {\n      count_trailing_zeros (shift, d);\n      d >>= shift;\n    }\n  else\n    shift = 0;\n\n  binvert_limb (di, d);\n  return mpn_pi1_bdiv_q_1 (rp, up, n, d, di, shift);\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/binvert.c": {
    "mpn_binvert_itch": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "mp_size_t\nmpn_binvert_itch (mp_size_t n)\n{\n  mp_size_t itch_local = mpn_mulmod_bnm1_next_size (n);\n  mp_size_t itch_out = mpn_mulmod_bnm1_itch (itch_local, n, (n + 1) >> 1);\n  return itch_local + itch_out;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_binvert": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\nmpn_binvert (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_ptr scratch)\n{\n  mp_ptr xp;\n  mp_size_t rn, newrn;\n  mp_size_t sizes[NPOWS], *sizp;\n  mp_limb_t di;\n\n  /* Compute the computation precisions from highest to lowest, leaving the\n     base case size in 'rn'.  */\n  sizp = sizes;\n  for (rn = n; ABOVE_THRESHOLD (rn, BINV_NEWTON_THRESHOLD); rn = (rn + 1) >> 1)\n    *sizp++ = rn;\n\n  xp = scratch;\n\n  /* Compute a base value of rn limbs.  */\n  MPN_ZERO (xp, rn);\n  xp[0] = 1;\n  binvert_limb (di, up[0]);\n  if (BELOW_THRESHOLD (rn, DC_BDIV_Q_THRESHOLD))\n    mpn_sbpi1_bdiv_q (rp, xp, rn, up, rn, -di);\n  else\n    mpn_dcpi1_bdiv_q (rp, xp, rn, up, rn, -di);\n\n  /* Use Newton iterations to get the desired precision.  */\n  for (; rn < n; rn = newrn)\n    {\n      mp_size_t m;\n      newrn = *--sizp;\n\n      /* X <- UR. */\n      m = mpn_mulmod_bnm1_next_size (newrn);\n      mpn_mulmod_bnm1 (xp, m, up, newrn, rp, rn, xp + m);\n      mpn_sub_1 (xp + m, xp, rn - (m - newrn), 1);\n\n      /* R = R(X/B^rn) */\n      mpn_mullo_n (rp + rn, rp, xp + rn, newrn - rn);\n      mpn_neg (rp + rn, rp + rn, newrn - rn);\n    }\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/broot.c": {
    "powlimb": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static mp_limb_t\npowlimb (mp_limb_t a, mp_limb_t e)\n{\n  mp_limb_t r = 1;\n  mp_limb_t s = a;\n\n  for (r = 1, s = a; e > 0; e >>= 1, s *= s)\n    if (e & 1)\n      r *= s;\n\n  return r;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_broot_invm1": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "void\nmpn_broot_invm1 (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t k)\n{\n  mp_size_t sizes[GMP_LIMB_BITS * 2];\n  mp_ptr akm1, tp, rnp, ep;\n  mp_limb_t a0, r0, km1, kp1h, kinv;\n  mp_size_t rn;\n  unsigned i;\n\n  TMP_DECL;\n\n  ASSERT (n > 0);\n  ASSERT (ap[0] & 1);\n  ASSERT (k & 1);\n  ASSERT (k >= 3);\n\n  TMP_MARK;\n\n  akm1 = TMP_ALLOC_LIMBS (4*n);\n  tp = akm1 + n;\n\n  km1 = k-1;\n  /* FIXME: Could arrange the iteration so we don't need to compute\n     this up front, computing a^{k-1} * r^k as (a r)^{k-1} * r. Note\n     that we can use wraparound also for a*r, since the low half is\n     unchanged from the previous iteration. Or possibly mulmid. Also,\n     a r = a^{1/k}, so we get that value too, for free? */\n  mpn_powlo (akm1, ap, &km1, 1, n, tp); /* 3 n scratch space */\n\n  a0 = ap[0];\n  binvert_limb (kinv, k);\n\n  /* 4 bits: a^{1/k - 1} (mod 16):\n\n\ta % 8\n\t1 3 5 7\n   k%4 +-------\n     1 |1 1 1 1\n     3 |1 9 9 1\n  */\n  r0 = 1 + (((k << 2) & ((a0 << 1) ^ (a0 << 2))) & 8);\n  r0 = kinv * r0 * (k+1 - akm1[0] * powlimb (r0, k & 0x7f)); /* 8 bits */\n  r0 = kinv * r0 * (k+1 - akm1[0] * powlimb (r0, k & 0x7fff)); /* 16 bits */\n  r0 = kinv * r0 * (k+1 - akm1[0] * powlimb (r0, k)); /* 32 bits */\n#if GMP_NUMB_BITS > 32\n  {\n    unsigned prec = 32;\n    do\n      {\n\tr0 = kinv * r0 * (k+1 - akm1[0] * powlimb (r0, k));\n\tprec *= 2;\n      }\n    while (prec < GMP_NUMB_BITS);\n  }\n#endif\n\n  rp[0] = r0;\n  if (n == 1)\n    {\n      TMP_FREE;\n      return;\n    }\n\n  /* For odd k, (k+1)/2 = k/2+1, and the latter avoids overflow. */\n  kp1h = k/2 + 1;\n\n  /* FIXME: Special case for two limb iteration. */\n  rnp = TMP_ALLOC_LIMBS (2*n + 1);\n  ep = rnp + n;\n\n  /* FIXME: Possible to this on the fly with some bit fiddling. */\n  for (i = 0; n > 1; n = (n + 1)/2)\n    sizes[i++] = n;\n\n  rn = 1;\n\n  while (i-- > 0)\n    {\n      /* Compute x^{k+1}. */\n      mpn_sqr (ep, rp, rn); /* For odd n, writes n+1 limbs in the\n\t\t\t       final iteration. */\n      mpn_powlo (rnp, ep, &kp1h, 1, sizes[i], tp);\n\n      /* Multiply by a^{k-1}. Can use wraparound; low part equals r. */\n\n      mpn_mullo_n (ep, rnp, akm1, sizes[i]);\n      ASSERT (mpn_cmp (ep, rp, rn) == 0);\n\n      ASSERT (sizes[i] <= 2*rn);\n      mpn_pi1_bdiv_q_1 (rp + rn, ep + rn, sizes[i] - rn, k, kinv, 0);\n      mpn_neg (rp + rn, rp + rn, sizes[i] - rn);\n      rn = sizes[i];\n    }\n  TMP_FREE;\n}",
      "lines": 95,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "mpn_broot": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "void\nmpn_broot (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t k)\n{\n  mp_ptr tp;\n  TMP_DECL;\n\n  ASSERT (n > 0);\n  ASSERT (ap[0] & 1);\n  ASSERT (k & 1);\n\n  if (k == 1)\n    {\n      MPN_COPY (rp, ap, n);\n      return;\n    }\n\n  TMP_MARK;\n  tp = TMP_ALLOC_LIMBS (n);\n\n  mpn_broot_invm1 (tp, ap, n, k);\n  mpn_mullo_n (rp, tp, ap, n);\n\n  TMP_FREE;\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/brootinv.c": {
    "powlimb": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static mp_limb_t\npowlimb (mp_limb_t a, mp_limb_t e)\n{\n  mp_limb_t r;\n\n  for (r = 1; e > 0; e >>= 1, a *= a)\n    if (e & 1)\n      r *= a;\n\n  return r;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_brootinv": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "void\nmpn_brootinv (mp_ptr rp, mp_srcptr yp, mp_size_t bn, mp_limb_t k, mp_ptr tp)\n{\n  mp_ptr tp2, tp3;\n  mp_limb_t kinv, k2, r0, y0;\n  mp_size_t order[GMP_LIMB_BITS + 1];\n  int i, d;\n\n  ASSERT (bn > 0);\n  ASSERT ((k & 1) != 0);\n\n  tp2 = tp + bn;\n  tp3 = tp + 2 * bn;\n  k2 = k + 1;\n\n  binvert_limb (kinv, k);\n\n  /* 4-bit initial approximation:\n\n   y%16 | 1  3  5  7  9 11 13 15,\n    k%4 +-------------------------+k2%4\n     1  | 1 11 13  7  9  3  5 15  |  2\n     3  | 1  3  5  7  9 11 13 15  |  0\n\n  */\n  y0 = yp[0];\n\n  r0 = y0 ^ (((y0 << 1) ^ (y0 << 2)) & (k2 << 2) & 8);\t\t/* 4 bits */\n  r0 = kinv * (k2 * r0 - y0 * powlimb(r0, k2 & 0x7f));\t\t/* 8 bits */\n  r0 = kinv * (k2 * r0 - y0 * powlimb(r0, k2 & 0x7fff));\t/* 16 bits */\n#if GMP_NUMB_BITS > 16\n  {\n    unsigned prec = 16;\n    do\n      {\n\tr0 = kinv * (k2 * r0 - y0 * powlimb(r0, k2));\n\tprec *= 2;\n      }\n    while (prec < GMP_NUMB_BITS);\n  }\n#endif\n\n  rp[0] = r0;\n  if (bn == 1)\n    return;\n\n  /* This initialization doesn't matter for the result (any garbage is\n     cancelled in the iteration), but proper initialization makes\n     valgrind happier. */\n  MPN_ZERO (rp+1, bn-1);\n\n  d = 0;\n  for (; bn > 1; bn = (bn + 1) >> 1)\n    order[d++] = bn;\n\n  for (i = d - 1; i >= 0; i--)\n    {\n      bn = order[i];\n\n      mpn_mul_1 (tp, rp, bn, k2);\n\n      mpn_powlo (tp2, rp, &k2, 1, bn, tp3);\n      mpn_mullo_n (rp, yp, tp2, bn);\n\n      mpn_sub_n (tp2, tp, rp, bn);\n      mpn_pi1_bdiv_q_1 (rp, tp2, bn, k, kinv, 0);\n    }\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/bsqrt.c": {
    "mpn_bsqrt": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\nmpn_bsqrt (mp_ptr rp, mp_srcptr ap, mp_bitcnt_t nb, mp_ptr tp)\n{\n  mp_ptr sp;\n  mp_size_t n;\n\n  ASSERT (nb > 0);\n\n  n = nb / GMP_NUMB_BITS;\n  sp = tp + n;\n\n  mpn_bsqrtinv (tp, ap, nb, sp);\n  mpn_mullo_n (rp, tp, ap, n);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/bsqrtinv.c": {
    "mpn_bsqrtinv": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nmpn_bsqrtinv (mp_ptr rp, mp_srcptr yp, mp_bitcnt_t bnb, mp_ptr tp)\n{\n  mp_ptr tp2;\n  mp_size_t bn, order[GMP_LIMB_BITS + 1];\n  int i, d;\n\n  ASSERT (bnb > 0);\n\n  bn = 1 + bnb / GMP_LIMB_BITS;\n\n  tp2 = tp + bn;\n\n  rp[0] = 1;\n  if (bnb == 1)\n    {\n      if ((yp[0] & 3) != 1)\n\treturn 0;\n    }\n  else\n    {\n      if ((yp[0] & 7) != 1)\n\treturn 0;\n\n      d = 0;\n      for (; bnb != 2; bnb = (bnb + 2) >> 1)\n\torder[d++] = bnb;\n\n      for (i = d - 1; i >= 0; i--)\n\t{\n\t  bnb = order[i];\n\t  bn = 1 + bnb / GMP_LIMB_BITS;\n\n\t  mpn_sqrlo (tp, rp, bn);\n\t  mpn_mullo_n (tp2, rp, tp, bn); /* tp2 <- rp ^ 3 */\n\n\t  mpn_mul_1 (tp, rp, bn, 3);\n\n\t  mpn_mullo_n (rp, yp, tp2, bn);\n\n#if HAVE_NATIVE_mpn_rsh1sub_n\n\t  mpn_rsh1sub_n (rp, tp, rp, bn);\n#else\n\t  mpn_sub_n (tp2, tp, rp, bn);\n\t  mpn_rshift (rp, tp2, bn, 1);\n#endif\n\t}\n    }\n  return 1;\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/cmp.c": {},
  "gmp/gmp-6.1.2/mpn/generic/cnd_add_n.c": {
    "mpn_cnd_add_n": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "mp_limb_t\nmpn_cnd_add_n (mp_limb_t cnd, mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_limb_t ul, vl, sl, rl, cy, cy1, cy2, mask;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, vp, n));\n\n  mask = -(mp_limb_t) (cnd != 0);\n  cy = 0;\n  do\n    {\n      ul = *up++;\n      vl = *vp++ & mask;\n#if GMP_NAIL_BITS == 0\n      sl = ul + vl;\n      cy1 = sl < ul;\n      rl = sl + cy;\n      cy2 = rl < sl;\n      cy = cy1 | cy2;\n      *rp++ = rl;\n#else\n      rl = ul + vl;\n      rl += cy;\n      cy = rl >> GMP_NUMB_BITS;\n      *rp++ = rl & GMP_NUMB_MASK;\n#endif\n    }\n  while (--n != 0);\n\n  return cy;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/cnd_sub_n.c": {
    "mpn_cnd_sub_n": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "mp_limb_t\nmpn_cnd_sub_n (mp_limb_t cnd, mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_limb_t ul, vl, sl, rl, cy, cy1, cy2, mask;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, vp, n));\n\n  mask = -(mp_limb_t) (cnd != 0);\n  cy = 0;\n  do\n    {\n      ul = *up++;\n      vl = *vp++ & mask;\n#if GMP_NAIL_BITS == 0\n      sl = ul - vl;\n      cy1 = sl > ul;\n      rl = sl - cy;\n      cy2 = rl > sl;\n      cy = cy1 | cy2;\n      *rp++ = rl;\n#else\n      rl = ul - vl;\n      rl -= cy;\n      cy = rl >> (GMP_LIMB_BITS - 1);\n      *rp++ = rl & GMP_NUMB_MASK;\n#endif\n    }\n  while (--n != 0);\n\n  return cy;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/cnd_swap.c": {
    "mpn_cnd_swap": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\nmpn_cnd_swap (mp_limb_t cnd, volatile mp_limb_t *ap, volatile mp_limb_t *bp,\n\t      mp_size_t n)\n{\n  volatile mp_limb_t mask = - (mp_limb_t) (cnd != 0);\n  mp_size_t i;\n  for (i = 0; i < n; i++)\n    {\n      mp_limb_t a, b, t;\n      a = ap[i];\n      b = bp[i];\n      t = (a ^ b) & mask;\n      ap[i] = a ^ t;\n      bp[i] = b ^ t;\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/com.c": {
    "mpn_com": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nmpn_com (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  mp_limb_t ul;\n  do {\n      ul = *up++;\n      *rp++ = ~ul & GMP_NUMB_MASK;\n  } while (--n != 0);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/comb_tables.c": {},
  "gmp/gmp-6.1.2/mpn/generic/copyd.c": {
    "mpn_copyd": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nmpn_copyd (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  mp_size_t i;\n\n  for (i = n - 1; i >= 0; i--)\n    rp[i] = up[i];\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/copyi.c": {
    "mpn_copyi": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\nmpn_copyi (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  mp_size_t i;\n\n  up += n;\n  rp += n;\n  for (i = -n; i != 0; i++)\n    rp[i] = up[i];\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/dcpi1_bdiv_q.c": {
    "mpn_dcpi1_bdiv_q_n_itch": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "mp_size_t\nmpn_dcpi1_bdiv_q_n_itch (mp_size_t n)\n{\n  /* NOTE: Depends on mullo_n interface */\n  return n;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_dcpi1_bdiv_q_n": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "void\nmpn_dcpi1_bdiv_q_n (mp_ptr qp,\n\t\t    mp_ptr np, mp_srcptr dp, mp_size_t n,\n\t\t    mp_limb_t dinv, mp_ptr tp)\n{\n  while (ABOVE_THRESHOLD (n, DC_BDIV_Q_THRESHOLD))\n    {\n      mp_size_t lo, hi;\n      mp_limb_t cy;\n\n      lo = n >> 1;\t\t\t/* floor(n/2) */\n      hi = n - lo;\t\t\t/* ceil(n/2) */\n\n      cy = mpn_dcpi1_bdiv_qr_n (qp, np, dp, lo, dinv, tp);\n\n      mpn_mullo_n (tp, qp, dp + hi, lo);\n      mpn_sub_n (np + hi, np + hi, tp, lo);\n\n      if (lo < hi)\n\t{\n\t  cy += mpn_submul_1 (np + lo, qp, lo, dp[lo]);\n\t  np[n - 1] -= cy;\n\t}\n      qp += lo;\n      np += lo;\n      n -= lo;\n    }\n  mpn_sbpi1_bdiv_q (qp, np, n, dp, n, dinv);\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpn_dcpi1_bdiv_q": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void\nmpn_dcpi1_bdiv_q (mp_ptr qp,\n\t\t  mp_ptr np, mp_size_t nn,\n\t\t  mp_srcptr dp, mp_size_t dn,\n\t\t  mp_limb_t dinv)\n{\n  mp_size_t qn;\n  mp_limb_t cy;\n  mp_ptr tp;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  ASSERT (dn >= 2);\n  ASSERT (nn - dn >= 0);\n  ASSERT (dp[0] & 1);\n\n  tp = TMP_SALLOC_LIMBS (dn);\n\n  qn = nn;\n\n  if (qn > dn)\n    {\n      /* Reduce qn mod dn in a super-efficient manner.  */\n      do\n\tqn -= dn;\n      while (qn > dn);\n\n      /* Perform the typically smaller block first.  */\n      if (BELOW_THRESHOLD (qn, DC_BDIV_QR_THRESHOLD))\n\tcy = mpn_sbpi1_bdiv_qr (qp, np, 2 * qn, dp, qn, dinv);\n      else\n\tcy = mpn_dcpi1_bdiv_qr_n (qp, np, dp, qn, dinv, tp);\n\n      if (qn != dn)\n\t{\n\t  if (qn > dn - qn)\n\t    mpn_mul (tp, qp, qn, dp + qn, dn - qn);\n\t  else\n\t    mpn_mul (tp, dp + qn, dn - qn, qp, qn);\n\t  mpn_incr_u (tp + qn, cy);\n\n\t  mpn_sub (np + qn, np + qn, nn - qn, tp, dn);\n\t  cy = 0;\n\t}\n\n      np += qn;\n      qp += qn;\n\n      qn = nn - qn;\n      while (qn > dn)\n\t{\n\t  mpn_sub_1 (np + dn, np + dn, qn - dn, cy);\n\t  cy = mpn_dcpi1_bdiv_qr_n (qp, np, dp, dn, dinv, tp);\n\t  qp += dn;\n\t  np += dn;\n\t  qn -= dn;\n\t}\n      mpn_dcpi1_bdiv_q_n (qp, np, dp, dn, dinv, tp);\n    }\n  else\n    {\n      if (BELOW_THRESHOLD (qn, DC_BDIV_Q_THRESHOLD))\n\tmpn_sbpi1_bdiv_q (qp, np, qn, dp, qn, dinv);\n      else\n\tmpn_dcpi1_bdiv_q_n (qp, np, dp, qn, dinv, tp);\n    }\n\n  TMP_FREE;\n}",
      "lines": 70,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/dcpi1_bdiv_qr.c": {
    "mpn_dcpi1_bdiv_qr_n_itch": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "mp_size_t\nmpn_dcpi1_bdiv_qr_n_itch (mp_size_t n)\n{\n  return n;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_dcpi1_bdiv_qr_n": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "mp_limb_t\nmpn_dcpi1_bdiv_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n,\n\t\t     mp_limb_t dinv, mp_ptr tp)\n{\n  mp_size_t lo, hi;\n  mp_limb_t cy;\n  mp_limb_t rh;\n\n  lo = n >> 1;\t\t\t/* floor(n/2) */\n  hi = n - lo;\t\t\t/* ceil(n/2) */\n\n  if (BELOW_THRESHOLD (lo, DC_BDIV_QR_THRESHOLD))\n    cy = mpn_sbpi1_bdiv_qr (qp, np, 2 * lo, dp, lo, dinv);\n  else\n    cy = mpn_dcpi1_bdiv_qr_n (qp, np, dp, lo, dinv, tp);\n\n  mpn_mul (tp, dp + lo, hi, qp, lo);\n\n  mpn_incr_u (tp + lo, cy);\n  rh = mpn_sub (np + lo, np + lo, n + hi, tp, n);\n\n  if (BELOW_THRESHOLD (hi, DC_BDIV_QR_THRESHOLD))\n    cy = mpn_sbpi1_bdiv_qr (qp + lo, np + lo, 2 * hi, dp, hi, dinv);\n  else\n    cy = mpn_dcpi1_bdiv_qr_n (qp + lo, np + lo, dp, hi, dinv, tp);\n\n  mpn_mul (tp, qp + lo, hi, dp + hi, lo);\n\n  mpn_incr_u (tp + hi, cy);\n  rh += mpn_sub_n (np + n, np + n, tp, n);\n\n  return rh;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_dcpi1_bdiv_qr": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "mp_limb_t\nmpn_dcpi1_bdiv_qr (mp_ptr qp, mp_ptr np, mp_size_t nn,\n\t\t   mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)\n{\n  mp_size_t qn;\n  mp_limb_t rr, cy;\n  mp_ptr tp;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  ASSERT (dn >= 2);\t\t/* to adhere to mpn_sbpi1_div_qr's limits */\n  ASSERT (nn - dn >= 1);\t/* to adhere to mpn_sbpi1_div_qr's limits */\n  ASSERT (dp[0] & 1);\n\n  tp = TMP_SALLOC_LIMBS (dn);\n\n  qn = nn - dn;\n\n  if (qn > dn)\n    {\n      /* Reduce qn mod dn without division, optimizing small operations.  */\n      do\n\tqn -= dn;\n      while (qn > dn);\n\n      /* Perform the typically smaller block first.  */\n      if (BELOW_THRESHOLD (qn, DC_BDIV_QR_THRESHOLD))\n\tcy = mpn_sbpi1_bdiv_qr (qp, np, 2 * qn, dp, qn, dinv);\n      else\n\tcy = mpn_dcpi1_bdiv_qr_n (qp, np, dp, qn, dinv, tp);\n\n      rr = 0;\n      if (qn != dn)\n\t{\n\t  if (qn > dn - qn)\n\t    mpn_mul (tp, qp, qn, dp + qn, dn - qn);\n\t  else\n\t    mpn_mul (tp, dp + qn, dn - qn, qp, qn);\n\t  mpn_incr_u (tp + qn, cy);\n\n\t  rr = mpn_sub (np + qn, np + qn, nn - qn, tp, dn);\n\t  cy = 0;\n\t}\n\n      np += qn;\n      qp += qn;\n\n      qn = nn - dn - qn;\n      do\n\t{\n\t  rr += mpn_sub_1 (np + dn, np + dn, qn, cy);\n\t  cy = mpn_dcpi1_bdiv_qr_n (qp, np, dp, dn, dinv, tp);\n\t  qp += dn;\n\t  np += dn;\n\t  qn -= dn;\n\t}\n      while (qn > 0);\n      TMP_FREE;\n      return rr + cy;\n    }\n\n  if (BELOW_THRESHOLD (qn, DC_BDIV_QR_THRESHOLD))\n    cy = mpn_sbpi1_bdiv_qr (qp, np, 2 * qn, dp, qn, dinv);\n  else\n    cy = mpn_dcpi1_bdiv_qr_n (qp, np, dp, qn, dinv, tp);\n\n  rr = 0;\n  if (qn != dn)\n    {\n      if (qn > dn - qn)\n\tmpn_mul (tp, qp, qn, dp + qn, dn - qn);\n      else\n\tmpn_mul (tp, dp + qn, dn - qn, qp, qn);\n      mpn_incr_u (tp + qn, cy);\n\n      rr = mpn_sub (np + qn, np + qn, nn - qn, tp, dn);\n      cy = 0;\n    }\n\n  TMP_FREE;\n  return rr + cy;\n}",
      "lines": 83,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/dcpi1_divappr_q.c": {
    "mpn_dcpi1_divappr_q_n": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "mp_limb_t\nmpn_dcpi1_divappr_q_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n,\n\t\t       gmp_pi1_t *dinv, mp_ptr tp)\n{\n  mp_size_t lo, hi;\n  mp_limb_t cy, qh, ql;\n\n  lo = n >> 1;\t\t\t/* floor(n/2) */\n  hi = n - lo;\t\t\t/* ceil(n/2) */\n\n  if (BELOW_THRESHOLD (hi, DC_DIV_QR_THRESHOLD))\n    qh = mpn_sbpi1_div_qr (qp + lo, np + 2 * lo, 2 * hi, dp + lo, hi, dinv->inv32);\n  else\n    qh = mpn_dcpi1_div_qr_n (qp + lo, np + 2 * lo, dp + lo, hi, dinv, tp);\n\n  mpn_mul (tp, qp + lo, hi, dp, lo);\n\n  cy = mpn_sub_n (np + lo, np + lo, tp, n);\n  if (qh != 0)\n    cy += mpn_sub_n (np + n, np + n, dp, lo);\n\n  while (cy != 0)\n    {\n      qh -= mpn_sub_1 (qp + lo, qp + lo, hi, 1);\n      cy -= mpn_add_n (np + lo, np + lo, dp, n);\n    }\n\n  if (BELOW_THRESHOLD (lo, DC_DIVAPPR_Q_THRESHOLD))\n    ql = mpn_sbpi1_divappr_q (qp, np + hi, 2 * lo, dp + hi, lo, dinv->inv32);\n  else\n    ql = mpn_dcpi1_divappr_q_n (qp, np + hi, dp + hi, lo, dinv, tp);\n\n  if (UNLIKELY (ql != 0))\n    {\n      mp_size_t i;\n      for (i = 0; i < lo; i++)\n\tqp[i] = GMP_NUMB_MASK;\n    }\n\n  return qh;\n}",
      "lines": 41,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_dcpi1_divappr_q": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "mp_limb_t\nmpn_dcpi1_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn,\n\t\t     mp_srcptr dp, mp_size_t dn, gmp_pi1_t *dinv)\n{\n  mp_size_t qn;\n  mp_limb_t qh, cy, qsave;\n  mp_ptr tp;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  ASSERT (dn >= 6);\n  ASSERT (nn > dn);\n  ASSERT (dp[dn-1] & GMP_NUMB_HIGHBIT);\n\n  qn = nn - dn;\n  qp += qn;\n  np += nn;\n  dp += dn;\n\n  if (qn >= dn)\n    {\n      qn++;\t\t\t/* pretend we'll need an extra limb */\n      /* Reduce qn mod dn without division, optimizing small operations.  */\n      do\n\tqn -= dn;\n      while (qn > dn);\n\n      qp -= qn;\t\t\t/* point at low limb of next quotient block */\n      np -= qn;\t\t\t/* point in the middle of partial remainder */\n\n      tp = TMP_SALLOC_LIMBS (dn);\n\n      /* Perform the typically smaller block first.  */\n      if (qn == 1)\n\t{\n\t  mp_limb_t q, n2, n1, n0, d1, d0;\n\n\t  /* Handle qh up front, for simplicity. */\n\t  qh = mpn_cmp (np - dn + 1, dp - dn, dn) >= 0;\n\t  if (qh)\n\t    ASSERT_NOCARRY (mpn_sub_n (np - dn + 1, np - dn + 1, dp - dn, dn));\n\n\t  /* A single iteration of schoolbook: One 3/2 division,\n\t     followed by the bignum update and adjustment. */\n\t  n2 = np[0];\n\t  n1 = np[-1];\n\t  n0 = np[-2];\n\t  d1 = dp[-1];\n\t  d0 = dp[-2];\n\n\t  ASSERT (n2 < d1 || (n2 == d1 && n1 <= d0));\n\n\t  if (UNLIKELY (n2 == d1) && n1 == d0)\n\t    {\n\t      q = GMP_NUMB_MASK;\n\t      cy = mpn_submul_1 (np - dn, dp - dn, dn, q);\n\t      ASSERT (cy == n2);\n\t    }\n\t  else\n\t    {\n\t      udiv_qr_3by2 (q, n1, n0, n2, n1, n0, d1, d0, dinv->inv32);\n\n\t      if (dn > 2)\n\t\t{\n\t\t  mp_limb_t cy, cy1;\n\t\t  cy = mpn_submul_1 (np - dn, dp - dn, dn - 2, q);\n\n\t\t  cy1 = n0 < cy;\n\t\t  n0 = (n0 - cy) & GMP_NUMB_MASK;\n\t\t  cy = n1 < cy1;\n\t\t  n1 = (n1 - cy1) & GMP_NUMB_MASK;\n\t\t  np[-2] = n0;\n\n\t\t  if (UNLIKELY (cy != 0))\n\t\t    {\n\t\t      n1 += d1 + mpn_add_n (np - dn, np - dn, dp - dn, dn - 1);\n\t\t      qh -= (q == 0);\n\t\t      q = (q - 1) & GMP_NUMB_MASK;\n\t\t    }\n\t\t}\n\t      else\n\t\tnp[-2] = n0;\n\n\t      np[-1] = n1;\n\t    }\n\t  qp[0] = q;\n\t}\n      else\n\t{\n\t  if (qn == 2)\n\t    qh = mpn_divrem_2 (qp, 0L, np - 2, 4, dp - 2);\n\t  else if (BELOW_THRESHOLD (qn, DC_DIV_QR_THRESHOLD))\n\t    qh = mpn_sbpi1_div_qr (qp, np - qn, 2 * qn, dp - qn, qn, dinv->inv32);\n\t  else\n\t    qh = mpn_dcpi1_div_qr_n (qp, np - qn, dp - qn, qn, dinv, tp);\n\n\t  if (qn != dn)\n\t    {\n\t      if (qn > dn - qn)\n\t\tmpn_mul (tp, qp, qn, dp - dn, dn - qn);\n\t      else\n\t\tmpn_mul (tp, dp - dn, dn - qn, qp, qn);\n\n\t      cy = mpn_sub_n (np - dn, np - dn, tp, dn);\n\t      if (qh != 0)\n\t\tcy += mpn_sub_n (np - dn + qn, np - dn + qn, dp - dn, dn - qn);\n\n\t      while (cy != 0)\n\t\t{\n\t\t  qh -= mpn_sub_1 (qp, qp, qn, 1);\n\t\t  cy -= mpn_add_n (np - dn, np - dn, dp - dn, dn);\n\t\t}\n\t    }\n\t}\n      qn = nn - dn - qn + 1;\n      while (qn > dn)\n\t{\n\t  qp -= dn;\n\t  np -= dn;\n\t  mpn_dcpi1_div_qr_n (qp, np - dn, dp - dn, dn, dinv, tp);\n\t  qn -= dn;\n\t}\n\n      /* Since we pretended we'd need an extra quotient limb before, we now\n\t have made sure the code above left just dn-1=qn quotient limbs to\n\t develop.  Develop that plus a guard limb. */\n      qn--;\n      qp -= qn;\n      np -= dn;\n      qsave = qp[qn];\n      mpn_dcpi1_divappr_q_n (qp, np - dn, dp - dn, dn, dinv, tp);\n      MPN_COPY_INCR (qp, qp + 1, qn);\n      qp[qn] = qsave;\n    }\n  else    /* (qn < dn) */\n    {\n      mp_ptr q2p;\n#if 0\t\t\t\t/* not possible since we demand nn > dn */\n      if (qn == 0)\n\t{\n\t  qh = mpn_cmp (np - dn, dp - dn, dn) >= 0;\n\t  if (qh)\n\t    mpn_sub_n (np - dn, np - dn, dp - dn, dn);\n\t  TMP_FREE;\n\t  return qh;\n\t}\n#endif\n\n      qp -= qn;\t\t\t/* point at low limb of next quotient block */\n      np -= qn;\t\t\t/* point in the middle of partial remainder */\n\n      q2p = TMP_SALLOC_LIMBS (qn + 1);\n      /* Should we at all check DC_DIVAPPR_Q_THRESHOLD here, or reply on\n\t callers not to be silly?  */\n      if (BELOW_THRESHOLD (qn, DC_DIVAPPR_Q_THRESHOLD))\n\t{\n\t  qh = mpn_sbpi1_divappr_q (q2p, np - qn - 2, 2 * (qn + 1),\n\t\t\t\t    dp - (qn + 1), qn + 1, dinv->inv32);\n\t}\n      else\n\t{\n\t  /* It is tempting to use qp for recursive scratch and put quotient in\n\t     tp, but the recursive scratch needs one limb too many.  */\n\t  tp = TMP_SALLOC_LIMBS (qn + 1);\n\t  qh = mpn_dcpi1_divappr_q_n (q2p, np - qn - 2, dp - (qn + 1), qn + 1, dinv, tp);\n\t}\n      MPN_COPY (qp, q2p + 1, qn);\n    }\n\n  TMP_FREE;\n  return qh;\n}",
      "lines": 173,
      "depth": 19,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/dcpi1_div_q.c": {
    "mpn_dcpi1_div_q": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "mp_limb_t\nmpn_dcpi1_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn,\n\t\t mp_srcptr dp, mp_size_t dn, gmp_pi1_t *dinv)\n{\n  mp_ptr tp, wp;\n  mp_limb_t qh;\n  mp_size_t qn;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  ASSERT (dn >= 6);\n  ASSERT (nn - dn >= 3);\n  ASSERT (dp[dn-1] & GMP_NUMB_HIGHBIT);\n\n  tp = TMP_ALLOC_LIMBS (nn + 1);\n  MPN_COPY (tp + 1, np, nn);\n  tp[0] = 0;\n\n  qn = nn - dn;\n  wp = TMP_ALLOC_LIMBS (qn + 1);\n\n  qh = mpn_dcpi1_divappr_q (wp, tp, nn + 1, dp, dn, dinv);\n\n  if (wp[0] == 0)\n    {\n      mp_limb_t cy;\n\n      if (qn > dn)\n\tmpn_mul (tp, wp + 1, qn, dp, dn);\n      else\n\tmpn_mul (tp, dp, dn, wp + 1, qn);\n\n      cy = (qh != 0) ? mpn_add_n (tp + qn, tp + qn, dp, dn) : 0;\n\n      if (cy || mpn_cmp (tp, np, nn) > 0) /* At most is wrong by one, no cycle. */\n\tqh -= mpn_sub_1 (qp, wp + 1, qn, 1);\n      else /* Same as below */\n\tMPN_COPY (qp, wp + 1, qn);\n    }\n  else\n    MPN_COPY (qp, wp + 1, qn);\n\n  TMP_FREE;\n  return qh;\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/dcpi1_div_qr.c": {
    "mpn_dcpi1_div_qr_n": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "mp_limb_t\nmpn_dcpi1_div_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n,\n\t\t    gmp_pi1_t *dinv, mp_ptr tp)\n{\n  mp_size_t lo, hi;\n  mp_limb_t cy, qh, ql;\n\n  lo = n >> 1;\t\t\t/* floor(n/2) */\n  hi = n - lo;\t\t\t/* ceil(n/2) */\n\n  if (BELOW_THRESHOLD (hi, DC_DIV_QR_THRESHOLD))\n    qh = mpn_sbpi1_div_qr (qp + lo, np + 2 * lo, 2 * hi, dp + lo, hi, dinv->inv32);\n  else\n    qh = mpn_dcpi1_div_qr_n (qp + lo, np + 2 * lo, dp + lo, hi, dinv, tp);\n\n  mpn_mul (tp, qp + lo, hi, dp, lo);\n\n  cy = mpn_sub_n (np + lo, np + lo, tp, n);\n  if (qh != 0)\n    cy += mpn_sub_n (np + n, np + n, dp, lo);\n\n  while (cy != 0)\n    {\n      qh -= mpn_sub_1 (qp + lo, qp + lo, hi, 1);\n      cy -= mpn_add_n (np + lo, np + lo, dp, n);\n    }\n\n  if (BELOW_THRESHOLD (lo, DC_DIV_QR_THRESHOLD))\n    ql = mpn_sbpi1_div_qr (qp, np + hi, 2 * lo, dp + hi, lo, dinv->inv32);\n  else\n    ql = mpn_dcpi1_div_qr_n (qp, np + hi, dp + hi, lo, dinv, tp);\n\n  mpn_mul (tp, dp, hi, qp, lo);\n\n  cy = mpn_sub_n (np, np, tp, n);\n  if (ql != 0)\n    cy += mpn_sub_n (np + lo, np + lo, dp, hi);\n\n  while (cy != 0)\n    {\n      mpn_sub_1 (qp, qp, lo, 1);\n      cy -= mpn_add_n (np, np, dp, n);\n    }\n\n  return qh;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_dcpi1_div_qr": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "mp_limb_t\nmpn_dcpi1_div_qr (mp_ptr qp,\n\t\t  mp_ptr np, mp_size_t nn,\n\t\t  mp_srcptr dp, mp_size_t dn,\n\t\t  gmp_pi1_t *dinv)\n{\n  mp_size_t qn;\n  mp_limb_t qh, cy;\n  mp_ptr tp;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  ASSERT (dn >= 6);\t\t/* to adhere to mpn_sbpi1_div_qr's limits */\n  ASSERT (nn - dn >= 3);\t/* to adhere to mpn_sbpi1_div_qr's limits */\n  ASSERT (dp[dn-1] & GMP_NUMB_HIGHBIT);\n\n  tp = TMP_ALLOC_LIMBS (dn);\n\n  qn = nn - dn;\n  qp += qn;\n  np += nn;\n  dp += dn;\n\n  if (qn > dn)\n    {\n      /* Reduce qn mod dn without division, optimizing small operations.  */\n      do\n\tqn -= dn;\n      while (qn > dn);\n\n      qp -= qn;\t\t\t/* point at low limb of next quotient block */\n      np -= qn;\t\t\t/* point in the middle of partial remainder */\n\n      /* Perform the typically smaller block first.  */\n      if (qn == 1)\n\t{\n\t  mp_limb_t q, n2, n1, n0, d1, d0;\n\n\t  /* Handle qh up front, for simplicity. */\n\t  qh = mpn_cmp (np - dn + 1, dp - dn, dn) >= 0;\n\t  if (qh)\n\t    ASSERT_NOCARRY (mpn_sub_n (np - dn + 1, np - dn + 1, dp - dn, dn));\n\n\t  /* A single iteration of schoolbook: One 3/2 division,\n\t     followed by the bignum update and adjustment. */\n\t  n2 = np[0];\n\t  n1 = np[-1];\n\t  n0 = np[-2];\n\t  d1 = dp[-1];\n\t  d0 = dp[-2];\n\n\t  ASSERT (n2 < d1 || (n2 == d1 && n1 <= d0));\n\n\t  if (UNLIKELY (n2 == d1) && n1 == d0)\n\t    {\n\t      q = GMP_NUMB_MASK;\n\t      cy = mpn_submul_1 (np - dn, dp - dn, dn, q);\n\t      ASSERT (cy == n2);\n\t    }\n\t  else\n\t    {\n\t      udiv_qr_3by2 (q, n1, n0, n2, n1, n0, d1, d0, dinv->inv32);\n\n\t      if (dn > 2)\n\t\t{\n\t\t  mp_limb_t cy, cy1;\n\t\t  cy = mpn_submul_1 (np - dn, dp - dn, dn - 2, q);\n\n\t\t  cy1 = n0 < cy;\n\t\t  n0 = (n0 - cy) & GMP_NUMB_MASK;\n\t\t  cy = n1 < cy1;\n\t\t  n1 = (n1 - cy1) & GMP_NUMB_MASK;\n\t\t  np[-2] = n0;\n\n\t\t  if (UNLIKELY (cy != 0))\n\t\t    {\n\t\t      n1 += d1 + mpn_add_n (np - dn, np - dn, dp - dn, dn - 1);\n\t\t      qh -= (q == 0);\n\t\t      q = (q - 1) & GMP_NUMB_MASK;\n\t\t    }\n\t\t}\n\t      else\n\t\tnp[-2] = n0;\n\n\t      np[-1] = n1;\n\t    }\n\t  qp[0] = q;\n\t}\n      else\n\t{\n\t  /* Do a 2qn / qn division */\n\t  if (qn == 2)\n\t    qh = mpn_divrem_2 (qp, 0L, np - 2, 4, dp - 2); /* FIXME: obsolete function. Use 5/3 division? */\n\t  else if (BELOW_THRESHOLD (qn, DC_DIV_QR_THRESHOLD))\n\t    qh = mpn_sbpi1_div_qr (qp, np - qn, 2 * qn, dp - qn, qn, dinv->inv32);\n\t  else\n\t    qh = mpn_dcpi1_div_qr_n (qp, np - qn, dp - qn, qn, dinv, tp);\n\n\t  if (qn != dn)\n\t    {\n\t      if (qn > dn - qn)\n\t\tmpn_mul (tp, qp, qn, dp - dn, dn - qn);\n\t      else\n\t\tmpn_mul (tp, dp - dn, dn - qn, qp, qn);\n\n\t      cy = mpn_sub_n (np - dn, np - dn, tp, dn);\n\t      if (qh != 0)\n\t\tcy += mpn_sub_n (np - dn + qn, np - dn + qn, dp - dn, dn - qn);\n\n\t      while (cy != 0)\n\t\t{\n\t\t  qh -= mpn_sub_1 (qp, qp, qn, 1);\n\t\t  cy -= mpn_add_n (np - dn, np - dn, dp - dn, dn);\n\t\t}\n\t    }\n\t}\n\n      qn = nn - dn - qn;\n      do\n\t{\n\t  qp -= dn;\n\t  np -= dn;\n\t  mpn_dcpi1_div_qr_n (qp, np - dn, dp - dn, dn, dinv, tp);\n\t  qn -= dn;\n\t}\n      while (qn > 0);\n    }\n  else\n    {\n      qp -= qn;\t\t\t/* point at low limb of next quotient block */\n      np -= qn;\t\t\t/* point in the middle of partial remainder */\n\n      if (BELOW_THRESHOLD (qn, DC_DIV_QR_THRESHOLD))\n\tqh = mpn_sbpi1_div_qr (qp, np - qn, 2 * qn, dp - qn, qn, dinv->inv32);\n      else\n\tqh = mpn_dcpi1_div_qr_n (qp, np - qn, dp - qn, qn, dinv, tp);\n\n      if (qn != dn)\n\t{\n\t  if (qn > dn - qn)\n\t    mpn_mul (tp, qp, qn, dp - dn, dn - qn);\n\t  else\n\t    mpn_mul (tp, dp - dn, dn - qn, qp, qn);\n\n\t  cy = mpn_sub_n (np - dn, np - dn, tp, dn);\n\t  if (qh != 0)\n\t    cy += mpn_sub_n (np - dn + qn, np - dn + qn, dp - dn, dn - qn);\n\n\t  while (cy != 0)\n\t    {\n\t      qh -= mpn_sub_1 (qp, qp, qn, 1);\n\t      cy -= mpn_add_n (np - dn, np - dn, dp - dn, dn);\n\t    }\n\t}\n    }\n\n  TMP_FREE;\n  return qh;\n}",
      "lines": 160,
      "depth": 19,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/diveby3.c": {
    "mpn_divexact_by3c": [
      {
        "start_point": [
          35,
          0
        ],
        "end_point": [
          45,
          1
        ],
        "content": "mp_limb_t\nmpn_divexact_by3c (mp_ptr rp, mp_srcptr up, mp_size_t un, mp_limb_t c)\n{\n  mp_limb_t r;\n  r = mpn_bdiv_dbm1c (rp, up, un, GMP_NUMB_MASK / 3, GMP_NUMB_MASK / 3 * c);\n\n  /* Possible bdiv_dbm1 return values are C * (GMP_NUMB_MASK / 3), 0 <= C < 3.\n     We want to return C.  We compute the remainder mod 4 and notice that the\n     inverse of (2^(2k)-1)/3 mod 4 is 1.  */\n  return r & 3;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          73,
          0
        ],
        "end_point": [
          99,
          1
        ],
        "content": "mp_limb_t\nmpn_divexact_by3c (mp_ptr restrict rp, mp_srcptr restrict up, mp_size_t un, mp_limb_t c)\n{\n  mp_limb_t  l, q, s;\n  mp_size_t  i;\n\n  ASSERT (un >= 1);\n  ASSERT (c == 0 || c == 1 || c == 2);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, un));\n\n  i = 0;\n  do\n    {\n      s = up[i];\n      SUBC_LIMB (c, l, s, c);\n\n      q = (l * MODLIMB_INVERSE_3) & GMP_NUMB_MASK;\n      rp[i] = q;\n\n      c += (q >= GMP_NUMB_CEIL_MAX_DIV3);\n      c += (q >= GMP_NUMB_CEIL_2MAX_DIV3);\n    }\n  while (++i < un);\n\n  ASSERT (c == 0 || c == 1 || c == 2);\n  return c;\n}",
        "lines": 27,
        "depth": 10,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          142,
          0
        ],
        "end_point": [
          171,
          1
        ],
        "content": "mp_limb_t\nmpn_divexact_by3c (mp_ptr restrict rp, mp_srcptr restrict up, mp_size_t un, mp_limb_t cy)\n{\n  mp_limb_t  s, sm, cl, q, qx, c2, c3;\n  mp_size_t  i;\n\n  ASSERT (un >= 1);\n  ASSERT (cy == 0 || cy == 1 || cy == 2);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, un));\n\n  cl = cy == 0 ? 0 : cy == 1 ? -MODLIMB_INVERSE_3 : -2*MODLIMB_INVERSE_3;\n\n  for (i = 0; i < un; i++)\n    {\n      s = up[i];\n      sm = (s * MODLIMB_INVERSE_3) & GMP_NUMB_MASK;\n\n      q = (cl + sm) & GMP_NUMB_MASK;\n      rp[i] = q;\n      qx = q + (s < cy);\n\n      c2 = qx >= GMP_NUMB_CEIL_MAX_DIV3;\n      c3 = qx >= GMP_NUMB_CEIL_2MAX_DIV3 ;\n\n      cy = c2 + c3;\n      cl = (-c2 & -MODLIMB_INVERSE_3) + (-c3 & -MODLIMB_INVERSE_3);\n    }\n\n  return cy;\n}",
        "lines": 30,
        "depth": 11,
        "decorators": [
          "mp_limb_t"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/divexact.c": {
    "mpn_divexact": [
      {
        "start_point": [
          44,
          0
        ],
        "end_point": [
          101,
          1
        ],
        "content": "void\nmpn_divexact (mp_ptr qp,\n\t      mp_srcptr np, mp_size_t nn,\n\t      mp_srcptr dp, mp_size_t dn)\n{\n  unsigned shift;\n  mp_size_t qn;\n  mp_ptr tp;\n  TMP_DECL;\n\n  ASSERT (dn > 0);\n  ASSERT (nn >= dn);\n  ASSERT (dp[dn-1] > 0);\n\n  while (dp[0] == 0)\n    {\n      ASSERT (np[0] == 0);\n      dp++;\n      np++;\n      dn--;\n      nn--;\n    }\n\n  if (dn == 1)\n    {\n      MPN_DIVREM_OR_DIVEXACT_1 (qp, np, nn, dp[0]);\n      return;\n    }\n\n  TMP_MARK;\n\n  qn = nn + 1 - dn;\n  count_trailing_zeros (shift, dp[0]);\n\n  if (shift > 0)\n    {\n      mp_ptr wp;\n      mp_size_t ss;\n      ss = (dn > qn) ? qn + 1 : dn;\n\n      tp = TMP_ALLOC_LIMBS (ss);\n      mpn_rshift (tp, dp, ss, shift);\n      dp = tp;\n\n      /* Since we have excluded dn == 1, we have nn > qn, and we need\n\t to shift one limb beyond qn. */\n      wp = TMP_ALLOC_LIMBS (qn + 1);\n      mpn_rshift (wp, np, qn + 1, shift);\n      np = wp;\n    }\n\n  if (dn > qn)\n    dn = qn;\n\n  tp = TMP_ALLOC_LIMBS (mpn_bdiv_q_itch (qn, dn));\n  mpn_bdiv_q (qp, np, qn, dp, dn, tp);\n  TMP_FREE;\n}",
        "lines": 58,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          130,
          0
        ],
        "end_point": [
          292,
          1
        ],
        "content": "void\nmpn_divexact (mp_ptr qp,\n\t      mp_srcptr np, mp_size_t nn,\n\t      mp_srcptr dp, mp_size_t dn,\n\t      mp_ptr scratch)\n{\n  mp_size_t qn;\n  mp_size_t nn0, qn0;\n  mp_size_t nn1, qn1;\n  mp_ptr tp;\n  mp_limb_t qml;\n  mp_limb_t qh;\n  int cnt;\n  mp_ptr xdp;\n  mp_limb_t di;\n  mp_limb_t cy;\n  gmp_pi1_t dinv;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  qn = nn - dn + 1;\n\n  /* For small divisors, and small quotients, don't use Jebelean's algorithm. */\n  if (dn < DIVEXACT_JEB_THRESHOLD || qn < DIVEXACT_JEB_THRESHOLD)\n    {\n      tp = scratch;\n      MPN_COPY (tp, np, qn);\n      binvert_limb (di, dp[0]);  di = -di;\n      dn = MIN (dn, qn);\n      mpn_sbpi1_bdiv_q (qp, tp, qn, dp, dn, di);\n      TMP_FREE;\n      return;\n    }\n\n  qn0 = ((nn - dn) >> 1) + 1;\t/* low quotient size */\n\n  /* If quotient is much larger than the divisor, the bidirectional algorithm\n     does not work as currently implemented.  Fall back to plain bdiv.  */\n  if (qn0 > dn)\n    {\n      if (BELOW_THRESHOLD (dn, DC_BDIV_Q_THRESHOLD))\n\t{\n\t  tp = scratch;\n\t  MPN_COPY (tp, np, qn);\n\t  binvert_limb (di, dp[0]);  di = -di;\n\t  dn = MIN (dn, qn);\n\t  mpn_sbpi1_bdiv_q (qp, tp, qn, dp, dn, di);\n\t}\n      else if (BELOW_THRESHOLD (dn, MU_BDIV_Q_THRESHOLD))\n\t{\n\t  tp = scratch;\n\t  MPN_COPY (tp, np, qn);\n\t  binvert_limb (di, dp[0]);  di = -di;\n\t  mpn_dcpi1_bdiv_q (qp, tp, qn, dp, dn, di);\n\t}\n      else\n\t{\n\t  mpn_mu_bdiv_q (qp, np, qn, dp, dn, scratch);\n\t}\n      TMP_FREE;\n      return;\n    }\n\n  nn0 = qn0 + qn0;\n\n  nn1 = nn0 - 1 + ((nn-dn) & 1);\n  qn1 = qn0;\n  if (LIKELY (qn0 != dn))\n    {\n      nn1 = nn1 + 1;\n      qn1 = qn1 + 1;\n      if (UNLIKELY (dp[dn - 1] == 1 && qn1 != dn))\n\t{\n\t  /* If the leading divisor limb == 1, i.e. has just one bit, we have\n\t     to include an extra limb in order to get the needed overlap.  */\n\t  /* FIXME: Now with the mu_divappr_q function, we should really need\n\t     more overlap. That indicates one of two things: (1) The test code\n\t     is not good. (2) We actually overlap too much by default.  */\n\t  nn1 = nn1 + 1;\n\t  qn1 = qn1 + 1;\n\t}\n    }\n\n  tp = TMP_ALLOC_LIMBS (nn1 + 1);\n\n  count_leading_zeros (cnt, dp[dn - 1]);\n\n  /* Normalize divisor, store into tmp area.  */\n  if (cnt != 0)\n    {\n      xdp = TMP_ALLOC_LIMBS (qn1);\n      mpn_lshift (xdp, dp + dn - qn1, qn1, cnt);\n    }\n  else\n    {\n      xdp = (mp_ptr) dp + dn - qn1;\n    }\n\n  /* Shift dividend according to the divisor normalization.  */\n  /* FIXME: We compute too much here for XX_divappr_q, but these functions'\n     interfaces want a pointer to the imaginative least significant limb, not\n     to the least significant *used* limb.  Of course, we could leave nn1-qn1\n     rubbish limbs in the low part, to save some time.  */\n  if (cnt != 0)\n    {\n      cy = mpn_lshift (tp, np + nn - nn1, nn1, cnt);\n      if (cy != 0)\n\t{\n\t  tp[nn1] = cy;\n\t  nn1++;\n\t}\n    }\n  else\n    {\n      /* FIXME: This copy is not needed for mpn_mu_divappr_q, except when the\n\t mpn_sub_n right before is executed.  */\n      MPN_COPY (tp, np + nn - nn1, nn1);\n    }\n\n  invert_pi1 (dinv, xdp[qn1 - 1], xdp[qn1 - 2]);\n  if (BELOW_THRESHOLD (qn1, DC_DIVAPPR_Q_THRESHOLD))\n    {\n      qp[qn0 - 1 + nn1 - qn1] = mpn_sbpi1_divappr_q (qp + qn0 - 1, tp, nn1, xdp, qn1, dinv.inv32);\n    }\n  else if (BELOW_THRESHOLD (qn1, MU_DIVAPPR_Q_THRESHOLD))\n    {\n      qp[qn0 - 1 + nn1 - qn1] = mpn_dcpi1_divappr_q (qp + qn0 - 1, tp, nn1, xdp, qn1, &dinv);\n    }\n  else\n    {\n      /* FIXME: mpn_mu_divappr_q doesn't handle qh != 0.  Work around it with a\n\t conditional subtraction here.  */\n      qh = mpn_cmp (tp + nn1 - qn1, xdp, qn1) >= 0;\n      if (qh)\n\tmpn_sub_n (tp + nn1 - qn1, tp + nn1 - qn1, xdp, qn1);\n      mpn_mu_divappr_q (qp + qn0 - 1, tp, nn1, xdp, qn1, scratch);\n      qp[qn0 - 1 + nn1 - qn1] = qh;\n    }\n  qml = qp[qn0 - 1];\n\n  binvert_limb (di, dp[0]);  di = -di;\n\n  if (BELOW_THRESHOLD (qn0, DC_BDIV_Q_THRESHOLD))\n    {\n      MPN_COPY (tp, np, qn0);\n      mpn_sbpi1_bdiv_q (qp, tp, qn0, dp, qn0, di);\n    }\n  else if (BELOW_THRESHOLD (qn0, MU_BDIV_Q_THRESHOLD))\n    {\n      MPN_COPY (tp, np, qn0);\n      mpn_dcpi1_bdiv_q (qp, tp, qn0, dp, qn0, di);\n    }\n  else\n    {\n      mpn_mu_bdiv_q (qp, np, qn0, dp, qn0, scratch);\n    }\n\n  if (qml < qp[qn0 - 1])\n    mpn_decr_u (qp + qn0, 1);\n\n  TMP_FREE;\n}",
        "lines": 163,
        "depth": 13,
        "decorators": [
          "void"
        ]
      }
    ],
    "mpn_divexact_itch": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "mp_size_t\nmpn_divexact_itch (mp_size_t nn, mp_size_t dn)\n{\n  return nn + dn;\t\t/* FIXME this is not right */\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/dive_1.c": {
    "mpn_divexact_1": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\nmpn_divexact_1 (mp_ptr dst, mp_srcptr src, mp_size_t size, mp_limb_t divisor)\n{\n  mp_size_t  i;\n  mp_limb_t  c, h, l, ls, s, s_next, inverse, dummy;\n  unsigned   shift;\n\n  ASSERT (size >= 1);\n  ASSERT (divisor != 0);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (dst, src, size));\n  ASSERT_MPN (src, size);\n  ASSERT_LIMB (divisor);\n\n  if ((divisor & 1) == 0)\n    {\n      count_trailing_zeros (shift, divisor);\n      divisor >>= shift;\n    }\n  else\n    shift = 0;\n\n  binvert_limb (inverse, divisor);\n  divisor <<= GMP_NAIL_BITS;\n\n  if (shift != 0)\n    {\n      c = 0;\n\n      s = src[0];\n\n      for (i = 1; i < size; i++)\n\t{\n\t  s_next = src[i];\n\t  ls = ((s >> shift) | (s_next << (GMP_NUMB_BITS-shift))) & GMP_NUMB_MASK;\n\t  s = s_next;\n\n\t  SUBC_LIMB (c, l, ls, c);\n\n\t  l = (l * inverse) & GMP_NUMB_MASK;\n\t  dst[i - 1] = l;\n\n\t  umul_ppmm (h, dummy, l, divisor);\n\t  c += h;\n\t}\n\n      ls = s >> shift;\n      l = ls - c;\n      l = (l * inverse) & GMP_NUMB_MASK;\n      dst[size - 1] = l;\n    }\n  else\n    {\n      s = src[0];\n\n      l = (s * inverse) & GMP_NUMB_MASK;\n      dst[0] = l;\n      c = 0;\n\n      for (i = 1; i < size; i++)\n\t{\n\t  umul_ppmm (h, dummy, l, divisor);\n\t  c += h;\n\n\t  s = src[i];\n\t  SUBC_LIMB (c, l, s, c);\n\n\t  l = (l * inverse) & GMP_NUMB_MASK;\n\t  dst[i] = l;\n\t}\n    }\n}",
      "lines": 71,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/divis.c": {
    "mpn_divisible_p": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "int\nmpn_divisible_p (mp_srcptr ap, mp_size_t an,\n\t\t mp_srcptr dp, mp_size_t dn)\n{\n  mp_limb_t  alow, dlow, dmask;\n  mp_ptr     qp, rp, tp;\n  mp_size_t  i;\n  mp_limb_t di;\n  unsigned  twos;\n  TMP_DECL;\n\n  ASSERT (an >= 0);\n  ASSERT (an == 0 || ap[an-1] != 0);\n  ASSERT (dn >= 1);\n  ASSERT (dp[dn-1] != 0);\n  ASSERT_MPN (ap, an);\n  ASSERT_MPN (dp, dn);\n\n  /* When a<d only a==0 is divisible.\n     Notice this test covers all cases of an==0. */\n  if (an < dn)\n    return (an == 0);\n\n  /* Strip low zero limbs from d, requiring a==0 on those. */\n  for (;;)\n    {\n      alow = *ap;\n      dlow = *dp;\n\n      if (dlow != 0)\n\tbreak;\n\n      if (alow != 0)\n\treturn 0;  /* a has fewer low zero limbs than d, so not divisible */\n\n      /* a!=0 and d!=0 so won't get to n==0 */\n      an--; ASSERT (an >= 1);\n      dn--; ASSERT (dn >= 1);\n      ap++;\n      dp++;\n    }\n\n  /* a must have at least as many low zero bits as d */\n  dmask = LOW_ZEROS_MASK (dlow);\n  if ((alow & dmask) != 0)\n    return 0;\n\n  if (dn == 1)\n    {\n      if (ABOVE_THRESHOLD (an, BMOD_1_TO_MOD_1_THRESHOLD))\n\treturn mpn_mod_1 (ap, an, dlow) == 0;\n\n      count_trailing_zeros (twos, dlow);\n      dlow >>= twos;\n      return mpn_modexact_1_odd (ap, an, dlow) == 0;\n    }\n\n  count_trailing_zeros (twos, dlow);\n  if (dn == 2)\n    {\n      mp_limb_t  dsecond = dp[1];\n      if (dsecond <= dmask)\n\t{\n\t  dlow = (dlow >> twos) | (dsecond << (GMP_NUMB_BITS-twos));\n\t  ASSERT_LIMB (dlow);\n\t  return MPN_MOD_OR_MODEXACT_1_ODD (ap, an, dlow) == 0;\n\t}\n    }\n\n  /* Should we compute Q = A * D^(-1) mod B^k,\n                       R = A - Q * D  mod B^k\n     here, for some small values of k?  Then check if R = 0 (mod B^k).  */\n\n  /* We could also compute A' = A mod T and D' = D mod P, for some\n     P = 3 * 5 * 7 * 11 ..., and then check if any prime factor from P\n     dividing D' also divides A'.  */\n\n  TMP_MARK;\n\n  TMP_ALLOC_LIMBS_2 (rp, an + 1,\n\t\t     qp, an - dn + 1); /* FIXME: Could we avoid this? */\n\n  if (twos != 0)\n    {\n      tp = TMP_ALLOC_LIMBS (dn);\n      ASSERT_NOCARRY (mpn_rshift (tp, dp, dn, twos));\n      dp = tp;\n\n      ASSERT_NOCARRY (mpn_rshift (rp, ap, an, twos));\n    }\n  else\n    {\n      MPN_COPY (rp, ap, an);\n    }\n  if (rp[an - 1] >= dp[dn - 1])\n    {\n      rp[an] = 0;\n      an++;\n    }\n  else if (an == dn)\n    {\n      TMP_FREE;\n      return 0;\n    }\n\n  ASSERT (an > dn);\t\t/* requirement of functions below */\n\n  if (BELOW_THRESHOLD (dn, DC_BDIV_QR_THRESHOLD) ||\n      BELOW_THRESHOLD (an - dn, DC_BDIV_QR_THRESHOLD))\n    {\n      binvert_limb (di, dp[0]);\n      mpn_sbpi1_bdiv_qr (qp, rp, an, dp, dn, -di);\n      rp += an - dn;\n    }\n  else if (BELOW_THRESHOLD (dn, MU_BDIV_QR_THRESHOLD))\n    {\n      binvert_limb (di, dp[0]);\n      mpn_dcpi1_bdiv_qr (qp, rp, an, dp, dn, -di);\n      rp += an - dn;\n    }\n  else\n    {\n      tp = TMP_ALLOC_LIMBS (mpn_mu_bdiv_qr_itch (an, dn));\n      mpn_mu_bdiv_qr (qp, rp, rp, an, dp, dn, tp);\n    }\n\n  /* test for {rp,dn} zero or non-zero */\n  i = 0;\n  do\n    {\n      if (rp[i] != 0)\n\t{\n\t  TMP_FREE;\n\t  return 0;\n\t}\n    }\n  while (++i < dn);\n\n  TMP_FREE;\n  return 1;\n}",
      "lines": 141,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/divrem.c": {
    "mpn_divrem": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "mp_limb_t\nmpn_divrem (mp_ptr qp, mp_size_t qxn,\n\t    mp_ptr np, mp_size_t nn,\n\t    mp_srcptr dp, mp_size_t dn)\n{\n  ASSERT (qxn >= 0);\n  ASSERT (nn >= dn);\n  ASSERT (dn >= 1);\n  ASSERT (dp[dn-1] & GMP_NUMB_HIGHBIT);\n  ASSERT (! MPN_OVERLAP_P (np, nn, dp, dn));\n  ASSERT (! MPN_OVERLAP_P (qp, nn-dn+qxn, np, nn) || qp==np+dn+qxn);\n  ASSERT (! MPN_OVERLAP_P (qp, nn-dn+qxn, dp, dn));\n  ASSERT_MPN (np, nn);\n  ASSERT_MPN (dp, dn);\n\n  if (dn == 1)\n    {\n      mp_limb_t ret;\n      mp_ptr q2p;\n      mp_size_t qn;\n      TMP_DECL;\n\n      TMP_MARK;\n      q2p = TMP_ALLOC_LIMBS (nn + qxn);\n\n      np[0] = mpn_divrem_1 (q2p, qxn, np, nn, dp[0]);\n      qn = nn + qxn - 1;\n      MPN_COPY (qp, q2p, qn);\n      ret = q2p[qn];\n\n      TMP_FREE;\n      return ret;\n    }\n  else if (dn == 2)\n    {\n      return mpn_divrem_2 (qp, qxn, np, nn, dp);\n    }\n  else\n    {\n      mp_ptr rp, q2p;\n      mp_limb_t qhl;\n      mp_size_t qn;\n      TMP_DECL;\n\n      TMP_MARK;\n      if (UNLIKELY (qxn != 0))\n\t{\n\t  mp_ptr n2p;\n\t  n2p = TMP_ALLOC_LIMBS (nn + qxn);\n\t  MPN_ZERO (n2p, qxn);\n\t  MPN_COPY (n2p + qxn, np, nn);\n\t  q2p = TMP_ALLOC_LIMBS (nn - dn + qxn + 1);\n\t  rp = TMP_ALLOC_LIMBS (dn);\n\t  mpn_tdiv_qr (q2p, rp, 0L, n2p, nn + qxn, dp, dn);\n\t  MPN_COPY (np, rp, dn);\n\t  qn = nn - dn + qxn;\n\t  MPN_COPY (qp, q2p, qn);\n\t  qhl = q2p[qn];\n\t}\n      else\n\t{\n\t  q2p = TMP_ALLOC_LIMBS (nn - dn + 1);\n\t  rp = TMP_ALLOC_LIMBS (dn);\n\t  mpn_tdiv_qr (q2p, rp, 0L, np, nn, dp, dn);\n\t  MPN_COPY (np, rp, dn);\t/* overwrite np area with remainder */\n\t  qn = nn - dn;\n\t  MPN_COPY (qp, q2p, qn);\n\t  qhl = q2p[qn];\n\t}\n      TMP_FREE;\n      return qhl;\n    }\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/divrem_1.c": {
    "mpn_divrem_1": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "mp_limb_t\nmpn_divrem_1 (mp_ptr qp, mp_size_t qxn,\n\t      mp_srcptr up, mp_size_t un, mp_limb_t d)\n{\n  mp_size_t  n;\n  mp_size_t  i;\n  mp_limb_t  n1, n0;\n  mp_limb_t  r = 0;\n\n  ASSERT (qxn >= 0);\n  ASSERT (un >= 0);\n  ASSERT (d != 0);\n  /* FIXME: What's the correct overlap rule when qxn!=0? */\n  ASSERT (MPN_SAME_OR_SEPARATE_P (qp+qxn, up, un));\n\n  n = un + qxn;\n  if (n == 0)\n    return 0;\n\n  d <<= GMP_NAIL_BITS;\n\n  qp += (n - 1);   /* Make qp point at most significant quotient limb */\n\n  if ((d & GMP_LIMB_HIGHBIT) != 0)\n    {\n      if (un != 0)\n\t{\n\t  /* High quotient limb is 0 or 1, skip a divide step. */\n\t  mp_limb_t q;\n\t  r = up[un - 1] << GMP_NAIL_BITS;\n\t  q = (r >= d);\n\t  *qp-- = q;\n\t  r -= (d & -q);\n\t  r >>= GMP_NAIL_BITS;\n\t  n--;\n\t  un--;\n\t}\n\n      if (BELOW_THRESHOLD (n, DIVREM_1_NORM_THRESHOLD))\n\t{\n\tplain:\n\t  for (i = un - 1; i >= 0; i--)\n\t    {\n\t      n0 = up[i] << GMP_NAIL_BITS;\n\t      udiv_qrnnd (*qp, r, r, n0, d);\n\t      r >>= GMP_NAIL_BITS;\n\t      qp--;\n\t    }\n\t  for (i = qxn - 1; i >= 0; i--)\n\t    {\n\t      udiv_qrnnd (*qp, r, r, CNST_LIMB(0), d);\n\t      r >>= GMP_NAIL_BITS;\n\t      qp--;\n\t    }\n\t  return r;\n\t}\n      else\n\t{\n\t  /* Multiply-by-inverse, divisor already normalized. */\n\t  mp_limb_t dinv;\n\t  invert_limb (dinv, d);\n\n\t  for (i = un - 1; i >= 0; i--)\n\t    {\n\t      n0 = up[i] << GMP_NAIL_BITS;\n\t      udiv_qrnnd_preinv (*qp, r, r, n0, d, dinv);\n\t      r >>= GMP_NAIL_BITS;\n\t      qp--;\n\t    }\n\t  for (i = qxn - 1; i >= 0; i--)\n\t    {\n\t      udiv_qrnnd_preinv (*qp, r, r, CNST_LIMB(0), d, dinv);\n\t      r >>= GMP_NAIL_BITS;\n\t      qp--;\n\t    }\n\t  return r;\n\t}\n    }\n  else\n    {\n      /* Most significant bit of divisor == 0.  */\n      int cnt;\n\n      /* Skip a division if high < divisor (high quotient 0).  Testing here\n\t before normalizing will still skip as often as possible.  */\n      if (un != 0)\n\t{\n\t  n1 = up[un - 1] << GMP_NAIL_BITS;\n\t  if (n1 < d)\n\t    {\n\t      r = n1 >> GMP_NAIL_BITS;\n\t      *qp-- = 0;\n\t      n--;\n\t      if (n == 0)\n\t\treturn r;\n\t      un--;\n\t    }\n\t}\n\n      if (! UDIV_NEEDS_NORMALIZATION\n\t  && BELOW_THRESHOLD (n, DIVREM_1_UNNORM_THRESHOLD))\n\tgoto plain;\n\n      count_leading_zeros (cnt, d);\n      d <<= cnt;\n      r <<= cnt;\n\n      if (UDIV_NEEDS_NORMALIZATION\n\t  && BELOW_THRESHOLD (n, DIVREM_1_UNNORM_THRESHOLD))\n\t{\n\t  mp_limb_t nshift;\n\t  if (un != 0)\n\t    {\n\t      n1 = up[un - 1] << GMP_NAIL_BITS;\n\t      r |= (n1 >> (GMP_LIMB_BITS - cnt));\n\t      for (i = un - 2; i >= 0; i--)\n\t\t{\n\t\t  n0 = up[i] << GMP_NAIL_BITS;\n\t\t  nshift = (n1 << cnt) | (n0 >> (GMP_NUMB_BITS - cnt));\n\t\t  udiv_qrnnd (*qp, r, r, nshift, d);\n\t\t  r >>= GMP_NAIL_BITS;\n\t\t  qp--;\n\t\t  n1 = n0;\n\t\t}\n\t      udiv_qrnnd (*qp, r, r, n1 << cnt, d);\n\t      r >>= GMP_NAIL_BITS;\n\t      qp--;\n\t    }\n\t  for (i = qxn - 1; i >= 0; i--)\n\t    {\n\t      udiv_qrnnd (*qp, r, r, CNST_LIMB(0), d);\n\t      r >>= GMP_NAIL_BITS;\n\t      qp--;\n\t    }\n\t  return r >> cnt;\n\t}\n      else\n\t{\n\t  mp_limb_t  dinv, nshift;\n\t  invert_limb (dinv, d);\n\t  if (un != 0)\n\t    {\n\t      n1 = up[un - 1] << GMP_NAIL_BITS;\n\t      r |= (n1 >> (GMP_LIMB_BITS - cnt));\n\t      for (i = un - 2; i >= 0; i--)\n\t\t{\n\t\t  n0 = up[i] << GMP_NAIL_BITS;\n\t\t  nshift = (n1 << cnt) | (n0 >> (GMP_NUMB_BITS - cnt));\n\t\t  udiv_qrnnd_preinv (*qp, r, r, nshift, d, dinv);\n\t\t  r >>= GMP_NAIL_BITS;\n\t\t  qp--;\n\t\t  n1 = n0;\n\t\t}\n\t      udiv_qrnnd_preinv (*qp, r, r, n1 << cnt, d, dinv);\n\t      r >>= GMP_NAIL_BITS;\n\t      qp--;\n\t    }\n\t  for (i = qxn - 1; i >= 0; i--)\n\t    {\n\t      udiv_qrnnd_preinv (*qp, r, r, CNST_LIMB(0), d, dinv);\n\t      r >>= GMP_NAIL_BITS;\n\t      qp--;\n\t    }\n\t  return r >> cnt;\n\t}\n    }\n}",
      "lines": 167,
      "depth": 18,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/divrem_2.c": {
    "mpn_divrem_2": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "mp_limb_t\nmpn_divrem_2 (mp_ptr qp, mp_size_t qxn,\n\t      mp_ptr np, mp_size_t nn,\n\t      mp_srcptr dp)\n{\n  mp_limb_t most_significant_q_limb;\n  mp_size_t i;\n  mp_limb_t r1, r0, d1, d0;\n  gmp_pi1_t di;\n\n  ASSERT (nn >= 2);\n  ASSERT (qxn >= 0);\n  ASSERT (dp[1] & GMP_NUMB_HIGHBIT);\n  ASSERT (! MPN_OVERLAP_P (qp, nn-2+qxn, np, nn) || qp >= np+2);\n  ASSERT_MPN (np, nn);\n  ASSERT_MPN (dp, 2);\n\n  np += nn - 2;\n  d1 = dp[1];\n  d0 = dp[0];\n  r1 = np[1];\n  r0 = np[0];\n\n  most_significant_q_limb = 0;\n  if (r1 >= d1 && (r1 > d1 || r0 >= d0))\n    {\n#if GMP_NAIL_BITS == 0\n      sub_ddmmss (r1, r0, r1, r0, d1, d0);\n#else\n      r0 = r0 - d0;\n      r1 = r1 - d1 - (r0 >> GMP_LIMB_BITS - 1);\n      r0 &= GMP_NUMB_MASK;\n#endif\n      most_significant_q_limb = 1;\n    }\n\n  invert_pi1 (di, d1, d0);\n\n  qp += qxn;\n\n  for (i = nn - 2 - 1; i >= 0; i--)\n    {\n      mp_limb_t n0, q;\n      n0 = np[-1];\n      udiv_qr_3by2 (q, r1, r0, r1, r0, n0, d1, d0, di.inv32);\n      np--;\n      qp[i] = q;\n    }\n\n  if (UNLIKELY (qxn != 0))\n    {\n      qp -= qxn;\n      for (i = qxn - 1; i >= 0; i--)\n\t{\n\t  mp_limb_t q;\n\t  udiv_qr_3by2 (q, r1, r0, r1, r0, CNST_LIMB(0), d1, d0, di.inv32);\n\t  qp[i] = q;\n\t}\n    }\n\n  np[1] = r1;\n  np[0] = r0;\n\n  return most_significant_q_limb;\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/div_q.c": {
    "mpn_div_q": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "void\nmpn_div_q (mp_ptr qp,\n\t   mp_srcptr np, mp_size_t nn,\n\t   mp_srcptr dp, mp_size_t dn, mp_ptr scratch)\n{\n  mp_ptr new_dp, new_np, tp, rp;\n  mp_limb_t cy, dh, qh;\n  mp_size_t new_nn, qn;\n  gmp_pi1_t dinv;\n  int cnt;\n  TMP_DECL;\n  TMP_MARK;\n\n  ASSERT (nn >= dn);\n  ASSERT (dn > 0);\n  ASSERT (dp[dn - 1] != 0);\n  ASSERT (! MPN_OVERLAP_P (qp, nn - dn + 1, np, nn));\n  ASSERT (! MPN_OVERLAP_P (qp, nn - dn + 1, dp, dn));\n  ASSERT (MPN_SAME_OR_SEPARATE_P (np, scratch, nn));\n\n  ASSERT_ALWAYS (FUDGE >= 2);\n\n  if (dn == 1)\n    {\n      mpn_divrem_1 (qp, 0L, np, nn, dp[dn - 1]);\n      return;\n    }\n\n  qn = nn - dn + 1;\t\t/* Quotient size, high limb might be zero */\n\n  if (qn + FUDGE >= dn)\n    {\n      /* |________________________|\n                          |_______|  */\n      new_np = scratch;\n\n      dh = dp[dn - 1];\n      if (LIKELY ((dh & GMP_NUMB_HIGHBIT) == 0))\n\t{\n\t  count_leading_zeros (cnt, dh);\n\n\t  cy = mpn_lshift (new_np, np, nn, cnt);\n\t  new_np[nn] = cy;\n\t  new_nn = nn + (cy != 0);\n\n\t  new_dp = TMP_ALLOC_LIMBS (dn);\n\t  mpn_lshift (new_dp, dp, dn, cnt);\n\n\t  if (dn == 2)\n\t    {\n\t      qh = mpn_divrem_2 (qp, 0L, new_np, new_nn, new_dp);\n\t    }\n\t  else if (BELOW_THRESHOLD (dn, DC_DIV_Q_THRESHOLD) ||\n\t\t   BELOW_THRESHOLD (new_nn - dn, DC_DIV_Q_THRESHOLD))\n\t    {\n\t      invert_pi1 (dinv, new_dp[dn - 1], new_dp[dn - 2]);\n\t      qh = mpn_sbpi1_div_q (qp, new_np, new_nn, new_dp, dn, dinv.inv32);\n\t    }\n\t  else if (BELOW_THRESHOLD (dn, MUPI_DIV_Q_THRESHOLD) ||   /* fast condition */\n\t\t   BELOW_THRESHOLD (nn, 2 * MU_DIV_Q_THRESHOLD) || /* fast condition */\n\t\t   (double) (2 * (MU_DIV_Q_THRESHOLD - MUPI_DIV_Q_THRESHOLD)) * dn /* slow... */\n\t\t   + (double) MUPI_DIV_Q_THRESHOLD * nn > (double) dn * nn)   /* ...condition */\n\t    {\n\t      invert_pi1 (dinv, new_dp[dn - 1], new_dp[dn - 2]);\n\t      qh = mpn_dcpi1_div_q (qp, new_np, new_nn, new_dp, dn, &dinv);\n\t    }\n\t  else\n\t    {\n\t      mp_size_t itch = mpn_mu_div_q_itch (new_nn, dn, 0);\n\t      mp_ptr scratch = TMP_ALLOC_LIMBS (itch);\n\t      qh = mpn_mu_div_q (qp, new_np, new_nn, new_dp, dn, scratch);\n\t    }\n\t  if (cy == 0)\n\t    qp[qn - 1] = qh;\n\t  else if (UNLIKELY (qh != 0))\n\t    {\n\t      /* This happens only when the quotient is close to B^n and\n\t\t mpn_*_divappr_q returned B^n.  */\n\t      mp_size_t i, n;\n\t      n = new_nn - dn;\n\t      for (i = 0; i < n; i++)\n\t\tqp[i] = GMP_NUMB_MAX;\n\t      qh = 0;\t\t/* currently ignored */\n\t    }\n\t}\n      else  /* divisor is already normalised */\n\t{\n\t  if (new_np != np)\n\t    MPN_COPY (new_np, np, nn);\n\n\t  if (dn == 2)\n\t    {\n\t      qh = mpn_divrem_2 (qp, 0L, new_np, nn, dp);\n\t    }\n\t  else if (BELOW_THRESHOLD (dn, DC_DIV_Q_THRESHOLD) ||\n\t\t   BELOW_THRESHOLD (nn - dn, DC_DIV_Q_THRESHOLD))\n\t    {\n\t      invert_pi1 (dinv, dh, dp[dn - 2]);\n\t      qh = mpn_sbpi1_div_q (qp, new_np, nn, dp, dn, dinv.inv32);\n\t    }\n\t  else if (BELOW_THRESHOLD (dn, MUPI_DIV_Q_THRESHOLD) ||   /* fast condition */\n\t\t   BELOW_THRESHOLD (nn, 2 * MU_DIV_Q_THRESHOLD) || /* fast condition */\n\t\t   (double) (2 * (MU_DIV_Q_THRESHOLD - MUPI_DIV_Q_THRESHOLD)) * dn /* slow... */\n\t\t   + (double) MUPI_DIV_Q_THRESHOLD * nn > (double) dn * nn)   /* ...condition */\n\t    {\n\t      invert_pi1 (dinv, dh, dp[dn - 2]);\n\t      qh = mpn_dcpi1_div_q (qp, new_np, nn, dp, dn, &dinv);\n\t    }\n\t  else\n\t    {\n\t      mp_size_t itch = mpn_mu_div_q_itch (nn, dn, 0);\n\t      mp_ptr scratch = TMP_ALLOC_LIMBS (itch);\n\t      qh = mpn_mu_div_q (qp, np, nn, dp, dn, scratch);\n\t    }\n\t  qp[nn - dn] = qh;\n\t}\n    }\n  else\n    {\n      /* |________________________|\n                |_________________|  */\n      tp = TMP_ALLOC_LIMBS (qn + 1);\n\n      new_np = scratch;\n      new_nn = 2 * qn + 1;\n      if (new_np == np)\n\t/* We need {np,nn} to remain untouched until the final adjustment, so\n\t   we need to allocate separate space for new_np.  */\n\tnew_np = TMP_ALLOC_LIMBS (new_nn + 1);\n\n\n      dh = dp[dn - 1];\n      if (LIKELY ((dh & GMP_NUMB_HIGHBIT) == 0))\n\t{\n\t  count_leading_zeros (cnt, dh);\n\n\t  cy = mpn_lshift (new_np, np + nn - new_nn, new_nn, cnt);\n\t  new_np[new_nn] = cy;\n\n\t  new_nn += (cy != 0);\n\n\t  new_dp = TMP_ALLOC_LIMBS (qn + 1);\n\t  mpn_lshift (new_dp, dp + dn - (qn + 1), qn + 1, cnt);\n\t  new_dp[0] |= dp[dn - (qn + 1) - 1] >> (GMP_NUMB_BITS - cnt);\n\n\t  if (qn + 1 == 2)\n\t    {\n\t      qh = mpn_divrem_2 (tp, 0L, new_np, new_nn, new_dp);\n\t    }\n\t  else if (BELOW_THRESHOLD (qn, DC_DIVAPPR_Q_THRESHOLD - 1))\n\t    {\n\t      invert_pi1 (dinv, new_dp[qn], new_dp[qn - 1]);\n\t      qh = mpn_sbpi1_divappr_q (tp, new_np, new_nn, new_dp, qn + 1, dinv.inv32);\n\t    }\n\t  else if (BELOW_THRESHOLD (qn, MU_DIVAPPR_Q_THRESHOLD - 1))\n\t    {\n\t      invert_pi1 (dinv, new_dp[qn], new_dp[qn - 1]);\n\t      qh = mpn_dcpi1_divappr_q (tp, new_np, new_nn, new_dp, qn + 1, &dinv);\n\t    }\n\t  else\n\t    {\n\t      mp_size_t itch = mpn_mu_divappr_q_itch (new_nn, qn + 1, 0);\n\t      mp_ptr scratch = TMP_ALLOC_LIMBS (itch);\n\t      qh = mpn_mu_divappr_q (tp, new_np, new_nn, new_dp, qn + 1, scratch);\n\t    }\n\t  if (cy == 0)\n\t    tp[qn] = qh;\n\t  else if (UNLIKELY (qh != 0))\n\t    {\n\t      /* This happens only when the quotient is close to B^n and\n\t\t mpn_*_divappr_q returned B^n.  */\n\t      mp_size_t i, n;\n\t      n = new_nn - (qn + 1);\n\t      for (i = 0; i < n; i++)\n\t\ttp[i] = GMP_NUMB_MAX;\n\t      qh = 0;\t\t/* currently ignored */\n\t    }\n\t}\n      else  /* divisor is already normalised */\n\t{\n\t  MPN_COPY (new_np, np + nn - new_nn, new_nn); /* pointless if MU will be used */\n\n\t  new_dp = (mp_ptr) dp + dn - (qn + 1);\n\n\t  if (qn == 2 - 1)\n\t    {\n\t      qh = mpn_divrem_2 (tp, 0L, new_np, new_nn, new_dp);\n\t    }\n\t  else if (BELOW_THRESHOLD (qn, DC_DIVAPPR_Q_THRESHOLD - 1))\n\t    {\n\t      invert_pi1 (dinv, dh, new_dp[qn - 1]);\n\t      qh = mpn_sbpi1_divappr_q (tp, new_np, new_nn, new_dp, qn + 1, dinv.inv32);\n\t    }\n\t  else if (BELOW_THRESHOLD (qn, MU_DIVAPPR_Q_THRESHOLD - 1))\n\t    {\n\t      invert_pi1 (dinv, dh, new_dp[qn - 1]);\n\t      qh = mpn_dcpi1_divappr_q (tp, new_np, new_nn, new_dp, qn + 1, &dinv);\n\t    }\n\t  else\n\t    {\n\t      mp_size_t itch = mpn_mu_divappr_q_itch (new_nn, qn + 1, 0);\n\t      mp_ptr scratch = TMP_ALLOC_LIMBS (itch);\n\t      qh = mpn_mu_divappr_q (tp, new_np, new_nn, new_dp, qn + 1, scratch);\n\t    }\n\t  tp[qn] = qh;\n\t}\n\n      MPN_COPY (qp, tp + 1, qn);\n      if (tp[0] <= 4)\n        {\n\t  mp_size_t rn;\n\n          rp = TMP_ALLOC_LIMBS (dn + qn);\n          mpn_mul (rp, dp, dn, tp + 1, qn);\n\t  rn = dn + qn;\n\t  rn -= rp[rn - 1] == 0;\n\n          if (rn > nn || mpn_cmp (np, rp, nn) < 0)\n            mpn_decr_u (qp, 1);\n        }\n    }\n\n  TMP_FREE;\n}",
      "lines": 224,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/div_qr_1.c": {
    "mpn_div_qr_1": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "mp_limb_t\nmpn_div_qr_1 (mp_ptr qp, mp_limb_t *qh, mp_srcptr up, mp_size_t n,\n\t      mp_limb_t d)\n{\n  unsigned cnt;\n  mp_limb_t uh;\n\n  ASSERT (n > 0);\n  ASSERT (d > 0);\n\n  if (d & GMP_NUMB_HIGHBIT)\n    {\n      /* Normalized case */\n      mp_limb_t dinv, q;\n\n      uh = up[--n];\n\n      q = (uh >= d);\n      *qh = q;\n      uh -= (-q) & d;\n\n      if (BELOW_THRESHOLD (n, DIV_QR_1_NORM_THRESHOLD))\n\t{\n\t  cnt = 0;\n\tplain:\n\t  while (n > 0)\n\t    {\n\t      mp_limb_t ul = up[--n];\n\t      udiv_qrnnd (qp[n], uh, uh, ul, d);\n\t    }\n\t  return uh >> cnt;\n\t}\n      invert_limb (dinv, d);\n      return mpn_div_qr_1n_pi1 (qp, up, n, uh, d, dinv);\n    }\n  else\n    {\n      /* Unnormalized case */\n      mp_limb_t dinv, ul;\n\n      if (! UDIV_NEEDS_NORMALIZATION\n\t  && BELOW_THRESHOLD (n, DIV_QR_1_UNNORM_THRESHOLD))\n\t{\n\t  uh = up[--n];\n\t  udiv_qrnnd (*qh, uh, CNST_LIMB(0), uh, d);\n\t  cnt = 0;\n\t  goto plain;\n\t}\n\n      count_leading_zeros (cnt, d);\n      d <<= cnt;\n\n#if HAVE_NATIVE_div_qr_1u_pi1\n      /* FIXME: Call loop doing on-the-fly normalization */\n#endif\n\n      /* Shift up front, use qp area for shifted copy. A bit messy,\n\t since we have only n-1 limbs available, and shift the high\n\t limb manually. */\n      uh = up[--n];\n      ul = (uh << cnt) | mpn_lshift (qp, up, n, cnt);\n      uh >>= (GMP_LIMB_BITS - cnt);\n\n      if (UDIV_NEEDS_NORMALIZATION\n\t  && BELOW_THRESHOLD (n, DIV_QR_1_UNNORM_THRESHOLD))\n\t{\n\t  udiv_qrnnd (*qh, uh, uh, ul, d);\n\t  up = qp;\n\t  goto plain;\n\t}\n      invert_limb (dinv, d);\n\n      udiv_qrnnd_preinv (*qh, uh, uh, ul, d, dinv);\n      return mpn_div_qr_1n_pi1 (qp, qp, n, uh, d, dinv) >> cnt;\n    }\n}",
      "lines": 76,
      "depth": 14,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/div_qr_1n_pi1.c": {
    "mpn_div_qr_1n_pi1": [
      {
        "start_point": [
          162,
          0
        ],
        "end_point": [
          182,
          1
        ],
        "content": "mp_limb_t\nmpn_div_qr_1n_pi1 (mp_ptr qp, mp_srcptr up, mp_size_t n, mp_limb_t uh,\n\t\t   mp_limb_t d, mp_limb_t dinv)\n{\n  ASSERT (n > 0);\n  ASSERT (uh < d);\n  ASSERT (d & GMP_NUMB_HIGHBIT);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (qp, up, n));\n\n  do\n    {\n      mp_limb_t q, ul;\n\n      ul = up[--n];\n      udiv_qrnnd_preinv (q, uh, uh, ul, d, dinv);\n      qp[n] = q;\n    }\n  while (n > 0);\n\n  return uh;\n}",
        "lines": 21,
        "depth": 9,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          186,
          0
        ],
        "end_point": [
          272,
          1
        ],
        "content": "mp_limb_t\nmpn_div_qr_1n_pi1 (mp_ptr qp, mp_srcptr up, mp_size_t n, mp_limb_t u1,\n\t\t   mp_limb_t d, mp_limb_t dinv)\n{\n  mp_limb_t B2;\n  mp_limb_t u0, u2;\n  mp_limb_t q0, q1;\n  mp_limb_t p0, p1;\n  mp_limb_t t;\n  mp_size_t j;\n\n  ASSERT (d & GMP_LIMB_HIGHBIT);\n  ASSERT (n > 0);\n  ASSERT (u1 < d);\n\n  if (n == 1)\n    {\n      udiv_qrnnd_preinv (qp[0], u1, u1, up[0], d, dinv);\n      return u1;\n    }\n\n  /* FIXME: Could be precomputed */\n  B2 = -d*dinv;\n\n  umul_ppmm (q1, q0, dinv, u1);\n  umul_ppmm (p1, p0, B2, u1);\n  q1 += u1;\n  ASSERT (q1 >= u1);\n  u0 = up[n-1];\t/* Early read, to allow qp == up. */\n  qp[n-1] = q1;\n\n  add_mssaaaa (u2, u1, u0, u0, up[n-2], p1, p0);\n\n  /* FIXME: Keep q1 in a variable between iterations, to reduce number\n     of memory accesses. */\n  for (j = n-2; j-- > 0; )\n    {\n      mp_limb_t q2, cy;\n\n      /* Additions for the q update:\n       *\t+-------+\n       *        |u1 * v |\n       *        +---+---+\n       *        | u1|\n       *    +---+---+\n       *    | 1 | v |  (conditional on u2)\n       *    +---+---+\n       *        | 1 |  (conditional on u0 + u2 B2 carry)\n       *        +---+\n       * +      | q0|\n       *   -+---+---+---+\n       *    | q2| q1| q0|\n       *    +---+---+---+\n      */\n      umul_ppmm (p1, t, u1, dinv);\n      add_ssaaaa (q2, q1, -u2, u2 & dinv, CNST_LIMB(0), u1);\n      add_ssaaaa (q2, q1, q2, q1, CNST_LIMB(0), p1);\n      add_ssaaaa (q2, q1, q2, q1, CNST_LIMB(0), q0);\n      q0 = t;\n\n      umul_ppmm (p1, p0, u1, B2);\n      ADDC_LIMB (cy, u0, u0, u2 & B2);\n      u0 -= (-cy) & d;\n\n      /* Final q update */\n      add_ssaaaa (q2, q1, q2, q1, CNST_LIMB(0), cy);\n      qp[j+1] = q1;\n      MPN_INCR_U (qp+j+2, n-j-2, q2);\n\n      add_mssaaaa (u2, u1, u0, u0, up[j], p1, p0);\n    }\n\n  q1 = (u2 > 0);\n  u1 -= (-q1) & d;\n\n  t = (u1 >= d);\n  q1 += t;\n  u1 -= (-t) & d;\n\n  udiv_qrnnd_preinv (t, u0, u1, u0, d, dinv);\n  add_ssaaaa (q1, q0, q1, q0, CNST_LIMB(0), t);\n\n  MPN_INCR_U (qp+1, n-1, q1);\n\n  qp[0] = q0;\n  return u0;\n}",
        "lines": 87,
        "depth": 10,
        "decorators": [
          "mp_limb_t"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/div_qr_1n_pi2.c": {
    "mpn_div_qr_1n_pi2": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "mp_limb_t\nmpn_div_qr_1n_pi2 (mp_ptr qp,\n\t\t   mp_srcptr up, mp_size_t un,\n\t\t   struct precomp_div_1_pi2 *pd)\n{\n  mp_limb_t most_significant_q_limb;\n  mp_size_t i;\n  mp_limb_t r, u2, u1, u0;\n  mp_limb_t d0, di1, di0;\n  mp_limb_t q3a, q2a, q2b, q1b, q2c, q1c, q1d, q0d;\n  mp_limb_t cnd;\n\n  ASSERT (un >= 2);\n  ASSERT ((pd->d & GMP_NUMB_HIGHBIT) != 0);\n  ASSERT (! MPN_OVERLAP_P (qp, un-2, up, un) || qp+2 >= up);\n  ASSERT_MPN (up, un);\n\n#define q3 q3a\n#define q2 q2b\n#define q1 q1b\n\n  up += un - 3;\n  r = up[2];\n  d0 = pd->d;\n\n  most_significant_q_limb = (r >= d0);\n  r -= d0 & -most_significant_q_limb;\n\n  qp += un - 3;\n  qp[2] = most_significant_q_limb;\n\n  di1 = pd->dip[1];\n  di0 = pd->dip[0];\n\n  for (i = un - 3; i >= 0; i -= 2)\n    {\n      u2 = r;\n      u1 = up[1];\n      u0 = up[0];\n\n      /* Dividend in {r,u1,u0} */\n\n      umul_ppmm (q1d,q0d, u1, di0);\n      umul_ppmm (q2b,q1b, u1, di1);\n      q2b++;\t\t\t\t/* cannot spill */\n      add_sssaaaa (r,q2b,q1b, q2b,q1b, u1,u0);\n\n      umul_ppmm (q2c,q1c, u2,  di0);\n      add_sssaaaa (r,q2b,q1b, q2b,q1b, q2c,q1c);\n      umul_ppmm (q3a,q2a, u2, di1);\n\n      add_sssaaaa (r,q2b,q1b, q2b,q1b, q2a,q1d);\n\n      q3 += r;\n\n      r = u0 - q2 * d0;\n\n      cnd = (r >= q1);\n      r += d0 & -cnd;\n      sub_ddmmss (q3,q2,  q3,q2,  0,cnd);\n\n      if (UNLIKELY (r >= d0))\n\t{\n\t  r -= d0;\n\t  add_ssaaaa (q3,q2,  q3,q2,  0,1);\n\t}\n\n      qp[0] = q2;\n      qp[1] = q3;\n\n      up -= 2;\n      qp -= 2;\n    }\n\n  if ((un & 1) == 0)\n    {\n      u2 = r;\n      u1 = up[1];\n\n      udiv_qrnnd_preinv (q3, r, u2, u1, d0, di1);\n      qp[1] = q3;\n    }\n\n  return r;\n\n#undef q3\n#undef q2\n#undef q1\n}",
      "lines": 89,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/div_qr_1u_pi2.c": {
    "mpn_div_qr_1u_pi2": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "mp_limb_t\nmpn_div_qr_1u_pi2 (mp_ptr qp,\n\t\t   mp_srcptr up, mp_size_t un,\n\t\t   struct precomp_div_1_pi2 *pd)\n{\n  mp_size_t i;\n  mp_limb_t r, u2, u1, u0;\n  mp_limb_t d0, di1, di0;\n  mp_limb_t q3a, q2a, q2b, q1b, q2c, q1c, q1d, q0d;\n  mp_limb_t cnd;\n  int cnt;\n\n  ASSERT (un >= 2);\n  ASSERT ((pd->d & GMP_NUMB_HIGHBIT) == 0);\n  ASSERT (! MPN_OVERLAP_P (qp, un-2, up, un) || qp+2 >= up);\n  ASSERT_MPN (up, un);\n\n#define q3 q3a\n#define q2 q2b\n#define q1 q1b\n\n  up += un - 3;\n  cnt = pd->norm_cnt;\n  r = up[2] >> (GMP_NUMB_BITS - cnt);\n  d0 = pd->d << cnt;\n\n  qp += un - 2;\n\n  di1 = pd->dip[1];\n  di0 = pd->dip[0];\n\n  for (i = un - 3; i >= 0; i -= 2)\n    {\n      u2 = r;\n      u1 = (up[2] << cnt) | (up[1] >> (GMP_NUMB_BITS - cnt));\n      u0 = (up[1] << cnt) | (up[0] >> (GMP_NUMB_BITS - cnt));\n\n      /* Dividend in {r,u1,u0} */\n\n      umul_ppmm (q1d,q0d, u1, di0);\n      umul_ppmm (q2b,q1b, u1, di1);\n      q2b++;\t\t\t\t/* cannot spill */\n      add_sssaaaa (r,q2b,q1b, q2b,q1b, u1,u0);\n\n      umul_ppmm (q2c,q1c, u2,  di0);\n      add_sssaaaa (r,q2b,q1b, q2b,q1b, q2c,q1c);\n      umul_ppmm (q3a,q2a, u2, di1);\n\n      add_sssaaaa (r,q2b,q1b, q2b,q1b, q2a,q1d);\n\n      q3 += r;\n\n      r = u0 - q2 * d0;\n\n      cnd = (r >= q1);\n      r += d0 & -cnd;\n      sub_ddmmss (q3,q2,  q3,q2,  0,cnd);\n\n      if (UNLIKELY (r >= d0))\n\t{\n\t  r -= d0;\n\t  add_ssaaaa (q3,q2,  q3,q2,  0,1);\n\t}\n\n      qp[0] = q2;\n      qp[1] = q3;\n\n      up -= 2;\n      qp -= 2;\n    }\n\n  if ((un & 1) != 0)\n    {\n      u2 = r;\n      u1 = (up[2] << cnt);\n\n      udiv_qrnnd_preinv (q3, r, u2, u1, d0, di1);\n      qp[1] = q3;\n    }\n  else\n    {\n      u2 = r;\n      u1 = (up[2] << cnt) | (up[1] >> (GMP_NUMB_BITS - cnt));\n      u0 = (up[1] << cnt);\n\n      /* Dividend in {r,u1,u0} */\n\n      umul_ppmm (q1d,q0d, u1, di0);\n      umul_ppmm (q2b,q1b, u1, di1);\n      q2b++;\t\t\t\t/* cannot spill */\n      add_sssaaaa (r,q2b,q1b, q2b,q1b, u1,u0);\n\n      umul_ppmm (q2c,q1c, u2,  di0);\n      add_sssaaaa (r,q2b,q1b, q2b,q1b, q2c,q1c);\n      umul_ppmm (q3a,q2a, u2, di1);\n\n      add_sssaaaa (r,q2b,q1b, q2b,q1b, q2a,q1d);\n\n      q3 += r;\n\n      r = u0 - q2 * d0;\n\n      cnd = (r >= q1);\n      r += d0 & -cnd;\n      sub_ddmmss (q3,q2,  q3,q2,  0,cnd);\n\n      if (UNLIKELY (r >= d0))\n\t{\n\t  r -= d0;\n\t  add_ssaaaa (q3,q2,  q3,q2,  0,1);\n\t}\n\n      qp[0] = q2;\n      qp[1] = q3;\n    }\n\n  return r >> cnt;\n\n#undef q3\n#undef q2\n#undef q1\n}",
      "lines": 122,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/div_qr_2.c": {
    "invert_4by2": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "static void\ninvert_4by2 (mp_ptr di, mp_limb_t d1, mp_limb_t d0)\n{\n  mp_limb_t v1, v0, p1, t1, t0, p0, mask;\n  invert_limb (v1, d1);\n  p1 = d1 * v1;\n  /* <1, v1> * d1 = <B-1, p1> */\n  p1 += d0;\n  if (p1 < d0)\n    {\n      v1--;\n      mask = -(mp_limb_t) (p1 >= d1);\n      p1 -= d1;\n      v1 += mask;\n      p1 -= mask & d1;\n    }\n  /* <1, v1> * d1 + d0 = <B-1, p1> */\n  umul_ppmm (t1, p0, d0, v1);\n  p1 += t1;\n  if (p1 < t1)\n    {\n      if (UNLIKELY (p1 >= d1))\n\t{\n\t  if (p1 > d1 || p0 >= d0)\n\t    {\n\t      sub_ddmmss (p1, p0, p1, p0, d1, d0);\n\t      v1--;\n\t    }\n\t}\n      sub_ddmmss (p1, p0, p1, p0, d1, d0);\n      v1--;\n    }\n  /* Now v1 is the 3/2 inverse, <1, v1> * <d1, d0> = <B-1, p1, p0>,\n   * with <p1, p0> + <d1, d0> >= B^2.\n   *\n   * The 4/2 inverse is (B^4 - 1) / <d1, d0> = <1, v1, v0>. The\n   * partial remainder after <1, v1> is\n   *\n   * B^4 - 1 - B <1, v1> <d1, d0> = <B-1, B-1, B-1, B-1> - <B-1, p1, p0, 0>\n   *                              = <~p1, ~p0, B-1>\n   */\n  udiv_qr_3by2 (v0, t1, t0, ~p1, ~p0, MP_LIMB_T_MAX, d1, d0, v1);\n  di[0] = v0;\n  di[1] = v1;\n\n#if SANITY_CHECK\n  {\n    mp_limb_t tp[4];\n    mp_limb_t dp[2];\n    dp[0] = d0;\n    dp[1] = d1;\n    mpn_mul_n (tp, dp, di, 2);\n    ASSERT_ALWAYS (mpn_add_n (tp+2, tp+2, dp, 2) == 0);\n    ASSERT_ALWAYS (tp[2] == MP_LIMB_T_MAX);\n    ASSERT_ALWAYS (tp[3] == MP_LIMB_T_MAX);\n    ASSERT_ALWAYS (mpn_add_n (tp, tp, dp, 2) == 1);\n  }\n#endif\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_2n_pi2": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static mp_limb_t\nmpn_div_qr_2n_pi2 (mp_ptr qp, mp_ptr rp, mp_srcptr np, mp_size_t nn,\n\t\t   mp_limb_t d1, mp_limb_t d0, mp_limb_t di1, mp_limb_t di0)\n{\n  mp_limb_t qh;\n  mp_size_t i;\n  mp_limb_t r1, r0;\n\n  ASSERT (nn >= 2);\n  ASSERT (d1 & GMP_NUMB_HIGHBIT);\n\n  r1 = np[nn-1];\n  r0 = np[nn-2];\n\n  qh = 0;\n  if (r1 >= d1 && (r1 > d1 || r0 >= d0))\n    {\n#if GMP_NAIL_BITS == 0\n      sub_ddmmss (r1, r0, r1, r0, d1, d0);\n#else\n      r0 = r0 - d0;\n      r1 = r1 - d1 - (r0 >> GMP_LIMB_BITS - 1);\n      r0 &= GMP_NUMB_MASK;\n#endif\n      qh = 1;\n    }\n\n  for (i = nn - 2; i >= 2; i -= 2)\n    {\n      mp_limb_t n1, n0, q1, q0;\n      n1 = np[i-1];\n      n0 = np[i-2];\n      udiv_qr_4by2 (q1, q0, r1, r0, r1, r0, n1, n0, d1, d0, di1, di0);\n      qp[i-1] = q1;\n      qp[i-2] = q0;\n    }\n\n  if (i > 0)\n    {\n      mp_limb_t q;\n      udiv_qr_3by2 (q, r1, r0, r1, r0, np[0], d1, d0, di1);\n      qp[0] = q;\n    }\n  rp[1] = r1;\n  rp[0] = r0;\n\n  return qh;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_div_qr_2": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "mp_limb_t\nmpn_div_qr_2 (mp_ptr qp, mp_ptr rp, mp_srcptr np, mp_size_t nn,\n\t      mp_srcptr dp)\n{\n  mp_limb_t d1;\n  mp_limb_t d0;\n  gmp_pi1_t dinv;\n\n  ASSERT (nn >= 2);\n  ASSERT (! MPN_OVERLAP_P (qp, nn-2, np, nn) || qp >= np + 2);\n  ASSERT_MPN (np, nn);\n  ASSERT_MPN (dp, 2);\n\n  d1 = dp[1]; d0 = dp[0];\n\n  ASSERT (d1 > 0);\n\n  if (UNLIKELY (d1 & GMP_NUMB_HIGHBIT))\n    {\n      if (BELOW_THRESHOLD (nn, DIV_QR_2_PI2_THRESHOLD))\n\t{\n\t  gmp_pi1_t dinv;\n\t  invert_pi1 (dinv, d1, d0);\n\t  return mpn_div_qr_2n_pi1 (qp, rp, np, nn, d1, d0, dinv.inv32);\n\t}\n      else\n\t{\n\t  mp_limb_t di[2];\n\t  invert_4by2 (di, d1, d0);\n\t  return mpn_div_qr_2n_pi2 (qp, rp, np, nn, d1, d0, di[1], di[0]);\n\t}\n    }\n  else\n    {\n      int shift;\n      count_leading_zeros (shift, d1);\n      d1 = (d1 << shift) | (d0 >> (GMP_LIMB_BITS - shift));\n      d0 <<= shift;\n      invert_pi1 (dinv, d1, d0);\n      return mpn_div_qr_2u_pi1 (qp, rp, np, nn, d1, d0, shift, dinv.inv32);\n    }\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/div_qr_2n_pi1.c": {
    "mpn_div_qr_2n_pi1": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "mp_limb_t\nmpn_div_qr_2n_pi1 (mp_ptr qp, mp_ptr rp, mp_srcptr np, mp_size_t nn,\n\t\t   mp_limb_t d1, mp_limb_t d0, mp_limb_t di)\n{\n  mp_limb_t qh;\n  mp_size_t i;\n  mp_limb_t r1, r0;\n\n  ASSERT (nn >= 2);\n  ASSERT (d1 & GMP_NUMB_HIGHBIT);\n\n  np += nn - 2;\n  r1 = np[1];\n  r0 = np[0];\n\n  qh = 0;\n  if (r1 >= d1 && (r1 > d1 || r0 >= d0))\n    {\n#if GMP_NAIL_BITS == 0\n      sub_ddmmss (r1, r0, r1, r0, d1, d0);\n#else\n      r0 = r0 - d0;\n      r1 = r1 - d1 - (r0 >> GMP_LIMB_BITS - 1);\n      r0 &= GMP_NUMB_MASK;\n#endif\n      qh = 1;\n    }\n\n  for (i = nn - 2 - 1; i >= 0; i--)\n    {\n      mp_limb_t n0, q;\n      n0 = np[-1];\n      udiv_qr_3by2 (q, r1, r0, r1, r0, n0, d1, d0, di);\n      np--;\n      qp[i] = q;\n    }\n\n  rp[1] = r1;\n  rp[0] = r0;\n\n  return qh;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/div_qr_2u_pi1.c": {
    "mpn_div_qr_2u_pi1": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "mp_limb_t\nmpn_div_qr_2u_pi1 (mp_ptr qp, mp_ptr rp, mp_srcptr np, mp_size_t nn,\n\t\t   mp_limb_t d1, mp_limb_t d0, int shift, mp_limb_t di)\n{\n  mp_limb_t qh;\n  mp_limb_t r2, r1, r0;\n  mp_size_t i;\n\n  ASSERT (nn >= 2);\n  ASSERT (d1 & GMP_NUMB_HIGHBIT);\n  ASSERT (shift > 0);\n\n  r2 = np[nn-1] >> (GMP_LIMB_BITS - shift);\n  r1 = (np[nn-1] << shift) | (np[nn-2] >> (GMP_LIMB_BITS - shift));\n  r0 = np[nn-2] << shift;\n\n  udiv_qr_3by2 (qh, r2, r1, r2, r1, r0, d1, d0, di);\n\n  for (i = nn - 2 - 1; i >= 0; i--)\n    {\n      mp_limb_t q;\n      r0 = np[i];\n      r1 |= r0 >> (GMP_LIMB_BITS - shift);\n      r0 <<= shift;\n      udiv_qr_3by2 (q, r2, r1, r2, r1, r0, d1, d0, di);\n      qp[i] = q;\n    }\n\n  rp[0] = (r1 >> shift) | (r2 << (GMP_LIMB_BITS - shift));\n  rp[1] = r2 >> shift;\n\n  return qh;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/dump.c": {
    "mpn_dump": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          71,
          1
        ],
        "content": "void\nmpn_dump (mp_srcptr ptr, mp_size_t n)\n{\n  MPN_NORMALIZE (ptr, n);\n\n  if (n == 0)\n    printf (\"0\\n\");\n  else\n    {\n      n--;\n#if _LONG_LONG_LIMB\n      if ((ptr[n] >> GMP_LIMB_BITS / 2) != 0)\n\t{\n\t  printf (\"%lX\", (unsigned long) (ptr[n] >> GMP_LIMB_BITS / 2));\n\t  printf (\"%0*lX\", (GMP_LIMB_BITS / 2 / 4), (unsigned long) ptr[n]);\n\t}\n      else\n#endif\n\tprintf (\"%lX\", (unsigned long) ptr[n]);\n\n      while (n)\n\t{\n\t  n--;\n#if _LONG_LONG_LIMB\n\t  printf (\"%0*lX\", (GMP_NUMB_BITS - GMP_LIMB_BITS / 2) / 4,\n\t\t  (unsigned long) (ptr[n] >> GMP_LIMB_BITS / 2));\n\t  printf (\"%0*lX\", GMP_LIMB_BITS / 2 / 4, (unsigned long) ptr[n]);\n#else\n\t  printf (\"%0*lX\", GMP_NUMB_BITS / 4, (unsigned long) ptr[n]);\n#endif\n\t}\n      printf (\"\\n\");\n    }\n}",
        "lines": 34,
        "depth": 15,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          88,
          0
        ],
        "end_point": [
          97,
          1
        ],
        "content": "void\nmpn_dump (mp_srcptr p, mp_size_t n)\n{\n  mp_ptr tp;\n  TMP_DECL;\n  TMP_MARK;\n  tp = TMP_ALLOC_LIMBS (n);\n  MPN_COPY (tp, p, n);\n  TMP_FREE;\n}",
        "lines": 10,
        "depth": 7,
        "decorators": [
          "void"
        ]
      }
    ],
    "mpn_recdump": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\nmpn_recdump (mp_ptr p, mp_size_t n)\n{\n  mp_limb_t lo;\n  if (n != 0)\n    {\n      lo = p[0] & 0xf;\n      mpn_rshift (p, p, n, 4);\n      mpn_recdump (p, n);\n      printf (\"%lX\", lo);\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/fib2_ui.c": {
    "mpn_fib2_ui": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "mp_size_t\nmpn_fib2_ui (mp_ptr fp, mp_ptr f1p, unsigned long int n)\n{\n  mp_size_t      size;\n  unsigned long  nfirst, mask;\n\n  TRACE (printf (\"mpn_fib2_ui n=%lu\\n\", n));\n\n  ASSERT (! MPN_OVERLAP_P (fp, MPN_FIB2_SIZE(n), f1p, MPN_FIB2_SIZE(n)));\n\n  /* Take a starting pair from the table. */\n  mask = 1;\n  for (nfirst = n; nfirst > FIB_TABLE_LIMIT; nfirst /= 2)\n    mask <<= 1;\n  TRACE (printf (\"nfirst=%lu mask=0x%lX\\n\", nfirst, mask));\n\n  f1p[0] = FIB_TABLE ((int) nfirst - 1);\n  fp[0]  = FIB_TABLE (nfirst);\n  size = 1;\n\n  /* Skip to the end if the table lookup gives the final answer. */\n  if (mask != 1)\n    {\n      mp_size_t  alloc;\n      mp_ptr        xp;\n      TMP_DECL;\n\n      TMP_MARK;\n      alloc = MPN_FIB2_SIZE (n);\n      xp = TMP_ALLOC_LIMBS (alloc);\n\n      do\n\t{\n\t  /* Here fp==F[k] and f1p==F[k-1], with k being the bits of n from\n\t     n&mask upwards.\n\n\t     The next bit of n is n&(mask>>1) and we'll double to the pair\n\t     fp==F[2k],f1p==F[2k-1] or fp==F[2k+1],f1p==F[2k], according as\n\t     that bit is 0 or 1 respectively.  */\n\n\t  TRACE (printf (\"k=%lu mask=0x%lX size=%ld alloc=%ld\\n\",\n\t\t\t n >> refmpn_count_trailing_zeros(mask),\n\t\t\t mask, size, alloc);\n\t\t mpn_trace (\"fp \", fp, size);\n\t\t mpn_trace (\"f1p\", f1p, size));\n\n\t  /* fp normalized, f1p at most one high zero */\n\t  ASSERT (fp[size-1] != 0);\n\t  ASSERT (f1p[size-1] != 0 || f1p[size-2] != 0);\n\n\t  /* f1p[size-1] might be zero, but this occurs rarely, so it's not\n\t     worth bothering checking for it */\n\t  ASSERT (alloc >= 2*size);\n\t  mpn_sqr (xp, fp,  size);\n\t  mpn_sqr (fp, f1p, size);\n\t  size *= 2;\n\n\t  /* Shrink if possible.  Since fp was normalized there'll be at\n\t     most one high zero on xp (and if there is then there's one on\n\t     yp too).  */\n\t  ASSERT (xp[size-1] != 0 || fp[size-1] == 0);\n\t  size -= (xp[size-1] == 0);\n\t  ASSERT (xp[size-1] != 0);  /* only one xp high zero */\n\n\t  /* Calculate F[2k-1] = F[k]^2 + F[k-1]^2. */\n\t  f1p[size] = mpn_add_n (f1p, xp, fp, size);\n\n\t  /* Calculate F[2k+1] = 4*F[k]^2 - F[k-1]^2 + 2*(-1)^k.\n\t     n&mask is the low bit of our implied k.  */\n#if HAVE_NATIVE_mpn_rsblsh2_n\n\t  fp[size] = mpn_rsblsh2_n (fp, fp, xp, size);\n\t  if ((n & mask) == 0)\n\t    MPN_INCR_U(fp, size + 1, 2);\t/* possible +2 */\n\t  else\n\t  {\n\t    ASSERT (fp[0] >= 2);\n\t    fp[0] -= 2;\t\t\t\t/* possible -2 */\n\t  }\n#else\n\t  {\n\t    mp_limb_t  c;\n\n\t    c = mpn_lshift (xp, xp, size, 2);\n\t    xp[0] |= (n & mask ? 0 : 2);\t/* possible +2 */\n\t    c -= mpn_sub_n (fp, xp, fp, size);\n\t    ASSERT (n & mask ? fp[0] != 0 && fp[0] != 1 : 1);\n\t    fp[0] -= (n & mask ? 2 : 0);\t/* possible -2 */\n\t    fp[size] = c;\n\t  }\n#endif\n\t  ASSERT (alloc >= size+1);\n\t  size += (fp[size] != 0);\n\n\t  /* now n&mask is the new bit of n being considered */\n\t  mask >>= 1;\n\n\t  /* Calculate F[2k] = F[2k+1] - F[2k-1], replacing the unwanted one of\n\t     F[2k+1] and F[2k-1].  */\n\t  if (n & mask)\n\t    ASSERT_NOCARRY (mpn_sub_n (f1p, fp, f1p, size));\n\t  else {\n\t    ASSERT_NOCARRY (mpn_sub_n ( fp, fp, f1p, size));\n\n\t    /* Can have a high zero after replacing F[2k+1] with F[2k].\n\t       f1p will have a high zero if fp does. */\n\t    ASSERT (fp[size-1] != 0 || f1p[size-1] == 0);\n\t    size -= (fp[size-1] == 0);\n\t  }\n\t}\n      while (mask != 1);\n\n      TMP_FREE;\n    }\n\n  TRACE (printf (\"done size=%ld\\n\", size);\n\t mpn_trace (\"fp \", fp, size);\n\t mpn_trace (\"f1p\", f1p, size));\n\n  return size;\n}",
      "lines": 120,
      "depth": 17,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/gcd.c": {
    "gcd_hook": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static void\ngcd_hook (void *p, mp_srcptr gp, mp_size_t gn,\n\t  mp_srcptr qp, mp_size_t qn, int d)\n{\n  struct gcd_ctx *ctx = (struct gcd_ctx *) p;\n  MPN_COPY (ctx->gp, gp, gn);\n  ctx->gn = gn;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gcd_2": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static inline mp_size_t\ngcd_2 (mp_ptr gp, mp_srcptr up, mp_srcptr vp)\n{\n  mp_limb_t u0, u1, v0, v1;\n  mp_size_t gn;\n\n  u0 = up[0];\n  u1 = up[1];\n  v0 = vp[0];\n  v1 = vp[1];\n\n  ASSERT (u0 & 1);\n  ASSERT (v0 & 1);\n\n  /* Check for u0 != v0 needed to ensure that argument to\n   * count_trailing_zeros is non-zero. */\n  while (u1 != v1 && u0 != v0)\n    {\n      unsigned long int r;\n      if (u1 > v1)\n\t{\n\t  sub_ddmmss (u1, u0, u1, u0, v1, v0);\n\t  count_trailing_zeros (r, u0);\n\t  u0 = ((u1 << (GMP_NUMB_BITS - r)) & GMP_NUMB_MASK) | (u0 >> r);\n\t  u1 >>= r;\n\t}\n      else  /* u1 < v1.  */\n\t{\n\t  sub_ddmmss (v1, v0, v1, v0, u1, u0);\n\t  count_trailing_zeros (r, v0);\n\t  v0 = ((v1 << (GMP_NUMB_BITS - r)) & GMP_NUMB_MASK) | (v0 >> r);\n\t  v1 >>= r;\n\t}\n    }\n\n  gp[0] = u0, gp[1] = u1, gn = 1 + (u1 != 0);\n\n  /* If U == V == GCD, done.  Otherwise, compute GCD (V, |U - V|).  */\n  if (u1 == v1 && u0 == v0)\n    return gn;\n\n  v0 = (u0 == v0) ? ((u1 > v1) ? u1-v1 : v1-u1) : ((u0 > v0) ? u0-v0 : v0-u0);\n  gp[0] = mpn_gcd_1 (gp, gn, v0);\n\n  return 1;\n}",
      "lines": 46,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_size_t"
      ]
    },
    "mpn_gcd": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "mp_size_t\nmpn_gcd (mp_ptr gp, mp_ptr up, mp_size_t usize, mp_ptr vp, mp_size_t n)\n{\n  mp_size_t talloc;\n  mp_size_t scratch;\n  mp_size_t matrix_scratch;\n\n  struct gcd_ctx ctx;\n  mp_ptr tp;\n  TMP_DECL;\n\n  ASSERT (usize >= n);\n  ASSERT (n > 0);\n  ASSERT (vp[n-1] > 0);\n\n  /* FIXME: Check for small sizes first, before setting up temporary\n     storage etc. */\n  talloc = MPN_GCD_SUBDIV_STEP_ITCH(n);\n\n  /* For initial division */\n  scratch = usize - n + 1;\n  if (scratch > talloc)\n    talloc = scratch;\n\n#if TUNE_GCD_P\n  if (CHOOSE_P (n) > 0)\n#else\n  if (ABOVE_THRESHOLD (n, GCD_DC_THRESHOLD))\n#endif\n    {\n      mp_size_t hgcd_scratch;\n      mp_size_t update_scratch;\n      mp_size_t p = CHOOSE_P (n);\n      mp_size_t scratch;\n#if TUNE_GCD_P\n      /* Worst case, since we don't guarantee that n - CHOOSE_P(n)\n\t is increasing */\n      matrix_scratch = MPN_HGCD_MATRIX_INIT_ITCH (n);\n      hgcd_scratch = mpn_hgcd_itch (n);\n      update_scratch = 2*(n - 1);\n#else\n      matrix_scratch = MPN_HGCD_MATRIX_INIT_ITCH (n - p);\n      hgcd_scratch = mpn_hgcd_itch (n - p);\n      update_scratch = p + n - 1;\n#endif\n      scratch = matrix_scratch + MAX(hgcd_scratch, update_scratch);\n      if (scratch > talloc)\n\ttalloc = scratch;\n    }\n\n  TMP_MARK;\n  tp = TMP_ALLOC_LIMBS(talloc);\n\n  if (usize > n)\n    {\n      mpn_tdiv_qr (tp, up, 0, up, usize, vp, n);\n\n      if (mpn_zero_p (up, n))\n\t{\n\t  MPN_COPY (gp, vp, n);\n\t  ctx.gn = n;\n\t  goto done;\n\t}\n    }\n\n  ctx.gp = gp;\n\n#if TUNE_GCD_P\n  while (CHOOSE_P (n) > 0)\n#else\n  while (ABOVE_THRESHOLD (n, GCD_DC_THRESHOLD))\n#endif\n    {\n      struct hgcd_matrix M;\n      mp_size_t p = CHOOSE_P (n);\n      mp_size_t matrix_scratch = MPN_HGCD_MATRIX_INIT_ITCH (n - p);\n      mp_size_t nn;\n      mpn_hgcd_matrix_init (&M, n - p, tp);\n      nn = mpn_hgcd (up + p, vp + p, n - p, &M, tp + matrix_scratch);\n      if (nn > 0)\n\t{\n\t  ASSERT (M.n <= (n - p - 1)/2);\n\t  ASSERT (M.n + p <= (p + n - 1) / 2);\n\t  /* Temporary storage 2 (p + M->n) <= p + n - 1. */\n\t  n = mpn_hgcd_matrix_adjust (&M, p + nn, up, vp, p, tp + matrix_scratch);\n\t}\n      else\n\t{\n\t  /* Temporary storage n */\n\t  n = mpn_gcd_subdiv_step (up, vp, n, 0, gcd_hook, &ctx, tp);\n\t  if (n == 0)\n\t    goto done;\n\t}\n    }\n\n  while (n > 2)\n    {\n      struct hgcd_matrix1 M;\n      mp_limb_t uh, ul, vh, vl;\n      mp_limb_t mask;\n\n      mask = up[n-1] | vp[n-1];\n      ASSERT (mask > 0);\n\n      if (mask & GMP_NUMB_HIGHBIT)\n\t{\n\t  uh = up[n-1]; ul = up[n-2];\n\t  vh = vp[n-1]; vl = vp[n-2];\n\t}\n      else\n\t{\n\t  int shift;\n\n\t  count_leading_zeros (shift, mask);\n\t  uh = MPN_EXTRACT_NUMB (shift, up[n-1], up[n-2]);\n\t  ul = MPN_EXTRACT_NUMB (shift, up[n-2], up[n-3]);\n\t  vh = MPN_EXTRACT_NUMB (shift, vp[n-1], vp[n-2]);\n\t  vl = MPN_EXTRACT_NUMB (shift, vp[n-2], vp[n-3]);\n\t}\n\n      /* Try an mpn_hgcd2 step */\n      if (mpn_hgcd2 (uh, ul, vh, vl, &M))\n\t{\n\t  n = mpn_matrix22_mul1_inverse_vector (&M, tp, up, vp, n);\n\t  MP_PTR_SWAP (up, tp);\n\t}\n      else\n\t{\n\t  /* mpn_hgcd2 has failed. Then either one of a or b is very\n\t     small, or the difference is very small. Perform one\n\t     subtraction followed by one division. */\n\n\t  /* Temporary storage n */\n\t  n = mpn_gcd_subdiv_step (up, vp, n, 0, &gcd_hook, &ctx, tp);\n\t  if (n == 0)\n\t    goto done;\n\t}\n    }\n\n  ASSERT(up[n-1] | vp[n-1]);\n\n  if (n == 1)\n    {\n      *gp = mpn_gcd_1(up, 1, vp[0]);\n      ctx.gn = 1;\n      goto done;\n    }\n\n  /* Due to the calling convention for mpn_gcd, at most one can be\n     even. */\n\n  if (! (up[0] & 1))\n    MP_PTR_SWAP (up, vp);\n\n  ASSERT (up[0] & 1);\n\n  if (vp[0] == 0)\n    {\n      *gp = mpn_gcd_1 (up, 2, vp[1]);\n      ctx.gn = 1;\n      goto done;\n    }\n  else if (! (vp[0] & 1))\n    {\n      int r;\n      count_trailing_zeros (r, vp[0]);\n      vp[0] = ((vp[1] << (GMP_NUMB_BITS - r)) & GMP_NUMB_MASK) | (vp[0] >> r);\n      vp[1] >>= r;\n    }\n\n  ctx.gn = gcd_2(gp, up, vp);\n\ndone:\n  TMP_FREE;\n  return ctx.gn;\n}",
      "lines": 176,
      "depth": 17,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/gcdext.c": {
    "hgcd_mul_matrix_vector": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static size_t\nhgcd_mul_matrix_vector (struct hgcd_matrix *M,\n\t\t\tmp_ptr rp, mp_srcptr ap, mp_ptr bp, mp_size_t n, mp_ptr tp)\n{\n  mp_limb_t ah, bh;\n\n  /* Compute (r,b) <-- (u00 a + u10 b, u01 a + u11 b) as\n\n     t  = u00 * a\n     r  = u10 * b\n     r += t;\n\n     t  = u11 * b\n     b  = u01 * a\n     b += t;\n  */\n\n  if (M->n >= n)\n    {\n      mpn_mul (tp, M->p[0][0], M->n, ap, n);\n      mpn_mul (rp, M->p[1][0], M->n, bp, n);\n    }\n  else\n    {\n      mpn_mul (tp, ap, n, M->p[0][0], M->n);\n      mpn_mul (rp, bp, n, M->p[1][0], M->n);\n    }\n\n  ah = mpn_add_n (rp, rp, tp, n + M->n);\n\n  if (M->n >= n)\n    {\n      mpn_mul (tp, M->p[1][1], M->n, bp, n);\n      mpn_mul (bp, M->p[0][1], M->n, ap, n);\n    }\n  else\n    {\n      mpn_mul (tp, bp, n, M->p[1][1], M->n);\n      mpn_mul (bp, ap, n, M->p[0][1], M->n);\n    }\n  bh = mpn_add_n (bp, bp, tp, n + M->n);\n\n  n += M->n;\n  if ( (ah | bh) > 0)\n    {\n      rp[n] = ah;\n      bp[n] = bh;\n      n++;\n    }\n  else\n    {\n      /* Normalize */\n      while ( (rp[n-1] | bp[n-1]) == 0)\n\tn--;\n    }\n\n  return n;\n}",
      "lines": 58,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "compute_v": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static mp_size_t\ncompute_v (mp_ptr vp,\n\t   mp_srcptr ap, mp_srcptr bp, mp_size_t n,\n\t   mp_srcptr gp, mp_size_t gn,\n\t   mp_srcptr up, mp_size_t usize,\n\t   mp_ptr tp)\n{\n  mp_size_t size;\n  mp_size_t an;\n  mp_size_t bn;\n  mp_size_t vn;\n\n  ASSERT (n > 0);\n  ASSERT (gn > 0);\n  ASSERT (usize != 0);\n\n  size = ABS (usize);\n  ASSERT (size <= n);\n  ASSERT (up[size-1] > 0);\n\n  an = n;\n  MPN_NORMALIZE (ap, an);\n  ASSERT (gn <= an);\n\n  if (an >= size)\n    mpn_mul (tp, ap, an, up, size);\n  else\n    mpn_mul (tp, up, size, ap, an);\n\n  size += an;\n\n  if (usize > 0)\n    {\n      /* |v| = -v = (u a - g) / b */\n\n      ASSERT_NOCARRY (mpn_sub (tp, tp, size, gp, gn));\n      MPN_NORMALIZE (tp, size);\n      if (size == 0)\n\treturn 0;\n    }\n  else\n    { /* |v| = v = (g - u a) / b = (g + |u| a) / b. Since g <= a,\n\t (g + |u| a) always fits in (|usize| + an) limbs. */\n\n      ASSERT_NOCARRY (mpn_add (tp, tp, size, gp, gn));\n      size -= (tp[size - 1] == 0);\n    }\n\n  /* Now divide t / b. There must be no remainder */\n  bn = n;\n  MPN_NORMALIZE (bp, bn);\n  ASSERT (size >= bn);\n\n  vn = size + 1 - bn;\n  ASSERT (vn <= n + 1);\n\n  mpn_divexact (vp, tp, size, bp, bn);\n  vn -= (vp[vn-1] == 0);\n\n  return vn;\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_gcdext": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        557,
        1
      ],
      "content": "mp_size_t\nmpn_gcdext (mp_ptr gp, mp_ptr up, mp_size_t *usizep,\n\t    mp_ptr ap, mp_size_t an, mp_ptr bp, mp_size_t n)\n{\n  mp_size_t talloc;\n  mp_size_t scratch;\n  mp_size_t matrix_scratch;\n  mp_size_t ualloc = n + 1;\n\n  struct gcdext_ctx ctx;\n  mp_size_t un;\n  mp_ptr u0;\n  mp_ptr u1;\n\n  mp_ptr tp;\n\n  TMP_DECL;\n\n  ASSERT (an >= n);\n  ASSERT (n > 0);\n  ASSERT (bp[n-1] > 0);\n\n  TMP_MARK;\n\n  /* FIXME: Check for small sizes first, before setting up temporary\n     storage etc. */\n  talloc = MPN_GCDEXT_LEHMER_N_ITCH(n);\n\n  /* For initial division */\n  scratch = an - n + 1;\n  if (scratch > talloc)\n    talloc = scratch;\n\n  if (ABOVE_THRESHOLD (n, GCDEXT_DC_THRESHOLD))\n    {\n      /* For hgcd loop. */\n      mp_size_t hgcd_scratch;\n      mp_size_t update_scratch;\n      mp_size_t p1 = CHOOSE_P_1 (n);\n      mp_size_t p2 = CHOOSE_P_2 (n);\n      mp_size_t min_p = MIN(p1, p2);\n      mp_size_t max_p = MAX(p1, p2);\n      matrix_scratch = MPN_HGCD_MATRIX_INIT_ITCH (n - min_p);\n      hgcd_scratch = mpn_hgcd_itch (n - min_p);\n      update_scratch = max_p + n - 1;\n\n      scratch = matrix_scratch + MAX(hgcd_scratch, update_scratch);\n      if (scratch > talloc)\n\ttalloc = scratch;\n\n      /* Final mpn_gcdext_lehmer_n call. Need space for u and for\n\t copies of a and b. */\n      scratch = MPN_GCDEXT_LEHMER_N_ITCH (GCDEXT_DC_THRESHOLD)\n\t+ 3*GCDEXT_DC_THRESHOLD;\n\n      if (scratch > talloc)\n\ttalloc = scratch;\n\n      /* Cofactors u0 and u1 */\n      talloc += 2*(n+1);\n    }\n\n  tp = TMP_ALLOC_LIMBS(talloc);\n\n  if (an > n)\n    {\n      mpn_tdiv_qr (tp, ap, 0, ap, an, bp, n);\n\n      if (mpn_zero_p (ap, n))\n\t{\n\t  MPN_COPY (gp, bp, n);\n\t  *usizep = 0;\n\t  TMP_FREE;\n\t  return n;\n\t}\n    }\n\n  if (BELOW_THRESHOLD (n, GCDEXT_DC_THRESHOLD))\n    {\n      mp_size_t gn = mpn_gcdext_lehmer_n(gp, up, usizep, ap, bp, n, tp);\n\n      TMP_FREE;\n      return gn;\n    }\n\n  MPN_ZERO (tp, 2*ualloc);\n  u0 = tp; tp += ualloc;\n  u1 = tp; tp += ualloc;\n\n  ctx.gp = gp;\n  ctx.up = up;\n  ctx.usize = usizep;\n\n  {\n    /* For the first hgcd call, there are no u updates, and it makes\n       some sense to use a different choice for p. */\n\n    /* FIXME: We could trim use of temporary storage, since u0 and u1\n       are not used yet. For the hgcd call, we could swap in the u0\n       and u1 pointers for the relevant matrix elements. */\n\n    struct hgcd_matrix M;\n    mp_size_t p = CHOOSE_P_1 (n);\n    mp_size_t nn;\n\n    mpn_hgcd_matrix_init (&M, n - p, tp);\n    nn = mpn_hgcd (ap + p, bp + p, n - p, &M, tp + matrix_scratch);\n    if (nn > 0)\n      {\n\tASSERT (M.n <= (n - p - 1)/2);\n\tASSERT (M.n + p <= (p + n - 1) / 2);\n\n\t/* Temporary storage 2 (p + M->n) <= p + n - 1 */\n\tn = mpn_hgcd_matrix_adjust (&M, p + nn, ap, bp, p, tp + matrix_scratch);\n\n\tMPN_COPY (u0, M.p[1][0], M.n);\n\tMPN_COPY (u1, M.p[1][1], M.n);\n\tun = M.n;\n\twhile ( (u0[un-1] | u1[un-1] ) == 0)\n\t  un--;\n      }\n    else\n      {\n\t/* mpn_hgcd has failed. Then either one of a or b is very\n\t   small, or the difference is very small. Perform one\n\t   subtraction followed by one division. */\n\tu1[0] = 1;\n\n\tctx.u0 = u0;\n\tctx.u1 = u1;\n\tctx.tp = tp + n; /* ualloc */\n\tctx.un = 1;\n\n\t/* Temporary storage n */\n\tn = mpn_gcd_subdiv_step (ap, bp, n, 0, mpn_gcdext_hook, &ctx, tp);\n\tif (n == 0)\n\t  {\n\t    TMP_FREE;\n\t    return ctx.gn;\n\t  }\n\n\tun = ctx.un;\n\tASSERT (un < ualloc);\n      }\n  }\n\n  while (ABOVE_THRESHOLD (n, GCDEXT_DC_THRESHOLD))\n    {\n      struct hgcd_matrix M;\n      mp_size_t p = CHOOSE_P_2 (n);\n      mp_size_t nn;\n\n      mpn_hgcd_matrix_init (&M, n - p, tp);\n      nn = mpn_hgcd (ap + p, bp + p, n - p, &M, tp + matrix_scratch);\n      if (nn > 0)\n\t{\n\t  mp_ptr t0;\n\n\t  t0 = tp + matrix_scratch;\n\t  ASSERT (M.n <= (n - p - 1)/2);\n\t  ASSERT (M.n + p <= (p + n - 1) / 2);\n\n\t  /* Temporary storage 2 (p + M->n) <= p + n - 1 */\n\t  n = mpn_hgcd_matrix_adjust (&M, p + nn, ap, bp, p, t0);\n\n\t  /* By the same analysis as for mpn_hgcd_matrix_mul */\n\t  ASSERT (M.n + un <= ualloc);\n\n\t  /* FIXME: This copying could be avoided by some swapping of\n\t   * pointers. May need more temporary storage, though. */\n\t  MPN_COPY (t0, u0, un);\n\n\t  /* Temporary storage ualloc */\n\t  un = hgcd_mul_matrix_vector (&M, u0, t0, u1, un, t0 + un);\n\n\t  ASSERT (un < ualloc);\n\t  ASSERT ( (u0[un-1] | u1[un-1]) > 0);\n\t}\n      else\n\t{\n\t  /* mpn_hgcd has failed. Then either one of a or b is very\n\t     small, or the difference is very small. Perform one\n\t     subtraction followed by one division. */\n\t  ctx.u0 = u0;\n\t  ctx.u1 = u1;\n\t  ctx.tp = tp + n; /* ualloc */\n\t  ctx.un = un;\n\n\t  /* Temporary storage n */\n\t  n = mpn_gcd_subdiv_step (ap, bp, n, 0, mpn_gcdext_hook, &ctx, tp);\n\t  if (n == 0)\n\t    {\n\t      TMP_FREE;\n\t      return ctx.gn;\n\t    }\n\n\t  un = ctx.un;\n\t  ASSERT (un < ualloc);\n\t}\n    }\n  /* We have A = ... a + ... b\n\t     B =  u0 a +  u1 b\n\n\t     a = u1  A + ... B\n\t     b = -u0 A + ... B\n\n     with bounds\n\n       |u0|, |u1| <= B / min(a, b)\n\n     We always have u1 > 0, and u0 == 0 is possible only if u1 == 1,\n     in which case the only reduction done so far is a = A - k B for\n     some k.\n\n     Compute g = u a + v b = (u u1 - v u0) A + (...) B\n     Here, u, v are bounded by\n\n       |u| <= b,\n       |v| <= a\n  */\n\n  ASSERT ( (ap[n-1] | bp[n-1]) > 0);\n\n  if (UNLIKELY (mpn_cmp (ap, bp, n) == 0))\n    {\n      /* Must return the smallest cofactor, +u1 or -u0 */\n      int c;\n\n      MPN_COPY (gp, ap, n);\n\n      MPN_CMP (c, u0, u1, un);\n      /* c == 0 can happen only when A = (2k+1) G, B = 2 G. And in\n\t this case we choose the cofactor + 1, corresponding to G = A\n\t - k B, rather than -1, corresponding to G = - A + (k+1) B. */\n      ASSERT (c != 0 || (un == 1 && u0[0] == 1 && u1[0] == 1));\n      if (c < 0)\n\t{\n\t  MPN_NORMALIZE (u0, un);\n\t  MPN_COPY (up, u0, un);\n\t  *usizep = -un;\n\t}\n      else\n\t{\n\t  MPN_NORMALIZE_NOT_ZERO (u1, un);\n\t  MPN_COPY (up, u1, un);\n\t  *usizep = un;\n\t}\n\n      TMP_FREE;\n      return n;\n    }\n  else if (UNLIKELY (u0[0] == 0) && un == 1)\n    {\n      mp_size_t gn;\n      ASSERT (u1[0] == 1);\n\n      /* g = u a + v b = (u u1 - v u0) A + (...) B = u A + (...) B */\n      gn = mpn_gcdext_lehmer_n (gp, up, usizep, ap, bp, n, tp);\n\n      TMP_FREE;\n      return gn;\n    }\n  else\n    {\n      mp_size_t u0n;\n      mp_size_t u1n;\n      mp_size_t lehmer_un;\n      mp_size_t lehmer_vn;\n      mp_size_t gn;\n\n      mp_ptr lehmer_up;\n      mp_ptr lehmer_vp;\n      int negate;\n\n      lehmer_up = tp; tp += n;\n\n      /* Call mpn_gcdext_lehmer_n with copies of a and b. */\n      MPN_COPY (tp, ap, n);\n      MPN_COPY (tp + n, bp, n);\n      gn = mpn_gcdext_lehmer_n (gp, lehmer_up, &lehmer_un, tp, tp + n, n, tp + 2*n);\n\n      u0n = un;\n      MPN_NORMALIZE (u0, u0n);\n      ASSERT (u0n > 0);\n\n      if (lehmer_un == 0)\n\t{\n\t  /* u == 0  ==>  v = g / b == 1  ==> g = - u0 A + (...) B */\n\t  MPN_COPY (up, u0, u0n);\n\t  *usizep = -u0n;\n\n\t  TMP_FREE;\n\t  return gn;\n\t}\n\n      lehmer_vp = tp;\n      /* Compute v = (g - u a) / b */\n      lehmer_vn = compute_v (lehmer_vp,\n\t\t\t     ap, bp, n, gp, gn, lehmer_up, lehmer_un, tp + n + 1);\n\n      if (lehmer_un > 0)\n\tnegate = 0;\n      else\n\t{\n\t  lehmer_un = -lehmer_un;\n\t  negate = 1;\n\t}\n\n      u1n = un;\n      MPN_NORMALIZE (u1, u1n);\n      ASSERT (u1n > 0);\n\n      ASSERT (lehmer_un + u1n <= ualloc);\n      ASSERT (lehmer_vn + u0n <= ualloc);\n\n      /* We may still have v == 0 */\n\n      /* Compute u u0 */\n      if (lehmer_un <= u1n)\n\t/* Should be the common case */\n\tmpn_mul (up, u1, u1n, lehmer_up, lehmer_un);\n      else\n\tmpn_mul (up, lehmer_up, lehmer_un, u1, u1n);\n\n      un = u1n + lehmer_un;\n      un -= (up[un - 1] == 0);\n\n      if (lehmer_vn > 0)\n\t{\n\t  mp_limb_t cy;\n\n\t  /* Overwrites old u1 value */\n\t  if (lehmer_vn <= u0n)\n\t    /* Should be the common case */\n\t    mpn_mul (u1, u0, u0n, lehmer_vp, lehmer_vn);\n\t  else\n\t    mpn_mul (u1, lehmer_vp, lehmer_vn, u0, u0n);\n\n\t  u1n = u0n + lehmer_vn;\n\t  u1n -= (u1[u1n - 1] == 0);\n\n\t  if (u1n <= un)\n\t    {\n\t      cy = mpn_add (up, up, un, u1, u1n);\n\t    }\n\t  else\n\t    {\n\t      cy = mpn_add (up, u1, u1n, up, un);\n\t      un = u1n;\n\t    }\n\t  up[un] = cy;\n\t  un += (cy != 0);\n\n\t  ASSERT (un < ualloc);\n\t}\n      *usizep = negate ? -un : un;\n\n      TMP_FREE;\n      return gn;\n    }\n}",
      "lines": 361,
      "depth": 15,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/gcdext_1.c": {
    "mpn_gcdext_1": [
      {
        "start_point": [
          57,
          0
        ],
        "end_point": [
          266,
          1
        ],
        "content": "mp_limb_t\nmpn_gcdext_1 (mp_limb_signed_t *sp, mp_limb_signed_t *tp,\n\t      mp_limb_t u, mp_limb_t v)\n{\n  /* Maintain\n\n     U = t1 u + t0 v\n     V = s1 u + s0 v\n\n     where U, V are the inputs (without any shared power of two),\n     and the matrix has determinant \u00b1 2^{shift}.\n  */\n  mp_limb_t s0 = 1;\n  mp_limb_t t0 = 0;\n  mp_limb_t s1 = 0;\n  mp_limb_t t1 = 1;\n  mp_limb_t ug;\n  mp_limb_t vg;\n  mp_limb_t ugh;\n  mp_limb_t vgh;\n  unsigned zero_bits;\n  unsigned shift;\n  unsigned i;\n#if GCDEXT_1_BINARY_METHOD == 2\n  mp_limb_t det_sign;\n#endif\n\n  ASSERT (u > 0);\n  ASSERT (v > 0);\n\n  count_trailing_zeros (zero_bits, u | v);\n  u >>= zero_bits;\n  v >>= zero_bits;\n\n  if ((u & 1) == 0)\n    {\n      count_trailing_zeros (shift, u);\n      u >>= shift;\n      t1 <<= shift;\n    }\n  else if ((v & 1) == 0)\n    {\n      count_trailing_zeros (shift, v);\n      v >>= shift;\n      s0 <<= shift;\n    }\n  else\n    shift = 0;\n\n#if GCDEXT_1_BINARY_METHOD == 1\n  while (u != v)\n    {\n      unsigned count;\n      if (u > v)\n\t{\n\t  u -= v;\n#if USE_ZEROTAB\n\t  count = zerotab [u & 0x3f];\n\t  u >>= count;\n\t  if (UNLIKELY (count == 6))\n\t    {\n\t      unsigned c;\n\t      do\n\t\t{\n\t\t  c = zerotab[u & 0x3f];\n\t\t  u >>= c;\n\t\t  count += c;\n\t\t}\n\t      while (c == 6);\n\t    }\n#else\n\t  count_trailing_zeros (count, u);\n\t  u >>= count;\n#endif\n\t  t0 += t1; t1 <<= count;\n\t  s0 += s1; s1 <<= count;\n\t}\n      else\n\t{\n\t  v -= u;\n#if USE_ZEROTAB\n\t  count = zerotab [v & 0x3f];\n\t  v >>= count;\n\t  if (UNLIKELY (count == 6))\n\t    {\n\t      unsigned c;\n\t      do\n\t\t{\n\t\t  c = zerotab[v & 0x3f];\n\t\t  v >>= c;\n\t\t  count += c;\n\t\t}\n\t      while (c == 6);\n\t    }\n#else\n\t  count_trailing_zeros (count, v);\n\t  v >>= count;\n#endif\n\t  t1 += t0; t0 <<= count;\n\t  s1 += s0; s0 <<= count;\n\t}\n      shift += count;\n    }\n#else\n# if GCDEXT_1_BINARY_METHOD == 2\n  u >>= 1;\n  v >>= 1;\n\n  det_sign = 0;\n\n  while (u != v)\n    {\n      unsigned count;\n      mp_limb_t d =  u - v;\n      mp_limb_t vgtu = LIMB_HIGHBIT_TO_MASK (d);\n      mp_limb_t sx;\n      mp_limb_t tx;\n\n      /* When v <= u (vgtu == 0), the updates are:\n\n\t   (u; v)   <-- ( (u - v) >> count; v)    (det = +(1<<count) for corr. M factor)\n\t   (t1, t0) <-- (t1 << count, t0 + t1)\n\n\t and when v > 0, the updates are\n\n\t   (u; v)   <-- ( (v - u) >> count; u)    (det = -(1<<count))\n\t   (t1, t0) <-- (t0 << count, t0 + t1)\n\n\t and similarly for s1, s0\n      */\n\n      /* v <-- min (u, v) */\n      v += (vgtu & d);\n\n      /* u <-- |u - v| */\n      u = (d ^ vgtu) - vgtu;\n\n      /* Number of trailing zeros is the same no matter if we look at\n       * d or u, but using d gives more parallelism. */\n#if USE_ZEROTAB\n      count = zerotab[d & 0x3f];\n      if (UNLIKELY (count == 6))\n\t{\n\t  unsigned c = 6;\n\t  do\n\t    {\n\t      d >>= c;\n\t      c = zerotab[d & 0x3f];\n\t      count += c;\n\t    }\n\t  while (c == 6);\n\t}\n#else\n      count_trailing_zeros (count, d);\n#endif\n      det_sign ^= vgtu;\n\n      tx = vgtu & (t0 - t1);\n      sx = vgtu & (s0 - s1);\n      t0 += t1;\n      s0 += s1;\n      t1 += tx;\n      s1 += sx;\n\n      count++;\n      u >>= count;\n      t1 <<= count;\n      s1 <<= count;\n      shift += count;\n    }\n  u = (u << 1) + 1;\n# else /* GCDEXT_1_BINARY_METHOD == 2 */\n#  error Unknown GCDEXT_1_BINARY_METHOD\n# endif\n#endif\n\n  /* Now u = v = g = gcd (u,v). Compute U/g and V/g */\n  ug = t0 + t1;\n  vg = s0 + s1;\n\n  ugh = ug/2 + (ug & 1);\n  vgh = vg/2 + (vg & 1);\n\n  /* Now \u00b12^{shift} g = s0 U - t0 V. Get rid of the power of two, using\n     s0 U - t0 V = (s0 + V/g) U - (t0 + U/g) V. */\n  for (i = 0; i < shift; i++)\n    {\n      mp_limb_t mask = - ( (s0 | t0) & 1);\n\n      s0 /= 2;\n      t0 /= 2;\n      s0 += mask & vgh;\n      t0 += mask & ugh;\n    }\n  /* FIXME: Try simplifying this condition. */\n  if ( (s0 > 1 && 2*s0 >= vg) || (t0 > 1 && 2*t0 >= ug) )\n    {\n      s0 -= vg;\n      t0 -= ug;\n    }\n#if GCDEXT_1_BINARY_METHOD == 2\n  /* Conditional negation. */\n  s0 = (s0 ^ det_sign) - det_sign;\n  t0 = (t0 ^ det_sign) - det_sign;\n#endif\n  *sp = s0;\n  *tp = -t0;\n\n  return u << zero_bits;\n}",
        "lines": 210,
        "depth": 17,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          275,
          0
        ],
        "end_point": [
          326,
          1
        ],
        "content": "mp_limb_t\nmpn_gcdext_1 (mp_limb_signed_t *up, mp_limb_signed_t *vp,\n\t      mp_limb_t a, mp_limb_t b)\n{\n  /* Maintain\n\n     a =  u0 A + v0 B\n     b =  u1 A + v1 B\n\n     where A, B are the original inputs.\n  */\n  mp_limb_signed_t u0 = 1;\n  mp_limb_signed_t v0 = 0;\n  mp_limb_signed_t u1 = 0;\n  mp_limb_signed_t v1 = 1;\n\n  ASSERT (a > 0);\n  ASSERT (b > 0);\n\n  if (a < b)\n    goto divide_by_b;\n\n  for (;;)\n    {\n      mp_limb_t q;\n\n      q = a / b;\n      a -= q * b;\n\n      if (a == 0)\n\t{\n\t  *up = u1;\n\t  *vp = v1;\n\t  return b;\n\t}\n      u0 -= q * u1;\n      v0 -= q * v1;\n\n    divide_by_b:\n      q = b / a;\n      b -= q * a;\n\n      if (b == 0)\n\t{\n\t  *up = u0;\n\t  *vp = v0;\n\t  return a;\n\t}\n      u1 -= q * u0;\n      v1 -= q * v0;\n    }\n}",
        "lines": 52,
        "depth": 10,
        "decorators": [
          "mp_limb_t"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/gcdext_lehmer.c": {
    "mpn_gcdext_hook": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void\nmpn_gcdext_hook (void *p, mp_srcptr gp, mp_size_t gn,\n\t\t mp_srcptr qp, mp_size_t qn, int d)\n{\n  struct gcdext_ctx *ctx = (struct gcdext_ctx *) p;\n  mp_size_t un = ctx->un;\n\n  if (gp)\n    {\n      mp_srcptr up;\n\n      ASSERT (gn > 0);\n      ASSERT (gp[gn-1] > 0);\n\n      MPN_COPY (ctx->gp, gp, gn);\n      ctx->gn = gn;\n\n      if (d < 0)\n\t{\n\t  int c;\n\n\t  /* Must return the smallest cofactor, +u1 or -u0 */\n\t  MPN_CMP (c, ctx->u0, ctx->u1, un);\n\t  ASSERT (c != 0 || (un == 1 && ctx->u0[0] == 1 && ctx->u1[0] == 1));\n\n\t  d = c < 0;\n\t}\n\n      up = d ? ctx->u0 : ctx->u1;\n\n      MPN_NORMALIZE (up, un);\n      MPN_COPY (ctx->up, up, un);\n\n      *ctx->usize = d ? -un : un;\n    }\n  else\n    {\n      mp_limb_t cy;\n      mp_ptr u0 = ctx->u0;\n      mp_ptr u1 = ctx->u1;\n\n      ASSERT (d >= 0);\n\n      if (d)\n\tMP_PTR_SWAP (u0, u1);\n\n      qn -= (qp[qn-1] == 0);\n\n      /* Update u0 += q  * u1 */\n      if (qn == 1)\n\t{\n\t  mp_limb_t q = qp[0];\n\n\t  if (q == 1)\n\t    /* A common case. */\n\t    cy = mpn_add_n (u0, u0, u1, un);\n\t  else\n\t    cy = mpn_addmul_1 (u0, u1, un, q);\n\t}\n      else\n\t{\n\t  mp_size_t u1n;\n\t  mp_ptr tp;\n\n\t  u1n = un;\n\t  MPN_NORMALIZE (u1, u1n);\n\n\t  if (u1n == 0)\n\t    return;\n\n\t  /* Should always have u1n == un here, and u1 >= u0. The\n\t     reason is that we alternate adding u0 to u1 and u1 to u0\n\t     (corresponding to subtractions a - b and b - a), and we\n\t     can get a large quotient only just after a switch, which\n\t     means that we'll add (a multiple of) the larger u to the\n\t     smaller. */\n\n\t  tp = ctx->tp;\n\n\t  if (qn > u1n)\n\t    mpn_mul (tp, qp, qn, u1, u1n);\n\t  else\n\t    mpn_mul (tp, u1, u1n, qp, qn);\n\n\t  u1n += qn;\n\t  u1n -= tp[u1n-1] == 0;\n\n\t  if (u1n >= un)\n\t    {\n\t      cy = mpn_add (u0, tp, u1n, u0, un);\n\t      un = u1n;\n\t    }\n\t  else\n\t    /* Note: Unlikely case, maybe never happens? */\n\t    cy = mpn_add (u0, u0, un, tp, u1n);\n\n\t}\n      u0[un] = cy;\n      ctx->un = un + (cy > 0);\n    }\n}",
      "lines": 101,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "mpn_gcdext_lehmer_n": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "mp_size_t\nmpn_gcdext_lehmer_n (mp_ptr gp, mp_ptr up, mp_size_t *usize,\n\t\t     mp_ptr ap, mp_ptr bp, mp_size_t n,\n\t\t     mp_ptr tp)\n{\n  mp_size_t ualloc = n + 1;\n\n  /* Keeps track of the second row of the reduction matrix\n   *\n   *   M = (v0, v1 ; u0, u1)\n   *\n   * which correspond to the first column of the inverse\n   *\n   *   M^{-1} = (u1, -v1; -u0, v0)\n   *\n   * This implies that\n   *\n   *   a =  u1 A (mod B)\n   *   b = -u0 A (mod B)\n   *\n   * where A, B denotes the input values.\n   */\n\n  struct gcdext_ctx ctx;\n  mp_size_t un;\n  mp_ptr u0;\n  mp_ptr u1;\n  mp_ptr u2;\n\n  MPN_ZERO (tp, 3*ualloc);\n  u0 = tp; tp += ualloc;\n  u1 = tp; tp += ualloc;\n  u2 = tp; tp += ualloc;\n\n  u1[0] = 1; un = 1;\n\n  ctx.gp = gp;\n  ctx.up = up;\n  ctx.usize = usize;\n\n  /* FIXME: Handle n == 2 differently, after the loop? */\n  while (n >= 2)\n    {\n      struct hgcd_matrix1 M;\n      mp_limb_t ah, al, bh, bl;\n      mp_limb_t mask;\n\n      mask = ap[n-1] | bp[n-1];\n      ASSERT (mask > 0);\n\n      if (mask & GMP_NUMB_HIGHBIT)\n\t{\n\t  ah = ap[n-1]; al = ap[n-2];\n\t  bh = bp[n-1]; bl = bp[n-2];\n\t}\n      else if (n == 2)\n\t{\n\t  /* We use the full inputs without truncation, so we can\n\t     safely shift left. */\n\t  int shift;\n\n\t  count_leading_zeros (shift, mask);\n\t  ah = MPN_EXTRACT_NUMB (shift, ap[1], ap[0]);\n\t  al = ap[0] << shift;\n\t  bh = MPN_EXTRACT_NUMB (shift, bp[1], bp[0]);\n\t  bl = bp[0] << shift;\n\t}\n      else\n\t{\n\t  int shift;\n\n\t  count_leading_zeros (shift, mask);\n\t  ah = MPN_EXTRACT_NUMB (shift, ap[n-1], ap[n-2]);\n\t  al = MPN_EXTRACT_NUMB (shift, ap[n-2], ap[n-3]);\n\t  bh = MPN_EXTRACT_NUMB (shift, bp[n-1], bp[n-2]);\n\t  bl = MPN_EXTRACT_NUMB (shift, bp[n-2], bp[n-3]);\n\t}\n\n      /* Try an mpn_nhgcd2 step */\n      if (mpn_hgcd2 (ah, al, bh, bl, &M))\n\t{\n\t  n = mpn_matrix22_mul1_inverse_vector (&M, tp, ap, bp, n);\n\t  MP_PTR_SWAP (ap, tp);\n\t  un = mpn_hgcd_mul_matrix1_vector(&M, u2, u0, u1, un);\n\t  MP_PTR_SWAP (u0, u2);\n\t}\n      else\n\t{\n\t  /* mpn_hgcd2 has failed. Then either one of a or b is very\n\t     small, or the difference is very small. Perform one\n\t     subtraction followed by one division. */\n\t  ctx.u0 = u0;\n\t  ctx.u1 = u1;\n\t  ctx.tp = u2;\n\t  ctx.un = un;\n\n\t  /* Temporary storage n for the quotient and ualloc for the\n\t     new cofactor. */\n\t  n = mpn_gcd_subdiv_step (ap, bp, n, 0, mpn_gcdext_hook, &ctx, tp);\n\t  if (n == 0)\n\t    return ctx.gn;\n\n\t  un = ctx.un;\n\t}\n    }\n  ASSERT_ALWAYS (ap[0] > 0);\n  ASSERT_ALWAYS (bp[0] > 0);\n\n  if (ap[0] == bp[0])\n    {\n      int c;\n\n      /* Which cofactor to return now? Candidates are +u1 and -u0,\n\t depending on which of a and b was most recently reduced,\n\t which we don't keep track of. So compare and get the smallest\n\t one. */\n\n      gp[0] = ap[0];\n\n      MPN_CMP (c, u0, u1, un);\n      ASSERT (c != 0 || (un == 1 && u0[0] == 1 && u1[0] == 1));\n      if (c < 0)\n\t{\n\t  MPN_NORMALIZE (u0, un);\n\t  MPN_COPY (up, u0, un);\n\t  *usize = -un;\n\t}\n      else\n\t{\n\t  MPN_NORMALIZE_NOT_ZERO (u1, un);\n\t  MPN_COPY (up, u1, un);\n\t  *usize = un;\n\t}\n      return 1;\n    }\n  else\n    {\n      mp_limb_t uh, vh;\n      mp_limb_signed_t u;\n      mp_limb_signed_t v;\n      int negate;\n\n      gp[0] = mpn_gcdext_1 (&u, &v, ap[0], bp[0]);\n\n      /* Set up = u u1 - v u0. Keep track of size, un grows by one or\n\t two limbs. */\n\n      if (u == 0)\n\t{\n\t  ASSERT (v == 1);\n\t  MPN_NORMALIZE (u0, un);\n\t  MPN_COPY (up, u0, un);\n\t  *usize = -un;\n\t  return 1;\n\t}\n      else if (v == 0)\n\t{\n\t  ASSERT (u == 1);\n\t  MPN_NORMALIZE (u1, un);\n\t  MPN_COPY (up, u1, un);\n\t  *usize = un;\n\t  return 1;\n\t}\n      else if (u > 0)\n\t{\n\t  negate = 0;\n\t  ASSERT (v < 0);\n\t  v = -v;\n\t}\n      else\n\t{\n\t  negate = 1;\n\t  ASSERT (v > 0);\n\t  u = -u;\n\t}\n\n      uh = mpn_mul_1 (up, u1, un, u);\n      vh = mpn_addmul_1 (up, u0, un, v);\n\n      if ( (uh | vh) > 0)\n\t{\n\t  uh += vh;\n\t  up[un++] = uh;\n\t  if (uh < vh)\n\t    up[un++] = 1;\n\t}\n\n      MPN_NORMALIZE_NOT_ZERO (up, un);\n\n      *usize = negate ? -un : un;\n      return 1;\n    }\n}",
      "lines": 193,
      "depth": 14,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/gcd_1.c": {
    "mpn_gcd_1": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "mp_limb_t\nmpn_gcd_1 (mp_srcptr up, mp_size_t size, mp_limb_t vlimb)\n{\n  mp_limb_t      ulimb;\n  unsigned long  zero_bits, u_low_zero_bits;\n\n  ASSERT (size >= 1);\n  ASSERT (vlimb != 0);\n  ASSERT_MPN_NONZERO_P (up, size);\n\n  ulimb = up[0];\n\n  /* Need vlimb odd for modexact, want it odd to get common zeros. */\n  count_trailing_zeros (zero_bits, vlimb);\n  vlimb >>= zero_bits;\n\n  if (size > 1)\n    {\n      /* Must get common zeros before the mod reduction.  If ulimb==0 then\n\t vlimb already gives the common zeros.  */\n      if (ulimb != 0)\n\t{\n\t  count_trailing_zeros (u_low_zero_bits, ulimb);\n\t  zero_bits = MIN (zero_bits, u_low_zero_bits);\n\t}\n\n      ulimb = MPN_MOD_OR_MODEXACT_1_ODD (up, size, vlimb);\n      if (ulimb == 0)\n\tgoto done;\n\n      goto strip_u_maybe;\n    }\n\n  /* size==1, so up[0]!=0 */\n  count_trailing_zeros (u_low_zero_bits, ulimb);\n  ulimb >>= u_low_zero_bits;\n  zero_bits = MIN (zero_bits, u_low_zero_bits);\n\n  /* make u bigger */\n  if (vlimb > ulimb)\n    MP_LIMB_T_SWAP (ulimb, vlimb);\n\n  /* if u is much bigger than v, reduce using a division rather than\n     chipping away at it bit-by-bit */\n  if ((ulimb >> 16) > vlimb)\n    {\n      ulimb %= vlimb;\n      if (ulimb == 0)\n\tgoto done;\n      goto strip_u_maybe;\n    }\n\n  ASSERT (ulimb & 1);\n  ASSERT (vlimb & 1);\n\n#if GCD_1_METHOD == 1\n  while (ulimb != vlimb)\n    {\n      ASSERT (ulimb & 1);\n      ASSERT (vlimb & 1);\n\n      if (ulimb > vlimb)\n\t{\n\t  ulimb -= vlimb;\n\t  do\n\t    {\n\t      ulimb >>= 1;\n\t      ASSERT (ulimb != 0);\n\t    strip_u_maybe:\n\t      ;\n\t    }\n\t  while ((ulimb & 1) == 0);\n\t}\n      else /*  vlimb > ulimb.  */\n\t{\n\t  vlimb -= ulimb;\n\t  do\n\t    {\n\t      vlimb >>= 1;\n\t      ASSERT (vlimb != 0);\n\t    }\n\t  while ((vlimb & 1) == 0);\n\t}\n    }\n#else\n# if GCD_1_METHOD  == 2\n\n  ulimb >>= 1;\n  vlimb >>= 1;\n\n  while (ulimb != vlimb)\n    {\n      int c;\n      mp_limb_t t;\n      mp_limb_t vgtu;\n\n      t = ulimb - vlimb;\n      vgtu = LIMB_HIGHBIT_TO_MASK (t);\n\n      /* v <-- min (u, v) */\n      vlimb += (vgtu & t);\n\n      /* u <-- |u - v| */\n      ulimb = (t ^ vgtu) - vgtu;\n\n#if USE_ZEROTAB\n      /* Number of trailing zeros is the same no matter if we look at\n       * t or ulimb, but using t gives more parallelism. */\n      c = zerotab[t & MASK];\n\n      while (UNLIKELY (c == MAXSHIFT))\n\t{\n\t  ulimb >>= MAXSHIFT;\n\t  if (0)\n\t  strip_u_maybe:\n\t    vlimb >>= 1;\n\n\t  c = zerotab[ulimb & MASK];\n\t}\n#else\n      if (0)\n\t{\n\tstrip_u_maybe:\n\t  vlimb >>= 1;\n\t  t = ulimb;\n\t}\n      count_trailing_zeros (c, t);\n#endif\n      ulimb >>= (c + 1);\n    }\n\n  vlimb = (vlimb << 1) | 1;\n# else\n#  error Unknown GCD_1_METHOD\n# endif\n#endif\n\n done:\n  return vlimb << zero_bits;\n}",
      "lines": 140,
      "depth": 15,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/gcd_subdiv_step.c": {
    "mpn_gcd_subdiv_step": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "mp_size_t\nmpn_gcd_subdiv_step (mp_ptr ap, mp_ptr bp, mp_size_t n, mp_size_t s,\n\t\t     gcd_subdiv_step_hook *hook, void *ctx,\n\t\t     mp_ptr tp)\n{\n  static const mp_limb_t one = CNST_LIMB(1);\n  mp_size_t an, bn, qn;\n\n  int swapped;\n\n  ASSERT (n > 0);\n  ASSERT (ap[n-1] > 0 || bp[n-1] > 0);\n\n  an = bn = n;\n  MPN_NORMALIZE (ap, an);\n  MPN_NORMALIZE (bp, bn);\n\n  swapped = 0;\n\n  /* Arrange so that a < b, subtract b -= a, and maintain\n     normalization. */\n  if (an == bn)\n    {\n      int c;\n      MPN_CMP (c, ap, bp, an);\n      if (UNLIKELY (c == 0))\n\t{\n\t  /* For gcdext, return the smallest of the two cofactors, so\n\t     pass d = -1. */\n\t  if (s == 0)\n\t    hook (ctx, ap, an, NULL, 0, -1);\n\t  return 0;\n\t}\n      else if (c > 0)\n\t{\n\t  MP_PTR_SWAP (ap, bp);\n\t  swapped ^= 1;\n\t}\n    }\n  else\n    {\n      if (an > bn)\n\t{\n\t  MPN_PTR_SWAP (ap, an, bp, bn);\n\t  swapped ^= 1;\n\t}\n    }\n  if (an <= s)\n    {\n      if (s == 0)\n\thook (ctx, bp, bn, NULL, 0, swapped ^ 1);\n      return 0;\n    }\n\n  ASSERT_NOCARRY (mpn_sub (bp, bp, bn, ap, an));\n  MPN_NORMALIZE (bp, bn);\n  ASSERT (bn > 0);\n\n  if (bn <= s)\n    {\n      /* Undo subtraction. */\n      mp_limb_t cy = mpn_add (bp, ap, an, bp, bn);\n      if (cy > 0)\n\tbp[an] = cy;\n      return 0;\n    }\n\n  /* Arrange so that a < b */\n  if (an == bn)\n    {\n      int c;\n      MPN_CMP (c, ap, bp, an);\n      if (UNLIKELY (c == 0))\n\t{\n\t  if (s > 0)\n\t    /* Just record subtraction and return */\n\t    hook (ctx, NULL, 0, &one, 1, swapped);\n\t  else\n\t    /* Found gcd. */\n\t    hook (ctx, bp, bn, NULL, 0, swapped);\n\t  return 0;\n\t}\n\n      hook (ctx, NULL, 0, &one, 1, swapped);\n\n      if (c > 0)\n\t{\n\t  MP_PTR_SWAP (ap, bp);\n\t  swapped ^= 1;\n\t}\n    }\n  else\n    {\n      hook (ctx, NULL, 0, &one, 1, swapped);\n\n      if (an > bn)\n\t{\n\t  MPN_PTR_SWAP (ap, an, bp, bn);\n\t  swapped ^= 1;\n\t}\n    }\n\n  mpn_tdiv_qr (tp, bp, 0, bp, bn, ap, an);\n  qn = bn - an + 1;\n  bn = an;\n  MPN_NORMALIZE (bp, bn);\n\n  if (UNLIKELY (bn <= s))\n    {\n      if (s == 0)\n\t{\n\t  hook (ctx, ap, an, tp, qn, swapped);\n\t  return 0;\n\t}\n\n      /* Quotient is one too large, so decrement it and add back A. */\n      if (bn > 0)\n\t{\n\t  mp_limb_t cy = mpn_add (bp, ap, an, bp, bn);\n\t  if (cy)\n\t    bp[an++] = cy;\n\t}\n      else\n\tMPN_COPY (bp, ap, an);\n\n      MPN_DECR_U (tp, qn, 1);\n    }\n\n  hook (ctx, NULL, 0, tp, qn, swapped);\n  return an;\n}",
      "lines": 131,
      "depth": 12,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/get_d.c": {
    "mpn_get_d": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "double\nmpn_get_d (mp_srcptr up, mp_size_t size, mp_size_t sign, long exp)\n{\n  int lshift, nbits;\n  mp_limb_t x, mhi, mlo;\n\n  ASSERT (size >= 0);\n  ASSERT_MPN (up, size);\n  ASSERT (size == 0 || up[size-1] != 0);\n\n  if (size == 0)\n    return 0.0;\n\n  /* Adjust exp to a radix point just above {up,size}, guarding against\n     overflow.  After this exp can of course be reduced to anywhere within\n     the {up,size} region without underflow.  */\n  if (UNLIKELY ((unsigned long) (GMP_NUMB_BITS * size)\n\t\t> ((unsigned long) LONG_MAX - exp)))\n    {\n#if _GMP_IEEE_FLOATS\n      goto ieee_infinity;\n#endif\n\n      /* generic */\n      exp = LONG_MAX;\n    }\n  else\n    {\n      exp += GMP_NUMB_BITS * size;\n    }\n\n#if _GMP_IEEE_FLOATS\n    {\n      union ieee_double_extract u;\n\n      up += size;\n\n#if GMP_LIMB_BITS == 64\n      mlo = up[-1];\n      count_leading_zeros (lshift, mlo);\n\n      exp -= (lshift - GMP_NAIL_BITS) + 1;\n      mlo <<= lshift;\n\n      nbits = GMP_LIMB_BITS - lshift;\n\n      if (nbits < 53 && size > 1)\n\t{\n\t  x = up[-2];\n\t  x <<= GMP_NAIL_BITS;\n\t  x >>= nbits;\n\t  mlo |= x;\n\t  nbits += GMP_NUMB_BITS;\n\n\t  if (LIMBS_PER_DOUBLE >= 3 && nbits < 53 && size > 2)\n\t    {\n\t      x = up[-3];\n\t      x <<= GMP_NAIL_BITS;\n\t      x >>= nbits;\n\t      mlo |= x;\n\t      nbits += GMP_NUMB_BITS;\n\t    }\n\t}\n      mhi = mlo >> (32 + 11);\n      mlo = mlo >> 11;\t\t/* later implicitly truncated to 32 bits */\n#endif\n#if GMP_LIMB_BITS == 32\n      x = *--up;\n      count_leading_zeros (lshift, x);\n\n      exp -= (lshift - GMP_NAIL_BITS) + 1;\n      x <<= lshift;\n      mhi = x >> 11;\n\n      if (lshift < 11)\t\t/* FIXME: never true if NUMB < 20 bits */\n\t{\n\t  /* All 20 bits in mhi */\n\t  mlo = x << 21;\n\t  /* >= 1 bit in mlo */\n\t  nbits = GMP_LIMB_BITS - lshift - 21;\n\t}\n      else\n\t{\n\t  if (size > 1)\n\t    {\n\t      nbits = GMP_LIMB_BITS - lshift;\n\n\t      x = *--up, size--;\n\t      x <<= GMP_NAIL_BITS;\n\t      mhi |= x >> nbits >> 11;\n\n\t      mlo = x << GMP_LIMB_BITS - nbits - 11;\n\t      nbits = nbits + 11 - GMP_NAIL_BITS;\n\t    }\n\t  else\n\t    {\n\t      mlo = 0;\n\t      goto done;\n\t    }\n\t}\n\n      /* Now all needed bits in mhi have been accumulated.  Add bits to mlo.  */\n\n      if (LIMBS_PER_DOUBLE >= 2 && nbits < 32 && size > 1)\n\t{\n\t  x = up[-1];\n\t  x <<= GMP_NAIL_BITS;\n\t  x >>= nbits;\n\t  mlo |= x;\n\t  nbits += GMP_NUMB_BITS;\n\n\t  if (LIMBS_PER_DOUBLE >= 3 && nbits < 32 && size > 2)\n\t    {\n\t      x = up[-2];\n\t      x <<= GMP_NAIL_BITS;\n\t      x >>= nbits;\n\t      mlo |= x;\n\t      nbits += GMP_NUMB_BITS;\n\n\t      if (LIMBS_PER_DOUBLE >= 4 && nbits < 32 && size > 3)\n\t\t{\n\t\t  x = up[-3];\n\t\t  x <<= GMP_NAIL_BITS;\n\t\t  x >>= nbits;\n\t\t  mlo |= x;\n\t\t  nbits += GMP_NUMB_BITS;\n\t\t}\n\t    }\n\t}\n\n    done:;\n\n#endif\n      if (UNLIKELY (exp >= CONST_1024))\n\t{\n\t  /* overflow, return infinity */\n\tieee_infinity:\n\t  mhi = 0;\n\t  mlo = 0;\n\t  exp = 1024;\n\t}\n      else if (UNLIKELY (exp <= CONST_NEG_1023))\n\t{\n\t  int rshift;\n\n\t  if (LIKELY (exp <= CONST_NEG_1022_SUB_53))\n\t    return 0.0;\t /* denorm underflows to zero */\n\n\t  rshift = -1022 - exp;\n\t  ASSERT (rshift > 0 && rshift < 53);\n#if GMP_LIMB_BITS > 53\n\t  mlo >>= rshift;\n\t  mhi = mlo >> 32;\n#else\n\t  if (rshift >= 32)\n\t    {\n\t      mlo = mhi;\n\t      mhi = 0;\n\t      rshift -= 32;\n\t    }\n\t  lshift = GMP_LIMB_BITS - rshift;\n\t  mlo = (mlo >> rshift) | (rshift == 0 ? 0 : mhi << lshift);\n\t  mhi >>= rshift;\n#endif\n\t  exp = -1023;\n\t}\n      u.s.manh = mhi;\n      u.s.manl = mlo;\n      u.s.exp = exp + 1023;\n      u.s.sig = (sign < 0);\n      return u.d;\n    }\n#define FORMAT_RECOGNIZED 1\n#endif\n\n#if HAVE_DOUBLE_VAX_D\n    {\n      union double_extract u;\n\n      up += size;\n\n      mhi = up[-1];\n\n      count_leading_zeros (lshift, mhi);\n      exp -= lshift;\n      mhi <<= lshift;\n\n      mlo = 0;\n      if (size > 1)\n\t{\n\t  mlo = up[-2];\n\t  if (lshift != 0)\n\t    mhi += mlo >> (GMP_LIMB_BITS - lshift);\n\t  mlo <<= lshift;\n\n\t  if (size > 2 && lshift > 8)\n\t    {\n\t      x = up[-3];\n\t      mlo += x >> (GMP_LIMB_BITS - lshift);\n\t    }\n\t}\n\n      if (UNLIKELY (exp >= 128))\n\t{\n\t  /* overflow, return maximum number */\n\t  mhi = 0xffffffff;\n\t  mlo = 0xffffffff;\n\t  exp = 127;\n\t}\n      else if (UNLIKELY (exp < -128))\n\t{\n\t  return 0.0;\t /* underflows to zero */\n\t}\n\n      u.s.man3 = mhi >> 24;\t/* drop msb, since implicit */\n      u.s.man2 = mhi >> 8;\n      u.s.man1 = (mhi << 8) + (mlo >> 24);\n      u.s.man0 = mlo >> 8;\n      u.s.exp = exp + 128;\n      u.s.sig = sign < 0;\n      return u.d;\n    }\n#define FORMAT_RECOGNIZED 1\n#endif\n\n#if ! FORMAT_RECOGNIZED\n    {      /* Non-IEEE or strange limb size, do something generic. */\n      mp_size_t i;\n      double d, weight;\n      unsigned long uexp;\n\n      /* First generate an fp number disregarding exp, instead keeping things\n\t within the numb base factor from 1, which should prevent overflow and\n\t underflow even for the most exponent limited fp formats.  The\n\t termination criteria should be refined, since we now include too many\n\t limbs.  */\n      weight = 1/MP_BASE_AS_DOUBLE;\n      d = up[size - 1];\n      for (i = size - 2; i >= 0; i--)\n\t{\n\t  d += up[i] * weight;\n\t  weight /= MP_BASE_AS_DOUBLE;\n\t  if (weight == 0)\n\t    break;\n\t}\n\n      /* Now apply exp.  */\n      exp -= GMP_NUMB_BITS;\n      if (exp > 0)\n\t{\n\t  weight = 2.0;\n\t  uexp = exp;\n\t}\n      else\n\t{\n\t  weight = 0.5;\n\t  uexp = 1 - (unsigned long) (exp + 1);\n\t}\n#if 1\n      /* Square-and-multiply exponentiation.  */\n      if (uexp & 1)\n\td *= weight;\n      while (uexp >>= 1)\n\t{\n\t  weight *= weight;\n\t  if (uexp & 1)\n\t    d *= weight;\n\t}\n#else\n      /* Plain exponentiation.  */\n      while (uexp > 0)\n\t{\n\t  d *= weight;\n\t  uexp--;\n\t}\n#endif\n\n      return sign >= 0 ? d : -d;\n    }\n#endif\n}",
      "lines": 281,
      "depth": 16,
      "decorators": [
        "double"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/get_str.c": {
    "mpn_sb_get_str": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "static unsigned char *\nmpn_sb_get_str (unsigned char *str, size_t len,\n\t\tmp_ptr up, mp_size_t un, int base)\n{\n  mp_limb_t rl, ul;\n  unsigned char *s;\n  size_t l;\n  /* Allocate memory for largest possible string, given that we only get here\n     for operands with un < GET_STR_PRECOMPUTE_THRESHOLD and that the smallest\n     base is 3.  7/11 is an approximation to 1/log2(3).  */\n#if TUNE_PROGRAM_BUILD\n#define BUF_ALLOC (GET_STR_THRESHOLD_LIMIT * GMP_LIMB_BITS * 7 / 11)\n#else\n#define BUF_ALLOC (GET_STR_PRECOMPUTE_THRESHOLD * GMP_LIMB_BITS * 7 / 11)\n#endif\n  unsigned char buf[BUF_ALLOC];\n#if TUNE_PROGRAM_BUILD\n  mp_limb_t rp[GET_STR_THRESHOLD_LIMIT];\n#else\n  mp_limb_t rp[GET_STR_PRECOMPUTE_THRESHOLD];\n#endif\n\n  if (base == 10)\n    {\n      /* Special case code for base==10 so that the compiler has a chance to\n\t optimize things.  */\n\n      MPN_COPY (rp + 1, up, un);\n\n      s = buf + BUF_ALLOC;\n      while (un > 1)\n\t{\n\t  int i;\n\t  mp_limb_t frac, digit;\n\t  MPN_DIVREM_OR_PREINV_DIVREM_1 (rp, (mp_size_t) 1, rp + 1, un,\n\t\t\t\t\t MP_BASES_BIG_BASE_10,\n\t\t\t\t\t MP_BASES_BIG_BASE_INVERTED_10,\n\t\t\t\t\t MP_BASES_NORMALIZATION_STEPS_10);\n\t  un -= rp[un] == 0;\n\t  frac = (rp[0] + 1) << GMP_NAIL_BITS;\n\t  s -= MP_BASES_CHARS_PER_LIMB_10;\n#if HAVE_HOST_CPU_FAMILY_x86\n\t  /* The code below turns out to be a bit slower for x86 using gcc.\n\t     Use plain code.  */\n\t  i = MP_BASES_CHARS_PER_LIMB_10;\n\t  do\n\t    {\n\t      umul_ppmm (digit, frac, frac, 10);\n\t      *s++ = digit;\n\t    }\n\t  while (--i);\n#else\n\t  /* Use the fact that 10 in binary is 1010, with the lowest bit 0.\n\t     After a few umul_ppmm, we will have accumulated enough low zeros\n\t     to use a plain multiply.  */\n\t  if (MP_BASES_NORMALIZATION_STEPS_10 == 0)\n\t    {\n\t      umul_ppmm (digit, frac, frac, 10);\n\t      *s++ = digit;\n\t    }\n\t  if (MP_BASES_NORMALIZATION_STEPS_10 <= 1)\n\t    {\n\t      umul_ppmm (digit, frac, frac, 10);\n\t      *s++ = digit;\n\t    }\n\t  if (MP_BASES_NORMALIZATION_STEPS_10 <= 2)\n\t    {\n\t      umul_ppmm (digit, frac, frac, 10);\n\t      *s++ = digit;\n\t    }\n\t  if (MP_BASES_NORMALIZATION_STEPS_10 <= 3)\n\t    {\n\t      umul_ppmm (digit, frac, frac, 10);\n\t      *s++ = digit;\n\t    }\n\t  i = (MP_BASES_CHARS_PER_LIMB_10 - ((MP_BASES_NORMALIZATION_STEPS_10 < 4)\n\t\t\t\t\t     ? (4-MP_BASES_NORMALIZATION_STEPS_10)\n\t\t\t\t\t     : 0));\n\t  frac = (frac + 0xf) >> 4;\n\t  do\n\t    {\n\t      frac *= 10;\n\t      digit = frac >> (GMP_LIMB_BITS - 4);\n\t      *s++ = digit;\n\t      frac &= (~(mp_limb_t) 0) >> 4;\n\t    }\n\t  while (--i);\n#endif\n\t  s -= MP_BASES_CHARS_PER_LIMB_10;\n\t}\n\n      ul = rp[1];\n      while (ul != 0)\n\t{\n\t  udiv_qrnd_unnorm (ul, rl, ul, 10);\n\t  *--s = rl;\n\t}\n    }\n  else /* not base 10 */\n    {\n      unsigned chars_per_limb;\n      mp_limb_t big_base, big_base_inverted;\n      unsigned normalization_steps;\n\n      chars_per_limb = mp_bases[base].chars_per_limb;\n      big_base = mp_bases[base].big_base;\n      big_base_inverted = mp_bases[base].big_base_inverted;\n      count_leading_zeros (normalization_steps, big_base);\n\n      MPN_COPY (rp + 1, up, un);\n\n      s = buf + BUF_ALLOC;\n      while (un > 1)\n\t{\n\t  int i;\n\t  mp_limb_t frac;\n\t  MPN_DIVREM_OR_PREINV_DIVREM_1 (rp, (mp_size_t) 1, rp + 1, un,\n\t\t\t\t\t big_base, big_base_inverted,\n\t\t\t\t\t normalization_steps);\n\t  un -= rp[un] == 0;\n\t  frac = (rp[0] + 1) << GMP_NAIL_BITS;\n\t  s -= chars_per_limb;\n\t  i = chars_per_limb;\n\t  do\n\t    {\n\t      mp_limb_t digit;\n\t      umul_ppmm (digit, frac, frac, base);\n\t      *s++ = digit;\n\t    }\n\t  while (--i);\n\t  s -= chars_per_limb;\n\t}\n\n      ul = rp[1];\n      while (ul != 0)\n\t{\n\t  udiv_qrnd_unnorm (ul, rl, ul, base);\n\t  *--s = rl;\n\t}\n    }\n\n  l = buf + BUF_ALLOC - s;\n  while (l < len)\n    {\n      *str++ = 0;\n      len--;\n    }\n  while (l != 0)\n    {\n      *str++ = *s++;\n      l--;\n    }\n  return str;\n}",
      "lines": 154,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "*\nmpn_sb_get_str (unsigned char *str, size_t len,\n\t\tmp_ptr up, mp_size_t un, int base)",
        "*"
      ]
    },
    "mpn_dc_get_str": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "static unsigned char *\nmpn_dc_get_str (unsigned char *str, size_t len,\n\t\tmp_ptr up, mp_size_t un,\n\t\tconst powers_t *powtab, mp_ptr tmp)\n{\n  if (BELOW_THRESHOLD (un, GET_STR_DC_THRESHOLD))\n    {\n      if (un != 0)\n\tstr = mpn_sb_get_str (str, len, up, un, powtab->base);\n      else\n\t{\n\t  while (len != 0)\n\t    {\n\t      *str++ = 0;\n\t      len--;\n\t    }\n\t}\n    }\n  else\n    {\n      mp_ptr pwp, qp, rp;\n      mp_size_t pwn, qn;\n      mp_size_t sn;\n\n      pwp = powtab->p;\n      pwn = powtab->n;\n      sn = powtab->shift;\n\n      if (un < pwn + sn || (un == pwn + sn && mpn_cmp (up + sn, pwp, un - sn) < 0))\n\t{\n\t  str = mpn_dc_get_str (str, len, up, un, powtab - 1, tmp);\n\t}\n      else\n\t{\n\t  qp = tmp;\t\t/* (un - pwn + 1) limbs for qp */\n\t  rp = up;\t\t/* pwn limbs for rp; overwrite up area */\n\n\t  mpn_tdiv_qr (qp, rp + sn, 0L, up + sn, un - sn, pwp, pwn);\n\t  qn = un - sn - pwn; qn += qp[qn] != 0;\t\t/* quotient size */\n\n\t  ASSERT (qn < pwn + sn || (qn == pwn + sn && mpn_cmp (qp + sn, pwp, pwn) < 0));\n\n\t  if (len != 0)\n\t    len = len - powtab->digits_in_base;\n\n\t  str = mpn_dc_get_str (str, len, qp, qn, powtab - 1, tmp + qn);\n\t  str = mpn_dc_get_str (str, powtab->digits_in_base, rp, pwn + sn, powtab - 1, tmp);\n\t}\n    }\n  return str;\n}",
      "lines": 51,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "*\nmpn_dc_get_str (unsigned char *str, size_t len,\n\t\tmp_ptr up, mp_size_t un,\n\t\tconst powers_t *powtab, mp_ptr tmp)",
        "*"
      ]
    },
    "mpn_get_str": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "size_t\nmpn_get_str (unsigned char *str, int base, mp_ptr up, mp_size_t un)\n{\n  mp_ptr powtab_mem, powtab_mem_ptr;\n  mp_limb_t big_base;\n  size_t digits_in_base;\n  powers_t powtab[GMP_LIMB_BITS];\n  int pi;\n  mp_size_t n;\n  mp_ptr p, t;\n  size_t out_len;\n  mp_ptr tmp;\n  TMP_DECL;\n\n  /* Special case zero, as the code below doesn't handle it.  */\n  if (un == 0)\n    {\n      str[0] = 0;\n      return 1;\n    }\n\n  if (POW2_P (base))\n    {\n      /* The base is a power of 2.  Convert from most significant end.  */\n      mp_limb_t n1, n0;\n      int bits_per_digit = mp_bases[base].big_base;\n      int cnt;\n      int bit_pos;\n      mp_size_t i;\n      unsigned char *s = str;\n      mp_bitcnt_t bits;\n\n      n1 = up[un - 1];\n      count_leading_zeros (cnt, n1);\n\n      /* BIT_POS should be R when input ends in least significant nibble,\n\t R + bits_per_digit * n when input ends in nth least significant\n\t nibble. */\n\n      bits = (mp_bitcnt_t) GMP_NUMB_BITS * un - cnt + GMP_NAIL_BITS;\n      cnt = bits % bits_per_digit;\n      if (cnt != 0)\n\tbits += bits_per_digit - cnt;\n      bit_pos = bits - (mp_bitcnt_t) (un - 1) * GMP_NUMB_BITS;\n\n      /* Fast loop for bit output.  */\n      i = un - 1;\n      for (;;)\n\t{\n\t  bit_pos -= bits_per_digit;\n\t  while (bit_pos >= 0)\n\t    {\n\t      *s++ = (n1 >> bit_pos) & ((1 << bits_per_digit) - 1);\n\t      bit_pos -= bits_per_digit;\n\t    }\n\t  i--;\n\t  if (i < 0)\n\t    break;\n\t  n0 = (n1 << -bit_pos) & ((1 << bits_per_digit) - 1);\n\t  n1 = up[i];\n\t  bit_pos += GMP_NUMB_BITS;\n\t  *s++ = n0 | (n1 >> bit_pos);\n\t}\n\n      return s - str;\n    }\n\n  /* General case.  The base is not a power of 2.  */\n\n  if (BELOW_THRESHOLD (un, GET_STR_PRECOMPUTE_THRESHOLD))\n    return mpn_sb_get_str (str, (size_t) 0, up, un, base) - str;\n\n  TMP_MARK;\n\n  /* Allocate one large block for the powers of big_base.  */\n  powtab_mem = TMP_BALLOC_LIMBS (mpn_dc_get_str_powtab_alloc (un));\n  powtab_mem_ptr = powtab_mem;\n\n  /* Compute a table of powers, were the largest power is >= sqrt(U).  */\n\n  big_base = mp_bases[base].big_base;\n  digits_in_base = mp_bases[base].chars_per_limb;\n\n  {\n    mp_size_t n_pows, xn, pn, exptab[GMP_LIMB_BITS], bexp;\n    mp_limb_t cy;\n    mp_size_t shift;\n    size_t ndig;\n\n    DIGITS_IN_BASE_PER_LIMB (ndig, un, base);\n    xn = 1 + ndig / mp_bases[base].chars_per_limb; /* FIXME: scalar integer division */\n\n    n_pows = 0;\n    for (pn = xn; pn != 1; pn = (pn + 1) >> 1)\n      {\n\texptab[n_pows] = pn;\n\tn_pows++;\n      }\n    exptab[n_pows] = 1;\n\n    powtab[0].p = &big_base;\n    powtab[0].n = 1;\n    powtab[0].digits_in_base = digits_in_base;\n    powtab[0].base = base;\n    powtab[0].shift = 0;\n\n    powtab[1].p = powtab_mem_ptr;  powtab_mem_ptr += 2;\n    powtab[1].p[0] = big_base;\n    powtab[1].n = 1;\n    powtab[1].digits_in_base = digits_in_base;\n    powtab[1].base = base;\n    powtab[1].shift = 0;\n\n    n = 1;\n    p = &big_base;\n    bexp = 1;\n    shift = 0;\n    for (pi = 2; pi < n_pows; pi++)\n      {\n\tt = powtab_mem_ptr;\n\tpowtab_mem_ptr += 2 * n + 2;\n\n\tASSERT_ALWAYS (powtab_mem_ptr < powtab_mem + mpn_dc_get_str_powtab_alloc (un));\n\n\tmpn_sqr (t, p, n);\n\n\tdigits_in_base *= 2;\n\tn *= 2;  n -= t[n - 1] == 0;\n\tbexp *= 2;\n\n\tif (bexp + 1 < exptab[n_pows - pi])\n\t  {\n\t    digits_in_base += mp_bases[base].chars_per_limb;\n\t    cy = mpn_mul_1 (t, t, n, big_base);\n\t    t[n] = cy;\n\t    n += cy != 0;\n\t    bexp += 1;\n\t  }\n\tshift *= 2;\n\t/* Strip low zero limbs.  */\n\twhile (t[0] == 0)\n\t  {\n\t    t++;\n\t    n--;\n\t    shift++;\n\t  }\n\tp = t;\n\tpowtab[pi].p = p;\n\tpowtab[pi].n = n;\n\tpowtab[pi].digits_in_base = digits_in_base;\n\tpowtab[pi].base = base;\n\tpowtab[pi].shift = shift;\n      }\n\n    for (pi = 1; pi < n_pows; pi++)\n      {\n\tt = powtab[pi].p;\n\tn = powtab[pi].n;\n\tcy = mpn_mul_1 (t, t, n, big_base);\n\tt[n] = cy;\n\tn += cy != 0;\n\tif (t[0] == 0)\n\t  {\n\t    powtab[pi].p = t + 1;\n\t    n--;\n\t    powtab[pi].shift++;\n\t  }\n\tpowtab[pi].n = n;\n\tpowtab[pi].digits_in_base += mp_bases[base].chars_per_limb;\n      }\n\n#if 0\n    { int i;\n      printf (\"Computed table values for base=%d, un=%d, xn=%d:\\n\", base, un, xn);\n      for (i = 0; i < n_pows; i++)\n\tprintf (\"%2d: %10ld %10ld %11ld %ld\\n\", i, exptab[n_pows-i], powtab[i].n, powtab[i].digits_in_base, powtab[i].shift);\n    }\n#endif\n  }\n\n  /* Using our precomputed powers, now in powtab[], convert our number.  */\n  tmp = TMP_BALLOC_LIMBS (mpn_dc_get_str_itch (un));\n  out_len = mpn_dc_get_str (str, 0, up, un, powtab + (pi - 1), tmp) - str;\n  TMP_FREE;\n\n  return out_len;\n}",
      "lines": 187,
      "depth": 16,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/generic/hgcd.c": {
    "mpn_hgcd_itch": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "mp_size_t\nmpn_hgcd_itch (mp_size_t n)\n{\n  unsigned k;\n  int count;\n  mp_size_t nscaled;\n\n  if (BELOW_THRESHOLD (n, HGCD_THRESHOLD))\n    return n;\n\n  /* Get the recursion depth. */\n  nscaled = (n - 1) / (HGCD_THRESHOLD - 1);\n  count_leading_zeros (count, nscaled);\n  k = GMP_LIMB_BITS - count;\n\n  return 20 * ((n+3) / 4) + 22 * k + HGCD_THRESHOLD;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_hgcd": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "mp_size_t\nmpn_hgcd (mp_ptr ap, mp_ptr bp, mp_size_t n,\n\t  struct hgcd_matrix *M, mp_ptr tp)\n{\n  mp_size_t s = n/2 + 1;\n\n  mp_size_t nn;\n  int success = 0;\n\n  if (n <= s)\n    /* Happens when n <= 2, a fairly uninteresting case but exercised\n       by the random inputs of the testsuite. */\n    return 0;\n\n  ASSERT ((ap[n-1] | bp[n-1]) > 0);\n\n  ASSERT ((n+1)/2 - 1 < M->alloc);\n\n  if (ABOVE_THRESHOLD (n, HGCD_THRESHOLD))\n    {\n      mp_size_t n2 = (3*n)/4 + 1;\n      mp_size_t p = n/2;\n\n      nn = mpn_hgcd_reduce (M, ap, bp, n, p, tp);\n      if (nn)\n\t{\n\t  n = nn;\n\t  success = 1;\n\t}\n\n      /* NOTE: It appears this loop never runs more than once (at\n\t least when not recursing to hgcd_appr). */\n      while (n > n2)\n\t{\n\t  /* Needs n + 1 storage */\n\t  nn = mpn_hgcd_step (n, ap, bp, s, M, tp);\n\t  if (!nn)\n\t    return success ? n : 0;\n\n\t  n = nn;\n\t  success = 1;\n\t}\n\n      if (n > s + 2)\n\t{\n\t  struct hgcd_matrix M1;\n\t  mp_size_t scratch;\n\n\t  p = 2*s - n + 1;\n\t  scratch = MPN_HGCD_MATRIX_INIT_ITCH (n-p);\n\n\t  mpn_hgcd_matrix_init(&M1, n - p, tp);\n\n\t  /* FIXME: Should use hgcd_reduce, but that may require more\n\t     scratch space, which requires review. */\n\n\t  nn = mpn_hgcd (ap + p, bp + p, n - p, &M1, tp + scratch);\n\t  if (nn > 0)\n\t    {\n\t      /* We always have max(M) > 2^{-(GMP_NUMB_BITS + 1)} max(M1) */\n\t      ASSERT (M->n + 2 >= M1.n);\n\n\t      /* Furthermore, assume M ends with a quotient (1, q; 0, 1),\n\t\t then either q or q + 1 is a correct quotient, and M1 will\n\t\t start with either (1, 0; 1, 1) or (2, 1; 1, 1). This\n\t\t rules out the case that the size of M * M1 is much\n\t\t smaller than the expected M->n + M1->n. */\n\n\t      ASSERT (M->n + M1.n < M->alloc);\n\n\t      /* Needs 2 (p + M->n) <= 2 (2*s - n2 + 1 + n2 - s - 1)\n\t\t = 2*s <= 2*(floor(n/2) + 1) <= n + 2. */\n\t      n = mpn_hgcd_matrix_adjust (&M1, p + nn, ap, bp, p, tp + scratch);\n\n\t      /* We need a bound for of M->n + M1.n. Let n be the original\n\t\t input size. Then\n\n\t\t ceil(n/2) - 1 >= size of product >= M.n + M1.n - 2\n\n\t\t and it follows that\n\n\t\t M.n + M1.n <= ceil(n/2) + 1\n\n\t\t Then 3*(M.n + M1.n) + 5 <= 3 * ceil(n/2) + 8 is the\n\t\t amount of needed scratch space. */\n\t      mpn_hgcd_matrix_mul (M, &M1, tp + scratch);\n\t      success = 1;\n\t    }\n\t}\n    }\n\n  for (;;)\n    {\n      /* Needs s+3 < n */\n      nn = mpn_hgcd_step (n, ap, bp, s, M, tp);\n      if (!nn)\n\treturn success ? n : 0;\n\n      n = nn;\n      success = 1;\n    }\n}",
      "lines": 102,
      "depth": 15,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/hgcd2.c": {
    "div1": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static inline mp_limb_t\ndiv1 (mp_ptr rp,\n      mp_limb_t n0,\n      mp_limb_t d0)\n{\n  mp_limb_t q = 0;\n\n  if ((mp_limb_signed_t) n0 < 0)\n    {\n      int cnt;\n      for (cnt = 1; (mp_limb_signed_t) d0 >= 0; cnt++)\n\t{\n\t  d0 = d0 << 1;\n\t}\n\n      q = 0;\n      while (cnt)\n\t{\n\t  q <<= 1;\n\t  if (n0 >= d0)\n\t    {\n\t      n0 = n0 - d0;\n\t      q |= 1;\n\t    }\n\t  d0 = d0 >> 1;\n\t  cnt--;\n\t}\n    }\n  else\n    {\n      int cnt;\n      for (cnt = 0; n0 >= d0; cnt++)\n\t{\n\t  d0 = d0 << 1;\n\t}\n\n      q = 0;\n      while (cnt)\n\t{\n\t  d0 = d0 >> 1;\n\t  q <<= 1;\n\t  if (n0 >= d0)\n\t    {\n\t      n0 = n0 - d0;\n\t      q |= 1;\n\t    }\n\t  cnt--;\n\t}\n    }\n  *rp = n0;\n  return q;\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_limb_t"
      ]
    },
    "div2": [
      {
        "start_point": [
          98,
          0
        ],
        "end_point": [
          154,
          1
        ],
        "content": "static inline mp_limb_t\ndiv2 (mp_ptr rp,\n      mp_limb_t nh, mp_limb_t nl,\n      mp_limb_t dh, mp_limb_t dl)\n{\n  mp_limb_t q = 0;\n\n  if ((mp_limb_signed_t) nh < 0)\n    {\n      int cnt;\n      for (cnt = 1; (mp_limb_signed_t) dh >= 0; cnt++)\n\t{\n\t  dh = (dh << 1) | (dl >> (GMP_LIMB_BITS - 1));\n\t  dl = dl << 1;\n\t}\n\n      while (cnt)\n\t{\n\t  q <<= 1;\n\t  if (nh > dh || (nh == dh && nl >= dl))\n\t    {\n\t      sub_ddmmss (nh, nl, nh, nl, dh, dl);\n\t      q |= 1;\n\t    }\n\t  dl = (dh << (GMP_LIMB_BITS - 1)) | (dl >> 1);\n\t  dh = dh >> 1;\n\t  cnt--;\n\t}\n    }\n  else\n    {\n      int cnt;\n      for (cnt = 0; nh > dh || (nh == dh && nl >= dl); cnt++)\n\t{\n\t  dh = (dh << 1) | (dl >> (GMP_LIMB_BITS - 1));\n\t  dl = dl << 1;\n\t}\n\n      while (cnt)\n\t{\n\t  dl = (dh << (GMP_LIMB_BITS - 1)) | (dl >> 1);\n\t  dh = dh >> 1;\n\t  q <<= 1;\n\t  if (nh > dh || (nh == dh && nl >= dl))\n\t    {\n\t      sub_ddmmss (nh, nl, nh, nl, dh, dl);\n\t      q |= 1;\n\t    }\n\t  cnt--;\n\t}\n    }\n\n  rp[0] = nl;\n  rp[1] = nh;\n\n  return q;\n}",
        "lines": 57,
        "depth": 14,
        "decorators": [
          "static",
          "static",
          "inline",
          "inline",
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          159,
          0
        ],
        "end_point": [
          197,
          1
        ],
        "content": "static inline mp_limb_t\ndiv2 (mp_ptr rp,\n      mp_limb_t nh, mp_limb_t nl,\n      mp_limb_t dh, mp_limb_t dl)\n{\n  mp_limb_t q = 0;\n  int ncnt;\n  int dcnt;\n\n  count_leading_zeros (ncnt, nh);\n  count_leading_zeros (dcnt, dh);\n  dcnt -= ncnt;\n\n  dh = (dh << dcnt) + (-(dcnt > 0) & (dl >> (GMP_LIMB_BITS - dcnt)));\n  dl <<= dcnt;\n\n  do\n    {\n      mp_limb_t bit;\n      q <<= 1;\n      if (UNLIKELY (nh == dh))\n\tbit = (nl >= dl);\n      else\n\tbit = (nh > dh);\n\n      q |= bit;\n\n      sub_ddmmss (nh, nl, nh, nl, (-bit) & dh, (-bit) & dl);\n\n      dl = (dh << (GMP_LIMB_BITS - 1)) | (dl >> 1);\n      dh = dh >> 1;\n    }\n  while (dcnt--);\n\n  rp[0] = nl;\n  rp[1] = nh;\n\n  return q;\n}",
        "lines": 39,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "inline",
          "inline",
          "mp_limb_t"
        ]
      }
    ],
    "mpn_hgcd2": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "int\nmpn_hgcd2 (mp_limb_t ah, mp_limb_t al, mp_limb_t bh, mp_limb_t bl,\n\t   struct hgcd_matrix1 *M)\n{\n  mp_limb_t u00, u01, u10, u11;\n\n  if (ah < 2 || bh < 2)\n    return 0;\n\n  if (ah > bh || (ah == bh && al > bl))\n    {\n      sub_ddmmss (ah, al, ah, al, bh, bl);\n      if (ah < 2)\n\treturn 0;\n\n      u00 = u01 = u11 = 1;\n      u10 = 0;\n    }\n  else\n    {\n      sub_ddmmss (bh, bl, bh, bl, ah, al);\n      if (bh < 2)\n\treturn 0;\n\n      u00 = u10 = u11 = 1;\n      u01 = 0;\n    }\n\n  if (ah < bh)\n    goto subtract_a;\n\n  for (;;)\n    {\n      ASSERT (ah >= bh);\n      if (ah == bh)\n\tgoto done;\n\n      if (ah < (CNST_LIMB(1) << (GMP_LIMB_BITS / 2)))\n\t{\n\t  ah = (ah << (GMP_LIMB_BITS / 2) ) + (al >> (GMP_LIMB_BITS / 2));\n\t  bh = (bh << (GMP_LIMB_BITS / 2) ) + (bl >> (GMP_LIMB_BITS / 2));\n\n\t  break;\n\t}\n\n      /* Subtract a -= q b, and multiply M from the right by (1 q ; 0\n\t 1), affecting the second column of M. */\n      ASSERT (ah > bh);\n      sub_ddmmss (ah, al, ah, al, bh, bl);\n\n      if (ah < 2)\n\tgoto done;\n\n      if (ah <= bh)\n\t{\n\t  /* Use q = 1 */\n\t  u01 += u00;\n\t  u11 += u10;\n\t}\n      else\n\t{\n\t  mp_limb_t r[2];\n\t  mp_limb_t q = div2 (r, ah, al, bh, bl);\n\t  al = r[0]; ah = r[1];\n\t  if (ah < 2)\n\t    {\n\t      /* A is too small, but q is correct. */\n\t      u01 += q * u00;\n\t      u11 += q * u10;\n\t      goto done;\n\t    }\n\t  q++;\n\t  u01 += q * u00;\n\t  u11 += q * u10;\n\t}\n    subtract_a:\n      ASSERT (bh >= ah);\n      if (ah == bh)\n\tgoto done;\n\n      if (bh < (CNST_LIMB(1) << (GMP_LIMB_BITS / 2)))\n\t{\n\t  ah = (ah << (GMP_LIMB_BITS / 2) ) + (al >> (GMP_LIMB_BITS / 2));\n\t  bh = (bh << (GMP_LIMB_BITS / 2) ) + (bl >> (GMP_LIMB_BITS / 2));\n\n\t  goto subtract_a1;\n\t}\n\n      /* Subtract b -= q a, and multiply M from the right by (1 0 ; q\n\t 1), affecting the first column of M. */\n      sub_ddmmss (bh, bl, bh, bl, ah, al);\n\n      if (bh < 2)\n\tgoto done;\n\n      if (bh <= ah)\n\t{\n\t  /* Use q = 1 */\n\t  u00 += u01;\n\t  u10 += u11;\n\t}\n      else\n\t{\n\t  mp_limb_t r[2];\n\t  mp_limb_t q = div2 (r, bh, bl, ah, al);\n\t  bl = r[0]; bh = r[1];\n\t  if (bh < 2)\n\t    {\n\t      /* B is too small, but q is correct. */\n\t      u00 += q * u01;\n\t      u10 += q * u11;\n\t      goto done;\n\t    }\n\t  q++;\n\t  u00 += q * u01;\n\t  u10 += q * u11;\n\t}\n    }\n\n  /* NOTE: Since we discard the least significant half limb, we don't\n     get a truly maximal M (corresponding to |a - b| <\n     2^{GMP_LIMB_BITS +1}). */\n  /* Single precision loop */\n  for (;;)\n    {\n      ASSERT (ah >= bh);\n\n      ah -= bh;\n      if (ah < (CNST_LIMB (1) << (GMP_LIMB_BITS / 2 + 1)))\n\tbreak;\n\n      if (ah <= bh)\n\t{\n\t  /* Use q = 1 */\n\t  u01 += u00;\n\t  u11 += u10;\n\t}\n      else\n\t{\n\t  mp_limb_t r;\n\t  mp_limb_t q = div1 (&r, ah, bh);\n\t  ah = r;\n\t  if (ah < (CNST_LIMB(1) << (GMP_LIMB_BITS / 2 + 1)))\n\t    {\n\t      /* A is too small, but q is correct. */\n\t      u01 += q * u00;\n\t      u11 += q * u10;\n\t      break;\n\t    }\n\t  q++;\n\t  u01 += q * u00;\n\t  u11 += q * u10;\n\t}\n    subtract_a1:\n      ASSERT (bh >= ah);\n\n      bh -= ah;\n      if (bh < (CNST_LIMB (1) << (GMP_LIMB_BITS / 2 + 1)))\n\tbreak;\n\n      if (bh <= ah)\n\t{\n\t  /* Use q = 1 */\n\t  u00 += u01;\n\t  u10 += u11;\n\t}\n      else\n\t{\n\t  mp_limb_t r;\n\t  mp_limb_t q = div1 (&r, bh, ah);\n\t  bh = r;\n\t  if (bh < (CNST_LIMB(1) << (GMP_LIMB_BITS / 2 + 1)))\n\t    {\n\t      /* B is too small, but q is correct. */\n\t      u00 += q * u01;\n\t      u10 += q * u11;\n\t      break;\n\t    }\n\t  q++;\n\t  u00 += q * u01;\n\t  u10 += q * u11;\n\t}\n    }\n\n done:\n  M->u[0][0] = u00; M->u[0][1] = u01;\n  M->u[1][0] = u10; M->u[1][1] = u11;\n\n  return 1;\n}",
      "lines": 190,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "mpn_hgcd_mul_matrix1_vector": {
      "start_point": [
        417,
        0
      ],
      "end_point": [
        446,
        1
      ],
      "content": "mp_size_t\nmpn_hgcd_mul_matrix1_vector (const struct hgcd_matrix1 *M,\n\t\t\t     mp_ptr rp, mp_srcptr ap, mp_ptr bp, mp_size_t n)\n{\n  mp_limb_t ah, bh;\n\n  /* Compute (r,b) <-- (u00 a + u10 b, u01 a + u11 b) as\n\n     r  = u00 * a\n     r += u10 * b\n     b *= u11\n     b += u01 * a\n  */\n\n#if HAVE_NATIVE_mpn_addaddmul_1msb0\n  ah = mpn_addaddmul_1msb0 (rp, ap, bp, n, M->u[0][0], M->u[1][0]);\n  bh = mpn_addaddmul_1msb0 (bp, bp, ap, n, M->u[1][1], M->u[0][1]);\n#else\n  ah =     mpn_mul_1 (rp, ap, n, M->u[0][0]);\n  ah += mpn_addmul_1 (rp, bp, n, M->u[1][0]);\n\n  bh =     mpn_mul_1 (bp, bp, n, M->u[1][1]);\n  bh += mpn_addmul_1 (bp, ap, n, M->u[0][1]);\n#endif\n  rp[n] = ah;\n  bp[n] = bh;\n\n  n += (ah | bh) > 0;\n  return n;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/hgcd2_jacobi.c": {
    "div1": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static inline mp_limb_t\ndiv1 (mp_ptr rp,\n      mp_limb_t n0,\n      mp_limb_t d0)\n{\n  mp_limb_t q = 0;\n\n  if ((mp_limb_signed_t) n0 < 0)\n    {\n      int cnt;\n      for (cnt = 1; (mp_limb_signed_t) d0 >= 0; cnt++)\n\t{\n\t  d0 = d0 << 1;\n\t}\n\n      q = 0;\n      while (cnt)\n\t{\n\t  q <<= 1;\n\t  if (n0 >= d0)\n\t    {\n\t      n0 = n0 - d0;\n\t      q |= 1;\n\t    }\n\t  d0 = d0 >> 1;\n\t  cnt--;\n\t}\n    }\n  else\n    {\n      int cnt;\n      for (cnt = 0; n0 >= d0; cnt++)\n\t{\n\t  d0 = d0 << 1;\n\t}\n\n      q = 0;\n      while (cnt)\n\t{\n\t  d0 = d0 >> 1;\n\t  q <<= 1;\n\t  if (n0 >= d0)\n\t    {\n\t      n0 = n0 - d0;\n\t      q |= 1;\n\t    }\n\t  cnt--;\n\t}\n    }\n  *rp = n0;\n  return q;\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_limb_t"
      ]
    },
    "div2": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static inline mp_limb_t\ndiv2 (mp_ptr rp,\n      mp_limb_t nh, mp_limb_t nl,\n      mp_limb_t dh, mp_limb_t dl)\n{\n  mp_limb_t q = 0;\n\n  if ((mp_limb_signed_t) nh < 0)\n    {\n      int cnt;\n      for (cnt = 1; (mp_limb_signed_t) dh >= 0; cnt++)\n\t{\n\t  dh = (dh << 1) | (dl >> (GMP_LIMB_BITS - 1));\n\t  dl = dl << 1;\n\t}\n\n      while (cnt)\n\t{\n\t  q <<= 1;\n\t  if (nh > dh || (nh == dh && nl >= dl))\n\t    {\n\t      sub_ddmmss (nh, nl, nh, nl, dh, dl);\n\t      q |= 1;\n\t    }\n\t  dl = (dh << (GMP_LIMB_BITS - 1)) | (dl >> 1);\n\t  dh = dh >> 1;\n\t  cnt--;\n\t}\n    }\n  else\n    {\n      int cnt;\n      for (cnt = 0; nh > dh || (nh == dh && nl >= dl); cnt++)\n\t{\n\t  dh = (dh << 1) | (dl >> (GMP_LIMB_BITS - 1));\n\t  dl = dl << 1;\n\t}\n\n      while (cnt)\n\t{\n\t  dl = (dh << (GMP_LIMB_BITS - 1)) | (dl >> 1);\n\t  dh = dh >> 1;\n\t  q <<= 1;\n\t  if (nh > dh || (nh == dh && nl >= dl))\n\t    {\n\t      sub_ddmmss (nh, nl, nh, nl, dh, dl);\n\t      q |= 1;\n\t    }\n\t  cnt--;\n\t}\n    }\n\n  rp[0] = nl;\n  rp[1] = nh;\n\n  return q;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_limb_t"
      ]
    },
    "mpn_hgcd2_jacobi": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "int\nmpn_hgcd2_jacobi (mp_limb_t ah, mp_limb_t al, mp_limb_t bh, mp_limb_t bl,\n\t\t  struct hgcd_matrix1 *M, unsigned *bitsp)\n{\n  mp_limb_t u00, u01, u10, u11;\n  unsigned bits = *bitsp;\n\n  if (ah < 2 || bh < 2)\n    return 0;\n\n  if (ah > bh || (ah == bh && al > bl))\n    {\n      sub_ddmmss (ah, al, ah, al, bh, bl);\n      if (ah < 2)\n\treturn 0;\n\n      u00 = u01 = u11 = 1;\n      u10 = 0;\n      bits = mpn_jacobi_update (bits, 1, 1);\n    }\n  else\n    {\n      sub_ddmmss (bh, bl, bh, bl, ah, al);\n      if (bh < 2)\n\treturn 0;\n\n      u00 = u10 = u11 = 1;\n      u01 = 0;\n      bits = mpn_jacobi_update (bits, 0, 1);\n    }\n\n  if (ah < bh)\n    goto subtract_a;\n\n  for (;;)\n    {\n      ASSERT (ah >= bh);\n      if (ah == bh)\n\tgoto done;\n\n      if (ah < (CNST_LIMB(1) << (GMP_LIMB_BITS / 2)))\n\t{\n\t  ah = (ah << (GMP_LIMB_BITS / 2) ) + (al >> (GMP_LIMB_BITS / 2));\n\t  bh = (bh << (GMP_LIMB_BITS / 2) ) + (bl >> (GMP_LIMB_BITS / 2));\n\n\t  break;\n\t}\n\n      /* Subtract a -= q b, and multiply M from the right by (1 q ; 0\n\t 1), affecting the second column of M. */\n      ASSERT (ah > bh);\n      sub_ddmmss (ah, al, ah, al, bh, bl);\n\n      if (ah < 2)\n\tgoto done;\n\n      if (ah <= bh)\n\t{\n\t  /* Use q = 1 */\n\t  u01 += u00;\n\t  u11 += u10;\n\t  bits = mpn_jacobi_update (bits, 1, 1);\n\t}\n      else\n\t{\n\t  mp_limb_t r[2];\n\t  mp_limb_t q = div2 (r, ah, al, bh, bl);\n\t  al = r[0]; ah = r[1];\n\t  if (ah < 2)\n\t    {\n\t      /* A is too small, but q is correct. */\n\t      u01 += q * u00;\n\t      u11 += q * u10;\n\t      bits = mpn_jacobi_update (bits, 1, q & 3);\n\t      goto done;\n\t    }\n\t  q++;\n\t  u01 += q * u00;\n\t  u11 += q * u10;\n\t  bits = mpn_jacobi_update (bits, 1, q & 3);\n\t}\n    subtract_a:\n      ASSERT (bh >= ah);\n      if (ah == bh)\n\tgoto done;\n\n      if (bh < (CNST_LIMB(1) << (GMP_LIMB_BITS / 2)))\n\t{\n\t  ah = (ah << (GMP_LIMB_BITS / 2) ) + (al >> (GMP_LIMB_BITS / 2));\n\t  bh = (bh << (GMP_LIMB_BITS / 2) ) + (bl >> (GMP_LIMB_BITS / 2));\n\n\t  goto subtract_a1;\n\t}\n\n      /* Subtract b -= q a, and multiply M from the right by (1 0 ; q\n\t 1), affecting the first column of M. */\n      sub_ddmmss (bh, bl, bh, bl, ah, al);\n\n      if (bh < 2)\n\tgoto done;\n\n      if (bh <= ah)\n\t{\n\t  /* Use q = 1 */\n\t  u00 += u01;\n\t  u10 += u11;\n\t  bits = mpn_jacobi_update (bits, 0, 1);\n\t}\n      else\n\t{\n\t  mp_limb_t r[2];\n\t  mp_limb_t q = div2 (r, bh, bl, ah, al);\n\t  bl = r[0]; bh = r[1];\n\t  if (bh < 2)\n\t    {\n\t      /* B is too small, but q is correct. */\n\t      u00 += q * u01;\n\t      u10 += q * u11;\n\t      bits = mpn_jacobi_update (bits, 0, q & 3);\n\t      goto done;\n\t    }\n\t  q++;\n\t  u00 += q * u01;\n\t  u10 += q * u11;\n\t  bits = mpn_jacobi_update (bits, 0, q & 3);\n\t}\n    }\n\n  /* NOTE: Since we discard the least significant half limb, we don't\n     get a truly maximal M (corresponding to |a - b| <\n     2^{GMP_LIMB_BITS +1}). */\n  /* Single precision loop */\n  for (;;)\n    {\n      ASSERT (ah >= bh);\n      if (ah == bh)\n\tbreak;\n\n      ah -= bh;\n      if (ah < (CNST_LIMB (1) << (GMP_LIMB_BITS / 2 + 1)))\n\tbreak;\n\n      if (ah <= bh)\n\t{\n\t  /* Use q = 1 */\n\t  u01 += u00;\n\t  u11 += u10;\n\t  bits = mpn_jacobi_update (bits, 1, 1);\n\t}\n      else\n\t{\n\t  mp_limb_t r;\n\t  mp_limb_t q = div1 (&r, ah, bh);\n\t  ah = r;\n\t  if (ah < (CNST_LIMB(1) << (GMP_LIMB_BITS / 2 + 1)))\n\t    {\n\t      /* A is too small, but q is correct. */\n\t      u01 += q * u00;\n\t      u11 += q * u10;\n\t      bits = mpn_jacobi_update (bits, 1, q & 3);\n\t      break;\n\t    }\n\t  q++;\n\t  u01 += q * u00;\n\t  u11 += q * u10;\n\t  bits = mpn_jacobi_update (bits, 1, q & 3);\n\t}\n    subtract_a1:\n      ASSERT (bh >= ah);\n      if (ah == bh)\n\tbreak;\n\n      bh -= ah;\n      if (bh < (CNST_LIMB (1) << (GMP_LIMB_BITS / 2 + 1)))\n\tbreak;\n\n      if (bh <= ah)\n\t{\n\t  /* Use q = 1 */\n\t  u00 += u01;\n\t  u10 += u11;\n\t  bits = mpn_jacobi_update (bits, 0, 1);\n\t}\n      else\n\t{\n\t  mp_limb_t r;\n\t  mp_limb_t q = div1 (&r, bh, ah);\n\t  bh = r;\n\t  if (bh < (CNST_LIMB(1) << (GMP_LIMB_BITS / 2 + 1)))\n\t    {\n\t      /* B is too small, but q is correct. */\n\t      u00 += q * u01;\n\t      u10 += q * u11;\n\t      bits = mpn_jacobi_update (bits, 0, q & 3);\n\t      break;\n\t    }\n\t  q++;\n\t  u00 += q * u01;\n\t  u10 += q * u11;\n\t  bits = mpn_jacobi_update (bits, 0, q & 3);\n\t}\n    }\n\n done:\n  M->u[0][0] = u00; M->u[0][1] = u01;\n  M->u[1][0] = u10; M->u[1][1] = u11;\n  *bitsp = bits;\n\n  return 1;\n}",
      "lines": 210,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/hgcd_appr.c": {
    "mpn_hgcd_appr_itch": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "mp_size_t\nmpn_hgcd_appr_itch (mp_size_t n)\n{\n  if (BELOW_THRESHOLD (n, HGCD_APPR_THRESHOLD))\n    return n;\n  else\n    {\n      unsigned k;\n      int count;\n      mp_size_t nscaled;\n\n      /* Get the recursion depth. */\n      nscaled = (n - 1) / (HGCD_APPR_THRESHOLD - 1);\n      count_leading_zeros (count, nscaled);\n      k = GMP_LIMB_BITS - count;\n\n      return 20 * ((n+3) / 4) + 22 * k + HGCD_THRESHOLD;\n    }\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_hgcd_appr": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "int\nmpn_hgcd_appr (mp_ptr ap, mp_ptr bp, mp_size_t n,\n\t       struct hgcd_matrix *M, mp_ptr tp)\n{\n  mp_size_t s;\n  int success = 0;\n\n  ASSERT (n > 0);\n\n  ASSERT ((ap[n-1] | bp[n-1]) != 0);\n\n  if (n <= 2)\n    /* Implies s = n. A fairly uninteresting case but exercised by the\n       random inputs of the testsuite. */\n    return 0;\n\n  ASSERT ((n+1)/2 - 1 < M->alloc);\n\n  /* We aim for reduction of to GMP_NUMB_BITS * s bits. But each time\n     we discard some of the least significant limbs, we must keep one\n     additional bit to account for the truncation error. We maintain\n     the GMP_NUMB_BITS * s - extra_bits as the current target size. */\n\n  s = n/2 + 1;\n  if (BELOW_THRESHOLD (n, HGCD_APPR_THRESHOLD))\n    {\n      unsigned extra_bits = 0;\n\n      while (n > 2)\n\t{\n\t  mp_size_t nn;\n\n\t  ASSERT (n > s);\n\t  ASSERT (n <= 2*s);\n\n\t  nn = mpn_hgcd_step (n, ap, bp, s, M, tp);\n\t  if (!nn)\n\t    break;\n\n\t  n = nn;\n\t  success = 1;\n\n\t  /* We can truncate and discard the lower p bits whenever nbits <=\n\t     2*sbits - p. To account for the truncation error, we must\n\t     adjust\n\n\t     sbits <-- sbits + 1 - p,\n\n\t     rather than just sbits <-- sbits - p. This adjustment makes\n\t     the produced matrix slightly smaller than it could be. */\n\n\t  if (GMP_NUMB_BITS * (n + 1) + 2 * extra_bits <= 2*GMP_NUMB_BITS * s)\n\t    {\n\t      mp_size_t p = (GMP_NUMB_BITS * (2*s - n) - 2*extra_bits) / GMP_NUMB_BITS;\n\n\t      if (extra_bits == 0)\n\t\t{\n\t\t  /* We cross a limb boundary and bump s. We can't do that\n\t\t     if the result is that it makes makes min(U, V)\n\t\t     smaller than 2^{GMP_NUMB_BITS} s. */\n\t\t  if (s + 1 == n\n\t\t      || mpn_zero_p (ap + s + 1, n - s - 1)\n\t\t      || mpn_zero_p (bp + s + 1, n - s - 1))\n\t\t    continue;\n\n\t\t  extra_bits = GMP_NUMB_BITS - 1;\n\t\t  s++;\n\t\t}\n\t      else\n\t\t{\n\t\t  extra_bits--;\n\t\t}\n\n\t      /* Drop the p least significant limbs */\n\t      ap += p; bp += p; n -= p; s -= p;\n\t    }\n\t}\n\n      ASSERT (s > 0);\n\n      if (extra_bits > 0)\n\t{\n\t  /* We can get here only of we have dropped at least one of the least\n\t     significant bits, so we can decrement ap and bp. We can then shift\n\t     left extra bits using mpn_rshift. */\n\t  /* NOTE: In the unlikely case that n is large, it would be preferable\n\t     to do an initial subdiv step to reduce the size before shifting,\n\t     but that would mean duplicating mpn_gcd_subdiv_step with a bit\n\t     count rather than a limb count. */\n\t  ap--; bp--;\n\t  ap[0] = mpn_rshift (ap+1, ap+1, n, GMP_NUMB_BITS - extra_bits);\n\t  bp[0] = mpn_rshift (bp+1, bp+1, n, GMP_NUMB_BITS - extra_bits);\n\t  n += (ap[n] | bp[n]) > 0;\n\n\t  ASSERT (success);\n\n\t  while (n > 2)\n\t    {\n\t      mp_size_t nn;\n\n\t      ASSERT (n > s);\n\t      ASSERT (n <= 2*s);\n\n\t      nn = mpn_hgcd_step (n, ap, bp, s, M, tp);\n\n\t      if (!nn)\n\t\treturn 1;\n\n\t      n = nn;\n\t    }\n\t}\n\n      if (n == 2)\n\t{\n\t  struct hgcd_matrix1 M1;\n\t  ASSERT (s == 1);\n\n\t  if (mpn_hgcd2 (ap[1], ap[0], bp[1], bp[0], &M1))\n\t    {\n\t      /* Multiply M <- M * M1 */\n\t      mpn_hgcd_matrix_mul_1 (M, &M1, tp);\n\t      success = 1;\n\t    }\n\t}\n      return success;\n    }\n  else\n    {\n      mp_size_t n2 = (3*n)/4 + 1;\n      mp_size_t p = n/2;\n      mp_size_t nn;\n\n      nn = mpn_hgcd_reduce (M, ap, bp, n, p, tp);\n      if (nn)\n\t{\n\t  n = nn;\n\t  /* FIXME: Discard some of the low limbs immediately? */\n\t  success = 1;\n\t}\n\n      while (n > n2)\n\t{\n\t  mp_size_t nn;\n\n\t  /* Needs n + 1 storage */\n\t  nn = mpn_hgcd_step (n, ap, bp, s, M, tp);\n\t  if (!nn)\n\t    return success;\n\n\t  n = nn;\n\t  success = 1;\n\t}\n      if (n > s + 2)\n\t{\n\t  struct hgcd_matrix M1;\n\t  mp_size_t scratch;\n\n\t  p = 2*s - n + 1;\n\t  scratch = MPN_HGCD_MATRIX_INIT_ITCH (n-p);\n\n\t  mpn_hgcd_matrix_init(&M1, n - p, tp);\n\t  if (mpn_hgcd_appr (ap + p, bp + p, n - p, &M1, tp + scratch))\n\t    {\n\t      /* We always have max(M) > 2^{-(GMP_NUMB_BITS + 1)} max(M1) */\n\t      ASSERT (M->n + 2 >= M1.n);\n\n\t      /* Furthermore, assume M ends with a quotient (1, q; 0, 1),\n\t\t then either q or q + 1 is a correct quotient, and M1 will\n\t\t start with either (1, 0; 1, 1) or (2, 1; 1, 1). This\n\t\t rules out the case that the size of M * M1 is much\n\t\t smaller than the expected M->n + M1->n. */\n\n\t      ASSERT (M->n + M1.n < M->alloc);\n\n\t      /* We need a bound for of M->n + M1.n. Let n be the original\n\t\t input size. Then\n\n\t\t ceil(n/2) - 1 >= size of product >= M.n + M1.n - 2\n\n\t\t and it follows that\n\n\t\t M.n + M1.n <= ceil(n/2) + 1\n\n\t\t Then 3*(M.n + M1.n) + 5 <= 3 * ceil(n/2) + 8 is the\n\t\t amount of needed scratch space. */\n\t      mpn_hgcd_matrix_mul (M, &M1, tp + scratch);\n\t      return 1;\n\t    }\n\t}\n\n      for(;;)\n\t{\n\t  mp_size_t nn;\n\n\t  ASSERT (n > s);\n\t  ASSERT (n <= 2*s);\n\n\t  nn = mpn_hgcd_step (n, ap, bp, s, M, tp);\n\n\t  if (!nn)\n\t    return success;\n\n\t  n = nn;\n\t  success = 1;\n\t}\n    }\n}",
      "lines": 207,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/hgcd_jacobi.c": {
    "hgcd_jacobi_hook": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\nhgcd_jacobi_hook (void *p, mp_srcptr gp, mp_size_t gn,\n\t\t  mp_srcptr qp, mp_size_t qn, int d)\n{\n  ASSERT (!gp);\n  ASSERT (d >= 0);\n\n  MPN_NORMALIZE (qp, qn);\n  if (qn > 0)\n    {\n      struct hgcd_jacobi_ctx *ctx = (struct hgcd_jacobi_ctx *) p;\n      /* NOTES: This is a bit ugly. A tp area is passed to\n\t gcd_subdiv_step, which stores q at the start of that area. We\n\t now use the rest. */\n      mp_ptr tp = (mp_ptr) qp + qn;\n\n      mpn_hgcd_matrix_update_q (ctx->M, qp, qn, d, tp);\n      *ctx->bitsp = mpn_jacobi_update (*ctx->bitsp, d, qp[0] & 3);\n    }\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hgcd_jacobi_step": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static mp_size_t\nhgcd_jacobi_step (mp_size_t n, mp_ptr ap, mp_ptr bp, mp_size_t s,\n\t\t  struct hgcd_matrix *M, unsigned *bitsp, mp_ptr tp)\n{\n  struct hgcd_matrix1 M1;\n  mp_limb_t mask;\n  mp_limb_t ah, al, bh, bl;\n\n  ASSERT (n > s);\n\n  mask = ap[n-1] | bp[n-1];\n  ASSERT (mask > 0);\n\n  if (n == s + 1)\n    {\n      if (mask < 4)\n\tgoto subtract;\n\n      ah = ap[n-1]; al = ap[n-2];\n      bh = bp[n-1]; bl = bp[n-2];\n    }\n  else if (mask & GMP_NUMB_HIGHBIT)\n    {\n      ah = ap[n-1]; al = ap[n-2];\n      bh = bp[n-1]; bl = bp[n-2];\n    }\n  else\n    {\n      int shift;\n\n      count_leading_zeros (shift, mask);\n      ah = MPN_EXTRACT_NUMB (shift, ap[n-1], ap[n-2]);\n      al = MPN_EXTRACT_NUMB (shift, ap[n-2], ap[n-3]);\n      bh = MPN_EXTRACT_NUMB (shift, bp[n-1], bp[n-2]);\n      bl = MPN_EXTRACT_NUMB (shift, bp[n-2], bp[n-3]);\n    }\n\n  /* Try an mpn_hgcd2 step */\n  if (mpn_hgcd2_jacobi (ah, al, bh, bl, &M1, bitsp))\n    {\n      /* Multiply M <- M * M1 */\n      mpn_hgcd_matrix_mul_1 (M, &M1, tp);\n\n      /* Can't swap inputs, so we need to copy. */\n      MPN_COPY (tp, ap, n);\n      /* Multiply M1^{-1} (a;b) */\n      return mpn_matrix22_mul1_inverse_vector (&M1, ap, tp, bp, n);\n    }\n\n subtract:\n  {\n    struct hgcd_jacobi_ctx ctx;\n    ctx.M = M;\n    ctx.bitsp = bitsp;\n\n    return mpn_gcd_subdiv_step (ap, bp, n, s, hgcd_jacobi_hook, &ctx, tp);\n  }\n}",
      "lines": 58,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_hgcd_jacobi": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "mp_size_t\nmpn_hgcd_jacobi (mp_ptr ap, mp_ptr bp, mp_size_t n,\n\t\t struct hgcd_matrix *M, unsigned *bitsp, mp_ptr tp)\n{\n  mp_size_t s = n/2 + 1;\n\n  mp_size_t nn;\n  int success = 0;\n\n  if (n <= s)\n    /* Happens when n <= 2, a fairly uninteresting case but exercised\n       by the random inputs of the testsuite. */\n    return 0;\n\n  ASSERT ((ap[n-1] | bp[n-1]) > 0);\n\n  ASSERT ((n+1)/2 - 1 < M->alloc);\n\n  if (ABOVE_THRESHOLD (n, HGCD_THRESHOLD))\n    {\n      mp_size_t n2 = (3*n)/4 + 1;\n      mp_size_t p = n/2;\n\n      nn = mpn_hgcd_jacobi (ap + p, bp + p, n - p, M, bitsp, tp);\n      if (nn > 0)\n\t{\n\t  /* Needs 2*(p + M->n) <= 2*(floor(n/2) + ceil(n/2) - 1)\n\t     = 2 (n - 1) */\n\t  n = mpn_hgcd_matrix_adjust (M, p + nn, ap, bp, p, tp);\n\t  success = 1;\n\t}\n      while (n > n2)\n\t{\n\t  /* Needs n + 1 storage */\n\t  nn = hgcd_jacobi_step (n, ap, bp, s, M, bitsp, tp);\n\t  if (!nn)\n\t    return success ? n : 0;\n\t  n = nn;\n\t  success = 1;\n\t}\n\n      if (n > s + 2)\n\t{\n\t  struct hgcd_matrix M1;\n\t  mp_size_t scratch;\n\n\t  p = 2*s - n + 1;\n\t  scratch = MPN_HGCD_MATRIX_INIT_ITCH (n-p);\n\n\t  mpn_hgcd_matrix_init(&M1, n - p, tp);\n\t  nn = mpn_hgcd_jacobi (ap + p, bp + p, n - p, &M1, bitsp, tp + scratch);\n\t  if (nn > 0)\n\t    {\n\t      /* We always have max(M) > 2^{-(GMP_NUMB_BITS + 1)} max(M1) */\n\t      ASSERT (M->n + 2 >= M1.n);\n\n\t      /* Furthermore, assume M ends with a quotient (1, q; 0, 1),\n\t\t then either q or q + 1 is a correct quotient, and M1 will\n\t\t start with either (1, 0; 1, 1) or (2, 1; 1, 1). This\n\t\t rules out the case that the size of M * M1 is much\n\t\t smaller than the expected M->n + M1->n. */\n\n\t      ASSERT (M->n + M1.n < M->alloc);\n\n\t      /* Needs 2 (p + M->n) <= 2 (2*s - n2 + 1 + n2 - s - 1)\n\t\t = 2*s <= 2*(floor(n/2) + 1) <= n + 2. */\n\t      n = mpn_hgcd_matrix_adjust (&M1, p + nn, ap, bp, p, tp + scratch);\n\n\t      /* We need a bound for of M->n + M1.n. Let n be the original\n\t\t input size. Then\n\n\t\t ceil(n/2) - 1 >= size of product >= M.n + M1.n - 2\n\n\t\t and it follows that\n\n\t\t M.n + M1.n <= ceil(n/2) + 1\n\n\t\t Then 3*(M.n + M1.n) + 5 <= 3 * ceil(n/2) + 8 is the\n\t\t amount of needed scratch space. */\n\t      mpn_hgcd_matrix_mul (M, &M1, tp + scratch);\n\t      success = 1;\n\t    }\n\t}\n    }\n\n  for (;;)\n    {\n      /* Needs s+3 < n */\n      nn = hgcd_jacobi_step (n, ap, bp, s, M, bitsp, tp);\n      if (!nn)\n\treturn success ? n : 0;\n\n      n = nn;\n      success = 1;\n    }\n}",
      "lines": 96,
      "depth": 15,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/hgcd_matrix.c": {
    "mpn_hgcd_matrix_init": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\nmpn_hgcd_matrix_init (struct hgcd_matrix *M, mp_size_t n, mp_ptr p)\n{\n  mp_size_t s = (n+1)/2 + 1;\n  M->alloc = s;\n  M->n = 1;\n  MPN_ZERO (p, 4 * s);\n  M->p[0][0] = p;\n  M->p[0][1] = p + s;\n  M->p[1][0] = p + 2 * s;\n  M->p[1][1] = p + 3 * s;\n\n  M->p[0][0][0] = M->p[1][1][0] = 1;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpn_hgcd_matrix_update_q": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\nmpn_hgcd_matrix_update_q (struct hgcd_matrix *M, mp_srcptr qp, mp_size_t qn,\n\t\t\t  unsigned col, mp_ptr tp)\n{\n  ASSERT (col < 2);\n\n  if (qn == 1)\n    {\n      mp_limb_t q = qp[0];\n      mp_limb_t c0, c1;\n\n      c0 = mpn_addmul_1 (M->p[0][col], M->p[0][1-col], M->n, q);\n      c1 = mpn_addmul_1 (M->p[1][col], M->p[1][1-col], M->n, q);\n\n      M->p[0][col][M->n] = c0;\n      M->p[1][col][M->n] = c1;\n\n      M->n += (c0 | c1) != 0;\n    }\n  else\n    {\n      unsigned row;\n\n      /* Carries for the unlikely case that we get both high words\n\t from the multiplication and carries from the addition. */\n      mp_limb_t c[2];\n      mp_size_t n;\n\n      /* The matrix will not necessarily grow in size by qn, so we\n\t need normalization in order not to overflow M. */\n\n      for (n = M->n; n + qn > M->n; n--)\n\t{\n\t  ASSERT (n > 0);\n\t  if (M->p[0][1-col][n-1] > 0 || M->p[1][1-col][n-1] > 0)\n\t    break;\n\t}\n\n      ASSERT (qn + n <= M->alloc);\n\n      for (row = 0; row < 2; row++)\n\t{\n\t  if (qn <= n)\n\t    mpn_mul (tp, M->p[row][1-col], n, qp, qn);\n\t  else\n\t    mpn_mul (tp, qp, qn, M->p[row][1-col], n);\n\n\t  ASSERT (n + qn >= M->n);\n\t  c[row] = mpn_add (M->p[row][col], tp, n + qn, M->p[row][col], M->n);\n\t}\n\n      n += qn;\n\n      if (c[0] | c[1])\n\t{\n\t  M->p[0][col][n] = c[0];\n\t  M->p[1][col][n] = c[1];\n\t  n++;\n\t}\n      else\n\t{\n\t  n -= (M->p[0][col][n-1] | M->p[1][col][n-1]) == 0;\n\t  ASSERT (n >= M->n);\n\t}\n      M->n = n;\n    }\n\n  ASSERT (M->n < M->alloc);\n}",
      "lines": 69,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "mpn_hgcd_matrix_mul_1": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\nmpn_hgcd_matrix_mul_1 (struct hgcd_matrix *M, const struct hgcd_matrix1 *M1,\n\t\t       mp_ptr tp)\n{\n  mp_size_t n0, n1;\n\n  /* Could avoid copy by some swapping of pointers. */\n  MPN_COPY (tp, M->p[0][0], M->n);\n  n0 = mpn_hgcd_mul_matrix1_vector (M1, M->p[0][0], tp, M->p[0][1], M->n);\n  MPN_COPY (tp, M->p[1][0], M->n);\n  n1 = mpn_hgcd_mul_matrix1_vector (M1, M->p[1][0], tp, M->p[1][1], M->n);\n\n  /* Depends on zero initialization */\n  M->n = MAX(n0, n1);\n  ASSERT (M->n < M->alloc);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpn_hgcd_matrix_mul": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "void\nmpn_hgcd_matrix_mul (struct hgcd_matrix *M, const struct hgcd_matrix *M1,\n\t\t     mp_ptr tp)\n{\n  mp_size_t n;\n\n  /* About the new size of M:s elements. Since M1's diagonal elements\n     are > 0, no element can decrease. The new elements are of size\n     M->n + M1->n, one limb more or less. The computation of the\n     matrix product produces elements of size M->n + M1->n + 1. But\n     the true size, after normalization, may be three limbs smaller.\n\n     The reason that the product has normalized size >= M->n + M1->n -\n     2 is subtle. It depends on the fact that M and M1 can be factored\n     as products of (1,1; 0,1) and (1,0; 1,1), and that we can't have\n     M ending with a large power and M1 starting with a large power of\n     the same matrix. */\n\n  /* FIXME: Strassen multiplication gives only a small speedup. In FFT\n     multiplication range, this function could be sped up quite a lot\n     using invariance. */\n  ASSERT (M->n + M1->n < M->alloc);\n\n  ASSERT ((M->p[0][0][M->n-1] | M->p[0][1][M->n-1]\n\t   | M->p[1][0][M->n-1] | M->p[1][1][M->n-1]) > 0);\n\n  ASSERT ((M1->p[0][0][M1->n-1] | M1->p[0][1][M1->n-1]\n\t   | M1->p[1][0][M1->n-1] | M1->p[1][1][M1->n-1]) > 0);\n\n  mpn_matrix22_mul (M->p[0][0], M->p[0][1],\n\t\t    M->p[1][0], M->p[1][1], M->n,\n\t\t    M1->p[0][0], M1->p[0][1],\n\t\t    M1->p[1][0], M1->p[1][1], M1->n, tp);\n\n  /* Index of last potentially non-zero limb, size is one greater. */\n  n = M->n + M1->n;\n\n  n -= ((M->p[0][0][n] | M->p[0][1][n] | M->p[1][0][n] | M->p[1][1][n]) == 0);\n  n -= ((M->p[0][0][n] | M->p[0][1][n] | M->p[1][0][n] | M->p[1][1][n]) == 0);\n  n -= ((M->p[0][0][n] | M->p[0][1][n] | M->p[1][0][n] | M->p[1][1][n]) == 0);\n\n  ASSERT ((M->p[0][0][n] | M->p[0][1][n] | M->p[1][0][n] | M->p[1][1][n]) > 0);\n\n  M->n = n + 1;\n}",
      "lines": 45,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "mpn_hgcd_matrix_adjust": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "mp_size_t\nmpn_hgcd_matrix_adjust (const struct hgcd_matrix *M,\n\t\t\tmp_size_t n, mp_ptr ap, mp_ptr bp,\n\t\t\tmp_size_t p, mp_ptr tp)\n{\n  /* M^-1 (a;b) = (r11, -r01; -r10, r00) (a ; b)\n     = (r11 a - r01 b; - r10 a + r00 b */\n\n  mp_ptr t0 = tp;\n  mp_ptr t1 = tp + p + M->n;\n  mp_limb_t ah, bh;\n  mp_limb_t cy;\n\n  ASSERT (p + M->n  < n);\n\n  /* First compute the two values depending on a, before overwriting a */\n\n  if (M->n >= p)\n    {\n      mpn_mul (t0, M->p[1][1], M->n, ap, p);\n      mpn_mul (t1, M->p[1][0], M->n, ap, p);\n    }\n  else\n    {\n      mpn_mul (t0, ap, p, M->p[1][1], M->n);\n      mpn_mul (t1, ap, p, M->p[1][0], M->n);\n    }\n\n  /* Update a */\n  MPN_COPY (ap, t0, p);\n  ah = mpn_add (ap + p, ap + p, n - p, t0 + p, M->n);\n\n  if (M->n >= p)\n    mpn_mul (t0, M->p[0][1], M->n, bp, p);\n  else\n    mpn_mul (t0, bp, p, M->p[0][1], M->n);\n\n  cy = mpn_sub (ap, ap, n, t0, p + M->n);\n  ASSERT (cy <= ah);\n  ah -= cy;\n\n  /* Update b */\n  if (M->n >= p)\n    mpn_mul (t0, M->p[0][0], M->n, bp, p);\n  else\n    mpn_mul (t0, bp, p, M->p[0][0], M->n);\n\n  MPN_COPY (bp, t0, p);\n  bh = mpn_add (bp + p, bp + p, n - p, t0 + p, M->n);\n  cy = mpn_sub (bp, bp, n, t1, p + M->n);\n  ASSERT (cy <= bh);\n  bh -= cy;\n\n  if (ah > 0 || bh > 0)\n    {\n      ap[n] = ah;\n      bp[n] = bh;\n      n++;\n    }\n  else\n    {\n      /* The subtraction can reduce the size by at most one limb. */\n      if (ap[n-1] == 0 && bp[n-1] == 0)\n\tn--;\n    }\n  ASSERT (ap[n-1] > 0 || bp[n-1] > 0);\n  return n;\n}",
      "lines": 68,
      "depth": 11,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/hgcd_reduce.c": {
    "submul": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static mp_size_t\nsubmul (mp_ptr rp, mp_size_t rn,\n\tmp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)\n{\n  mp_ptr tp;\n  TMP_DECL;\n\n  ASSERT (bn > 0);\n  ASSERT (an >= bn);\n  ASSERT (rn >= an);\n  ASSERT (an + bn <= rn + 1);\n\n  TMP_MARK;\n  tp = TMP_ALLOC_LIMBS (an + bn);\n\n  mpn_mul (tp, ap, an, bp, bn);\n  ASSERT ((an + bn <= rn) || (tp[rn] == 0));\n  ASSERT_NOCARRY (mpn_sub (rp, rp, rn, tp, an + bn - (an + bn > rn)));\n  TMP_FREE;\n\n  while (rn > an && (rp[rn-1] == 0))\n    rn--;\n\n  return rn;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "hgcd_matrix_apply": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static mp_size_t\nhgcd_matrix_apply (const struct hgcd_matrix *M,\n\t\t   mp_ptr ap, mp_ptr bp,\n\t\t   mp_size_t n)\n{\n  mp_size_t an, bn, un, vn, nn;\n  mp_size_t mn[2][2];\n  mp_size_t modn;\n  mp_ptr tp, sp, scratch;\n  mp_limb_t cy;\n  unsigned i, j;\n\n  TMP_DECL;\n\n  ASSERT ( (ap[n-1] | bp[n-1]) > 0);\n\n  an = n;\n  MPN_NORMALIZE (ap, an);\n  bn = n;\n  MPN_NORMALIZE (bp, bn);\n\n  for (i = 0; i < 2; i++)\n    for (j = 0; j < 2; j++)\n      {\n\tmp_size_t k;\n\tk = M->n;\n\tMPN_NORMALIZE (M->p[i][j], k);\n\tmn[i][j] = k;\n      }\n\n  ASSERT (mn[0][0] > 0);\n  ASSERT (mn[1][1] > 0);\n  ASSERT ( (mn[0][1] | mn[1][0]) > 0);\n\n  TMP_MARK;\n\n  if (mn[0][1] == 0)\n    {\n      /* A unchanged, M = (1, 0; q, 1) */\n      ASSERT (mn[0][0] == 1);\n      ASSERT (M->p[0][0][0] == 1);\n      ASSERT (mn[1][1] == 1);\n      ASSERT (M->p[1][1][0] == 1);\n\n      /* Put B <-- B - q A */\n      nn = submul (bp, bn, ap, an, M->p[1][0], mn[1][0]);\n    }\n  else if (mn[1][0] == 0)\n    {\n      /* B unchanged, M = (1, q; 0, 1) */\n      ASSERT (mn[0][0] == 1);\n      ASSERT (M->p[0][0][0] == 1);\n      ASSERT (mn[1][1] == 1);\n      ASSERT (M->p[1][1][0] == 1);\n\n      /* Put A  <-- A - q * B */\n      nn = submul (ap, an, bp, bn, M->p[0][1], mn[0][1]);\n    }\n  else\n    {\n      /* A = m00 a + m01 b  ==> a <= A / m00, b <= A / m01.\n\t B = m10 a + m11 b  ==> a <= B / m10, b <= B / m11. */\n      un = MIN (an - mn[0][0], bn - mn[1][0]) + 1;\n      vn = MIN (an - mn[0][1], bn - mn[1][1]) + 1;\n\n      nn = MAX (un, vn);\n      /* In the range of interest, mulmod_bnm1 should always beat mullo. */\n      modn = mpn_mulmod_bnm1_next_size (nn + 1);\n\n      TMP_ALLOC_LIMBS_3 (tp, modn,\n\t\t\t sp, modn,\n\t\t\t scratch, mpn_mulmod_bnm1_itch (modn, modn, M->n));\n\n      ASSERT (n <= 2*modn);\n\n      if (n > modn)\n\t{\n\t  cy = mpn_add (ap, ap, modn, ap + modn, n - modn);\n\t  MPN_INCR_U (ap, modn, cy);\n\n\t  cy = mpn_add (bp, bp, modn, bp + modn, n - modn);\n\t  MPN_INCR_U (bp, modn, cy);\n\n\t  n = modn;\n\t}\n\n      mpn_mulmod_bnm1 (tp, modn, ap, n, M->p[1][1], mn[1][1], scratch);\n      mpn_mulmod_bnm1 (sp, modn, bp, n, M->p[0][1], mn[0][1], scratch);\n\n      /* FIXME: Handle the small n case in some better way. */\n      if (n + mn[1][1] < modn)\n\tMPN_ZERO (tp + n + mn[1][1], modn - n - mn[1][1]);\n      if (n + mn[0][1] < modn)\n\tMPN_ZERO (sp + n + mn[0][1], modn - n - mn[0][1]);\n\n      cy = mpn_sub_n (tp, tp, sp, modn);\n      MPN_DECR_U (tp, modn, cy);\n\n      ASSERT (mpn_zero_p (tp + nn, modn - nn));\n\n      mpn_mulmod_bnm1 (sp, modn, ap, n, M->p[1][0], mn[1][0], scratch);\n      MPN_COPY (ap, tp, nn);\n      mpn_mulmod_bnm1 (tp, modn, bp, n, M->p[0][0], mn[0][0], scratch);\n\n      if (n + mn[1][0] < modn)\n\tMPN_ZERO (sp + n + mn[1][0], modn - n - mn[1][0]);\n      if (n + mn[0][0] < modn)\n\tMPN_ZERO (tp + n + mn[0][0], modn - n - mn[0][0]);\n\n      cy = mpn_sub_n (tp, tp, sp, modn);\n      MPN_DECR_U (tp, modn, cy);\n\n      ASSERT (mpn_zero_p (tp + nn, modn - nn));\n      MPN_COPY (bp, tp, nn);\n\n      while ( (ap[nn-1] | bp[nn-1]) == 0)\n\t{\n\t  nn--;\n\t  ASSERT (nn > 0);\n\t}\n    }\n  TMP_FREE;\n\n  return nn;\n}",
      "lines": 125,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_hgcd_reduce_itch": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "mp_size_t\nmpn_hgcd_reduce_itch (mp_size_t n, mp_size_t p)\n{\n  mp_size_t itch;\n  if (BELOW_THRESHOLD (n, HGCD_REDUCE_THRESHOLD))\n    {\n      itch = mpn_hgcd_itch (n-p);\n\n      /* For arbitrary p, the storage for _adjust is 2*(p + M->n) = 2 *\n\t (p + ceil((n-p)/2) - 1 <= n + p - 1 */\n      if (itch < n + p - 1)\n\titch = n + p - 1;\n    }\n  else\n    {\n      itch = 2*(n-p) + mpn_hgcd_itch (n-p);\n      /* Currently, hgcd_matrix_apply allocates its own storage. */\n    }\n  return itch;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_hgcd_reduce": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "mp_size_t\nmpn_hgcd_reduce (struct hgcd_matrix *M,\n\t\t mp_ptr ap, mp_ptr bp, mp_size_t n, mp_size_t p,\n\t\t mp_ptr tp)\n{\n  mp_size_t nn;\n  if (BELOW_THRESHOLD (n, HGCD_REDUCE_THRESHOLD))\n    {\n      nn = mpn_hgcd (ap + p, bp + p, n - p, M, tp);\n      if (nn > 0)\n\t/* Needs 2*(p + M->n) <= 2*(floor(n/2) + ceil(n/2) - 1)\n\t   = 2 (n - 1) */\n\treturn mpn_hgcd_matrix_adjust (M, p + nn, ap, bp, p, tp);\n    }\n  else\n    {\n      MPN_COPY (tp, ap + p, n - p);\n      MPN_COPY (tp + n - p, bp + p, n - p);\n      if (mpn_hgcd_appr (tp, tp + n - p, n - p, M, tp + 2*(n-p)))\n\treturn hgcd_matrix_apply (M, ap, bp, n);\n    }\n  return 0;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/hgcd_step.c": {
    "hgcd_hook": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\nhgcd_hook (void *p, mp_srcptr gp, mp_size_t gn,\n\t   mp_srcptr qp, mp_size_t qn, int d)\n{\n  ASSERT (!gp);\n  ASSERT (d >= 0);\n  ASSERT (d <= 1);\n\n  MPN_NORMALIZE (qp, qn);\n  if (qn > 0)\n    {\n      struct hgcd_matrix *M = (struct hgcd_matrix *) p;\n      /* NOTES: This is a bit ugly. A tp area is passed to\n\t gcd_subdiv_step, which stores q at the start of that area. We\n\t now use the rest. */\n      mp_ptr tp = (mp_ptr) qp + qn;\n      mpn_hgcd_matrix_update_q (M, qp, qn, d, tp);\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_hgcd_step": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "mp_size_t\nmpn_hgcd_step (mp_size_t n, mp_ptr ap, mp_ptr bp, mp_size_t s,\n\t       struct hgcd_matrix *M, mp_ptr tp)\n{\n  struct hgcd_matrix1 M1;\n  mp_limb_t mask;\n  mp_limb_t ah, al, bh, bl;\n\n  ASSERT (n > s);\n\n  mask = ap[n-1] | bp[n-1];\n  ASSERT (mask > 0);\n\n  if (n == s + 1)\n    {\n      if (mask < 4)\n\tgoto subtract;\n\n      ah = ap[n-1]; al = ap[n-2];\n      bh = bp[n-1]; bl = bp[n-2];\n    }\n  else if (mask & GMP_NUMB_HIGHBIT)\n    {\n      ah = ap[n-1]; al = ap[n-2];\n      bh = bp[n-1]; bl = bp[n-2];\n    }\n  else\n    {\n      int shift;\n\n      count_leading_zeros (shift, mask);\n      ah = MPN_EXTRACT_NUMB (shift, ap[n-1], ap[n-2]);\n      al = MPN_EXTRACT_NUMB (shift, ap[n-2], ap[n-3]);\n      bh = MPN_EXTRACT_NUMB (shift, bp[n-1], bp[n-2]);\n      bl = MPN_EXTRACT_NUMB (shift, bp[n-2], bp[n-3]);\n    }\n\n  /* Try an mpn_hgcd2 step */\n  if (mpn_hgcd2 (ah, al, bh, bl, &M1))\n    {\n      /* Multiply M <- M * M1 */\n      mpn_hgcd_matrix_mul_1 (M, &M1, tp);\n\n      /* Can't swap inputs, so we need to copy. */\n      MPN_COPY (tp, ap, n);\n      /* Multiply M1^{-1} (a;b) */\n      return mpn_matrix22_mul1_inverse_vector (&M1, ap, tp, bp, n);\n    }\n\n subtract:\n\n  return mpn_gcd_subdiv_step (ap, bp, n, s, hgcd_hook, M, tp);\n}",
      "lines": 53,
      "depth": 12,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/invert.c": {
    "mpn_invert": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\nmpn_invert (mp_ptr ip, mp_srcptr dp, mp_size_t n, mp_ptr scratch)\n{\n  ASSERT (n > 0);\n  ASSERT (dp[n-1] & GMP_NUMB_HIGHBIT);\n  ASSERT (! MPN_OVERLAP_P (ip, n, dp, n));\n  ASSERT (! MPN_OVERLAP_P (ip, n, scratch, mpn_invertappr_itch(n)));\n  ASSERT (! MPN_OVERLAP_P (dp, n, scratch, mpn_invertappr_itch(n)));\n\n  if (n == 1)\n    invert_limb (*ip, *dp);\n  else if (BELOW_THRESHOLD (n, INV_APPR_THRESHOLD))\n    {\n\t/* Maximum scratch needed by this branch: 2*n */\n\tmp_size_t i;\n\tmp_ptr xp;\n\n\txp = scratch;\t\t\t\t/* 2 * n limbs */\n\t/* n > 1 here */\n\ti = n;\n\tdo\n\t  xp[--i] = GMP_NUMB_MAX;\n\twhile (i);\n\tmpn_com (xp + n, dp, n);\n\tif (n == 2) {\n\t  mpn_divrem_2 (ip, 0, xp, 4, dp);\n\t} else {\n\t  gmp_pi1_t inv;\n\t  invert_pi1 (inv, dp[n-1], dp[n-2]);\n\t  /* FIXME: should we use dcpi1_div_q, for big sizes? */\n\t  mpn_sbpi1_div_q (ip, xp, 2 * n, dp, n, inv.inv32);\n\t}\n    }\n  else { /* Use approximated inverse; correct the result if needed. */\n      mp_limb_t e; /* The possible error in the approximate inverse */\n\n      ASSERT ( mpn_invert_itch (n) >= mpn_invertappr_itch (n) );\n      e = mpn_ni_invertappr (ip, dp, n, scratch);\n\n      if (UNLIKELY (e)) { /* Assume the error can only be \"0\" (no error) or \"1\". */\n\t/* Code to detect and correct the \"off by one\" approximation. */\n\tmpn_mul_n (scratch, ip, dp, n);\n\te = mpn_add_n (scratch, scratch, dp, n); /* FIXME: we only need e.*/\n\tif (LIKELY(e)) /* The high part can not give a carry by itself. */\n\t  e = mpn_add_nc (scratch + n, scratch + n, dp, n, e); /* FIXME:e */\n\t/* If the value was wrong (no carry), correct it (increment). */\n\te ^= CNST_LIMB (1);\n\tMPN_INCR_U (ip, n, e);\n      }\n  }\n}",
      "lines": 51,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/invertappr.c": {
    "mpn_bc_invertappr": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static mp_limb_t\nmpn_bc_invertappr (mp_ptr ip, mp_srcptr dp, mp_size_t n, mp_ptr xp)\n{\n  ASSERT (n > 0);\n  ASSERT (dp[n-1] & GMP_NUMB_HIGHBIT);\n  ASSERT (! MPN_OVERLAP_P (ip, n, dp, n));\n  ASSERT (! MPN_OVERLAP_P (ip, n, xp, mpn_invertappr_itch(n)));\n  ASSERT (! MPN_OVERLAP_P (dp, n, xp, mpn_invertappr_itch(n)));\n\n  /* Compute a base value of r limbs. */\n  if (n == 1)\n    invert_limb (*ip, *dp);\n  else {\n    mp_size_t i;\n\n    /* n > 1 here */\n    i = n;\n    do\n      xp[--i] = GMP_NUMB_MAX;\n    while (i);\n    mpn_com (xp + n, dp, n);\n\n    /* Now xp contains B^2n - {dp,n}*B^n - 1 */\n\n    /* FIXME: if mpn_*pi1_divappr_q handles n==2, use it! */\n    if (n == 2) {\n      mpn_divrem_2 (ip, 0, xp, 4, dp);\n    } else {\n      gmp_pi1_t inv;\n      invert_pi1 (inv, dp[n-1], dp[n-2]);\n      if (! MAYBE_dcpi1_divappr\n\t  || BELOW_THRESHOLD (n, DC_DIVAPPR_Q_THRESHOLD))\n\tmpn_sbpi1_divappr_q (ip, xp, 2 * n, dp, n, inv.inv32);\n      else\n\tmpn_dcpi1_divappr_q (ip, xp, 2 * n, dp, n, &inv);\n      MPN_DECR_U(ip, n, CNST_LIMB (1));\n      return 1;\n    }\n  }\n  return 0;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_ni_invertappr": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "mp_limb_t\nmpn_ni_invertappr (mp_ptr ip, mp_srcptr dp, mp_size_t n, mp_ptr scratch)\n{\n  mp_limb_t cy;\n  mp_size_t rn, mn;\n  mp_size_t sizes[NPOWS], *sizp;\n  mp_ptr tp;\n  TMP_DECL;\n#define xp scratch\n\n  ASSERT (n > 4);\n  ASSERT (dp[n-1] & GMP_NUMB_HIGHBIT);\n  ASSERT (! MPN_OVERLAP_P (ip, n, dp, n));\n  ASSERT (! MPN_OVERLAP_P (ip, n, scratch, mpn_invertappr_itch(n)));\n  ASSERT (! MPN_OVERLAP_P (dp, n, scratch, mpn_invertappr_itch(n)));\n\n  /* Compute the computation precisions from highest to lowest, leaving the\n     base case size in 'rn'.  */\n  sizp = sizes;\n  rn = n;\n  do {\n    *sizp = rn;\n    rn = (rn >> 1) + 1;\n    ++sizp;\n  } while (ABOVE_THRESHOLD (rn, INV_NEWTON_THRESHOLD));\n\n  /* We search the inverse of 0.{dp,n}, we compute it as 1.{ip,n} */\n  dp += n;\n  ip += n;\n\n  /* Compute a base value of rn limbs. */\n  mpn_bc_invertappr (ip - rn, dp - rn, rn, scratch);\n\n  TMP_MARK;\n\n  if (ABOVE_THRESHOLD (n, INV_MULMOD_BNM1_THRESHOLD))\n    {\n      mn = mpn_mulmod_bnm1_next_size (n + 1);\n      tp = TMP_ALLOC_LIMBS (mpn_mulmod_bnm1_itch (mn, n, (n >> 1) + 1));\n    }\n  /* Use Newton's iterations to get the desired precision.*/\n\n  while (1) {\n    n = *--sizp;\n    /*\n      v    n  v\n      +----+--+\n      ^ rn ^\n    */\n\n    /* Compute i_jd . */\n    if (BELOW_THRESHOLD (n, INV_MULMOD_BNM1_THRESHOLD)\n\t|| ((mn = mpn_mulmod_bnm1_next_size (n + 1)) > (n + rn))) {\n      /* FIXME: We do only need {xp,n+1}*/\n      mpn_mul (xp, dp - n, n, ip - rn, rn);\n      mpn_add_n (xp + rn, xp + rn, dp - n, n - rn + 1);\n      cy = CNST_LIMB(1); /* Remember we truncated, Mod B^(n+1) */\n      /* We computed (truncated) {xp,n+1} <- 1.{ip,rn} * 0.{dp,n} */\n    } else { /* Use B^mn-1 wraparound */\n      mpn_mulmod_bnm1 (xp, mn, dp - n, n, ip - rn, rn, tp);\n      /* We computed {xp,mn} <- {ip,rn} * {dp,n} mod (B^mn-1) */\n      /* We know that 2*|ip*dp + dp*B^rn - B^{rn+n}| < B^mn-1 */\n      /* Add dp*B^rn mod (B^mn-1) */\n      ASSERT (n >= mn - rn);\n      cy = mpn_add_n (xp + rn, xp + rn, dp - n, mn - rn);\n      cy = mpn_add_nc (xp, xp, dp - (n - (mn - rn)), n - (mn - rn), cy);\n      /* Subtract B^{rn+n}, maybe only compensate the carry*/\n      xp[mn] = CNST_LIMB (1); /* set a limit for DECR_U */\n      MPN_DECR_U (xp + rn + n - mn, 2 * mn + 1 - rn - n, CNST_LIMB (1) - cy);\n      MPN_DECR_U (xp, mn, CNST_LIMB (1) - xp[mn]); /* if DECR_U eroded xp[mn] */\n      cy = CNST_LIMB(0); /* Remember we are working Mod B^mn-1 */\n    }\n\n    if (xp[n] < CNST_LIMB (2)) { /* \"positive\" residue class */\n      cy = xp[n]; /* 0 <= cy <= 1 here. */\n#if HAVE_NATIVE_mpn_sublsh1_n\n      if (cy++) {\n\tif (mpn_cmp (xp, dp - n, n) > 0) {\n\t  mp_limb_t chk;\n\t  chk = mpn_sublsh1_n (xp, xp, dp - n, n);\n\t  ASSERT (chk == xp[n]);\n\t  ++ cy;\n\t} else\n\t  ASSERT_CARRY (mpn_sub_n (xp, xp, dp - n, n));\n      }\n#else /* no mpn_sublsh1_n*/\n      if (cy++ && !mpn_sub_n (xp, xp, dp - n, n)) {\n\tASSERT_CARRY (mpn_sub_n (xp, xp, dp - n, n));\n\t++cy;\n      }\n#endif\n      /* 1 <= cy <= 3 here. */\n#if HAVE_NATIVE_mpn_rsblsh1_n\n      if (mpn_cmp (xp, dp - n, n) > 0) {\n\tASSERT_NOCARRY (mpn_rsblsh1_n (xp + n, xp, dp - n, n));\n\t++cy;\n      } else\n\tASSERT_NOCARRY (mpn_sub_nc (xp + 2 * n - rn, dp - rn, xp + n - rn, rn, mpn_cmp (xp, dp - n, n - rn) > 0));\n#else /* no mpn_rsblsh1_n*/\n      if (mpn_cmp (xp, dp - n, n) > 0) {\n\tASSERT_NOCARRY (mpn_sub_n (xp, xp, dp - n, n));\n\t++cy;\n      }\n      ASSERT_NOCARRY (mpn_sub_nc (xp + 2 * n - rn, dp - rn, xp + n - rn, rn, mpn_cmp (xp, dp - n, n - rn) > 0));\n#endif\n      MPN_DECR_U(ip - rn, rn, cy); /* 1 <= cy <= 4 here. */\n    } else { /* \"negative\" residue class */\n      ASSERT (xp[n] >= GMP_NUMB_MAX - CNST_LIMB(1));\n      MPN_DECR_U(xp, n + 1, cy);\n      if (xp[n] != GMP_NUMB_MAX) {\n\tMPN_INCR_U(ip - rn, rn, CNST_LIMB (1));\n\tASSERT_CARRY (mpn_add_n (xp, xp, dp - n, n));\n      }\n      mpn_com (xp + 2 * n - rn, xp + n - rn, rn);\n    }\n\n    /* Compute x_ju_j. FIXME:We need {xp+rn,rn}, mulhi? */\n    mpn_mul_n (xp, xp + 2 * n - rn, ip - rn, rn);\n    cy = mpn_add_n (xp + rn, xp + rn, xp + 2 * n - rn, 2 * rn - n);\n    cy = mpn_add_nc (ip - n, xp + 3 * rn - n, xp + n + rn, n - rn, cy);\n    MPN_INCR_U (ip - rn, rn, cy);\n    if (sizp == sizes) { /* Get out of the cycle */\n      /* Check for possible carry propagation from below. */\n      cy = xp[3 * rn - n - 1] > GMP_NUMB_MAX - CNST_LIMB (7); /* Be conservative. */\n      /*    cy = mpn_add_1 (xp + rn, xp + rn, 2*rn - n, 4); */\n      break;\n    }\n    rn = n;\n  }\n  TMP_FREE;\n\n  return cy;\n#undef xp\n}",
      "lines": 134,
      "depth": 18,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_invertappr": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "mp_limb_t\nmpn_invertappr (mp_ptr ip, mp_srcptr dp, mp_size_t n, mp_ptr scratch)\n{\n  ASSERT (n > 0);\n  ASSERT (dp[n-1] & GMP_NUMB_HIGHBIT);\n  ASSERT (! MPN_OVERLAP_P (ip, n, dp, n));\n  ASSERT (! MPN_OVERLAP_P (ip, n, scratch, mpn_invertappr_itch(n)));\n  ASSERT (! MPN_OVERLAP_P (dp, n, scratch, mpn_invertappr_itch(n)));\n\n  if (BELOW_THRESHOLD (n, INV_NEWTON_THRESHOLD))\n    return mpn_bc_invertappr (ip, dp, n, scratch);\n  else\n    return mpn_ni_invertappr (ip, dp, n, scratch);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/jacbase.c": {
    "mpn_jacobi_base": [
      {
        "start_point": [
          137,
          0
        ],
        "end_point": [
          178,
          1
        ],
        "content": "int\nmpn_jacobi_base (mp_limb_t a, mp_limb_t b, int result_bit1)\n{\n  ASSERT (b & 1);  /* b odd */\n  ASSERT (b != 1);\n\n  if (a == 0)\n    return 0;\n\n  PROCESS_TWOS_ANY;\n  if (a == 1)\n    goto done;\n\n  if (a >= b)\n    goto a_gt_b;\n\n  for (;;)\n    {\n      result_bit1 ^= JACOBI_RECIP_UU_BIT1 (a, b);\n      MP_LIMB_T_SWAP (a, b);\n\n    a_gt_b:\n      do\n\t{\n\t  /* working on (a/b), a,b odd, a>=b */\n\t  ASSERT (a & 1);\n\t  ASSERT (b & 1);\n\t  ASSERT (a >= b);\n\n\t  if ((a -= b) == 0)\n\t    return 0;\n\n\t  PROCESS_TWOS_EVEN;\n\t  if (a == 1)\n\t    goto done;\n\t}\n      while (a >= b);\n    }\n\n done:\n  return JACOBI_BIT1_TO_PN (result_bit1);\n}",
        "lines": 42,
        "depth": 13,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          187,
          0
        ],
        "end_point": [
          241,
          1
        ],
        "content": "int\nmpn_jacobi_base (mp_limb_t a, mp_limb_t b, int bit)\n{\n  int c;\n\n  ASSERT (b & 1);\n  ASSERT (b > 1);\n\n  if (a == 0)\n    /* This is the only line which depends on b > 1 */\n    return 0;\n\n  bit >>= 1;\n\n  /* Below, we represent a and b shifted right so that the least\n     significant one bit is implicit. */\n\n  b >>= 1;\n\n  count_trailing_zeros (c, a);\n  bit ^= c & (b ^ (b >> 1));\n\n  /* We may have c==GMP_LIMB_BITS-1, so we can't use a>>c+1. */\n  a >>= c;\n  a >>= 1;\n\n  do\n    {\n      mp_limb_t t = a - b;\n      mp_limb_t bgta = LIMB_HIGHBIT_TO_MASK (t);\n\n      if (t == 0)\n\treturn 0;\n\n      /* If b > a, invoke reciprocity */\n      bit ^= (bgta & a & b);\n\n      /* b <-- min (a, b) */\n      b += (bgta & t);\n\n      /* a <-- |a - b| */\n      a = (t ^ bgta) - bgta;\n\n      /* Number of trailing zeros is the same no matter if we look at\n       * t or a, but using t gives more parallelism. */\n      count_trailing_zeros (c, t);\n      c ++;\n      /* (2/b) = -1 if b = 3 or 5 mod 8 */\n      bit ^= c & (b ^ (b >> 1));\n      a >>= c;\n    }\n  while (b > 0);\n\n  return 1-2*(bit & 1);\n}",
        "lines": 55,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/jacobi.c": {
    "jacobi_hook": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static void\njacobi_hook (void *p, mp_srcptr gp, mp_size_t gn,\n\t     mp_srcptr qp, mp_size_t qn, int d)\n{\n  unsigned *bitsp = (unsigned *) p;\n\n  if (gp)\n    {\n      ASSERT (gn > 0);\n      if (gn != 1 || gp[0] != 1)\n\t{\n\t  *bitsp = BITS_FAIL;\n\t  return;\n\t}\n    }\n\n  if (qp)\n    {\n      ASSERT (qn > 0);\n      ASSERT (d >= 0);\n      *bitsp = mpn_jacobi_update (*bitsp, d, qp[0] & 3);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_jacobi_n": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "int\nmpn_jacobi_n (mp_ptr ap, mp_ptr bp, mp_size_t n, unsigned bits)\n{\n  mp_size_t scratch;\n  mp_size_t matrix_scratch;\n  mp_ptr tp;\n\n  TMP_DECL;\n\n  ASSERT (n > 0);\n  ASSERT ( (ap[n-1] | bp[n-1]) > 0);\n  ASSERT ( (bp[0] | ap[0]) & 1);\n\n  /* FIXME: Check for small sizes first, before setting up temporary\n     storage etc. */\n  scratch = MPN_GCD_SUBDIV_STEP_ITCH(n);\n\n  if (ABOVE_THRESHOLD (n, GCD_DC_THRESHOLD))\n    {\n      mp_size_t hgcd_scratch;\n      mp_size_t update_scratch;\n      mp_size_t p = CHOOSE_P (n);\n      mp_size_t dc_scratch;\n\n      matrix_scratch = MPN_HGCD_MATRIX_INIT_ITCH (n - p);\n      hgcd_scratch = mpn_hgcd_itch (n - p);\n      update_scratch = p + n - 1;\n\n      dc_scratch = matrix_scratch + MAX(hgcd_scratch, update_scratch);\n      if (dc_scratch > scratch)\n\tscratch = dc_scratch;\n    }\n\n  TMP_MARK;\n  tp = TMP_ALLOC_LIMBS(scratch);\n\n  while (ABOVE_THRESHOLD (n, JACOBI_DC_THRESHOLD))\n    {\n      struct hgcd_matrix M;\n      mp_size_t p = 2*n/3;\n      mp_size_t matrix_scratch = MPN_HGCD_MATRIX_INIT_ITCH (n - p);\n      mp_size_t nn;\n      mpn_hgcd_matrix_init (&M, n - p, tp);\n\n      nn = mpn_hgcd_jacobi (ap + p, bp + p, n - p, &M, &bits,\n\t\t\t    tp + matrix_scratch);\n      if (nn > 0)\n\t{\n\t  ASSERT (M.n <= (n - p - 1)/2);\n\t  ASSERT (M.n + p <= (p + n - 1) / 2);\n\t  /* Temporary storage 2 (p + M->n) <= p + n - 1. */\n\t  n = mpn_hgcd_matrix_adjust (&M, p + nn, ap, bp, p, tp + matrix_scratch);\n\t}\n      else\n\t{\n\t  /* Temporary storage n */\n\t  n = mpn_gcd_subdiv_step (ap, bp, n, 0, jacobi_hook, &bits, tp);\n\t  if (!n)\n\t    {\n\t      TMP_FREE;\n\t      return bits == BITS_FAIL ? 0 : mpn_jacobi_finish (bits);\n\t    }\n\t}\n    }\n\n  while (n > 2)\n    {\n      struct hgcd_matrix1 M;\n      mp_limb_t ah, al, bh, bl;\n      mp_limb_t mask;\n\n      mask = ap[n-1] | bp[n-1];\n      ASSERT (mask > 0);\n\n      if (mask & GMP_NUMB_HIGHBIT)\n\t{\n\t  ah = ap[n-1]; al = ap[n-2];\n\t  bh = bp[n-1]; bl = bp[n-2];\n\t}\n      else\n\t{\n\t  int shift;\n\n\t  count_leading_zeros (shift, mask);\n\t  ah = MPN_EXTRACT_NUMB (shift, ap[n-1], ap[n-2]);\n\t  al = MPN_EXTRACT_NUMB (shift, ap[n-2], ap[n-3]);\n\t  bh = MPN_EXTRACT_NUMB (shift, bp[n-1], bp[n-2]);\n\t  bl = MPN_EXTRACT_NUMB (shift, bp[n-2], bp[n-3]);\n\t}\n\n      /* Try an mpn_nhgcd2 step */\n      if (mpn_hgcd2_jacobi (ah, al, bh, bl, &M, &bits))\n\t{\n\t  n = mpn_matrix22_mul1_inverse_vector (&M, tp, ap, bp, n);\n\t  MP_PTR_SWAP (ap, tp);\n\t}\n      else\n\t{\n\t  /* mpn_hgcd2 has failed. Then either one of a or b is very\n\t     small, or the difference is very small. Perform one\n\t     subtraction followed by one division. */\n\t  n = mpn_gcd_subdiv_step (ap, bp, n, 0, &jacobi_hook, &bits, tp);\n\t  if (!n)\n\t    {\n\t      TMP_FREE;\n\t      return bits == BITS_FAIL ? 0 : mpn_jacobi_finish (bits);\n\t    }\n\t}\n    }\n\n  if (bits >= 16)\n    MP_PTR_SWAP (ap, bp);\n\n  ASSERT (bp[0] & 1);\n\n  if (n == 1)\n    {\n      mp_limb_t al, bl;\n      al = ap[0];\n      bl = bp[0];\n\n      TMP_FREE;\n      if (bl == 1)\n\treturn 1 - 2*(bits & 1);\n      else\n\treturn mpn_jacobi_base (al, bl, bits << 1);\n    }\n\n  else\n    {\n      int res = mpn_jacobi_2 (ap, bp, bits & 1);\n      TMP_FREE;\n      return res;\n    }\n}",
      "lines": 135,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/jacobi_2.c": {
    "mpn_jacobi_2": [
      {
        "start_point": [
          45,
          0
        ],
        "end_point": [
          170,
          1
        ],
        "content": "int\nmpn_jacobi_2 (mp_srcptr ap, mp_srcptr bp, unsigned bit)\n{\n  mp_limb_t ah, al, bh, bl;\n  int c;\n\n  al = ap[0];\n  ah = ap[1];\n  bl = bp[0];\n  bh = bp[1];\n\n  ASSERT (bl & 1);\n\n  bl = ((bh << (GMP_NUMB_BITS - 1)) & GMP_NUMB_MASK) | (bl >> 1);\n  bh >>= 1;\n\n  if ( (bh | bl) == 0)\n    return 1 - 2*(bit & 1);\n\n  if ( (ah | al) == 0)\n    return 0;\n\n  if (al == 0)\n    {\n      al = ah;\n      ah = 0;\n      bit ^= GMP_NUMB_BITS & (bl ^ (bl >> 1));\n    }\n  count_trailing_zeros (c, al);\n  bit ^= c & (bl ^ (bl >> 1));\n\n  c++;\n  if (UNLIKELY (c == GMP_NUMB_BITS))\n    {\n      al = ah;\n      ah = 0;\n    }\n  else\n    {\n      al = ((ah << (GMP_NUMB_BITS - c)) & GMP_NUMB_MASK) | (al >> c);\n      ah >>= c;\n    }\n  while ( (ah | bh) > 0)\n    {\n      mp_limb_t th, tl;\n      mp_limb_t bgta;\n\n      sub_ddmmss (th, tl, ah, al, bh, bl);\n      if ( (tl | th) == 0)\n\treturn 0;\n\n      bgta = LIMB_HIGHBIT_TO_MASK (th);\n\n      /* If b > a, invoke reciprocity */\n      bit ^= (bgta & al & bl);\n\n      /* b <-- min (a, b) */\n      add_ssaaaa (bh, bl, bh, bl, th & bgta, tl & bgta);\n\n      if ( (bh | bl) == 0)\n\treturn 1 - 2*(bit & 1);\n\n      /* a <-- |a - b| */\n      al = (bgta ^ tl) - bgta;\n      ah = (bgta ^ th);\n\n      if (UNLIKELY (al == 0))\n\t{\n\t  /* If b > a, al == 0 implies that we have a carry to\n\t     propagate. */\n\t  al = ah - bgta;\n\t  ah = 0;\n\t  bit ^= GMP_NUMB_BITS & (bl ^ (bl >> 1));\n\t}\n      count_trailing_zeros (c, al);\n      c++;\n      bit ^= c & (bl ^ (bl >> 1));\n\n      if (UNLIKELY (c == GMP_NUMB_BITS))\n\t{\n\t  al = ah;\n\t  ah = 0;\n\t}\n      else\n\t{\n\t  al = ((ah << (GMP_NUMB_BITS - c)) & GMP_NUMB_MASK) | (al >> c);\n\t  ah >>= c;\n\t}\n    }\n\n  ASSERT (bl > 0);\n\n  while ( (al | bl) & GMP_LIMB_HIGHBIT)\n    {\n      /* Need an extra comparison to get the mask. */\n      mp_limb_t t = al - bl;\n      mp_limb_t bgta = - (bl > al);\n\n      if (t == 0)\n\treturn 0;\n\n      /* If b > a, invoke reciprocity */\n      bit ^= (bgta & al & bl);\n\n      /* b <-- min (a, b) */\n      bl += (bgta & t);\n\n      /* a <-- |a - b| */\n      al = (t ^ bgta) - bgta;\n\n      /* Number of trailing zeros is the same no matter if we look at\n       * t or a, but using t gives more parallelism. */\n      count_trailing_zeros (c, t);\n      c ++;\n      /* (2/b) = -1 if b = 3 or 5 mod 8 */\n      bit ^= c & (bl ^ (bl >> 1));\n\n      if (UNLIKELY (c == GMP_NUMB_BITS))\n\treturn 1 - 2*(bit & 1);\n\n      al >>= c;\n    }\n\n  /* Here we have a little impedance mismatch. Better to inline it? */\n  return mpn_jacobi_base (2*al+1, 2*bl+1, bit << 1);\n}",
        "lines": 126,
        "depth": 16,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          172,
          0
        ],
        "end_point": [
          348,
          1
        ],
        "content": "int\nmpn_jacobi_2 (mp_srcptr ap, mp_srcptr bp, unsigned bit)\n{\n  mp_limb_t ah, al, bh, bl;\n  int c;\n\n  al = ap[0];\n  ah = ap[1];\n  bl = bp[0];\n  bh = bp[1];\n\n  ASSERT (bl & 1);\n\n  /* Use bit 1. */\n  bit <<= 1;\n\n  if (bh == 0 && bl == 1)\n    /* (a|1) = 1 */\n    return 1 - (bit & 2);\n\n  if (al == 0)\n    {\n      if (ah == 0)\n\t/* (0|b) = 0, b > 1 */\n\treturn 0;\n\n      count_trailing_zeros (c, ah);\n      bit ^= ((GMP_NUMB_BITS + c) << 1) & (bl ^ (bl >> 1));\n\n      al = bl;\n      bl = ah >> c;\n\n      if (bl == 1)\n\t/* (1|b) = 1 */\n\treturn 1 - (bit & 2);\n\n      ah = bh;\n\n      bit ^= al & bl;\n\n      goto b_reduced;\n    }\n  if ( (al & 1) == 0)\n    {\n      count_trailing_zeros (c, al);\n\n      al = ((ah << (GMP_NUMB_BITS - c)) & GMP_NUMB_MASK) | (al >> c);\n      ah >>= c;\n      bit ^= (c << 1) & (bl ^ (bl >> 1));\n    }\n  if (ah == 0)\n    {\n      if (bh > 0)\n\t{\n\t  bit ^= al & bl;\n\t  MP_LIMB_T_SWAP (al, bl);\n\t  ah = bh;\n\t  goto b_reduced;\n\t}\n      goto ab_reduced;\n    }\n\n  while (bh > 0)\n    {\n      /* Compute (a|b) */\n      while (ah > bh)\n\t{\n\t  sub_ddmmss (ah, al, ah, al, bh, bl);\n\t  if (al == 0)\n\t    {\n\t      count_trailing_zeros (c, ah);\n\t      bit ^= ((GMP_NUMB_BITS + c) << 1) & (bl ^ (bl >> 1));\n\n\t      al = bl;\n\t      bl = ah >> c;\n\t      ah = bh;\n\n\t      bit ^= al & bl;\n\t      goto b_reduced;\n\t    }\n\t  count_trailing_zeros (c, al);\n\t  bit ^= (c << 1) & (bl ^ (bl >> 1));\n\t  al = ((ah << (GMP_NUMB_BITS - c)) & GMP_NUMB_MASK) | (al >> c);\n\t  ah >>= c;\n\t}\n      if (ah == bh)\n\tgoto cancel_hi;\n\n      if (ah == 0)\n\t{\n\t  bit ^= al & bl;\n\t  MP_LIMB_T_SWAP (al, bl);\n\t  ah = bh;\n\t  break;\n\t}\n\n      bit ^= al & bl;\n\n      /* Compute (b|a) */\n      while (bh > ah)\n\t{\n\t  sub_ddmmss (bh, bl, bh, bl, ah, al);\n\t  if (bl == 0)\n\t    {\n\t      count_trailing_zeros (c, bh);\n\t      bit ^= ((GMP_NUMB_BITS + c) << 1) & (al ^ (al >> 1));\n\n\t      bl = bh >> c;\n\t      bit ^= al & bl;\n\t      goto b_reduced;\n\t    }\n\t  count_trailing_zeros (c, bl);\n\t  bit ^= (c << 1) & (al ^ (al >> 1));\n\t  bl = ((bh << (GMP_NUMB_BITS - c)) & GMP_NUMB_MASK) | (bl >> c);\n\t  bh >>= c;\n\t}\n      bit ^= al & bl;\n\n      /* Compute (a|b) */\n      if (ah == bh)\n\t{\n\tcancel_hi:\n\t  if (al < bl)\n\t    {\n\t      MP_LIMB_T_SWAP (al, bl);\n\t      bit ^= al & bl;\n\t    }\n\t  al -= bl;\n\t  if (al == 0)\n\t    return 0;\n\n\t  count_trailing_zeros (c, al);\n\t  bit ^= (c << 1) & (bl ^ (bl >> 1));\n\t  al >>= c;\n\n\t  if (al == 1)\n\t    return 1 - (bit & 2);\n\n\t  MP_LIMB_T_SWAP (al, bl);\n\t  bit ^= al & bl;\n\t  break;\n\t}\n    }\n\n b_reduced:\n  /* Compute (a|b), with b a single limb. */\n  ASSERT (bl & 1);\n\n  if (bl == 1)\n    /* (a|1) = 1 */\n    return 1 - (bit & 2);\n\n  while (ah > 0)\n    {\n      ah -= (al < bl);\n      al -= bl;\n      if (al == 0)\n\t{\n\t  if (ah == 0)\n\t    return 0;\n\t  count_trailing_zeros (c, ah);\n\t  bit ^= ((GMP_NUMB_BITS + c) << 1) & (bl ^ (bl >> 1));\n\t  al = ah >> c;\n\t  goto ab_reduced;\n\t}\n      count_trailing_zeros (c, al);\n\n      al = ((ah << (GMP_NUMB_BITS - c)) & GMP_NUMB_MASK) | (al >> c);\n      ah >>= c;\n      bit ^= (c << 1) & (bl ^ (bl >> 1));\n    }\n ab_reduced:\n  ASSERT (bl & 1);\n  ASSERT (bl > 1);\n\n  return mpn_jacobi_base (al, bl, bit);\n}",
        "lines": 177,
        "depth": 16,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/logops_n.c": {
    "func": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\nfunc (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  call (rp, up, vp, n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/lshift.c": {
    "mpn_lshift": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "mp_limb_t\nmpn_lshift (mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)\n{\n  mp_limb_t high_limb, low_limb;\n  unsigned int tnc;\n  mp_size_t i;\n  mp_limb_t retval;\n\n  ASSERT (n >= 1);\n  ASSERT (cnt >= 1);\n  ASSERT (cnt < GMP_NUMB_BITS);\n  ASSERT (MPN_SAME_OR_DECR_P (rp, up, n));\n\n  up += n;\n  rp += n;\n\n  tnc = GMP_NUMB_BITS - cnt;\n  low_limb = *--up;\n  retval = low_limb >> tnc;\n  high_limb = (low_limb << cnt) & GMP_NUMB_MASK;\n\n  for (i = n - 1; i != 0; i--)\n    {\n      low_limb = *--up;\n      *--rp = high_limb | (low_limb >> tnc);\n      high_limb = (low_limb << cnt) & GMP_NUMB_MASK;\n    }\n  *--rp = high_limb;\n\n  return retval;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/lshiftc.c": {
    "mpn_lshiftc": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "mp_limb_t\nmpn_lshiftc (mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)\n{\n  mp_limb_t high_limb, low_limb;\n  unsigned int tnc;\n  mp_size_t i;\n  mp_limb_t retval;\n\n  ASSERT (n >= 1);\n  ASSERT (cnt >= 1);\n  ASSERT (cnt < GMP_NUMB_BITS);\n  ASSERT (MPN_SAME_OR_DECR_P (rp, up, n));\n\n  up += n;\n  rp += n;\n\n  tnc = GMP_NUMB_BITS - cnt;\n  low_limb = *--up;\n  retval = low_limb >> tnc;\n  high_limb = (low_limb << cnt);\n\n  for (i = n - 1; i != 0; i--)\n    {\n      low_limb = *--up;\n      *--rp = (~(high_limb | (low_limb >> tnc))) & GMP_NUMB_MASK;\n      high_limb = low_limb << cnt;\n    }\n  *--rp = (~high_limb) & GMP_NUMB_MASK;\n\n  return retval;\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/matrix22_mul.c": {
    "abs_sub_n": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static int\nabs_sub_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  int c;\n  MPN_CMP (c, ap, bp, n);\n  if (c >= 0)\n    {\n      mpn_sub_n (rp, ap, bp, n);\n      return 0;\n    }\n  else\n    {\n      mpn_sub_n (rp, bp, ap, n);\n      return 1;\n    }\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "add_signed_n": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static int\nadd_signed_n (mp_ptr rp,\n\t      mp_srcptr ap, int as, mp_srcptr bp, int bs, mp_size_t n)\n{\n  if (as != bs)\n    return as ^ abs_sub_n (rp, ap, bp, n);\n  else\n    {\n      ASSERT_NOCARRY (mpn_add_n (rp, ap, bp, n));\n      return as;\n    }\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpn_matrix22_mul_itch": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "mp_size_t\nmpn_matrix22_mul_itch (mp_size_t rn, mp_size_t mn)\n{\n  if (BELOW_THRESHOLD (rn, MATRIX22_STRASSEN_THRESHOLD)\n      || BELOW_THRESHOLD (mn, MATRIX22_STRASSEN_THRESHOLD))\n    return 3*rn + 2*mn;\n  else\n    return 3*(rn + mn) + 5;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_matrix22_mul_strassen": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "void\nmpn_matrix22_mul_strassen (mp_ptr r0, mp_ptr r1, mp_ptr r2, mp_ptr r3, mp_size_t rn,\n\t\t\t   mp_srcptr m0, mp_srcptr m1, mp_srcptr m2, mp_srcptr m3, mp_size_t mn,\n\t\t\t   mp_ptr tp)\n{\n  mp_ptr s0, t0, u0, u1;\n  int r1s, r3s, s0s, t0s, u1s;\n  s0 = tp; tp += rn + 1;\n  t0 = tp; tp += mn + 1;\n  u0 = tp; tp += rn + mn + 1;\n  u1 = tp; /* rn + mn + 2 */\n\n  MUL (u0, r1, rn, m2, mn);\t\t/* u5 = s5 * t6 */\n  r3s = abs_sub_n (r3, r3, r2, rn);\t/* r3 - r2 */\n  if (r3s)\n    {\n      r1s = abs_sub_n (r1, r1, r3, rn);\n      r1[rn] = 0;\n    }\n  else\n    {\n      r1[rn] = mpn_add_n (r1, r1, r3, rn);\n      r1s = 0;\t\t\t\t/* r1 - r2 + r3  */\n    }\n  if (r1s)\n    {\n      s0[rn] = mpn_add_n (s0, r1, r0, rn);\n      s0s = 0;\n    }\n  else if (r1[rn] != 0)\n    {\n      s0[rn] = r1[rn] - mpn_sub_n (s0, r1, r0, rn);\n      s0s = 1;\t\t\t\t/* s4 = -r0 + r1 - r2 + r3 */\n\t\t\t\t\t/* Reverse sign! */\n    }\n  else\n    {\n      s0s = abs_sub_n (s0, r0, r1, rn);\n      s0[rn] = 0;\n    }\n  MUL (u1, r0, rn, m0, mn);\t\t/* u0 = s0 * t0 */\n  r0[rn+mn] = mpn_add_n (r0, u0, u1, rn + mn);\n  ASSERT (r0[rn+mn] < 2);\t\t/* u0 + u5 */\n\n  t0s = abs_sub_n (t0, m3, m2, mn);\n  u1s = r3s^t0s^1;\t\t\t/* Reverse sign! */\n  MUL (u1, r3, rn, t0, mn);\t\t/* u2 = s2 * t2 */\n  u1[rn+mn] = 0;\n  if (t0s)\n    {\n      t0s = abs_sub_n (t0, m1, t0, mn);\n      t0[mn] = 0;\n    }\n  else\n    {\n      t0[mn] = mpn_add_n (t0, t0, m1, mn);\n    }\n\n  /* FIXME: Could be simplified if we had space for rn + mn + 2 limbs\n     at r3. I'd expect that for matrices of random size, the high\n     words t0[mn] and r1[rn] are non-zero with a pretty small\n     probability. If that can be confirmed this should be done as an\n     unconditional rn x (mn+1) followed by an if (UNLIKELY (r1[rn]))\n     add_n. */\n  if (t0[mn] != 0)\n    {\n      MUL (r3, r1, rn, t0, mn + 1);\t/* u3 = s3 * t3 */\n      ASSERT (r1[rn] < 2);\n      if (r1[rn] != 0)\n\tmpn_add_n (r3 + rn, r3 + rn, t0, mn + 1);\n    }\n  else\n    {\n      MUL (r3, r1, rn + 1, t0, mn);\n    }\n\n  ASSERT (r3[rn+mn] < 4);\n\n  u0[rn+mn] = 0;\n  if (r1s^t0s)\n    {\n      r3s = abs_sub_n (r3, u0, r3, rn + mn + 1);\n    }\n  else\n    {\n      ASSERT_NOCARRY (mpn_add_n (r3, r3, u0, rn + mn + 1));\n      r3s = 0;\t\t\t\t/* u3 + u5 */\n    }\n\n  if (t0s)\n    {\n      t0[mn] = mpn_add_n (t0, t0, m0, mn);\n    }\n  else if (t0[mn] != 0)\n    {\n      t0[mn] -= mpn_sub_n (t0, t0, m0, mn);\n    }\n  else\n    {\n      t0s = abs_sub_n (t0, t0, m0, mn);\n    }\n  MUL (u0, r2, rn, t0, mn + 1);\t\t/* u6 = s6 * t4 */\n  ASSERT (u0[rn+mn] < 2);\n  if (r1s)\n    {\n      ASSERT_NOCARRY (mpn_sub_n (r1, r2, r1, rn));\n    }\n  else\n    {\n      r1[rn] += mpn_add_n (r1, r1, r2, rn);\n    }\n  rn++;\n  t0s = add_signed_n (r2, r3, r3s, u0, t0s, rn + mn);\n\t\t\t\t\t/* u3 + u5 + u6 */\n  ASSERT (r2[rn+mn-1] < 4);\n  r3s = add_signed_n (r3, r3, r3s, u1, u1s, rn + mn);\n\t\t\t\t\t/* -u2 + u3 + u5  */\n  ASSERT (r3[rn+mn-1] < 3);\n  MUL (u0, s0, rn, m1, mn);\t\t/* u4 = s4 * t5 */\n  ASSERT (u0[rn+mn-1] < 2);\n  t0[mn] = mpn_add_n (t0, m3, m1, mn);\n  MUL (u1, r1, rn, t0, mn + 1);\t\t/* u1 = s1 * t1 */\n  mn += rn;\n  ASSERT (u1[mn-1] < 4);\n  ASSERT (u1[mn] == 0);\n  ASSERT_NOCARRY (add_signed_n (r1, r3, r3s, u0, s0s, mn));\n\t\t\t\t\t/* -u2 + u3 - u4 + u5  */\n  ASSERT (r1[mn-1] < 2);\n  if (r3s)\n    {\n      ASSERT_NOCARRY (mpn_add_n (r3, u1, r3, mn));\n    }\n  else\n    {\n      ASSERT_NOCARRY (mpn_sub_n (r3, u1, r3, mn));\n\t\t\t\t\t/* u1 + u2 - u3 - u5  */\n    }\n  ASSERT (r3[mn-1] < 2);\n  if (t0s)\n    {\n      ASSERT_NOCARRY (mpn_add_n (r2, u1, r2, mn));\n    }\n  else\n    {\n      ASSERT_NOCARRY (mpn_sub_n (r2, u1, r2, mn));\n\t\t\t\t\t/* u1 - u3 - u5 - u6  */\n    }\n  ASSERT (r2[mn-1] < 2);\n}",
      "lines": 149,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpn_matrix22_mul": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "void\nmpn_matrix22_mul (mp_ptr r0, mp_ptr r1, mp_ptr r2, mp_ptr r3, mp_size_t rn,\n\t\t  mp_srcptr m0, mp_srcptr m1, mp_srcptr m2, mp_srcptr m3, mp_size_t mn,\n\t\t  mp_ptr tp)\n{\n  if (BELOW_THRESHOLD (rn, MATRIX22_STRASSEN_THRESHOLD)\n      || BELOW_THRESHOLD (mn, MATRIX22_STRASSEN_THRESHOLD))\n    {\n      mp_ptr p0, p1;\n      unsigned i;\n\n      /* Temporary storage: 3 rn + 2 mn */\n      p0 = tp + rn;\n      p1 = p0 + rn + mn;\n\n      for (i = 0; i < 2; i++)\n\t{\n\t  MPN_COPY (tp, r0, rn);\n\n\t  if (rn >= mn)\n\t    {\n\t      mpn_mul (p0, r0, rn, m0, mn);\n\t      mpn_mul (p1, r1, rn, m3, mn);\n\t      mpn_mul (r0, r1, rn, m2, mn);\n\t      mpn_mul (r1, tp, rn, m1, mn);\n\t    }\n\t  else\n\t    {\n\t      mpn_mul (p0, m0, mn, r0, rn);\n\t      mpn_mul (p1, m3, mn, r1, rn);\n\t      mpn_mul (r0, m2, mn, r1, rn);\n\t      mpn_mul (r1, m1, mn, tp, rn);\n\t    }\n\t  r0[rn+mn] = mpn_add_n (r0, r0, p0, rn + mn);\n\t  r1[rn+mn] = mpn_add_n (r1, r1, p1, rn + mn);\n\n\t  r0 = r2; r1 = r3;\n\t}\n    }\n  else\n    mpn_matrix22_mul_strassen (r0, r1, r2, r3, rn,\n\t\t\t       m0, m1, m2, m3, mn, tp);\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/matrix22_mul1_inverse_vector.c": {
    "mpn_matrix22_mul1_inverse_vector": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "mp_size_t\nmpn_matrix22_mul1_inverse_vector (const struct hgcd_matrix1 *M,\n\t\t\t\t  mp_ptr rp, mp_srcptr ap, mp_ptr bp, mp_size_t n)\n{\n  mp_limb_t h0, h1;\n\n  /* Compute (r;b) <-- (u11 a - u01 b; -u10 a + u00 b) as\n\n     r  = u11 * a\n     r -= u01 * b\n     b *= u00\n     b -= u10 * a\n  */\n\n  h0 =    mpn_mul_1 (rp, ap, n, M->u[1][1]);\n  h1 = mpn_submul_1 (rp, bp, n, M->u[0][1]);\n  ASSERT (h0 == h1);\n\n  h0 =    mpn_mul_1 (bp, bp, n, M->u[0][0]);\n  h1 = mpn_submul_1 (bp, ap, n, M->u[1][0]);\n  ASSERT (h0 == h1);\n\n  n -= (rp[n-1] | bp[n-1]) == 0;\n  return n;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mode1o.c": {
    "mpn_modexact_1c_odd": [
      {
        "start_point": [
          113,
          0
        ],
        "end_point": [
          187,
          1
        ],
        "content": "mp_limb_t\nmpn_modexact_1c_odd (mp_srcptr src, mp_size_t size, mp_limb_t d,\n                     mp_limb_t orig_c)\n{\n  mp_limb_t  s, h, l, inverse, dummy, dmul, ret;\n  mp_limb_t  c = orig_c;\n  mp_size_t  i;\n\n  ASSERT (size >= 1);\n  ASSERT (d & 1);\n  ASSERT_MPN (src, size);\n  ASSERT_LIMB (d);\n  ASSERT_LIMB (c);\n\n  if (size == 1)\n    {\n      s = src[0];\n      if (s > c)\n\t{\n\t  l = s-c;\n\t  h = l % d;\n\t  if (h != 0)\n\t    h = d - h;\n\t}\n      else\n\t{\n\t  l = c-s;\n\t  h = l % d;\n\t}\n      return h;\n    }\n\n\n  binvert_limb (inverse, d);\n  dmul = d << GMP_NAIL_BITS;\n\n  i = 0;\n  do\n    {\n      s = src[i];\n      SUBC_LIMB (c, l, s, c);\n      l = (l * inverse) & GMP_NUMB_MASK;\n      umul_ppmm (h, dummy, l, dmul);\n      c += h;\n    }\n  while (++i < size-1);\n\n\n  s = src[i];\n  if (s <= d)\n    {\n      /* With high<=d the final step can be a subtract and addback.  If c==0\n\t then the addback will restore to l>=0.  If c==d then will get l==d\n\t if s==0, but that's ok per the function definition.  */\n\n      l = c - s;\n      if (c < s)\n\tl += d;\n\n      ret = l;\n    }\n  else\n    {\n      /* Can't skip a divide, just do the loop code once more. */\n\n      SUBC_LIMB (c, l, s, c);\n      l = (l * inverse) & GMP_NUMB_MASK;\n      umul_ppmm (h, dummy, l, dmul);\n      c += h;\n      ret = c;\n    }\n\n  ASSERT (orig_c < d ? ret < d : ret <= d);\n  return ret;\n}",
        "lines": 75,
        "depth": 11,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          204,
          0
        ],
        "end_point": [
          233,
          1
        ],
        "content": "mp_limb_t\nmpn_modexact_1c_odd (mp_srcptr src, mp_size_t size, mp_limb_t d, mp_limb_t h)\n{\n  mp_limb_t  s, x, y, inverse, dummy, dmul, c1, c2;\n  mp_limb_t  c = 0;\n  mp_size_t  i;\n\n  ASSERT (size >= 1);\n  ASSERT (d & 1);\n\n  binvert_limb (inverse, d);\n  dmul = d << GMP_NAIL_BITS;\n\n  for (i = 0; i < size; i++)\n    {\n      ASSERT (c==0 || c==1);\n\n      s = src[i];\n      SUBC_LIMB (c1, x, s, c);\n\n      SUBC_LIMB (c2, y, x, h);\n      c = c1 + c2;\n\n      y = (y * inverse) & GMP_NUMB_MASK;\n      umul_ppmm (h, dummy, y, dmul);\n    }\n\n  h += c;\n  return h;\n}",
        "lines": 30,
        "depth": 10,
        "decorators": [
          "mp_limb_t"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/mod_1.c": {
    "mpn_mod_1_unnorm": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static mp_limb_t\nmpn_mod_1_unnorm (mp_srcptr up, mp_size_t un, mp_limb_t d)\n{\n  mp_size_t  i;\n  mp_limb_t  n1, n0, r;\n  mp_limb_t  dummy;\n  int cnt;\n\n  ASSERT (un > 0);\n  ASSERT (d != 0);\n\n  d <<= GMP_NAIL_BITS;\n\n  /* Skip a division if high < divisor.  Having the test here before\n     normalizing will still skip as often as possible.  */\n  r = up[un - 1] << GMP_NAIL_BITS;\n  if (r < d)\n    {\n      r >>= GMP_NAIL_BITS;\n      un--;\n      if (un == 0)\n\treturn r;\n    }\n  else\n    r = 0;\n\n  /* If udiv_qrnnd doesn't need a normalized divisor, can use the simple\n     code above. */\n  if (! UDIV_NEEDS_NORMALIZATION\n      && BELOW_THRESHOLD (un, MOD_1_UNNORM_THRESHOLD))\n    {\n      for (i = un - 1; i >= 0; i--)\n\t{\n\t  n0 = up[i] << GMP_NAIL_BITS;\n\t  udiv_qrnnd (dummy, r, r, n0, d);\n\t  r >>= GMP_NAIL_BITS;\n\t}\n      return r;\n    }\n\n  count_leading_zeros (cnt, d);\n  d <<= cnt;\n\n  n1 = up[un - 1] << GMP_NAIL_BITS;\n  r = (r << cnt) | (n1 >> (GMP_LIMB_BITS - cnt));\n\n  if (UDIV_NEEDS_NORMALIZATION\n      && BELOW_THRESHOLD (un, MOD_1_UNNORM_THRESHOLD))\n    {\n      mp_limb_t nshift;\n      for (i = un - 2; i >= 0; i--)\n\t{\n\t  n0 = up[i] << GMP_NAIL_BITS;\n\t  nshift = (n1 << cnt) | (n0 >> (GMP_NUMB_BITS - cnt));\n\t  udiv_qrnnd (dummy, r, r, nshift, d);\n\t  r >>= GMP_NAIL_BITS;\n\t  n1 = n0;\n\t}\n      udiv_qrnnd (dummy, r, r, n1 << cnt, d);\n      r >>= GMP_NAIL_BITS;\n      return r >> cnt;\n    }\n  else\n    {\n      mp_limb_t inv, nshift;\n      invert_limb (inv, d);\n\n      for (i = un - 2; i >= 0; i--)\n\t{\n\t  n0 = up[i] << GMP_NAIL_BITS;\n\t  nshift = (n1 << cnt) | (n0 >> (GMP_NUMB_BITS - cnt));\n\t  udiv_rnnd_preinv (r, r, nshift, d, inv);\n\t  r >>= GMP_NAIL_BITS;\n\t  n1 = n0;\n\t}\n      udiv_rnnd_preinv (r, r, n1 << cnt, d, inv);\n      r >>= GMP_NAIL_BITS;\n      return r >> cnt;\n    }\n}",
      "lines": 80,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_mod_1_norm": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static mp_limb_t\nmpn_mod_1_norm (mp_srcptr up, mp_size_t un, mp_limb_t d)\n{\n  mp_size_t  i;\n  mp_limb_t  n0, r;\n  mp_limb_t  dummy;\n\n  ASSERT (un > 0);\n\n  d <<= GMP_NAIL_BITS;\n\n  ASSERT (d & GMP_LIMB_HIGHBIT);\n\n  /* High limb is initial remainder, possibly with one subtract of\n     d to get r<d.  */\n  r = up[un - 1] << GMP_NAIL_BITS;\n  if (r >= d)\n    r -= d;\n  r >>= GMP_NAIL_BITS;\n  un--;\n  if (un == 0)\n    return r;\n\n  if (BELOW_THRESHOLD (un, MOD_1_NORM_THRESHOLD))\n    {\n      for (i = un - 1; i >= 0; i--)\n\t{\n\t  n0 = up[i] << GMP_NAIL_BITS;\n\t  udiv_qrnnd (dummy, r, r, n0, d);\n\t  r >>= GMP_NAIL_BITS;\n\t}\n      return r;\n    }\n  else\n    {\n      mp_limb_t  inv;\n      invert_limb (inv, d);\n      for (i = un - 1; i >= 0; i--)\n\t{\n\t  n0 = up[i] << GMP_NAIL_BITS;\n\t  udiv_rnnd_preinv (r, r, n0, d, inv);\n\t  r >>= GMP_NAIL_BITS;\n\t}\n      return r;\n    }\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_mod_1": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "mp_limb_t\nmpn_mod_1 (mp_srcptr ap, mp_size_t n, mp_limb_t b)\n{\n  ASSERT (n >= 0);\n  ASSERT (b != 0);\n\n  /* Should this be handled at all?  Rely on callers?  Note un==0 is currently\n     required by mpz/fdiv_r_ui.c and possibly other places.  */\n  if (n == 0)\n    return 0;\n\n  if (UNLIKELY ((b & GMP_NUMB_HIGHBIT) != 0))\n    {\n      if (BELOW_THRESHOLD (n, MOD_1N_TO_MOD_1_1_THRESHOLD))\n\t{\n\t  return mpn_mod_1_norm (ap, n, b);\n\t}\n      else\n\t{\n\t  mp_limb_t pre[4];\n\t  mpn_mod_1_1p_cps (pre, b);\n\t  return mpn_mod_1_1p (ap, n, b, pre);\n\t}\n    }\n  else\n    {\n      if (BELOW_THRESHOLD (n, MOD_1U_TO_MOD_1_1_THRESHOLD))\n\t{\n\t  return mpn_mod_1_unnorm (ap, n, b);\n\t}\n      else if (BELOW_THRESHOLD (n, MOD_1_1_TO_MOD_1_2_THRESHOLD))\n\t{\n\t  mp_limb_t pre[4];\n\t  mpn_mod_1_1p_cps (pre, b);\n\t  return mpn_mod_1_1p (ap, n, b << pre[1], pre);\n\t}\n      else if (BELOW_THRESHOLD (n, MOD_1_2_TO_MOD_1_4_THRESHOLD) || UNLIKELY (b > GMP_NUMB_MASK / 4))\n\t{\n\t  mp_limb_t pre[5];\n\t  mpn_mod_1s_2p_cps (pre, b);\n\t  return mpn_mod_1s_2p (ap, n, b << pre[1], pre);\n\t}\n      else\n\t{\n\t  mp_limb_t pre[7];\n\t  mpn_mod_1s_4p_cps (pre, b);\n\t  return mpn_mod_1s_4p (ap, n, b << pre[1], pre);\n\t}\n    }\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mod_1_1.c": {
    "mpn_mod_1_1p_cps": [
      {
        "start_point": [
          158,
          0
        ],
        "end_point": [
          186,
          1
        ],
        "content": "void\nmpn_mod_1_1p_cps (mp_limb_t cps[4], mp_limb_t b)\n{\n  mp_limb_t bi;\n  mp_limb_t B1modb, B2modb;\n  int cnt;\n\n  count_leading_zeros (cnt, b);\n\n  b <<= cnt;\n  invert_limb (bi, b);\n\n  cps[0] = bi;\n  cps[1] = cnt;\n\n  B1modb = -b;\n  if (LIKELY (cnt != 0))\n    B1modb *= ((bi >> (GMP_LIMB_BITS-cnt)) | (CNST_LIMB(1) << cnt));\n  ASSERT (B1modb <= b);\t\t/* NB: not fully reduced mod b */\n  cps[2] = B1modb >> cnt;\n\n  /* In the normalized case, this can be simplified to\n   *\n   *   B2modb = - b * bi;\n   *   ASSERT (B2modb <= b);    // NB: equality iff b = B/2\n   */\n  udiv_rnnd_preinv (B2modb, B1modb, CNST_LIMB(0), b, bi);\n  cps[3] = B2modb >> cnt;\n}",
        "lines": 29,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          235,
          0
        ],
        "end_point": [
          260,
          1
        ],
        "content": "void\nmpn_mod_1_1p_cps (mp_limb_t cps[4], mp_limb_t b)\n{\n  mp_limb_t bi;\n  mp_limb_t B2modb;\n  int cnt;\n\n  count_leading_zeros (cnt, b);\n\n  b <<= cnt;\n  invert_limb (bi, b);\n\n  cps[0] = bi;\n  cps[1] = cnt;\n\n  if (LIKELY (cnt != 0))\n    {\n      mp_limb_t B1modb = -b;\n      B1modb *= ((bi >> (GMP_LIMB_BITS-cnt)) | (CNST_LIMB(1) << cnt));\n      ASSERT (B1modb <= b);\t\t/* NB: not fully reduced mod b */\n      cps[2] = B1modb >> cnt;\n    }\n  B2modb = - b * bi;\n  ASSERT (B2modb <= b);    // NB: equality iff b = B/2\n  cps[3] = B2modb;\n}",
        "lines": 26,
        "depth": 13,
        "decorators": [
          "void"
        ]
      }
    ],
    "mpn_mod_1_1p": [
      {
        "start_point": [
          188,
          0
        ],
        "end_point": [
          231,
          1
        ],
        "content": "mp_limb_t\nmpn_mod_1_1p (mp_srcptr ap, mp_size_t n, mp_limb_t b, const mp_limb_t bmodb[4])\n{\n  mp_limb_t rh, rl, bi, ph, pl, r;\n  mp_limb_t B1modb, B2modb;\n  mp_size_t i;\n  int cnt;\n  mp_limb_t mask;\n\n  ASSERT (n >= 2);\t\t/* fix tuneup.c if this is changed */\n\n  B1modb = bmodb[2];\n  B2modb = bmodb[3];\n\n  rl = ap[n - 1];\n  umul_ppmm (ph, pl, rl, B1modb);\n  add_ssaaaa (rh, rl, ph, pl, CNST_LIMB(0), ap[n - 2]);\n\n  for (i = n - 3; i >= 0; i -= 1)\n    {\n      /* rr = ap[i]\t\t\t\t< B\n\t    + LO(rr)  * (B mod b)\t\t<= (B-1)(b-1)\n\t    + HI(rr)  * (B^2 mod b)\t\t<= (B-1)(b-1)\n      */\n      umul_ppmm (ph, pl, rl, B1modb);\n      add_ssaaaa (ph, pl, ph, pl, CNST_LIMB(0), ap[i]);\n\n      umul_ppmm (rh, rl, rh, B2modb);\n      add_ssaaaa (rh, rl, rh, rl, ph, pl);\n    }\n\n  cnt = bmodb[1];\n  bi = bmodb[0];\n\n  if (LIKELY (cnt != 0))\n    rh = (rh << cnt) | (rl >> (GMP_LIMB_BITS - cnt));\n\n  mask = -(mp_limb_t) (rh >= b);\n  rh -= mask & b;\n\n  udiv_rnnd_preinv (r, rh, rl << cnt, b, bi);\n\n  return r >> cnt;\n}",
        "lines": 44,
        "depth": 11,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          262,
          0
        ],
        "end_point": [
          330,
          1
        ],
        "content": "mp_limb_t\nmpn_mod_1_1p (mp_srcptr ap, mp_size_t n, mp_limb_t b, const mp_limb_t bmodb[4])\n{\n  int cnt;\n  mp_limb_t bi, B1modb;\n  mp_limb_t r0, r1;\n  mp_limb_t r;\n\n  ASSERT (n >= 2);\t\t/* fix tuneup.c if this is changed */\n\n  r0 = ap[n-2];\n  r1 = ap[n-1];\n\n  if (n > 2)\n    {\n      mp_limb_t B2modb, B2mb;\n      mp_limb_t p0, p1;\n      mp_limb_t r2;\n      mp_size_t j;\n\n      B2modb = bmodb[3];\n      B2mb = B2modb - b;\n\n      umul_ppmm (p1, p0, r1, B2modb);\n      add_mssaaaa (r2, r1, r0, r0, ap[n-3], p1, p0);\n\n      for (j = n-4; j >= 0; j--)\n\t{\n\t  mp_limb_t cy;\n\t  /* mp_limb_t t = r0 + B2mb; */\n\t  umul_ppmm (p1, p0, r1, B2modb);\n\n\t  ADDC_LIMB (cy, r0, r0, r2 & B2modb);\n\t  /* Alternative, for cmov: if (cy) r0 = t; */\n\t  r0 -= (-cy) & b;\n\t  add_mssaaaa (r2, r1, r0, r0, ap[j], p1, p0);\n\t}\n\n      r1 -= (r2 & b);\n    }\n\n  cnt = bmodb[1];\n\n  if (LIKELY (cnt != 0))\n    {\n      mp_limb_t t;\n      mp_limb_t B1modb = bmodb[2];\n\n      umul_ppmm (r1, t, r1, B1modb);\n      r0 += t;\n      r1 += (r0 < t);\n\n      /* Normalize */\n      r1 = (r1 << cnt) | (r0 >> (GMP_LIMB_BITS - cnt));\n      r0 <<= cnt;\n\n      /* NOTE: Might get r1 == b here, but udiv_rnnd_preinv allows that. */\n    }\n  else\n    {\n      mp_limb_t mask = -(mp_limb_t) (r1 >= b);\n      r1 -= mask & b;\n    }\n\n  bi = bmodb[0];\n\n  udiv_rnnd_preinv (r, r1, r0, b, bi);\n  return r >> cnt;\n}",
        "lines": 69,
        "depth": 12,
        "decorators": [
          "mp_limb_t"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/mod_1_2.c": {
    "mpn_mod_1s_2p_cps": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\nmpn_mod_1s_2p_cps (mp_limb_t cps[5], mp_limb_t b)\n{\n  mp_limb_t bi;\n  mp_limb_t B1modb, B2modb, B3modb;\n  int cnt;\n\n  ASSERT (b <= (~(mp_limb_t) 0) / 2);\n\n  count_leading_zeros (cnt, b);\n\n  b <<= cnt;\n  invert_limb (bi, b);\n\n  cps[0] = bi;\n  cps[1] = cnt;\n\n  B1modb = -b * ((bi >> (GMP_LIMB_BITS-cnt)) | (CNST_LIMB(1) << cnt));\n  ASSERT (B1modb <= b);\t\t/* NB: not fully reduced mod b */\n  cps[2] = B1modb >> cnt;\n\n  udiv_rnnd_preinv (B2modb, B1modb, CNST_LIMB(0), b, bi);\n  cps[3] = B2modb >> cnt;\n\n  udiv_rnnd_preinv (B3modb, B2modb, CNST_LIMB(0), b, bi);\n  cps[4] = B3modb >> cnt;\n\n#if WANT_ASSERT\n  {\n    int i;\n    b = cps[2];\n    for (i = 3; i <= 4; i++)\n      {\n\tb += cps[i];\n\tASSERT (b >= cps[i]);\n      }\n  }\n#endif\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpn_mod_1s_2p": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "mp_limb_t\nmpn_mod_1s_2p (mp_srcptr ap, mp_size_t n, mp_limb_t b, const mp_limb_t cps[5])\n{\n  mp_limb_t rh, rl, bi, ph, pl, ch, cl, r;\n  mp_limb_t B1modb, B2modb, B3modb;\n  mp_size_t i;\n  int cnt;\n\n  ASSERT (n >= 1);\n\n  B1modb = cps[2];\n  B2modb = cps[3];\n  B3modb = cps[4];\n\n  if ((n & 1) != 0)\n    {\n      if (n == 1)\n\t{\n\t  rl = ap[n - 1];\n\t  bi = cps[0];\n\t  cnt = cps[1];\n\t  udiv_rnnd_preinv (r, rl >> (GMP_LIMB_BITS - cnt),\n\t\t\t     rl << cnt, b, bi);\n\t  return r >> cnt;\n\t}\n\n      umul_ppmm (ph, pl, ap[n - 2], B1modb);\n      add_ssaaaa (ph, pl, ph, pl, CNST_LIMB(0), ap[n - 3]);\n      umul_ppmm (rh, rl, ap[n - 1], B2modb);\n      add_ssaaaa (rh, rl, rh, rl, ph, pl);\n      n--;\n    }\n  else\n    {\n      rh = ap[n - 1];\n      rl = ap[n - 2];\n    }\n\n  for (i = n - 4; i >= 0; i -= 2)\n    {\n      /* rr = ap[i]\t\t\t\t< B\n\t    + ap[i+1] * (B mod b)\t\t<= (B-1)(b-1)\n\t    + LO(rr)  * (B^2 mod b)\t\t<= (B-1)(b-1)\n\t    + HI(rr)  * (B^3 mod b)\t\t<= (B-1)(b-1)\n      */\n      umul_ppmm (ph, pl, ap[i + 1], B1modb);\n      add_ssaaaa (ph, pl, ph, pl, CNST_LIMB(0), ap[i + 0]);\n\n      umul_ppmm (ch, cl, rl, B2modb);\n      add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n      umul_ppmm (rh, rl, rh, B3modb);\n      add_ssaaaa (rh, rl, rh, rl, ph, pl);\n    }\n\n  umul_ppmm (rh, cl, rh, B1modb);\n  add_ssaaaa (rh, rl, rh, rl, CNST_LIMB(0), cl);\n\n  cnt = cps[1];\n  bi = cps[0];\n\n  r = (rh << cnt) | (rl >> (GMP_LIMB_BITS - cnt));\n  udiv_rnnd_preinv (r, r, rl << cnt, b, bi);\n\n  return r >> cnt;\n}",
      "lines": 66,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mod_1_3.c": {
    "mpn_mod_1s_3p_cps": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\nmpn_mod_1s_3p_cps (mp_limb_t cps[6], mp_limb_t b)\n{\n  mp_limb_t bi;\n  mp_limb_t B1modb, B2modb, B3modb, B4modb;\n  int cnt;\n\n  ASSERT (b <= (~(mp_limb_t) 0) / 3);\n\n  count_leading_zeros (cnt, b);\n\n  b <<= cnt;\n  invert_limb (bi, b);\n\n  cps[0] = bi;\n  cps[1] = cnt;\n\n  B1modb = -b * ((bi >> (GMP_LIMB_BITS-cnt)) | (CNST_LIMB(1) << cnt));\n  ASSERT (B1modb <= b);\t\t/* NB: not fully reduced mod b */\n  cps[2] = B1modb >> cnt;\n\n  udiv_rnnd_preinv (B2modb, B1modb, CNST_LIMB(0), b, bi);\n  cps[3] = B2modb >> cnt;\n\n  udiv_rnnd_preinv (B3modb, B2modb, CNST_LIMB(0), b, bi);\n  cps[4] = B3modb >> cnt;\n\n  udiv_rnnd_preinv (B4modb, B3modb, CNST_LIMB(0), b, bi);\n  cps[5] = B4modb >> cnt;\n\n#if WANT_ASSERT\n  {\n    int i;\n    b = cps[2];\n    for (i = 3; i <= 5; i++)\n      {\n\tb += cps[i];\n\tASSERT (b >= cps[i]);\n      }\n  }\n#endif\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpn_mod_1s_3p": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "mp_limb_t\nmpn_mod_1s_3p (mp_srcptr ap, mp_size_t n, mp_limb_t b, const mp_limb_t cps[6])\n{\n  mp_limb_t rh, rl, bi, ph, pl, ch, cl, r;\n  mp_limb_t B1modb, B2modb, B3modb, B4modb;\n  mp_size_t i;\n  int cnt;\n\n  ASSERT (n >= 1);\n\n  B1modb = cps[2];\n  B2modb = cps[3];\n  B3modb = cps[4];\n  B4modb = cps[5];\n\n  /* We compute n mod 3 in a tricky way, which works except for when n is so\n     close to the maximum size that we don't need to support it.  The final\n     cast to int is a workaround for HP cc.  */\n  switch ((int) ((mp_limb_t) n * MODLIMB_INVERSE_3 >> (GMP_NUMB_BITS - 2)))\n    {\n    case 0:\n      umul_ppmm (ph, pl, ap[n - 2], B1modb);\n      add_ssaaaa (ph, pl, ph, pl, CNST_LIMB(0), ap[n - 3]);\n      umul_ppmm (rh, rl, ap[n - 1], B2modb);\n      add_ssaaaa (rh, rl, rh, rl, ph, pl);\n      n -= 3;\n      break;\n    case 2:\t/* n mod 3 = 1 */\n      rh = 0;\n      rl = ap[n - 1];\n      n -= 1;\n      break;\n    case 1:\t/* n mod 3 = 2 */\n      rh = ap[n - 1];\n      rl = ap[n - 2];\n      n -= 2;\n      break;\n    }\n\n  for (i = n - 3; i >= 0; i -= 3)\n    {\n      /* rr = ap[i]\t\t\t\t< B\n\t    + ap[i+1] * (B mod b)\t\t<= (B-1)(b-1)\n\t    + ap[i+2] * (B^2 mod b)\t\t<= (B-1)(b-1)\n\t    + LO(rr)  * (B^3 mod b)\t\t<= (B-1)(b-1)\n\t    + HI(rr)  * (B^4 mod b)\t\t<= (B-1)(b-1)\n      */\n      umul_ppmm (ph, pl, ap[i + 1], B1modb);\n      add_ssaaaa (ph, pl, ph, pl, CNST_LIMB(0), ap[i + 0]);\n\n      umul_ppmm (ch, cl, ap[i + 2], B2modb);\n      add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n      umul_ppmm (ch, cl, rl, B3modb);\n      add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n      umul_ppmm (rh, rl, rh, B4modb);\n      add_ssaaaa (rh, rl, rh, rl, ph, pl);\n    }\n\n  umul_ppmm (rh, cl, rh, B1modb);\n  add_ssaaaa (rh, rl, rh, rl, CNST_LIMB(0), cl);\n\n  cnt = cps[1];\n  bi = cps[0];\n\n  r = (rh << cnt) | (rl >> (GMP_LIMB_BITS - cnt));\n  udiv_rnnd_preinv (r, r, rl << cnt, b, bi);\n\n  return r >> cnt;\n}",
      "lines": 71,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mod_1_4.c": {
    "mpn_mod_1s_4p_cps": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "void\nmpn_mod_1s_4p_cps (mp_limb_t cps[7], mp_limb_t b)\n{\n  mp_limb_t bi;\n  mp_limb_t B1modb, B2modb, B3modb, B4modb, B5modb;\n  int cnt;\n\n  ASSERT (b <= (~(mp_limb_t) 0) / 4);\n\n  count_leading_zeros (cnt, b);\n\n  b <<= cnt;\n  invert_limb (bi, b);\n\n  cps[0] = bi;\n  cps[1] = cnt;\n\n  B1modb = -b * ((bi >> (GMP_LIMB_BITS-cnt)) | (CNST_LIMB(1) << cnt));\n  ASSERT (B1modb <= b);\t\t/* NB: not fully reduced mod b */\n  cps[2] = B1modb >> cnt;\n\n  udiv_rnnd_preinv (B2modb, B1modb, CNST_LIMB(0), b, bi);\n  cps[3] = B2modb >> cnt;\n\n  udiv_rnnd_preinv (B3modb, B2modb, CNST_LIMB(0), b, bi);\n  cps[4] = B3modb >> cnt;\n\n  udiv_rnnd_preinv (B4modb, B3modb, CNST_LIMB(0), b, bi);\n  cps[5] = B4modb >> cnt;\n\n  udiv_rnnd_preinv (B5modb, B4modb, CNST_LIMB(0), b, bi);\n  cps[6] = B5modb >> cnt;\n\n#if WANT_ASSERT\n  {\n    int i;\n    b = cps[2];\n    for (i = 3; i <= 6; i++)\n      {\n\tb += cps[i];\n\tASSERT (b >= cps[i]);\n      }\n  }\n#endif\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpn_mod_1s_4p": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "mp_limb_t\nmpn_mod_1s_4p (mp_srcptr ap, mp_size_t n, mp_limb_t b, const mp_limb_t cps[7])\n{\n  mp_limb_t rh, rl, bi, ph, pl, ch, cl, r;\n  mp_limb_t B1modb, B2modb, B3modb, B4modb, B5modb;\n  mp_size_t i;\n  int cnt;\n\n  ASSERT (n >= 1);\n\n  B1modb = cps[2];\n  B2modb = cps[3];\n  B3modb = cps[4];\n  B4modb = cps[5];\n  B5modb = cps[6];\n\n  switch (n & 3)\n    {\n    case 0:\n      umul_ppmm (ph, pl, ap[n - 3], B1modb);\n      add_ssaaaa (ph, pl, ph, pl, CNST_LIMB(0), ap[n - 4]);\n      umul_ppmm (ch, cl, ap[n - 2], B2modb);\n      add_ssaaaa (ph, pl, ph, pl, ch, cl);\n      umul_ppmm (rh, rl, ap[n - 1], B3modb);\n      add_ssaaaa (rh, rl, rh, rl, ph, pl);\n      n -= 4;\n      break;\n    case 1:\n      rh = 0;\n      rl = ap[n - 1];\n      n -= 1;\n      break;\n    case 2:\n      rh = ap[n - 1];\n      rl = ap[n - 2];\n      n -= 2;\n      break;\n    case 3:\n      umul_ppmm (ph, pl, ap[n - 2], B1modb);\n      add_ssaaaa (ph, pl, ph, pl, CNST_LIMB(0), ap[n - 3]);\n      umul_ppmm (rh, rl, ap[n - 1], B2modb);\n      add_ssaaaa (rh, rl, rh, rl, ph, pl);\n      n -= 3;\n      break;\n    }\n\n  for (i = n - 4; i >= 0; i -= 4)\n    {\n      /* rr = ap[i]\t\t\t\t< B\n\t    + ap[i+1] * (B mod b)\t\t<= (B-1)(b-1)\n\t    + ap[i+2] * (B^2 mod b)\t\t<= (B-1)(b-1)\n\t    + ap[i+3] * (B^3 mod b)\t\t<= (B-1)(b-1)\n\t    + LO(rr)  * (B^4 mod b)\t\t<= (B-1)(b-1)\n\t    + HI(rr)  * (B^5 mod b)\t\t<= (B-1)(b-1)\n      */\n      umul_ppmm (ph, pl, ap[i + 1], B1modb);\n      add_ssaaaa (ph, pl, ph, pl, CNST_LIMB(0), ap[i + 0]);\n\n      umul_ppmm (ch, cl, ap[i + 2], B2modb);\n      add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n      umul_ppmm (ch, cl, ap[i + 3], B3modb);\n      add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n      umul_ppmm (ch, cl, rl, B4modb);\n      add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n      umul_ppmm (rh, rl, rh, B5modb);\n      add_ssaaaa (rh, rl, rh, rl, ph, pl);\n    }\n\n  umul_ppmm (rh, cl, rh, B1modb);\n  add_ssaaaa (rh, rl, rh, rl, CNST_LIMB(0), cl);\n\n  cnt = cps[1];\n  bi = cps[0];\n\n  r = (rh << cnt) | (rl >> (GMP_LIMB_BITS - cnt));\n  udiv_rnnd_preinv (r, r, rl << cnt, b, bi);\n\n  return r >> cnt;\n}",
      "lines": 82,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mod_34lsub1.c": {
    "mpn_mod_34lsub1": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "mp_limb_t\nmpn_mod_34lsub1 (mp_srcptr p, mp_size_t n)\n{\n  mp_limb_t  c0 = 0;\n  mp_limb_t  c1 = 0;\n  mp_limb_t  c2 = 0;\n  mp_limb_t  a0, a1, a2;\n\n  ASSERT (n >= 1);\n  ASSERT (n/3 < GMP_NUMB_MAX);\n\n  a0 = a1 = a2 = 0;\n  c0 = c1 = c2 = 0;\n\n  while ((n -= 3) >= 0)\n    {\n      ADD (c0, a0, p[0]);\n      ADD (c1, a1, p[1]);\n      ADD (c2, a2, p[2]);\n      p += 3;\n    }\n\n  if (n != -3)\n    {\n      ADD (c0, a0, p[0]);\n      if (n != -2)\n\tADD (c1, a1, p[1]);\n    }\n\n  return\n    PARTS0 (a0) + PARTS1 (a1) + PARTS2 (a2)\n    + PARTS1 (c0) + PARTS2 (c1) + PARTS0 (c2);\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mul.c": {
    "mpn_mul": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "mp_limb_t\nmpn_mul (mp_ptr prodp,\n\t mp_srcptr up, mp_size_t un,\n\t mp_srcptr vp, mp_size_t vn)\n{\n  ASSERT (un >= vn);\n  ASSERT (vn >= 1);\n  ASSERT (! MPN_OVERLAP_P (prodp, un+vn, up, un));\n  ASSERT (! MPN_OVERLAP_P (prodp, un+vn, vp, vn));\n\n  if (un == vn)\n    {\n      if (up == vp)\n\tmpn_sqr (prodp, up, un);\n      else\n\tmpn_mul_n (prodp, up, vp, un);\n    }\n  else if (vn < MUL_TOOM22_THRESHOLD)\n    { /* plain schoolbook multiplication */\n\n      /* Unless un is very large, or else if have an applicable mpn_mul_N,\n\t perform basecase multiply directly.  */\n      if (un <= MUL_BASECASE_MAX_UN\n#if HAVE_NATIVE_mpn_mul_2\n\t  || vn <= 2\n#else\n\t  || vn == 1\n#endif\n\t  )\n\tmpn_mul_basecase (prodp, up, un, vp, vn);\n      else\n\t{\n\t  /* We have un >> MUL_BASECASE_MAX_UN > vn.  For better memory\n\t     locality, split up[] into MUL_BASECASE_MAX_UN pieces and multiply\n\t     these pieces with the vp[] operand.  After each such partial\n\t     multiplication (but the last) we copy the most significant vn\n\t     limbs into a temporary buffer since that part would otherwise be\n\t     overwritten by the next multiplication.  After the next\n\t     multiplication, we add it back.  This illustrates the situation:\n\n                                                    -->vn<--\n                                                      |  |<------- un ------->|\n                                                         _____________________|\n                                                        X                    /|\n                                                      /XX__________________/  |\n                                    _____________________                     |\n                                   X                    /                     |\n                                 /XX__________________/                       |\n               _____________________                                          |\n              /                    /                                          |\n            /____________________/                                            |\n\t    ==================================================================\n\n\t    The parts marked with X are the parts whose sums are copied into\n\t    the temporary buffer.  */\n\n\t  mp_limb_t tp[MUL_TOOM22_THRESHOLD_LIMIT];\n\t  mp_limb_t cy;\n\t  ASSERT (MUL_TOOM22_THRESHOLD <= MUL_TOOM22_THRESHOLD_LIMIT);\n\n\t  mpn_mul_basecase (prodp, up, MUL_BASECASE_MAX_UN, vp, vn);\n\t  prodp += MUL_BASECASE_MAX_UN;\n\t  MPN_COPY (tp, prodp, vn);\t\t/* preserve high triangle */\n\t  up += MUL_BASECASE_MAX_UN;\n\t  un -= MUL_BASECASE_MAX_UN;\n\t  while (un > MUL_BASECASE_MAX_UN)\n\t    {\n\t      mpn_mul_basecase (prodp, up, MUL_BASECASE_MAX_UN, vp, vn);\n\t      cy = mpn_add_n (prodp, prodp, tp, vn); /* add back preserved triangle */\n\t      mpn_incr_u (prodp + vn, cy);\n\t      prodp += MUL_BASECASE_MAX_UN;\n\t      MPN_COPY (tp, prodp, vn);\t\t/* preserve high triangle */\n\t      up += MUL_BASECASE_MAX_UN;\n\t      un -= MUL_BASECASE_MAX_UN;\n\t    }\n\t  if (un > vn)\n\t    {\n\t      mpn_mul_basecase (prodp, up, un, vp, vn);\n\t    }\n\t  else\n\t    {\n\t      ASSERT (un > 0);\n\t      mpn_mul_basecase (prodp, vp, vn, up, un);\n\t    }\n\t  cy = mpn_add_n (prodp, prodp, tp, vn); /* add back preserved triangle */\n\t  mpn_incr_u (prodp + vn, cy);\n\t}\n    }\n  else if (BELOW_THRESHOLD (vn, MUL_TOOM33_THRESHOLD))\n    {\n      /* Use ToomX2 variants */\n      mp_ptr scratch;\n      TMP_SDECL; TMP_SMARK;\n\n#define ITCH_TOOMX2 (9 * vn / 2 + GMP_NUMB_BITS * 2)\n      scratch = TMP_SALLOC_LIMBS (ITCH_TOOMX2);\n      ASSERT (mpn_toom22_mul_itch ((5*vn-1)/4, vn) <= ITCH_TOOMX2); /* 5vn/2+ */\n      ASSERT (mpn_toom32_mul_itch ((7*vn-1)/4, vn) <= ITCH_TOOMX2); /* 7vn/6+ */\n      ASSERT (mpn_toom42_mul_itch (3 * vn - 1, vn) <= ITCH_TOOMX2); /* 9vn/2+ */\n#undef ITCH_TOOMX2\n\n      /* FIXME: This condition (repeated in the loop below) leaves from a vn*vn\n\t square to a (3vn-1)*vn rectangle.  Leaving such a rectangle is hardly\n\t wise; we would get better balance by slightly moving the bound.  We\n\t will sometimes end up with un < vn, like in the X3 arm below.  */\n      if (un >= 3 * vn)\n\t{\n\t  mp_limb_t cy;\n\t  mp_ptr ws;\n\n\t  /* The maximum ws usage is for the mpn_mul result.  */\n\t  ws = TMP_SALLOC_LIMBS (4 * vn);\n\n\t  mpn_toom42_mul (prodp, up, 2 * vn, vp, vn, scratch);\n\t  un -= 2 * vn;\n\t  up += 2 * vn;\n\t  prodp += 2 * vn;\n\n\t  while (un >= 3 * vn)\n\t    {\n\t      mpn_toom42_mul (ws, up, 2 * vn, vp, vn, scratch);\n\t      un -= 2 * vn;\n\t      up += 2 * vn;\n\t      cy = mpn_add_n (prodp, prodp, ws, vn);\n\t      MPN_COPY (prodp + vn, ws + vn, 2 * vn);\n\t      mpn_incr_u (prodp + vn, cy);\n\t      prodp += 2 * vn;\n\t    }\n\n\t  /* vn <= un < 3vn */\n\n\t  if (4 * un < 5 * vn)\n\t    mpn_toom22_mul (ws, up, un, vp, vn, scratch);\n\t  else if (4 * un < 7 * vn)\n\t    mpn_toom32_mul (ws, up, un, vp, vn, scratch);\n\t  else\n\t    mpn_toom42_mul (ws, up, un, vp, vn, scratch);\n\n\t  cy = mpn_add_n (prodp, prodp, ws, vn);\n\t  MPN_COPY (prodp + vn, ws + vn, un);\n\t  mpn_incr_u (prodp + vn, cy);\n\t}\n      else\n\t{\n\t  if (4 * un < 5 * vn)\n\t    mpn_toom22_mul (prodp, up, un, vp, vn, scratch);\n\t  else if (4 * un < 7 * vn)\n\t    mpn_toom32_mul (prodp, up, un, vp, vn, scratch);\n\t  else\n\t    mpn_toom42_mul (prodp, up, un, vp, vn, scratch);\n\t}\n      TMP_SFREE;\n    }\n  else if (BELOW_THRESHOLD ((un + vn) >> 1, MUL_FFT_THRESHOLD) ||\n\t   BELOW_THRESHOLD (3 * vn, MUL_FFT_THRESHOLD))\n    {\n      /* Handle the largest operands that are not in the FFT range.  The 2nd\n\t condition makes very unbalanced operands avoid the FFT code (except\n\t perhaps as coefficient products of the Toom code.  */\n\n      if (BELOW_THRESHOLD (vn, MUL_TOOM44_THRESHOLD) || !TOOM44_OK (un, vn))\n\t{\n\t  /* Use ToomX3 variants */\n\t  mp_ptr scratch;\n\t  TMP_DECL; TMP_MARK;\n\n#define ITCH_TOOMX3 (4 * vn + GMP_NUMB_BITS)\n\t  scratch = TMP_ALLOC_LIMBS (ITCH_TOOMX3);\n\t  ASSERT (mpn_toom33_mul_itch ((7*vn-1)/6, vn) <= ITCH_TOOMX3); /* 7vn/2+ */\n\t  ASSERT (mpn_toom43_mul_itch ((3*vn-1)/2, vn) <= ITCH_TOOMX3); /* 9vn/4+ */\n\t  ASSERT (mpn_toom32_mul_itch ((7*vn-1)/4, vn) <= ITCH_TOOMX3); /* 7vn/6+ */\n\t  ASSERT (mpn_toom53_mul_itch ((11*vn-1)/6, vn) <= ITCH_TOOMX3); /* 11vn/3+ */\n\t  ASSERT (mpn_toom42_mul_itch ((5*vn-1)/2, vn) <= ITCH_TOOMX3); /* 15vn/4+ */\n\t  ASSERT (mpn_toom63_mul_itch ((5*vn-1)/2, vn) <= ITCH_TOOMX3); /* 15vn/4+ */\n#undef ITCH_TOOMX3\n\n\t  if (2 * un >= 5 * vn)\n\t    {\n\t      mp_limb_t cy;\n\t      mp_ptr ws;\n\n\t      /* The maximum ws usage is for the mpn_mul result.  */\n\t      ws = TMP_ALLOC_LIMBS (7 * vn >> 1);\n\n\t      if (BELOW_THRESHOLD (vn, MUL_TOOM42_TO_TOOM63_THRESHOLD))\n\t\tmpn_toom42_mul (prodp, up, 2 * vn, vp, vn, scratch);\n\t      else\n\t\tmpn_toom63_mul (prodp, up, 2 * vn, vp, vn, scratch);\n\t      un -= 2 * vn;\n\t      up += 2 * vn;\n\t      prodp += 2 * vn;\n\n\t      while (2 * un >= 5 * vn)\t/* un >= 2.5vn */\n\t\t{\n\t\t  if (BELOW_THRESHOLD (vn, MUL_TOOM42_TO_TOOM63_THRESHOLD))\n\t\t    mpn_toom42_mul (ws, up, 2 * vn, vp, vn, scratch);\n\t\t  else\n\t\t    mpn_toom63_mul (ws, up, 2 * vn, vp, vn, scratch);\n\t\t  un -= 2 * vn;\n\t\t  up += 2 * vn;\n\t\t  cy = mpn_add_n (prodp, prodp, ws, vn);\n\t\t  MPN_COPY (prodp + vn, ws + vn, 2 * vn);\n\t\t  mpn_incr_u (prodp + vn, cy);\n\t\t  prodp += 2 * vn;\n\t\t}\n\n\t      /* vn / 2 <= un < 2.5vn */\n\n\t      if (un < vn)\n\t\tmpn_mul (ws, vp, vn, up, un);\n\t      else\n\t\tmpn_mul (ws, up, un, vp, vn);\n\n\t      cy = mpn_add_n (prodp, prodp, ws, vn);\n\t      MPN_COPY (prodp + vn, ws + vn, un);\n\t      mpn_incr_u (prodp + vn, cy);\n\t    }\n\t  else\n\t    {\n\t      if (6 * un < 7 * vn)\n\t\tmpn_toom33_mul (prodp, up, un, vp, vn, scratch);\n\t      else if (2 * un < 3 * vn)\n\t\t{\n\t\t  if (BELOW_THRESHOLD (vn, MUL_TOOM32_TO_TOOM43_THRESHOLD))\n\t\t    mpn_toom32_mul (prodp, up, un, vp, vn, scratch);\n\t\t  else\n\t\t    mpn_toom43_mul (prodp, up, un, vp, vn, scratch);\n\t\t}\n\t      else if (6 * un < 11 * vn)\n\t\t{\n\t\t  if (4 * un < 7 * vn)\n\t\t    {\n\t\t      if (BELOW_THRESHOLD (vn, MUL_TOOM32_TO_TOOM53_THRESHOLD))\n\t\t\tmpn_toom32_mul (prodp, up, un, vp, vn, scratch);\n\t\t      else\n\t\t\tmpn_toom53_mul (prodp, up, un, vp, vn, scratch);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if (BELOW_THRESHOLD (vn, MUL_TOOM42_TO_TOOM53_THRESHOLD))\n\t\t\tmpn_toom42_mul (prodp, up, un, vp, vn, scratch);\n\t\t      else\n\t\t\tmpn_toom53_mul (prodp, up, un, vp, vn, scratch);\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  if (BELOW_THRESHOLD (vn, MUL_TOOM42_TO_TOOM63_THRESHOLD))\n\t\t    mpn_toom42_mul (prodp, up, un, vp, vn, scratch);\n\t\t  else\n\t\t    mpn_toom63_mul (prodp, up, un, vp, vn, scratch);\n\t\t}\n\t    }\n\t  TMP_FREE;\n\t}\n      else\n\t{\n\t  mp_ptr scratch;\n\t  TMP_DECL; TMP_MARK;\n\n\t  if (BELOW_THRESHOLD (vn, MUL_TOOM6H_THRESHOLD))\n\t    {\n\t      scratch = TMP_SALLOC_LIMBS (mpn_toom44_mul_itch (un, vn));\n\t      mpn_toom44_mul (prodp, up, un, vp, vn, scratch);\n\t    }\n\t  else if (BELOW_THRESHOLD (vn, MUL_TOOM8H_THRESHOLD))\n\t    {\n\t      scratch = TMP_SALLOC_LIMBS (mpn_toom6h_mul_itch (un, vn));\n\t      mpn_toom6h_mul (prodp, up, un, vp, vn, scratch);\n\t    }\n\t  else\n\t    {\n\t      scratch = TMP_ALLOC_LIMBS (mpn_toom8h_mul_itch (un, vn));\n\t      mpn_toom8h_mul (prodp, up, un, vp, vn, scratch);\n\t    }\n\t  TMP_FREE;\n\t}\n    }\n  else\n    {\n      if (un >= 8 * vn)\n\t{\n\t  mp_limb_t cy;\n\t  mp_ptr ws;\n\t  TMP_DECL; TMP_MARK;\n\n\t  /* The maximum ws usage is for the mpn_mul result.  */\n\t  ws = TMP_BALLOC_LIMBS (9 * vn >> 1);\n\n\t  mpn_fft_mul (prodp, up, 3 * vn, vp, vn);\n\t  un -= 3 * vn;\n\t  up += 3 * vn;\n\t  prodp += 3 * vn;\n\n\t  while (2 * un >= 7 * vn)\t/* un >= 3.5vn  */\n\t    {\n\t      mpn_fft_mul (ws, up, 3 * vn, vp, vn);\n\t      un -= 3 * vn;\n\t      up += 3 * vn;\n\t      cy = mpn_add_n (prodp, prodp, ws, vn);\n\t      MPN_COPY (prodp + vn, ws + vn, 3 * vn);\n\t      mpn_incr_u (prodp + vn, cy);\n\t      prodp += 3 * vn;\n\t    }\n\n\t  /* vn / 2 <= un < 3.5vn */\n\n\t  if (un < vn)\n\t    mpn_mul (ws, vp, vn, up, un);\n\t  else\n\t    mpn_mul (ws, up, un, vp, vn);\n\n\t  cy = mpn_add_n (prodp, prodp, ws, vn);\n\t  MPN_COPY (prodp + vn, ws + vn, un);\n\t  mpn_incr_u (prodp + vn, cy);\n\n\t  TMP_FREE;\n\t}\n      else\n\tmpn_fft_mul (prodp, up, un, vp, vn);\n    }\n\n  return prodp[un + vn - 1];\t/* historic */\n}",
      "lines": 324,
      "depth": 22,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mullo_basecase.c": {
    "mpn_mullo_basecase": [
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          59,
          1
        ],
        "content": "void\nmpn_mullo_basecase (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_size_t i;\n\n  mpn_mul_1 (rp, up, n, vp[0]);\n\n  for (i = n - 1; i > 0; i--)\n    {\n      vp++;\n      rp++;\n      mpn_addmul_1 (rp, up, i, vp[0]);\n    }\n}",
        "lines": 14,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          64,
          0
        ],
        "end_point": [
          89,
          1
        ],
        "content": "void\nmpn_mullo_basecase (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_limb_t h;\n\n  h = up[0] * vp[n - 1];\n\n  if (n != 1)\n    {\n      mp_size_t i;\n      mp_limb_t v0;\n\n      v0 = *vp++;\n      h += up[n - 1] * v0 + mpn_mul_1 (rp, up, n - 1, v0);\n      rp++;\n\n      for (i = n - 2; i > 0; i--)\n\t{\n\t  v0 = *vp++;\n\t  h += up[i] * v0 + mpn_addmul_1 (rp, up, i, v0);\n\t  rp++;\n\t}\n    }\n\n  rp[0] = h;\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/mullo_n.c": {
    "mpn_mullo_n_itch": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static mp_size_t\nmpn_mullo_n_itch (mp_size_t n)\n{\n  return 2*n;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_dc_mullo_n": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "static void\nmpn_dc_mullo_n (mp_ptr rp, mp_srcptr xp, mp_srcptr yp, mp_size_t n, mp_ptr tp)\n{\n  mp_size_t n2, n1;\n  ASSERT (n >= 2);\n  ASSERT (! MPN_OVERLAP_P (rp, n, xp, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp, n));\n  ASSERT (MPN_SAME_OR_SEPARATE2_P(rp, n, tp, 2*n));\n\n  /* Divide-and-conquer */\n\n  /* We need fractional approximation of the value 0 < a <= 1/2\n     giving the minimum in the function k=(1-a)^e/(1-2*a^e).\n  */\n  if (MAYBE_range_basecase && BELOW_THRESHOLD (n, MUL_TOOM22_THRESHOLD*36/(36-11)))\n    n1 = n >> 1;\n  else if (MAYBE_range_toom22 && BELOW_THRESHOLD (n, MUL_TOOM33_THRESHOLD*36/(36-11)))\n    n1 = n * 11 / (size_t) 36;\t/* n1 ~= n*(1-.694...) */\n  else if (BELOW_THRESHOLD (n, MUL_TOOM44_THRESHOLD*40/(40-9)))\n    n1 = n * 9 / (size_t) 40;\t/* n1 ~= n*(1-.775...) */\n  else if (BELOW_THRESHOLD (n, MUL_TOOM8H_THRESHOLD*10/9))\n    n1 = n * 7 / (size_t) 39;\t/* n1 ~= n*(1-.821...) */\n  /* n1 = n * 4 / (size_t) 31;\t// n1 ~= n*(1-.871...) [TOOM66] */\n  else\n    n1 = n / (size_t) 10;\t\t/* n1 ~= n*(1-.899...) [TOOM88] */\n\n  n2 = n - n1;\n\n  /* Split as x = x1 2^(n2 GMP_NUMB_BITS) + x0,\n\t      y = y1 2^(n2 GMP_NUMB_BITS) + y0 */\n\n  /* x0 * y0 */\n  mpn_mul_n (tp, xp, yp, n2);\n  MPN_COPY (rp, tp, n2);\n\n  /* x1 * y0 * 2^(n2 GMP_NUMB_BITS) */\n  if (BELOW_THRESHOLD (n1, MULLO_BASECASE_THRESHOLD))\n    mpn_mul_basecase (tp + n, xp + n2, n1, yp, n1);\n  else if (BELOW_THRESHOLD (n1, MULLO_DC_THRESHOLD))\n    mpn_mullo_basecase (tp + n, xp + n2, yp, n1);\n  else\n    mpn_dc_mullo_n (tp + n, xp + n2, yp, n1, tp + n);\n  mpn_add_n (rp + n2, tp + n2, tp + n, n1);\n\n  /* x0 * y1 * 2^(n2 GMP_NUMB_BITS) */\n  if (BELOW_THRESHOLD (n1, MULLO_BASECASE_THRESHOLD))\n    mpn_mul_basecase (tp + n, xp, n1, yp + n2, n1);\n  else if (BELOW_THRESHOLD (n1, MULLO_DC_THRESHOLD))\n    mpn_mullo_basecase (tp + n, xp, yp + n2, n1);\n  else\n    mpn_dc_mullo_n (tp + n, xp, yp + n2, n1, tp + n);\n  mpn_add_n (rp + n2, rp + n2, tp + n, n1);\n}",
      "lines": 53,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_mullo_n": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\nmpn_mullo_n (mp_ptr rp, mp_srcptr xp, mp_srcptr yp, mp_size_t n)\n{\n  ASSERT (n >= 1);\n  ASSERT (! MPN_OVERLAP_P (rp, n, xp, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp, n));\n\n  if (BELOW_THRESHOLD (n, MULLO_BASECASE_THRESHOLD))\n    {\n      /* Allocate workspace of fixed size on stack: fast! */\n      mp_limb_t tp[MUL_BASECASE_ALLOC];\n      mpn_mul_basecase (tp, xp, n, yp, n);\n      MPN_COPY (rp, tp, n);\n    }\n  else if (BELOW_THRESHOLD (n, MULLO_DC_THRESHOLD))\n    {\n      mpn_mullo_basecase (rp, xp, yp, n);\n    }\n  else\n    {\n      mp_ptr tp;\n      TMP_DECL;\n      TMP_MARK;\n      tp = TMP_ALLOC_LIMBS (mpn_mullo_n_itch (n));\n      if (BELOW_THRESHOLD (n, MULLO_MUL_N_THRESHOLD))\n\t{\n\t  mpn_dc_mullo_n (rp, xp, yp, n, tp);\n\t}\n      else\n\t{\n\t  /* For really large operands, use plain mpn_mul_n but throw away upper n\n\t     limbs of result.  */\n#if !TUNE_PROGRAM_BUILD && (MULLO_MUL_N_THRESHOLD > MUL_FFT_THRESHOLD)\n\t  mpn_fft_mul (tp, xp, n, yp, n);\n#else\n\t  mpn_mul_n (tp, xp, yp, n);\n#endif\n\t  MPN_COPY (rp, tp, n);\n\t}\n      TMP_FREE;\n    }\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mulmid.c": {
    "mpn_mulmid": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "void\nmpn_mulmid (mp_ptr rp,\n            mp_srcptr ap, mp_size_t an,\n            mp_srcptr bp, mp_size_t bn)\n{\n  mp_size_t rn, k;\n  mp_ptr scratch, temp;\n\n  ASSERT (an >= bn);\n  ASSERT (bn >= 1);\n  ASSERT (! MPN_OVERLAP_P (rp, an - bn + 3, ap, an));\n  ASSERT (! MPN_OVERLAP_P (rp, an - bn + 3, bp, bn));\n\n  if (bn < MULMID_TOOM42_THRESHOLD)\n    {\n      /* region not tall enough to make toom42 worthwhile for any portion */\n\n      if (an < CHUNK)\n\t{\n\t  /* region not too wide either, just call basecase directly */\n\t  mpn_mulmid_basecase (rp, ap, an, bp, bn);\n\t  return;\n\t}\n\n      /* Region quite wide. For better locality, use basecase on chunks:\n\n\t AAABBBCC..\n\t .AAABBBCC.\n\t ..AAABBBCC\n      */\n\n      k = CHUNK - bn + 1;    /* number of diagonals per chunk */\n\n      /* first chunk (marked A in the above diagram) */\n      mpn_mulmid_basecase (rp, ap, CHUNK, bp, bn);\n\n      /* remaining chunks (B, C, etc) */\n      an -= k;\n\n      while (an >= CHUNK)\n\t{\n\t  mp_limb_t t0, t1, cy;\n\t  ap += k, rp += k;\n\t  t0 = rp[0], t1 = rp[1];\n\t  mpn_mulmid_basecase (rp, ap, CHUNK, bp, bn);\n\t  ADDC_LIMB (cy, rp[0], rp[0], t0);    /* add back saved limbs */\n\t  MPN_INCR_U (rp + 1, k + 1, t1 + cy);\n\t  an -= k;\n\t}\n\n      if (an >= bn)\n\t{\n\t  /* last remaining chunk */\n\t  mp_limb_t t0, t1, cy;\n\t  ap += k, rp += k;\n\t  t0 = rp[0], t1 = rp[1];\n\t  mpn_mulmid_basecase (rp, ap, an, bp, bn);\n\t  ADDC_LIMB (cy, rp[0], rp[0], t0);\n\t  MPN_INCR_U (rp + 1, an - bn + 2, t1 + cy);\n\t}\n\n      return;\n    }\n\n  /* region is tall enough for toom42 */\n\n  rn = an - bn + 1;\n\n  if (rn < MULMID_TOOM42_THRESHOLD)\n    {\n      /* region not wide enough to make toom42 worthwhile for any portion */\n\n      TMP_DECL;\n\n      if (bn < CHUNK)\n\t{\n\t  /* region not too tall either, just call basecase directly */\n\t  mpn_mulmid_basecase (rp, ap, an, bp, bn);\n\t  return;\n\t}\n\n      /* Region quite tall. For better locality, use basecase on chunks:\n\n\t AAAAA....\n\t .AAAAA...\n\t ..BBBBB..\n\t ...BBBBB.\n\t ....CCCCC\n      */\n\n      TMP_MARK;\n\n      temp = TMP_ALLOC_LIMBS (rn + 2);\n\n      /* first chunk (marked A in the above diagram) */\n      bp += bn - CHUNK, an -= bn - CHUNK;\n      mpn_mulmid_basecase (rp, ap, an, bp, CHUNK);\n\n      /* remaining chunks (B, C, etc) */\n      bn -= CHUNK;\n\n      while (bn >= CHUNK)\n\t{\n\t  ap += CHUNK, bp -= CHUNK;\n\t  mpn_mulmid_basecase (temp, ap, an, bp, CHUNK);\n\t  mpn_add_n (rp, rp, temp, rn + 2);\n\t  bn -= CHUNK;\n\t}\n\n      if (bn)\n\t{\n\t  /* last remaining chunk */\n\t  ap += CHUNK, bp -= bn;\n\t  mpn_mulmid_basecase (temp, ap, rn + bn - 1, bp, bn);\n\t  mpn_add_n (rp, rp, temp, rn + 2);\n\t}\n\n      TMP_FREE;\n      return;\n    }\n\n  /* we're definitely going to use toom42 somewhere */\n\n  if (bn > rn)\n    {\n      /* slice region into chunks, use toom42 on all chunks except possibly\n\t the last:\n\n         AA....\n         .AA...\n         ..BB..\n         ...BB.\n         ....CC\n      */\n\n      TMP_DECL;\n      TMP_MARK;\n\n      temp = TMP_ALLOC_LIMBS (rn + 2 + mpn_toom42_mulmid_itch (rn));\n      scratch = temp + rn + 2;\n\n      /* first chunk (marked A in the above diagram) */\n      bp += bn - rn;\n      mpn_toom42_mulmid (rp, ap, bp, rn, scratch);\n\n      /* remaining chunks (B, C, etc) */\n      bn -= rn;\n\n      while (bn >= rn)\n        {\n          ap += rn, bp -= rn;\n\t  mpn_toom42_mulmid (temp, ap, bp, rn, scratch);\n          mpn_add_n (rp, rp, temp, rn + 2);\n          bn -= rn;\n        }\n\n      if (bn)\n        {\n          /* last remaining chunk */\n          ap += rn, bp -= bn;\n\t  mpn_mulmid (temp, ap, rn + bn - 1, bp, bn);\n          mpn_add_n (rp, rp, temp, rn + 2);\n        }\n\n      TMP_FREE;\n    }\n  else\n    {\n      /* slice region into chunks, use toom42 on all chunks except possibly\n\t the last:\n\n         AAABBBCC..\n         .AAABBBCC.\n         ..AAABBBCC\n      */\n\n      TMP_DECL;\n      TMP_MARK;\n\n      scratch = TMP_ALLOC_LIMBS (mpn_toom42_mulmid_itch (bn));\n\n      /* first chunk (marked A in the above diagram) */\n      mpn_toom42_mulmid (rp, ap, bp, bn, scratch);\n\n      /* remaining chunks (B, C, etc) */\n      rn -= bn;\n\n      while (rn >= bn)\n        {\n\t  mp_limb_t t0, t1, cy;\n          ap += bn, rp += bn;\n          t0 = rp[0], t1 = rp[1];\n          mpn_toom42_mulmid (rp, ap, bp, bn, scratch);\n\t  ADDC_LIMB (cy, rp[0], rp[0], t0);     /* add back saved limbs */\n\t  MPN_INCR_U (rp + 1, bn + 1, t1 + cy);\n\t  rn -= bn;\n        }\n\n      TMP_FREE;\n\n      if (rn)\n        {\n          /* last remaining chunk */\n\t  mp_limb_t t0, t1, cy;\n          ap += bn, rp += bn;\n          t0 = rp[0], t1 = rp[1];\n          mpn_mulmid (rp, ap, rn + bn - 1, bp, bn);\n\t  ADDC_LIMB (cy, rp[0], rp[0], t0);\n\t  MPN_INCR_U (rp + 1, rn + 1, t1 + cy);\n        }\n    }\n}",
      "lines": 212,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mulmid_basecase.c": {
    "mpn_mulmid_basecase": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "void\nmpn_mulmid_basecase (mp_ptr rp,\n                     mp_srcptr up, mp_size_t un,\n                     mp_srcptr vp, mp_size_t vn)\n{\n  mp_limb_t lo, hi;  /* last two limbs of output */\n  mp_limb_t cy;\n\n  ASSERT (un >= vn);\n  ASSERT (vn >= 1);\n  ASSERT (! MPN_OVERLAP_P (rp, un - vn + 3, up, un));\n  ASSERT (! MPN_OVERLAP_P (rp, un - vn + 3, vp, vn));\n\n  up += vn - 1;\n  un -= vn - 1;\n\n  /* multiply by first limb, store result */\n  lo = mpn_mul_1 (rp, up, un, vp[0]);\n  hi = 0;\n\n  /* accumulate remaining rows */\n  for (vn--; vn; vn--)\n    {\n      up--, vp++;\n      cy = mpn_addmul_1 (rp, up, un, vp[0]);\n      add_ssaaaa (hi, lo, hi, lo, CNST_LIMB(0), cy);\n    }\n\n  /* store final limbs */\n#if GMP_NAIL_BITS != 0\n  hi = (hi << GMP_NAIL_BITS) + (lo >> GMP_NUMB_BITS);\n  lo &= GMP_NUMB_MASK;\n#endif\n\n  rp[un] = lo;\n  rp[un + 1] = hi;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mulmid_n.c": {
    "mpn_mulmid_n": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\nmpn_mulmid_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  ASSERT (n >= 1);\n  ASSERT (! MPN_OVERLAP_P (rp, n + 2, ap, 2*n - 1));\n  ASSERT (! MPN_OVERLAP_P (rp, n + 2, bp, n));\n\n  if (n < MULMID_TOOM42_THRESHOLD)\n    {\n      mpn_mulmid_basecase (rp, ap, 2*n - 1, bp, n);\n    }\n  else\n    {\n      mp_ptr scratch;\n      TMP_DECL;\n      TMP_MARK;\n      scratch = TMP_ALLOC_LIMBS (mpn_toom42_mulmid_itch (n));\n      mpn_toom42_mulmid (rp, ap, bp, n, scratch);\n      TMP_FREE;\n    }\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mulmod_bnm1.c": {
    "mpn_bc_mulmod_bnm1": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nmpn_bc_mulmod_bnm1 (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t rn,\n\t\t    mp_ptr tp)\n{\n  mp_limb_t cy;\n\n  ASSERT (0 < rn);\n\n  mpn_mul_n (tp, ap, bp, rn);\n  cy = mpn_add_n (rp, tp, tp + rn, rn);\n  /* If cy == 1, then the value of rp is at most B^rn - 2, so there can\n   * be no overflow when adding in the carry. */\n  MPN_INCR_U (rp, rn, cy);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpn_bc_mulmod_bnp1": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void\nmpn_bc_mulmod_bnp1 (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t rn,\n\t\t    mp_ptr tp)\n{\n  mp_limb_t cy;\n\n  ASSERT (0 < rn);\n\n  mpn_mul_n (tp, ap, bp, rn + 1);\n  ASSERT (tp[2*rn+1] == 0);\n  ASSERT (tp[2*rn] < GMP_NUMB_MAX);\n  cy = tp[2*rn] + mpn_sub_n (rp, tp, tp+rn, rn);\n  rp[rn] = 0;\n  MPN_INCR_U (rp, rn+1, cy );\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_mulmod_bnm1": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "void\nmpn_mulmod_bnm1 (mp_ptr rp, mp_size_t rn, mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn, mp_ptr tp)\n{\n  ASSERT (0 < bn);\n  ASSERT (bn <= an);\n  ASSERT (an <= rn);\n\n  if ((rn & 1) != 0 || BELOW_THRESHOLD (rn, MULMOD_BNM1_THRESHOLD))\n    {\n      if (UNLIKELY (bn < rn))\n\t{\n\t  if (UNLIKELY (an + bn <= rn))\n\t    {\n\t      mpn_mul (rp, ap, an, bp, bn);\n\t    }\n\t  else\n\t    {\n\t      mp_limb_t cy;\n\t      mpn_mul (tp, ap, an, bp, bn);\n\t      cy = mpn_add (rp, tp, rn, tp + rn, an + bn - rn);\n\t      MPN_INCR_U (rp, rn, cy);\n\t    }\n\t}\n      else\n\tmpn_bc_mulmod_bnm1 (rp, ap, bp, rn, tp);\n    }\n  else\n    {\n      mp_size_t n;\n      mp_limb_t cy;\n      mp_limb_t hi;\n\n      n = rn >> 1;\n\n      /* We need at least an + bn >= n, to be able to fit one of the\n\t recursive products at rp. Requiring strict inequality makes\n\t the code slightly simpler. If desired, we could avoid this\n\t restriction by initially halving rn as long as rn is even and\n\t an + bn <= rn/2. */\n\n      ASSERT (an + bn > n);\n\n      /* Compute xm = a*b mod (B^n - 1), xp = a*b mod (B^n + 1)\n\t and crt together as\n\n\t x = -xp * B^n + (B^n + 1) * [ (xp + xm)/2 mod (B^n-1)]\n      */\n\n#define a0 ap\n#define a1 (ap + n)\n#define b0 bp\n#define b1 (bp + n)\n\n#define xp  tp\t/* 2n + 2 */\n      /* am1  maybe in {xp, n} */\n      /* bm1  maybe in {xp + n, n} */\n#define sp1 (tp + 2*n + 2)\n      /* ap1  maybe in {sp1, n + 1} */\n      /* bp1  maybe in {sp1 + n + 1, n + 1} */\n\n      {\n\tmp_srcptr am1, bm1;\n\tmp_size_t anm, bnm;\n\tmp_ptr so;\n\n\tbm1 = b0;\n\tbnm = bn;\n\tif (LIKELY (an > n))\n\t  {\n\t    am1 = xp;\n\t    cy = mpn_add (xp, a0, n, a1, an - n);\n\t    MPN_INCR_U (xp, n, cy);\n\t    anm = n;\n\t    so = xp + n;\n\t    if (LIKELY (bn > n))\n\t      {\n\t\tbm1 = so;\n\t\tcy = mpn_add (so, b0, n, b1, bn - n);\n\t\tMPN_INCR_U (so, n, cy);\n\t\tbnm = n;\n\t\tso += n;\n\t      }\n\t  }\n\telse\n\t  {\n\t    so = xp;\n\t    am1 = a0;\n\t    anm = an;\n\t  }\n\n\tmpn_mulmod_bnm1 (rp, n, am1, anm, bm1, bnm, so);\n      }\n\n      {\n\tint       k;\n\tmp_srcptr ap1, bp1;\n\tmp_size_t anp, bnp;\n\n\tbp1 = b0;\n\tbnp = bn;\n\tif (LIKELY (an > n)) {\n\t  ap1 = sp1;\n\t  cy = mpn_sub (sp1, a0, n, a1, an - n);\n\t  sp1[n] = 0;\n\t  MPN_INCR_U (sp1, n + 1, cy);\n\t  anp = n + ap1[n];\n\t  if (LIKELY (bn > n)) {\n\t    bp1 = sp1 + n + 1;\n\t    cy = mpn_sub (sp1 + n + 1, b0, n, b1, bn - n);\n\t    sp1[2*n+1] = 0;\n\t    MPN_INCR_U (sp1 + n + 1, n + 1, cy);\n\t    bnp = n + bp1[n];\n\t  }\n\t} else {\n\t  ap1 = a0;\n\t  anp = an;\n\t}\n\n\tif (BELOW_THRESHOLD (n, MUL_FFT_MODF_THRESHOLD))\n\t  k=0;\n\telse\n\t  {\n\t    int mask;\n\t    k = mpn_fft_best_k (n, 0);\n\t    mask = (1<<k) - 1;\n\t    while (n & mask) {k--; mask >>=1;};\n\t  }\n\tif (k >= FFT_FIRST_K)\n\t  xp[n] = mpn_mul_fft (xp, n, ap1, anp, bp1, bnp, k);\n\telse if (UNLIKELY (bp1 == b0))\n\t  {\n\t    ASSERT (anp + bnp <= 2*n+1);\n\t    ASSERT (anp + bnp > n);\n\t    ASSERT (anp >= bnp);\n\t    mpn_mul (xp, ap1, anp, bp1, bnp);\n\t    anp = anp + bnp - n;\n\t    ASSERT (anp <= n || xp[2*n]==0);\n\t    anp-= anp > n;\n\t    cy = mpn_sub (xp, xp, n, xp + n, anp);\n\t    xp[n] = 0;\n\t    MPN_INCR_U (xp, n+1, cy);\n\t  }\n\telse\n\t  mpn_bc_mulmod_bnp1 (xp, ap1, bp1, n, xp);\n      }\n\n      /* Here the CRT recomposition begins.\n\n\t xm <- (xp + xm)/2 = (xp + xm)B^n/2 mod (B^n-1)\n\t Division by 2 is a bitwise rotation.\n\n\t Assumes xp normalised mod (B^n+1).\n\n\t The residue class [0] is represented by [B^n-1]; except when\n\t both input are ZERO.\n      */\n\n#if HAVE_NATIVE_mpn_rsh1add_n || HAVE_NATIVE_mpn_rsh1add_nc\n#if HAVE_NATIVE_mpn_rsh1add_nc\n      cy = mpn_rsh1add_nc(rp, rp, xp, n, xp[n]); /* B^n = 1 */\n      hi = cy << (GMP_NUMB_BITS - 1);\n      cy = 0;\n      /* next update of rp[n-1] will set cy = 1 only if rp[n-1]+=hi\n\t overflows, i.e. a further increment will not overflow again. */\n#else /* ! _nc */\n      cy = xp[n] + mpn_rsh1add_n(rp, rp, xp, n); /* B^n = 1 */\n      hi = (cy<<(GMP_NUMB_BITS-1))&GMP_NUMB_MASK; /* (cy&1) << ... */\n      cy >>= 1;\n      /* cy = 1 only if xp[n] = 1 i.e. {xp,n} = ZERO, this implies that\n\t the rsh1add was a simple rshift: the top bit is 0. cy=1 => hi=0. */\n#endif\n#if GMP_NAIL_BITS == 0\n      add_ssaaaa(cy, rp[n-1], cy, rp[n-1], 0, hi);\n#else\n      cy += (hi & rp[n-1]) >> (GMP_NUMB_BITS-1);\n      rp[n-1] ^= hi;\n#endif\n#else /* ! HAVE_NATIVE_mpn_rsh1add_n */\n#if HAVE_NATIVE_mpn_add_nc\n      cy = mpn_add_nc(rp, rp, xp, n, xp[n]);\n#else /* ! _nc */\n      cy = xp[n] + mpn_add_n(rp, rp, xp, n); /* xp[n] == 1 implies {xp,n} == ZERO */\n#endif\n      cy += (rp[0]&1);\n      mpn_rshift(rp, rp, n, 1);\n      ASSERT (cy <= 2);\n      hi = (cy<<(GMP_NUMB_BITS-1))&GMP_NUMB_MASK; /* (cy&1) << ... */\n      cy >>= 1;\n      /* We can have cy != 0 only if hi = 0... */\n      ASSERT ((rp[n-1] & GMP_NUMB_HIGHBIT) == 0);\n      rp[n-1] |= hi;\n      /* ... rp[n-1] + cy can not overflow, the following INCR is correct. */\n#endif\n      ASSERT (cy <= 1);\n      /* Next increment can not overflow, read the previous comments about cy. */\n      ASSERT ((cy == 0) || ((rp[n-1] & GMP_NUMB_HIGHBIT) == 0));\n      MPN_INCR_U(rp, n, cy);\n\n      /* Compute the highest half:\n\t ([(xp + xm)/2 mod (B^n-1)] - xp ) * B^n\n       */\n      if (UNLIKELY (an + bn < rn))\n\t{\n\t  /* Note that in this case, the only way the result can equal\n\t     zero mod B^{rn} - 1 is if one of the inputs is zero, and\n\t     then the output of both the recursive calls and this CRT\n\t     reconstruction is zero, not B^{rn} - 1. Which is good,\n\t     since the latter representation doesn't fit in the output\n\t     area.*/\n\t  cy = mpn_sub_n (rp + n, rp, xp, an + bn - n);\n\n\t  /* FIXME: This subtraction of the high parts is not really\n\t     necessary, we do it to get the carry out, and for sanity\n\t     checking. */\n\t  cy = xp[n] + mpn_sub_nc (xp + an + bn - n, rp + an + bn - n,\n\t\t\t\t   xp + an + bn - n, rn - (an + bn), cy);\n\t  ASSERT (an + bn == rn - 1 ||\n\t\t  mpn_zero_p (xp + an + bn - n + 1, rn - 1 - (an + bn)));\n\t  cy = mpn_sub_1 (rp, rp, an + bn, cy);\n\t  ASSERT (cy == (xp + an + bn - n)[0]);\n\t}\n      else\n\t{\n\t  cy = xp[n] + mpn_sub_n (rp + n, rp, xp, n);\n\t  /* cy = 1 only if {xp,n+1} is not ZERO, i.e. {rp,n} is not ZERO.\n\t     DECR will affect _at most_ the lowest n limbs. */\n\t  MPN_DECR_U (rp, 2*n, cy);\n\t}\n#undef a0\n#undef a1\n#undef b0\n#undef b1\n#undef xp\n#undef sp1\n    }\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "mpn_mulmod_bnm1_next_size": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "mp_size_t\nmpn_mulmod_bnm1_next_size (mp_size_t n)\n{\n  mp_size_t nh;\n\n  if (BELOW_THRESHOLD (n,     MULMOD_BNM1_THRESHOLD))\n    return n;\n  if (BELOW_THRESHOLD (n, 4 * (MULMOD_BNM1_THRESHOLD - 1) + 1))\n    return (n + (2-1)) & (-2);\n  if (BELOW_THRESHOLD (n, 8 * (MULMOD_BNM1_THRESHOLD - 1) + 1))\n    return (n + (4-1)) & (-4);\n\n  nh = (n + 1) >> 1;\n\n  if (BELOW_THRESHOLD (nh, MUL_FFT_MODF_THRESHOLD))\n    return (n + (8-1)) & (-8);\n\n  return 2 * mpn_fft_next_size (nh, mpn_fft_best_k (nh, 0));\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mul_1.c": {
    "mpn_mul_1": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "mp_limb_t\nmpn_mul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_INCR_P (rp, up, n));\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}",
        "lines": 23,
        "depth": 10,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          66,
          0
        ],
        "end_point": [
          94,
          1
        ],
        "content": "mp_limb_t\nmpn_mul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t shifted_vl, ul, lpl, hpl, prev_hpl, xw, cl, xl;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_INCR_P (rp, up, n));\n  ASSERT_MPN (up, n);\n  ASSERT_LIMB (vl);\n\n  shifted_vl = vl << GMP_NAIL_BITS;\n  cl = 0;\n  prev_hpl = 0;\n  do\n    {\n      ul = *up++;\n\n      umul_ppmm (hpl, lpl, ul, shifted_vl);\n      lpl >>= GMP_NAIL_BITS;\n      xw = prev_hpl + lpl + cl;\n      cl = xw >> GMP_NUMB_BITS;\n      xl = xw & GMP_NUMB_MASK;\n      *rp++ = xl;\n      prev_hpl = hpl;\n    }\n  while (--n != 0);\n\n  return prev_hpl + cl;\n}",
        "lines": 29,
        "depth": 9,
        "decorators": [
          "mp_limb_t"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/mul_basecase.c": {
    "mpn_mul_basecase": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\nmpn_mul_basecase (mp_ptr rp,\n\t\t  mp_srcptr up, mp_size_t un,\n\t\t  mp_srcptr vp, mp_size_t vn)\n{\n  ASSERT (un >= vn);\n  ASSERT (vn >= 1);\n  ASSERT (! MPN_OVERLAP_P (rp, un+vn, up, un));\n  ASSERT (! MPN_OVERLAP_P (rp, un+vn, vp, vn));\n\n  /* We first multiply by the low order limb (or depending on optional function\n     availability, limbs).  This result can be stored, not added, to rp.  We\n     also avoid a loop for zeroing this way.  */\n\n#if HAVE_NATIVE_mpn_mul_2\n  if (vn >= 2)\n    {\n      rp[un + 1] = mpn_mul_2 (rp, up, un, vp);\n      rp += 2, vp += 2, vn -= 2;\n    }\n  else\n    {\n      rp[un] = mpn_mul_1 (rp, up, un, vp[0]);\n      return;\n    }\n#else\n  rp[un] = mpn_mul_1 (rp, up, un, vp[0]);\n  rp += 1, vp += 1, vn -= 1;\n#endif\n\n  /* Now accumulate the product of up[] and the next higher limb (or depending\n     on optional function availability, limbs) from vp[].  */\n\n#define MAX_LEFT MP_SIZE_T_MAX\t/* Used to simplify loops into if statements */\n\n\n#if HAVE_NATIVE_mpn_addmul_6\n  while (vn >= 6)\n    {\n      rp[un + 6 - 1] = mpn_addmul_6 (rp, up, un, vp);\n      if (MAX_LEFT == 6)\n\treturn;\n      rp += 6, vp += 6, vn -= 6;\n      if (MAX_LEFT < 2 * 6)\n\tbreak;\n    }\n#undef MAX_LEFT\n#define MAX_LEFT (6 - 1)\n#endif\n\n#if HAVE_NATIVE_mpn_addmul_5\n  while (vn >= 5)\n    {\n      rp[un + 5 - 1] = mpn_addmul_5 (rp, up, un, vp);\n      if (MAX_LEFT == 5)\n\treturn;\n      rp += 5, vp += 5, vn -= 5;\n      if (MAX_LEFT < 2 * 5)\n\tbreak;\n    }\n#undef MAX_LEFT\n#define MAX_LEFT (5 - 1)\n#endif\n\n#if HAVE_NATIVE_mpn_addmul_4\n  while (vn >= 4)\n    {\n      rp[un + 4 - 1] = mpn_addmul_4 (rp, up, un, vp);\n      if (MAX_LEFT == 4)\n\treturn;\n      rp += 4, vp += 4, vn -= 4;\n      if (MAX_LEFT < 2 * 4)\n\tbreak;\n    }\n#undef MAX_LEFT\n#define MAX_LEFT (4 - 1)\n#endif\n\n#if HAVE_NATIVE_mpn_addmul_3\n  while (vn >= 3)\n    {\n      rp[un + 3 - 1] = mpn_addmul_3 (rp, up, un, vp);\n      if (MAX_LEFT == 3)\n\treturn;\n      rp += 3, vp += 3, vn -= 3;\n      if (MAX_LEFT < 2 * 3)\n\tbreak;\n    }\n#undef MAX_LEFT\n#define MAX_LEFT (3 - 1)\n#endif\n\n#if HAVE_NATIVE_mpn_addmul_2\n  while (vn >= 2)\n    {\n      rp[un + 2 - 1] = mpn_addmul_2 (rp, up, un, vp);\n      if (MAX_LEFT == 2)\n\treturn;\n      rp += 2, vp += 2, vn -= 2;\n      if (MAX_LEFT < 2 * 2)\n\tbreak;\n    }\n#undef MAX_LEFT\n#define MAX_LEFT (2 - 1)\n#endif\n\n  while (vn >= 1)\n    {\n      rp[un] = mpn_addmul_1 (rp, up, un, vp[0]);\n      if (MAX_LEFT == 1)\n\treturn;\n      rp += 1, vp += 1, vn -= 1;\n    }\n}",
      "lines": 114,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mul_fft.c": {
    "mpn_fft_best_k": [
      {
        "start_point": [
          113,
          0
        ],
        "end_point": [
          131,
          1
        ],
        "content": "int\nmpn_fft_best_k (mp_size_t n, int sqr)\n{\n  const struct fft_table_nk *fft_tab, *tab;\n  mp_size_t tab_n, thres;\n  int last_k;\n\n  fft_tab = mpn_fft_table3[sqr];\n  last_k = fft_tab->k;\n  for (tab = fft_tab + 1; ; tab++)\n    {\n      tab_n = tab->n;\n      thres = tab_n << last_k;\n      if (n <= thres)\n\tbreak;\n      last_k = tab->k;\n    }\n  return last_k;\n}",
        "lines": 19,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          145,
          0
        ],
        "end_point": [
          159,
          1
        ],
        "content": "int\nmpn_fft_best_k (mp_size_t n, int sqr)\n{\n  int i;\n\n  for (i = 0; mpn_fft_table[sqr][i] != 0; i++)\n    if (n < mpn_fft_table[sqr][i])\n      return i + FFT_FIRST_K;\n\n  /* treat 4*last as one further entry */\n  if (i == 0 || n < 4 * mpn_fft_table[sqr][i - 1])\n    return i + FFT_FIRST_K;\n  else\n    return i + FFT_FIRST_K + 1;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "mpn_fft_next_size": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "mp_size_t\nmpn_fft_next_size (mp_size_t pl, int k)\n{\n  pl = 1 + ((pl - 1) >> k); /* ceil (pl/2^k) */\n  return pl << k;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_fft_initl": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static void\nmpn_fft_initl (int **l, int k)\n{\n  int i, j, K;\n  int *li;\n\n  l[0][0] = 0;\n  for (i = 1, K = 1; i <= k; i++, K *= 2)\n    {\n      li = l[i];\n      for (j = 0; j < K; j++)\n\t{\n\t  li[j] = 2 * l[i - 1][j];\n\t  li[K + j] = 1 + li[j];\n\t}\n    }\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_fft_mul_2exp_modF": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static void\nmpn_fft_mul_2exp_modF (mp_ptr r, mp_srcptr a, mp_bitcnt_t d, mp_size_t n)\n{\n  unsigned int sh;\n  mp_size_t m;\n  mp_limb_t cc, rd;\n\n  sh = d % GMP_NUMB_BITS;\n  m = d / GMP_NUMB_BITS;\n\n  if (m >= n)\t\t\t/* negate */\n    {\n      /* r[0..m-1]  <-- lshift(a[n-m]..a[n-1], sh)\n\t r[m..n-1]  <-- -lshift(a[0]..a[n-m-1],  sh) */\n\n      m -= n;\n      if (sh != 0)\n\t{\n\t  /* no out shift below since a[n] <= 1 */\n\t  mpn_lshift (r, a + n - m, m + 1, sh);\n\t  rd = r[m];\n\t  cc = mpn_lshiftc (r + m, a, n - m, sh);\n\t}\n      else\n\t{\n\t  MPN_COPY (r, a + n - m, m);\n\t  rd = a[n];\n\t  mpn_com (r + m, a, n - m);\n\t  cc = 0;\n\t}\n\n      /* add cc to r[0], and add rd to r[m] */\n\n      /* now add 1 in r[m], subtract 1 in r[n], i.e. add 1 in r[0] */\n\n      r[n] = 0;\n      /* cc < 2^sh <= 2^(GMP_NUMB_BITS-1) thus no overflow here */\n      cc++;\n      mpn_incr_u (r, cc);\n\n      rd++;\n      /* rd might overflow when sh=GMP_NUMB_BITS-1 */\n      cc = (rd == 0) ? 1 : rd;\n      r = r + m + (rd == 0);\n      mpn_incr_u (r, cc);\n    }\n  else\n    {\n      /* r[0..m-1]  <-- -lshift(a[n-m]..a[n-1], sh)\n\t r[m..n-1]  <-- lshift(a[0]..a[n-m-1],  sh)  */\n      if (sh != 0)\n\t{\n\t  /* no out bits below since a[n] <= 1 */\n\t  mpn_lshiftc (r, a + n - m, m + 1, sh);\n\t  rd = ~r[m];\n\t  /* {r, m+1} = {a+n-m, m+1} << sh */\n\t  cc = mpn_lshift (r + m, a, n - m, sh); /* {r+m, n-m} = {a, n-m}<<sh */\n\t}\n      else\n\t{\n\t  /* r[m] is not used below, but we save a test for m=0 */\n\t  mpn_com (r, a + n - m, m + 1);\n\t  rd = a[n];\n\t  MPN_COPY (r + m, a, n - m);\n\t  cc = 0;\n\t}\n\n      /* now complement {r, m}, subtract cc from r[0], subtract rd from r[m] */\n\n      /* if m=0 we just have r[0]=a[n] << sh */\n      if (m != 0)\n\t{\n\t  /* now add 1 in r[0], subtract 1 in r[m] */\n\t  if (cc-- == 0) /* then add 1 to r[0] */\n\t    cc = mpn_add_1 (r, r, n, CNST_LIMB(1));\n\t  cc = mpn_sub_1 (r, r, m, cc) + 1;\n\t  /* add 1 to cc instead of rd since rd might overflow */\n\t}\n\n      /* now subtract cc and rd from r[m..n] */\n\n      r[n] = -mpn_sub_1 (r + m, r + m, n - m, cc);\n      r[n] -= mpn_sub_1 (r + m, r + m, n - m, rd);\n      if (r[n] & GMP_LIMB_HIGHBIT)\n\tr[n] = mpn_add_1 (r, r, n, CNST_LIMB(1));\n    }\n}",
      "lines": 87,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_fft_add_modF": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "static inline void\nmpn_fft_add_modF (mp_ptr r, mp_srcptr a, mp_srcptr b, mp_size_t n)\n{\n  mp_limb_t c, x;\n\n  c = a[n] + b[n] + mpn_add_n (r, a, b, n);\n  /* 0 <= c <= 3 */\n\n#if 1\n  /* GCC 4.1 outsmarts most expressions here, and generates a 50% branch.  The\n     result is slower code, of course.  But the following outsmarts GCC.  */\n  x = (c - 1) & -(c != 0);\n  r[n] = c - x;\n  MPN_DECR_U (r, n + 1, x);\n#endif\n#if 0\n  if (c > 1)\n    {\n      r[n] = 1;                       /* r[n] - c = 1 */\n      MPN_DECR_U (r, n + 1, c - 1);\n    }\n  else\n    {\n      r[n] = c;\n    }\n#endif\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "mpn_fft_sub_modF": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "static inline void\nmpn_fft_sub_modF (mp_ptr r, mp_srcptr a, mp_srcptr b, mp_size_t n)\n{\n  mp_limb_t c, x;\n\n  c = a[n] - b[n] - mpn_sub_n (r, a, b, n);\n  /* -2 <= c <= 1 */\n\n#if 1\n  /* GCC 4.1 outsmarts most expressions here, and generates a 50% branch.  The\n     result is slower code, of course.  But the following outsmarts GCC.  */\n  x = (-c) & -((c & GMP_LIMB_HIGHBIT) != 0);\n  r[n] = x + c;\n  MPN_INCR_U (r, n + 1, x);\n#endif\n#if 0\n  if ((c & GMP_LIMB_HIGHBIT) != 0)\n    {\n      r[n] = 0;\n      MPN_INCR_U (r, n + 1, -c);\n    }\n  else\n    {\n      r[n] = c;\n    }\n#endif\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "mpn_fft_fft": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "static void\nmpn_fft_fft (mp_ptr *Ap, mp_size_t K, int **ll,\n\t     mp_size_t omega, mp_size_t n, mp_size_t inc, mp_ptr tp)\n{\n  if (K == 2)\n    {\n      mp_limb_t cy;\n#if HAVE_NATIVE_mpn_add_n_sub_n\n      cy = mpn_add_n_sub_n (Ap[0], Ap[inc], Ap[0], Ap[inc], n + 1) & 1;\n#else\n      MPN_COPY (tp, Ap[0], n + 1);\n      mpn_add_n (Ap[0], Ap[0], Ap[inc], n + 1);\n      cy = mpn_sub_n (Ap[inc], tp, Ap[inc], n + 1);\n#endif\n      if (Ap[0][n] > 1) /* can be 2 or 3 */\n\tAp[0][n] = 1 - mpn_sub_1 (Ap[0], Ap[0], n, Ap[0][n] - 1);\n      if (cy) /* Ap[inc][n] can be -1 or -2 */\n\tAp[inc][n] = mpn_add_1 (Ap[inc], Ap[inc], n, ~Ap[inc][n] + 1);\n    }\n  else\n    {\n      mp_size_t j, K2 = K >> 1;\n      int *lk = *ll;\n\n      mpn_fft_fft (Ap,     K2, ll-1, 2 * omega, n, inc * 2, tp);\n      mpn_fft_fft (Ap+inc, K2, ll-1, 2 * omega, n, inc * 2, tp);\n      /* A[2*j*inc]   <- A[2*j*inc] + omega^l[k][2*j*inc] A[(2j+1)inc]\n\t A[(2j+1)inc] <- A[2*j*inc] + omega^l[k][(2j+1)inc] A[(2j+1)inc] */\n      for (j = 0; j < K2; j++, lk += 2, Ap += 2 * inc)\n\t{\n\t  /* Ap[inc] <- Ap[0] + Ap[inc] * 2^(lk[1] * omega)\n\t     Ap[0]   <- Ap[0] + Ap[inc] * 2^(lk[0] * omega) */\n\t  mpn_fft_mul_2exp_modF (tp, Ap[inc], lk[0] * omega, n);\n\t  mpn_fft_sub_modF (Ap[inc], Ap[0], tp, n);\n\t  mpn_fft_add_modF (Ap[0],   Ap[0], tp, n);\n\t}\n    }\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_fft_normalize": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "static inline void\nmpn_fft_normalize (mp_ptr ap, mp_size_t n)\n{\n  if (ap[n] != 0)\n    {\n      MPN_DECR_U (ap, n + 1, CNST_LIMB(1));\n      if (ap[n] == 0)\n\t{\n\t  /* This happens with very low probability; we have yet to trigger it,\n\t     and thereby make sure this code is correct.  */\n\t  MPN_ZERO (ap, n);\n\t  ap[n] = 1;\n\t}\n      else\n\tap[n] = 0;\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "mpn_fft_mul_modF_K": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        539,
        1
      ],
      "content": "static void\nmpn_fft_mul_modF_K (mp_ptr *ap, mp_ptr *bp, mp_size_t n, mp_size_t K)\n{\n  int i;\n  int sqr = (ap == bp);\n  TMP_DECL;\n\n  TMP_MARK;\n\n  if (n >= (sqr ? SQR_FFT_MODF_THRESHOLD : MUL_FFT_MODF_THRESHOLD))\n    {\n      mp_size_t K2, nprime2, Nprime2, M2, maxLK, l, Mp2;\n      int k;\n      int **fft_l, *tmp;\n      mp_ptr *Ap, *Bp, A, B, T;\n\n      k = mpn_fft_best_k (n, sqr);\n      K2 = (mp_size_t) 1 << k;\n      ASSERT_ALWAYS((n & (K2 - 1)) == 0);\n      maxLK = (K2 > GMP_NUMB_BITS) ? K2 : GMP_NUMB_BITS;\n      M2 = n * GMP_NUMB_BITS >> k;\n      l = n >> k;\n      Nprime2 = ((2 * M2 + k + 2 + maxLK) / maxLK) * maxLK;\n      /* Nprime2 = ceil((2*M2+k+3)/maxLK)*maxLK*/\n      nprime2 = Nprime2 / GMP_NUMB_BITS;\n\n      /* we should ensure that nprime2 is a multiple of the next K */\n      if (nprime2 >= (sqr ? SQR_FFT_MODF_THRESHOLD : MUL_FFT_MODF_THRESHOLD))\n\t{\n\t  mp_size_t K3;\n\t  for (;;)\n\t    {\n\t      K3 = (mp_size_t) 1 << mpn_fft_best_k (nprime2, sqr);\n\t      if ((nprime2 & (K3 - 1)) == 0)\n\t\tbreak;\n\t      nprime2 = (nprime2 + K3 - 1) & -K3;\n\t      Nprime2 = nprime2 * GMP_LIMB_BITS;\n\t      /* warning: since nprime2 changed, K3 may change too! */\n\t    }\n\t}\n      ASSERT_ALWAYS(nprime2 < n); /* otherwise we'll loop */\n\n      Mp2 = Nprime2 >> k;\n\n      Ap = TMP_BALLOC_MP_PTRS (K2);\n      Bp = TMP_BALLOC_MP_PTRS (K2);\n      A = TMP_BALLOC_LIMBS (2 * (nprime2 + 1) << k);\n      T = TMP_BALLOC_LIMBS (2 * (nprime2 + 1));\n      B = A + ((nprime2 + 1) << k);\n      fft_l = TMP_BALLOC_TYPE (k + 1, int *);\n      tmp = TMP_BALLOC_TYPE ((size_t) 2 << k, int);\n      for (i = 0; i <= k; i++)\n\t{\n\t  fft_l[i] = tmp;\n\t  tmp += (mp_size_t) 1 << i;\n\t}\n\n      mpn_fft_initl (fft_l, k);\n\n      TRACE (printf (\"recurse: %ldx%ld limbs -> %ld times %ldx%ld (%1.2f)\\n\", n,\n\t\t    n, K2, nprime2, nprime2, 2.0*(double)n/nprime2/K2));\n      for (i = 0; i < K; i++, ap++, bp++)\n\t{\n\t  mp_limb_t cy;\n\t  mpn_fft_normalize (*ap, n);\n\t  if (!sqr)\n\t    mpn_fft_normalize (*bp, n);\n\n\t  mpn_mul_fft_decompose (A, Ap, K2, nprime2, *ap, (l << k) + 1, l, Mp2, T);\n\t  if (!sqr)\n\t    mpn_mul_fft_decompose (B, Bp, K2, nprime2, *bp, (l << k) + 1, l, Mp2, T);\n\n\t  cy = mpn_mul_fft_internal (*ap, n, k, Ap, Bp, A, B, nprime2,\n\t\t\t\t     l, Mp2, fft_l, T, sqr);\n\t  (*ap)[n] = cy;\n\t}\n    }\n  else\n    {\n      mp_ptr a, b, tp, tpn;\n      mp_limb_t cc;\n      mp_size_t n2 = 2 * n;\n      tp = TMP_BALLOC_LIMBS (n2);\n      tpn = tp + n;\n      TRACE (printf (\"  mpn_mul_n %ld of %ld limbs\\n\", K, n));\n      for (i = 0; i < K; i++)\n\t{\n\t  a = *ap++;\n\t  b = *bp++;\n\t  if (sqr)\n\t    mpn_sqr (tp, a, n);\n\t  else\n\t    mpn_mul_n (tp, b, a, n);\n\t  if (a[n] != 0)\n\t    cc = mpn_add_n (tpn, tpn, b, n);\n\t  else\n\t    cc = 0;\n\t  if (b[n] != 0)\n\t    cc += mpn_add_n (tpn, tpn, a, n) + a[n];\n\t  if (cc != 0)\n\t    {\n\t      /* FIXME: use MPN_INCR_U here, since carry is not expected.  */\n\t      cc = mpn_add_1 (tp, tp, n2, cc);\n\t      ASSERT (cc == 0);\n\t    }\n\t  a[n] = mpn_sub_n (a, tp, tpn, n) && mpn_add_1 (a, a, n, CNST_LIMB(1));\n\t}\n    }\n  TMP_FREE;\n}",
      "lines": 110,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_fft_fftinv": {
      "start_point": [
        547,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "static void\nmpn_fft_fftinv (mp_ptr *Ap, mp_size_t K, mp_size_t omega, mp_size_t n, mp_ptr tp)\n{\n  if (K == 2)\n    {\n      mp_limb_t cy;\n#if HAVE_NATIVE_mpn_add_n_sub_n\n      cy = mpn_add_n_sub_n (Ap[0], Ap[1], Ap[0], Ap[1], n + 1) & 1;\n#else\n      MPN_COPY (tp, Ap[0], n + 1);\n      mpn_add_n (Ap[0], Ap[0], Ap[1], n + 1);\n      cy = mpn_sub_n (Ap[1], tp, Ap[1], n + 1);\n#endif\n      if (Ap[0][n] > 1) /* can be 2 or 3 */\n\tAp[0][n] = 1 - mpn_sub_1 (Ap[0], Ap[0], n, Ap[0][n] - 1);\n      if (cy) /* Ap[1][n] can be -1 or -2 */\n\tAp[1][n] = mpn_add_1 (Ap[1], Ap[1], n, ~Ap[1][n] + 1);\n    }\n  else\n    {\n      mp_size_t j, K2 = K >> 1;\n\n      mpn_fft_fftinv (Ap,      K2, 2 * omega, n, tp);\n      mpn_fft_fftinv (Ap + K2, K2, 2 * omega, n, tp);\n      /* A[j]     <- A[j] + omega^j A[j+K/2]\n\t A[j+K/2] <- A[j] + omega^(j+K/2) A[j+K/2] */\n      for (j = 0; j < K2; j++, Ap++)\n\t{\n\t  /* Ap[K2] <- Ap[0] + Ap[K2] * 2^((j + K2) * omega)\n\t     Ap[0]  <- Ap[0] + Ap[K2] * 2^(j * omega) */\n\t  mpn_fft_mul_2exp_modF (tp, Ap[K2], j * omega, n);\n\t  mpn_fft_sub_modF (Ap[K2], Ap[0], tp, n);\n\t  mpn_fft_add_modF (Ap[0],  Ap[0], tp, n);\n\t}\n    }\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_fft_div_2exp_modF": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        597,
        1
      ],
      "content": "static void\nmpn_fft_div_2exp_modF (mp_ptr r, mp_srcptr a, mp_bitcnt_t k, mp_size_t n)\n{\n  mp_bitcnt_t i;\n\n  ASSERT (r != a);\n  i = (mp_bitcnt_t) 2 * n * GMP_NUMB_BITS - k;\n  mpn_fft_mul_2exp_modF (r, a, i, n);\n  /* 1/2^k = 2^(2nL-k) mod 2^(n*GMP_NUMB_BITS)+1 */\n  /* normalize so that R < 2^(n*GMP_NUMB_BITS)+1 */\n  mpn_fft_normalize (r, n);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_fft_norm_modF": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        633,
        1
      ],
      "content": "static mp_size_t\nmpn_fft_norm_modF (mp_ptr rp, mp_size_t n, mp_ptr ap, mp_size_t an)\n{\n  mp_size_t l, m, rpn;\n  mp_limb_t cc;\n\n  ASSERT ((n <= an) && (an <= 3 * n));\n  m = an - 2 * n;\n  if (m > 0)\n    {\n      l = n;\n      /* add {ap, m} and {ap+2n, m} in {rp, m} */\n      cc = mpn_add_n (rp, ap, ap + 2 * n, m);\n      /* copy {ap+m, n-m} to {rp+m, n-m} */\n      rpn = mpn_add_1 (rp + m, ap + m, n - m, cc);\n    }\n  else\n    {\n      l = an - n; /* l <= n */\n      MPN_COPY (rp, ap, n);\n      rpn = 0;\n    }\n\n  /* remains to subtract {ap+n, l} from {rp, n+1} */\n  cc = mpn_sub_n (rp, rp, ap + n, l);\n  rpn -= mpn_sub_1 (rp + l, rp + l, n - l, cc);\n  if (rpn < 0) /* necessarily rpn = -1 */\n    rpn = mpn_add_1 (rp, rp, n, CNST_LIMB(1));\n  return rpn;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_mul_fft_decompose": {
      "start_point": [
        641,
        0
      ],
      "end_point": [
        716,
        1
      ],
      "content": "static void\nmpn_mul_fft_decompose (mp_ptr A, mp_ptr *Ap, mp_size_t K, mp_size_t nprime,\n\t\t       mp_srcptr n, mp_size_t nl, mp_size_t l, mp_size_t Mp,\n\t\t       mp_ptr T)\n{\n  mp_size_t i, j;\n  mp_ptr tmp;\n  mp_size_t Kl = K * l;\n  TMP_DECL;\n  TMP_MARK;\n\n  if (nl > Kl) /* normalize {n, nl} mod 2^(Kl*GMP_NUMB_BITS)+1 */\n    {\n      mp_size_t dif = nl - Kl;\n      mp_limb_signed_t cy;\n\n      tmp = TMP_BALLOC_LIMBS(Kl + 1);\n\n      if (dif > Kl)\n\t{\n\t  int subp = 0;\n\n\t  cy = mpn_sub_n (tmp, n, n + Kl, Kl);\n\t  n += 2 * Kl;\n\t  dif -= Kl;\n\n\t  /* now dif > 0 */\n\t  while (dif > Kl)\n\t    {\n\t      if (subp)\n\t\tcy += mpn_sub_n (tmp, tmp, n, Kl);\n\t      else\n\t\tcy -= mpn_add_n (tmp, tmp, n, Kl);\n\t      subp ^= 1;\n\t      n += Kl;\n\t      dif -= Kl;\n\t    }\n\t  /* now dif <= Kl */\n\t  if (subp)\n\t    cy += mpn_sub (tmp, tmp, Kl, n, dif);\n\t  else\n\t    cy -= mpn_add (tmp, tmp, Kl, n, dif);\n\t  if (cy >= 0)\n\t    cy = mpn_add_1 (tmp, tmp, Kl, cy);\n\t  else\n\t    cy = mpn_sub_1 (tmp, tmp, Kl, -cy);\n\t}\n      else /* dif <= Kl, i.e. nl <= 2 * Kl */\n\t{\n\t  cy = mpn_sub (tmp, n, Kl, n + Kl, dif);\n\t  cy = mpn_add_1 (tmp, tmp, Kl, cy);\n\t}\n      tmp[Kl] = cy;\n      nl = Kl + 1;\n      n = tmp;\n    }\n  for (i = 0; i < K; i++)\n    {\n      Ap[i] = A;\n      /* store the next M bits of n into A[0..nprime] */\n      if (nl > 0) /* nl is the number of remaining limbs */\n\t{\n\t  j = (l <= nl && i < K - 1) ? l : nl; /* store j next limbs */\n\t  nl -= j;\n\t  MPN_COPY (T, n, j);\n\t  MPN_ZERO (T + j, nprime + 1 - j);\n\t  n += l;\n\t  mpn_fft_mul_2exp_modF (A, T, i * Mp, nprime);\n\t}\n      else\n\tMPN_ZERO (A, nprime + 1);\n      A += nprime + 1;\n    }\n  ASSERT_ALWAYS (nl == 0);\n  TMP_FREE;\n}",
      "lines": 76,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_mul_fft_internal": {
      "start_point": [
        724,
        0
      ],
      "end_point": [
        807,
        1
      ],
      "content": "static mp_limb_t\nmpn_mul_fft_internal (mp_ptr op, mp_size_t pl, int k,\n\t\t      mp_ptr *Ap, mp_ptr *Bp, mp_ptr A, mp_ptr B,\n\t\t      mp_size_t nprime, mp_size_t l, mp_size_t Mp,\n\t\t      int **fft_l, mp_ptr T, int sqr)\n{\n  mp_size_t K, i, pla, lo, sh, j;\n  mp_ptr p;\n  mp_limb_t cc;\n\n  K = (mp_size_t) 1 << k;\n\n  /* direct fft's */\n  mpn_fft_fft (Ap, K, fft_l + k, 2 * Mp, nprime, 1, T);\n  if (!sqr)\n    mpn_fft_fft (Bp, K, fft_l + k, 2 * Mp, nprime, 1, T);\n\n  /* term to term multiplications */\n  mpn_fft_mul_modF_K (Ap, sqr ? Ap : Bp, nprime, K);\n\n  /* inverse fft's */\n  mpn_fft_fftinv (Ap, K, 2 * Mp, nprime, T);\n\n  /* division of terms after inverse fft */\n  Bp[0] = T + nprime + 1;\n  mpn_fft_div_2exp_modF (Bp[0], Ap[0], k, nprime);\n  for (i = 1; i < K; i++)\n    {\n      Bp[i] = Ap[i - 1];\n      mpn_fft_div_2exp_modF (Bp[i], Ap[i], k + (K - i) * Mp, nprime);\n    }\n\n  /* addition of terms in result p */\n  MPN_ZERO (T, nprime + 1);\n  pla = l * (K - 1) + nprime + 1; /* number of required limbs for p */\n  p = B; /* B has K*(n' + 1) limbs, which is >= pla, i.e. enough */\n  MPN_ZERO (p, pla);\n  cc = 0; /* will accumulate the (signed) carry at p[pla] */\n  for (i = K - 1, lo = l * i + nprime,sh = l * i; i >= 0; i--,lo -= l,sh -= l)\n    {\n      mp_ptr n = p + sh;\n\n      j = (K - i) & (K - 1);\n\n      if (mpn_add_n (n, n, Bp[j], nprime + 1))\n\tcc += mpn_add_1 (n + nprime + 1, n + nprime + 1,\n\t\t\t  pla - sh - nprime - 1, CNST_LIMB(1));\n      T[2 * l] = i + 1; /* T = (i + 1)*2^(2*M) */\n      if (mpn_cmp (Bp[j], T, nprime + 1) > 0)\n\t{ /* subtract 2^N'+1 */\n\t  cc -= mpn_sub_1 (n, n, pla - sh, CNST_LIMB(1));\n\t  cc -= mpn_sub_1 (p + lo, p + lo, pla - lo, CNST_LIMB(1));\n\t}\n    }\n  if (cc == -CNST_LIMB(1))\n    {\n      if ((cc = mpn_add_1 (p + pla - pl, p + pla - pl, pl, CNST_LIMB(1))))\n\t{\n\t  /* p[pla-pl]...p[pla-1] are all zero */\n\t  mpn_sub_1 (p + pla - pl - 1, p + pla - pl - 1, pl + 1, CNST_LIMB(1));\n\t  mpn_sub_1 (p + pla - 1, p + pla - 1, 1, CNST_LIMB(1));\n\t}\n    }\n  else if (cc == 1)\n    {\n      if (pla >= 2 * pl)\n\t{\n\t  while ((cc = mpn_add_1 (p + pla - 2 * pl, p + pla - 2 * pl, 2 * pl, cc)))\n\t    ;\n\t}\n      else\n\t{\n\t  cc = mpn_sub_1 (p + pla - pl, p + pla - pl, pl, cc);\n\t  ASSERT (cc == 0);\n\t}\n    }\n  else\n    ASSERT (cc == 0);\n\n  /* here p < 2^(2M) [K 2^(M(K-1)) + (K-1) 2^(M(K-2)) + ... ]\n     < K 2^(2M) [2^(M(K-1)) + 2^(M(K-2)) + ... ]\n     < K 2^(2M) 2^(M(K-1))*2 = 2^(M*K+M+k+1) */\n  return mpn_fft_norm_modF (op, pl, p, pla);\n}",
      "lines": 84,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_mul_fft_lcm": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        821,
        1
      ],
      "content": "static mp_bitcnt_t\nmpn_mul_fft_lcm (mp_bitcnt_t a, int k)\n{\n  mp_bitcnt_t l = k;\n\n  while (a % 2 == 0 && k > 0)\n    {\n      a >>= 1;\n      k --;\n    }\n  return a << l;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_bitcnt_t"
      ]
    },
    "mpn_mul_fft": {
      "start_point": [
        824,
        0
      ],
      "end_point": [
        907,
        1
      ],
      "content": "mp_limb_t\nmpn_mul_fft (mp_ptr op, mp_size_t pl,\n\t     mp_srcptr n, mp_size_t nl,\n\t     mp_srcptr m, mp_size_t ml,\n\t     int k)\n{\n  int i;\n  mp_size_t K, maxLK;\n  mp_size_t N, Nprime, nprime, M, Mp, l;\n  mp_ptr *Ap, *Bp, A, T, B;\n  int **fft_l, *tmp;\n  int sqr = (n == m && nl == ml);\n  mp_limb_t h;\n  TMP_DECL;\n\n  TRACE (printf (\"\\nmpn_mul_fft pl=%ld nl=%ld ml=%ld k=%d\\n\", pl, nl, ml, k));\n  ASSERT_ALWAYS (mpn_fft_next_size (pl, k) == pl);\n\n  TMP_MARK;\n  N = pl * GMP_NUMB_BITS;\n  fft_l = TMP_BALLOC_TYPE (k + 1, int *);\n  tmp = TMP_BALLOC_TYPE ((size_t) 2 << k, int);\n  for (i = 0; i <= k; i++)\n    {\n      fft_l[i] = tmp;\n      tmp += (mp_size_t) 1 << i;\n    }\n\n  mpn_fft_initl (fft_l, k);\n  K = (mp_size_t) 1 << k;\n  M = N >> k;\t/* N = 2^k M */\n  l = 1 + (M - 1) / GMP_NUMB_BITS;\n  maxLK = mpn_mul_fft_lcm (GMP_NUMB_BITS, k); /* lcm (GMP_NUMB_BITS, 2^k) */\n\n  Nprime = (1 + (2 * M + k + 2) / maxLK) * maxLK;\n  /* Nprime = ceil((2*M+k+3)/maxLK)*maxLK; */\n  nprime = Nprime / GMP_NUMB_BITS;\n  TRACE (printf (\"N=%ld K=%ld, M=%ld, l=%ld, maxLK=%ld, Np=%ld, np=%ld\\n\",\n\t\t N, K, M, l, maxLK, Nprime, nprime));\n  /* we should ensure that recursively, nprime is a multiple of the next K */\n  if (nprime >= (sqr ? SQR_FFT_MODF_THRESHOLD : MUL_FFT_MODF_THRESHOLD))\n    {\n      mp_size_t K2;\n      for (;;)\n\t{\n\t  K2 = (mp_size_t) 1 << mpn_fft_best_k (nprime, sqr);\n\t  if ((nprime & (K2 - 1)) == 0)\n\t    break;\n\t  nprime = (nprime + K2 - 1) & -K2;\n\t  Nprime = nprime * GMP_LIMB_BITS;\n\t  /* warning: since nprime changed, K2 may change too! */\n\t}\n      TRACE (printf (\"new maxLK=%ld, Np=%ld, np=%ld\\n\", maxLK, Nprime, nprime));\n    }\n  ASSERT_ALWAYS (nprime < pl); /* otherwise we'll loop */\n\n  T = TMP_BALLOC_LIMBS (2 * (nprime + 1));\n  Mp = Nprime >> k;\n\n  TRACE (printf (\"%ldx%ld limbs -> %ld times %ldx%ld limbs (%1.2f)\\n\",\n\t\tpl, pl, K, nprime, nprime, 2.0 * (double) N / Nprime / K);\n\t printf (\"   temp space %ld\\n\", 2 * K * (nprime + 1)));\n\n  A = TMP_BALLOC_LIMBS (K * (nprime + 1));\n  Ap = TMP_BALLOC_MP_PTRS (K);\n  mpn_mul_fft_decompose (A, Ap, K, nprime, n, nl, l, Mp, T);\n  if (sqr)\n    {\n      mp_size_t pla;\n      pla = l * (K - 1) + nprime + 1; /* number of required limbs for p */\n      B = TMP_BALLOC_LIMBS (pla);\n      Bp = TMP_BALLOC_MP_PTRS (K);\n    }\n  else\n    {\n      B = TMP_BALLOC_LIMBS (K * (nprime + 1));\n      Bp = TMP_BALLOC_MP_PTRS (K);\n      mpn_mul_fft_decompose (B, Bp, K, nprime, m, ml, l, Mp, T);\n    }\n  h = mpn_mul_fft_internal (op, pl, k, Ap, Bp, A, B, nprime, l, Mp, fft_l, T, sqr);\n\n  TMP_FREE;\n  return h;\n}",
      "lines": 84,
      "depth": 14,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mul_fft_full": {
      "start_point": [
        911,
        0
      ],
      "end_point": [
        1012,
        1
      ],
      "content": "void\nmpn_mul_fft_full (mp_ptr op,\n\t\t  mp_srcptr n, mp_size_t nl,\n\t\t  mp_srcptr m, mp_size_t ml)\n{\n  mp_ptr pad_op;\n  mp_size_t pl, pl2, pl3, l;\n  mp_size_t cc, c2, oldcc;\n  int k2, k3;\n  int sqr = (n == m && nl == ml);\n\n  pl = nl + ml; /* total number of limbs of the result */\n\n  /* perform a fft mod 2^(2N)+1 and one mod 2^(3N)+1.\n     We must have pl3 = 3/2 * pl2, with pl2 a multiple of 2^k2, and\n     pl3 a multiple of 2^k3. Since k3 >= k2, both are multiples of 2^k2,\n     and pl2 must be an even multiple of 2^k2. Thus (pl2,pl3) =\n     (2*j*2^k2,3*j*2^k2), which works for 3*j <= pl/2^k2 <= 5*j.\n     We need that consecutive intervals overlap, i.e. 5*j >= 3*(j+1),\n     which requires j>=2. Thus this scheme requires pl >= 6 * 2^FFT_FIRST_K. */\n\n  /*  ASSERT_ALWAYS(pl >= 6 * (1 << FFT_FIRST_K)); */\n\n  pl2 = (2 * pl - 1) / 5; /* ceil (2pl/5) - 1 */\n  do\n    {\n      pl2++;\n      k2 = mpn_fft_best_k (pl2, sqr); /* best fft size for pl2 limbs */\n      pl2 = mpn_fft_next_size (pl2, k2);\n      pl3 = 3 * pl2 / 2; /* since k>=FFT_FIRST_K=4, pl2 is a multiple of 2^4,\n\t\t\t    thus pl2 / 2 is exact */\n      k3 = mpn_fft_best_k (pl3, sqr);\n    }\n  while (mpn_fft_next_size (pl3, k3) != pl3);\n\n  TRACE (printf (\"mpn_mul_fft_full nl=%ld ml=%ld -> pl2=%ld pl3=%ld k=%d\\n\",\n\t\t nl, ml, pl2, pl3, k2));\n\n  ASSERT_ALWAYS(pl3 <= pl);\n  cc = mpn_mul_fft (op, pl3, n, nl, m, ml, k3);     /* mu */\n  ASSERT(cc == 0);\n  pad_op = __GMP_ALLOCATE_FUNC_LIMBS (pl2);\n  cc = mpn_mul_fft (pad_op, pl2, n, nl, m, ml, k2); /* lambda */\n  cc = -cc + mpn_sub_n (pad_op, pad_op, op, pl2);    /* lambda - low(mu) */\n  /* 0 <= cc <= 1 */\n  ASSERT(0 <= cc && cc <= 1);\n  l = pl3 - pl2; /* l = pl2 / 2 since pl3 = 3/2 * pl2 */\n  c2 = mpn_add_n (pad_op, pad_op, op + pl2, l);\n  cc = mpn_add_1 (pad_op + l, pad_op + l, l, (mp_limb_t) c2) - cc;\n  ASSERT(-1 <= cc && cc <= 1);\n  if (cc < 0)\n    cc = mpn_add_1 (pad_op, pad_op, pl2, (mp_limb_t) -cc);\n  ASSERT(0 <= cc && cc <= 1);\n  /* now lambda-mu = {pad_op, pl2} - cc mod 2^(pl2*GMP_NUMB_BITS)+1 */\n  oldcc = cc;\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  c2 = mpn_add_n_sub_n (pad_op + l, pad_op, pad_op, pad_op + l, l);\n  /* c2 & 1 is the borrow, c2 & 2 is the carry */\n  cc += c2 >> 1; /* carry out from high <- low + high */\n  c2 = c2 & 1; /* borrow out from low <- low - high */\n#else\n  {\n    mp_ptr tmp;\n    TMP_DECL;\n\n    TMP_MARK;\n    tmp = TMP_BALLOC_LIMBS (l);\n    MPN_COPY (tmp, pad_op, l);\n    c2 = mpn_sub_n (pad_op,      pad_op, pad_op + l, l);\n    cc += mpn_add_n (pad_op + l, tmp,    pad_op + l, l);\n    TMP_FREE;\n  }\n#endif\n  c2 += oldcc;\n  /* first normalize {pad_op, pl2} before dividing by 2: c2 is the borrow\n     at pad_op + l, cc is the carry at pad_op + pl2 */\n  /* 0 <= cc <= 2 */\n  cc -= mpn_sub_1 (pad_op + l, pad_op + l, l, (mp_limb_t) c2);\n  /* -1 <= cc <= 2 */\n  if (cc > 0)\n    cc = -mpn_sub_1 (pad_op, pad_op, pl2, (mp_limb_t) cc);\n  /* now -1 <= cc <= 0 */\n  if (cc < 0)\n    cc = mpn_add_1 (pad_op, pad_op, pl2, (mp_limb_t) -cc);\n  /* now {pad_op, pl2} is normalized, with 0 <= cc <= 1 */\n  if (pad_op[0] & 1) /* if odd, add 2^(pl2*GMP_NUMB_BITS)+1 */\n    cc += 1 + mpn_add_1 (pad_op, pad_op, pl2, CNST_LIMB(1));\n  /* now 0 <= cc <= 2, but cc=2 cannot occur since it would give a carry\n     out below */\n  mpn_rshift (pad_op, pad_op, pl2, 1); /* divide by two */\n  if (cc) /* then cc=1 */\n    pad_op [pl2 - 1] |= (mp_limb_t) 1 << (GMP_NUMB_BITS - 1);\n  /* now {pad_op,pl2}-cc = (lambda-mu)/(1-2^(l*GMP_NUMB_BITS))\n     mod 2^(pl2*GMP_NUMB_BITS) + 1 */\n  c2 = mpn_add_n (op, op, pad_op, pl2); /* no need to add cc (is 0) */\n  /* since pl2+pl3 >= pl, necessary the extra limbs (including cc) are zero */\n  MPN_COPY (op + pl3, pad_op, pl - pl3);\n  ASSERT_MPN_ZERO_P (pad_op + pl - pl3, pl2 + pl3 - pl);\n  __GMP_FREE_FUNC_LIMBS (pad_op, pl2);\n  /* since the final result has at most pl limbs, no carry out below */\n  mpn_add_1 (op + pl2, op + pl2, pl - pl2, (mp_limb_t) c2);\n}",
      "lines": 102,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mul_n.c": {
    "mpn_mul_n": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nmpn_mul_n (mp_ptr p, mp_srcptr a, mp_srcptr b, mp_size_t n)\n{\n  ASSERT (n >= 1);\n  ASSERT (! MPN_OVERLAP_P (p, 2 * n, a, n));\n  ASSERT (! MPN_OVERLAP_P (p, 2 * n, b, n));\n\n  if (BELOW_THRESHOLD (n, MUL_TOOM22_THRESHOLD))\n    {\n      mpn_mul_basecase (p, a, n, b, n);\n    }\n  else if (BELOW_THRESHOLD (n, MUL_TOOM33_THRESHOLD))\n    {\n      /* Allocate workspace of fixed size on stack: fast! */\n      mp_limb_t ws[mpn_toom22_mul_itch (MUL_TOOM33_THRESHOLD_LIMIT-1,\n\t\t\t\t\tMUL_TOOM33_THRESHOLD_LIMIT-1)];\n      ASSERT (MUL_TOOM33_THRESHOLD <= MUL_TOOM33_THRESHOLD_LIMIT);\n      mpn_toom22_mul (p, a, n, b, n, ws);\n    }\n  else if (BELOW_THRESHOLD (n, MUL_TOOM44_THRESHOLD))\n    {\n      mp_ptr ws;\n      TMP_SDECL;\n      TMP_SMARK;\n      ws = TMP_SALLOC_LIMBS (mpn_toom33_mul_itch (n, n));\n      mpn_toom33_mul (p, a, n, b, n, ws);\n      TMP_SFREE;\n    }\n  else if (BELOW_THRESHOLD (n, MUL_TOOM6H_THRESHOLD))\n    {\n      mp_ptr ws;\n      TMP_SDECL;\n      TMP_SMARK;\n      ws = TMP_SALLOC_LIMBS (mpn_toom44_mul_itch (n, n));\n      mpn_toom44_mul (p, a, n, b, n, ws);\n      TMP_SFREE;\n    }\n  else if (BELOW_THRESHOLD (n, MUL_TOOM8H_THRESHOLD))\n    {\n      mp_ptr ws;\n      TMP_SDECL;\n      TMP_SMARK;\n      ws = TMP_SALLOC_LIMBS (mpn_toom6_mul_n_itch (n));\n      mpn_toom6h_mul (p, a, n, b, n, ws);\n      TMP_SFREE;\n    }\n  else if (BELOW_THRESHOLD (n, MUL_FFT_THRESHOLD))\n    {\n      mp_ptr ws;\n      TMP_DECL;\n      TMP_MARK;\n      ws = TMP_ALLOC_LIMBS (mpn_toom8_mul_n_itch (n));\n      mpn_toom8h_mul (p, a, n, b, n, ws);\n      TMP_FREE;\n    }\n  else\n    {\n      /* The current FFT code allocates its own space.  That should probably\n\t change.  */\n      mpn_fft_mul (p, a, n, b, n);\n    }\n}",
      "lines": 62,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mu_bdiv_q.c": {
    "mpn_mu_bdiv_q": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "void\nmpn_mu_bdiv_q (mp_ptr qp,\n\t       mp_srcptr np, mp_size_t nn,\n\t       mp_srcptr dp, mp_size_t dn,\n\t       mp_ptr scratch)\n{\n  mp_size_t qn;\n  mp_size_t in;\n  int cy, c0;\n  mp_size_t tn, wn;\n\n  qn = nn;\n\n  ASSERT (dn >= 2);\n  ASSERT (qn >= 2);\n\n  if (qn > dn)\n    {\n      mp_size_t b;\n\n      /* |_______________________|   dividend\n\t\t\t|________|   divisor  */\n\n#define ip           scratch\t\t\t/* in */\n#define rp           (scratch + in)\t\t/* dn or rest >= binvert_itch(in) */\n#define tp           (scratch + in + dn)\t/* dn+in or next_size(dn) */\n#define scratch_out  (scratch + in + dn + tn)\t/* mulmod_bnm1_itch(next_size(dn)) */\n\n      /* Compute an inverse size that is a nice partition of the quotient.  */\n      b = (qn - 1) / dn + 1;\t/* ceil(qn/dn), number of blocks */\n      in = (qn - 1) / b + 1;\t/* ceil(qn/b) = ceil(qn / ceil(qn/dn)) */\n\n      /* Some notes on allocation:\n\n\t When in = dn, R dies when mpn_mullo returns, if in < dn the low in\n\t limbs of R dies at that point.  We could save memory by letting T live\n\t just under R, and let the upper part of T expand into R. These changes\n\t should reduce itch to perhaps 3dn.\n       */\n\n      mpn_binvert (ip, dp, in, rp);\n\n      cy = 0;\n\n      MPN_COPY (rp, np, dn);\n      np += dn;\n      mpn_mullo_n (qp, rp, ip, in);\n      qn -= in;\n\n      while (qn > in)\n\t{\n\t  if (BELOW_THRESHOLD (in, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n\t    mpn_mul (tp, dp, dn, qp, in);\t/* mulhi, need tp[dn+in-1...in] */\n\t  else\n\t    {\n\t      tn = mpn_mulmod_bnm1_next_size (dn);\n\t      mpn_mulmod_bnm1 (tp, tn, dp, dn, qp, in, scratch_out);\n\t      wn = dn + in - tn;\t\t/* number of wrapped limbs */\n\t      if (wn > 0)\n\t\t{\n\t\t  c0 = mpn_sub_n (tp + tn, tp, rp, wn);\n\t\t  mpn_decr_u (tp + wn, c0);\n\t\t}\n\t    }\n\n\t  qp += in;\n\t  if (dn != in)\n\t    {\n\t      /* Subtract tp[dn-1...in] from partial remainder.  */\n\t      cy += mpn_sub_n (rp, rp + in, tp + in, dn - in);\n\t      if (cy == 2)\n\t\t{\n\t\t  mpn_incr_u (tp + dn, 1);\n\t\t  cy = 1;\n\t\t}\n\t    }\n\t  /* Subtract tp[dn+in-1...dn] from dividend.  */\n\t  cy = mpn_sub_nc (rp + dn - in, np, tp + dn, in, cy);\n\t  np += in;\n\t  mpn_mullo_n (qp, rp, ip, in);\n\t  qn -= in;\n\t}\n\n      /* Generate last qn limbs.\n\t FIXME: It should be possible to limit precision here, since qn is\n\t typically somewhat smaller than dn.  No big gains expected.  */\n\n      if (BELOW_THRESHOLD (in, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n\tmpn_mul (tp, dp, dn, qp, in);\t\t/* mulhi, need tp[qn+in-1...in] */\n      else\n\t{\n\t  tn = mpn_mulmod_bnm1_next_size (dn);\n\t  mpn_mulmod_bnm1 (tp, tn, dp, dn, qp, in, scratch_out);\n\t  wn = dn + in - tn;\t\t\t/* number of wrapped limbs */\n\t  if (wn > 0)\n\t    {\n\t      c0 = mpn_sub_n (tp + tn, tp, rp, wn);\n\t      mpn_decr_u (tp + wn, c0);\n\t    }\n\t}\n\n      qp += in;\n      if (dn != in)\n\t{\n\t  cy += mpn_sub_n (rp, rp + in, tp + in, dn - in);\n\t  if (cy == 2)\n\t    {\n\t      mpn_incr_u (tp + dn, 1);\n\t      cy = 1;\n\t    }\n\t}\n\n      mpn_sub_nc (rp + dn - in, np, tp + dn, qn - (dn - in), cy);\n      mpn_mullo_n (qp, rp, ip, qn);\n\n#undef ip\n#undef rp\n#undef tp\n#undef scratch_out\n   }\n  else\n    {\n      /* |_______________________|   dividend\n\t\t|________________|   divisor  */\n\n#define ip           scratch\t\t/* in */\n#define tp           (scratch + in)\t/* qn+in or next_size(qn) or rest >= binvert_itch(in) */\n#define scratch_out  (scratch + in + tn)/* mulmod_bnm1_itch(next_size(qn)) */\n\n      /* Compute half-sized inverse.  */\n      in = qn - (qn >> 1);\n\n      mpn_binvert (ip, dp, in, tp);\n\n      mpn_mullo_n (qp, np, ip, in);\t\t/* low `in' quotient limbs */\n\n      if (BELOW_THRESHOLD (in, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n\tmpn_mul (tp, dp, qn, qp, in);\t\t/* mulhigh */\n      else\n\t{\n\t  tn = mpn_mulmod_bnm1_next_size (qn);\n\t  mpn_mulmod_bnm1 (tp, tn, dp, qn, qp, in, scratch_out);\n\t  wn = qn + in - tn;\t\t\t/* number of wrapped limbs */\n\t  if (wn > 0)\n\t    {\n\t      c0 = mpn_cmp (tp, np, wn) < 0;\n\t      mpn_decr_u (tp + wn, c0);\n\t    }\n\t}\n\n      mpn_sub_n (tp, np + in, tp + in, qn - in);\n      mpn_mullo_n (qp + in, tp, ip, qn - in);\t/* high qn-in quotient limbs */\n\n#undef ip\n#undef tp\n#undef scratch_out\n    }\n}",
      "lines": 158,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "mpn_mu_bdiv_q_itch": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "mp_size_t\nmpn_mu_bdiv_q_itch (mp_size_t nn, mp_size_t dn)\n{\n  mp_size_t qn, in, tn, itch_binvert, itch_out, itches;\n  mp_size_t b;\n\n  ASSERT_ALWAYS (DC_BDIV_Q_THRESHOLD < MU_BDIV_Q_THRESHOLD);\n\n  qn = nn;\n\n  if (qn > dn)\n    {\n      b = (qn - 1) / dn + 1;\t/* ceil(qn/dn), number of blocks */\n      in = (qn - 1) / b + 1;\t/* ceil(qn/b) = ceil(qn / ceil(qn/dn)) */\n      if (BELOW_THRESHOLD (in, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n\t{\n\t  tn = dn + in;\n\t  itch_out = 0;\n\t}\n      else\n\t{\n\t  tn = mpn_mulmod_bnm1_next_size (dn);\n\t  itch_out = mpn_mulmod_bnm1_itch (tn, dn, in);\n\t}\n      itches = dn + tn + itch_out;\n    }\n  else\n    {\n      in = qn - (qn >> 1);\n      if (BELOW_THRESHOLD (in, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n\t{\n\t  tn = qn + in;\n\t  itch_out = 0;\n\t}\n      else\n\t{\n\t  tn = mpn_mulmod_bnm1_next_size (qn);\n\t  itch_out = mpn_mulmod_bnm1_itch (tn, qn, in);\n\t}\n      itches = tn + itch_out;\n    }\n\n  itch_binvert = mpn_binvert_itch (in);\n  return in + MAX (itches, itch_binvert);\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mu_bdiv_qr.c": {
    "mpn_mu_bdiv_qr": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "mp_limb_t\nmpn_mu_bdiv_qr (mp_ptr qp,\n\t\tmp_ptr rp,\n\t\tmp_srcptr np, mp_size_t nn,\n\t\tmp_srcptr dp, mp_size_t dn,\n\t\tmp_ptr scratch)\n{\n  mp_size_t qn;\n  mp_size_t in;\n  mp_limb_t cy, c0;\n  mp_size_t tn, wn;\n\n  qn = nn - dn;\n\n  ASSERT (dn >= 2);\n  ASSERT (qn >= 2);\n\n  if (qn > dn)\n    {\n      mp_size_t b;\n\n      /* |_______________________|   dividend\n\t\t\t|________|   divisor  */\n\n#define ip           scratch\t\t/* in */\n#define tp           (scratch + in)\t/* dn+in or next_size(dn) or rest >= binvert_itch(in) */\n#define scratch_out  (scratch + in + tn)/* mulmod_bnm1_itch(next_size(dn)) */\n\n      /* Compute an inverse size that is a nice partition of the quotient.  */\n      b = (qn - 1) / dn + 1;\t/* ceil(qn/dn), number of blocks */\n      in = (qn - 1) / b + 1;\t/* ceil(qn/b) = ceil(qn / ceil(qn/dn)) */\n\n      /* Some notes on allocation:\n\n\t When in = dn, R dies when mpn_mullo returns, if in < dn the low in\n\t limbs of R dies at that point.  We could save memory by letting T live\n\t just under R, and let the upper part of T expand into R. These changes\n\t should reduce itch to perhaps 3dn.\n       */\n\n      mpn_binvert (ip, dp, in, tp);\n\n      MPN_COPY (rp, np, dn);\n      np += dn;\n      cy = 0;\n\n      while (qn > in)\n\t{\n\t  mpn_mullo_n (qp, rp, ip, in);\n\n\t  if (BELOW_THRESHOLD (in, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n\t    mpn_mul (tp, dp, dn, qp, in);\t/* mulhi, need tp[dn+in-1...in] */\n\t  else\n\t    {\n\t      tn = mpn_mulmod_bnm1_next_size (dn);\n\t      mpn_mulmod_bnm1 (tp, tn, dp, dn, qp, in, scratch_out);\n\t      wn = dn + in - tn;\t\t/* number of wrapped limbs */\n\t      if (wn > 0)\n\t\t{\n\t\t  c0 = mpn_sub_n (tp + tn, tp, rp, wn);\n\t\t  mpn_decr_u (tp + wn, c0);\n\t\t}\n\t    }\n\n\t  qp += in;\n\t  qn -= in;\n\n\t  if (dn != in)\n\t    {\n\t      /* Subtract tp[dn-1...in] from partial remainder.  */\n\t      cy += mpn_sub_n (rp, rp + in, tp + in, dn - in);\n\t      if (cy == 2)\n\t\t{\n\t\t  mpn_incr_u (tp + dn, 1);\n\t\t  cy = 1;\n\t\t}\n\t    }\n\t  /* Subtract tp[dn+in-1...dn] from dividend.  */\n\t  cy = mpn_sub_nc (rp + dn - in, np, tp + dn, in, cy);\n\t  np += in;\n\t}\n\n      /* Generate last qn limbs.  */\n      mpn_mullo_n (qp, rp, ip, qn);\n\n      if (BELOW_THRESHOLD (qn, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n\tmpn_mul (tp, dp, dn, qp, qn);\t\t/* mulhi, need tp[qn+in-1...in] */\n      else\n\t{\n\t  tn = mpn_mulmod_bnm1_next_size (dn);\n\t  mpn_mulmod_bnm1 (tp, tn, dp, dn, qp, qn, scratch_out);\n\t  wn = dn + qn - tn;\t\t\t/* number of wrapped limbs */\n\t  if (wn > 0)\n\t    {\n\t      c0 = mpn_sub_n (tp + tn, tp, rp, wn);\n\t      mpn_decr_u (tp + wn, c0);\n\t    }\n\t}\n\n      if (dn != qn)\n\t{\n\t  cy += mpn_sub_n (rp, rp + qn, tp + qn, dn - qn);\n\t  if (cy == 2)\n\t    {\n\t      mpn_incr_u (tp + dn, 1);\n\t      cy = 1;\n\t    }\n\t}\n      return mpn_sub_nc (rp + dn - qn, np, tp + dn, qn, cy);\n\n#undef ip\n#undef tp\n#undef scratch_out\n    }\n  else\n    {\n      /* |_______________________|   dividend\n\t\t|________________|   divisor  */\n\n#define ip           scratch\t\t/* in */\n#define tp           (scratch + in)\t/* dn+in or next_size(dn) or rest >= binvert_itch(in) */\n#define scratch_out  (scratch + in + tn)/* mulmod_bnm1_itch(next_size(dn)) */\n\n      /* Compute half-sized inverse.  */\n      in = qn - (qn >> 1);\n\n      mpn_binvert (ip, dp, in, tp);\n\n      mpn_mullo_n (qp, np, ip, in);\t\t/* low `in' quotient limbs */\n\n      if (BELOW_THRESHOLD (in, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n\tmpn_mul (tp, dp, dn, qp, in);\t\t/* mulhigh */\n      else\n\t{\n\t  tn = mpn_mulmod_bnm1_next_size (dn);\n\t  mpn_mulmod_bnm1 (tp, tn, dp, dn, qp, in, scratch_out);\n\t  wn = dn + in - tn;\t\t\t/* number of wrapped limbs */\n\t  if (wn > 0)\n\t    {\n\t      c0 = mpn_sub_n (tp + tn, tp, np, wn);\n\t      mpn_decr_u (tp + wn, c0);\n\t    }\n\t}\n\n      qp += in;\n      qn -= in;\n\n      cy = mpn_sub_n (rp, np + in, tp + in, dn);\n      mpn_mullo_n (qp, rp, ip, qn);\t\t/* high qn quotient limbs */\n\n      if (BELOW_THRESHOLD (qn, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n\tmpn_mul (tp, dp, dn, qp, qn);\t\t/* mulhigh */\n      else\n\t{\n\t  tn = mpn_mulmod_bnm1_next_size (dn);\n\t  mpn_mulmod_bnm1 (tp, tn, dp, dn, qp, qn, scratch_out);\n\t  wn = dn + qn - tn;\t\t\t/* number of wrapped limbs */\n\t  if (wn > 0)\n\t    {\n\t      c0 = mpn_sub_n (tp + tn, tp, rp, wn);\n\t      mpn_decr_u (tp + wn, c0);\n\t    }\n\t}\n\n      cy += mpn_sub_n (rp, rp + qn, tp + qn, dn - qn);\n      if (cy == 2)\n\t{\n\t  mpn_incr_u (tp + dn, 1);\n\t  cy = 1;\n\t}\n      return mpn_sub_nc (rp + dn - qn, np + dn + in, tp + dn, qn, cy);\n\n#undef ip\n#undef tp\n#undef scratch_out\n    }\n}",
      "lines": 177,
      "depth": 16,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mu_bdiv_qr_itch": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "mp_size_t\nmpn_mu_bdiv_qr_itch (mp_size_t nn, mp_size_t dn)\n{\n  mp_size_t qn, in, tn, itch_binvert, itch_out, itches;\n  mp_size_t b;\n\n  ASSERT_ALWAYS (DC_BDIV_Q_THRESHOLD < MU_BDIV_Q_THRESHOLD);\n\n  qn = nn - dn;\n\n  if (qn > dn)\n    {\n      b = (qn - 1) / dn + 1;\t/* ceil(qn/dn), number of blocks */\n      in = (qn - 1) / b + 1;\t/* ceil(qn/b) = ceil(qn / ceil(qn/dn)) */\n    }\n  else\n    {\n      in = qn - (qn >> 1);\n    }\n\n  if (BELOW_THRESHOLD (in, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n    {\n      tn = dn + in;\n      itch_out = 0;\n    }\n  else\n    {\n      tn = mpn_mulmod_bnm1_next_size (dn);\n      itch_out = mpn_mulmod_bnm1_itch (tn, dn, in);\n    }\n\n  itch_binvert = mpn_binvert_itch (in);\n  itches = tn + itch_out;\n  return in + MAX (itches, itch_binvert);\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mu_divappr_q.c": {
    "mpn_mu_divappr_q": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "mp_limb_t\nmpn_mu_divappr_q (mp_ptr qp,\n\t\t  mp_srcptr np,\n\t\t  mp_size_t nn,\n\t\t  mp_srcptr dp,\n\t\t  mp_size_t dn,\n\t\t  mp_ptr scratch)\n{\n  mp_size_t qn, in;\n  mp_limb_t cy, qh;\n  mp_ptr ip, tp;\n\n  ASSERT (dn > 1);\n\n  qn = nn - dn;\n\n  /* If Q is smaller than D, truncate operands. */\n  if (qn + 1 < dn)\n    {\n      np += dn - (qn + 1);\n      nn -= dn - (qn + 1);\n      dp += dn - (qn + 1);\n      dn = qn + 1;\n    }\n\n  /* Compute the inverse size.  */\n  in = mpn_mu_divappr_q_choose_in (qn, dn, 0);\n  ASSERT (in <= dn);\n\n#if 1\n  /* This alternative inverse computation method gets slightly more accurate\n     results.  FIXMEs: (1) Temp allocation needs not analysed (2) itch function\n     not adapted (3) mpn_invertappr scratch needs not met.  */\n  ip = scratch;\n  tp = scratch + in + 1;\n\n  /* compute an approximate inverse on (in+1) limbs */\n  if (dn == in)\n    {\n      MPN_COPY (tp + 1, dp, in);\n      tp[0] = 1;\n      mpn_invertappr (ip, tp, in + 1, tp + in + 1);\n      MPN_COPY_INCR (ip, ip + 1, in);\n    }\n  else\n    {\n      cy = mpn_add_1 (tp, dp + dn - (in + 1), in + 1, 1);\n      if (UNLIKELY (cy != 0))\n\tMPN_ZERO (ip, in);\n      else\n\t{\n\t  mpn_invertappr (ip, tp, in + 1, tp + in + 1);\n\t  MPN_COPY_INCR (ip, ip + 1, in);\n\t}\n    }\n#else\n  /* This older inverse computation method gets slightly worse results than the\n     one above.  */\n  ip = scratch;\n  tp = scratch + in;\n\n  /* Compute inverse of D to in+1 limbs, then round to 'in' limbs.  Ideally the\n     inversion function should do this automatically.  */\n  if (dn == in)\n    {\n      tp[in + 1] = 0;\n      MPN_COPY (tp + in + 2, dp, in);\n      mpn_invertappr (tp, tp + in + 1, in + 1, NULL);\n    }\n  else\n    {\n      mpn_invertappr (tp, dp + dn - (in + 1), in + 1, NULL);\n    }\n  cy = mpn_sub_1 (tp, tp, in + 1, GMP_NUMB_HIGHBIT);\n  if (UNLIKELY (cy != 0))\n    MPN_ZERO (tp + 1, in);\n  MPN_COPY (ip, tp + 1, in);\n#endif\n\n  qh = mpn_preinv_mu_divappr_q (qp, np, nn, dp, dn, ip, in, scratch + in);\n\n  return qh;\n}",
      "lines": 83,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_preinv_mu_divappr_q": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "mp_limb_t\nmpn_preinv_mu_divappr_q (mp_ptr qp,\n\t\t\t mp_srcptr np,\n\t\t\t mp_size_t nn,\n\t\t\t mp_srcptr dp,\n\t\t\t mp_size_t dn,\n\t\t\t mp_srcptr ip,\n\t\t\t mp_size_t in,\n\t\t\t mp_ptr scratch)\n{\n  mp_size_t qn;\n  mp_limb_t cy, cx, qh;\n  mp_limb_t r;\n  mp_size_t tn, wn;\n\n#define rp           scratch\n#define tp           (scratch + dn)\n#define scratch_out  (scratch + dn + tn)\n\n  qn = nn - dn;\n\n  np += qn;\n  qp += qn;\n\n  qh = mpn_cmp (np, dp, dn) >= 0;\n  if (qh != 0)\n    mpn_sub_n (rp, np, dp, dn);\n  else\n    MPN_COPY (rp, np, dn);\n\n  if (qn == 0)\n    return qh;\t\t\t/* Degenerate use.  Should we allow this? */\n\n  while (qn > 0)\n    {\n      if (qn < in)\n\t{\n\t  ip += in - qn;\n\t  in = qn;\n\t}\n      np -= in;\n      qp -= in;\n\n      /* Compute the next block of quotient limbs by multiplying the inverse I\n\t by the upper part of the partial remainder R.  */\n      mpn_mul_n (tp, rp + dn - in, ip, in);\t\t/* mulhi  */\n      cy = mpn_add_n (qp, tp + in, rp + dn - in, in);\t/* I's msb implicit */\n      ASSERT_ALWAYS (cy == 0);\n\n      qn -= in;\n      if (qn == 0)\n\tbreak;\n\n      /* Compute the product of the quotient block and the divisor D, to be\n\t subtracted from the partial remainder combined with new limbs from the\n\t dividend N.  We only really need the low dn limbs.  */\n\n      if (BELOW_THRESHOLD (in, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n\tmpn_mul (tp, dp, dn, qp, in);\t\t/* dn+in limbs, high 'in' cancels */\n      else\n\t{\n\t  tn = mpn_mulmod_bnm1_next_size (dn + 1);\n\t  mpn_mulmod_bnm1 (tp, tn, dp, dn, qp, in, scratch_out);\n\t  wn = dn + in - tn;\t\t\t/* number of wrapped limbs */\n\t  if (wn > 0)\n\t    {\n\t      cy = mpn_sub_n (tp, tp, rp + dn - wn, wn);\n\t      cy = mpn_sub_1 (tp + wn, tp + wn, tn - wn, cy);\n\t      cx = mpn_cmp (rp + dn - in, tp + dn, tn - dn) < 0;\n\t      ASSERT_ALWAYS (cx >= cy);\n\t      mpn_incr_u (tp, cx - cy);\n\t    }\n\t}\n\n      r = rp[dn - in] - tp[dn];\n\n      /* Subtract the product from the partial remainder combined with new\n\t limbs from the dividend N, generating a new partial remainder R.  */\n      if (dn != in)\n\t{\n\t  cy = mpn_sub_n (tp, np, tp, in);\t/* get next 'in' limbs from N */\n\t  cy = mpn_sub_nc (tp + in, rp, tp + in, dn - in, cy);\n\t  MPN_COPY (rp, tp, dn);\t\t/* FIXME: try to avoid this */\n\t}\n      else\n\t{\n\t  cy = mpn_sub_n (rp, np, tp, in);\t/* get next 'in' limbs from N */\n\t}\n\n      STAT (int i; int err = 0;\n\t    static int errarr[5]; static int err_rec; static int tot);\n\n      /* Check the remainder R and adjust the quotient as needed.  */\n      r -= cy;\n      while (r != 0)\n\t{\n\t  /* We loop 0 times with about 69% probability, 1 time with about 31%\n\t     probability, 2 times with about 0.6% probability, if inverse is\n\t     computed as recommended.  */\n\t  mpn_incr_u (qp, 1);\n\t  cy = mpn_sub_n (rp, rp, dp, dn);\n\t  r -= cy;\n\t  STAT (err++);\n\t}\n      if (mpn_cmp (rp, dp, dn) >= 0)\n\t{\n\t  /* This is executed with about 76% probability.  */\n\t  mpn_incr_u (qp, 1);\n\t  cy = mpn_sub_n (rp, rp, dp, dn);\n\t  STAT (err++);\n\t}\n\n      STAT (\n\t    tot++;\n\t    errarr[err]++;\n\t    if (err > err_rec)\n\t      err_rec = err;\n\t    if (tot % 0x10000 == 0)\n\t      {\n\t\tfor (i = 0; i <= err_rec; i++)\n\t\t  printf (\"  %d(%.1f%%)\", errarr[i], 100.0*errarr[i]/tot);\n\t\tprintf (\"\\n\");\n\t      }\n\t    );\n    }\n\n  /* FIXME: We should perhaps be somewhat more elegant in our rounding of the\n     quotient.  For now, just make sure the returned quotient is >= the real\n     quotient; add 3 with saturating arithmetic.  */\n  qn = nn - dn;\n  cy += mpn_add_1 (qp, qp, qn, 3);\n  if (cy != 0)\n    {\n      if (qh != 0)\n\t{\n\t  /* Return a quotient of just 1-bits, with qh set.  */\n\t  mp_size_t i;\n\t  for (i = 0; i < qn; i++)\n\t    qp[i] = GMP_NUMB_MAX;\n\t}\n      else\n\t{\n\t  /* Propagate carry into qh.  */\n\t  qh = 1;\n\t}\n    }\n\n  return qh;\n}",
      "lines": 149,
      "depth": 16,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mu_divappr_q_choose_in": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "mp_size_t\nmpn_mu_divappr_q_choose_in (mp_size_t qn, mp_size_t dn, int k)\n{\n  mp_size_t in;\n\n  if (k == 0)\n    {\n      mp_size_t b;\n      if (qn > dn)\n\t{\n\t  /* Compute an inverse size that is a nice partition of the quotient.  */\n\t  b = (qn - 1) / dn + 1;\t/* ceil(qn/dn), number of blocks */\n\t  in = (qn - 1) / b + 1;\t/* ceil(qn/b) = ceil(qn / ceil(qn/dn)) */\n\t}\n      else if (3 * qn > dn)\n\t{\n\t  in = (qn - 1) / 2 + 1;\t/* b = 2 */\n\t}\n      else\n\t{\n\t  in = (qn - 1) / 1 + 1;\t/* b = 1 */\n\t}\n    }\n  else\n    {\n      mp_size_t xn;\n      xn = MIN (dn, qn);\n      in = (xn - 1) / k + 1;\n    }\n\n  return in;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_mu_divappr_q_itch": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "mp_size_t\nmpn_mu_divappr_q_itch (mp_size_t nn, mp_size_t dn, int mua_k)\n{\n  mp_size_t qn, in, itch_local, itch_out, itch_invapp;\n\n  qn = nn - dn;\n  if (qn + 1 < dn)\n    {\n      dn = qn + 1;\n    }\n  in = mpn_mu_divappr_q_choose_in (qn, dn, mua_k);\n\n  itch_local = mpn_mulmod_bnm1_next_size (dn + 1);\n  itch_out = mpn_mulmod_bnm1_itch (itch_local, dn, in);\n  itch_invapp = mpn_invertappr_itch (in + 1) + in + 2; /* 3in + 4 */\n\n  ASSERT (dn + itch_local + itch_out >= itch_invapp);\n  return in + MAX (dn + itch_local + itch_out, itch_invapp);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mu_div_q.c": {
    "mpn_mu_div_q": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "mp_limb_t\nmpn_mu_div_q (mp_ptr qp,\n\t      mp_srcptr np, mp_size_t nn,\n\t      mp_srcptr dp, mp_size_t dn,\n\t      mp_ptr scratch)\n{\n  mp_ptr tp, rp;\n  mp_size_t qn;\n  mp_limb_t cy, qh;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  qn = nn - dn;\n\n  tp = TMP_BALLOC_LIMBS (qn + 1);\n\n  if (qn >= dn)\t\t\t/* nn >= 2*dn + 1 */\n    {\n       /* |_______________________|   dividend\n\t\t\t |________|   divisor  */\n\n      rp = TMP_BALLOC_LIMBS (nn + 1);\n      MPN_COPY (rp + 1, np, nn);\n      rp[0] = 0;\n\n      qh = mpn_cmp (rp + 1 + nn - dn, dp, dn) >= 0;\n      if (qh != 0)\n\tmpn_sub_n (rp + 1 + nn - dn, rp + 1 + nn - dn, dp, dn);\n\n      cy = mpn_mu_divappr_q (tp, rp, nn + 1, dp, dn, scratch);\n\n      if (UNLIKELY (cy != 0))\n\t{\n\t  /* Since the partial remainder fed to mpn_preinv_mu_divappr_q was\n\t     canonically reduced, replace the returned value of B^(qn-dn)+eps\n\t     by the largest possible value.  */\n\t  mp_size_t i;\n\t  for (i = 0; i < qn + 1; i++)\n\t    tp[i] = GMP_NUMB_MAX;\n\t}\n\n      /* The max error of mpn_mu_divappr_q is +4.  If the low quotient limb is\n\t smaller than the max error, we cannot trust the quotient.  */\n      if (tp[0] > 4)\n\t{\n\t  MPN_COPY (qp, tp + 1, qn);\n\t}\n      else\n\t{\n\t  mp_limb_t cy;\n\t  mp_ptr pp;\n\n\t  pp = rp;\n\t  mpn_mul (pp, tp + 1, qn, dp, dn);\n\n\t  cy = (qh != 0) ? mpn_add_n (pp + qn, pp + qn, dp, dn) : 0;\n\n\t  if (cy || mpn_cmp (pp, np, nn) > 0) /* At most is wrong by one, no cycle. */\n\t    qh -= mpn_sub_1 (qp, tp + 1, qn, 1);\n\t  else /* Same as above */\n\t    MPN_COPY (qp, tp + 1, qn);\n\t}\n    }\n  else\n    {\n       /* |_______________________|   dividend\n\t\t |________________|   divisor  */\n\n      /* FIXME: When nn = 2dn-1, qn becomes dn-1, and the numerator size passed\n\t here becomes 2dn, i.e., more than nn.  This shouldn't hurt, since only\n\t the most significant dn-1 limbs will actually be read, but it is not\n\t pretty.  */\n\n      qh = mpn_mu_divappr_q (tp, np + nn - (2 * qn + 2), 2 * qn + 2,\n\t\t\t     dp + dn - (qn + 1), qn + 1, scratch);\n\n      /* The max error of mpn_mu_divappr_q is +4, but we get an additional\n         error from the divisor truncation.  */\n      if (tp[0] > 6)\n\t{\n\t  MPN_COPY (qp, tp + 1, qn);\n\t}\n      else\n\t{\n\t  mp_limb_t cy;\n\n\t  /* FIXME: a shorter product should be enough; we may use already\n\t     allocated space... */\n\t  rp = TMP_BALLOC_LIMBS (nn);\n\t  mpn_mul (rp, dp, dn, tp + 1, qn);\n\n\t  cy = (qh != 0) ? mpn_add_n (rp + qn, rp + qn, dp, dn) : 0;\n\n\t  if (cy || mpn_cmp (rp, np, nn) > 0) /* At most is wrong by one, no cycle. */\n\t    qh -= mpn_sub_1 (qp, tp + 1, qn, 1);\n\t  else /* Same as above */\n\t    MPN_COPY (qp, tp + 1, qn);\n\t}\n    }\n\n  TMP_FREE;\n  return qh;\n}",
      "lines": 104,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mu_div_q_itch": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "mp_size_t\nmpn_mu_div_q_itch (mp_size_t nn, mp_size_t dn, int mua_k)\n{\n  mp_size_t qn;\n\n  qn = nn - dn;\n  if (qn >= dn)\n    {\n      return mpn_mu_divappr_q_itch (nn + 1, dn, mua_k);\n    }\n  else\n    {\n      return mpn_mu_divappr_q_itch (2 * qn + 2, qn + 1, mua_k);\n    }\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/mu_div_qr.c": {
    "mpn_mu_div_qr": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "mp_limb_t\nmpn_mu_div_qr (mp_ptr qp,\n\t       mp_ptr rp,\n\t       mp_srcptr np,\n\t       mp_size_t nn,\n\t       mp_srcptr dp,\n\t       mp_size_t dn,\n\t       mp_ptr scratch)\n{\n  mp_size_t qn;\n  mp_limb_t cy, qh;\n\n  qn = nn - dn;\n  if (qn + MU_DIV_QR_SKEW_THRESHOLD < dn)\n    {\n      /* |______________|_ign_first__|   dividend\t\t\t  nn\n\t\t|_______|_ign_first__|   divisor\t\t\t  dn\n\n\t\t|______|\t     quotient (prel)\t\t\t  qn\n\n\t\t |___________________|   quotient * ignored-divisor-part  dn-1\n      */\n\n      /* Compute a preliminary quotient and a partial remainder by dividing the\n\t most significant limbs of each operand.  */\n      qh = mpn_mu_div_qr2 (qp, rp + nn - (2 * qn + 1),\n\t\t\t   np + nn - (2 * qn + 1), 2 * qn + 1,\n\t\t\t   dp + dn - (qn + 1), qn + 1,\n\t\t\t   scratch);\n\n      /* Multiply the quotient by the divisor limbs ignored above.  */\n      if (dn - (qn + 1) > qn)\n\tmpn_mul (scratch, dp, dn - (qn + 1), qp, qn);  /* prod is dn-1 limbs */\n      else\n\tmpn_mul (scratch, qp, qn, dp, dn - (qn + 1));  /* prod is dn-1 limbs */\n\n      if (qh)\n\tcy = mpn_add_n (scratch + qn, scratch + qn, dp, dn - (qn + 1));\n      else\n\tcy = 0;\n      scratch[dn - 1] = cy;\n\n      cy = mpn_sub_n (rp, np, scratch, nn - (2 * qn + 1));\n      cy = mpn_sub_nc (rp + nn - (2 * qn + 1),\n\t\t       rp + nn - (2 * qn + 1),\n\t\t       scratch + nn - (2 * qn + 1),\n\t\t       qn + 1, cy);\n      if (cy)\n\t{\n\t  qh -= mpn_sub_1 (qp, qp, qn, 1);\n\t  mpn_add_n (rp, rp, dp, dn);\n\t}\n    }\n  else\n    {\n      qh = mpn_mu_div_qr2 (qp, rp, np, nn, dp, dn, scratch);\n    }\n\n  return qh;\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mu_div_qr2": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "static mp_limb_t\nmpn_mu_div_qr2 (mp_ptr qp,\n\t\tmp_ptr rp,\n\t\tmp_srcptr np,\n\t\tmp_size_t nn,\n\t\tmp_srcptr dp,\n\t\tmp_size_t dn,\n\t\tmp_ptr scratch)\n{\n  mp_size_t qn, in;\n  mp_limb_t cy, qh;\n  mp_ptr ip, tp;\n\n  ASSERT (dn > 1);\n\n  qn = nn - dn;\n\n  /* Compute the inverse size.  */\n  in = mpn_mu_div_qr_choose_in (qn, dn, 0);\n  ASSERT (in <= dn);\n\n#if 1\n  /* This alternative inverse computation method gets slightly more accurate\n     results.  FIXMEs: (1) Temp allocation needs not analysed (2) itch function\n     not adapted (3) mpn_invertappr scratch needs not met.  */\n  ip = scratch;\n  tp = scratch + in + 1;\n\n  /* compute an approximate inverse on (in+1) limbs */\n  if (dn == in)\n    {\n      MPN_COPY (tp + 1, dp, in);\n      tp[0] = 1;\n      mpn_invertappr (ip, tp, in + 1, tp + in + 1);\n      MPN_COPY_INCR (ip, ip + 1, in);\n    }\n  else\n    {\n      cy = mpn_add_1 (tp, dp + dn - (in + 1), in + 1, 1);\n      if (UNLIKELY (cy != 0))\n\tMPN_ZERO (ip, in);\n      else\n\t{\n\t  mpn_invertappr (ip, tp, in + 1, tp + in + 1);\n\t  MPN_COPY_INCR (ip, ip + 1, in);\n\t}\n    }\n#else\n  /* This older inverse computation method gets slightly worse results than the\n     one above.  */\n  ip = scratch;\n  tp = scratch + in;\n\n  /* Compute inverse of D to in+1 limbs, then round to 'in' limbs.  Ideally the\n     inversion function should do this automatically.  */\n  if (dn == in)\n    {\n      tp[in + 1] = 0;\n      MPN_COPY (tp + in + 2, dp, in);\n      mpn_invertappr (tp, tp + in + 1, in + 1, NULL);\n    }\n  else\n    {\n      mpn_invertappr (tp, dp + dn - (in + 1), in + 1, NULL);\n    }\n  cy = mpn_sub_1 (tp, tp, in + 1, GMP_NUMB_HIGHBIT);\n  if (UNLIKELY (cy != 0))\n    MPN_ZERO (tp + 1, in);\n  MPN_COPY (ip, tp + 1, in);\n#endif\n\n  qh = mpn_preinv_mu_div_qr (qp, rp, np, nn, dp, dn, ip, in, scratch + in);\n\n  return qh;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_preinv_mu_div_qr": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "mp_limb_t\nmpn_preinv_mu_div_qr (mp_ptr qp,\n\t\t      mp_ptr rp,\n\t\t      mp_srcptr np,\n\t\t      mp_size_t nn,\n\t\t      mp_srcptr dp,\n\t\t      mp_size_t dn,\n\t\t      mp_srcptr ip,\n\t\t      mp_size_t in,\n\t\t      mp_ptr scratch)\n{\n  mp_size_t qn;\n  mp_limb_t cy, cx, qh;\n  mp_limb_t r;\n  mp_size_t tn, wn;\n\n#define tp           scratch\n#define scratch_out  (scratch + tn)\n\n  qn = nn - dn;\n\n  np += qn;\n  qp += qn;\n\n  qh = mpn_cmp (np, dp, dn) >= 0;\n  if (qh != 0)\n    mpn_sub_n (rp, np, dp, dn);\n  else\n    MPN_COPY_INCR (rp, np, dn);\n\n  /* if (qn == 0) */\t\t\t/* The while below handles this case */\n  /*   return qh; */\t\t\t/* Degenerate use.  Should we allow this? */\n\n  while (qn > 0)\n    {\n      if (qn < in)\n\t{\n\t  ip += in - qn;\n\t  in = qn;\n\t}\n      np -= in;\n      qp -= in;\n\n      /* Compute the next block of quotient limbs by multiplying the inverse I\n\t by the upper part of the partial remainder R.  */\n      mpn_mul_n (tp, rp + dn - in, ip, in);\t\t/* mulhi  */\n      cy = mpn_add_n (qp, tp + in, rp + dn - in, in);\t/* I's msb implicit */\n      ASSERT_ALWAYS (cy == 0);\n\n      qn -= in;\n\n      /* Compute the product of the quotient block and the divisor D, to be\n\t subtracted from the partial remainder combined with new limbs from the\n\t dividend N.  We only really need the low dn+1 limbs.  */\n\n      if (BELOW_THRESHOLD (in, MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD))\n\tmpn_mul (tp, dp, dn, qp, in);\t\t/* dn+in limbs, high 'in' cancels */\n      else\n\t{\n\t  tn = mpn_mulmod_bnm1_next_size (dn + 1);\n\t  mpn_mulmod_bnm1 (tp, tn, dp, dn, qp, in, scratch_out);\n\t  wn = dn + in - tn;\t\t\t/* number of wrapped limbs */\n\t  if (wn > 0)\n\t    {\n\t      cy = mpn_sub_n (tp, tp, rp + dn - wn, wn);\n\t      cy = mpn_sub_1 (tp + wn, tp + wn, tn - wn, cy);\n\t      cx = mpn_cmp (rp + dn - in, tp + dn, tn - dn) < 0;\n\t      ASSERT_ALWAYS (cx >= cy);\n\t      mpn_incr_u (tp, cx - cy);\n\t    }\n\t}\n\n      r = rp[dn - in] - tp[dn];\n\n      /* Subtract the product from the partial remainder combined with new\n\t limbs from the dividend N, generating a new partial remainder R.  */\n      if (dn != in)\n\t{\n\t  cy = mpn_sub_n (tp, np, tp, in);\t/* get next 'in' limbs from N */\n\t  cy = mpn_sub_nc (tp + in, rp, tp + in, dn - in, cy);\n\t  MPN_COPY (rp, tp, dn);\t\t/* FIXME: try to avoid this */\n\t}\n      else\n\t{\n\t  cy = mpn_sub_n (rp, np, tp, in);\t/* get next 'in' limbs from N */\n\t}\n\n      STAT (int i; int err = 0;\n\t    static int errarr[5]; static int err_rec; static int tot);\n\n      /* Check the remainder R and adjust the quotient as needed.  */\n      r -= cy;\n      while (r != 0)\n\t{\n\t  /* We loop 0 times with about 69% probability, 1 time with about 31%\n\t     probability, 2 times with about 0.6% probability, if inverse is\n\t     computed as recommended.  */\n\t  mpn_incr_u (qp, 1);\n\t  cy = mpn_sub_n (rp, rp, dp, dn);\n\t  r -= cy;\n\t  STAT (err++);\n\t}\n      if (mpn_cmp (rp, dp, dn) >= 0)\n\t{\n\t  /* This is executed with about 76% probability.  */\n\t  mpn_incr_u (qp, 1);\n\t  cy = mpn_sub_n (rp, rp, dp, dn);\n\t  STAT (err++);\n\t}\n\n      STAT (\n\t    tot++;\n\t    errarr[err]++;\n\t    if (err > err_rec)\n\t      err_rec = err;\n\t    if (tot % 0x10000 == 0)\n\t      {\n\t\tfor (i = 0; i <= err_rec; i++)\n\t\t  printf (\"  %d(%.1f%%)\", errarr[i], 100.0*errarr[i]/tot);\n\t\tprintf (\"\\n\");\n\t      }\n\t    );\n    }\n\n  return qh;\n}",
      "lines": 126,
      "depth": 16,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mu_div_qr_choose_in": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "mp_size_t\nmpn_mu_div_qr_choose_in (mp_size_t qn, mp_size_t dn, int k)\n{\n  mp_size_t in;\n\n  if (k == 0)\n    {\n      mp_size_t b;\n      if (qn > dn)\n\t{\n\t  /* Compute an inverse size that is a nice partition of the quotient.  */\n\t  b = (qn - 1) / dn + 1;\t/* ceil(qn/dn), number of blocks */\n\t  in = (qn - 1) / b + 1;\t/* ceil(qn/b) = ceil(qn / ceil(qn/dn)) */\n\t}\n      else if (3 * qn > dn)\n\t{\n\t  in = (qn - 1) / 2 + 1;\t/* b = 2 */\n\t}\n      else\n\t{\n\t  in = (qn - 1) / 1 + 1;\t/* b = 1 */\n\t}\n    }\n  else\n    {\n      mp_size_t xn;\n      xn = MIN (dn, qn);\n      in = (xn - 1) / k + 1;\n    }\n\n  return in;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_mu_div_qr_itch": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        407,
        1
      ],
      "content": "mp_size_t\nmpn_mu_div_qr_itch (mp_size_t nn, mp_size_t dn, int mua_k)\n{\n  mp_size_t in = mpn_mu_div_qr_choose_in (nn - dn, dn, mua_k);\n  mp_size_t itch_preinv = mpn_preinv_mu_div_qr_itch (nn, dn, in);\n  mp_size_t itch_invapp = mpn_invertappr_itch (in + 1) + in + 2; /* 3in + 4 */\n\n  ASSERT (itch_preinv >= itch_invapp);\n  return in + MAX (itch_invapp, itch_preinv);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_preinv_mu_div_qr_itch": {
      "start_point": [
        409,
        0
      ],
      "end_point": [
        416,
        1
      ],
      "content": "mp_size_t\nmpn_preinv_mu_div_qr_itch (mp_size_t nn, mp_size_t dn, mp_size_t in)\n{\n  mp_size_t itch_local = mpn_mulmod_bnm1_next_size (dn + 1);\n  mp_size_t itch_out = mpn_mulmod_bnm1_itch (itch_local, dn, in);\n\n  return itch_local + itch_out;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/neg.c": {},
  "gmp/gmp-6.1.2/mpn/generic/nussbaumer_mul.c": {
    "mpn_nussbaumer_mul": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\nmpn_nussbaumer_mul (mp_ptr pp,\n\t\t    mp_srcptr ap, mp_size_t an,\n\t\t    mp_srcptr bp, mp_size_t bn)\n{\n  mp_size_t rn;\n  mp_ptr tp;\n  TMP_DECL;\n\n  ASSERT (an >= bn);\n  ASSERT (bn > 0);\n\n  TMP_MARK;\n\n  if ((ap == bp) && (an == bn))\n    {\n      rn = mpn_sqrmod_bnm1_next_size (2*an);\n      tp = TMP_ALLOC_LIMBS (mpn_sqrmod_bnm1_itch (rn, an));\n      mpn_sqrmod_bnm1 (pp, rn, ap, an, tp);\n    }\n  else\n    {\n      rn = mpn_mulmod_bnm1_next_size (an + bn);\n      tp = TMP_ALLOC_LIMBS (mpn_mulmod_bnm1_itch (rn, an, bn));\n      mpn_mulmod_bnm1 (pp, rn, ap, an, bp, bn, tp);\n    }\n\n  TMP_FREE;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/perfpow.c": {
    "pow_equals": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static int\npow_equals (mp_srcptr np, mp_size_t n,\n\t    mp_srcptr xp,mp_size_t xn,\n\t    mp_limb_t k, mp_bitcnt_t f,\n\t    mp_ptr tp)\n{\n  mp_bitcnt_t y, z;\n  mp_size_t bn;\n  mp_limb_t h, l;\n\n  ASSERT (n > 1 || (n == 1 && np[0] > 1));\n  ASSERT (np[n - 1] > 0);\n  ASSERT (xn > 0);\n\n  if (xn == 1 && xp[0] == 1)\n    return 0;\n\n  z = 1 + (n >> 1);\n  for (bn = 1; bn < z; bn <<= 1)\n    {\n      mpn_powlo (tp, xp, &k, 1, bn, tp + bn);\n      if (mpn_cmp (tp, np, bn) != 0)\n\treturn 0;\n    }\n\n  /* Final check. Estimate the size of {xp,xn}^k before computing the power\n     with full precision.  Optimization: It might pay off to make a more\n     accurate estimation of the logarithm of {xp,xn}, rather than using the\n     index of the MSB.  */\n\n  MPN_SIZEINBASE_2EXP(y, xp, xn, 1);\n  y -= 1;  /* msb_index (xp, xn) */\n\n  umul_ppmm (h, l, k, y);\n  h -= l == 0;  --l;\t/* two-limb decrement */\n\n  z = f - 1; /* msb_index (np, n) */\n  if (h == 0 && l <= z)\n    {\n      mp_limb_t *tp2;\n      mp_size_t i;\n      int ans;\n      mp_limb_t size;\n      TMP_DECL;\n\n      size = l + k;\n      ASSERT_ALWAYS (size >= k);\n\n      TMP_MARK;\n      y = 2 + size / GMP_LIMB_BITS;\n      tp2 = TMP_ALLOC_LIMBS (y);\n\n      i = mpn_pow_1 (tp, xp, xn, k, tp2);\n      if (i == n && mpn_cmp (tp, np, n) == 0)\n\tans = 1;\n      else\n\tans = 0;\n      TMP_FREE;\n      return ans;\n    }\n\n  return 0;\n}",
      "lines": 63,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_kth_power": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static int\nis_kth_power (mp_ptr rp, mp_srcptr np,\n\t      mp_limb_t k, mp_srcptr ip,\n\t      mp_size_t n, mp_bitcnt_t f,\n\t      mp_ptr tp)\n{\n  mp_bitcnt_t b;\n  mp_size_t rn, xn;\n\n  ASSERT (n > 0);\n  ASSERT ((k & 1) != 0 || k == 2);\n  ASSERT ((np[0] & 1) != 0);\n\n  if (k == 2)\n    {\n      b = (f + 1) >> 1;\n      rn = 1 + b / GMP_LIMB_BITS;\n      if (mpn_bsqrtinv (rp, ip, b, tp) != 0)\n\t{\n\t  rp[rn - 1] &= (CNST_LIMB(1) << (b % GMP_LIMB_BITS)) - 1;\n\t  xn = rn;\n\t  MPN_NORMALIZE (rp, xn);\n\t  if (pow_equals (np, n, rp, xn, k, f, tp) != 0)\n\t    return 1;\n\n\t  /* Check if (2^b - r)^2 == n */\n\t  mpn_neg (rp, rp, rn);\n\t  rp[rn - 1] &= (CNST_LIMB(1) << (b % GMP_LIMB_BITS)) - 1;\n\t  MPN_NORMALIZE (rp, rn);\n\t  if (pow_equals (np, n, rp, rn, k, f, tp) != 0)\n\t    return 1;\n\t}\n    }\n  else\n    {\n      b = 1 + (f - 1) / k;\n      rn = 1 + (b - 1) / GMP_LIMB_BITS;\n      mpn_brootinv (rp, ip, rn, k, tp);\n      if ((b % GMP_LIMB_BITS) != 0)\n\trp[rn - 1] &= (CNST_LIMB(1) << (b % GMP_LIMB_BITS)) - 1;\n      MPN_NORMALIZE (rp, rn);\n      if (pow_equals (np, n, rp, rn, k, f, tp) != 0)\n\treturn 1;\n    }\n  MPN_ZERO (rp, rn); /* Untrash rp */\n  return 0;\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "perfpow": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "static int\nperfpow (mp_srcptr np, mp_size_t n,\n\t mp_limb_t ub, mp_limb_t g,\n\t mp_bitcnt_t f, int neg)\n{\n  mp_ptr ip, tp, rp;\n  mp_limb_t k;\n  int ans;\n  mp_bitcnt_t b;\n  gmp_primesieve_t ps;\n  TMP_DECL;\n\n  ASSERT (n > 0);\n  ASSERT ((np[0] & 1) != 0);\n  ASSERT (ub > 0);\n\n  TMP_MARK;\n  gmp_init_primesieve (&ps);\n  b = (f + 3) >> 1;\n\n  TMP_ALLOC_LIMBS_3 (ip, n, rp, n, tp, 5 * n);\n\n  MPN_ZERO (rp, n);\n\n  /* FIXME: It seems the inverse in ninv is needed only to get non-inverted\n     roots. I.e., is_kth_power computes n^{1/2} as (n^{-1})^{-1/2} and\n     similarly for nth roots. It should be more efficient to compute n^{1/2} as\n     n * n^{-1/2}, with a mullo instead of a binvert. And we can do something\n     similar for kth roots if we switch to an iteration converging to n^{1/k -\n     1}, and we can then eliminate this binvert call. */\n  mpn_binvert (ip, np, 1 + (b - 1) / GMP_LIMB_BITS, tp);\n  if (b % GMP_LIMB_BITS)\n    ip[(b - 1) / GMP_LIMB_BITS] &= (CNST_LIMB(1) << (b % GMP_LIMB_BITS)) - 1;\n\n  if (neg)\n    gmp_nextprime (&ps);\n\n  ans = 0;\n  if (g > 0)\n    {\n      ub = MIN (ub, g + 1);\n      while ((k = gmp_nextprime (&ps)) < ub)\n\t{\n\t  if ((g % k) == 0)\n\t    {\n\t      if (is_kth_power (rp, np, k, ip, n, f, tp) != 0)\n\t\t{\n\t\t  ans = 1;\n\t\t  goto ret;\n\t\t}\n\t    }\n\t}\n    }\n  else\n    {\n      while ((k = gmp_nextprime (&ps)) < ub)\n\t{\n\t  if (is_kth_power (rp, np, k, ip, n, f, tp) != 0)\n\t    {\n\t      ans = 1;\n\t      goto ret;\n\t    }\n\t}\n    }\n ret:\n  TMP_FREE;\n  return ans;\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpn_perfect_power_p": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "int\nmpn_perfect_power_p (mp_srcptr np, mp_size_t n)\n{\n  mp_limb_t *nc, factor, g;\n  mp_limb_t exp, d;\n  mp_bitcnt_t twos, count;\n  int ans, where, neg, trial;\n  TMP_DECL;\n\n  neg = n < 0;\n  if (neg)\n    {\n      n = -n;\n    }\n\n  if (n == 0 || (n == 1 && np[0] == 1)) /* Valgrind doesn't like\n\t\t\t\t\t   (n <= (np[0] == 1)) */\n    return 1;\n\n  TMP_MARK;\n\n  count = 0;\n\n  twos = mpn_scan1 (np, 0);\n  if (twos != 0)\n    {\n      mp_size_t s;\n      if (twos == 1)\n\t{\n\t  return 0;\n\t}\n      s = twos / GMP_LIMB_BITS;\n      if (s + 1 == n && POW2_P (np[s]))\n\t{\n\t  return ! (neg && POW2_P (twos));\n\t}\n      count = twos % GMP_LIMB_BITS;\n      n -= s;\n      np += s;\n      if (count > 0)\n\t{\n\t  nc = TMP_ALLOC_LIMBS (n);\n\t  mpn_rshift (nc, np, n, count);\n\t  n -= (nc[n - 1] == 0);\n\t  np = nc;\n\t}\n    }\n  g = twos;\n\n  trial = (n > SMALL) + (n > MEDIUM);\n\n  where = 0;\n  factor = mpn_trialdiv (np, n, nrtrial[trial], &where);\n\n  if (factor != 0)\n    {\n      if (count == 0) /* We did not allocate nc yet. */\n\t{\n\t  nc = TMP_ALLOC_LIMBS (n);\n\t}\n\n      /* Remove factors found by trialdiv.  Optimization: If remove\n\t define _itch, we can allocate its scratch just once */\n\n      do\n\t{\n\t  binvert_limb (d, factor);\n\n\t  /* After the first round we always have nc == np */\n\t  exp = mpn_remove (nc, &n, np, n, &d, 1, ~(mp_bitcnt_t)0);\n\n\t  if (g == 0)\n\t    g = exp;\n\t  else\n\t    g = mpn_gcd_1 (&g, 1, exp);\n\n\t  if (g == 1)\n\t    {\n\t      ans = 0;\n\t      goto ret;\n\t    }\n\n\t  if ((n == 1) & (nc[0] == 1))\n\t    {\n\t      ans = ! (neg && POW2_P (g));\n\t      goto ret;\n\t    }\n\n\t  np = nc;\n\t  factor = mpn_trialdiv (np, n, nrtrial[trial], &where);\n\t}\n      while (factor != 0);\n    }\n\n  MPN_SIZEINBASE_2EXP(count, np, n, 1);   /* log (np) + 1 */\n  d = (mp_limb_t) (count * logs[trial] + 1e-9) + 1;\n  ans = perfpow (np, n, d, g, count, neg);\n\n ret:\n  TMP_FREE;\n  return ans;\n}",
      "lines": 102,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/perfsqr.c": {
    "mpn_perfect_square_p": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "int\nmpn_perfect_square_p (mp_srcptr up, mp_size_t usize)\n{\n  ASSERT (usize >= 1);\n\n  TRACE (gmp_printf (\"mpn_perfect_square_p %Nd\\n\", up, usize));\n\n  /* The first test excludes 212/256 (82.8%) of the perfect square candidates\n     in O(1) time.  */\n  {\n    unsigned  idx = up[0] % 0x100;\n    if (((sq_res_0x100[idx / GMP_LIMB_BITS]\n\t  >> (idx % GMP_LIMB_BITS)) & 1) == 0)\n      return 0;\n  }\n\n#if 0\n  /* Check that we have even multiplicity of 2, and then check that the rest is\n     a possible perfect square.  Leave disabled until we can determine this\n     really is an improvement.  It it is, it could completely replace the\n     simple probe above, since this should throw out more non-squares, but at\n     the expense of somewhat more cycles.  */\n  {\n    mp_limb_t lo;\n    int cnt;\n    lo = up[0];\n    while (lo == 0)\n      up++, lo = up[0], usize--;\n    count_trailing_zeros (cnt, lo);\n    if ((cnt & 1) != 0)\n      return 0;\t\t\t/* return of not even multiplicity of 2 */\n    lo >>= cnt;\t\t\t/* shift down to align lowest non-zero bit */\n    lo >>= 1;\t\t\t/* shift away lowest non-zero bit */\n    if ((lo & 3) != 0)\n      return 0;\n  }\n#endif\n\n\n  /* The second test uses mpn_mod_34lsub1 or mpn_mod_1 to detect non-squares\n     according to their residues modulo small primes (or powers of\n     primes).  See perfsqr.h.  */\n  PERFSQR_MOD_TEST (up, usize);\n\n\n  /* For the third and last test, we finally compute the square root,\n     to make sure we've really got a perfect square.  */\n  {\n    mp_ptr root_ptr;\n    int res;\n    TMP_DECL;\n\n    TMP_MARK;\n    root_ptr = TMP_ALLOC_LIMBS ((usize + 1) / 2);\n\n    /* Iff mpn_sqrtrem returns zero, the square is perfect.  */\n    res = ! mpn_sqrtrem (root_ptr, NULL, up, usize);\n    TMP_FREE;\n\n    return res;\n  }\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/popham.c": {},
  "gmp/gmp-6.1.2/mpn/generic/powlo.c": {
    "getbits": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static inline mp_limb_t\ngetbits (const mp_limb_t *p, mp_bitcnt_t bi, int nbits)\n{\n  int nbits_in_r;\n  mp_limb_t r;\n  mp_size_t i;\n\n  if (bi < nbits)\n    {\n      return p[0] & (((mp_limb_t) 1 << bi) - 1);\n    }\n  else\n    {\n      bi -= nbits;\t\t\t/* bit index of low bit to extract */\n      i = bi / GMP_NUMB_BITS;\t\t/* word index of low bit to extract */\n      bi %= GMP_NUMB_BITS;\t\t/* bit index in low word */\n      r = p[i] >> bi;\t\t\t/* extract (low) bits */\n      nbits_in_r = GMP_NUMB_BITS - bi;\t/* number of bits now in r */\n      if (nbits_in_r < nbits)\t\t/* did we get enough bits? */\n\tr += p[i + 1] << nbits_in_r;\t/* prepend bits from higher word */\n      return r & (((mp_limb_t ) 1 << nbits) - 1);\n    }\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_limb_t"
      ]
    },
    "win_size": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static inline int\nwin_size (mp_bitcnt_t eb)\n{\n  int k;\n  static mp_bitcnt_t x[] = {1,7,25,81,241,673,1793,4609,11521,28161,~(mp_bitcnt_t)0};\n  ASSERT (eb > 1);\n  for (k = 1; eb > x[k]; ++k)\n    ;\n  return k;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "mpn_powlo": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "void\nmpn_powlo (mp_ptr rp, mp_srcptr bp,\n\t   mp_srcptr ep, mp_size_t en,\n\t   mp_size_t n, mp_ptr tp)\n{\n  int cnt;\n  mp_bitcnt_t ebi;\n  int windowsize, this_windowsize;\n  mp_limb_t expbits;\n  mp_limb_t *pp, *this_pp, *last_pp;\n  long i;\n  TMP_DECL;\n\n  ASSERT (en > 1 || (en == 1 && ep[0] > 1));\n\n  TMP_MARK;\n\n  MPN_SIZEINBASE_2EXP(ebi, ep, en, 1);\n\n  windowsize = win_size (ebi);\n  ASSERT (windowsize < ebi);\n\n  pp = TMP_ALLOC_LIMBS ((n << (windowsize - 1)));\n\n  this_pp = pp;\n\n  MPN_COPY (this_pp, bp, n);\n\n  /* Store b^2 in tp.  */\n  mpn_sqrlo (tp, bp, n);\n\n  /* Precompute odd powers of b and put them in the temporary area at pp.  */\n  for (i = (1 << (windowsize - 1)) - 1; i > 0; i--)\n    {\n      last_pp = this_pp;\n      this_pp += n;\n      mpn_mullo_n (this_pp, last_pp, tp, n);\n    }\n\n  expbits = getbits (ep, ebi, windowsize);\n\n  /* FIXME: for even expbits, we can init with a mullo. */\n  count_trailing_zeros (cnt, expbits);\n  ebi -= windowsize;\n  ebi += cnt;\n  expbits >>= cnt;\n\n  MPN_COPY (rp, pp + n * (expbits >> 1), n);\n\n  do\n    {\n      while (getbit (ep, ebi) == 0)\n\t{\n\t  mpn_sqrlo (tp, rp, n);\n\t  MPN_COPY (rp, tp, n);\n\t  if (--ebi == 0)\n\t    goto done;\n\t}\n\n      /* The next bit of the exponent is 1.  Now extract the largest block of\n\t bits <= windowsize, and such that the least significant bit is 1.  */\n\n      expbits = getbits (ep, ebi, windowsize);\n      this_windowsize = windowsize;\n      if (ebi < windowsize)\n\t{\n\t  this_windowsize -= windowsize - ebi;\n\t  ebi = 0;\n\t}\n      else\n\tebi -= windowsize;\n\n      count_trailing_zeros (cnt, expbits);\n      this_windowsize -= cnt;\n      ebi += cnt;\n      expbits >>= cnt;\n\n      while (this_windowsize > 1)\n\t{\n\t  mpn_sqrlo (tp, rp, n);\n\t  mpn_sqrlo (rp, tp, n);\n\t  this_windowsize -= 2;\n\t}\n\n      if (this_windowsize != 0)\n\tmpn_sqrlo (tp, rp, n);\n      else\n\tMPN_COPY (tp, rp, n);\n      \n      mpn_mullo_n (rp, tp, pp + n * (expbits >> 1), n);\n    } while (ebi != 0);\n\n done:\n  TMP_FREE;\n}",
      "lines": 95,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/powm.c": {
    "getbits": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static inline mp_limb_t\ngetbits (const mp_limb_t *p, mp_bitcnt_t bi, int nbits)\n{\n  int nbits_in_r;\n  mp_limb_t r;\n  mp_size_t i;\n\n  if (bi < nbits)\n    {\n      return p[0] & (((mp_limb_t) 1 << bi) - 1);\n    }\n  else\n    {\n      bi -= nbits;\t\t\t/* bit index of low bit to extract */\n      i = bi / GMP_NUMB_BITS;\t\t/* word index of low bit to extract */\n      bi %= GMP_NUMB_BITS;\t\t/* bit index in low word */\n      r = p[i] >> bi;\t\t\t/* extract (low) bits */\n      nbits_in_r = GMP_NUMB_BITS - bi;\t/* number of bits now in r */\n      if (nbits_in_r < nbits)\t\t/* did we get enough bits? */\n\tr += p[i + 1] << nbits_in_r;\t/* prepend bits from higher word */\n      return r & (((mp_limb_t ) 1 << nbits) - 1);\n    }\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_limb_t"
      ]
    },
    "win_size": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static inline int\nwin_size (mp_bitcnt_t eb)\n{\n  int k;\n  static mp_bitcnt_t x[] = {0,7,25,81,241,673,1793,4609,11521,28161,~(mp_bitcnt_t)0};\n  for (k = 1; eb > x[k]; k++)\n    ;\n  return k;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "redcify": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static void\nredcify (mp_ptr rp, mp_srcptr up, mp_size_t un, mp_srcptr mp, mp_size_t n)\n{\n  mp_ptr tp, qp;\n  TMP_DECL;\n  TMP_MARK;\n\n  TMP_ALLOC_LIMBS_2 (tp, un + n, qp, un + 1);\n\n  MPN_ZERO (tp, n);\n  MPN_COPY (tp + n, up, un);\n  mpn_tdiv_qr (qp, rp, 0L, tp, un + n, mp, n);\n  TMP_FREE;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_powm": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        230,
        5
      ],
      "content": "void\nmpn_powm (mp_ptr rp, mp_srcptr bp, mp_size_t bn,\n\t  mp_srcptr ep, mp_size_t en,\n\t  mp_srcptr mp, mp_size_t n, mp_ptr tp)\n{\n  mp_limb_t ip[2], *mip;\n  int cnt;\n  mp_bitcnt_t ebi;\n  int windowsize, this_windowsize;\n  mp_limb_t expbits;\n  mp_ptr pp, this_pp;\n  long i;\n  TMP_DECL;\n\n  ASSERT (en > 1 || (en == 1 && ep[0] > 1));\n  ASSERT (n >= 1 && ((mp[0] & 1) != 0));\n\n  TMP_MARK;\n\n  MPN_SIZEINBASE_2EXP(ebi, ep, en, 1);\n\n#if 0\n  if (bn < n)\n    {\n      /* Do the first few exponent bits without mod reductions,\n\t until the result is greater than the mod argument.  */\n      for (;;)\n\t{\n\t  mpn_sqr (tp, this_pp, tn);\n\t  tn = tn * 2 - 1,  tn += tp[tn] != 0;\n\t  if (getbit (ep, ebi) != 0)\n\t    mpn_mul (..., tp, tn, bp, bn);\n\t  ebi--;\n\t}\n    }\n#endif\n\n  windowsize = win_size (ebi);\n\n#if WANT_REDC_2\n  if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_2_THRESHOLD))\n    {\n      mip = ip;\n      binvert_limb (mip[0], mp[0]);\n      mip[0] = -mip[0];\n    }\n  else if (BELOW_THRESHOLD (n, REDC_2_TO_REDC_N_THRESHOLD))\n    {\n      mip = ip;\n      mpn_binvert (mip, mp, 2, tp);\n      mip[0] = -mip[0]; mip[1] = ~mip[1];\n    }\n#else\n  if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_N_THRESHOLD))\n    {\n      mip = ip;\n      binvert_limb (mip[0], mp[0]);\n      mip[0] = -mip[0];\n    }\n#endif\n  else\n    {\n      mip = TMP_ALLOC_LIMBS (n);\n      mpn_binvert (mip, mp, n, tp);\n    }",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/pow_1.c": {
    "mpn_pow_1": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "mp_size_t\nmpn_pow_1 (mp_ptr rp, mp_srcptr bp, mp_size_t bn, mp_limb_t exp, mp_ptr tp)\n{\n  mp_limb_t x;\n  int cnt, i;\n  mp_size_t rn;\n  int par;\n\n  ASSERT (bn >= 1);\n  /* FIXME: Add operand overlap criteria */\n\n  if (exp <= 1)\n    {\n      if (exp == 0)\n\t{\n\t  rp[0] = 1;\n\t  return 1;\n\t}\n      else\n\t{\n\t  MPN_COPY (rp, bp, bn);\n\t  return bn;\n\t}\n    }\n\n  /* Count number of bits in exp, and compute where to put initial square in\n     order to magically get results in the entry rp.  Use simple code,\n     optimized for small exp.  For large exp, the bignum operations will take\n     so much time that the slowness of this code will be negligible.  */\n  par = 0;\n  cnt = GMP_LIMB_BITS;\n  x = exp;\n  do\n    {\n      par ^= x;\n      cnt--;\n      x >>= 1;\n    } while (x != 0);\n  exp <<= cnt;\n\n  if (bn == 1)\n    {\n      mp_limb_t bl = bp[0];\n\n      if ((cnt & 1) != 0)\n\tMP_PTR_SWAP (rp, tp);\n\n      mpn_sqr (rp, bp, bn);\n      rn = 2 * bn; rn -= rp[rn - 1] == 0;\n\n      for (i = GMP_LIMB_BITS - cnt - 1;;)\n\t{\n\t  exp <<= 1;\n\t  if ((exp & GMP_LIMB_HIGHBIT) != 0)\n\t    {\n\t      rp[rn] = mpn_mul_1 (rp, rp, rn, bl);\n\t      rn += rp[rn] != 0;\n\t    }\n\n\t  if (--i == 0)\n\t    break;\n\n\t  mpn_sqr (tp, rp, rn);\n\t  rn = 2 * rn; rn -= tp[rn - 1] == 0;\n\t  MP_PTR_SWAP (rp, tp);\n\t}\n    }\n  else\n    {\n      if (((par ^ cnt) & 1) == 0)\n\tMP_PTR_SWAP (rp, tp);\n\n      mpn_sqr (rp, bp, bn);\n      rn = 2 * bn; rn -= rp[rn - 1] == 0;\n\n      for (i = GMP_LIMB_BITS - cnt - 1;;)\n\t{\n\t  exp <<= 1;\n\t  if ((exp & GMP_LIMB_HIGHBIT) != 0)\n\t    {\n\t      rn = rn + bn - (mpn_mul (tp, rp, rn, bp, bn) == 0);\n\t      MP_PTR_SWAP (rp, tp);\n\t    }\n\n\t  if (--i == 0)\n\t    break;\n\n\t  mpn_sqr (tp, rp, rn);\n\t  rn = 2 * rn; rn -= tp[rn - 1] == 0;\n\t  MP_PTR_SWAP (rp, tp);\n\t}\n    }\n\n  return rn;\n}",
      "lines": 95,
      "depth": 16,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/pre_divrem_1.c": {
    "mpn_preinv_divrem_1": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "mp_limb_t\nmpn_preinv_divrem_1 (mp_ptr qp, mp_size_t xsize,\n\t\t     mp_srcptr ap, mp_size_t size, mp_limb_t d_unnorm,\n\t\t     mp_limb_t dinv, int shift)\n{\n  mp_limb_t  ahigh, qhigh, r;\n  mp_size_t  i;\n  mp_limb_t  n1, n0;\n  mp_limb_t  d;\n\n  ASSERT (xsize >= 0);\n  ASSERT (size >= 1);\n  ASSERT (d_unnorm != 0);\n#if WANT_ASSERT\n  {\n    int        want_shift;\n    mp_limb_t  want_dinv;\n    count_leading_zeros (want_shift, d_unnorm);\n    ASSERT (shift == want_shift);\n    invert_limb (want_dinv, d_unnorm << shift);\n    ASSERT (dinv == want_dinv);\n  }\n#endif\n  /* FIXME: What's the correct overlap rule when xsize!=0? */\n  ASSERT (MPN_SAME_OR_SEPARATE_P (qp+xsize, ap, size));\n\n  ahigh = ap[size-1];\n  d = d_unnorm << shift;\n  qp += (size + xsize - 1);   /* dest high limb */\n\n  if (shift == 0)\n    {\n      /* High quotient limb is 0 or 1, and skip a divide step. */\n      r = ahigh;\n      qhigh = (r >= d);\n      r = (qhigh ? r-d : r);\n      *qp-- = qhigh;\n      size--;\n\n      for (i = size-1; i >= 0; i--)\n\t{\n\t  n0 = ap[i];\n\t  udiv_qrnnd_preinv (*qp, r, r, n0, d, dinv);\n\t  qp--;\n\t}\n    }\n  else\n    {\n      r = 0;\n      if (ahigh < d_unnorm)\n\t{\n\t  r = ahigh << shift;\n\t  *qp-- = 0;\n\t  size--;\n\t  if (size == 0)\n\t    goto done_integer;\n\t}\n\n      n1 = ap[size-1];\n      r |= n1 >> (GMP_LIMB_BITS - shift);\n\n      for (i = size-2; i >= 0; i--)\n\t{\n\t  ASSERT (r < d);\n\t  n0 = ap[i];\n\t  udiv_qrnnd_preinv (*qp, r, r,\n\t\t\t     ((n1 << shift) | (n0 >> (GMP_LIMB_BITS - shift))),\n\t\t\t     d, dinv);\n\t  qp--;\n\t  n1 = n0;\n\t}\n      udiv_qrnnd_preinv (*qp, r, r, n1 << shift, d, dinv);\n      qp--;\n    }\n\n done_integer:\n  for (i = 0; i < xsize; i++)\n    {\n      udiv_qrnnd_preinv (*qp, r, r, CNST_LIMB(0), d, dinv);\n      qp--;\n    }\n\n  return r >> shift;\n}",
      "lines": 84,
      "depth": 16,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/pre_mod_1.c": {
    "mpn_preinv_mod_1": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "mp_limb_t\nmpn_preinv_mod_1 (mp_srcptr up, mp_size_t un, mp_limb_t d, mp_limb_t dinv)\n{\n  mp_size_t i;\n  mp_limb_t n0, r;\n\n  ASSERT (un >= 1);\n  ASSERT (d & GMP_LIMB_HIGHBIT);\n\n  r = up[un - 1];\n  if (r >= d)\n    r -= d;\n\n  for (i = un - 2; i >= 0; i--)\n    {\n      n0 = up[i];\n      udiv_rnnd_preinv (r, r, n0, d, dinv);\n    }\n  return r;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/random.c": {
    "mpn_random": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\nmpn_random (mp_ptr ptr, mp_size_t size)\n{\n  gmp_randstate_ptr  rands;\n\n  /* FIXME: Is size==0 supposed to be allowed? */\n  ASSERT (size >= 0);\n\n  if (size == 0)\n    return;\n\n  rands = RANDS;\n  _gmp_rand (ptr, rands, size * GMP_NUMB_BITS);\n\n  /* Make sure the most significant limb is non-zero.  */\n  while (ptr[size-1] == 0)\n    _gmp_rand (&ptr[size-1], rands, GMP_NUMB_BITS);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/random2.c": {
    "mpn_random2": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "void\nmpn_random2 (mp_ptr rp, mp_size_t n)\n{\n  gmp_randstate_ptr rstate = RANDS;\n  int bit_pos;\t\t\t/* bit number of least significant bit where\n\t\t\t\t   next bit field to be inserted */\n  mp_limb_t ran, ranm;\t\t/* buffer for random bits */\n\n  /* FIXME: Is n==0 supposed to be allowed? */\n  ASSERT (n >= 0);\n\n  _gmp_rand (&ranm, rstate, BITS_PER_RANDCALL);\n  ran = ranm;\n\n  /* Start off at a random bit position in the most significant limb.  */\n  bit_pos = ran % GMP_NUMB_BITS;\n\n  gmp_rrandomb (rp, rstate, n * GMP_NUMB_BITS - bit_pos);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "gmp_rrandomb": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static void\ngmp_rrandomb (mp_ptr rp, gmp_randstate_t rstate, mp_bitcnt_t nbits)\n{\n  mp_bitcnt_t bi;\n  mp_limb_t ranm;\t\t/* buffer for random bits */\n  unsigned cap_chunksize, chunksize;\n  mp_size_t i;\n\n  /* Set entire result to 111..1  */\n  i = BITS_TO_LIMBS (nbits) - 1;\n  rp[i] = GMP_NUMB_MAX >> (GMP_NUMB_BITS - (nbits % GMP_NUMB_BITS)) % GMP_NUMB_BITS;\n  for (i = i - 1; i >= 0; i--)\n    rp[i] = GMP_NUMB_MAX;\n\n  _gmp_rand (&ranm, rstate, BITS_PER_RANDCALL);\n  cap_chunksize = nbits / (ranm % 4 + 1);\n  cap_chunksize += cap_chunksize == 0; /* make it at least 1 */\n\n  bi = nbits;\n\n  for (;;)\n    {\n      _gmp_rand (&ranm, rstate, BITS_PER_RANDCALL);\n      chunksize = 1 + ranm % cap_chunksize;\n      bi = (bi < chunksize) ? 0 : bi - chunksize;\n\n      if (bi == 0)\n\tbreak;\t\t\t/* low chunk is ...1 */\n\n      rp[bi / GMP_NUMB_BITS] ^= CNST_LIMB (1) << bi % GMP_NUMB_BITS;\n\n      _gmp_rand (&ranm, rstate, BITS_PER_RANDCALL);\n      chunksize = 1 + ranm % cap_chunksize;\n      bi = (bi < chunksize) ? 0 : bi - chunksize;\n\n      mpn_incr_u (rp + bi / GMP_NUMB_BITS, CNST_LIMB (1) << bi % GMP_NUMB_BITS);\n\n      if (bi == 0)\n\tbreak;\t\t\t/* low chunk is ...0 */\n    }\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/redc_1.c": {
    "mpn_redc_1": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "mp_limb_t\nmpn_redc_1 (mp_ptr rp, mp_ptr up, mp_srcptr mp, mp_size_t n, mp_limb_t invm)\n{\n  mp_size_t j;\n  mp_limb_t cy;\n\n  ASSERT (n > 0);\n  ASSERT_MPN (up, 2*n);\n\n  for (j = n - 1; j >= 0; j--)\n    {\n      cy = mpn_addmul_1 (up, mp, n, (up[0] * invm) & GMP_NUMB_MASK);\n      ASSERT (up[0] == 0);\n      up[0] = cy;\n      up++;\n    }\n\n  cy = mpn_add_n (rp, up, up - n, n);\n  return cy;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/redc_2.c": {
    "mpn_addmul_2": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static mp_limb_t\nmpn_addmul_2 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_srcptr vp)\n{\n  rp[n] = mpn_addmul_1 (rp, up, n, vp[0]);\n  return mpn_addmul_1 (rp + 1, up, n, vp[1]);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_redc_2": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "mp_limb_t\nmpn_redc_2 (mp_ptr rp, mp_ptr up, mp_srcptr mp, mp_size_t n, mp_srcptr mip)\n{\n  mp_limb_t q[2];\n  mp_size_t j;\n  mp_limb_t upn;\n  mp_limb_t cy;\n\n  ASSERT (n > 0);\n  ASSERT_MPN (up, 2*n);\n\n  if ((n & 1) != 0)\n    {\n      up[0] = mpn_addmul_1 (up, mp, n, (up[0] * mip[0]) & GMP_NUMB_MASK);\n      up++;\n    }\n\n  for (j = n - 2; j >= 0; j -= 2)\n    {\n      umul2low (q[1], q[0], mip[1], mip[0], up[1], up[0]);\n      upn = up[n];\t\t/* mpn_addmul_2 overwrites this */\n      up[1] = mpn_addmul_2 (up, mp, n, q);\n      up[0] = up[n];\n      up[n] = upn;\n      up += 2;\n    }\n\n  cy = mpn_add_n (rp, up, up - n, n);\n  return cy;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/redc_n.c": {
    "mpn_redc_n": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nmpn_redc_n (mp_ptr rp, mp_ptr up, mp_srcptr mp, mp_size_t n, mp_srcptr ip)\n{\n  mp_ptr xp, yp, scratch;\n  mp_limb_t cy;\n  mp_size_t rn;\n  TMP_DECL;\n  TMP_MARK;\n\n  ASSERT (n > 8);\n\n  rn = mpn_mulmod_bnm1_next_size (n);\n\n  scratch = TMP_ALLOC_LIMBS (n + rn + mpn_mulmod_bnm1_itch (rn, n, n));\n\n  xp = scratch;\n  mpn_mullo_n (xp, up, ip, n);\n\n  yp = scratch + n;\n  mpn_mulmod_bnm1 (yp, rn, xp, n, mp, n, scratch + n + rn);\n\n  ASSERT_ALWAYS (2 * n > rn);\t\t\t\t/* could handle this */\n\n  cy = mpn_sub_n (yp + rn, yp, up, 2*n - rn);\t\t/* undo wrap around */\n  MPN_DECR_U (yp + 2*n - rn, rn, cy);\n\n  cy = mpn_sub_n (rp, up + n, yp + n, n);\n  if (cy != 0)\n    mpn_add_n (rp, rp, mp, n);\n\n  TMP_FREE;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/remove.c": {
    "mpn_bdiv_qr_wrap": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static void\nmpn_bdiv_qr_wrap (mp_ptr qp, mp_ptr rp,\n\t\t  mp_srcptr np, mp_size_t nn,\n\t\t  mp_srcptr dp, mp_size_t dn)\n{\n  mp_ptr scratch_out;\n  TMP_DECL;\n\n  TMP_MARK;\n  scratch_out = TMP_ALLOC_LIMBS (mpn_bdiv_qr_itch (nn, dn));\n  mpn_bdiv_qr (qp, rp, np, nn, dp, dn, scratch_out);\n\n  TMP_FREE;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_remove": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "mp_bitcnt_t\nmpn_remove (mp_ptr wp, mp_size_t *wn,\n\t    mp_srcptr up, mp_size_t un, mp_srcptr vp, mp_size_t vn,\n\t    mp_bitcnt_t cap)\n{\n  mp_srcptr pwpsp[LOG];\n  mp_size_t pwpsn[LOG];\n  mp_size_t npowers;\n  mp_ptr tp, qp, np, qp2;\n  mp_srcptr pp;\n  mp_size_t pn, nn, qn, i;\n  mp_bitcnt_t pwr;\n  TMP_DECL;\n\n  ASSERT (un > 0);\n  ASSERT (vn > 0);\n  ASSERT (vp[0] % 2 != 0);\t/* 2-adic division wants odd numbers */\n  ASSERT (vn > 1 || vp[0] > 1);\t/* else we would loop indefinitely */\n\n  TMP_MARK;\n\n  TMP_ALLOC_LIMBS_3 (qp, un + 1,\t/* quotient, alternating */\n\t\t     qp2, un + 1,\t/* quotient, alternating */\n\t\t     tp, (un + 1 + vn) / 2); /* remainder */\n  pp = vp;\n  pn = vn;\n\n  MPN_COPY (qp, up, un);\n  qn = un;\n\n  npowers = 0;\n  while (qn >= pn)\n    {\n      qp[qn] = 0;\n      mpn_bdiv_qr_wrap (qp2, tp, qp, qn + 1, pp, pn);\n      if (!mpn_zero_p (tp, pn))\n\tbreak;\t\t\t/* could not divide by V^npowers */\n\n      MP_PTR_SWAP (qp, qp2);\n      qn = qn - pn;\n      qn += qp[qn] != 0;\n\n      pwpsp[npowers] = pp;\n      pwpsn[npowers] = pn;\n      ++npowers;\n\n      if (((mp_bitcnt_t) 2 << npowers) - 1 > cap)\n\tbreak;\n\n      nn = 2 * pn - 1;\t\t/* next power will be at least this large */\n      if (nn > qn)\n\tbreak;\t\t\t/* next power would be overlarge */\n\n      if (npowers == 1)\t\t/* Alloc once, but only if it's needed */\n\tnp = TMP_ALLOC_LIMBS (qn + LOG);\t/* powers of V */\n      else\n\tnp += pn;\n\n      mpn_sqr (np, pp, pn);\n      pn = nn + (np[nn] != 0);\n      pp = np;\n    }\n\n  pwr = ((mp_bitcnt_t) 1 << npowers) - 1;\n\n  for (i = npowers; --i >= 0;)\n    {\n      pn = pwpsn[i];\n      if (qn < pn)\n\tcontinue;\n\n      if (pwr + ((mp_bitcnt_t) 1 << i) > cap)\n\tcontinue;\t\t/* V^i would bring us past cap */\n\n      qp[qn] = 0;\n      mpn_bdiv_qr_wrap (qp2, tp, qp, qn + 1, pwpsp[i], pn);\n      if (!mpn_zero_p (tp, pn))\n\tcontinue;\t\t/* could not divide by V^i */\n\n      MP_PTR_SWAP (qp, qp2);\n      qn = qn - pn;\n      qn += qp[qn] != 0;\n\n      pwr += (mp_bitcnt_t) 1 << i;\n    }\n\n  MPN_COPY (wp, qp, qn);\n  *wn = qn;\n\n  TMP_FREE;\n\n  return pwr;\n}",
      "lines": 93,
      "depth": 13,
      "decorators": [
        "mp_bitcnt_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/rootrem.c": {
    "mpn_rootrem": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "mp_size_t\nmpn_rootrem (mp_ptr rootp, mp_ptr remp,\n\t     mp_srcptr up, mp_size_t un, mp_limb_t k)\n{\n  ASSERT (un > 0);\n  ASSERT (up[un - 1] != 0);\n  ASSERT (k > 1);\n\n  if (UNLIKELY (k == 2))\n    return mpn_sqrtrem (rootp, remp, up, un);\n  /* (un-1)/k > 2 <=> un > 3k <=> (un + 2)/3 > k */\n  if (remp == NULL && (un + 2) / 3 > k)\n    /* Pad {up,un} with k zero limbs.  This will produce an approximate root\n       with one more limb, allowing us to compute the exact integral result. */\n    {\n      mp_ptr sp, wp;\n      mp_size_t rn, sn, wn;\n      TMP_DECL;\n      TMP_MARK;\n      wn = un + k;\n      sn = (un - 1) / k + 2; /* ceil(un/k) + 1 */\n      TMP_ALLOC_LIMBS_2 (wp, wn, /* will contain the padded input */\n\t\t\t sp, sn); /* approximate root of padded input */\n      MPN_COPY (wp + k, up, un);\n      MPN_FILL (wp, k, 0);\n      rn = mpn_rootrem_internal (sp, NULL, wp, wn, k, 1);\n      /* The approximate root S = {sp,sn} is either the correct root of\n\t {sp,sn}, or 1 too large.  Thus unless the least significant limb of\n\t S is 0 or 1, we can deduce the root of {up,un} is S truncated by one\n\t limb.  (In case sp[0]=1, we can deduce the root, but not decide\n\t whether it is exact or not.) */\n      MPN_COPY (rootp, sp + 1, sn - 1);\n      TMP_FREE;\n      return rn;\n    }\n  else\n    {\n      return mpn_rootrem_internal (rootp, remp, up, un, k, 0);\n    }\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "mp_size_t"
      ]
    },
    "logbased_root": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "static unsigned\nlogbased_root (mp_ptr rootp, mp_limb_t op, mp_bitcnt_t bitn, mp_limb_t k)\n{\n  /* vlog=vector(256,i,floor((log(256+i)/log(2)-8)*256)-(i>255)) */\n  static const\n  unsigned char vlog[] = {1,   2,   4,   5,   7,   8,   9,  11,  12,  14,  15,  16,  18,  19,  21,  22,\n\t\t\t 23,  25,  26,  27,  29,  30,  31,  33,  34,  35,  37,  38,  39,  40,  42,  43,\n\t\t\t 44,  46,  47,  48,  49,  51,  52,  53,  54,  56,  57,  58,  59,  61,  62,  63,\n\t\t\t 64,  65,  67,  68,  69,  70,  71,  73,  74,  75,  76,  77,  78,  80,  81,  82,\n\t\t\t 83,  84,  85,  87,  88,  89,  90,  91,  92,  93,  94,  96,  97,  98,  99, 100,\n\t\t\t101, 102, 103, 104, 105, 106, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,\n\t\t\t118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 131, 132, 133, 134,\n\t\t\t135, 136, 137, 138, 139, 140, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,\n\t\t\t150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 162, 163, 164,\n\t\t\t165, 166, 167, 168, 169, 170, 171, 172, 173, 173, 174, 175, 176, 177, 178, 179,\n\t\t\t180, 181, 181, 182, 183, 184, 185, 186, 187, 188, 188, 189, 190, 191, 192, 193,\n\t\t\t194, 194, 195, 196, 197, 198, 199, 200, 200, 201, 202, 203, 204, 205, 205, 206,\n\t\t\t207, 208, 209, 209, 210, 211, 212, 213, 214, 214, 215, 216, 217, 218, 218, 219,\n\t\t\t220, 221, 222, 222, 223, 224, 225, 225, 226, 227, 228, 229, 229, 230, 231, 232,\n\t\t\t232, 233, 234, 235, 235, 236, 237, 238, 239, 239, 240, 241, 242, 242, 243, 244,\n\t\t\t245, 245, 246, 247, 247, 248, 249, 250, 250, 251, 252, 253, 253, 254, 255, 255};\n\n  /* vexp=vector(256,i,floor(2^(8+i/256)-256)-(i>255)) */\n  static const\n  unsigned char vexp[] = {0,   1,   2,   2,   3,   4,   4,   5,   6,   7,   7,   8,   9,   9,  10,  11,\n\t\t\t 12,  12,  13,  14,  14,  15,  16,  17,  17,  18,  19,  20,  20,  21,  22,  23,\n\t\t\t 23,  24,  25,  26,  26,  27,  28,  29,  30,  30,  31,  32,  33,  33,  34,  35,\n\t\t\t 36,  37,  37,  38,  39,  40,  41,  41,  42,  43,  44,  45,  45,  46,  47,  48,\n\t\t\t 49,  50,  50,  51,  52,  53,  54,  55,  55,  56,  57,  58,  59,  60,  61,  61,\n\t\t\t 62,  63,  64,  65,  66,  67,  67,  68,  69,  70,  71,  72,  73,  74,  75,  75,\n\t\t\t 76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,\n\t\t\t 91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,\n\t\t\t107, 108, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 122,\n\t\t\t123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,\n\t\t\t139, 140, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 154, 155, 156,\n\t\t\t157, 158, 159, 160, 161, 163, 164, 165, 166, 167, 168, 169, 171, 172, 173, 174,\n\t\t\t175, 176, 178, 179, 180, 181, 182, 183, 185, 186, 187, 188, 189, 191, 192, 193,\n\t\t\t194, 196, 197, 198, 199, 200, 202, 203, 204, 205, 207, 208, 209, 210, 212, 213,\n\t\t\t214, 216, 217, 218, 219, 221, 222, 223, 225, 226, 227, 229, 230, 231, 232, 234,\n\t\t\t235, 236, 238, 239, 240, 242, 243, 245, 246, 247, 249, 250, 251, 253, 254, 255};\n  mp_bitcnt_t retval;\n\n  if (UNLIKELY (bitn > (~ (mp_bitcnt_t) 0) >> LOGROOT_USED_BITS))\n    {\n      /* In the unlikely case, we use two divisions and a modulo. */\n      retval = bitn / k;\n      bitn %= k;\n      bitn = (bitn << LOGROOT_USED_BITS |\n\t      vlog[op >> (GMP_NUMB_BITS - LOGROOT_USED_BITS)]) / k;\n    }\n  else\n    {\n      bitn = (bitn << LOGROOT_USED_BITS |\n\t      vlog[op >> (GMP_NUMB_BITS - LOGROOT_USED_BITS)]) / k;\n      retval = bitn >> LOGROOT_USED_BITS;\n      bitn &= (CNST_LIMB (1) << LOGROOT_USED_BITS) - 1;\n    }\n  ASSERT(bitn < CNST_LIMB (1) << LOGROOT_USED_BITS);\n  *rootp = CNST_LIMB(1) << (LOGROOT_USED_BITS - ! LOGROOT_NEEDS_TWO_CORRECTIONS)\n    | vexp[bitn] >> ! LOGROOT_NEEDS_TWO_CORRECTIONS;\n  return retval;\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "mpn_rootrem_internal": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "static mp_size_t\nmpn_rootrem_internal (mp_ptr rootp, mp_ptr remp, mp_srcptr up, mp_size_t un,\n\t\t      mp_limb_t k, int approx)\n{\n  mp_ptr qp, rp, sp, wp, scratch;\n  mp_size_t qn, rn, sn, wn, nl, bn;\n  mp_limb_t save, save2, cy, uh;\n  mp_bitcnt_t unb; /* number of significant bits of {up,un} */\n  mp_bitcnt_t xnb; /* number of significant bits of the result */\n  mp_bitcnt_t b, kk;\n  mp_bitcnt_t sizes[GMP_NUMB_BITS + 1];\n  int ni;\n  int perf_pow;\n  unsigned ulz, snb, c, logk;\n  TMP_DECL;\n\n  /* MPN_SIZEINBASE_2EXP(unb, up, un, 1); --unb; */\n  uh = up[un - 1];\n  count_leading_zeros (ulz, uh);\n  ulz = ulz - GMP_NAIL_BITS + 1; /* Ignore the first 1. */\n  unb = (mp_bitcnt_t) un * GMP_NUMB_BITS - ulz;\n  /* unb is the (truncated) logarithm of the input U in base 2*/\n\n  if (unb < k) /* root is 1 */\n    {\n      rootp[0] = 1;\n      if (remp == NULL)\n\tun -= (*up == CNST_LIMB (1)); /* Non-zero iif {up,un} > 1 */\n      else\n\t{\n\t  mpn_sub_1 (remp, up, un, CNST_LIMB (1));\n\t  un -= (remp [un - 1] == 0);\t/* There should be at most one zero limb,\n\t\t\t\t   if we demand u to be normalized  */\n\t}\n      return un;\n    }\n  /* if (unb - k < k/2 + k/16) // root is 2 */\n\n  if (ulz == GMP_NUMB_BITS)\n    uh = up[un - 2];\n  else\n    uh = (uh << ulz & GMP_NUMB_MASK) | up[un - 1 - (un != 1)] >> (GMP_NUMB_BITS - ulz);\n  ASSERT (un != 1 || up[un - 1 - (un != 1)] >> (GMP_NUMB_BITS - ulz) == 1);\n\n  xnb = logbased_root (rootp, uh, unb, k);\n  snb = LOGROOT_RETURNED_BITS - 1;\n  /* xnb+1 is the number of bits of the root R */\n  /* snb+1 is the number of bits of the current approximation S */\n\n  kk = k * xnb;\t\t/* number of truncated bits in the input */\n\n  /* FIXME: Should we skip the next two loops when xnb <= snb ? */\n  for (uh = (k - 1) / 2, logk = 3; (uh >>= 1) != 0; ++logk )\n    ;\n  /* logk = ceil(log(k)/log(2)) + 1 */\n\n  /* xnb is the number of remaining bits to determine in the kth root */\n  for (ni = 0; (sizes[ni] = xnb) > snb; ++ni)\n    {\n      /* invariant: here we want xnb+1 total bits for the kth root */\n\n      /* if c is the new value of xnb, this means that we'll go from a\n\t root of c+1 bits (say s') to a root of xnb+1 bits.\n\t It is proved in the book \"Modern Computer Arithmetic\" by Brent\n\t and Zimmermann, Chapter 1, that\n\t if s' >= k*beta, then at most one correction is necessary.\n\t Here beta = 2^(xnb-c), and s' >= 2^c, thus it suffices that\n\t c >= ceil((xnb + log2(k))/2). */\n      if (xnb > logk)\n\txnb = (xnb + logk) / 2;\n      else\n\t--xnb;\t/* add just one bit at a time */\n    }\n\n  *rootp >>= snb - xnb;\n  kk -= xnb;\n\n  ASSERT_ALWAYS (ni < GMP_NUMB_BITS + 1);\n  /* We have sizes[0] = b > sizes[1] > ... > sizes[ni] = 0 with\n     sizes[i] <= 2 * sizes[i+1].\n     Newton iteration will first compute sizes[ni-1] extra bits,\n     then sizes[ni-2], ..., then sizes[0] = b. */\n\n  TMP_MARK;\n  /* qp and wp need enough space to store S'^k where S' is an approximate\n     root. Since S' can be as large as S+2, the worst case is when S=2 and\n     S'=4. But then since we know the number of bits of S in advance, S'\n     can only be 3 at most. Similarly for S=4, then S' can be 6 at most.\n     So the worst case is S'/S=3/2, thus S'^k <= (3/2)^k * S^k. Since S^k\n     fits in un limbs, the number of extra limbs needed is bounded by\n     ceil(k*log2(3/2)/GMP_NUMB_BITS). */\n  /* THINK: with the use of logbased_root, maybe the constant is\n     258/256 instead of 3/2 ? log2(258/256) < 1/89 < 1/64 */\n#define EXTRA 2 + (mp_size_t) (0.585 * (double) k / (double) GMP_NUMB_BITS)\n  TMP_ALLOC_LIMBS_3 (scratch, un + 1, /* used by mpn_div_q */\n\t\t     qp, un + EXTRA,  /* will contain quotient and remainder\n\t\t\t\t\t of R/(k*S^(k-1)), and S^k */\n\t\t     wp, un + EXTRA); /* will contain S^(k-1), k*S^(k-1),\n\t\t\t\t\t and temporary for mpn_pow_1 */\n\n  if (remp == NULL)\n    rp = scratch;\t/* will contain the remainder */\n  else\n    rp = remp;\n  sp = rootp;\n\n  sn = 1;\t\t/* Initial approximation has one limb */\n\n  for (b = xnb; ni != 0; --ni)\n    {\n      /* 1: loop invariant:\n\t {sp, sn} is the current approximation of the root, which has\n\t\t  exactly 1 + sizes[ni] bits.\n\t {rp, rn} is the current remainder\n\t {wp, wn} = {sp, sn}^(k-1)\n\t kk = number of truncated bits of the input\n      */\n\n      /* Since each iteration treats b bits from the root and thus k*b bits\n\t from the input, and we already considered b bits from the input,\n\t we now have to take another (k-1)*b bits from the input. */\n      kk -= (k - 1) * b; /* remaining input bits */\n      /* {rp, rn} = floor({up, un} / 2^kk) */\n      rn = un - kk / GMP_NUMB_BITS;\n      MPN_RSHIFT (rp, up + kk / GMP_NUMB_BITS, rn, kk % GMP_NUMB_BITS);\n      rn -= rp[rn - 1] == 0;\n\n      /* 9: current buffers: {sp,sn}, {rp,rn} */\n\n      for (c = 0;; c++)\n\t{\n\t  /* Compute S^k in {qp,qn}. */\n\t  /* W <- S^(k-1) for the next iteration,\n\t     and S^k = W * S. */\n\t  wn = mpn_pow_1 (wp, sp, sn, k - 1, qp);\n\t  mpn_mul (qp, wp, wn, sp, sn);\n\t  qn = wn + sn;\n\t  qn -= qp[qn - 1] == 0;\n\n\t  perf_pow = 1;\n\t  /* if S^k > floor(U/2^kk), the root approximation was too large */\n\t  if (qn > rn || (qn == rn && (perf_pow=mpn_cmp (qp, rp, rn)) > 0))\n\t    MPN_DECR_U (sp, sn, 1);\n\t  else\n\t    break;\n\t}\n\n      /* 10: current buffers: {sp,sn}, {rp,rn}, {qp,qn}, {wp,wn} */\n\n      /* sometimes two corrections are needed with logbased_root*/\n      ASSERT (c <= 1 + LOGROOT_NEEDS_TWO_CORRECTIONS);\n      ASSERT_ALWAYS (rn >= qn);\n\n      b = sizes[ni - 1] - sizes[ni]; /* number of bits to compute in the\n\t\t\t\t      next iteration */\n      bn = b / GMP_NUMB_BITS; /* lowest limb from high part of rp[], after shift */\n\n      kk = kk - b;\n      /* nl is the number of limbs in U which contain bits [kk,kk+b-1] */\n      nl = 1 + (kk + b - 1) / GMP_NUMB_BITS - (kk / GMP_NUMB_BITS);\n      /* nl  = 1 + floor((kk + b - 1) / GMP_NUMB_BITS)\n\t\t - floor(kk / GMP_NUMB_BITS)\n\t     <= 1 + (kk + b - 1) / GMP_NUMB_BITS\n\t\t  - (kk - GMP_NUMB_BITS + 1) / GMP_NUMB_BITS\n\t     = 2 + (b - 2) / GMP_NUMB_BITS\n\t thus since nl is an integer:\n\t nl <= 2 + floor(b/GMP_NUMB_BITS) <= 2 + bn. */\n\n      /* 11: current buffers: {sp,sn}, {rp,rn}, {wp,wn} */\n\n      /* R = R - Q = floor(U/2^kk) - S^k */\n      if (perf_pow != 0)\n\t{\n\t  mpn_sub (rp, rp, rn, qp, qn);\n\t  MPN_NORMALIZE_NOT_ZERO (rp, rn);\n\n\t  /* first multiply the remainder by 2^b */\n\t  MPN_LSHIFT (cy, rp + bn, rp, rn, b % GMP_NUMB_BITS);\n\t  rn = rn + bn;\n\t  if (cy != 0)\n\t    {\n\t      rp[rn] = cy;\n\t      rn++;\n\t    }\n\n\t  save = rp[bn];\n\t  /* we have to save rp[bn] up to rp[nl-1], i.e. 1 or 2 limbs */\n\t  if (nl - 1 > bn)\n\t    save2 = rp[bn + 1];\n\t}\n      else\n\t{\n\t  rn = bn;\n\t  save2 = save = 0;\n\t}\n      /* 2: current buffers: {sp,sn}, {rp,rn}, {wp,wn} */\n\n      /* Now insert bits [kk,kk+b-1] from the input U */\n      MPN_RSHIFT (rp, up + kk / GMP_NUMB_BITS, nl, kk % GMP_NUMB_BITS);\n      /* set to zero high bits of rp[bn] */\n      rp[bn] &= (CNST_LIMB (1) << (b % GMP_NUMB_BITS)) - 1;\n      /* restore corresponding bits */\n      rp[bn] |= save;\n      if (nl - 1 > bn)\n\trp[bn + 1] = save2; /* the low b bits go in rp[0..bn] only, since\n\t\t\t       they start by bit 0 in rp[0], so they use\n\t\t\t       at most ceil(b/GMP_NUMB_BITS) limbs */\n      /* FIXME: Should we normalise {rp,rn} here ?*/\n\n      /* 3: current buffers: {sp,sn}, {rp,rn}, {wp,wn} */\n\n      /* compute {wp, wn} = k * {sp, sn}^(k-1) */\n      cy = mpn_mul_1 (wp, wp, wn, k);\n      wp[wn] = cy;\n      wn += cy != 0;\n\n      /* 6: current buffers: {sp,sn}, {qp,qn} */\n\n      /* multiply the root approximation by 2^b */\n      MPN_LSHIFT (cy, sp + b / GMP_NUMB_BITS, sp, sn, b % GMP_NUMB_BITS);\n      sn = sn + b / GMP_NUMB_BITS;\n      if (cy != 0)\n\t{\n\t  sp[sn] = cy;\n\t  sn++;\n\t}\n\n      save = sp[b / GMP_NUMB_BITS];\n\n      /* Number of limbs used by b bits, when least significant bit is\n\t aligned to least limb */\n      bn = (b - 1) / GMP_NUMB_BITS + 1;\n\n      /* 4: current buffers: {sp,sn}, {rp,rn}, {wp,wn} */\n\n      /* now divide {rp, rn} by {wp, wn} to get the low part of the root */\n      if (UNLIKELY (rn < wn))\n\t{\n\t  MPN_FILL (sp, bn, 0);\n\t}\n      else\n\t{\n\t  qn = rn - wn; /* expected quotient size */\n\t  if (qn <= bn) { /* Divide only if result is not too big. */\n\t    mpn_div_q (qp, rp, rn, wp, wn, scratch);\n\t    qn += qp[qn] != 0;\n\t  }\n\n      /* 5: current buffers: {sp,sn}, {qp,qn}.\n\t Note: {rp,rn} is not needed any more since we'll compute it from\n\t scratch at the end of the loop.\n       */\n\n      /* the quotient should be smaller than 2^b, since the previous\n\t approximation was correctly rounded toward zero */\n\t  if (qn > bn || (qn == bn && (b % GMP_NUMB_BITS != 0) &&\n\t\t\t  qp[qn - 1] >= (CNST_LIMB (1) << (b % GMP_NUMB_BITS))))\n\t    {\n\t      for (qn = 1; qn < bn; ++qn)\n\t\tsp[qn - 1] = GMP_NUMB_MAX;\n\t      sp[qn - 1] = GMP_NUMB_MAX >> (GMP_NUMB_BITS - 1 - ((b - 1) % GMP_NUMB_BITS));\n\t    }\n\t  else\n\t    {\n      /* 7: current buffers: {sp,sn}, {qp,qn} */\n\n      /* Combine sB and q to form sB + q.  */\n\t      MPN_COPY (sp, qp, qn);\n\t      MPN_ZERO (sp + qn, bn - qn);\n\t    }\n\t}\n      sp[b / GMP_NUMB_BITS] |= save;\n\n      /* 8: current buffer: {sp,sn} */\n\n    };\n\n  /* otherwise we have rn > 0, thus the return value is ok */\n  if (!approx || sp[0] <= CNST_LIMB (1))\n    {\n      for (c = 0;; c++)\n\t{\n\t  /* Compute S^k in {qp,qn}. */\n\t  /* Last iteration: we don't need W anymore. */\n\t  /* mpn_pow_1 requires that both qp and wp have enough\n\t     space to store the result {sp,sn}^k + 1 limb */\n\t  qn = mpn_pow_1 (qp, sp, sn, k, wp);\n\n\t  perf_pow = 1;\n\t  if (qn > un || (qn == un && (perf_pow=mpn_cmp (qp, up, un)) > 0))\n\t    MPN_DECR_U (sp, sn, 1);\n\t  else\n\t    break;\n\t};\n\n      /* sometimes two corrections are needed with logbased_root*/\n      ASSERT (c <= 1 + LOGROOT_NEEDS_TWO_CORRECTIONS);\n\n      rn = perf_pow != 0;\n      if (rn != 0 && remp != NULL)\n\t{\n\t  mpn_sub (remp, up, un, qp, qn);\n\t  rn = un;\n\t  MPN_NORMALIZE_NOT_ZERO (remp, rn);\n\t}\n    }\n\n  TMP_FREE;\n  return rn;\n}",
      "lines": 310,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/rshift.c": {
    "mpn_rshift": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "mp_limb_t\nmpn_rshift (mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)\n{\n  mp_limb_t high_limb, low_limb;\n  unsigned int tnc;\n  mp_size_t i;\n  mp_limb_t retval;\n\n  ASSERT (n >= 1);\n  ASSERT (cnt >= 1);\n  ASSERT (cnt < GMP_NUMB_BITS);\n  ASSERT (MPN_SAME_OR_INCR_P (rp, up, n));\n\n  tnc = GMP_NUMB_BITS - cnt;\n  high_limb = *up++;\n  retval = (high_limb << tnc) & GMP_NUMB_MASK;\n  low_limb = high_limb >> cnt;\n\n  for (i = n - 1; i != 0; i--)\n    {\n      high_limb = *up++;\n      *rp++ = low_limb | ((high_limb << tnc) & GMP_NUMB_MASK);\n      low_limb = high_limb >> cnt;\n    }\n  *rp = low_limb;\n\n  return retval;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sbpi1_bdiv_q.c": {
    "mpn_sbpi1_bdiv_q": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\nmpn_sbpi1_bdiv_q (mp_ptr qp,\n\t\t  mp_ptr np, mp_size_t nn,\n\t\t  mp_srcptr dp, mp_size_t dn,\n\t\t  mp_limb_t dinv)\n{\n  mp_size_t i;\n  mp_limb_t cy, q;\n\n  ASSERT (dn > 0);\n  ASSERT (nn >= dn);\n  ASSERT ((dp[0] & 1) != 0);\n  /* FIXME: Add ASSERTs for allowable overlapping; i.e., that qp = np is OK,\n     but some over N/Q overlaps will not work.  */\n\n  for (i = nn - dn; i > 0; i--)\n    {\n      q = dinv * np[0];\n      cy = mpn_addmul_1 (np, dp, dn, q);\n      mpn_add_1 (np + dn, np + dn, i, cy);\n      ASSERT (np[0] == 0);\n      qp[0] = ~q;\n      qp++;\n      np++;\n    }\n\n  for (i = dn; i > 1; i--)\n    {\n      q = dinv * np[0];\n      mpn_addmul_1 (np, dp, i, q);\n      ASSERT (np[0] == 0);\n      qp[0] = ~q;\n      qp++;\n      np++;\n    }\n\n  /* Final limb */\n  q = dinv * np[0];\n  qp[0] = ~q;\n  mpn_add_1 (qp - nn + 1, qp - nn + 1, nn, 1);\n}",
      "lines": 41,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sbpi1_bdiv_qr.c": {
    "mpn_sbpi1_bdiv_qr": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "mp_limb_t\nmpn_sbpi1_bdiv_qr (mp_ptr qp,\n\t\t   mp_ptr np, mp_size_t nn,\n\t\t   mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)\n{\n  mp_size_t qn;\n  mp_size_t i;\n  mp_limb_t rh;\n  mp_limb_t ql;\n\n  ASSERT (dn > 0);\n  ASSERT (nn > dn);\n  ASSERT ((dp[0] & 1) != 0);\n  /* FIXME: Add ASSERTs for allowable overlapping; i.e., that qp = np is OK,\n     but some over N/Q overlaps will not work.  */\n\n  qn = nn - dn;\n\n  rh = 0;\n\n  /* To complete the negation, this value is added to q. */\n  ql = 1;\n  while (qn > dn)\n    {\n      for (i = 0; i < dn; i++)\n\t{\n\t  mp_limb_t q;\n\n\t  q = dinv * np[i];\n\t  np[i] = mpn_addmul_1 (np + i, dp, dn, q);\n\t  qp[i] = ~q;\n\t}\n      rh += mpn_add (np + dn, np + dn, qn, np, dn);\n      ql = mpn_add_1 (qp, qp, dn, ql);\n\n      qp += dn; qn -= dn;\n      np += dn; nn -= dn;\n    }\n\n  for (i = 0; i < qn; i++)\n    {\n      mp_limb_t q;\n\n      q = dinv * np[i];\n      np[i] = mpn_addmul_1 (np + i, dp, dn, q);\n      qp[i] = ~q;\n    }\n\n  rh += mpn_add_n (np + dn, np + dn, np, qn);\n  ql = mpn_add_1 (qp, qp, qn, ql);\n\n  if (UNLIKELY (ql > 0))\n    {\n      /* q == 0 */\n      ASSERT (rh == 0);\n      return 0;\n    }\n  else\n    {\n      mp_limb_t cy;\n\n      cy = mpn_sub_n (np + qn, np + qn, dp, dn);\n      ASSERT (cy >= rh);\n      return cy - rh;\n    }\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sbpi1_divappr_q.c": {
    "mpn_sbpi1_divappr_q": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "mp_limb_t\nmpn_sbpi1_divappr_q (mp_ptr qp,\n\t\t     mp_ptr np, mp_size_t nn,\n\t\t     mp_srcptr dp, mp_size_t dn,\n\t\t     mp_limb_t dinv)\n{\n  mp_limb_t qh;\n  mp_size_t qn, i;\n  mp_limb_t n1, n0;\n  mp_limb_t d1, d0;\n  mp_limb_t cy, cy1;\n  mp_limb_t q;\n  mp_limb_t flag;\n\n  ASSERT (dn > 2);\n  ASSERT (nn >= dn);\n  ASSERT ((dp[dn-1] & GMP_NUMB_HIGHBIT) != 0);\n\n  np += nn;\n\n  qn = nn - dn;\n  if (qn + 1 < dn)\n    {\n      dp += dn - (qn + 1);\n      dn = qn + 1;\n    }\n\n  qh = mpn_cmp (np - dn, dp, dn) >= 0;\n  if (qh != 0)\n    mpn_sub_n (np - dn, np - dn, dp, dn);\n\n  qp += qn;\n\n  dn -= 2;\t\t\t/* offset dn by 2 for main division loops,\n\t\t\t\t   saving two iterations in mpn_submul_1.  */\n  d1 = dp[dn + 1];\n  d0 = dp[dn + 0];\n\n  np -= 2;\n\n  n1 = np[1];\n\n  for (i = qn - (dn + 2); i >= 0; i--)\n    {\n      np--;\n      if (UNLIKELY (n1 == d1) && np[1] == d0)\n\t{\n\t  q = GMP_NUMB_MASK;\n\t  mpn_submul_1 (np - dn, dp, dn + 2, q);\n\t  n1 = np[1];\t\t/* update n1, last loop's value will now be invalid */\n\t}\n      else\n\t{\n\t  udiv_qr_3by2 (q, n1, n0, n1, np[1], np[0], d1, d0, dinv);\n\n\t  cy = mpn_submul_1 (np - dn, dp, dn, q);\n\n\t  cy1 = n0 < cy;\n\t  n0 = (n0 - cy) & GMP_NUMB_MASK;\n\t  cy = n1 < cy1;\n\t  n1 -= cy1;\n\t  np[0] = n0;\n\n\t  if (UNLIKELY (cy != 0))\n\t    {\n\t      n1 += d1 + mpn_add_n (np - dn, np - dn, dp, dn + 1);\n\t      q--;\n\t    }\n\t}\n\n      *--qp = q;\n    }\n\n  flag = ~CNST_LIMB(0);\n\n  if (dn >= 0)\n    {\n      for (i = dn; i > 0; i--)\n\t{\n\t  np--;\n\t  if (UNLIKELY (n1 >= (d1 & flag)))\n\t    {\n\t      q = GMP_NUMB_MASK;\n\t      cy = mpn_submul_1 (np - dn, dp, dn + 2, q);\n\n\t      if (UNLIKELY (n1 != cy))\n\t\t{\n\t\t  if (n1 < (cy & flag))\n\t\t    {\n\t\t      q--;\n\t\t      mpn_add_n (np - dn, np - dn, dp, dn + 2);\n\t\t    }\n\t\t  else\n\t\t    flag = 0;\n\t\t}\n\t      n1 = np[1];\n\t    }\n\t  else\n\t    {\n\t      udiv_qr_3by2 (q, n1, n0, n1, np[1], np[0], d1, d0, dinv);\n\n\t      cy = mpn_submul_1 (np - dn, dp, dn, q);\n\n\t      cy1 = n0 < cy;\n\t      n0 = (n0 - cy) & GMP_NUMB_MASK;\n\t      cy = n1 < cy1;\n\t      n1 -= cy1;\n\t      np[0] = n0;\n\n\t      if (UNLIKELY (cy != 0))\n\t\t{\n\t\t  n1 += d1 + mpn_add_n (np - dn, np - dn, dp, dn + 1);\n\t\t  q--;\n\t\t}\n\t    }\n\n\t  *--qp = q;\n\n\t  /* Truncate operands.  */\n\t  dn--;\n\t  dp++;\n\t}\n\n      np--;\n      if (UNLIKELY (n1 >= (d1 & flag)))\n\t{\n\t  q = GMP_NUMB_MASK;\n\t  cy = mpn_submul_1 (np, dp, 2, q);\n\n\t  if (UNLIKELY (n1 != cy))\n\t    {\n\t      if (n1 < (cy & flag))\n\t\t{\n\t\t  q--;\n\t\t  add_ssaaaa (np[1], np[0], np[1], np[0], dp[1], dp[0]);\n\t\t}\n\t      else\n\t\tflag = 0;\n\t    }\n\t  n1 = np[1];\n\t}\n      else\n\t{\n\t  udiv_qr_3by2 (q, n1, n0, n1, np[1], np[0], d1, d0, dinv);\n\n\t  np[1] = n1;\n\t  np[0] = n0;\n\t}\n\n      *--qp = q;\n    }\n\n  ASSERT_ALWAYS (np[1] == n1);\n\n  return qh;\n}",
      "lines": 156,
      "depth": 17,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sbpi1_div_q.c": {
    "mpn_sbpi1_div_q": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "mp_limb_t\nmpn_sbpi1_div_q (mp_ptr qp,\n\t\t mp_ptr np, mp_size_t nn,\n\t\t mp_srcptr dp, mp_size_t dn,\n\t\t mp_limb_t dinv)\n{\n  mp_limb_t qh;\n  mp_size_t qn, i;\n  mp_limb_t n1, n0;\n  mp_limb_t d1, d0;\n  mp_limb_t cy, cy1;\n  mp_limb_t q;\n  mp_limb_t flag;\n\n  mp_size_t dn_orig = dn;\n  mp_srcptr dp_orig = dp;\n  mp_ptr np_orig = np;\n\n  ASSERT (dn > 2);\n  ASSERT (nn >= dn);\n  ASSERT ((dp[dn-1] & GMP_NUMB_HIGHBIT) != 0);\n\n  np += nn;\n\n  qn = nn - dn;\n  if (qn + 1 < dn)\n    {\n      dp += dn - (qn + 1);\n      dn = qn + 1;\n    }\n\n  qh = mpn_cmp (np - dn, dp, dn) >= 0;\n  if (qh != 0)\n    mpn_sub_n (np - dn, np - dn, dp, dn);\n\n  qp += qn;\n\n  dn -= 2;\t\t\t/* offset dn by 2 for main division loops,\n\t\t\t\t   saving two iterations in mpn_submul_1.  */\n  d1 = dp[dn + 1];\n  d0 = dp[dn + 0];\n\n  np -= 2;\n\n  n1 = np[1];\n\n  for (i = qn - (dn + 2); i >= 0; i--)\n    {\n      np--;\n      if (UNLIKELY (n1 == d1) && np[1] == d0)\n\t{\n\t  q = GMP_NUMB_MASK;\n\t  mpn_submul_1 (np - dn, dp, dn + 2, q);\n\t  n1 = np[1];\t\t/* update n1, last loop's value will now be invalid */\n\t}\n      else\n\t{\n\t  udiv_qr_3by2 (q, n1, n0, n1, np[1], np[0], d1, d0, dinv);\n\n\t  cy = mpn_submul_1 (np - dn, dp, dn, q);\n\n\t  cy1 = n0 < cy;\n\t  n0 = (n0 - cy) & GMP_NUMB_MASK;\n\t  cy = n1 < cy1;\n\t  n1 -= cy1;\n\t  np[0] = n0;\n\n\t  if (UNLIKELY (cy != 0))\n\t    {\n\t      n1 += d1 + mpn_add_n (np - dn, np - dn, dp, dn + 1);\n\t      q--;\n\t    }\n\t}\n\n      *--qp = q;\n    }\n\n  flag = ~CNST_LIMB(0);\n\n  if (dn >= 0)\n    {\n      for (i = dn; i > 0; i--)\n\t{\n\t  np--;\n\t  if (UNLIKELY (n1 >= (d1 & flag)))\n\t    {\n\t      q = GMP_NUMB_MASK;\n\t      cy = mpn_submul_1 (np - dn, dp, dn + 2, q);\n\n\t      if (UNLIKELY (n1 != cy))\n\t\t{\n\t\t  if (n1 < (cy & flag))\n\t\t    {\n\t\t      q--;\n\t\t      mpn_add_n (np - dn, np - dn, dp, dn + 2);\n\t\t    }\n\t\t  else\n\t\t    flag = 0;\n\t\t}\n\t      n1 = np[1];\n\t    }\n\t  else\n\t    {\n\t      udiv_qr_3by2 (q, n1, n0, n1, np[1], np[0], d1, d0, dinv);\n\n\t      cy = mpn_submul_1 (np - dn, dp, dn, q);\n\n\t      cy1 = n0 < cy;\n\t      n0 = (n0 - cy) & GMP_NUMB_MASK;\n\t      cy = n1 < cy1;\n\t      n1 -= cy1;\n\t      np[0] = n0;\n\n\t      if (UNLIKELY (cy != 0))\n\t\t{\n\t\t  n1 += d1 + mpn_add_n (np - dn, np - dn, dp, dn + 1);\n\t\t  q--;\n\t\t}\n\t    }\n\n\t  *--qp = q;\n\n\t  /* Truncate operands.  */\n\t  dn--;\n\t  dp++;\n\t}\n\n      np--;\n      if (UNLIKELY (n1 >= (d1 & flag)))\n\t{\n\t  q = GMP_NUMB_MASK;\n\t  cy = mpn_submul_1 (np, dp, 2, q);\n\n\t  if (UNLIKELY (n1 != cy))\n\t    {\n\t      if (n1 < (cy & flag))\n\t\t{\n\t\t  q--;\n\t\t  add_ssaaaa (np[1], np[0], np[1], np[0], dp[1], dp[0]);\n\t\t}\n\t      else\n\t\tflag = 0;\n\t    }\n\t  n1 = np[1];\n\t}\n      else\n\t{\n\t  udiv_qr_3by2 (q, n1, n0, n1, np[1], np[0], d1, d0, dinv);\n\n\t  np[0] = n0;\n\t  np[1] = n1;\n\t}\n\n      *--qp = q;\n    }\n  ASSERT_ALWAYS (np[1] == n1);\n  np += 2;\n\n\n  dn = dn_orig;\n  if (UNLIKELY (n1 < (dn & flag)))\n    {\n      mp_limb_t q, x;\n\n      /* The quotient may be too large if the remainder is small.  Recompute\n\t for above ignored operand parts, until the remainder spills.\n\n\t FIXME: The quality of this code isn't the same as the code above.\n\t 1. We don't compute things in an optimal order, high-to-low, in order\n\t    to terminate as quickly as possible.\n\t 2. We mess with pointers and sizes, adding and subtracting and\n\t    adjusting to get things right.  It surely could be streamlined.\n\t 3. The only termination criteria are that we determine that the\n\t    quotient needs to be adjusted, or that we have recomputed\n\t    everything.  We should stop when the remainder is so large\n\t    that no additional subtracting could make it spill.\n\t 4. If nothing else, we should not do two loops of submul_1 over the\n\t    data, instead handle both the triangularization and chopping at\n\t    once.  */\n\n      x = n1;\n\n      if (dn > 2)\n\t{\n\t  /* Compensate for triangularization.  */\n\t  mp_limb_t y;\n\n\t  dp = dp_orig;\n\t  if (qn + 1 < dn)\n\t    {\n\t      dp += dn - (qn + 1);\n\t      dn = qn + 1;\n\t    }\n\n\t  y = np[-2];\n\n\t  for (i = dn - 3; i >= 0; i--)\n\t    {\n\t      q = qp[i];\n\t      cy = mpn_submul_1 (np - (dn - i), dp, dn - i - 2, q);\n\n\t      if (y < cy)\n\t\t{\n\t\t  if (x == 0)\n\t\t    {\n\t\t      cy = mpn_sub_1 (qp, qp, qn, 1);\n\t\t      ASSERT_ALWAYS (cy == 0);\n\t\t      return qh - cy;\n\t\t    }\n\t\t  x--;\n\t\t}\n\t      y -= cy;\n\t    }\n\t  np[-2] = y;\n\t}\n\n      dn = dn_orig;\n      if (qn + 1 < dn)\n\t{\n\t  /* Compensate for ignored dividend and divisor tails.  */\n\n\t  dp = dp_orig;\n\t  np = np_orig;\n\n\t  if (qh != 0)\n\t    {\n\t      cy = mpn_sub_n (np + qn, np + qn, dp, dn - (qn + 1));\n\t      if (cy != 0)\n\t\t{\n\t\t  if (x == 0)\n\t\t    {\n\t\t      if (qn != 0)\n\t\t\tcy = mpn_sub_1 (qp, qp, qn, 1);\n\t\t      return qh - cy;\n\t\t    }\n\t\t  x--;\n\t\t}\n\t    }\n\n\t  if (qn == 0)\n\t    return qh;\n\n\t  for (i = dn - qn - 2; i >= 0; i--)\n\t    {\n\t      cy = mpn_submul_1 (np + i, qp, qn, dp[i]);\n\t      cy = mpn_sub_1 (np + qn + i, np + qn + i, dn - qn - i - 1, cy);\n\t      if (cy != 0)\n\t\t{\n\t\t  if (x == 0)\n\t\t    {\n\t\t      cy = mpn_sub_1 (qp, qp, qn, 1);\n\t\t      return qh;\n\t\t    }\n\t\t  x--;\n\t\t}\n\t    }\n\t}\n    }\n\n  return qh;\n}",
      "lines": 261,
      "depth": 18,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sbpi1_div_qr.c": {
    "mpn_sbpi1_div_qr": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "mp_limb_t\nmpn_sbpi1_div_qr (mp_ptr qp,\n\t\t  mp_ptr np, mp_size_t nn,\n\t\t  mp_srcptr dp, mp_size_t dn,\n\t\t  mp_limb_t dinv)\n{\n  mp_limb_t qh;\n  mp_size_t i;\n  mp_limb_t n1, n0;\n  mp_limb_t d1, d0;\n  mp_limb_t cy, cy1;\n  mp_limb_t q;\n\n  ASSERT (dn > 2);\n  ASSERT (nn >= dn);\n  ASSERT ((dp[dn-1] & GMP_NUMB_HIGHBIT) != 0);\n\n  np += nn;\n\n  qh = mpn_cmp (np - dn, dp, dn) >= 0;\n  if (qh != 0)\n    mpn_sub_n (np - dn, np - dn, dp, dn);\n\n  qp += nn - dn;\n\n  dn -= 2;\t\t\t/* offset dn by 2 for main division loops,\n\t\t\t\t   saving two iterations in mpn_submul_1.  */\n  d1 = dp[dn + 1];\n  d0 = dp[dn + 0];\n\n  np -= 2;\n\n  n1 = np[1];\n\n  for (i = nn - (dn + 2); i > 0; i--)\n    {\n      np--;\n      if (UNLIKELY (n1 == d1) && np[1] == d0)\n\t{\n\t  q = GMP_NUMB_MASK;\n\t  mpn_submul_1 (np - dn, dp, dn + 2, q);\n\t  n1 = np[1];\t\t/* update n1, last loop's value will now be invalid */\n\t}\n      else\n\t{\n\t  udiv_qr_3by2 (q, n1, n0, n1, np[1], np[0], d1, d0, dinv);\n\n\t  cy = mpn_submul_1 (np - dn, dp, dn, q);\n\n\t  cy1 = n0 < cy;\n\t  n0 = (n0 - cy) & GMP_NUMB_MASK;\n\t  cy = n1 < cy1;\n\t  n1 = (n1 - cy1) & GMP_NUMB_MASK;\n\t  np[0] = n0;\n\n\t  if (UNLIKELY (cy != 0))\n\t    {\n\t      n1 += d1 + mpn_add_n (np - dn, np - dn, dp, dn + 1);\n\t      q--;\n\t    }\n\t}\n\n      *--qp = q;\n    }\n  np[1] = n1;\n\n  return qh;\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/scan0.c": {
    "mpn_scan0": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "mp_bitcnt_t\nmpn_scan0 (mp_srcptr up, mp_bitcnt_t starting_bit)\n{\n  mp_size_t starting_word;\n  mp_limb_t alimb;\n  int cnt;\n  mp_srcptr p;\n\n  /* Start at the word implied by STARTING_BIT.  */\n  starting_word = starting_bit / GMP_NUMB_BITS;\n  p = up + starting_word;\n  alimb = *p++ ^ GMP_NUMB_MASK;\n\n  /* Mask off any bits before STARTING_BIT in the first limb.  */\n  alimb &= - (mp_limb_t) 1 << (starting_bit % GMP_NUMB_BITS);\n\n  while (alimb == 0)\n    alimb = *p++ ^ GMP_NUMB_MASK;\n\n  count_trailing_zeros (cnt, alimb);\n  return (p - up - 1) * GMP_NUMB_BITS + cnt;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "mp_bitcnt_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/scan1.c": {
    "mpn_scan1": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "mp_bitcnt_t\nmpn_scan1 (mp_srcptr up, mp_bitcnt_t starting_bit)\n{\n  mp_size_t starting_word;\n  mp_limb_t alimb;\n  int cnt;\n  mp_srcptr p;\n\n  /* Start at the word implied by STARTING_BIT.  */\n  starting_word = starting_bit / GMP_NUMB_BITS;\n  p = up + starting_word;\n  alimb = *p++;\n\n  /* Mask off any bits before STARTING_BIT in the first limb.  */\n  alimb &= - (mp_limb_t) 1 << (starting_bit % GMP_NUMB_BITS);\n\n  while (alimb == 0)\n    alimb = *p++;\n\n  count_trailing_zeros (cnt, alimb);\n  return (p - up - 1) * GMP_NUMB_BITS + cnt;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "mp_bitcnt_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sec_aors_1.c": {
    "FNAME_itch": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "mp_size_t\nFNAME_itch (mp_size_t n)\n{\n  return n;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "mp_size_t"
      ]
    },
    "FNAME": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "mp_limb_t\nFNAME (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b, mp_ptr scratch)\n{\n  scratch[0] = b;\n  MPN_ZERO (scratch + 1, n-1);\n  return OP_N (rp, ap, scratch, n);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sec_div.c": {
    "FNAME_itch": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "mp_size_t\nFNAME_itch (mp_size_t nn, mp_size_t dn)\n{\n#if OPERATION_sec_div_qr\n/* Needs (nn + dn + 1) + mpn_sec_pi1_div_qr's needs of (2nn' - dn + 1) for a\n   total of 3nn + 4 limbs at tp.  Note that mpn_sec_pi1_div_qr's nn is one\n   greater than ours, therefore +4 and not just +2.  */\n  return 3 * nn + 4;\n#endif\n#if OPERATION_sec_div_r\n/* Needs (nn + dn + 1) + mpn_sec_pi1_div_r's needs of (dn + 1) for a total of\n   nn + 2dn + 2 limbs at tp.  */\n  return nn + 2 * dn + 2;\n#endif\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "mp_size_t"
      ]
    },
    "FNAME": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "RETTYPE\nFNAME (Q(mp_ptr qp)\n       mp_ptr np, mp_size_t nn,\n       mp_srcptr dp, mp_size_t dn,\n       mp_ptr tp)\n{\n  mp_limb_t d1, d0;\n  unsigned int cnt;\n  gmp_pi1_t dinv;\n  mp_limb_t inv32;\n\n  ASSERT (dn >= 1);\n  ASSERT (nn >= dn);\n  ASSERT (dp[dn - 1] != 0);\n\n  d1 = dp[dn - 1];\n  count_leading_zeros (cnt, d1);\n\n  if (cnt != 0)\n    {\n      mp_limb_t qh, cy;\n      mp_ptr np2, dp2;\n      dp2 = tp;\t\t\t\t\t/* dn limbs */\n      mpn_lshift (dp2, dp, dn, cnt);\n\n      np2 = tp + dn;\t\t\t\t/* (nn + 1) limbs */\n      cy = mpn_lshift (np2, np, nn, cnt);\n      np2[nn++] = cy;\n\n      d0 = dp2[dn - 1];\n      d0 += (~d0 != 0);\n      invert_limb (inv32, d0);\n\n      /* We add nn + dn to tp here, not nn + 1 + dn, as expected.  This is\n\t since nn here will have been incremented.  */\n#if OPERATION_sec_div_qr\n      qh = mpn_sec_pi1_div_qr (np2 + dn, np2, nn, dp2, dn, inv32, tp + nn + dn);\n      ASSERT (qh == 0);\t\t/* FIXME: this indicates inefficiency! */\n      MPN_COPY (qp, np2 + dn, nn - dn - 1);\n      qh = np2[nn - 1];\n#else\n      mpn_sec_pi1_div_r (np2, nn, dp2, dn, inv32, tp + nn + dn);\n#endif\n\n      mpn_rshift (np, np2, dn, cnt);\n\n#if OPERATION_sec_div_qr\n      return qh;\n#endif\n    }\n  else\n    {\n      /* FIXME: Consider copying np => np2 here, adding a 0-limb at the top.\n\t That would simplify the underlying pi1 function, since then it could\n\t assume nn > dn.  */\n      d0 = dp[dn - 1];\n      d0 += (~d0 != 0);\n      invert_limb (inv32, d0);\n\n#if OPERATION_sec_div_qr\n      return mpn_sec_pi1_div_qr (qp, np, nn, dp, dn, inv32, tp);\n#else\n      mpn_sec_pi1_div_r (np, nn, dp, dn, inv32, tp);\n#endif\n    }\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "RETTYPE"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sec_invert.c": {
    "mpn_cnd_neg_itch": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static mp_size_t\nmpn_cnd_neg_itch (mp_size_t n)\n{\n  return n;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_cnd_neg": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static void\nmpn_cnd_neg (int cnd, mp_limb_t *rp, const mp_limb_t *ap, mp_size_t n,\n\t     mp_ptr scratch)\n{\n  mpn_lshift (scratch, ap, n, 1);\n  mpn_cnd_sub_n (cnd, rp, ap, scratch, n);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_sec_eq_ui": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nmpn_sec_eq_ui (mp_srcptr ap, mp_size_t n, mp_limb_t b)\n{\n  mp_limb_t d;\n  ASSERT (n > 0);\n\n  d = ap[0] ^ b;\n\n  while (--n > 0)\n    d |= ap[n];\n\n  return d == 0;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpn_sec_invert_itch": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "mp_size_t\nmpn_sec_invert_itch (mp_size_t n)\n{\n  return 4*n;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_sec_invert": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "int\nmpn_sec_invert (mp_ptr vp, mp_ptr ap, mp_srcptr mp,\n\t\tmp_size_t n, mp_bitcnt_t bit_size,\n\t\tmp_ptr scratch)\n{\n  ASSERT (n > 0);\n  ASSERT (bit_size > 0);\n  ASSERT (mp[0] & 1);\n  ASSERT (! MPN_OVERLAP_P (ap, n, vp, n));\n#define bp (scratch + n)\n#define up (scratch + 2*n)\n#define m1hp (scratch + 3*n)\n\n  /* Maintain\n\n       a = u * orig_a (mod m)\n       b = v * orig_a (mod m)\n\n     and b odd at all times. Initially,\n\n       a = a_orig, u = 1\n       b = m,      v = 0\n     */\n\n\n  up[0] = 1;\n  mpn_zero (up+1, n - 1);\n  mpn_copyi (bp, mp, n);\n  mpn_zero (vp, n);\n\n  ASSERT_CARRY (mpn_rshift (m1hp, mp, n, 1));\n  ASSERT_NOCARRY (mpn_sec_add_1 (m1hp, m1hp, n, 1, scratch));\n\n  while (bit_size-- > 0)\n    {\n      mp_limb_t odd, swap, cy;\n\n      /* Always maintain b odd. The logic of the iteration is as\n\t follows. For a, b:\n\n\t   odd = a & 1\n\t   a -= odd * b\n\t   if (underflow from a-b)\n\t     {\n\t       b += a, assigns old a\n\t       a = B^n-a\n\t     }\n\n\t   a /= 2\n\n\t For u, v:\n\n\t   if (underflow from a - b)\n\t     swap u, v\n\t   u -= odd * v\n\t   if (underflow from u - v)\n\t     u += m\n\n\t   u /= 2\n\t   if (a one bit was shifted out)\n\t     u += (m+1)/2\n\n\t As long as a > 0, the quantity\n\n\t   (bitsize of a) + (bitsize of b)\n\n\t is reduced by at least one bit per iteration, hence after (bit_size of\n\t orig_a) + (bit_size of m) - 1 iterations we surely have a = 0. Then b\n\t = gcd(orig_a, m) and if b = 1 then also v = orig_a^{-1} (mod m).\n      */\n\n      ASSERT (bp[0] & 1);\n      odd = ap[0] & 1;\n\n      swap = mpn_cnd_sub_n (odd, ap, ap, bp, n);\n      mpn_cnd_add_n (swap, bp, bp, ap, n);\n      mpn_cnd_neg (swap, ap, ap, n, scratch);\n\n      mpn_cnd_swap (swap, up, vp, n);\n      cy = mpn_cnd_sub_n (odd, up, up, vp, n);\n      cy -= mpn_cnd_add_n (cy, up, up, mp, n);\n      ASSERT (cy == 0);\n\n      cy = mpn_rshift (ap, ap, n, 1);\n      ASSERT (cy == 0);\n      cy = mpn_rshift (up, up, n, 1);\n      cy = mpn_cnd_add_n (cy, up, up, m1hp, n);\n      ASSERT (cy == 0);\n    }\n  /* Should be all zeros, but check only extreme limbs */\n  ASSERT ( (ap[0] | ap[n-1]) == 0);\n  /* Check if indeed gcd == 1. */\n  return mpn_sec_eq_ui (bp, n, 1);\n#undef bp\n#undef up\n#undef m1hp\n}",
      "lines": 97,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sec_mul.c": {
    "mpn_sec_mul": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\nmpn_sec_mul (mp_ptr rp,\n\t     mp_srcptr ap, mp_size_t an,\n\t     mp_srcptr bp, mp_size_t bn,\n\t     mp_ptr tp)\n{\n  mpn_mul_basecase (rp, ap, an, bp, bn);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_sec_mul_itch": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "mp_size_t\nmpn_sec_mul_itch (mp_size_t an, mp_size_t bn)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sec_pi1_div.c": {
    "FNAME": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "RETTYPE\nFNAME (Q(mp_ptr qp)\n       mp_ptr np, mp_size_t nn,\n       mp_srcptr dp, mp_size_t dn,\n       mp_limb_t dinv,\n       mp_ptr tp)\n{\n  mp_limb_t nh, cy, q1h, q0h, dummy, cnd;\n  mp_size_t i;\n  mp_ptr hp;\n#if OPERATION_sec_pi1_div_qr\n  mp_limb_t qh;\n  mp_ptr qlp, qhp;\n#endif\n\n  ASSERT (dn >= 1);\n  ASSERT (nn >= dn);\n  ASSERT ((dp[dn - 1] & GMP_NUMB_HIGHBIT) != 0);\n\n  if (nn == dn)\n    {\n      cy = mpn_sub_n (np, np, dp, dn);\n      mpn_cnd_add_n (cy, np, np, dp, dn);\n#if OPERATION_sec_pi1_div_qr\n      return 1 - cy;\n#else\n      return;\n#endif\n    }\n\n  /* Create a divisor copy shifted half a limb.  */\n  hp = tp;\t\t\t\t\t/* (dn + 1) limbs */\n  hp[dn] = mpn_lshift (hp, dp, dn, GMP_NUMB_BITS / 2);\n\n#if OPERATION_sec_pi1_div_qr\n  qlp = tp + (dn + 1);\t\t\t\t/* (nn - dn) limbs */\n  qhp = tp + (nn + 1);\t\t\t\t/* (nn - dn) limbs */\n#endif\n\n  np += nn - dn;\n  nh = 0;\n\n  for (i = nn - dn - 1; i >= 0; i--)\n    {\n      np--;\n\n      nh = (nh << GMP_NUMB_BITS/2) + (np[dn] >> GMP_NUMB_BITS/2);\n      umul_ppmm (q1h, dummy, nh, dinv);\n      q1h += nh;\n#if OPERATION_sec_pi1_div_qr\n      qhp[i] = q1h;\n#endif\n      mpn_submul_1 (np, hp, dn + 1, q1h);\n\n      nh = np[dn];\n      umul_ppmm (q0h, dummy, nh, dinv);\n      q0h += nh;\n#if OPERATION_sec_pi1_div_qr\n      qlp[i] = q0h;\n#endif\n      nh -= mpn_submul_1 (np, dp, dn, q0h);\n    }\n\n  /* 1st adjustment depends on extra high remainder limb.  */\n  cnd = nh != 0;\t\t\t\t/* FIXME: cmp-to-int */\n#if OPERATION_sec_pi1_div_qr\n  qlp[0] += cnd;\n#endif\n  nh -= mpn_cnd_sub_n (cnd, np, np, dp, dn);\n\n  /* 2nd adjustment depends on remainder/divisor comparison as well as whether\n     extra remainder limb was nullified by previous subtract.  */\n  cy = mpn_sub_n (np, np, dp, dn);\n  cy = cy - nh;\n#if OPERATION_sec_pi1_div_qr\n  qlp[0] += 1 - cy;\n#endif\n  mpn_cnd_add_n (cy, np, np, dp, dn);\n\n  /* 3rd adjustment depends on remainder/divisor comparison.  */\n  cy = mpn_sub_n (np, np, dp, dn);\n#if OPERATION_sec_pi1_div_qr\n  qlp[0] += 1 - cy;\n#endif\n  mpn_cnd_add_n (cy, np, np, dp, dn);\n\n#if OPERATION_sec_pi1_div_qr\n  /* Combine quotient halves into final quotient.  */\n  qh = mpn_lshift (qhp, qhp, nn - dn, GMP_NUMB_BITS/2);\n  qh += mpn_add_n (qp, qhp, qlp, nn - dn);\n\n  return qh;\n#else\n  return;\n#endif\n}",
      "lines": 96,
      "depth": 11,
      "decorators": [
        "RETTYPE"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sec_powm.c": {
    "getbits": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static inline mp_limb_t\ngetbits (const mp_limb_t *p, mp_bitcnt_t bi, int nbits)\n{\n  int nbits_in_r;\n  mp_limb_t r;\n  mp_size_t i;\n\n  if (bi < nbits)\n    {\n      return p[0] & (((mp_limb_t) 1 << bi) - 1);\n    }\n  else\n    {\n      bi -= nbits;\t\t\t/* bit index of low bit to extract */\n      i = bi / GMP_NUMB_BITS;\t\t/* word index of low bit to extract */\n      bi %= GMP_NUMB_BITS;\t\t/* bit index in low word */\n      r = p[i] >> bi;\t\t\t/* extract (low) bits */\n      nbits_in_r = GMP_NUMB_BITS - bi;\t/* number of bits now in r */\n      if (nbits_in_r < nbits)\t\t/* did we get enough bits? */\n\tr += p[i + 1] << nbits_in_r;\t/* prepend bits from higher word */\n      return r & (((mp_limb_t ) 1 << nbits) - 1);\n    }\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mp_limb_t"
      ]
    },
    "win_size": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static inline int\nwin_size (mp_bitcnt_t enb)\n{\n  int k;\n  /* Find k, such that x[k-1] < enb <= x[k].\n\n     We require that x[k] >= k, then it follows that enb > x[k-1] >=\n     k-1, which implies k <= enb.\n  */\n  static const mp_bitcnt_t x[] = {0,POWM_SEC_TABLE,~(mp_bitcnt_t)0};\n  for (k = 1; enb > x[k]; k++)\n    ;\n  ASSERT (k <= enb);\n  return k;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "redcify": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static void\nredcify (mp_ptr rp, mp_srcptr up, mp_size_t un, mp_srcptr mp, mp_size_t n, mp_ptr tp)\n{\n  MPN_ZERO (tp, n);\n  MPN_COPY (tp + n, up, un);\n\n  mpn_sec_div_r (tp, un + n, mp, n, tp + un + n);\n  MPN_COPY (rp, tp, n);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_sec_powm": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "void\nmpn_sec_powm (mp_ptr rp, mp_srcptr bp, mp_size_t bn,\n\t      mp_srcptr ep, mp_bitcnt_t enb,\n\t      mp_srcptr mp, mp_size_t n, mp_ptr tp)\n{\n  mp_limb_t ip[2], *mip;\n  int windowsize, this_windowsize;\n  mp_limb_t expbits;\n  mp_ptr pp, this_pp;\n  long i;\n  int cnd;\n\n  ASSERT (enb > 0);\n  ASSERT (n > 0);\n  /* The code works for bn = 0, but the defined scratch space is 2 limbs\n     greater than we supply, when converting 1 to redc form .  */\n  ASSERT (bn > 0);\n  ASSERT ((mp[0] & 1) != 0);\n\n  windowsize = win_size (enb);\n\n#if WANT_REDC_2\n  if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_2_THRESHOLD))\n    {\n      mip = ip;\n      binvert_limb (mip[0], mp[0]);\n      mip[0] = -mip[0];\n    }\n  else\n    {\n      mip = ip;\n      mpn_binvert (mip, mp, 2, tp);\n      mip[0] = -mip[0]; mip[1] = ~mip[1];\n    }\n#else\n  mip = ip;\n  binvert_limb (mip[0], mp[0]);\n  mip[0] = -mip[0];\n#endif\n\n  pp = tp;\n  tp += (n << windowsize);\t/* put tp after power table */\n\n  /* Compute pp[0] table entry */\n  /* scratch: |   n   | 1 |   n+2    |  */\n  /*          | pp[0] | 1 | redcify  |  */\n  this_pp = pp;\n  this_pp[n] = 1;\n  redcify (this_pp, this_pp + n, 1, mp, n, this_pp + n + 1);\n  this_pp += n;\n\n  /* Compute pp[1] table entry.  To avoid excessive scratch usage in the\n     degenerate situation where B >> M, we let redcify use scratch space which\n     will later be used by the pp table (element 2 and up).  */\n  /* scratch: |   n   |   n   |  bn + n + 1  |  */\n  /*          | pp[0] | pp[1] |   redcify    |  */\n  redcify (this_pp, bp, bn, mp, n, this_pp + n);\n\n  /* Precompute powers of b and put them in the temporary area at pp.  */\n  /* scratch: |   n   |   n   | ...  |                    |   2n      |  */\n  /*          | pp[0] | pp[1] | ...  | pp[2^windowsize-1] |  product  |  */\n  for (i = (1 << windowsize) - 2; i > 0; i--)\n    {\n      mpn_mul_basecase (tp, this_pp, n, pp + n, n);\n      this_pp += n;\n#if WANT_REDC_2\n      if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_2_THRESHOLD))\n\tMPN_REDC_1_SEC (this_pp, tp, mp, n, mip[0]);\n      else\n\tMPN_REDC_2_SEC (this_pp, tp, mp, n, mip);\n#else\n      MPN_REDC_1_SEC (this_pp, tp, mp, n, mip[0]);\n#endif\n    }\n\n  expbits = getbits (ep, enb, windowsize);\n  ASSERT_ALWAYS (enb >= windowsize);\n  enb -= windowsize;\n\n  mpn_sec_tabselect (rp, pp, n, 1 << windowsize, expbits);\n\n  /* Main exponentiation loop.  */\n  /* scratch: |   n   |   n   | ...  |                    |     3n-4n     |  */\n  /*          | pp[0] | pp[1] | ...  | pp[2^windowsize-1] |  loop scratch |  */\n\n#define INNERLOOP\t\t\t\t\t\t\t\\\n  while (enb != 0)\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      expbits = getbits (ep, enb, windowsize);\t\t\t\t\\\n      this_windowsize = windowsize;\t\t\t\t\t\\\n      if (enb < windowsize)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  this_windowsize -= windowsize - enb;\t\t\t\t\\\n\t  enb = 0;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\tenb -= windowsize;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      do\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  mpn_local_sqr (tp, rp, n, tp + 2 * n);\t\t\t\\\n\t  MPN_REDUCE (rp, tp, mp, n, mip);\t\t\t\t\\\n\t  this_windowsize--;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      while (this_windowsize != 0);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      mpn_sec_tabselect (tp + 2*n, pp, n, 1 << windowsize, expbits);\t\\\n      mpn_mul_basecase (tp, rp, n, tp + 2*n, n);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      MPN_REDUCE (rp, tp, mp, n, mip);\t\t\t\t\t\\\n    }\n\n#if WANT_REDC_2\n  if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_2_THRESHOLD))\n    {\n#undef MPN_MUL_N\n#undef MPN_SQR\n#undef MPN_REDUCE\n#define MPN_MUL_N(r,a,b,n)\t\tmpn_mul_basecase (r,a,n,b,n)\n#define MPN_SQR(r,a,n)\t\t\tmpn_sqr_basecase (r,a,n)\n#define MPN_REDUCE(rp,tp,mp,n,mip)\tMPN_REDC_1_SEC (rp, tp, mp, n, mip[0])\n      INNERLOOP;\n    }\n  else\n    {\n#undef MPN_MUL_N\n#undef MPN_SQR\n#undef MPN_REDUCE\n#define MPN_MUL_N(r,a,b,n)\t\tmpn_mul_basecase (r,a,n,b,n)\n#define MPN_SQR(r,a,n)\t\t\tmpn_sqr_basecase (r,a,n)\n#define MPN_REDUCE(rp,tp,mp,n,mip)\tMPN_REDC_2_SEC (rp, tp, mp, n, mip)\n      INNERLOOP;\n    }\n#else\n#undef MPN_MUL_N\n#undef MPN_SQR\n#undef MPN_REDUCE\n#define MPN_MUL_N(r,a,b,n)\t\tmpn_mul_basecase (r,a,n,b,n)\n#define MPN_SQR(r,a,n)\t\t\tmpn_sqr_basecase (r,a,n)\n#define MPN_REDUCE(rp,tp,mp,n,mip)\tMPN_REDC_1_SEC (rp, tp, mp, n, mip[0])\n  INNERLOOP;\n#endif\n\n  MPN_COPY (tp, rp, n);\n  MPN_ZERO (tp + n, n);\n\n#if WANT_REDC_2\n  if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_2_THRESHOLD))\n    MPN_REDC_1_SEC (rp, tp, mp, n, mip[0]);\n  else\n    MPN_REDC_2_SEC (rp, tp, mp, n, mip);\n#else\n  MPN_REDC_1_SEC (rp, tp, mp, n, mip[0]);\n#endif\n  cnd = mpn_sub_n (tp, rp, mp, n);\t/* we need just retval */\n  mpn_cnd_sub_n (!cnd, rp, rp, mp, n);\n}",
      "lines": 157,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "mpn_sec_powm_itch": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "mp_size_t\nmpn_sec_powm_itch (mp_size_t bn, mp_bitcnt_t enb, mp_size_t n)\n{\n  int windowsize;\n  mp_size_t redcify_itch, itch;\n\n  /* The top scratch usage will either be when reducing B in the 2nd redcify\n     call, or more typically n*2^windowsize + 3n or 4n, in the main loop.  (It\n     is 3n or 4n depending on if we use mpn_local_sqr or a native\n     mpn_sqr_basecase.  We assume 4n always for now.) */\n\n  windowsize = win_size (enb);\n\n  /* The 2n term is due to pp[0] and pp[1] at the time of the 2nd redcify call,\n     the (bn + n) term is due to redcify's own usage, and the rest is due to\n     mpn_sec_div_r's usage when called from redcify.  */\n  redcify_itch = (2 * n) + (bn + n) + ((bn + n) + 2 * n + 2);\n\n  /* The n * 2^windowsize term is due to the power table, the 4n term is due to\n     scratch needs of squaring/multiplication in the exponentiation loop.  */\n  itch = (n << windowsize) + (4 * n);\n\n  return MAX (itch, redcify_itch);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sec_sqr.c": {
    "mpn_sec_sqr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\nmpn_sec_sqr (mp_ptr rp,\n\t     mp_srcptr ap, mp_size_t an,\n\t     mp_ptr tp)\n{\n#ifndef SQR_BASECASE_LIM\n/* If SQR_BASECASE_LIM is now not defined, use mpn_sqr_basecase for any operand\n   size.  */\n  mpn_sqr_basecase (rp, ap, an);\n#else\n/* Else use mpn_sqr_basecase for its allowed sizes, else mpn_mul_basecase.  */\n  mpn_mul_basecase (rp, ap, an, ap, an);\n#endif\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpn_sec_sqr_itch": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "mp_size_t\nmpn_sec_sqr_itch (mp_size_t an)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sec_tabselect.c": {
    "mpn_sec_tabselect": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\nmpn_sec_tabselect (volatile mp_limb_t *rp, volatile const mp_limb_t *tab,\n\t\t   mp_size_t n, mp_size_t nents, mp_size_t which)\n{\n  mp_size_t k, i;\n  mp_limb_t mask;\n  volatile const mp_limb_t *tp;\n\n  for (k = 0; k < nents; k++)\n    {\n      mask = -(mp_limb_t) (which == k);\n      tp = tab + n * k;\n      for (i = 0; i < n; i++)\n\t{\n\t  rp[i] = (rp[i] & ~mask) | (tp[i] & mask);\n\t}\n    }\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/set_str.c": {
    "mpn_set_str": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "mp_size_t\nmpn_set_str (mp_ptr rp, const unsigned char *str, size_t str_len, int base)\n{\n  if (POW2_P (base))\n    {\n      /* The base is a power of 2.  Read the input string from least to most\n\t significant character/digit.  */\n\n      const unsigned char *s;\n      int next_bitpos;\n      mp_limb_t res_digit;\n      mp_size_t size;\n      int bits_per_indigit = mp_bases[base].big_base;\n\n      size = 0;\n      res_digit = 0;\n      next_bitpos = 0;\n\n      for (s = str + str_len - 1; s >= str; s--)\n\t{\n\t  int inp_digit = *s;\n\n\t  res_digit |= ((mp_limb_t) inp_digit << next_bitpos) & GMP_NUMB_MASK;\n\t  next_bitpos += bits_per_indigit;\n\t  if (next_bitpos >= GMP_NUMB_BITS)\n\t    {\n\t      rp[size++] = res_digit;\n\t      next_bitpos -= GMP_NUMB_BITS;\n\t      res_digit = inp_digit >> (bits_per_indigit - next_bitpos);\n\t    }\n\t}\n\n      if (res_digit != 0)\n\trp[size++] = res_digit;\n      return size;\n    }\n\n  if (BELOW_THRESHOLD (str_len, SET_STR_PRECOMPUTE_THRESHOLD))\n    return mpn_bc_set_str (rp, str, str_len, base);\n  else\n    {\n      mp_ptr powtab_mem, tp;\n      powers_t powtab[GMP_LIMB_BITS];\n      int chars_per_limb;\n      mp_size_t size;\n      mp_size_t un;\n      TMP_DECL;\n\n      TMP_MARK;\n\n      chars_per_limb = mp_bases[base].chars_per_limb;\n\n      un = str_len / chars_per_limb + 1;\n\n      /* Allocate one large block for the powers of big_base.  */\n      powtab_mem = TMP_BALLOC_LIMBS (mpn_dc_set_str_powtab_alloc (un));\n\n      mpn_set_str_compute_powtab (powtab, powtab_mem, un, base);\n\n      tp = TMP_BALLOC_LIMBS (mpn_dc_set_str_itch (un));\n      size = mpn_dc_set_str (rp, str, str_len, powtab, tp);\n\n      TMP_FREE;\n      return size;\n    }\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_set_str_compute_powtab": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "void\nmpn_set_str_compute_powtab (powers_t *powtab, mp_ptr powtab_mem, mp_size_t un, int base)\n{\n  mp_ptr powtab_mem_ptr;\n  long i, pi;\n  mp_size_t n;\n  mp_ptr p, t;\n  mp_limb_t big_base;\n  int chars_per_limb;\n  size_t digits_in_base;\n  mp_size_t shift;\n\n  powtab_mem_ptr = powtab_mem;\n\n  chars_per_limb = mp_bases[base].chars_per_limb;\n  big_base = mp_bases[base].big_base;\n\n  p = powtab_mem_ptr;\n  powtab_mem_ptr += 1;\n\n  digits_in_base = chars_per_limb;\n\n  p[0] = big_base;\n  n = 1;\n\n  count_leading_zeros (i, un - 1);\n  i = GMP_LIMB_BITS - 1 - i;\n\n  powtab[i].p = p;\n  powtab[i].n = n;\n  powtab[i].digits_in_base = digits_in_base;\n  powtab[i].base = base;\n  powtab[i].shift = 0;\n\n  shift = 0;\n  for (pi = i - 1; pi >= 0; pi--)\n    {\n      t = powtab_mem_ptr;\n      powtab_mem_ptr += 2 * n;\n\n      ASSERT_ALWAYS (powtab_mem_ptr < powtab_mem + mpn_dc_set_str_powtab_alloc (un));\n\n      mpn_sqr (t, p, n);\n      n = 2 * n - 1; n += t[n] != 0;\n      digits_in_base *= 2;\n#if 1\n      if ((((un - 1) >> pi) & 2) == 0)\n\t{\n\t  mpn_divexact_1 (t, t, n, big_base);\n\t  n -= t[n - 1] == 0;\n\t  digits_in_base -= chars_per_limb;\n\t}\n#else\n      if (CLEVER_CONDITION_1 ())\n\t{\n\t  /* perform adjustment operation of previous */\n\t  cy = mpn_mul_1 (p, p, n, big_base);\n\t}\n      if (CLEVER_CONDITION_2 ())\n\t{\n\t  /* perform adjustment operation of new */\n\t  cy = mpn_mul_1 (t, t, n, big_base);\n\t}\n#endif\n      shift *= 2;\n      /* Strip low zero limbs, but be careful to keep the result divisible by\n\t big_base.  */\n      while (t[0] == 0 && (t[1] & ((big_base & -big_base) - 1)) == 0)\n\t{\n\t  t++;\n\t  n--;\n\t  shift++;\n\t}\n      p = t;\n      powtab[pi].p = p;\n      powtab[pi].n = n;\n      powtab[pi].digits_in_base = digits_in_base;\n      powtab[pi].base = base;\n      powtab[pi].shift = shift;\n    }\n}",
      "lines": 81,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "mpn_dc_set_str": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "mp_size_t\nmpn_dc_set_str (mp_ptr rp, const unsigned char *str, size_t str_len,\n\t\tconst powers_t *powtab, mp_ptr tp)\n{\n  size_t len_lo, len_hi;\n  mp_limb_t cy;\n  mp_size_t ln, hn, n, sn;\n\n  len_lo = powtab->digits_in_base;\n\n  if (str_len <= len_lo)\n    {\n      if (BELOW_THRESHOLD (str_len, SET_STR_DC_THRESHOLD))\n\treturn mpn_bc_set_str (rp, str, str_len, powtab->base);\n      else\n\treturn mpn_dc_set_str (rp, str, str_len, powtab + 1, tp);\n    }\n\n  len_hi = str_len - len_lo;\n  ASSERT (len_lo >= len_hi);\n\n  if (BELOW_THRESHOLD (len_hi, SET_STR_DC_THRESHOLD))\n    hn = mpn_bc_set_str (tp, str, len_hi, powtab->base);\n  else\n    hn = mpn_dc_set_str (tp, str, len_hi, powtab + 1, rp);\n\n  sn = powtab->shift;\n\n  if (hn == 0)\n    {\n      /* Zero +1 limb here, to avoid reading an allocated but uninitialised\n\t limb in mpn_incr_u below.  */\n      MPN_ZERO (rp, powtab->n + sn + 1);\n    }\n  else\n    {\n      if (powtab->n > hn)\n\tmpn_mul (rp + sn, powtab->p, powtab->n, tp, hn);\n      else\n\tmpn_mul (rp + sn, tp, hn, powtab->p, powtab->n);\n      MPN_ZERO (rp, sn);\n    }\n\n  str = str + str_len - len_lo;\n  if (BELOW_THRESHOLD (len_lo, SET_STR_DC_THRESHOLD))\n    ln = mpn_bc_set_str (tp, str, len_lo, powtab->base);\n  else\n    ln = mpn_dc_set_str (tp, str, len_lo, powtab + 1, tp + powtab->n + sn + 1);\n\n  if (ln != 0)\n    {\n      cy = mpn_add_n (rp, rp, tp, ln);\n      mpn_incr_u (rp + ln, cy);\n    }\n  n = hn + powtab->n + sn;\n  return n - (rp[n - 1] == 0);\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_bc_set_str": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "mp_size_t\nmpn_bc_set_str (mp_ptr rp, const unsigned char *str, size_t str_len, int base)\n{\n  mp_size_t size;\n  size_t i;\n  long j;\n  mp_limb_t cy_limb;\n\n  mp_limb_t big_base;\n  int chars_per_limb;\n  mp_limb_t res_digit;\n\n  ASSERT (base >= 2);\n  ASSERT (base < numberof (mp_bases));\n  ASSERT (str_len >= 1);\n\n  big_base = mp_bases[base].big_base;\n  chars_per_limb = mp_bases[base].chars_per_limb;\n\n  size = 0;\n  for (i = chars_per_limb; i < str_len; i += chars_per_limb)\n    {\n      res_digit = *str++;\n      if (base == 10)\n\t{ /* This is a common case.\n\t     Help the compiler to avoid multiplication.  */\n\t  for (j = MP_BASES_CHARS_PER_LIMB_10 - 1; j != 0; j--)\n\t    res_digit = res_digit * 10 + *str++;\n\t}\n      else\n\t{\n\t  for (j = chars_per_limb - 1; j != 0; j--)\n\t    res_digit = res_digit * base + *str++;\n\t}\n\n      if (size == 0)\n\t{\n\t  if (res_digit != 0)\n\t    {\n\t      rp[0] = res_digit;\n\t      size = 1;\n\t    }\n\t}\n      else\n\t{\n#if HAVE_NATIVE_mpn_mul_1c\n\t  cy_limb = mpn_mul_1c (rp, rp, size, big_base, res_digit);\n#else\n\t  cy_limb = mpn_mul_1 (rp, rp, size, big_base);\n\t  cy_limb += mpn_add_1 (rp, rp, size, res_digit);\n#endif\n\t  if (cy_limb != 0)\n\t    rp[size++] = cy_limb;\n\t}\n    }\n\n  big_base = base;\n  res_digit = *str++;\n  if (base == 10)\n    { /* This is a common case.\n\t Help the compiler to avoid multiplication.  */\n      for (j = str_len - (i - MP_BASES_CHARS_PER_LIMB_10) - 1; j > 0; j--)\n\t{\n\t  res_digit = res_digit * 10 + *str++;\n\t  big_base *= 10;\n\t}\n    }\n  else\n    {\n      for (j = str_len - (i - chars_per_limb) - 1; j > 0; j--)\n\t{\n\t  res_digit = res_digit * base + *str++;\n\t  big_base *= base;\n\t}\n    }\n\n  if (size == 0)\n    {\n      if (res_digit != 0)\n\t{\n\t  rp[0] = res_digit;\n\t  size = 1;\n\t}\n    }\n  else\n    {\n#if HAVE_NATIVE_mpn_mul_1c\n      cy_limb = mpn_mul_1c (rp, rp, size, big_base, res_digit);\n#else\n      cy_limb = mpn_mul_1 (rp, rp, size, big_base);\n      cy_limb += mpn_add_1 (rp, rp, size, res_digit);\n#endif\n      if (cy_limb != 0)\n\trp[size++] = cy_limb;\n    }\n  return size;\n}",
      "lines": 97,
      "depth": 13,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sizeinbase.c": {
    "mpn_sizeinbase": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "size_t\nmpn_sizeinbase (mp_srcptr xp, mp_size_t xsize, int base)\n{\n  size_t  result;\n  MPN_SIZEINBASE (result, xp, xsize, base);\n  return result;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sqr.c": {
    "mpn_sqr": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\nmpn_sqr (mp_ptr p, mp_srcptr a, mp_size_t n)\n{\n  ASSERT (n >= 1);\n  ASSERT (! MPN_OVERLAP_P (p, 2 * n, a, n));\n\n  if (BELOW_THRESHOLD (n, SQR_BASECASE_THRESHOLD))\n    { /* mul_basecase is faster than sqr_basecase on small sizes sometimes */\n      mpn_mul_basecase (p, a, n, a, n);\n    }\n  else if (BELOW_THRESHOLD (n, SQR_TOOM2_THRESHOLD))\n    {\n      mpn_sqr_basecase (p, a, n);\n    }\n  else if (BELOW_THRESHOLD (n, SQR_TOOM3_THRESHOLD))\n    {\n      /* Allocate workspace of fixed size on stack: fast! */\n      mp_limb_t ws[mpn_toom2_sqr_itch (SQR_TOOM3_THRESHOLD_LIMIT-1)];\n      ASSERT (SQR_TOOM3_THRESHOLD <= SQR_TOOM3_THRESHOLD_LIMIT);\n      mpn_toom2_sqr (p, a, n, ws);\n    }\n  else if (BELOW_THRESHOLD (n, SQR_TOOM4_THRESHOLD))\n    {\n      mp_ptr ws;\n      TMP_SDECL;\n      TMP_SMARK;\n      ws = TMP_SALLOC_LIMBS (mpn_toom3_sqr_itch (n));\n      mpn_toom3_sqr (p, a, n, ws);\n      TMP_SFREE;\n    }\n  else if (BELOW_THRESHOLD (n, SQR_TOOM6_THRESHOLD))\n    {\n      mp_ptr ws;\n      TMP_SDECL;\n      TMP_SMARK;\n      ws = TMP_SALLOC_LIMBS (mpn_toom4_sqr_itch (n));\n      mpn_toom4_sqr (p, a, n, ws);\n      TMP_SFREE;\n    }\n  else if (BELOW_THRESHOLD (n, SQR_TOOM8_THRESHOLD))\n    {\n      mp_ptr ws;\n      TMP_SDECL;\n      TMP_SMARK;\n      ws = TMP_SALLOC_LIMBS (mpn_toom6_sqr_itch (n));\n      mpn_toom6_sqr (p, a, n, ws);\n      TMP_SFREE;\n    }\n  else if (BELOW_THRESHOLD (n, SQR_FFT_THRESHOLD))\n    {\n      mp_ptr ws;\n      TMP_DECL;\n      TMP_MARK;\n      ws = TMP_ALLOC_LIMBS (mpn_toom8_sqr_itch (n));\n      mpn_toom8_sqr (p, a, n, ws);\n      TMP_FREE;\n    }\n  else\n    {\n      /* The current FFT code allocates its own space.  That should probably\n\t change.  */\n      mpn_fft_mul (p, a, n, a, n);\n    }\n}",
      "lines": 64,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sqrlo.c": {
    "mpn_sqrlo_itch": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "static mp_size_t\nmpn_sqrlo_itch (mp_size_t n)\n{\n  return 2*n;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_dc_sqrlo": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void\nmpn_dc_sqrlo (mp_ptr rp, mp_srcptr xp, mp_size_t n, mp_ptr tp)\n{\n  mp_size_t n2, n1;\n  ASSERT (n >= 2);\n  ASSERT (! MPN_OVERLAP_P (rp, n, xp, n));\n  ASSERT (MPN_SAME_OR_SEPARATE2_P(rp, n, tp, 2*n));\n\n  /* Divide-and-conquer */\n\n  /* We need fractional approximation of the value 0 < a <= 1/2\n     giving the minimum in the function k=(1-a)^e/(1-2*a^e).\n  */\n  if (MAYBE_range_basecase && BELOW_THRESHOLD (n, SQR_TOOM2_THRESHOLD*36/(36-11)))\n    n1 = n >> 1;\n  else if (MAYBE_range_toom22 && BELOW_THRESHOLD (n, SQR_TOOM3_THRESHOLD*36/(36-11)))\n    n1 = n * 11 / (size_t) 36;\t/* n1 ~= n*(1-.694...) */\n  else if (BELOW_THRESHOLD (n, SQR_TOOM4_THRESHOLD*40/(40-9)))\n    n1 = n * 9 / (size_t) 40;\t/* n1 ~= n*(1-.775...) */\n  else if (BELOW_THRESHOLD (n, SQR_TOOM8_THRESHOLD*10/9))\n    n1 = n * 7 / (size_t) 39;\t/* n1 ~= n*(1-.821...) */\n  /* n1 = n * 4 / (size_t) 31;\t// n1 ~= n*(1-.871...) [TOOM66] */\n  else\n    n1 = n / (size_t) 10;\t\t/* n1 ~= n*(1-.899...) [TOOM88] */\n\n  n2 = n - n1;\n\n  /* Split as x = x1 2^(n2 GMP_NUMB_BITS) + x0 */\n\n  /* x0 ^ 2 */\n  mpn_sqr (tp, xp, n2);\n  MPN_COPY (rp, tp, n2);\n\n  /* x1 * x0 * 2^(n2 GMP_NUMB_BITS) */\n  if (BELOW_THRESHOLD (n1, MULLO_BASECASE_THRESHOLD))\n    mpn_mul_basecase (tp + n, xp + n2, n1, xp, n1);\n  else if (BELOW_THRESHOLD (n1, MULLO_DC_THRESHOLD))\n    mpn_mullo_basecase (tp + n, xp + n2, xp, n1);\n  else\n    mpn_mullo_n (tp + n, xp + n2, xp, n1);\n  /* mpn_dc_mullo_n (tp + n, xp + n2, xp, n1, tp + n); */\n#if HAVE_NATIVE_mpn_addlsh1_n\n  mpn_addlsh1_n (rp + n2, tp + n2, tp + n, n1);\n#else\n  mpn_lshift (rp + n2, tp + n, n1, 1);\n  mpn_add_n (rp + n2, rp + n2, tp + n2, n1);\n#endif\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_sqrlo": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "void\nmpn_sqrlo (mp_ptr rp, mp_srcptr xp, mp_size_t n)\n{\n  ASSERT (n >= 1);\n  ASSERT (! MPN_OVERLAP_P (rp, n, xp, n));\n\n  if (BELOW_THRESHOLD (n, SQRLO_BASECASE_THRESHOLD))\n    {\n      /* FIXME: smarter criteria? */\n#if HAVE_NATIVE_mpn_mullo_basecase || ! HAVE_NATIVE_mpn_sqr_basecase\n      /* mullo computes as many products as sqr, but directly writes\n\t on the result area. */\n      mpn_mullo_basecase (rp, xp, xp, n);\n#else\n      /* Allocate workspace of fixed size on stack: fast! */\n      mp_limb_t tp[SQR_BASECASE_ALLOC];\n      mpn_sqr_basecase (tp, xp, n);\n      MPN_COPY (rp, tp, n);\n#endif\n    }\n  else if (BELOW_THRESHOLD (n, SQRLO_DC_THRESHOLD))\n    {\n      mpn_sqrlo_basecase (rp, xp, n);\n    }\n  else\n    {\n      mp_ptr tp;\n      TMP_DECL;\n      TMP_MARK;\n      tp = TMP_ALLOC_LIMBS (mpn_sqrlo_itch (n));\n      if (BELOW_THRESHOLD (n, SQRLO_SQR_THRESHOLD))\n\t{\n\t  mpn_dc_sqrlo (rp, xp, n, tp);\n\t}\n      else\n\t{\n\t  /* For really large operands, use plain mpn_mul_n but throw away upper n\n\t     limbs of result.  */\n#if !TUNE_PROGRAM_BUILD && (SQRLO_SQR_THRESHOLD > SQR_FFT_THRESHOLD)\n\t  mpn_fft_mul (tp, xp, n, xp, n);\n#else\n\t  mpn_sqr (tp, xp, n);\n#endif\n\t  MPN_COPY (rp, tp, n);\n\t}\n      TMP_FREE;\n    }\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sqrlo_basecase.c": {
    "mpn_sqrlo_basecase": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void\nmpn_sqrlo_basecase (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  mp_limb_t ul;\n\n  ASSERT (n >= 1);\n  ASSERT (! MPN_OVERLAP_P (rp, n, up, n));\n\n  ul = up[0];\n\n  if (n <= SQRLO_SPECIAL_CASES)\n    {\n#if SQRLO_SPECIAL_CASES == 1\n      rp[0] = (ul * ul) & GMP_NUMB_MASK;\n#else\n      if (n == 1)\n\trp[0] = (ul * ul) & GMP_NUMB_MASK;\n      else\n\t{\n\t  mp_limb_t hi, lo, ul1;\n\t  umul_ppmm (hi, lo, ul, ul << GMP_NAIL_BITS);\n\t  rp[0] = lo >> GMP_NAIL_BITS;\n\t  ul1 = up[1];\n#if SQRLO_SPECIAL_CASES == 2\n\t  rp[1] = (hi + ul * ul1 * 2) & GMP_NUMB_MASK;\n#else\n\t  if (n == 2)\n\t    rp[1] = (hi + ul * ul1 * 2) & GMP_NUMB_MASK;\n\t  else\n\t    {\n\t      mp_limb_t hi1;\n#if GMP_NAIL_BITS != 0\n\t      ul <<= 1;\n#endif\n\t      umul_ppmm (hi1, lo, ul1 << GMP_NAIL_BITS, ul);\n\t      hi1 += ul * up[2];\n#if GMP_NAIL_BITS == 0\n\t      hi1 = (hi1 << 1) | (lo >> (GMP_LIMB_BITS - 1));\n\t      add_ssaaaa(rp[2], rp[1], hi1, lo << 1, ul1 * ul1, hi);\n#else\n\t      hi += lo >> GMP_NAIL_BITS;\n\t      rp[1] = hi & GMP_NUMB_MASK;\n\t      rp[2] = (hi1 + ul1 * ul1 + (hi >> GMP_NUMB_BITS)) & GMP_NUMB_MASK;\n#endif\n\t    }\n#endif\n\t}\n#endif\n    }\n  else\n    {\n      mp_limb_t tp[SQRLO_BASECASE_ALLOC];\n      mp_size_t i;\n\n      /* must fit n-1 limbs in tp */\n      ASSERT (n <= SQRLO_DC_THRESHOLD_LIMIT);\n\n      --n;\n#if SQRLO_SHORTCUT_MULTIPLICATIONS\n      {\n\tmp_limb_t cy;\n\n\tcy = ul * up[n] + mpn_mul_1 (tp, up + 1, n - 1, ul);\n\tfor (i = 1; 2 * i + 1 < n; ++i)\n\t  {\n\t    ul = up[i];\n\t    cy += ul * up[n - i] + mpn_addmul_1 (tp + 2 * i, up + i + 1, n - 2 * i - 1, ul);\n\t  }\n\ttp [n-1] = (cy + ((n & 1)?up[i] * up[i + 1]:0)) & GMP_NUMB_MASK;\n      }\n#else\n      mpn_mul_1 (tp, up + 1, n, ul);\n      for (i = 1; 2 * i < n; ++i)\n\tmpn_addmul_1 (tp + 2 * i, up + i + 1, n - 2 * i, up[i]);\n#endif\n\n      MPN_SQRLO_DIAG_ADDLSH1 (rp, tp, up, n + 1);\n    }\n}",
      "lines": 79,
      "depth": 22,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sqrmod_bnm1.c": {
    "mpn_bc_sqrmod_bnm1": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static void\nmpn_bc_sqrmod_bnm1 (mp_ptr rp, mp_srcptr ap, mp_size_t rn, mp_ptr tp)\n{\n  mp_limb_t cy;\n\n  ASSERT (0 < rn);\n\n  mpn_sqr (tp, ap, rn);\n  cy = mpn_add_n (rp, tp, tp + rn, rn);\n  /* If cy == 1, then the value of rp is at most B^rn - 2, so there can\n   * be no overflow when adding in the carry. */\n  MPN_INCR_U (rp, rn, cy);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_bc_sqrmod_bnp1": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static void\nmpn_bc_sqrmod_bnp1 (mp_ptr rp, mp_srcptr ap, mp_size_t rn, mp_ptr tp)\n{\n  mp_limb_t cy;\n\n  ASSERT (0 < rn);\n\n  mpn_sqr (tp, ap, rn + 1);\n  ASSERT (tp[2*rn+1] == 0);\n  ASSERT (tp[2*rn] < GMP_NUMB_MAX);\n  cy = tp[2*rn] + mpn_sub_n (rp, tp, tp+rn, rn);\n  rp[rn] = 0;\n  MPN_INCR_U (rp, rn+1, cy );\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_sqrmod_bnm1": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "void\nmpn_sqrmod_bnm1 (mp_ptr rp, mp_size_t rn, mp_srcptr ap, mp_size_t an, mp_ptr tp)\n{\n  ASSERT (0 < an);\n  ASSERT (an <= rn);\n\n  if ((rn & 1) != 0 || BELOW_THRESHOLD (rn, SQRMOD_BNM1_THRESHOLD))\n    {\n      if (UNLIKELY (an < rn))\n\t{\n\t  if (UNLIKELY (2*an <= rn))\n\t    {\n\t      mpn_sqr (rp, ap, an);\n\t    }\n\t  else\n\t    {\n\t      mp_limb_t cy;\n\t      mpn_sqr (tp, ap, an);\n\t      cy = mpn_add (rp, tp, rn, tp + rn, 2*an - rn);\n\t      MPN_INCR_U (rp, rn, cy);\n\t    }\n\t}\n      else\n\tmpn_bc_sqrmod_bnm1 (rp, ap, rn, tp);\n    }\n  else\n    {\n      mp_size_t n;\n      mp_limb_t cy;\n      mp_limb_t hi;\n\n      n = rn >> 1;\n\n      ASSERT (2*an > n);\n\n      /* Compute xm = a^2 mod (B^n - 1), xp = a^2 mod (B^n + 1)\n\t and crt together as\n\n\t x = -xp * B^n + (B^n + 1) * [ (xp + xm)/2 mod (B^n-1)]\n      */\n\n#define a0 ap\n#define a1 (ap + n)\n\n#define xp  tp\t/* 2n + 2 */\n      /* am1  maybe in {xp, n} */\n#define sp1 (tp + 2*n + 2)\n      /* ap1  maybe in {sp1, n + 1} */\n\n      {\n\tmp_srcptr am1;\n\tmp_size_t anm;\n\tmp_ptr so;\n\n\tif (LIKELY (an > n))\n\t  {\n\t    so = xp + n;\n\t    am1 = xp;\n\t    cy = mpn_add (xp, a0, n, a1, an - n);\n\t    MPN_INCR_U (xp, n, cy);\n\t    anm = n;\n\t  }\n\telse\n\t  {\n\t    so = xp;\n\t    am1 = a0;\n\t    anm = an;\n\t  }\n\n\tmpn_sqrmod_bnm1 (rp, n, am1, anm, so);\n      }\n\n      {\n\tint       k;\n\tmp_srcptr ap1;\n\tmp_size_t anp;\n\n\tif (LIKELY (an > n)) {\n\t  ap1 = sp1;\n\t  cy = mpn_sub (sp1, a0, n, a1, an - n);\n\t  sp1[n] = 0;\n\t  MPN_INCR_U (sp1, n + 1, cy);\n\t  anp = n + ap1[n];\n\t} else {\n\t  ap1 = a0;\n\t  anp = an;\n\t}\n\n\tif (BELOW_THRESHOLD (n, MUL_FFT_MODF_THRESHOLD))\n\t  k=0;\n\telse\n\t  {\n\t    int mask;\n\t    k = mpn_fft_best_k (n, 1);\n\t    mask = (1<<k) -1;\n\t    while (n & mask) {k--; mask >>=1;};\n\t  }\n\tif (k >= FFT_FIRST_K)\n\t  xp[n] = mpn_mul_fft (xp, n, ap1, anp, ap1, anp, k);\n\telse if (UNLIKELY (ap1 == a0))\n\t  {\n\t    ASSERT (anp <= n);\n\t    ASSERT (2*anp > n);\n\t    mpn_sqr (xp, a0, an);\n\t    anp = 2*an - n;\n\t    cy = mpn_sub (xp, xp, n, xp + n, anp);\n\t    xp[n] = 0;\n\t    MPN_INCR_U (xp, n+1, cy);\n\t  }\n\telse\n\t  mpn_bc_sqrmod_bnp1 (xp, ap1, n, xp);\n      }\n\n      /* Here the CRT recomposition begins.\n\n\t xm <- (xp + xm)/2 = (xp + xm)B^n/2 mod (B^n-1)\n\t Division by 2 is a bitwise rotation.\n\n\t Assumes xp normalised mod (B^n+1).\n\n\t The residue class [0] is represented by [B^n-1]; except when\n\t both input are ZERO.\n      */\n\n#if HAVE_NATIVE_mpn_rsh1add_n || HAVE_NATIVE_mpn_rsh1add_nc\n#if HAVE_NATIVE_mpn_rsh1add_nc\n      cy = mpn_rsh1add_nc(rp, rp, xp, n, xp[n]); /* B^n = 1 */\n      hi = cy << (GMP_NUMB_BITS - 1);\n      cy = 0;\n      /* next update of rp[n-1] will set cy = 1 only if rp[n-1]+=hi\n\t overflows, i.e. a further increment will not overflow again. */\n#else /* ! _nc */\n      cy = xp[n] + mpn_rsh1add_n(rp, rp, xp, n); /* B^n = 1 */\n      hi = (cy<<(GMP_NUMB_BITS-1))&GMP_NUMB_MASK; /* (cy&1) << ... */\n      cy >>= 1;\n      /* cy = 1 only if xp[n] = 1 i.e. {xp,n} = ZERO, this implies that\n\t the rsh1add was a simple rshift: the top bit is 0. cy=1 => hi=0. */\n#endif\n#if GMP_NAIL_BITS == 0\n      add_ssaaaa(cy, rp[n-1], cy, rp[n-1], CNST_LIMB(0), hi);\n#else\n      cy += (hi & rp[n-1]) >> (GMP_NUMB_BITS-1);\n      rp[n-1] ^= hi;\n#endif\n#else /* ! HAVE_NATIVE_mpn_rsh1add_n */\n#if HAVE_NATIVE_mpn_add_nc\n      cy = mpn_add_nc(rp, rp, xp, n, xp[n]);\n#else /* ! _nc */\n      cy = xp[n] + mpn_add_n(rp, rp, xp, n); /* xp[n] == 1 implies {xp,n} == ZERO */\n#endif\n      cy += (rp[0]&1);\n      mpn_rshift(rp, rp, n, 1);\n      ASSERT (cy <= 2);\n      hi = (cy<<(GMP_NUMB_BITS-1))&GMP_NUMB_MASK; /* (cy&1) << ... */\n      cy >>= 1;\n      /* We can have cy != 0 only if hi = 0... */\n      ASSERT ((rp[n-1] & GMP_NUMB_HIGHBIT) == 0);\n      rp[n-1] |= hi;\n      /* ... rp[n-1] + cy can not overflow, the following INCR is correct. */\n#endif\n      ASSERT (cy <= 1);\n      /* Next increment can not overflow, read the previous comments about cy. */\n      ASSERT ((cy == 0) || ((rp[n-1] & GMP_NUMB_HIGHBIT) == 0));\n      MPN_INCR_U(rp, n, cy);\n\n      /* Compute the highest half:\n\t ([(xp + xm)/2 mod (B^n-1)] - xp ) * B^n\n       */\n      if (UNLIKELY (2*an < rn))\n\t{\n\t  /* Note that in this case, the only way the result can equal\n\t     zero mod B^{rn} - 1 is if the input is zero, and\n\t     then the output of both the recursive calls and this CRT\n\t     reconstruction is zero, not B^{rn} - 1. */\n\t  cy = mpn_sub_n (rp + n, rp, xp, 2*an - n);\n\n\t  /* FIXME: This subtraction of the high parts is not really\n\t     necessary, we do it to get the carry out, and for sanity\n\t     checking. */\n\t  cy = xp[n] + mpn_sub_nc (xp + 2*an - n, rp + 2*an - n,\n\t\t\t\t   xp + 2*an - n, rn - 2*an, cy);\n\t  ASSERT (mpn_zero_p (xp + 2*an - n+1, rn - 1 - 2*an));\n\t  cy = mpn_sub_1 (rp, rp, 2*an, cy);\n\t  ASSERT (cy == (xp + 2*an - n)[0]);\n\t}\n      else\n\t{\n\t  cy = xp[n] + mpn_sub_n (rp + n, rp, xp, n);\n\t  /* cy = 1 only if {xp,n+1} is not ZERO, i.e. {rp,n} is not ZERO.\n\t     DECR will affect _at most_ the lowest n limbs. */\n\t  MPN_DECR_U (rp, 2*n, cy);\n\t}\n#undef a0\n#undef a1\n#undef xp\n#undef sp1\n    }\n}",
      "lines": 198,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "mpn_sqrmod_bnm1_next_size": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "mp_size_t\nmpn_sqrmod_bnm1_next_size (mp_size_t n)\n{\n  mp_size_t nh;\n\n  if (BELOW_THRESHOLD (n,     SQRMOD_BNM1_THRESHOLD))\n    return n;\n  if (BELOW_THRESHOLD (n, 4 * (SQRMOD_BNM1_THRESHOLD - 1) + 1))\n    return (n + (2-1)) & (-2);\n  if (BELOW_THRESHOLD (n, 8 * (SQRMOD_BNM1_THRESHOLD - 1) + 1))\n    return (n + (4-1)) & (-4);\n\n  nh = (n + 1) >> 1;\n\n  if (BELOW_THRESHOLD (nh, SQR_FFT_MODF_THRESHOLD))\n    return (n + (8-1)) & (-8);\n\n  return 2 * mpn_fft_next_size (nh, mpn_fft_best_k (nh, 1));\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sqrtrem.c": {
    "mpn_sqrtrem1": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static mp_limb_t\nmpn_sqrtrem1 (mp_ptr rp, mp_limb_t a0)\n{\n#if GMP_NUMB_BITS > 32\n  mp_limb_t a1;\n#endif\n  mp_limb_t x0, t2, t, x2;\n  unsigned abits;\n\n  ASSERT_ALWAYS (GMP_NAIL_BITS == 0);\n  ASSERT_ALWAYS (GMP_LIMB_BITS == 32 || GMP_LIMB_BITS == 64);\n  ASSERT (a0 >= GMP_NUMB_HIGHBIT / 2);\n\n  /* Use Newton iterations for approximating 1/sqrt(a) instead of sqrt(a),\n     since we can do the former without division.  As part of the last\n     iteration convert from 1/sqrt(a) to sqrt(a).  */\n\n  abits = a0 >> (GMP_LIMB_BITS - 1 - 8);\t/* extract bits for table lookup */\n  x0 = 0x100 | invsqrttab[abits - 0x80];\t/* initial 1/sqrt(a) */\n\n  /* x0 is now an 8 bits approximation of 1/sqrt(a0) */\n\n#if GMP_NUMB_BITS > 32\n  a1 = a0 >> (GMP_LIMB_BITS - 1 - 32);\n  t = (mp_limb_signed_t) (CNST_LIMB(0x2000000000000) - 0x30000 - a1 * x0 * x0) >> 16;\n  x0 = (x0 << 16) + ((mp_limb_signed_t) (x0 * t) >> (16+2));\n\n  /* x0 is now a 16 bits approximation of 1/sqrt(a0) */\n\n  t2 = x0 * (a0 >> (32-8));\n  t = t2 >> 25;\n  t = ((mp_limb_signed_t) ((a0 << 14) - t * t - MAGIC) >> (32-8));\n  x0 = t2 + ((mp_limb_signed_t) (x0 * t) >> 15);\n  x0 >>= 32;\n#else\n  t2 = x0 * (a0 >> (16-8));\n  t = t2 >> 13;\n  t = ((mp_limb_signed_t) ((a0 << 6) - t * t - MAGIC) >> (16-8));\n  x0 = t2 + ((mp_limb_signed_t) (x0 * t) >> 7);\n  x0 >>= 16;\n#endif\n\n  /* x0 is now a full limb approximation of sqrt(a0) */\n\n  x2 = x0 * x0;\n  if (x2 + 2*x0 <= a0 - 1)\n    {\n      x2 += 2*x0 + 1;\n      x0++;\n    }\n\n  *rp = a0 - x2;\n  return x0;\n}",
      "lines": 54,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_sqrtrem2": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static mp_limb_t\nmpn_sqrtrem2 (mp_ptr sp, mp_ptr rp, mp_srcptr np)\n{\n  mp_limb_t q, u, np0, sp0, rp0, q2;\n  int cc;\n\n  ASSERT (np[1] >= GMP_NUMB_HIGHBIT / 2);\n\n  np0 = np[0];\n  sp0 = mpn_sqrtrem1 (rp, np[1]);\n  rp0 = rp[0];\n  /* rp0 <= 2*sp0 < 2^(Prec + 1) */\n  rp0 = (rp0 << (Prec - 1)) + (np0 >> (Prec + 1));\n  q = rp0 / sp0;\n  /* q <= 2^Prec, if q = 2^Prec, reduce the overestimate. */\n  q -= q >> Prec;\n  /* now we have q < 2^Prec */\n  u = rp0 - q * sp0;\n  /* now we have (rp[0]<<Prec + np0>>Prec)/2 = q * sp0 + u */\n  sp0 = (sp0 << Prec) | q;\n  cc = u >> (Prec - 1);\n  rp0 = ((u << (Prec + 1)) & GMP_NUMB_MASK) + (np0 & ((CNST_LIMB (1) << (Prec + 1)) - 1));\n  /* subtract q * q from rp */\n  q2 = q * q;\n  cc -= rp0 < q2;\n  rp0 -= q2;\n  if (cc < 0)\n    {\n      rp0 += sp0;\n      cc += rp0 < sp0;\n      --sp0;\n      rp0 += sp0;\n      cc += rp0 < sp0;\n    }\n\n  rp[0] = rp0;\n  sp[0] = sp0;\n  return cc;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_dc_sqrtrem": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static mp_limb_t\nmpn_dc_sqrtrem (mp_ptr sp, mp_ptr np, mp_size_t n, mp_limb_t approx, mp_ptr scratch)\n{\n  mp_limb_t q;\t\t\t/* carry out of {sp, n} */\n  int c, b;\t\t\t/* carry out of remainder */\n  mp_size_t l, h;\n\n  ASSERT (np[2 * n - 1] >= GMP_NUMB_HIGHBIT / 2);\n\n  if (n == 1)\n    c = mpn_sqrtrem2 (sp, np, np);\n  else\n    {\n      l = n / 2;\n      h = n - l;\n      q = mpn_dc_sqrtrem (sp + l, np + 2 * l, h, 0, scratch);\n      if (q != 0)\n\tASSERT_CARRY (mpn_sub_n (np + 2 * l, np + 2 * l, sp + l, h));\n      TRACE(printf(\"tdiv_qr(,,,,%u,,%u) -> %u\\n\", (unsigned) n, (unsigned) h, (unsigned) (n - h + 1)));\n      mpn_tdiv_qr (scratch, np + l, 0, np + l, n, sp + l, h);\n      q += scratch[l];\n      c = scratch[0] & 1;\n      mpn_rshift (sp, scratch, l, 1);\n      sp[l - 1] |= (q << (GMP_NUMB_BITS - 1)) & GMP_NUMB_MASK;\n      if (UNLIKELY ((sp[0] & approx) != 0)) /* (sp[0] & mask) > 1 */\n\treturn 1; /* Remainder is non-zero */\n      q >>= 1;\n      if (c != 0)\n\tc = mpn_add_n (np + l, np + l, sp + l, h);\n      TRACE(printf(\"sqr(,,%u)\\n\", (unsigned) l));\n      mpn_sqr (np + n, sp, l);\n      b = q + mpn_sub_n (np, np, np + n, 2 * l);\n      c -= (l == h) ? b : mpn_sub_1 (np + 2 * l, np + 2 * l, 1, (mp_limb_t) b);\n\n      if (c < 0)\n\t{\n\t  q = mpn_add_1 (sp + l, sp + l, h, q);\n#if HAVE_NATIVE_mpn_addlsh1_n_ip1 || HAVE_NATIVE_mpn_addlsh1_n\n\t  c += mpn_addlsh1_n_ip1 (np, sp, n) + 2 * q;\n#else\n\t  c += mpn_addmul_1 (np, sp, n, CNST_LIMB(2)) + 2 * q;\n#endif\n\t  c -= mpn_sub_1 (np, np, n, CNST_LIMB(1));\n\t  q -= mpn_sub_1 (sp, sp, n, CNST_LIMB(1));\n\t}\n    }\n\n  return c;\n}",
      "lines": 49,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_divappr_q": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static void\nmpn_divappr_q (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_ptr scratch)\n{\n  gmp_pi1_t inv;\n  mp_limb_t qh;\n  ASSERT (dn > 2);\n  ASSERT (nn >= dn);\n  ASSERT ((dp[dn-1] & GMP_NUMB_HIGHBIT) != 0);\n\n  MPN_COPY (scratch, np, nn);\n  invert_pi1 (inv, dp[dn-1], dp[dn-2]);\n  if (BELOW_THRESHOLD (dn, DC_DIVAPPR_Q_THRESHOLD))\n    qh = mpn_sbpi1_divappr_q (qp, scratch, nn, dp, dn, inv.inv32);\n  else if (BELOW_THRESHOLD (dn, MU_DIVAPPR_Q_THRESHOLD))\n    qh = mpn_dcpi1_divappr_q (qp, scratch, nn, dp, dn, &inv);\n  else\n    {\n      mp_size_t itch = mpn_mu_divappr_q_itch (nn, dn, 0);\n      TMP_DECL;\n      TMP_MARK;\n      /* Sadly, scratch is too small. */\n      qh = mpn_mu_divappr_q (qp, np, nn, dp, dn, TMP_ALLOC_LIMBS (itch));\n      TMP_FREE;\n    }\n  qp [nn - dn] = qh;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_dc_sqrt": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        416,
        1
      ],
      "content": "static int\nmpn_dc_sqrt (mp_ptr sp, mp_srcptr np, mp_size_t n, unsigned nsh, unsigned odd)\n{\n  mp_limb_t q;\t\t\t/* carry out of {sp, n} */\n  int c;\t\t\t/* carry out of remainder */\n  mp_size_t l, h;\n  mp_ptr qp, tp, scratch;\n  TMP_DECL;\n  TMP_MARK;\n\n  ASSERT (np[2 * n - 1 - odd] != 0);\n  ASSERT (n > 4);\n  ASSERT (nsh < GMP_NUMB_BITS / 2);\n\n  l = (n - 1) / 2;\n  h = n - l;\n  ASSERT (n >= l + 2 && l + 2 >= h && h > l && l >= 1 + odd);\n  scratch = TMP_ALLOC_LIMBS (l + 2 * n + 5 - USE_DIVAPPR_Q); /* n + 2-USE_DIVAPPR_Q */\n  tp = scratch + n + 2 - USE_DIVAPPR_Q; /* n + h + 1, but tp [-1] is writable */\n  if (nsh != 0)\n    {\n      /* o is used to exactly set the lowest bits of the dividend, is it needed? */\n      int o = l > (1 + odd);\n      ASSERT_NOCARRY (mpn_lshift (tp - o, np + l - 1 - o - odd, n + h + 1 + o, 2 * nsh));\n    }\n  else\n    MPN_COPY (tp, np + l - 1 - odd, n + h + 1);\n  q = mpn_dc_sqrtrem (sp + l, tp + l + 1, h, 0, scratch);\n  if (q != 0)\n    ASSERT_CARRY (mpn_sub_n (tp + l + 1, tp + l + 1, sp + l, h));\n  qp = tp + n + 1; /* l + 2 */\n  TRACE(printf(\"div(appr)_q(,,%u,,%u) -> %u \\n\", (unsigned) n+1, (unsigned) h, (unsigned) (n + 1 - h + 1)));\n#if USE_DIVAPPR_Q\n  mpn_divappr_q (qp, tp, n + 1, sp + l, h, scratch);\n#else\n  mpn_div_q (qp, tp, n + 1, sp + l, h, scratch);\n#endif\n  q += qp [l + 1];\n  c = 1;\n  if (q > 1)\n    {\n      /* FIXME: if s!=0 we will shift later, a noop on this area. */\n      MPN_FILL (sp, l, GMP_NUMB_MAX);\n    }\n  else\n    {\n      /* FIXME: if s!=0 we will shift again later, shift just once. */\n      mpn_rshift (sp, qp + 1, l, 1);\n      sp[l - 1] |= q << (GMP_NUMB_BITS - 1);\n      if (((qp[0] >> (2 + USE_DIVAPPR_Q)) | /* < 3 + 4*USE_DIVAPPR_Q */\n\t   (qp[1] & (GMP_NUMB_MASK >> ((GMP_NUMB_BITS >> odd)- nsh - 1)))) == 0)\n\t{\n\t  mp_limb_t cy;\n\t  /* Approximation is not good enough, the extra limb(+ nsh bits)\n\t     is smaller than needed to absorb the possible error. */\n\t  /* {qp + 1, l + 1} equals 2*{sp, l} */\n\t  /* FIXME: use mullo or wrap-around, or directly evaluate\n\t     remainder with a single sqrmod_bnm1. */\n\t  TRACE(printf(\"mul(,,%u,,%u)\\n\", (unsigned) h, (unsigned) (l+1)));\n\t  ASSERT_NOCARRY (mpn_mul (scratch, sp + l, h, qp + 1, l + 1));\n\t  /* Compute the remainder of the previous mpn_div(appr)_q. */\n\t  cy = mpn_sub_n (tp + 1, tp + 1, scratch, h);\n#if USE_DIVAPPR_Q || WANT_ASSERT\n\t  MPN_DECR_U (tp + 1 + h, l, cy);\n#if USE_DIVAPPR_Q\n\t  ASSERT (mpn_cmp (tp + 1 + h, scratch + h, l) <= 0);\n\t  if (mpn_cmp (tp + 1 + h, scratch + h, l) < 0)\n\t    {\n\t      /* May happen only if div result was not exact. */\n#if HAVE_NATIVE_mpn_addlsh1_n_ip1 || HAVE_NATIVE_mpn_addlsh1_n\n\t      cy = mpn_addlsh1_n_ip1 (tp + 1, sp + l, h);\n#else\n\t      cy = mpn_addmul_1 (tp + 1, sp + l, h, CNST_LIMB(2));\n#endif\n\t      ASSERT_NOCARRY (mpn_add_1 (tp + 1 + h, tp + 1 + h, l, cy));\n\t      MPN_DECR_U (sp, l, 1);\n\t    }\n\t  /* Can the root be exact when a correction was needed? We\n\t     did not find an example, but it depends on divappr\n\t     internals, and we can not assume it true in general...*/\n\t  /* else */\n#else /* WANT_ASSERT */\n\t  ASSERT (mpn_cmp (tp + 1 + h, scratch + h, l) == 0);\n#endif\n#endif\n\t  if (mpn_zero_p (tp + l + 1, h - l))\n\t    {\n\t      TRACE(printf(\"sqr(,,%u)\\n\", (unsigned) l));\n\t      mpn_sqr (scratch, sp, l);\n\t      c = mpn_cmp (tp + 1, scratch + l, l);\n\t      if (c == 0)\n\t\t{\n\t\t  if (nsh != 0)\n\t\t    {\n\t\t      mpn_lshift (tp, np, l, 2 * nsh);\n\t\t      np = tp;\n\t\t    }\n\t\t  c = mpn_cmp (np, scratch + odd, l - odd);\n\t\t}\n\t      if (c < 0)\n\t\t{\n\t\t  MPN_DECR_U (sp, l, 1);\n\t\t  c = 1;\n\t\t}\n\t    }\n\t}\n    }\n  TMP_FREE;\n\n  if ((odd | nsh) != 0)\n    mpn_rshift (sp, sp, n, nsh + (odd ? GMP_NUMB_BITS / 2 : 0));\n  return c;\n}",
      "lines": 113,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpn_sqrtrem": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        518,
        1
      ],
      "content": "mp_size_t\nmpn_sqrtrem (mp_ptr sp, mp_ptr rp, mp_srcptr np, mp_size_t nn)\n{\n  mp_limb_t *tp, s0[1], cc, high, rl;\n  int c;\n  mp_size_t rn, tn;\n  TMP_DECL;\n\n  ASSERT (nn > 0);\n  ASSERT_MPN (np, nn);\n\n  ASSERT (np[nn - 1] != 0);\n  ASSERT (rp == NULL || MPN_SAME_OR_SEPARATE_P (np, rp, nn));\n  ASSERT (rp == NULL || ! MPN_OVERLAP_P (sp, (nn + 1) / 2, rp, nn));\n  ASSERT (! MPN_OVERLAP_P (sp, (nn + 1) / 2, np, nn));\n\n  high = np[nn - 1];\n  if (high & (GMP_NUMB_HIGHBIT | (GMP_NUMB_HIGHBIT / 2)))\n    c = 0;\n  else\n    {\n      count_leading_zeros (c, high);\n      c -= GMP_NAIL_BITS;\n\n      c = c / 2; /* we have to shift left by 2c bits to normalize {np, nn} */\n    }\n  if (nn == 1) {\n    if (c == 0)\n      {\n\tsp[0] = mpn_sqrtrem1 (&rl, high);\n\tif (rp != NULL)\n\t  rp[0] = rl;\n      }\n    else\n      {\n\tcc = mpn_sqrtrem1 (&rl, high << (2*c)) >> c;\n\tsp[0] = cc;\n\tif (rp != NULL)\n\t  rp[0] = rl = high - cc*cc;\n      }\n    return rl != 0;\n  }\n  tn = (nn + 1) / 2; /* 2*tn is the smallest even integer >= nn */\n\n  if ((rp == NULL) && (nn > 8))\n    return mpn_dc_sqrt (sp, np, tn, c, nn & 1);\n  TMP_MARK;\n  if (((nn & 1) | c) != 0)\n    {\n      mp_limb_t mask;\n      mp_ptr scratch;\n      TMP_ALLOC_LIMBS_2 (tp, 2 * tn, scratch, tn / 2 + 1);\n      tp[0] = 0;\t     /* needed only when 2*tn > nn, but saves a test */\n      if (c != 0)\n\tmpn_lshift (tp + (nn & 1), np, nn, 2 * c);\n      else\n\tMPN_COPY (tp + (nn & 1), np, nn);\n      c += (nn & 1) ? GMP_NUMB_BITS / 2 : 0;\t\t/* c now represents k */\n      mask = (CNST_LIMB (1) << c) - 1;\n      rl = mpn_dc_sqrtrem (sp, tp, tn, (rp == NULL) ? mask - 1 : 0, scratch);\n      /* We have 2^(2k)*N = S^2 + R where k = c + (2tn-nn)*GMP_NUMB_BITS/2,\n\t thus 2^(2k)*N = (S-s0)^2 + 2*S*s0 - s0^2 + R where s0=S mod 2^k */\n      s0[0] = sp[0] & mask;\t/* S mod 2^k */\n      rl += mpn_addmul_1 (tp, sp, tn, 2 * s0[0]);\t/* R = R + 2*s0*S */\n      cc = mpn_submul_1 (tp, s0, 1, s0[0]);\n      rl -= (tn > 1) ? mpn_sub_1 (tp + 1, tp + 1, tn - 1, cc) : cc;\n      mpn_rshift (sp, sp, tn, c);\n      tp[tn] = rl;\n      if (rp == NULL)\n\trp = tp;\n      c = c << 1;\n      if (c < GMP_NUMB_BITS)\n\ttn++;\n      else\n\t{\n\t  tp++;\n\t  c -= GMP_NUMB_BITS;\n\t}\n      if (c != 0)\n\tmpn_rshift (rp, tp, tn, c);\n      else\n\tMPN_COPY_INCR (rp, tp, tn);\n      rn = tn;\n    }\n  else\n    {\n      if (rp != np)\n\t{\n\t  if (rp == NULL) /* nn <= 8 */\n\t    rp = TMP_SALLOC_LIMBS (nn);\n\t  MPN_COPY (rp, np, nn);\n\t}\n      rn = tn + (rp[tn] = mpn_dc_sqrtrem (sp, rp, tn, 0, TMP_ALLOC_LIMBS(tn / 2 + 1)));\n    }\n\n  MPN_NORMALIZE (rp, rn);\n\n  TMP_FREE;\n  return rn;\n}",
      "lines": 100,
      "depth": 16,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sqr_basecase.c": {
    "mpn_sqr_basecase": [
      {
        "start_point": [
          87,
          0
        ],
        "end_point": [
          143,
          1
        ],
        "content": "void\nmpn_sqr_basecase (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  mp_size_t i;\n  mp_limb_t tarr[2 * SQR_TOOM2_THRESHOLD];\n  mp_ptr tp = tarr;\n  mp_limb_t cy;\n\n  /* must fit 2*n limbs in tarr */\n  ASSERT (n <= SQR_TOOM2_THRESHOLD);\n\n  if ((n & 1) != 0)\n    {\n      if (n == 1)\n\t{\n\t  mp_limb_t ul, lpl;\n\t  ul = up[0];\n\t  umul_ppmm (rp[1], lpl, ul, ul << GMP_NAIL_BITS);\n\t  rp[0] = lpl >> GMP_NAIL_BITS;\n\t  return;\n\t}\n\n      MPN_ZERO (tp, n);\n\n      for (i = 0; i <= n - 2; i += 2)\n\t{\n\t  cy = mpn_addmul_2s (tp + 2 * i, up + i + 1, n - (i + 1), up + i);\n\t  tp[n + i] = cy;\n\t}\n    }\n  else\n    {\n      if (n == 2)\n\t{\n#if HAVE_NATIVE_mpn_mul_2\n\t  rp[3] = mpn_mul_2 (rp, up, 2, up);\n#else\n\t  rp[0] = 0;\n\t  rp[1] = 0;\n\t  rp[3] = mpn_addmul_2 (rp, up, 2, up);\n#endif\n\t  return;\n\t}\n\n      MPN_ZERO (tp, n);\n\n      for (i = 0; i <= n - 4; i += 2)\n\t{\n\t  cy = mpn_addmul_2s (tp + 2 * i, up + i + 1, n - (i + 1), up + i);\n\t  tp[n + i] = cy;\n\t}\n      cy = mpn_addmul_1 (tp + 2 * n - 4, up + n - 1, 1, up[n - 2]);\n      tp[2 * n - 3] = cy;\n    }\n\n  MPN_SQR_DIAG_ADDLSH1 (rp, tp, up, n);\n}",
        "lines": 57,
        "depth": 14,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          165,
          0
        ],
        "end_point": [
          280,
          1
        ],
        "content": "void\nmpn_sqr_basecase (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  mp_size_t i;\n  mp_limb_t tarr[2 * SQR_TOOM2_THRESHOLD];\n  mp_ptr tp = tarr;\n  mp_limb_t cy;\n\n  /* must fit 2*n limbs in tarr */\n  ASSERT (n <= SQR_TOOM2_THRESHOLD);\n\n  if ((n & 1) != 0)\n    {\n      mp_limb_t x0, x1;\n\n      if (n == 1)\n\t{\n\t  mp_limb_t ul, lpl;\n\t  ul = up[0];\n\t  umul_ppmm (rp[1], lpl, ul, ul << GMP_NAIL_BITS);\n\t  rp[0] = lpl >> GMP_NAIL_BITS;\n\t  return;\n\t}\n\n      /* The code below doesn't like unnormalized operands.  Since such\n\t operands are unusual, handle them with a dumb recursion.  */\n      if (up[n - 1] == 0)\n\t{\n\t  rp[2 * n - 2] = 0;\n\t  rp[2 * n - 1] = 0;\n\t  mpn_sqr_basecase (rp, up, n - 1);\n\t  return;\n\t}\n\n      MPN_ZERO (tp, n);\n\n      for (i = 0; i <= n - 2; i += 2)\n\t{\n\t  cy = mpn_addmul_2 (tp + 2 * i, up + i + 1, n - (i + 1), up + i);\n\t  tp[n + i] = cy;\n\t}\n\n      MPN_SQR_DIAGONAL (rp, up, n);\n\n      for (i = 2;; i += 4)\n\t{\n\t  x0 = rp[i + 0];\n\t  rp[i + 0] = (-x0) & GMP_NUMB_MASK;\n\t  x1 = rp[i + 1];\n\t  rp[i + 1] = (-x1 - (x0 != 0)) & GMP_NUMB_MASK;\n\t  __GMPN_SUB_1 (cy, rp + i + 2, rp + i + 2, 2, (x1 | x0) != 0);\n\t  if (i + 4 >= 2 * n)\n\t    break;\n\t  mpn_incr_u (rp + i + 4, cy);\n\t}\n    }\n  else\n    {\n      mp_limb_t x0, x1;\n\n      if (n == 2)\n\t{\n#if HAVE_NATIVE_mpn_mul_2\n\t  rp[3] = mpn_mul_2 (rp, up, 2, up);\n#else\n\t  rp[0] = 0;\n\t  rp[1] = 0;\n\t  rp[3] = mpn_addmul_2 (rp, up, 2, up);\n#endif\n\t  return;\n\t}\n\n      /* The code below doesn't like unnormalized operands.  Since such\n\t operands are unusual, handle them with a dumb recursion.  */\n      if (up[n - 1] == 0)\n\t{\n\t  rp[2 * n - 2] = 0;\n\t  rp[2 * n - 1] = 0;\n\t  mpn_sqr_basecase (rp, up, n - 1);\n\t  return;\n\t}\n\n      MPN_ZERO (tp, n);\n\n      for (i = 0; i <= n - 4; i += 2)\n\t{\n\t  cy = mpn_addmul_2 (tp + 2 * i, up + i + 1, n - (i + 1), up + i);\n\t  tp[n + i] = cy;\n\t}\n      cy = mpn_addmul_1 (tp + 2 * n - 4, up + n - 1, 1, up[n - 2]);\n      tp[2 * n - 3] = cy;\n\n      MPN_SQR_DIAGONAL (rp, up, n);\n\n      for (i = 2;; i += 4)\n\t{\n\t  x0 = rp[i + 0];\n\t  rp[i + 0] = (-x0) & GMP_NUMB_MASK;\n\t  x1 = rp[i + 1];\n\t  rp[i + 1] = (-x1 - (x0 != 0)) & GMP_NUMB_MASK;\n\t  if (i + 6 >= 2 * n)\n\t    break;\n\t  __GMPN_SUB_1 (cy, rp + i + 2, rp + i + 2, 2, (x1 | x0) != 0);\n\t  mpn_incr_u (rp + i + 4, cy);\n\t}\n      mpn_decr_u (rp + i + 2, (x1 | x0) != 0);\n    }\n\n#if HAVE_NATIVE_mpn_addlsh1_n\n  cy = mpn_addlsh1_n (rp + 1, rp + 1, tp, 2 * n - 2);\n#else\n  cy = mpn_lshift (tp, tp, 2 * n - 2, 1);\n  cy += mpn_add_n (rp + 1, rp + 1, tp, 2 * n - 2);\n#endif\n  rp[2 * n - 1] += cy;\n}",
        "lines": 116,
        "depth": 14,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          289,
          0
        ],
        "end_point": [
          323,
          1
        ],
        "content": "void\nmpn_sqr_basecase (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  mp_size_t i;\n\n  ASSERT (n >= 1);\n  ASSERT (! MPN_OVERLAP_P (rp, 2*n, up, n));\n\n  {\n    mp_limb_t ul, lpl;\n    ul = up[0];\n    umul_ppmm (rp[1], lpl, ul, ul << GMP_NAIL_BITS);\n    rp[0] = lpl >> GMP_NAIL_BITS;\n  }\n  if (n > 1)\n    {\n      mp_limb_t tarr[2 * SQR_TOOM2_THRESHOLD];\n      mp_ptr tp = tarr;\n      mp_limb_t cy;\n\n      /* must fit 2*n limbs in tarr */\n      ASSERT (n <= SQR_TOOM2_THRESHOLD);\n\n      cy = mpn_mul_1 (tp, up + 1, n - 1, up[0]);\n      tp[n - 1] = cy;\n      for (i = 2; i < n; i++)\n\t{\n\t  mp_limb_t cy;\n\t  cy = mpn_addmul_1 (tp + 2 * i - 2, up + i, n - i, up[i - 1]);\n\t  tp[n + i - 2] = cy;\n\t}\n\n      MPN_SQR_DIAG_ADDLSH1 (rp, tp, up, n);\n    }\n}",
        "lines": 35,
        "depth": 14,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/sub.c": {},
  "gmp/gmp-6.1.2/mpn/generic/submul_1.c": {
    "mpn_submul_1": [
      {
        "start_point": [
          40,
          0
        ],
        "end_point": [
          65,
          1
        ],
        "content": "mp_limb_t\nmpn_submul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl, rl;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      rl = *rp;\n      lpl = rl - lpl;\n      cl += lpl > rl;\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}",
        "lines": 26,
        "depth": 10,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          71,
          0
        ],
        "end_point": [
          101,
          1
        ],
        "content": "mp_limb_t\nmpn_submul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t shifted_vl, ul, rl, lpl, hpl, prev_hpl, cl, xl, c1, c2, c3;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT_MPN (rp, n);\n  ASSERT_MPN (up, n);\n  ASSERT_LIMB (vl);\n\n  shifted_vl = vl << GMP_NAIL_BITS;\n  cl = 0;\n  prev_hpl = 0;\n  do\n    {\n      ul = *up++;\n      rl = *rp;\n      umul_ppmm (hpl, lpl, ul, shifted_vl);\n      lpl >>= GMP_NAIL_BITS;\n      SUBC_LIMB (c1, xl, rl, prev_hpl);\n      SUBC_LIMB (c2, xl, xl, lpl);\n      SUBC_LIMB (c3, xl, xl, cl);\n      cl = c1 + c2 + c3;\n      *rp++ = xl;\n      prev_hpl = hpl;\n    }\n  while (--n != 0);\n\n  return prev_hpl + cl;\n}",
        "lines": 31,
        "depth": 9,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          107,
          0
        ],
        "end_point": [
          136,
          1
        ],
        "content": "mp_limb_t\nmpn_submul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t shifted_vl, ul, rl, lpl, hpl, prev_hpl, xw, cl, xl;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT_MPN (rp, n);\n  ASSERT_MPN (up, n);\n  ASSERT_LIMB (vl);\n\n  shifted_vl = vl << GMP_NAIL_BITS;\n  cl = 0;\n  prev_hpl = 0;\n  do\n    {\n      ul = *up++;\n      rl = *rp;\n      umul_ppmm (hpl, lpl, ul, shifted_vl);\n      lpl >>= GMP_NAIL_BITS;\n      xw = rl - (prev_hpl + lpl) + cl;\n      cl = (mp_limb_signed_t) xw >> GMP_NUMB_BITS; /* FIXME: non-portable */\n      xl = xw & GMP_NUMB_MASK;\n      *rp++ = xl;\n      prev_hpl = hpl;\n    }\n  while (--n != 0);\n\n  return prev_hpl - cl;\n}",
        "lines": 30,
        "depth": 11,
        "decorators": [
          "mp_limb_t"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/sub_1.c": {},
  "gmp/gmp-6.1.2/mpn/generic/sub_err1_n.c": {
    "mpn_sub_err1_n": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "mp_limb_t\nmpn_sub_err1_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n\t\tmp_ptr ep, mp_srcptr yp,\n                mp_size_t n, mp_limb_t cy)\n{\n  mp_limb_t el, eh, ul, vl, yl, zl, rl, sl, cy1, cy2;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, vp, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 2, up, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 2, vp, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 2, yp, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 2, rp, n));\n\n  yp += n - 1;\n  el = eh = 0;\n\n  do\n    {\n      yl = *yp--;\n      ul = *up++;\n      vl = *vp++;\n\n      /* ordinary sub_n */\n      SUBC_LIMB (cy1, sl, ul, vl);\n      SUBC_LIMB (cy2, rl, sl, cy);\n      cy = cy1 | cy2;\n      *rp++ = rl;\n\n      /* update (eh:el) */\n      zl = (-cy) & yl;\n      el += zl;\n      eh += el < zl;\n    }\n  while (--n);\n\n#if GMP_NAIL_BITS != 0\n  eh = (eh << GMP_NAIL_BITS) + (el >> GMP_NUMB_BITS);\n  el &= GMP_NUMB_MASK;\n#endif\n\n  ep[0] = el;\n  ep[1] = eh;\n\n  return cy;\n}",
      "lines": 48,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sub_err2_n.c": {
    "mpn_sub_err2_n": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "mp_limb_t\nmpn_sub_err2_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n                mp_ptr ep, mp_srcptr yp1, mp_srcptr yp2,\n                mp_size_t n, mp_limb_t cy)\n{\n  mp_limb_t el1, eh1, el2, eh2, ul, vl, yl1, yl2, zl1, zl2, rl, sl, cy1, cy2;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, vp, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp1, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp2, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 4, up, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 4, vp, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 4, yp1, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 4, yp2, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 4, rp, n));\n\n  yp1 += n - 1;\n  yp2 += n - 1;\n  el1 = eh1 = 0;\n  el2 = eh2 = 0;\n\n  do\n    {\n      yl1 = *yp1--;\n      yl2 = *yp2--;\n      ul = *up++;\n      vl = *vp++;\n\n      /* ordinary sub_n */\n      SUBC_LIMB (cy1, sl, ul, vl);\n      SUBC_LIMB (cy2, rl, sl, cy);\n      cy = cy1 | cy2;\n      *rp++ = rl;\n\n      /* update (eh1:el1) */\n      zl1 = (-cy) & yl1;\n      el1 += zl1;\n      eh1 += el1 < zl1;\n\n      /* update (eh2:el2) */\n      zl2 = (-cy) & yl2;\n      el2 += zl2;\n      eh2 += el2 < zl2;\n    }\n  while (--n);\n\n#if GMP_NAIL_BITS != 0\n  eh1 = (eh1 << GMP_NAIL_BITS) + (el1 >> GMP_NUMB_BITS);\n  el1 &= GMP_NUMB_MASK;\n  eh2 = (eh2 << GMP_NAIL_BITS) + (el2 >> GMP_NUMB_BITS);\n  el2 &= GMP_NUMB_MASK;\n#endif\n\n  ep[0] = el1;\n  ep[1] = eh1;\n  ep[2] = el2;\n  ep[3] = eh2;\n\n  return cy;\n}",
      "lines": 62,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sub_err3_n.c": {
    "mpn_sub_err3_n": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "mp_limb_t\nmpn_sub_err3_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n                mp_ptr ep, mp_srcptr yp1, mp_srcptr yp2, mp_srcptr yp3,\n                mp_size_t n, mp_limb_t cy)\n{\n  mp_limb_t el1, eh1, el2, eh2, el3, eh3, ul, vl, yl1, yl2, yl3, zl1, zl2, zl3, rl, sl, cy1, cy2;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_SEPARATE_P (rp, vp, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp1, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp2, n));\n  ASSERT (! MPN_OVERLAP_P (rp, n, yp3, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, up, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, vp, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, yp1, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, yp2, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, yp3, n));\n  ASSERT (! MPN_OVERLAP_P (ep, 6, rp, n));\n\n  yp1 += n - 1;\n  yp2 += n - 1;\n  yp3 += n - 1;\n  el1 = eh1 = 0;\n  el2 = eh2 = 0;\n  el3 = eh3 = 0;\n\n  do\n    {\n      yl1 = *yp1--;\n      yl2 = *yp2--;\n      yl3 = *yp3--;\n      ul = *up++;\n      vl = *vp++;\n\n      /* ordinary sub_n */\n      SUBC_LIMB (cy1, sl, ul, vl);\n      SUBC_LIMB (cy2, rl, sl, cy);\n      cy = cy1 | cy2;\n      *rp++ = rl;\n\n      /* update (eh1:el1) */\n      zl1 = (-cy) & yl1;\n      el1 += zl1;\n      eh1 += el1 < zl1;\n\n      /* update (eh2:el2) */\n      zl2 = (-cy) & yl2;\n      el2 += zl2;\n      eh2 += el2 < zl2;\n\n      /* update (eh3:el3) */\n      zl3 = (-cy) & yl3;\n      el3 += zl3;\n      eh3 += el3 < zl3;\n    }\n  while (--n);\n\n#if GMP_NAIL_BITS != 0\n  eh1 = (eh1 << GMP_NAIL_BITS) + (el1 >> GMP_NUMB_BITS);\n  el1 &= GMP_NUMB_MASK;\n  eh2 = (eh2 << GMP_NAIL_BITS) + (el2 >> GMP_NUMB_BITS);\n  el2 &= GMP_NUMB_MASK;\n  eh3 = (eh3 << GMP_NAIL_BITS) + (el3 >> GMP_NUMB_BITS);\n  el3 &= GMP_NUMB_MASK;\n#endif\n\n  ep[0] = el1;\n  ep[1] = eh1;\n  ep[2] = el2;\n  ep[3] = eh2;\n  ep[4] = el3;\n  ep[5] = eh3;\n\n  return cy;\n}",
      "lines": 76,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/sub_n.c": {
    "mpn_sub_n": [
      {
        "start_point": [
          36,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "mp_limb_t\nmpn_sub_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_limb_t ul, vl, sl, rl, cy, cy1, cy2;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_INCR_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_INCR_P (rp, vp, n));\n\n  cy = 0;\n  do\n    {\n      ul = *up++;\n      vl = *vp++;\n      sl = ul - vl;\n      cy1 = sl > ul;\n      rl = sl - cy;\n      cy2 = rl > sl;\n      cy = cy1 | cy2;\n      *rp++ = rl;\n    }\n  while (--n != 0);\n\n  return cy;\n}",
        "lines": 25,
        "depth": 9,
        "decorators": [
          "mp_limb_t"
        ]
      },
      {
        "start_point": [
          66,
          0
        ],
        "end_point": [
          87,
          1
        ],
        "content": "mp_limb_t\nmpn_sub_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_limb_t ul, vl, rl, cy;\n\n  ASSERT (n >= 1);\n  ASSERT (MPN_SAME_OR_INCR_P (rp, up, n));\n  ASSERT (MPN_SAME_OR_INCR_P (rp, vp, n));\n\n  cy = 0;\n  do\n    {\n      ul = *up++;\n      vl = *vp++;\n      rl = ul - vl - cy;\n      cy = rl >> (GMP_LIMB_BITS - 1);\n      *rp++ = rl & GMP_NUMB_MASK;\n    }\n  while (--n != 0);\n\n  return cy;\n}",
        "lines": 22,
        "depth": 10,
        "decorators": [
          "mp_limb_t"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/mpn/generic/tdiv_qr.c": {
    "mpn_tdiv_qr": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "void\nmpn_tdiv_qr (mp_ptr qp, mp_ptr rp, mp_size_t qxn,\n\t     mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)\n{\n  ASSERT_ALWAYS (qxn == 0);\n\n  ASSERT (nn >= 0);\n  ASSERT (dn >= 0);\n  ASSERT (dn == 0 || dp[dn - 1] != 0);\n  ASSERT (! MPN_OVERLAP_P (qp, nn - dn + 1 + qxn, np, nn));\n  ASSERT (! MPN_OVERLAP_P (qp, nn - dn + 1 + qxn, dp, dn));\n\n  switch (dn)\n    {\n    case 0:\n      DIVIDE_BY_ZERO;\n\n    case 1:\n      {\n\trp[0] = mpn_divrem_1 (qp, (mp_size_t) 0, np, nn, dp[0]);\n\treturn;\n      }\n\n    case 2:\n      {\n\tmp_ptr n2p, d2p;\n\tmp_limb_t qhl, cy;\n\tTMP_DECL;\n\tTMP_MARK;\n\tif ((dp[1] & GMP_NUMB_HIGHBIT) == 0)\n\t  {\n\t    int cnt;\n\t    mp_limb_t dtmp[2];\n\t    count_leading_zeros (cnt, dp[1]);\n\t    cnt -= GMP_NAIL_BITS;\n\t    d2p = dtmp;\n\t    d2p[1] = (dp[1] << cnt) | (dp[0] >> (GMP_NUMB_BITS - cnt));\n\t    d2p[0] = (dp[0] << cnt) & GMP_NUMB_MASK;\n\t    n2p = TMP_ALLOC_LIMBS (nn + 1);\n\t    cy = mpn_lshift (n2p, np, nn, cnt);\n\t    n2p[nn] = cy;\n\t    qhl = mpn_divrem_2 (qp, 0L, n2p, nn + (cy != 0), d2p);\n\t    if (cy == 0)\n\t      qp[nn - 2] = qhl;\t/* always store nn-2+1 quotient limbs */\n\t    rp[0] = (n2p[0] >> cnt)\n\t      | ((n2p[1] << (GMP_NUMB_BITS - cnt)) & GMP_NUMB_MASK);\n\t    rp[1] = (n2p[1] >> cnt);\n\t  }\n\telse\n\t  {\n\t    d2p = (mp_ptr) dp;\n\t    n2p = TMP_ALLOC_LIMBS (nn);\n\t    MPN_COPY (n2p, np, nn);\n\t    qhl = mpn_divrem_2 (qp, 0L, n2p, nn, d2p);\n\t    qp[nn - 2] = qhl;\t/* always store nn-2+1 quotient limbs */\n\t    rp[0] = n2p[0];\n\t    rp[1] = n2p[1];\n\t  }\n\tTMP_FREE;\n\treturn;\n      }\n\n    default:\n      {\n\tint adjust;\n\tgmp_pi1_t dinv;\n\tTMP_DECL;\n\tTMP_MARK;\n\tadjust = np[nn - 1] >= dp[dn - 1];\t/* conservative tests for quotient size */\n\tif (nn + adjust >= 2 * dn)\n\t  {\n\t    mp_ptr n2p, d2p;\n\t    mp_limb_t cy;\n\t    int cnt;\n\n\t    qp[nn - dn] = 0;\t\t\t  /* zero high quotient limb */\n\t    if ((dp[dn - 1] & GMP_NUMB_HIGHBIT) == 0) /* normalize divisor */\n\t      {\n\t\tcount_leading_zeros (cnt, dp[dn - 1]);\n\t\tcnt -= GMP_NAIL_BITS;\n\t\td2p = TMP_ALLOC_LIMBS (dn);\n\t\tmpn_lshift (d2p, dp, dn, cnt);\n\t\tn2p = TMP_ALLOC_LIMBS (nn + 1);\n\t\tcy = mpn_lshift (n2p, np, nn, cnt);\n\t\tn2p[nn] = cy;\n\t\tnn += adjust;\n\t      }\n\t    else\n\t      {\n\t\tcnt = 0;\n\t\td2p = (mp_ptr) dp;\n\t\tn2p = TMP_ALLOC_LIMBS (nn + 1);\n\t\tMPN_COPY (n2p, np, nn);\n\t\tn2p[nn] = 0;\n\t\tnn += adjust;\n\t      }\n\n\t    invert_pi1 (dinv, d2p[dn - 1], d2p[dn - 2]);\n\t    if (BELOW_THRESHOLD (dn, DC_DIV_QR_THRESHOLD))\n\t      mpn_sbpi1_div_qr (qp, n2p, nn, d2p, dn, dinv.inv32);\n\t    else if (BELOW_THRESHOLD (dn, MUPI_DIV_QR_THRESHOLD) ||   /* fast condition */\n\t\t     BELOW_THRESHOLD (nn, 2 * MU_DIV_QR_THRESHOLD) || /* fast condition */\n\t\t     (double) (2 * (MU_DIV_QR_THRESHOLD - MUPI_DIV_QR_THRESHOLD)) * dn /* slow... */\n\t\t     + (double) MUPI_DIV_QR_THRESHOLD * nn > (double) dn * nn)    /* ...condition */\n\t      mpn_dcpi1_div_qr (qp, n2p, nn, d2p, dn, &dinv);\n\t    else\n\t      {\n\t\tmp_size_t itch = mpn_mu_div_qr_itch (nn, dn, 0);\n\t\tmp_ptr scratch = TMP_ALLOC_LIMBS (itch);\n\t\tmpn_mu_div_qr (qp, rp, n2p, nn, d2p, dn, scratch);\n\t\tn2p = rp;\n\t      }\n\n\t    if (cnt != 0)\n\t      mpn_rshift (rp, n2p, dn, cnt);\n\t    else\n\t      MPN_COPY (rp, n2p, dn);\n\t    TMP_FREE;\n\t    return;\n\t  }\n\n\t/* When we come here, the numerator/partial remainder is less\n\t   than twice the size of the denominator.  */\n\n\t  {\n\t    /* Problem:\n\n\t       Divide a numerator N with nn limbs by a denominator D with dn\n\t       limbs forming a quotient of qn=nn-dn+1 limbs.  When qn is small\n\t       compared to dn, conventional division algorithms perform poorly.\n\t       We want an algorithm that has an expected running time that is\n\t       dependent only on qn.\n\n\t       Algorithm (very informally stated):\n\n\t       1) Divide the 2 x qn most significant limbs from the numerator\n\t\t  by the qn most significant limbs from the denominator.  Call\n\t\t  the result qest.  This is either the correct quotient, but\n\t\t  might be 1 or 2 too large.  Compute the remainder from the\n\t\t  division.  (This step is implemented by an mpn_divrem call.)\n\n\t       2) Is the most significant limb from the remainder < p, where p\n\t\t  is the product of the most significant limb from the quotient\n\t\t  and the next(d)?  (Next(d) denotes the next ignored limb from\n\t\t  the denominator.)  If it is, decrement qest, and adjust the\n\t\t  remainder accordingly.\n\n\t       3) Is the remainder >= qest?  If it is, qest is the desired\n\t\t  quotient.  The algorithm terminates.\n\n\t       4) Subtract qest x next(d) from the remainder.  If there is\n\t\t  borrow out, decrement qest, and adjust the remainder\n\t\t  accordingly.\n\n\t       5) Skip one word from the denominator (i.e., let next(d) denote\n\t\t  the next less significant limb.  */\n\n\t    mp_size_t qn;\n\t    mp_ptr n2p, d2p;\n\t    mp_ptr tp;\n\t    mp_limb_t cy;\n\t    mp_size_t in, rn;\n\t    mp_limb_t quotient_too_large;\n\t    unsigned int cnt;\n\n\t    qn = nn - dn;\n\t    qp[qn] = 0;\t\t\t\t/* zero high quotient limb */\n\t    qn += adjust;\t\t\t/* qn cannot become bigger */\n\n\t    if (qn == 0)\n\t      {\n\t\tMPN_COPY (rp, np, dn);\n\t\tTMP_FREE;\n\t\treturn;\n\t      }\n\n\t    in = dn - qn;\t\t/* (at least partially) ignored # of limbs in ops */\n\t    /* Normalize denominator by shifting it to the left such that its\n\t       most significant bit is set.  Then shift the numerator the same\n\t       amount, to mathematically preserve quotient.  */\n\t    if ((dp[dn - 1] & GMP_NUMB_HIGHBIT) == 0)\n\t      {\n\t\tcount_leading_zeros (cnt, dp[dn - 1]);\n\t\tcnt -= GMP_NAIL_BITS;\n\n\t\td2p = TMP_ALLOC_LIMBS (qn);\n\t\tmpn_lshift (d2p, dp + in, qn, cnt);\n\t\td2p[0] |= dp[in - 1] >> (GMP_NUMB_BITS - cnt);\n\n\t\tn2p = TMP_ALLOC_LIMBS (2 * qn + 1);\n\t\tcy = mpn_lshift (n2p, np + nn - 2 * qn, 2 * qn, cnt);\n\t\tif (adjust)\n\t\t  {\n\t\t    n2p[2 * qn] = cy;\n\t\t    n2p++;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    n2p[0] |= np[nn - 2 * qn - 1] >> (GMP_NUMB_BITS - cnt);\n\t\t  }\n\t      }\n\t    else\n\t      {\n\t\tcnt = 0;\n\t\td2p = (mp_ptr) dp + in;\n\n\t\tn2p = TMP_ALLOC_LIMBS (2 * qn + 1);\n\t\tMPN_COPY (n2p, np + nn - 2 * qn, 2 * qn);\n\t\tif (adjust)\n\t\t  {\n\t\t    n2p[2 * qn] = 0;\n\t\t    n2p++;\n\t\t  }\n\t      }\n\n\t    /* Get an approximate quotient using the extracted operands.  */\n\t    if (qn == 1)\n\t      {\n\t\tmp_limb_t q0, r0;\n\t\tudiv_qrnnd (q0, r0, n2p[1], n2p[0] << GMP_NAIL_BITS, d2p[0] << GMP_NAIL_BITS);\n\t\tn2p[0] = r0 >> GMP_NAIL_BITS;\n\t\tqp[0] = q0;\n\t      }\n\t    else if (qn == 2)\n\t      mpn_divrem_2 (qp, 0L, n2p, 4L, d2p); /* FIXME: obsolete function */\n\t    else\n\t      {\n\t\tinvert_pi1 (dinv, d2p[qn - 1], d2p[qn - 2]);\n\t\tif (BELOW_THRESHOLD (qn, DC_DIV_QR_THRESHOLD))\n\t\t  mpn_sbpi1_div_qr (qp, n2p, 2 * qn, d2p, qn, dinv.inv32);\n\t\telse if (BELOW_THRESHOLD (qn, MU_DIV_QR_THRESHOLD))\n\t\t  mpn_dcpi1_div_qr (qp, n2p, 2 * qn, d2p, qn, &dinv);\n\t\telse\n\t\t  {\n\t\t    mp_size_t itch = mpn_mu_div_qr_itch (2 * qn, qn, 0);\n\t\t    mp_ptr scratch = TMP_ALLOC_LIMBS (itch);\n\t\t    mp_ptr r2p = rp;\n\t\t    if (np == r2p)\t/* If N and R share space, put ... */\n\t\t      r2p += nn - qn;\t/* intermediate remainder at N's upper end. */\n\t\t    mpn_mu_div_qr (qp, r2p, n2p, 2 * qn, d2p, qn, scratch);\n\t\t    MPN_COPY (n2p, r2p, qn);\n\t\t  }\n\t      }\n\n\t    rn = qn;\n\t    /* Multiply the first ignored divisor limb by the most significant\n\t       quotient limb.  If that product is > the partial remainder's\n\t       most significant limb, we know the quotient is too large.  This\n\t       test quickly catches most cases where the quotient is too large;\n\t       it catches all cases where the quotient is 2 too large.  */\n\t    {\n\t      mp_limb_t dl, x;\n\t      mp_limb_t h, dummy;\n\n\t      if (in - 2 < 0)\n\t\tdl = 0;\n\t      else\n\t\tdl = dp[in - 2];\n\n#if GMP_NAIL_BITS == 0\n\t      x = (dp[in - 1] << cnt) | ((dl >> 1) >> ((~cnt) % GMP_LIMB_BITS));\n#else\n\t      x = (dp[in - 1] << cnt) & GMP_NUMB_MASK;\n\t      if (cnt != 0)\n\t\tx |= dl >> (GMP_NUMB_BITS - cnt);\n#endif\n\t      umul_ppmm (h, dummy, x, qp[qn - 1] << GMP_NAIL_BITS);\n\n\t      if (n2p[qn - 1] < h)\n\t\t{\n\t\t  mp_limb_t cy;\n\n\t\t  mpn_decr_u (qp, (mp_limb_t) 1);\n\t\t  cy = mpn_add_n (n2p, n2p, d2p, qn);\n\t\t  if (cy)\n\t\t    {\n\t\t      /* The partial remainder is safely large.  */\n\t\t      n2p[qn] = cy;\n\t\t      ++rn;\n\t\t    }\n\t\t}\n\t    }\n\n\t    quotient_too_large = 0;\n\t    if (cnt != 0)\n\t      {\n\t\tmp_limb_t cy1, cy2;\n\n\t\t/* Append partially used numerator limb to partial remainder.  */\n\t\tcy1 = mpn_lshift (n2p, n2p, rn, GMP_NUMB_BITS - cnt);\n\t\tn2p[0] |= np[in - 1] & (GMP_NUMB_MASK >> cnt);\n\n\t\t/* Update partial remainder with partially used divisor limb.  */\n\t\tcy2 = mpn_submul_1 (n2p, qp, qn, dp[in - 1] & (GMP_NUMB_MASK >> cnt));\n\t\tif (qn != rn)\n\t\t  {\n\t\t    ASSERT_ALWAYS (n2p[qn] >= cy2);\n\t\t    n2p[qn] -= cy2;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    n2p[qn] = cy1 - cy2; /* & GMP_NUMB_MASK; */\n\n\t\t    quotient_too_large = (cy1 < cy2);\n\t\t    ++rn;\n\t\t  }\n\t\t--in;\n\t      }\n\t    /* True: partial remainder now is neutral, i.e., it is not shifted up.  */\n\n\t    tp = TMP_ALLOC_LIMBS (dn);\n\n\t    if (in < qn)\n\t      {\n\t\tif (in == 0)\n\t\t  {\n\t\t    MPN_COPY (rp, n2p, rn);\n\t\t    ASSERT_ALWAYS (rn == dn);\n\t\t    goto foo;\n\t\t  }\n\t\tmpn_mul (tp, qp, qn, dp, in);\n\t      }\n\t    else\n\t      mpn_mul (tp, dp, in, qp, qn);\n\n\t    cy = mpn_sub (n2p, n2p, rn, tp + in, qn);\n\t    MPN_COPY (rp + in, n2p, dn - in);\n\t    quotient_too_large |= cy;\n\t    cy = mpn_sub_n (rp, np, tp, in);\n\t    cy = mpn_sub_1 (rp + in, rp + in, rn, cy);\n\t    quotient_too_large |= cy;\n\t  foo:\n\t    if (quotient_too_large)\n\t      {\n\t\tmpn_decr_u (qp, (mp_limb_t) 1);\n\t\tmpn_add_n (rp, rp, dp, dn);\n\t      }\n\t  }\n\tTMP_FREE;\n\treturn;\n      }\n    }\n}",
      "lines": 343,
      "depth": 21,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom22_mul.c": {
    "mpn_toom22_mul": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "void\nmpn_toom22_mul (mp_ptr pp,\n\t\tmp_srcptr ap, mp_size_t an,\n\t\tmp_srcptr bp, mp_size_t bn,\n\t\tmp_ptr scratch)\n{\n  const int __gmpn_cpuvec_initialized = 1;\n  mp_size_t n, s, t;\n  int vm1_neg;\n  mp_limb_t cy, cy2;\n  mp_ptr asm1;\n  mp_ptr bsm1;\n\n#define a0  ap\n#define a1  (ap + n)\n#define b0  bp\n#define b1  (bp + n)\n\n  s = an >> 1;\n  n = an - s;\n  t = bn - n;\n\n  ASSERT (an >= bn);\n\n  ASSERT (0 < s && s <= n && s >= n - 1);\n  ASSERT (0 < t && t <= s);\n\n  asm1 = pp;\n  bsm1 = pp + n;\n\n  vm1_neg = 0;\n\n  /* Compute asm1.  */\n  if (s == n)\n    {\n      if (mpn_cmp (a0, a1, n) < 0)\n\t{\n\t  mpn_sub_n (asm1, a1, a0, n);\n\t  vm1_neg = 1;\n\t}\n      else\n\t{\n\t  mpn_sub_n (asm1, a0, a1, n);\n\t}\n    }\n  else /* n - s == 1 */\n    {\n      if (a0[s] == 0 && mpn_cmp (a0, a1, s) < 0)\n\t{\n\t  mpn_sub_n (asm1, a1, a0, s);\n\t  asm1[s] = 0;\n\t  vm1_neg = 1;\n\t}\n      else\n\t{\n\t  asm1[s] = a0[s] - mpn_sub_n (asm1, a0, a1, s);\n\t}\n    }\n\n  /* Compute bsm1.  */\n  if (t == n)\n    {\n      if (mpn_cmp (b0, b1, n) < 0)\n\t{\n\t  mpn_sub_n (bsm1, b1, b0, n);\n\t  vm1_neg ^= 1;\n\t}\n      else\n\t{\n\t  mpn_sub_n (bsm1, b0, b1, n);\n\t}\n    }\n  else\n    {\n      if (mpn_zero_p (b0 + t, n - t) && mpn_cmp (b0, b1, t) < 0)\n\t{\n\t  mpn_sub_n (bsm1, b1, b0, t);\n\t  MPN_ZERO (bsm1 + t, n - t);\n\t  vm1_neg ^= 1;\n\t}\n      else\n\t{\n\t  mpn_sub (bsm1, b0, n, b1, t);\n\t}\n    }\n\n#define v0\tpp\t\t\t\t/* 2n */\n#define vinf\t(pp + 2 * n)\t\t\t/* s+t */\n#define vm1\tscratch\t\t\t\t/* 2n */\n#define scratch_out\tscratch + 2 * n\n\n  /* vm1, 2n limbs */\n  TOOM22_MUL_N_REC (vm1, asm1, bsm1, n, scratch_out);\n\n  if (s > t)  TOOM22_MUL_REC (vinf, a1, s, b1, t, scratch_out);\n  else        TOOM22_MUL_N_REC (vinf, a1, b1, s, scratch_out);\n\n  /* v0, 2n limbs */\n  TOOM22_MUL_N_REC (v0, ap, bp, n, scratch_out);\n\n  /* H(v0) + L(vinf) */\n  cy = mpn_add_n (pp + 2 * n, v0 + n, vinf, n);\n\n  /* L(v0) + H(v0) */\n  cy2 = cy + mpn_add_n (pp + n, pp + 2 * n, v0, n);\n\n  /* L(vinf) + H(vinf) */\n  cy += mpn_add (pp + 2 * n, pp + 2 * n, n, vinf + n, s + t - n);\n\n  if (vm1_neg)\n    cy += mpn_add_n (pp + n, pp + n, vm1, 2 * n);\n  else\n    cy -= mpn_sub_n (pp + n, pp + n, vm1, 2 * n);\n\n  ASSERT (cy + 1  <= 3);\n  ASSERT (cy2 <= 2);\n\n  MPN_INCR_U (pp + 2 * n, s + t, cy2);\n  if (LIKELY (cy <= 2))\n    /* if s+t==n, cy is zero, but we should not acces pp[3*n] at all. */\n    MPN_INCR_U (pp + 3 * n, s + t - n, cy);\n  else\n    MPN_DECR_U (pp + 3 * n, s + t - n, 1);\n}",
      "lines": 124,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom2_sqr.c": {
    "mpn_toom2_sqr": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\nmpn_toom2_sqr (mp_ptr pp,\n\t       mp_srcptr ap, mp_size_t an,\n\t       mp_ptr scratch)\n{\n  const int __gmpn_cpuvec_initialized = 1;\n  mp_size_t n, s;\n  mp_limb_t cy, cy2;\n  mp_ptr asm1;\n\n#define a0  ap\n#define a1  (ap + n)\n\n  s = an >> 1;\n  n = an - s;\n\n  ASSERT (0 < s && s <= n && s >= n - 1);\n\n  asm1 = pp;\n\n  /* Compute asm1.  */\n  if (s == n)\n    {\n      if (mpn_cmp (a0, a1, n) < 0)\n\t{\n\t  mpn_sub_n (asm1, a1, a0, n);\n\t}\n      else\n\t{\n\t  mpn_sub_n (asm1, a0, a1, n);\n\t}\n    }\n  else /* n - s == 1 */\n    {\n      if (a0[s] == 0 && mpn_cmp (a0, a1, s) < 0)\n\t{\n\t  mpn_sub_n (asm1, a1, a0, s);\n\t  asm1[s] = 0;\n\t}\n      else\n\t{\n\t  asm1[s] = a0[s] - mpn_sub_n (asm1, a0, a1, s);\n\t}\n    }\n\n#define v0\tpp\t\t\t\t/* 2n */\n#define vinf\t(pp + 2 * n)\t\t\t/* s+s */\n#define vm1\tscratch\t\t\t\t/* 2n */\n#define scratch_out\tscratch + 2 * n\n\n  /* vm1, 2n limbs */\n  TOOM2_SQR_REC (vm1, asm1, n, scratch_out);\n\n  /* vinf, s+s limbs */\n  TOOM2_SQR_REC (vinf, a1, s, scratch_out);\n\n  /* v0, 2n limbs */\n  TOOM2_SQR_REC (v0, ap, n, scratch_out);\n\n  /* H(v0) + L(vinf) */\n  cy = mpn_add_n (pp + 2 * n, v0 + n, vinf, n);\n\n  /* L(v0) + H(v0) */\n  cy2 = cy + mpn_add_n (pp + n, pp + 2 * n, v0, n);\n\n  /* L(vinf) + H(vinf) */\n  cy += mpn_add (pp + 2 * n, pp + 2 * n, n, vinf + n, s + s - n);\n\n  cy -= mpn_sub_n (pp + n, pp + n, vm1, 2 * n);\n\n  ASSERT (cy + 1  <= 3);\n  ASSERT (cy2 <= 2);\n\n  MPN_INCR_U (pp + 2 * n, s + s, cy2);\n  if (LIKELY (cy <= 2))\n    MPN_INCR_U (pp + 3 * n, s + s - n, cy);\n  else\n    MPN_DECR_U (pp + 3 * n, s + s - n, 1);\n}",
      "lines": 79,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom32_mul.c": {
    "mpn_toom32_mul": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "void\nmpn_toom32_mul (mp_ptr pp,\n\t\tmp_srcptr ap, mp_size_t an,\n\t\tmp_srcptr bp, mp_size_t bn,\n\t\tmp_ptr scratch)\n{\n  mp_size_t n, s, t;\n  int vm1_neg;\n  mp_limb_t cy;\n  mp_limb_signed_t hi;\n  mp_limb_t ap1_hi, bp1_hi;\n\n#define a0  ap\n#define a1  (ap + n)\n#define a2  (ap + 2 * n)\n#define b0  bp\n#define b1  (bp + n)\n\n  /* Required, to ensure that s + t >= n. */\n  ASSERT (bn + 2 <= an && an + 6 <= 3*bn);\n\n  n = 1 + (2 * an >= 3 * bn ? (an - 1) / (size_t) 3 : (bn - 1) >> 1);\n\n  s = an - 2 * n;\n  t = bn - n;\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n  ASSERT (s + t >= n);\n\n  /* Product area of size an + bn = 3*n + s + t >= 4*n + 2. */\n#define ap1 (pp)\t\t/* n, most significant limb in ap1_hi */\n#define bp1 (pp + n)\t\t/* n, most significant bit in bp1_hi */\n#define am1 (pp + 2*n)\t\t/* n, most significant bit in hi */\n#define bm1 (pp + 3*n)\t\t/* n */\n#define v1 (scratch)\t\t/* 2n + 1 */\n#define vm1 (pp)\t\t/* 2n + 1 */\n#define scratch_out (scratch + 2*n + 1) /* Currently unused. */\n\n  /* Scratch need: 2*n + 1 + scratch for the recursive multiplications. */\n\n  /* FIXME: Keep v1[2*n] and vm1[2*n] in scalar variables? */\n\n  /* Compute ap1 = a0 + a1 + a3, am1 = a0 - a1 + a3 */\n  ap1_hi = mpn_add (ap1, a0, n, a2, s);\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (ap1_hi == 0 && mpn_cmp (ap1, a1, n) < 0)\n    {\n      ap1_hi = mpn_add_n_sub_n (ap1, am1, a1, ap1, n) >> 1;\n      hi = 0;\n      vm1_neg = 1;\n    }\n  else\n    {\n      cy = mpn_add_n_sub_n (ap1, am1, ap1, a1, n);\n      hi = ap1_hi - (cy & 1);\n      ap1_hi += (cy >> 1);\n      vm1_neg = 0;\n    }\n#else\n  if (ap1_hi == 0 && mpn_cmp (ap1, a1, n) < 0)\n    {\n      ASSERT_NOCARRY (mpn_sub_n (am1, a1, ap1, n));\n      hi = 0;\n      vm1_neg = 1;\n    }\n  else\n    {\n      hi = ap1_hi - mpn_sub_n (am1, ap1, a1, n);\n      vm1_neg = 0;\n    }\n  ap1_hi += mpn_add_n (ap1, ap1, a1, n);\n#endif\n\n  /* Compute bp1 = b0 + b1 and bm1 = b0 - b1. */\n  if (t == n)\n    {\n#if HAVE_NATIVE_mpn_add_n_sub_n\n      if (mpn_cmp (b0, b1, n) < 0)\n\t{\n\t  cy = mpn_add_n_sub_n (bp1, bm1, b1, b0, n);\n\t  vm1_neg ^= 1;\n\t}\n      else\n\t{\n\t  cy = mpn_add_n_sub_n (bp1, bm1, b0, b1, n);\n\t}\n      bp1_hi = cy >> 1;\n#else\n      bp1_hi = mpn_add_n (bp1, b0, b1, n);\n\n      if (mpn_cmp (b0, b1, n) < 0)\n\t{\n\t  ASSERT_NOCARRY (mpn_sub_n (bm1, b1, b0, n));\n\t  vm1_neg ^= 1;\n\t}\n      else\n\t{\n\t  ASSERT_NOCARRY (mpn_sub_n (bm1, b0, b1, n));\n\t}\n#endif\n    }\n  else\n    {\n      /* FIXME: Should still use mpn_add_n_sub_n for the main part. */\n      bp1_hi = mpn_add (bp1, b0, n, b1, t);\n\n      if (mpn_zero_p (b0 + t, n - t) && mpn_cmp (b0, b1, t) < 0)\n\t{\n\t  ASSERT_NOCARRY (mpn_sub_n (bm1, b1, b0, t));\n\t  MPN_ZERO (bm1 + t, n - t);\n\t  vm1_neg ^= 1;\n\t}\n      else\n\t{\n\t  ASSERT_NOCARRY (mpn_sub (bm1, b0, n, b1, t));\n\t}\n    }\n\n  TOOM32_MUL_N_REC (v1, ap1, bp1, n, scratch_out);\n  if (ap1_hi == 1)\n    {\n      cy = bp1_hi + mpn_add_n (v1 + n, v1 + n, bp1, n);\n    }\n  else if (ap1_hi == 2)\n    {\n#if HAVE_NATIVE_mpn_addlsh1_n\n      cy = 2 * bp1_hi + mpn_addlsh1_n (v1 + n, v1 + n, bp1, n);\n#else\n      cy = 2 * bp1_hi + mpn_addmul_1 (v1 + n, bp1, n, CNST_LIMB(2));\n#endif\n    }\n  else\n    cy = 0;\n  if (bp1_hi != 0)\n    cy += mpn_add_n (v1 + n, v1 + n, ap1, n);\n  v1[2 * n] = cy;\n\n  TOOM32_MUL_N_REC (vm1, am1, bm1, n, scratch_out);\n  if (hi)\n    hi = mpn_add_n (vm1+n, vm1+n, bm1, n);\n\n  vm1[2*n] = hi;\n\n  /* v1 <-- (v1 + vm1) / 2 = x0 + x2 */\n  if (vm1_neg)\n    {\n#if HAVE_NATIVE_mpn_rsh1sub_n\n      mpn_rsh1sub_n (v1, v1, vm1, 2*n+1);\n#else\n      mpn_sub_n (v1, v1, vm1, 2*n+1);\n      ASSERT_NOCARRY (mpn_rshift (v1, v1, 2*n+1, 1));\n#endif\n    }\n  else\n    {\n#if HAVE_NATIVE_mpn_rsh1add_n\n      mpn_rsh1add_n (v1, v1, vm1, 2*n+1);\n#else\n      mpn_add_n (v1, v1, vm1, 2*n+1);\n      ASSERT_NOCARRY (mpn_rshift (v1, v1, 2*n+1, 1));\n#endif\n    }\n\n  /* We get x1 + x3 = (x0 + x2) - (x0 - x1 + x2 - x3), and hence\n\n     y = x1 + x3 + (x0 + x2) * B\n       = (x0 + x2) * B + (x0 + x2) - vm1.\n\n     y is 3*n + 1 limbs, y = y0 + y1 B + y2 B^2. We store them as\n     follows: y0 at scratch, y1 at pp + 2*n, and y2 at scratch + n\n     (already in place, except for carry propagation).\n\n     We thus add\n\n   B^3  B^2   B    1\n    |    |    |    |\n   +-----+----+\n + |  x0 + x2 |\n   +----+-----+----+\n +      |  x0 + x2 |\n\t+----------+\n -      |  vm1     |\n --+----++----+----+-\n   | y2  | y1 | y0 |\n   +-----+----+----+\n\n  Since we store y0 at the same location as the low half of x0 + x2, we\n  need to do the middle sum first. */\n\n  hi = vm1[2*n];\n  cy = mpn_add_n (pp + 2*n, v1, v1 + n, n);\n  MPN_INCR_U (v1 + n, n + 1, cy + v1[2*n]);\n\n  /* FIXME: Can we get rid of this second vm1_neg conditional by\n     swapping the location of +1 and -1 values? */\n  if (vm1_neg)\n    {\n      cy = mpn_add_n (v1, v1, vm1, n);\n      hi += mpn_add_nc (pp + 2*n, pp + 2*n, vm1 + n, n, cy);\n      MPN_INCR_U (v1 + n, n+1, hi);\n    }\n  else\n    {\n      cy = mpn_sub_n (v1, v1, vm1, n);\n      hi += mpn_sub_nc (pp + 2*n, pp + 2*n, vm1 + n, n, cy);\n      MPN_DECR_U (v1 + n, n+1, hi);\n    }\n\n  TOOM32_MUL_N_REC (pp, a0, b0, n, scratch_out);\n  /* vinf, s+t limbs.  Use mpn_mul for now, to handle unbalanced operands */\n  if (s > t)  mpn_mul (pp+3*n, a2, s, b1, t);\n  else        mpn_mul (pp+3*n, b1, t, a2, s);\n\n  /* Remaining interpolation.\n\n     y * B + x0 + x3 B^3 - x0 B^2 - x3 B\n     = (x1 + x3) B + (x0 + x2) B^2 + x0 + x3 B^3 - x0 B^2 - x3 B\n     = y0 B + y1 B^2 + y3 B^3 + Lx0 + H x0 B\n       + L x3 B^3 + H x3 B^4 - Lx0 B^2 - H x0 B^3 - L x3 B - H x3 B^2\n     = L x0 + (y0 + H x0 - L x3) B + (y1 - L x0 - H x3) B^2\n       + (y2 - (H x0 - L x3)) B^3 + H x3 B^4\n\n\t  B^4       B^3       B^2        B         1\n |         |         |         |         |         |\n   +-------+                   +---------+---------+\n   |  Hx3  |                   | Hx0-Lx3 |    Lx0  |\n   +------+----------+---------+---------+---------+\n\t  |    y2    |  y1     |   y0    |\n\t  ++---------+---------+---------+\n\t  -| Hx0-Lx3 | - Lx0   |\n\t   +---------+---------+\n\t\t      | - Hx3  |\n\t\t      +--------+\n\n    We must take into account the carry from Hx0 - Lx3.\n  */\n\n  cy = mpn_sub_n (pp + n, pp + n, pp+3*n, n);\n  hi = scratch[2*n] + cy;\n\n  cy = mpn_sub_nc (pp + 2*n, pp + 2*n, pp, n, cy);\n  hi -= mpn_sub_nc (pp + 3*n, scratch + n, pp + n, n, cy);\n\n  hi += mpn_add (pp + n, pp + n, 3*n, scratch, n);\n\n  /* FIXME: Is support for s + t == n needed? */\n  if (LIKELY (s + t > n))\n    {\n      hi -= mpn_sub (pp + 2*n, pp + 2*n, 2*n, pp + 4*n, s+t-n);\n\n      if (hi < 0)\n\tMPN_DECR_U (pp + 4*n, s+t-n, -hi);\n      else\n\tMPN_INCR_U (pp + 4*n, s+t-n, hi);\n    }\n  else\n    ASSERT (hi == 0);\n}",
      "lines": 259,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom33_mul.c": {
    "mpn_toom33_mul": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "void\nmpn_toom33_mul (mp_ptr pp,\n\t\tmp_srcptr ap, mp_size_t an,\n\t\tmp_srcptr bp, mp_size_t bn,\n\t\tmp_ptr scratch)\n{\n  const int __gmpn_cpuvec_initialized = 1;\n  mp_size_t n, s, t;\n  int vm1_neg;\n  mp_limb_t cy, vinf0;\n  mp_ptr gp;\n  mp_ptr as1, asm1, as2;\n  mp_ptr bs1, bsm1, bs2;\n\n#define a0  ap\n#define a1  (ap + n)\n#define a2  (ap + 2*n)\n#define b0  bp\n#define b1  (bp + n)\n#define b2  (bp + 2*n)\n\n  n = (an + 2) / (size_t) 3;\n\n  s = an - 2 * n;\n  t = bn - 2 * n;\n\n  ASSERT (an >= bn);\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n\n  as1  = scratch + 4 * n + 4;\n  asm1 = scratch + 2 * n + 2;\n  as2 = pp + n + 1;\n\n  bs1 = pp;\n  bsm1 = scratch + 3 * n + 3; /* we need 4n+4 <= 4n+s+t */\n  bs2 = pp + 2 * n + 2;\n\n  gp = scratch;\n\n  vm1_neg = 0;\n\n  /* Compute as1 and asm1.  */\n  cy = mpn_add (gp, a0, n, a2, s);\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (cy == 0 && mpn_cmp (gp, a1, n) < 0)\n    {\n      cy = mpn_add_n_sub_n (as1, asm1, a1, gp, n);\n      as1[n] = cy >> 1;\n      asm1[n] = 0;\n      vm1_neg = 1;\n    }\n  else\n    {\n      mp_limb_t cy2;\n      cy2 = mpn_add_n_sub_n (as1, asm1, gp, a1, n);\n      as1[n] = cy + (cy2 >> 1);\n      asm1[n] = cy - (cy2 & 1);\n    }\n#else\n  as1[n] = cy + mpn_add_n (as1, gp, a1, n);\n  if (cy == 0 && mpn_cmp (gp, a1, n) < 0)\n    {\n      mpn_sub_n (asm1, a1, gp, n);\n      asm1[n] = 0;\n      vm1_neg = 1;\n    }\n  else\n    {\n      cy -= mpn_sub_n (asm1, gp, a1, n);\n      asm1[n] = cy;\n    }\n#endif\n\n  /* Compute as2.  */\n#if HAVE_NATIVE_mpn_rsblsh1_n\n  cy = mpn_add_n (as2, a2, as1, s);\n  if (s != n)\n    cy = mpn_add_1 (as2 + s, as1 + s, n - s, cy);\n  cy += as1[n];\n  cy = 2 * cy + mpn_rsblsh1_n (as2, a0, as2, n);\n#else\n#if HAVE_NATIVE_mpn_addlsh1_n\n  cy  = mpn_addlsh1_n (as2, a1, a2, s);\n  if (s != n)\n    cy = mpn_add_1 (as2 + s, a1 + s, n - s, cy);\n  cy = 2 * cy + mpn_addlsh1_n (as2, a0, as2, n);\n#else\n  cy = mpn_add_n (as2, a2, as1, s);\n  if (s != n)\n    cy = mpn_add_1 (as2 + s, as1 + s, n - s, cy);\n  cy += as1[n];\n  cy = 2 * cy + mpn_lshift (as2, as2, n, 1);\n  cy -= mpn_sub_n (as2, as2, a0, n);\n#endif\n#endif\n  as2[n] = cy;\n\n  /* Compute bs1 and bsm1.  */\n  cy = mpn_add (gp, b0, n, b2, t);\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (cy == 0 && mpn_cmp (gp, b1, n) < 0)\n    {\n      cy = mpn_add_n_sub_n (bs1, bsm1, b1, gp, n);\n      bs1[n] = cy >> 1;\n      bsm1[n] = 0;\n      vm1_neg ^= 1;\n    }\n  else\n    {\n      mp_limb_t cy2;\n      cy2 = mpn_add_n_sub_n (bs1, bsm1, gp, b1, n);\n      bs1[n] = cy + (cy2 >> 1);\n      bsm1[n] = cy - (cy2 & 1);\n    }\n#else\n  bs1[n] = cy + mpn_add_n (bs1, gp, b1, n);\n  if (cy == 0 && mpn_cmp (gp, b1, n) < 0)\n    {\n      mpn_sub_n (bsm1, b1, gp, n);\n      bsm1[n] = 0;\n      vm1_neg ^= 1;\n    }\n  else\n    {\n      cy -= mpn_sub_n (bsm1, gp, b1, n);\n      bsm1[n] = cy;\n    }\n#endif\n\n  /* Compute bs2.  */\n#if HAVE_NATIVE_mpn_rsblsh1_n\n  cy = mpn_add_n (bs2, b2, bs1, t);\n  if (t != n)\n    cy = mpn_add_1 (bs2 + t, bs1 + t, n - t, cy);\n  cy += bs1[n];\n  cy = 2 * cy + mpn_rsblsh1_n (bs2, b0, bs2, n);\n#else\n#if HAVE_NATIVE_mpn_addlsh1_n\n  cy  = mpn_addlsh1_n (bs2, b1, b2, t);\n  if (t != n)\n    cy = mpn_add_1 (bs2 + t, b1 + t, n - t, cy);\n  cy = 2 * cy + mpn_addlsh1_n (bs2, b0, bs2, n);\n#else\n  cy  = mpn_add_n (bs2, bs1, b2, t);\n  if (t != n)\n    cy = mpn_add_1 (bs2 + t, bs1 + t, n - t, cy);\n  cy += bs1[n];\n  cy = 2 * cy + mpn_lshift (bs2, bs2, n, 1);\n  cy -= mpn_sub_n (bs2, bs2, b0, n);\n#endif\n#endif\n  bs2[n] = cy;\n\n  ASSERT (as1[n] <= 2);\n  ASSERT (bs1[n] <= 2);\n  ASSERT (asm1[n] <= 1);\n  ASSERT (bsm1[n] <= 1);\n  ASSERT (as2[n] <= 6);\n  ASSERT (bs2[n] <= 6);\n\n#define v0    pp\t\t\t\t/* 2n */\n#define v1    (pp + 2 * n)\t\t\t/* 2n+1 */\n#define vinf  (pp + 4 * n)\t\t\t/* s+t */\n#define vm1   scratch\t\t\t\t/* 2n+1 */\n#define v2    (scratch + 2 * n + 1)\t\t/* 2n+2 */\n#define scratch_out  (scratch + 5 * n + 5)\n\n  /* vm1, 2n+1 limbs */\n#ifdef SMALLER_RECURSION\n  TOOM33_MUL_N_REC (vm1, asm1, bsm1, n, scratch_out);\n  cy = 0;\n  if (asm1[n] != 0)\n    cy = bsm1[n] + mpn_add_n (vm1 + n, vm1 + n, bsm1, n);\n  if (bsm1[n] != 0)\n    cy += mpn_add_n (vm1 + n, vm1 + n, asm1, n);\n  vm1[2 * n] = cy;\n#else\n  TOOM33_MUL_N_REC (vm1, asm1, bsm1, n + 1, scratch_out);\n#endif\n\n  TOOM33_MUL_N_REC (v2, as2, bs2, n + 1, scratch_out);\t/* v2, 2n+1 limbs */\n\n  /* vinf, s+t limbs */\n  if (s > t)  mpn_mul (vinf, a2, s, b2, t);\n  else        TOOM33_MUL_N_REC (vinf, a2, b2, s, scratch_out);\n\n  vinf0 = vinf[0];\t\t\t\t/* v1 overlaps with this */\n\n#ifdef SMALLER_RECURSION\n  /* v1, 2n+1 limbs */\n  TOOM33_MUL_N_REC (v1, as1, bs1, n, scratch_out);\n  if (as1[n] == 1)\n    {\n      cy = bs1[n] + mpn_add_n (v1 + n, v1 + n, bs1, n);\n    }\n  else if (as1[n] != 0)\n    {\n#if HAVE_NATIVE_mpn_addlsh1_n\n      cy = 2 * bs1[n] + mpn_addlsh1_n (v1 + n, v1 + n, bs1, n);\n#else\n      cy = 2 * bs1[n] + mpn_addmul_1 (v1 + n, bs1, n, CNST_LIMB(2));\n#endif\n    }\n  else\n    cy = 0;\n  if (bs1[n] == 1)\n    {\n      cy += mpn_add_n (v1 + n, v1 + n, as1, n);\n    }\n  else if (bs1[n] != 0)\n    {\n#if HAVE_NATIVE_mpn_addlsh1_n\n      cy += mpn_addlsh1_n (v1 + n, v1 + n, as1, n);\n#else\n      cy += mpn_addmul_1 (v1 + n, as1, n, CNST_LIMB(2));\n#endif\n    }\n  v1[2 * n] = cy;\n#else\n  cy = vinf[1];\n  TOOM33_MUL_N_REC (v1, as1, bs1, n + 1, scratch_out);\n  vinf[1] = cy;\n#endif\n\n  TOOM33_MUL_N_REC (v0, ap, bp, n, scratch_out);\t/* v0, 2n limbs */\n\n  mpn_toom_interpolate_5pts (pp, v2, vm1, n, s + t, vm1_neg, vinf0);\n}",
      "lines": 230,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom3_sqr.c": {
    "mpn_toom3_sqr": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "void\nmpn_toom3_sqr (mp_ptr pp,\n\t       mp_srcptr ap, mp_size_t an,\n\t       mp_ptr scratch)\n{\n  const int __gmpn_cpuvec_initialized = 1;\n  mp_size_t n, s;\n  mp_limb_t cy, vinf0;\n  mp_ptr gp;\n  mp_ptr as1, asm1, as2;\n\n#define a0  ap\n#define a1  (ap + n)\n#define a2  (ap + 2*n)\n\n  n = (an + 2) / (size_t) 3;\n\n  s = an - 2 * n;\n\n  ASSERT (0 < s && s <= n);\n\n  as1 = scratch + 4 * n + 4;\n  asm1 = scratch + 2 * n + 2;\n  as2 = pp + n + 1;\n\n  gp = scratch;\n\n  /* Compute as1 and asm1.  */\n  cy = mpn_add (gp, a0, n, a2, s);\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (cy == 0 && mpn_cmp (gp, a1, n) < 0)\n    {\n      cy = mpn_add_n_sub_n (as1, asm1, a1, gp, n);\n      as1[n] = cy >> 1;\n      asm1[n] = 0;\n    }\n  else\n    {\n      mp_limb_t cy2;\n      cy2 = mpn_add_n_sub_n (as1, asm1, gp, a1, n);\n      as1[n] = cy + (cy2 >> 1);\n      asm1[n] = cy - (cy2 & 1);\n    }\n#else\n  as1[n] = cy + mpn_add_n (as1, gp, a1, n);\n  if (cy == 0 && mpn_cmp (gp, a1, n) < 0)\n    {\n      mpn_sub_n (asm1, a1, gp, n);\n      asm1[n] = 0;\n    }\n  else\n    {\n      cy -= mpn_sub_n (asm1, gp, a1, n);\n      asm1[n] = cy;\n    }\n#endif\n\n  /* Compute as2.  */\n#if HAVE_NATIVE_mpn_rsblsh1_n\n  cy = mpn_add_n (as2, a2, as1, s);\n  if (s != n)\n    cy = mpn_add_1 (as2 + s, as1 + s, n - s, cy);\n  cy += as1[n];\n  cy = 2 * cy + mpn_rsblsh1_n (as2, a0, as2, n);\n#else\n#if HAVE_NATIVE_mpn_addlsh1_n\n  cy  = mpn_addlsh1_n (as2, a1, a2, s);\n  if (s != n)\n    cy = mpn_add_1 (as2 + s, a1 + s, n - s, cy);\n  cy = 2 * cy + mpn_addlsh1_n (as2, a0, as2, n);\n#else\n  cy = mpn_add_n (as2, a2, as1, s);\n  if (s != n)\n    cy = mpn_add_1 (as2 + s, as1 + s, n - s, cy);\n  cy += as1[n];\n  cy = 2 * cy + mpn_lshift (as2, as2, n, 1);\n  cy -= mpn_sub_n (as2, as2, a0, n);\n#endif\n#endif\n  as2[n] = cy;\n\n  ASSERT (as1[n] <= 2);\n  ASSERT (asm1[n] <= 1);\n\n#define v0    pp\t\t\t\t/* 2n */\n#define v1    (pp + 2 * n)\t\t\t/* 2n+1 */\n#define vinf  (pp + 4 * n)\t\t\t/* s+s */\n#define vm1   scratch\t\t\t\t/* 2n+1 */\n#define v2    (scratch + 2 * n + 1)\t\t/* 2n+2 */\n#define scratch_out  (scratch + 5 * n + 5)\n\n  /* vm1, 2n+1 limbs */\n#ifdef SMALLER_RECURSION\n  TOOM3_SQR_REC (vm1, asm1, n, scratch_out);\n  cy = 0;\n  if (asm1[n] != 0)\n    cy = asm1[n] + mpn_add_n (vm1 + n, vm1 + n, asm1, n);\n  if (asm1[n] != 0)\n    cy += mpn_add_n (vm1 + n, vm1 + n, asm1, n);\n  vm1[2 * n] = cy;\n#else\n  TOOM3_SQR_REC (vm1, asm1, n + 1, scratch_out);\n#endif\n\n  TOOM3_SQR_REC (v2, as2, n + 1, scratch_out);\t/* v2, 2n+1 limbs */\n\n  TOOM3_SQR_REC (vinf, a2, s, scratch_out);\t/* vinf, s+s limbs */\n\n  vinf0 = vinf[0];\t\t\t\t/* v1 overlaps with this */\n\n#ifdef SMALLER_RECURSION\n  /* v1, 2n+1 limbs */\n  TOOM3_SQR_REC (v1, as1, n, scratch_out);\n  if (as1[n] == 1)\n    {\n      cy = as1[n] + mpn_add_n (v1 + n, v1 + n, as1, n);\n    }\n  else if (as1[n] != 0)\n    {\n#if HAVE_NATIVE_mpn_addlsh1_n\n      cy = 2 * as1[n] + mpn_addlsh1_n (v1 + n, v1 + n, as1, n);\n#else\n      cy = 2 * as1[n] + mpn_addmul_1 (v1 + n, as1, n, CNST_LIMB(2));\n#endif\n    }\n  else\n    cy = 0;\n  if (as1[n] == 1)\n    {\n      cy += mpn_add_n (v1 + n, v1 + n, as1, n);\n    }\n  else if (as1[n] != 0)\n    {\n#if HAVE_NATIVE_mpn_addlsh1_n\n      cy += mpn_addlsh1_n (v1 + n, v1 + n, as1, n);\n#else\n      cy += mpn_addmul_1 (v1 + n, as1, n, CNST_LIMB(2));\n#endif\n    }\n  v1[2 * n] = cy;\n#else\n  cy = vinf[1];\n  TOOM3_SQR_REC (v1, as1, n + 1, scratch_out);\n  vinf[1] = cy;\n#endif\n\n  TOOM3_SQR_REC (v0, ap, n, scratch_out);\t/* v0, 2n limbs */\n\n  mpn_toom_interpolate_5pts (pp, v2, vm1, n, s + s, 0, vinf0);\n}",
      "lines": 150,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom42_mul.c": {
    "mpn_toom42_mul": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "void\nmpn_toom42_mul (mp_ptr pp,\n\t\tmp_srcptr ap, mp_size_t an,\n\t\tmp_srcptr bp, mp_size_t bn,\n\t\tmp_ptr scratch)\n{\n  mp_size_t n, s, t;\n  int vm1_neg;\n  mp_limb_t cy, vinf0;\n  mp_ptr a0_a2;\n  mp_ptr as1, asm1, as2;\n  mp_ptr bs1, bsm1, bs2;\n  mp_ptr tmp;\n  TMP_DECL;\n\n#define a0  ap\n#define a1  (ap + n)\n#define a2  (ap + 2*n)\n#define a3  (ap + 3*n)\n#define b0  bp\n#define b1  (bp + n)\n\n  n = an >= 2 * bn ? (an + 3) >> 2 : (bn + 1) >> 1;\n\n  s = an - 3 * n;\n  t = bn - n;\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n\n  TMP_MARK;\n\n  tmp = TMP_ALLOC_LIMBS (6 * n + 5);\n  as1  = tmp; tmp += n + 1;\n  asm1 = tmp; tmp += n + 1;\n  as2  = tmp; tmp += n + 1;\n  bs1  = tmp; tmp += n + 1;\n  bsm1 = tmp; tmp += n;\n  bs2  = tmp; tmp += n + 1;\n\n  a0_a2 = pp;\n\n  /* Compute as1 and asm1.  */\n  vm1_neg = mpn_toom_eval_dgr3_pm1 (as1, asm1, ap, n, s, a0_a2) & 1;\n\n  /* Compute as2.  */\n#if HAVE_NATIVE_mpn_addlsh1_n\n  cy  = mpn_addlsh1_n (as2, a2, a3, s);\n  if (s != n)\n    cy = mpn_add_1 (as2 + s, a2 + s, n - s, cy);\n  cy = 2 * cy + mpn_addlsh1_n (as2, a1, as2, n);\n  cy = 2 * cy + mpn_addlsh1_n (as2, a0, as2, n);\n#else\n  cy  = mpn_lshift (as2, a3, s, 1);\n  cy += mpn_add_n (as2, a2, as2, s);\n  if (s != n)\n    cy = mpn_add_1 (as2 + s, a2 + s, n - s, cy);\n  cy = 2 * cy + mpn_lshift (as2, as2, n, 1);\n  cy += mpn_add_n (as2, a1, as2, n);\n  cy = 2 * cy + mpn_lshift (as2, as2, n, 1);\n  cy += mpn_add_n (as2, a0, as2, n);\n#endif\n  as2[n] = cy;\n\n  /* Compute bs1 and bsm1.  */\n  if (t == n)\n    {\n#if HAVE_NATIVE_mpn_add_n_sub_n\n      if (mpn_cmp (b0, b1, n) < 0)\n\t{\n\t  cy = mpn_add_n_sub_n (bs1, bsm1, b1, b0, n);\n\t  vm1_neg ^= 1;\n\t}\n      else\n\t{\n\t  cy = mpn_add_n_sub_n (bs1, bsm1, b0, b1, n);\n\t}\n      bs1[n] = cy >> 1;\n#else\n      bs1[n] = mpn_add_n (bs1, b0, b1, n);\n\n      if (mpn_cmp (b0, b1, n) < 0)\n\t{\n\t  mpn_sub_n (bsm1, b1, b0, n);\n\t  vm1_neg ^= 1;\n\t}\n      else\n\t{\n\t  mpn_sub_n (bsm1, b0, b1, n);\n\t}\n#endif\n    }\n  else\n    {\n      bs1[n] = mpn_add (bs1, b0, n, b1, t);\n\n      if (mpn_zero_p (b0 + t, n - t) && mpn_cmp (b0, b1, t) < 0)\n\t{\n\t  mpn_sub_n (bsm1, b1, b0, t);\n\t  MPN_ZERO (bsm1 + t, n - t);\n\t  vm1_neg ^= 1;\n\t}\n      else\n\t{\n\t  mpn_sub (bsm1, b0, n, b1, t);\n\t}\n    }\n\n  /* Compute bs2, recycling bs1. bs2=bs1+b1  */\n  mpn_add (bs2, bs1, n + 1, b1, t);\n\n  ASSERT (as1[n] <= 3);\n  ASSERT (bs1[n] <= 1);\n  ASSERT (asm1[n] <= 1);\n/*ASSERT (bsm1[n] == 0);*/\n  ASSERT (as2[n] <= 14);\n  ASSERT (bs2[n] <= 2);\n\n#define v0    pp\t\t\t\t/* 2n */\n#define v1    (pp + 2 * n)\t\t\t/* 2n+1 */\n#define vinf  (pp + 4 * n)\t\t\t/* s+t */\n#define vm1   scratch\t\t\t\t/* 2n+1 */\n#define v2    (scratch + 2 * n + 1)\t\t/* 2n+2 */\n#define scratch_out\tscratch + 4 * n + 4\t/* Currently unused. */\n\n  /* vm1, 2n+1 limbs */\n  TOOM42_MUL_N_REC (vm1, asm1, bsm1, n, scratch_out);\n  cy = 0;\n  if (asm1[n] != 0)\n    cy = mpn_add_n (vm1 + n, vm1 + n, bsm1, n);\n  vm1[2 * n] = cy;\n\n  TOOM42_MUL_N_REC (v2, as2, bs2, n + 1, scratch_out);\t/* v2, 2n+1 limbs */\n\n  /* vinf, s+t limbs */\n  if (s > t)  mpn_mul (vinf, a3, s, b1, t);\n  else        mpn_mul (vinf, b1, t, a3, s);\n\n  vinf0 = vinf[0];\t\t\t\t/* v1 overlaps with this */\n\n  /* v1, 2n+1 limbs */\n  TOOM42_MUL_N_REC (v1, as1, bs1, n, scratch_out);\n  if (as1[n] == 1)\n    {\n      cy = bs1[n] + mpn_add_n (v1 + n, v1 + n, bs1, n);\n    }\n  else if (as1[n] == 2)\n    {\n#if HAVE_NATIVE_mpn_addlsh1_n\n      cy = 2 * bs1[n] + mpn_addlsh1_n (v1 + n, v1 + n, bs1, n);\n#else\n      cy = 2 * bs1[n] + mpn_addmul_1 (v1 + n, bs1, n, CNST_LIMB(2));\n#endif\n    }\n  else if (as1[n] == 3)\n    {\n      cy = 3 * bs1[n] + mpn_addmul_1 (v1 + n, bs1, n, CNST_LIMB(3));\n    }\n  else\n    cy = 0;\n  if (bs1[n] != 0)\n    cy += mpn_add_n (v1 + n, v1 + n, as1, n);\n  v1[2 * n] = cy;\n\n  TOOM42_MUL_N_REC (v0, ap, bp, n, scratch_out);\t/* v0, 2n limbs */\n\n  mpn_toom_interpolate_5pts (pp, v2, vm1, n, s + t, vm1_neg, vinf0);\n\n  TMP_FREE;\n}",
      "lines": 170,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom42_mulmid.c": {
    "mpn_toom42_mulmid": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "void\nmpn_toom42_mulmid (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n,\n                   mp_ptr scratch)\n{\n  mp_limb_t cy, e[12], zh, zl;\n  mp_size_t m;\n  int neg;\n\n  ASSERT (n >= 4);\n  ASSERT (! MPN_OVERLAP_P (rp, n + 2, ap, 2*n - 1));\n  ASSERT (! MPN_OVERLAP_P (rp, n + 2, bp, n));\n\n  ap += n & 1;   /* handle odd row and diagonal later */\n  m = n / 2;\n\n  /* (e0h:e0l) etc are correction terms, in 2's complement */\n#define e0l (e[0])\n#define e0h (e[1])\n#define e1l (e[2])\n#define e1h (e[3])\n#define e2l (e[4])\n#define e2h (e[5])\n#define e3l (e[6])\n#define e3h (e[7])\n#define e4l (e[8])\n#define e4h (e[9])\n#define e5l (e[10])\n#define e5h (e[11])\n\n#define s (scratch + 2)\n#define t (rp + m + 2)\n#define p0 rp\n#define p1 scratch\n#define p2 (rp + m)\n#define next_scratch (scratch + 3*m + 1)\n\n  /*\n            rp                            scratch\n  |---------|-----------|    |---------|---------|----------|\n  0         m         2m+2   0         m         2m        3m+1\n            <----p2---->       <-------------s------------->\n  <----p0----><---t---->     <----p1---->\n  */\n\n  /* compute {s,3m-1} = {a,3m-1} + {a+m,3m-1} and error terms e0, e1, e2, e3 */\n  cy = mpn_add_err1_n (s, ap, ap + m, &e0l, bp + m, m - 1, 0);\n  cy = mpn_add_err2_n (s + m - 1, ap + m - 1, ap + 2*m - 1, &e1l,\n\t\t       bp + m, bp, m, cy);\n  mpn_add_err1_n (s + 2*m - 1, ap + 2*m - 1, ap + 3*m - 1, &e3l, bp, m, cy);\n\n  /* compute t = (-1)^neg * ({b,m} - {b+m,m}) and error terms e4, e5 */\n  if (mpn_cmp (bp + m, bp, m) < 0)\n    {\n      ASSERT_NOCARRY (mpn_sub_err2_n (t, bp, bp + m, &e4l,\n\t\t\t\t      ap + m - 1, ap + 2*m - 1, m, 0));\n      neg = 1;\n    }\n  else\n    {\n      ASSERT_NOCARRY (mpn_sub_err2_n (t, bp + m, bp, &e4l,\n\t\t\t\t      ap + m - 1, ap + 2*m - 1, m, 0));\n      neg = 0;\n    }\n\n  /* recursive middle products. The picture is:\n\n      b[2m-1]   A   A   A   B   B   B   -   -   -   -   -\n      ...       -   A   A   A   B   B   B   -   -   -   -\n      b[m]      -   -   A   A   A   B   B   B   -   -   -\n      b[m-1]    -   -   -   C   C   C   D   D   D   -   -\n      ...       -   -   -   -   C   C   C   D   D   D   -\n      b[0]      -   -   -   -   -   C   C   C   D   D   D\n               a[0]   ...  a[m]  ...  a[2m]    ...    a[4m-2]\n  */\n\n  if (m < MULMID_TOOM42_THRESHOLD)\n    {\n      /* A + B */\n      mpn_mulmid_basecase (p0, s, 2*m - 1, bp + m, m);\n      /* accumulate high limbs of p0 into e1 */\n      ADDC_LIMB (cy, e1l, e1l, p0[m]);\n      e1h += p0[m + 1] + cy;\n      /* (-1)^neg * (B - C)   (overwrites first m limbs of s) */\n      mpn_mulmid_basecase (p1, ap + m, 2*m - 1, t, m);\n      /* C + D   (overwrites t) */\n      mpn_mulmid_basecase (p2, s + m, 2*m - 1, bp, m);\n    }\n  else\n    {\n      /* as above, but use toom42 instead */\n      mpn_toom42_mulmid (p0, s, bp + m, m, next_scratch);\n      ADDC_LIMB (cy, e1l, e1l, p0[m]);\n      e1h += p0[m + 1] + cy;\n      mpn_toom42_mulmid (p1, ap + m, t, m, next_scratch);\n      mpn_toom42_mulmid (p2, s + m, bp, m, next_scratch);\n    }\n\n  /* apply error terms */\n\n  /* -e0 at rp[0] */\n  SUBC_LIMB (cy, rp[0], rp[0], e0l);\n  SUBC_LIMB (cy, rp[1], rp[1], e0h + cy);\n  if (UNLIKELY (cy))\n    {\n      cy = (m > 2) ? mpn_sub_1 (rp + 2, rp + 2, m - 2, 1) : 1;\n      SUBC_LIMB (cy, e1l, e1l, cy);\n      e1h -= cy;\n    }\n\n  /* z = e1 - e2 + high(p0) */\n  SUBC_LIMB (cy, zl, e1l, e2l);\n  zh = e1h - e2h - cy;\n\n  /* z at rp[m] */\n  ADDC_LIMB (cy, rp[m], rp[m], zl);\n  zh = (zh + cy) & GMP_NUMB_MASK;\n  ADDC_LIMB (cy, rp[m + 1], rp[m + 1], zh);\n  cy -= (zh >> (GMP_NUMB_BITS - 1));\n  if (UNLIKELY (cy))\n    {\n      if (cy == 1)\n\tmpn_add_1 (rp + m + 2, rp + m + 2, m, 1);\n      else /* cy == -1 */\n\tmpn_sub_1 (rp + m + 2, rp + m + 2, m, 1);\n    }\n\n  /* e3 at rp[2*m] */\n  ADDC_LIMB (cy, rp[2*m], rp[2*m], e3l);\n  rp[2*m + 1] = (rp[2*m + 1] + e3h + cy) & GMP_NUMB_MASK;\n\n  /* e4 at p1[0] */\n  ADDC_LIMB (cy, p1[0], p1[0], e4l);\n  ADDC_LIMB (cy, p1[1], p1[1], e4h + cy);\n  if (UNLIKELY (cy))\n    mpn_add_1 (p1 + 2, p1 + 2, m, 1);\n\n  /* -e5 at p1[m] */\n  SUBC_LIMB (cy, p1[m], p1[m], e5l);\n  p1[m + 1] = (p1[m + 1] - e5h - cy) & GMP_NUMB_MASK;\n\n  /* adjustment if p1 ends up negative */\n  cy = (p1[m + 1] >> (GMP_NUMB_BITS - 1));\n\n  /* add (-1)^neg * (p1 - B^m * p1) to output */\n  if (neg)\n    {\n      mpn_sub_1 (rp + m + 2, rp + m + 2, m, cy);\n      mpn_add (rp, rp, 2*m + 2, p1, m + 2);             /* A + C */\n      mpn_sub_n (rp + m, rp + m, p1, m + 2);            /* B + D */\n    }\n  else\n    {\n      mpn_add_1 (rp + m + 2, rp + m + 2, m, cy);\n      mpn_sub (rp, rp, 2*m + 2, p1, m + 2);             /* A + C */\n      mpn_add_n (rp + m, rp + m, p1, m + 2);            /* B + D */\n    }\n\n  /* odd row and diagonal */\n  if (n & 1)\n    {\n      /*\n        Products marked E are already done. We need to do products marked O.\n\n        OOOOO----\n        -EEEEO---\n        --EEEEO--\n        ---EEEEO-\n        ----EEEEO\n       */\n\n      /* first row of O's */\n      cy = mpn_addmul_1 (rp, ap - 1, n, bp[n - 1]);\n      ADDC_LIMB (rp[n + 1], rp[n], rp[n], cy);\n\n      /* O's on diagonal */\n      /* FIXME: should probably define an interface \"mpn_mulmid_diag_1\"\n         that can handle the sum below. Currently we're relying on\n         mulmid_basecase being pretty fast for a diagonal sum like this,\n\t which is true at least for the K8 asm version, but surely false\n\t for the generic version. */\n      mpn_mulmid_basecase (e, ap + n - 1, n - 1, bp, n - 1);\n      mpn_add_n (rp + n - 1, rp + n - 1, e, 3);\n    }\n}",
      "lines": 184,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom43_mul.c": {
    "mpn_toom43_mul": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "void\nmpn_toom43_mul (mp_ptr pp,\n\t\tmp_srcptr ap, mp_size_t an,\n\t\tmp_srcptr bp, mp_size_t bn, mp_ptr scratch)\n{\n  mp_size_t n, s, t;\n  enum toom6_flags flags;\n  mp_limb_t cy;\n\n#define a0  ap\n#define a1  (ap + n)\n#define a2  (ap + 2 * n)\n#define a3  (ap + 3 * n)\n#define b0  bp\n#define b1  (bp + n)\n#define b2  (bp + 2 * n)\n\n  n = 1 + (3 * an >= 4 * bn ? (an - 1) >> 2 : (bn - 1) / (size_t) 3);\n\n  s = an - 3 * n;\n  t = bn - 2 * n;\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n\n  /* This is true whenever an >= 25 or bn >= 19, I think. It\n     guarantees that we can fit 5 values of size n+1 in the product\n     area. */\n  ASSERT (s+t >= 5);\n\n#define v0    pp\t\t\t\t/* 2n */\n#define vm1   (scratch)\t\t\t\t/* 2n+1 */\n#define v1    (pp + 2*n)\t\t\t/* 2n+1 */\n#define vm2   (scratch + 2 * n + 1)\t\t/* 2n+1 */\n#define v2    (scratch + 4 * n + 2)\t\t/* 2n+1 */\n#define vinf  (pp + 5 * n)\t\t\t/* s+t */\n#define bs1    pp\t\t\t\t/* n+1 */\n#define bsm1  (scratch + 2 * n + 2)\t\t/* n+1 */\n#define asm1  (scratch + 3 * n + 3)\t\t/* n+1 */\n#define asm2  (scratch + 4 * n + 4)\t\t/* n+1 */\n#define bsm2  (pp + n + 1)\t\t\t/* n+1 */\n#define bs2   (pp + 2 * n + 2)\t\t\t/* n+1 */\n#define as2   (pp + 3 * n + 3)\t\t\t/* n+1 */\n#define as1   (pp + 4 * n + 4)\t\t\t/* n+1 */\n\n  /* Total sccratch need is 6 * n + 3 + 1; we allocate one extra\n     limb, because products will overwrite 2n+2 limbs. */\n\n#define a0a2  scratch\n#define b0b2  scratch\n#define a1a3  asm1\n#define b1d   bsm1\n\n  /* Compute as2 and asm2.  */\n  flags = (enum toom6_flags) (toom6_vm2_neg & mpn_toom_eval_dgr3_pm2 (as2, asm2, ap, n, s, a1a3));\n\n  /* Compute bs2 and bsm2.  */\n  b1d[n] = mpn_lshift (b1d, b1, n, 1);\t\t\t/*       2b1      */\n  cy  = mpn_lshift (b0b2, b2, t, 2);\t\t\t/*  4b2           */\n  cy += mpn_add_n (b0b2, b0b2, b0, t);\t\t\t/*  4b2      + b0 */\n  if (t != n)\n    cy = mpn_add_1 (b0b2 + t, b0 + t, n - t, cy);\n  b0b2[n] = cy;\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (mpn_cmp (b0b2, b1d, n+1) < 0)\n    {\n      mpn_add_n_sub_n (bs2, bsm2, b1d, b0b2, n+1);\n      flags = (enum toom6_flags) (flags ^ toom6_vm2_neg);\n    }\n  else\n    {\n      mpn_add_n_sub_n (bs2, bsm2, b0b2, b1d, n+1);\n    }\n#else\n  mpn_add_n (bs2, b0b2, b1d, n+1);\n  if (mpn_cmp (b0b2, b1d, n+1) < 0)\n    {\n      mpn_sub_n (bsm2, b1d, b0b2, n+1);\n      flags = (enum toom6_flags) (flags ^ toom6_vm2_neg);\n    }\n  else\n    {\n      mpn_sub_n (bsm2, b0b2, b1d, n+1);\n    }\n#endif\n\n  /* Compute as1 and asm1.  */\n  flags = (enum toom6_flags) (flags ^ (toom6_vm1_neg & mpn_toom_eval_dgr3_pm1 (as1, asm1, ap, n, s, a0a2)));\n\n  /* Compute bs1 and bsm1.  */\n  bsm1[n] = mpn_add (bsm1, b0, n, b2, t);\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (bsm1[n] == 0 && mpn_cmp (bsm1, b1, n) < 0)\n    {\n      cy = mpn_add_n_sub_n (bs1, bsm1, b1, bsm1, n);\n      bs1[n] = cy >> 1;\n      flags = (enum toom6_flags) (flags ^ toom6_vm1_neg);\n    }\n  else\n    {\n      cy = mpn_add_n_sub_n (bs1, bsm1, bsm1, b1, n);\n      bs1[n] = bsm1[n] + (cy >> 1);\n      bsm1[n]-= cy & 1;\n    }\n#else\n  bs1[n] = bsm1[n] + mpn_add_n (bs1, bsm1, b1, n);\n  if (bsm1[n] == 0 && mpn_cmp (bsm1, b1, n) < 0)\n    {\n      mpn_sub_n (bsm1, b1, bsm1, n);\n      flags = (enum toom6_flags) (flags ^ toom6_vm1_neg);\n    }\n  else\n    {\n      bsm1[n] -= mpn_sub_n (bsm1, bsm1, b1, n);\n    }\n#endif\n\n  ASSERT (as1[n] <= 3);\n  ASSERT (bs1[n] <= 2);\n  ASSERT (asm1[n] <= 1);\n  ASSERT (bsm1[n] <= 1);\n  ASSERT (as2[n] <=14);\n  ASSERT (bs2[n] <= 6);\n  ASSERT (asm2[n] <= 9);\n  ASSERT (bsm2[n] <= 4);\n\n  /* vm1, 2n+1 limbs */\n  mpn_mul_n (vm1, asm1, bsm1, n+1);  /* W4 */\n\n  /* vm2, 2n+1 limbs */\n  mpn_mul_n (vm2, asm2, bsm2, n+1);  /* W2 */\n\n  /* v2, 2n+1 limbs */\n  mpn_mul_n (v2, as2, bs2, n+1);  /* W1 */\n\n  /* v1, 2n+1 limbs */\n  mpn_mul_n (v1, as1, bs1, n+1);  /* W3 */\n\n  /* vinf, s+t limbs */   /* W0 */\n  if (s > t)  mpn_mul (vinf, a3, s, b2, t);\n  else        mpn_mul (vinf, b2, t, a3, s);\n\n  /* v0, 2n limbs */\n  mpn_mul_n (v0, ap, bp, n);  /* W5 */\n\n  mpn_toom_interpolate_6pts (pp, n, flags, vm1, vm2, v2, t + s);\n\n#undef v0\n#undef vm1\n#undef v1\n#undef vm2\n#undef v2\n#undef vinf\n#undef bs1\n#undef bs2\n#undef bsm1\n#undef bsm2\n#undef asm1\n#undef asm2\n/* #undef as1 */\n/* #undef as2 */\n#undef a0a2\n#undef b0b2\n#undef a1a3\n#undef b1d\n#undef a0\n#undef a1\n#undef a2\n#undef a3\n#undef b0\n#undef b1\n#undef b2\n}",
      "lines": 174,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom44_mul.c": {
    "mpn_toom44_mul": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nmpn_toom44_mul (mp_ptr pp,\n\t\tmp_srcptr ap, mp_size_t an,\n\t\tmp_srcptr bp, mp_size_t bn,\n\t\tmp_ptr scratch)\n{\n  mp_size_t n, s, t;\n  mp_limb_t cy;\n  enum toom7_flags flags;\n\n#define a0  ap\n#define a1  (ap + n)\n#define a2  (ap + 2*n)\n#define a3  (ap + 3*n)\n#define b0  bp\n#define b1  (bp + n)\n#define b2  (bp + 2*n)\n#define b3  (bp + 3*n)\n\n  ASSERT (an >= bn);\n\n  n = (an + 3) >> 2;\n\n  s = an - 3 * n;\n  t = bn - 3 * n;\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n  ASSERT (s >= t);\n\n  /* NOTE: The multiplications to v2, vm2, vh and vm1 overwrites the\n   * following limb, so these must be computed in order, and we need a\n   * one limb gap to tp. */\n#define v0    pp\t\t\t\t/* 2n */\n#define v1    (pp + 2 * n)\t\t\t/* 2n+1 */\n#define vinf  (pp + 6 * n)\t\t\t/* s+t */\n#define v2    scratch\t\t\t\t/* 2n+1 */\n#define vm2   (scratch + 2 * n + 1)\t\t/* 2n+1 */\n#define vh    (scratch + 4 * n + 2)\t\t/* 2n+1 */\n#define vm1   (scratch + 6 * n + 3)\t\t/* 2n+1 */\n#define tp (scratch + 8*n + 5)\n\n  /* apx and bpx must not overlap with v1 */\n#define apx   pp\t\t\t\t/* n+1 */\n#define amx   (pp + n + 1)\t\t\t/* n+1 */\n#define bmx   (pp + 2*n + 2)\t\t\t/* n+1 */\n#define bpx   (pp + 4*n + 2)\t\t\t/* n+1 */\n\n  /* Total scratch need: 8*n + 5 + scratch for recursive calls. This\n     gives roughly 32 n/3 + log term. */\n\n  /* Compute apx = a0 + 2 a1 + 4 a2 + 8 a3 and amx = a0 - 2 a1 + 4 a2 - 8 a3.  */\n  flags = (enum toom7_flags) (toom7_w1_neg & mpn_toom_eval_dgr3_pm2 (apx, amx, ap, n, s, tp));\n\n  /* Compute bpx = b0 + 2 b1 + 4 b2 + 8 b3 and bmx = b0 - 2 b1 + 4 b2 - 8 b3.  */\n  flags = (enum toom7_flags) (flags ^ (toom7_w1_neg & mpn_toom_eval_dgr3_pm2 (bpx, bmx, bp, n, t, tp)));\n\n  TOOM44_MUL_N_REC (v2, apx, bpx, n + 1, tp);\t/* v2,  2n+1 limbs */\n  TOOM44_MUL_N_REC (vm2, amx, bmx, n + 1, tp);\t/* vm2,  2n+1 limbs */\n\n  /* Compute apx = 8 a0 + 4 a1 + 2 a2 + a3 = (((2*a0 + a1) * 2 + a2) * 2 + a3 */\n#if HAVE_NATIVE_mpn_addlsh1_n\n  cy = mpn_addlsh1_n (apx, a1, a0, n);\n  cy = 2*cy + mpn_addlsh1_n (apx, a2, apx, n);\n  if (s < n)\n    {\n      mp_limb_t cy2;\n      cy2 = mpn_addlsh1_n (apx, a3, apx, s);\n      apx[n] = 2*cy + mpn_lshift (apx + s, apx + s, n - s, 1);\n      MPN_INCR_U (apx + s, n+1-s, cy2);\n    }\n  else\n    apx[n] = 2*cy + mpn_addlsh1_n (apx, a3, apx, n);\n#else\n  cy = mpn_lshift (apx, a0, n, 1);\n  cy += mpn_add_n (apx, apx, a1, n);\n  cy = 2*cy + mpn_lshift (apx, apx, n, 1);\n  cy += mpn_add_n (apx, apx, a2, n);\n  cy = 2*cy + mpn_lshift (apx, apx, n, 1);\n  apx[n] = cy + mpn_add (apx, apx, n, a3, s);\n#endif\n\n  /* Compute bpx = 8 b0 + 4 b1 + 2 b2 + b3 = (((2*b0 + b1) * 2 + b2) * 2 + b3 */\n#if HAVE_NATIVE_mpn_addlsh1_n\n  cy = mpn_addlsh1_n (bpx, b1, b0, n);\n  cy = 2*cy + mpn_addlsh1_n (bpx, b2, bpx, n);\n  if (t < n)\n    {\n      mp_limb_t cy2;\n      cy2 = mpn_addlsh1_n (bpx, b3, bpx, t);\n      bpx[n] = 2*cy + mpn_lshift (bpx + t, bpx + t, n - t, 1);\n      MPN_INCR_U (bpx + t, n+1-t, cy2);\n    }\n  else\n    bpx[n] = 2*cy + mpn_addlsh1_n (bpx, b3, bpx, n);\n#else\n  cy = mpn_lshift (bpx, b0, n, 1);\n  cy += mpn_add_n (bpx, bpx, b1, n);\n  cy = 2*cy + mpn_lshift (bpx, bpx, n, 1);\n  cy += mpn_add_n (bpx, bpx, b2, n);\n  cy = 2*cy + mpn_lshift (bpx, bpx, n, 1);\n  bpx[n] = cy + mpn_add (bpx, bpx, n, b3, t);\n#endif\n\n  ASSERT (apx[n] < 15);\n  ASSERT (bpx[n] < 15);\n\n  TOOM44_MUL_N_REC (vh, apx, bpx, n + 1, tp);\t/* vh,  2n+1 limbs */\n\n  /* Compute apx = a0 + a1 + a2 + a3 and amx = a0 - a1 + a2 - a3.  */\n  flags = (enum toom7_flags) (flags | (toom7_w3_neg & mpn_toom_eval_dgr3_pm1 (apx, amx, ap, n, s, tp)));\n\n  /* Compute bpx = b0 + b1 + b2 + b3 and bmx = b0 - b1 + b2 - b3.  */\n  flags = (enum toom7_flags) (flags ^ (toom7_w3_neg & mpn_toom_eval_dgr3_pm1 (bpx, bmx, bp, n, t, tp)));\n\n  TOOM44_MUL_N_REC (vm1, amx, bmx, n + 1, tp);\t/* vm1,  2n+1 limbs */\n  /* Clobbers amx, bmx. */\n  TOOM44_MUL_N_REC (v1, apx, bpx, n + 1, tp);\t/* v1,  2n+1 limbs */\n\n  TOOM44_MUL_N_REC (v0, a0, b0, n, tp);\n  if (s > t)\n    mpn_mul (vinf, a3, s, b3, t);\n  else\n    TOOM44_MUL_N_REC (vinf, a3, b3, s, tp);\t/* vinf, s+t limbs */\n\n  mpn_toom_interpolate_7pts (pp, n, flags, vm2, vm1, v2, vh, s + t, tp);\n}",
      "lines": 127,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom4_sqr.c": {
    "mpn_toom4_sqr": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "void\nmpn_toom4_sqr (mp_ptr pp,\n\t       mp_srcptr ap, mp_size_t an,\n\t       mp_ptr scratch)\n{\n  mp_size_t n, s;\n  mp_limb_t cy;\n\n#define a0  ap\n#define a1  (ap + n)\n#define a2  (ap + 2*n)\n#define a3  (ap + 3*n)\n\n  n = (an + 3) >> 2;\n\n  s = an - 3 * n;\n\n  ASSERT (0 < s && s <= n);\n\n  /* NOTE: The multiplications to v2, vm2, vh and vm1 overwrites the\n   * following limb, so these must be computed in order, and we need a\n   * one limb gap to tp. */\n#define v0    pp\t\t\t\t/* 2n */\n#define v1    (pp + 2 * n)\t\t\t/* 2n+1 */\n#define vinf  (pp + 6 * n)\t\t\t/* s+t */\n#define v2    scratch\t\t\t\t/* 2n+1 */\n#define vm2   (scratch + 2 * n + 1)\t\t/* 2n+1 */\n#define vh    (scratch + 4 * n + 2)\t\t/* 2n+1 */\n#define vm1   (scratch + 6 * n + 3)\t\t/* 2n+1 */\n#define tp (scratch + 8*n + 5)\n\n  /* No overlap with v1 */\n#define apx   pp\t\t\t\t/* n+1 */\n#define amx   (pp + 4*n + 2)\t\t\t/* n+1 */\n\n  /* Total scratch need: 8*n + 5 + scratch for recursive calls. This\n     gives roughly 32 n/3 + log term. */\n\n  /* Compute apx = a0 + 2 a1 + 4 a2 + 8 a3 and amx = a0 - 2 a1 + 4 a2 - 8 a3.  */\n  mpn_toom_eval_dgr3_pm2 (apx, amx, ap, n, s, tp);\n\n  TOOM4_SQR_REC (v2, apx, n + 1, tp);\t/* v2,  2n+1 limbs */\n  TOOM4_SQR_REC (vm2, amx, n + 1, tp);\t/* vm2,  2n+1 limbs */\n\n  /* Compute apx = 8 a0 + 4 a1 + 2 a2 + a3 = (((2*a0 + a1) * 2 + a2) * 2 + a3 */\n#if HAVE_NATIVE_mpn_addlsh1_n\n  cy = mpn_addlsh1_n (apx, a1, a0, n);\n  cy = 2*cy + mpn_addlsh1_n (apx, a2, apx, n);\n  if (s < n)\n    {\n      mp_limb_t cy2;\n      cy2 = mpn_addlsh1_n (apx, a3, apx, s);\n      apx[n] = 2*cy + mpn_lshift (apx + s, apx + s, n - s, 1);\n      MPN_INCR_U (apx + s, n+1-s, cy2);\n    }\n  else\n    apx[n] = 2*cy + mpn_addlsh1_n (apx, a3, apx, n);\n#else\n  cy = mpn_lshift (apx, a0, n, 1);\n  cy += mpn_add_n (apx, apx, a1, n);\n  cy = 2*cy + mpn_lshift (apx, apx, n, 1);\n  cy += mpn_add_n (apx, apx, a2, n);\n  cy = 2*cy + mpn_lshift (apx, apx, n, 1);\n  apx[n] = cy + mpn_add (apx, apx, n, a3, s);\n#endif\n\n  ASSERT (apx[n] < 15);\n\n  TOOM4_SQR_REC (vh, apx, n + 1, tp);\t/* vh,  2n+1 limbs */\n\n  /* Compute apx = a0 + a1 + a2 + a3 and amx = a0 - a1 + a2 - a3.  */\n  mpn_toom_eval_dgr3_pm1 (apx, amx, ap, n, s, tp);\n\n  TOOM4_SQR_REC (v1, apx, n + 1, tp);\t/* v1,  2n+1 limbs */\n  TOOM4_SQR_REC (vm1, amx, n + 1, tp);\t/* vm1,  2n+1 limbs */\n\n  TOOM4_SQR_REC (v0, a0, n, tp);\n  TOOM4_SQR_REC (vinf, a3, s, tp);\t/* vinf, 2s limbs */\n\n  mpn_toom_interpolate_7pts (pp, n, (enum toom7_flags) 0, vm2, vm1, v2, vh, 2*s, tp);\n}",
      "lines": 81,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom52_mul.c": {
    "mpn_toom52_mul": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "void\nmpn_toom52_mul (mp_ptr pp,\n\t\tmp_srcptr ap, mp_size_t an,\n\t\tmp_srcptr bp, mp_size_t bn, mp_ptr scratch)\n{\n  mp_size_t n, s, t;\n  enum toom6_flags flags;\n\n#define a0  ap\n#define a1  (ap + n)\n#define a2  (ap + 2 * n)\n#define a3  (ap + 3 * n)\n#define a4  (ap + 4 * n)\n#define b0  bp\n#define b1  (bp + n)\n\n  n = 1 + (2 * an >= 5 * bn ? (an - 1) / (size_t) 5 : (bn - 1) >> 1);\n\n  s = an - 4 * n;\n  t = bn - n;\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n\n  /* Ensures that 5 values of n+1 limbs each fits in the product area.\n     Borderline cases are an = 32, bn = 8, n = 7, and an = 36, bn = 9,\n     n = 8. */\n  ASSERT (s+t >= 5);\n\n#define v0    pp\t\t\t\t/* 2n */\n#define vm1   (scratch)\t\t\t\t/* 2n+1 */\n#define v1    (pp + 2 * n)\t\t\t/* 2n+1 */\n#define vm2   (scratch + 2 * n + 1)\t\t/* 2n+1 */\n#define v2    (scratch + 4 * n + 2)\t\t/* 2n+1 */\n#define vinf  (pp + 5 * n)\t\t\t/* s+t */\n#define bs1    pp\t\t\t\t/* n+1 */\n#define bsm1  (scratch + 2 * n + 2)\t\t/* n   */\n#define asm1  (scratch + 3 * n + 3)\t\t/* n+1 */\n#define asm2  (scratch + 4 * n + 4)\t\t/* n+1 */\n#define bsm2  (pp + n + 1)\t\t\t/* n+1 */\n#define bs2   (pp + 2 * n + 2)\t\t\t/* n+1 */\n#define as2   (pp + 3 * n + 3)\t\t\t/* n+1 */\n#define as1   (pp + 4 * n + 4)\t\t\t/* n+1 */\n\n  /* Scratch need is 6 * n + 3 + 1. We need one extra limb, because\n     products will overwrite 2n+2 limbs. */\n\n#define a0a2  scratch\n#define a1a3  asm1\n\n  /* Compute as2 and asm2.  */\n  flags = (enum toom6_flags) (toom6_vm2_neg & mpn_toom_eval_pm2 (as2, asm2, 4, ap, n, s, a1a3));\n\n  /* Compute bs1 and bsm1.  */\n  if (t == n)\n    {\n#if HAVE_NATIVE_mpn_add_n_sub_n\n      mp_limb_t cy;\n\n      if (mpn_cmp (b0, b1, n) < 0)\n\t{\n\t  cy = mpn_add_n_sub_n (bs1, bsm1, b1, b0, n);\n\t  flags = (enum toom6_flags) (flags ^ toom6_vm1_neg);\n\t}\n      else\n\t{\n\t  cy = mpn_add_n_sub_n (bs1, bsm1, b0, b1, n);\n\t}\n      bs1[n] = cy >> 1;\n#else\n      bs1[n] = mpn_add_n (bs1, b0, b1, n);\n      if (mpn_cmp (b0, b1, n) < 0)\n\t{\n\t  mpn_sub_n (bsm1, b1, b0, n);\n\t  flags = (enum toom6_flags) (flags ^ toom6_vm1_neg);\n\t}\n      else\n\t{\n\t  mpn_sub_n (bsm1, b0, b1, n);\n\t}\n#endif\n    }\n  else\n    {\n      bs1[n] = mpn_add (bs1, b0, n, b1, t);\n      if (mpn_zero_p (b0 + t, n - t) && mpn_cmp (b0, b1, t) < 0)\n\t{\n\t  mpn_sub_n (bsm1, b1, b0, t);\n\t  MPN_ZERO (bsm1 + t, n - t);\n\t  flags = (enum toom6_flags) (flags ^ toom6_vm1_neg);\n\t}\n      else\n\t{\n\t  mpn_sub (bsm1, b0, n, b1, t);\n\t}\n    }\n\n  /* Compute bs2 and bsm2, recycling bs1 and bsm1. bs2=bs1+b1; bsm2=bsm1-b1  */\n  mpn_add (bs2, bs1, n+1, b1, t);\n  if (flags & toom6_vm1_neg )\n    {\n      bsm2[n] = mpn_add (bsm2, bsm1, n, b1, t);\n      flags = (enum toom6_flags) (flags ^ toom6_vm2_neg);\n    }\n  else\n    {\n      bsm2[n] = 0;\n      if (t == n)\n\t{\n\t  if (mpn_cmp (bsm1, b1, n) < 0)\n\t    {\n\t      mpn_sub_n (bsm2, b1, bsm1, n);\n\t      flags = (enum toom6_flags) (flags ^ toom6_vm2_neg);\n\t    }\n\t  else\n\t    {\n\t      mpn_sub_n (bsm2, bsm1, b1, n);\n\t    }\n\t}\n      else\n\t{\n\t  if (mpn_zero_p (bsm1 + t, n - t) && mpn_cmp (bsm1, b1, t) < 0)\n\t    {\n\t      mpn_sub_n (bsm2, b1, bsm1, t);\n\t      MPN_ZERO (bsm2 + t, n - t);\n\t      flags = (enum toom6_flags) (flags ^ toom6_vm2_neg);\n\t    }\n\t  else\n\t    {\n\t      mpn_sub (bsm2, bsm1, n, b1, t);\n\t    }\n\t}\n    }\n\n  /* Compute as1 and asm1.  */\n  flags = (enum toom6_flags) (flags ^ (toom6_vm1_neg & mpn_toom_eval_pm1 (as1, asm1, 4, ap, n, s, a0a2)));\n\n  ASSERT (as1[n] <= 4);\n  ASSERT (bs1[n] <= 1);\n  ASSERT (asm1[n] <= 2);\n/*   ASSERT (bsm1[n] <= 1); */\n  ASSERT (as2[n] <=30);\n  ASSERT (bs2[n] <= 2);\n  ASSERT (asm2[n] <= 20);\n  ASSERT (bsm2[n] <= 1);\n\n  /* vm1, 2n+1 limbs */\n  mpn_mul (vm1, asm1, n+1, bsm1, n);  /* W4 */\n\n  /* vm2, 2n+1 limbs */\n  mpn_mul_n (vm2, asm2, bsm2, n+1);  /* W2 */\n\n  /* v2, 2n+1 limbs */\n  mpn_mul_n (v2, as2, bs2, n+1);  /* W1 */\n\n  /* v1, 2n+1 limbs */\n  mpn_mul_n (v1, as1, bs1, n+1);  /* W3 */\n\n  /* vinf, s+t limbs */   /* W0 */\n  if (s > t)  mpn_mul (vinf, a4, s, b1, t);\n  else        mpn_mul (vinf, b1, t, a4, s);\n\n  /* v0, 2n limbs */\n  mpn_mul_n (v0, ap, bp, n);  /* W5 */\n\n  mpn_toom_interpolate_6pts (pp, n, flags, vm1, vm2, v2, t + s);\n\n#undef v0\n#undef vm1\n#undef v1\n#undef vm2\n#undef v2\n#undef vinf\n#undef bs1\n#undef bs2\n#undef bsm1\n#undef bsm2\n#undef asm1\n#undef asm2\n#undef as1\n#undef as2\n#undef a0a2\n#undef b0b2\n#undef a1a3\n#undef a0\n#undef a1\n#undef a2\n#undef a3\n#undef b0\n#undef b1\n#undef b2\n\n}",
      "lines": 193,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom53_mul.c": {
    "mpn_toom53_mul": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "void\nmpn_toom53_mul (mp_ptr pp,\n\t\tmp_srcptr ap, mp_size_t an,\n\t\tmp_srcptr bp, mp_size_t bn,\n\t\tmp_ptr scratch)\n{\n  mp_size_t n, s, t;\n  mp_limb_t cy;\n  mp_ptr gp;\n  mp_ptr as1, asm1, as2, asm2, ash;\n  mp_ptr bs1, bsm1, bs2, bsm2, bsh;\n  mp_ptr tmp;\n  enum toom7_flags flags;\n  TMP_DECL;\n\n#define a0  ap\n#define a1  (ap + n)\n#define a2  (ap + 2*n)\n#define a3  (ap + 3*n)\n#define a4  (ap + 4*n)\n#define b0  bp\n#define b1  (bp + n)\n#define b2  (bp + 2*n)\n\n  n = 1 + (3 * an >= 5 * bn ? (an - 1) / (size_t) 5 : (bn - 1) / (size_t) 3);\n\n  s = an - 4 * n;\n  t = bn - 2 * n;\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n\n  TMP_MARK;\n\n  tmp = TMP_ALLOC_LIMBS (10 * (n + 1));\n  as1  = tmp; tmp += n + 1;\n  asm1 = tmp; tmp += n + 1;\n  as2  = tmp; tmp += n + 1;\n  asm2 = tmp; tmp += n + 1;\n  ash  = tmp; tmp += n + 1;\n  bs1  = tmp; tmp += n + 1;\n  bsm1 = tmp; tmp += n + 1;\n  bs2  = tmp; tmp += n + 1;\n  bsm2 = tmp; tmp += n + 1;\n  bsh  = tmp; tmp += n + 1;\n\n  gp = pp;\n\n  /* Compute as1 and asm1.  */\n  flags = (enum toom7_flags) (toom7_w3_neg & mpn_toom_eval_pm1 (as1, asm1, 4, ap, n, s, gp));\n\n  /* Compute as2 and asm2. */\n  flags = (enum toom7_flags) (flags | (toom7_w1_neg & mpn_toom_eval_pm2 (as2, asm2, 4, ap, n, s, gp)));\n\n  /* Compute ash = 16 a0 + 8 a1 + 4 a2 + 2 a3 + a4\n     = 2*(2*(2*(2*a0 + a1) + a2) + a3) + a4  */\n#if HAVE_NATIVE_mpn_addlsh1_n\n  cy = mpn_addlsh1_n (ash, a1, a0, n);\n  cy = 2*cy + mpn_addlsh1_n (ash, a2, ash, n);\n  cy = 2*cy + mpn_addlsh1_n (ash, a3, ash, n);\n  if (s < n)\n    {\n      mp_limb_t cy2;\n      cy2 = mpn_addlsh1_n (ash, a4, ash, s);\n      ash[n] = 2*cy + mpn_lshift (ash + s, ash + s, n - s, 1);\n      MPN_INCR_U (ash + s, n+1-s, cy2);\n    }\n  else\n    ash[n] = 2*cy + mpn_addlsh1_n (ash, a4, ash, n);\n#else\n  cy = mpn_lshift (ash, a0, n, 1);\n  cy += mpn_add_n (ash, ash, a1, n);\n  cy = 2*cy + mpn_lshift (ash, ash, n, 1);\n  cy += mpn_add_n (ash, ash, a2, n);\n  cy = 2*cy + mpn_lshift (ash, ash, n, 1);\n  cy += mpn_add_n (ash, ash, a3, n);\n  cy = 2*cy + mpn_lshift (ash, ash, n, 1);\n  ash[n] = cy + mpn_add (ash, ash, n, a4, s);\n#endif\n\n  /* Compute bs1 and bsm1.  */\n  bs1[n] = mpn_add (bs1, b0, n, b2, t);\t\t/* b0 + b2 */\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (bs1[n] == 0 && mpn_cmp (bs1, b1, n) < 0)\n    {\n      bs1[n] = mpn_add_n_sub_n (bs1, bsm1, b1, bs1, n) >> 1;\n      bsm1[n] = 0;\n      flags = (enum toom7_flags) (flags ^ toom7_w3_neg);\n    }\n  else\n    {\n      cy = mpn_add_n_sub_n (bs1, bsm1, bs1, b1, n);\n      bsm1[n] = bs1[n] - (cy & 1);\n      bs1[n] += (cy >> 1);\n    }\n#else\n  if (bs1[n] == 0 && mpn_cmp (bs1, b1, n) < 0)\n    {\n      mpn_sub_n (bsm1, b1, bs1, n);\n      bsm1[n] = 0;\n      flags = (enum toom7_flags) (flags ^ toom7_w3_neg);\n    }\n  else\n    {\n      bsm1[n] = bs1[n] - mpn_sub_n (bsm1, bs1, b1, n);\n    }\n  bs1[n] += mpn_add_n (bs1, bs1, b1, n);  /* b0+b1+b2 */\n#endif\n\n  /* Compute bs2 and bsm2. */\n#if HAVE_NATIVE_mpn_addlsh_n || HAVE_NATIVE_mpn_addlsh2_n\n#if HAVE_NATIVE_mpn_addlsh2_n\n  cy = mpn_addlsh2_n (bs2, b0, b2, t);\n#else /* HAVE_NATIVE_mpn_addlsh_n */\n  cy = mpn_addlsh_n (bs2, b0, b2, t, 2);\n#endif\n  if (t < n)\n    cy = mpn_add_1 (bs2 + t, b0 + t, n - t, cy);\n  bs2[n] = cy;\n#else\n  cy = mpn_lshift (gp, b2, t, 2);\n  bs2[n] = mpn_add (bs2, b0, n, gp, t);\n  MPN_INCR_U (bs2 + t, n+1-t, cy);\n#endif\n\n  gp[n] = mpn_lshift (gp, b1, n, 1);\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (mpn_cmp (bs2, gp, n+1) < 0)\n    {\n      ASSERT_NOCARRY (mpn_add_n_sub_n (bs2, bsm2, gp, bs2, n+1));\n      flags = (enum toom7_flags) (flags ^ toom7_w1_neg);\n    }\n  else\n    {\n      ASSERT_NOCARRY (mpn_add_n_sub_n (bs2, bsm2, bs2, gp, n+1));\n    }\n#else\n  if (mpn_cmp (bs2, gp, n+1) < 0)\n    {\n      ASSERT_NOCARRY (mpn_sub_n (bsm2, gp, bs2, n+1));\n      flags = (enum toom7_flags) (flags ^ toom7_w1_neg);\n    }\n  else\n    {\n      ASSERT_NOCARRY (mpn_sub_n (bsm2, bs2, gp, n+1));\n    }\n  mpn_add_n (bs2, bs2, gp, n+1);\n#endif\n\n  /* Compute bsh = 4 b0 + 2 b1 + b2 = 2*(2*b0 + b1)+b2.  */\n#if HAVE_NATIVE_mpn_addlsh1_n\n  cy = mpn_addlsh1_n (bsh, b1, b0, n);\n  if (t < n)\n    {\n      mp_limb_t cy2;\n      cy2 = mpn_addlsh1_n (bsh, b2, bsh, t);\n      bsh[n] = 2*cy + mpn_lshift (bsh + t, bsh + t, n - t, 1);\n      MPN_INCR_U (bsh + t, n+1-t, cy2);\n    }\n  else\n    bsh[n] = 2*cy + mpn_addlsh1_n (bsh, b2, bsh, n);\n#else\n  cy = mpn_lshift (bsh, b0, n, 1);\n  cy += mpn_add_n (bsh, bsh, b1, n);\n  cy = 2*cy + mpn_lshift (bsh, bsh, n, 1);\n  bsh[n] = cy + mpn_add (bsh, bsh, n, b2, t);\n#endif\n\n  ASSERT (as1[n] <= 4);\n  ASSERT (bs1[n] <= 2);\n  ASSERT (asm1[n] <= 2);\n  ASSERT (bsm1[n] <= 1);\n  ASSERT (as2[n] <= 30);\n  ASSERT (bs2[n] <= 6);\n  ASSERT (asm2[n] <= 20);\n  ASSERT (bsm2[n] <= 4);\n  ASSERT (ash[n] <= 30);\n  ASSERT (bsh[n] <= 6);\n\n#define v0    pp\t\t\t\t/* 2n */\n#define v1    (pp + 2 * n)\t\t\t/* 2n+1 */\n#define vinf  (pp + 6 * n)\t\t\t/* s+t */\n#define v2    scratch\t\t\t\t/* 2n+1 */\n#define vm2   (scratch + 2 * n + 1)\t\t/* 2n+1 */\n#define vh    (scratch + 4 * n + 2)\t\t/* 2n+1 */\n#define vm1   (scratch + 6 * n + 3)\t\t/* 2n+1 */\n#define scratch_out (scratch + 8 * n + 4)\t\t/* 2n+1 */\n  /* Total scratch need: 10*n+5 */\n\n  /* Must be in allocation order, as they overwrite one limb beyond\n   * 2n+1. */\n  mpn_mul_n (v2, as2, bs2, n + 1);\t\t/* v2, 2n+1 limbs */\n  mpn_mul_n (vm2, asm2, bsm2, n + 1);\t\t/* vm2, 2n+1 limbs */\n  mpn_mul_n (vh, ash, bsh, n + 1);\t\t/* vh, 2n+1 limbs */\n\n  /* vm1, 2n+1 limbs */\n#ifdef SMALLER_RECURSION\n  mpn_mul_n (vm1, asm1, bsm1, n);\n  if (asm1[n] == 1)\n    {\n      cy = bsm1[n] + mpn_add_n (vm1 + n, vm1 + n, bsm1, n);\n    }\n  else if (asm1[n] == 2)\n    {\n#if HAVE_NATIVE_mpn_addlsh1_n\n      cy = 2 * bsm1[n] + mpn_addlsh1_n (vm1 + n, vm1 + n, bsm1, n);\n#else\n      cy = 2 * bsm1[n] + mpn_addmul_1 (vm1 + n, bsm1, n, CNST_LIMB(2));\n#endif\n    }\n  else\n    cy = 0;\n  if (bsm1[n] != 0)\n    cy += mpn_add_n (vm1 + n, vm1 + n, asm1, n);\n  vm1[2 * n] = cy;\n#else /* SMALLER_RECURSION */\n  vm1[2 * n] = 0;\n  mpn_mul_n (vm1, asm1, bsm1, n + ((asm1[n] | bsm1[n]) != 0));\n#endif /* SMALLER_RECURSION */\n\n  /* v1, 2n+1 limbs */\n#ifdef SMALLER_RECURSION\n  mpn_mul_n (v1, as1, bs1, n);\n  if (as1[n] == 1)\n    {\n      cy = bs1[n] + mpn_add_n (v1 + n, v1 + n, bs1, n);\n    }\n  else if (as1[n] == 2)\n    {\n#if HAVE_NATIVE_mpn_addlsh1_n\n      cy = 2 * bs1[n] + mpn_addlsh1_n (v1 + n, v1 + n, bs1, n);\n#else\n      cy = 2 * bs1[n] + mpn_addmul_1 (v1 + n, bs1, n, CNST_LIMB(2));\n#endif\n    }\n  else if (as1[n] != 0)\n    {\n      cy = as1[n] * bs1[n] + mpn_addmul_1 (v1 + n, bs1, n, as1[n]);\n    }\n  else\n    cy = 0;\n  if (bs1[n] == 1)\n    {\n      cy += mpn_add_n (v1 + n, v1 + n, as1, n);\n    }\n  else if (bs1[n] == 2)\n    {\n#if HAVE_NATIVE_mpn_addlsh1_n\n      cy += mpn_addlsh1_n (v1 + n, v1 + n, as1, n);\n#else\n      cy += mpn_addmul_1 (v1 + n, as1, n, CNST_LIMB(2));\n#endif\n    }\n  v1[2 * n] = cy;\n#else /* SMALLER_RECURSION */\n  v1[2 * n] = 0;\n  mpn_mul_n (v1, as1, bs1, n + ((as1[n] | bs1[n]) != 0));\n#endif /* SMALLER_RECURSION */\n\n  mpn_mul_n (v0, a0, b0, n);\t\t\t/* v0, 2n limbs */\n\n  /* vinf, s+t limbs */\n  if (s > t)  mpn_mul (vinf, a4, s, b2, t);\n  else        mpn_mul (vinf, b2, t, a4, s);\n\n  mpn_toom_interpolate_7pts (pp, n, flags, vm2, vm1, v2, vh, s + t,\n\t\t\t     scratch_out);\n\n  TMP_FREE;\n}",
      "lines": 271,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom54_mul.c": {
    "mpn_toom54_mul": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "void\nmpn_toom54_mul (mp_ptr pp,\n\t\tmp_srcptr ap, mp_size_t an,\n\t\tmp_srcptr bp, mp_size_t bn, mp_ptr scratch)\n{\n  mp_size_t n, s, t;\n  int sign;\n\n  /***************************** decomposition *******************************/\n#define a4  (ap + 4 * n)\n#define b3  (bp + 3 * n)\n\n  ASSERT (an >= bn);\n  n = 1 + (4 * an >= 5 * bn ? (an - 1) / (size_t) 5 : (bn - 1) / (size_t) 4);\n\n  s = an - 4 * n;\n  t = bn - 3 * n;\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n  /* Required by mpn_toom_interpolate_8pts. */\n  ASSERT ( s + t >= n );\n  ASSERT ( s + t > 4);\n  ASSERT ( n > 2);\n\n#define   r8    pp\t\t\t\t/* 2n   */\n#define   r7    scratch\t\t\t\t/* 3n+1 */\n#define   r5    (pp + 3*n)\t\t\t/* 3n+1 */\n#define   v0    (pp + 3*n)\t\t\t/* n+1 */\n#define   v1    (pp + 4*n+1)\t\t\t/* n+1 */\n#define   v2    (pp + 5*n+2)\t\t\t/* n+1 */\n#define   v3    (pp + 6*n+3)\t\t\t/* n+1 */\n#define   r3    (scratch + 3 * n + 1)\t\t/* 3n+1 */\n#define   r1    (pp + 7*n)\t\t\t/* s+t <= 2*n */\n#define   ws    (scratch + 6 * n + 2)\t\t/* ??? */\n\n  /* Alloc also 3n+1 limbs for ws... mpn_toom_interpolate_8pts may\n     need all of them, when DO_mpn_sublsh_n usea a scratch  */\n  /********************** evaluation and recursive calls *********************/\n  /* $\\pm4$ */\n  sign = mpn_toom_eval_pm2exp (v2, v0, 4, ap, n, s, 2, pp)\n       ^ mpn_toom_eval_pm2exp (v3, v1, 3, bp, n, t, 2, pp);\n  TOOM_54_MUL_N_REC(pp, v0, v1, n + 1, ws); /* A(-4)*B(-4) */\n  TOOM_54_MUL_N_REC(r3, v2, v3, n + 1, ws); /* A(+4)*B(+4) */\n  mpn_toom_couple_handling (r3, 2*n+1, pp, sign, n, 2, 4);\n\n  /* $\\pm1$ */\n  sign = mpn_toom_eval_pm1 (v2, v0, 4, ap, n, s,    pp)\n       ^ mpn_toom_eval_dgr3_pm1 (v3, v1, bp, n, t,    pp);\n  TOOM_54_MUL_N_REC(pp, v0, v1, n + 1, ws); /* A(-1)*B(-1) */\n  TOOM_54_MUL_N_REC(r7, v2, v3, n + 1, ws); /* A(1)*B(1) */\n  mpn_toom_couple_handling (r7, 2*n+1, pp, sign, n, 0, 0);\n\n  /* $\\pm2$ */\n  sign = mpn_toom_eval_pm2 (v2, v0, 4, ap, n, s, pp)\n       ^ mpn_toom_eval_dgr3_pm2 (v3, v1, bp, n, t, pp);\n  TOOM_54_MUL_N_REC(pp, v0, v1, n + 1, ws); /* A(-2)*B(-2) */\n  TOOM_54_MUL_N_REC(r5, v2, v3, n + 1, ws); /* A(+2)*B(+2) */\n  mpn_toom_couple_handling (r5, 2*n+1, pp, sign, n, 1, 2);\n\n  /* A(0)*B(0) */\n  TOOM_54_MUL_N_REC(pp, ap, bp, n, ws);\n\n  /* Infinity */\n  if (s > t) {\n    TOOM_54_MUL_REC(r1, a4, s, b3, t, ws);\n  } else {\n    TOOM_54_MUL_REC(r1, b3, t, a4, s, ws);\n  };\n\n  mpn_toom_interpolate_8pts (pp, n, r3, r7, s + t, ws);\n\n#undef a4\n#undef b3\n#undef r1\n#undef r3\n#undef r5\n#undef v0\n#undef v1\n#undef v2\n#undef v3\n#undef r7\n#undef r8\n#undef ws\n}",
      "lines": 85,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom62_mul.c": {
    "mpn_toom62_mul": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "void\nmpn_toom62_mul (mp_ptr pp,\n\t\tmp_srcptr ap, mp_size_t an,\n\t\tmp_srcptr bp, mp_size_t bn,\n\t\tmp_ptr scratch)\n{\n  mp_size_t n, s, t;\n  mp_limb_t cy;\n  mp_ptr as1, asm1, as2, asm2, ash;\n  mp_ptr bs1, bsm1, bs2, bsm2, bsh;\n  mp_ptr gp;\n  enum toom7_flags aflags, bflags;\n  TMP_DECL;\n\n#define a0  ap\n#define a1  (ap + n)\n#define a2  (ap + 2*n)\n#define a3  (ap + 3*n)\n#define a4  (ap + 4*n)\n#define a5  (ap + 5*n)\n#define b0  bp\n#define b1  (bp + n)\n\n  n = 1 + (an >= 3 * bn ? (an - 1) / (size_t) 6 : (bn - 1) >> 1);\n\n  s = an - 5 * n;\n  t = bn - n;\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n\n  TMP_MARK;\n\n  as1 = TMP_SALLOC_LIMBS (n + 1);\n  asm1 = TMP_SALLOC_LIMBS (n + 1);\n  as2 = TMP_SALLOC_LIMBS (n + 1);\n  asm2 = TMP_SALLOC_LIMBS (n + 1);\n  ash = TMP_SALLOC_LIMBS (n + 1);\n\n  bs1 = TMP_SALLOC_LIMBS (n + 1);\n  bsm1 = TMP_SALLOC_LIMBS (n);\n  bs2 = TMP_SALLOC_LIMBS (n + 1);\n  bsm2 = TMP_SALLOC_LIMBS (n + 1);\n  bsh = TMP_SALLOC_LIMBS (n + 1);\n\n  gp = pp;\n\n  /* Compute as1 and asm1.  */\n  aflags = (enum toom7_flags) (toom7_w3_neg & mpn_toom_eval_pm1 (as1, asm1, 5, ap, n, s, gp));\n\n  /* Compute as2 and asm2. */\n  aflags = (enum toom7_flags) (aflags | (toom7_w1_neg & mpn_toom_eval_pm2 (as2, asm2, 5, ap, n, s, gp)));\n\n  /* Compute ash = 32 a0 + 16 a1 + 8 a2 + 4 a3 + 2 a4 + a5\n     = 2*(2*(2*(2*(2*a0 + a1) + a2) + a3) + a4) + a5  */\n\n#if HAVE_NATIVE_mpn_addlsh1_n\n  cy = mpn_addlsh1_n (ash, a1, a0, n);\n  cy = 2*cy + mpn_addlsh1_n (ash, a2, ash, n);\n  cy = 2*cy + mpn_addlsh1_n (ash, a3, ash, n);\n  cy = 2*cy + mpn_addlsh1_n (ash, a4, ash, n);\n  if (s < n)\n    {\n      mp_limb_t cy2;\n      cy2 = mpn_addlsh1_n (ash, a5, ash, s);\n      ash[n] = 2*cy + mpn_lshift (ash + s, ash + s, n - s, 1);\n      MPN_INCR_U (ash + s, n+1-s, cy2);\n    }\n  else\n    ash[n] = 2*cy + mpn_addlsh1_n (ash, a5, ash, n);\n#else\n  cy = mpn_lshift (ash, a0, n, 1);\n  cy += mpn_add_n (ash, ash, a1, n);\n  cy = 2*cy + mpn_lshift (ash, ash, n, 1);\n  cy += mpn_add_n (ash, ash, a2, n);\n  cy = 2*cy + mpn_lshift (ash, ash, n, 1);\n  cy += mpn_add_n (ash, ash, a3, n);\n  cy = 2*cy + mpn_lshift (ash, ash, n, 1);\n  cy += mpn_add_n (ash, ash, a4, n);\n  cy = 2*cy + mpn_lshift (ash, ash, n, 1);\n  ash[n] = cy + mpn_add (ash, ash, n, a5, s);\n#endif\n\n  /* Compute bs1 and bsm1.  */\n  if (t == n)\n    {\n#if HAVE_NATIVE_mpn_add_n_sub_n\n      if (mpn_cmp (b0, b1, n) < 0)\n\t{\n\t  cy = mpn_add_n_sub_n (bs1, bsm1, b1, b0, n);\n\t  bflags = toom7_w3_neg;\n\t}\n      else\n\t{\n\t  cy = mpn_add_n_sub_n (bs1, bsm1, b0, b1, n);\n\t  bflags = (enum toom7_flags) 0;\n\t}\n      bs1[n] = cy >> 1;\n#else\n      bs1[n] = mpn_add_n (bs1, b0, b1, n);\n      if (mpn_cmp (b0, b1, n) < 0)\n\t{\n\t  mpn_sub_n (bsm1, b1, b0, n);\n\t  bflags = toom7_w3_neg;\n\t}\n      else\n\t{\n\t  mpn_sub_n (bsm1, b0, b1, n);\n\t  bflags = (enum toom7_flags) 0;\n\t}\n#endif\n    }\n  else\n    {\n      bs1[n] = mpn_add (bs1, b0, n, b1, t);\n      if (mpn_zero_p (b0 + t, n - t) && mpn_cmp (b0, b1, t) < 0)\n\t{\n\t  mpn_sub_n (bsm1, b1, b0, t);\n\t  MPN_ZERO (bsm1 + t, n - t);\n\t  bflags = toom7_w3_neg;\n\t}\n      else\n\t{\n\t  mpn_sub (bsm1, b0, n, b1, t);\n\t  bflags = (enum toom7_flags) 0;\n\t}\n    }\n\n  /* Compute bs2 and bsm2. Recycling bs1 and bsm1; bs2=bs1+b1, bsm2 =\n     bsm1 - b1 */\n  mpn_add (bs2, bs1, n + 1, b1, t);\n  if (bflags & toom7_w3_neg)\n    {\n      bsm2[n] = mpn_add (bsm2, bsm1, n, b1, t);\n      bflags = (enum toom7_flags) (bflags | toom7_w1_neg);\n    }\n  else\n    {\n      /* FIXME: Simplify this logic? */\n      if (t < n)\n\t{\n\t  if (mpn_zero_p (bsm1 + t, n - t) && mpn_cmp (bsm1, b1, t) < 0)\n\t    {\n\t      ASSERT_NOCARRY (mpn_sub_n (bsm2, b1, bsm1, t));\n\t      MPN_ZERO (bsm2 + t, n + 1 - t);\n\t      bflags = (enum toom7_flags) (bflags | toom7_w1_neg);\n\t    }\n\t  else\n\t    {\n\t      ASSERT_NOCARRY (mpn_sub (bsm2, bsm1, n, b1, t));\n\t      bsm2[n] = 0;\n\t    }\n\t}\n      else\n\t{\n\t  if (mpn_cmp (bsm1, b1, n) < 0)\n\t    {\n\t      ASSERT_NOCARRY (mpn_sub_n (bsm2, b1, bsm1, n));\n\t      bflags = (enum toom7_flags) (bflags | toom7_w1_neg);\n\t    }\n\t  else\n\t    {\n\t      ASSERT_NOCARRY (mpn_sub_n (bsm2, bsm1, b1, n));\n\t    }\n\t  bsm2[n] = 0;\n\t}\n    }\n\n  /* Compute bsh, recycling bs1. bsh=bs1+b0;  */\n  bsh[n] = bs1[n] + mpn_add_n (bsh, bs1, b0, n);\n\n  ASSERT (as1[n] <= 5);\n  ASSERT (bs1[n] <= 1);\n  ASSERT (asm1[n] <= 2);\n  ASSERT (as2[n] <= 62);\n  ASSERT (bs2[n] <= 2);\n  ASSERT (asm2[n] <= 41);\n  ASSERT (bsm2[n] <= 1);\n  ASSERT (ash[n] <= 62);\n  ASSERT (bsh[n] <= 2);\n\n#define v0    pp\t\t\t\t/* 2n */\n#define v1    (pp + 2 * n)\t\t\t/* 2n+1 */\n#define vinf  (pp + 6 * n)\t\t\t/* s+t */\n#define v2    scratch\t\t\t\t/* 2n+1 */\n#define vm2   (scratch + 2 * n + 1)\t\t/* 2n+1 */\n#define vh    (scratch + 4 * n + 2)\t\t/* 2n+1 */\n#define vm1   (scratch + 6 * n + 3)\t\t/* 2n+1 */\n#define scratch_out (scratch + 8 * n + 4)\t\t/* 2n+1 */\n  /* Total scratch need: 10*n+5 */\n\n  /* Must be in allocation order, as they overwrite one limb beyond\n   * 2n+1. */\n  mpn_mul_n (v2, as2, bs2, n + 1);\t\t/* v2, 2n+1 limbs */\n  mpn_mul_n (vm2, asm2, bsm2, n + 1);\t\t/* vm2, 2n+1 limbs */\n  mpn_mul_n (vh, ash, bsh, n + 1);\t\t/* vh, 2n+1 limbs */\n\n  /* vm1, 2n+1 limbs */\n  mpn_mul_n (vm1, asm1, bsm1, n);\n  cy = 0;\n  if (asm1[n] == 1)\n    {\n      cy = mpn_add_n (vm1 + n, vm1 + n, bsm1, n);\n    }\n  else if (asm1[n] == 2)\n    {\n#if HAVE_NATIVE_mpn_addlsh1_n\n      cy = mpn_addlsh1_n (vm1 + n, vm1 + n, bsm1, n);\n#else\n      cy = mpn_addmul_1 (vm1 + n, bsm1, n, CNST_LIMB(2));\n#endif\n    }\n  vm1[2 * n] = cy;\n\n  /* v1, 2n+1 limbs */\n  mpn_mul_n (v1, as1, bs1, n);\n  if (as1[n] == 1)\n    {\n      cy = bs1[n] + mpn_add_n (v1 + n, v1 + n, bs1, n);\n    }\n  else if (as1[n] == 2)\n    {\n#if HAVE_NATIVE_mpn_addlsh1_n\n      cy = 2 * bs1[n] + mpn_addlsh1_n (v1 + n, v1 + n, bs1, n);\n#else\n      cy = 2 * bs1[n] + mpn_addmul_1 (v1 + n, bs1, n, CNST_LIMB(2));\n#endif\n    }\n  else if (as1[n] != 0)\n    {\n      cy = as1[n] * bs1[n] + mpn_addmul_1 (v1 + n, bs1, n, as1[n]);\n    }\n  else\n    cy = 0;\n  if (bs1[n] != 0)\n    cy += mpn_add_n (v1 + n, v1 + n, as1, n);\n  v1[2 * n] = cy;\n\n  mpn_mul_n (v0, a0, b0, n);\t\t\t/* v0, 2n limbs */\n\n  /* vinf, s+t limbs */\n  if (s > t)  mpn_mul (vinf, a5, s, b1, t);\n  else        mpn_mul (vinf, b1, t, a5, s);\n\n  mpn_toom_interpolate_7pts (pp, n, (enum toom7_flags) (aflags ^ bflags),\n\t\t\t     vm2, vm1, v2, vh, s + t, scratch_out);\n\n  TMP_FREE;\n}",
      "lines": 249,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom63_mul.c": {
    "abs_sub_n": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nabs_sub_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  mp_limb_t  x, y;\n  while (--n >= 0)\n    {\n      x = ap[n];\n      y = bp[n];\n      if (x != y)\n\t{\n\t  n++;\n\t  if (x > y)\n\t    {\n\t      mpn_sub_n (rp, ap, bp, n);\n\t      return 0;\n\t    }\n\t  else\n\t    {\n\t      mpn_sub_n (rp, bp, ap, n);\n\t      return ~0;\n\t    }\n\t}\n      rp[n] = 0;\n    }\n  return 0;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "abs_sub_add_n": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\nabs_sub_add_n (mp_ptr rm, mp_ptr rp, mp_srcptr rs, mp_size_t n) {\n  int result;\n  result = abs_sub_n (rm, rp, rs, n);\n  ASSERT_NOCARRY(mpn_add_n (rp, rp, rs, n));\n  return result;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpn_toom63_mul": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "void\nmpn_toom63_mul (mp_ptr pp,\n\t\tmp_srcptr ap, mp_size_t an,\n\t\tmp_srcptr bp, mp_size_t bn, mp_ptr scratch)\n{\n  mp_size_t n, s, t;\n  mp_limb_t cy;\n  int sign;\n\n  /***************************** decomposition *******************************/\n#define a5  (ap + 5 * n)\n#define b0  (bp + 0 * n)\n#define b1  (bp + 1 * n)\n#define b2  (bp + 2 * n)\n\n  ASSERT (an >= bn);\n  n = 1 + (an >= 2 * bn ? (an - 1) / (size_t) 6 : (bn - 1) / (size_t) 3);\n\n  s = an - 5 * n;\n  t = bn - 2 * n;\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n  /* WARNING! it assumes s+t>=n */\n  ASSERT ( s + t >= n );\n  ASSERT ( s + t > 4);\n  /* WARNING! it assumes n>1 */\n  ASSERT ( n > 2);\n\n#define   r8    pp\t\t\t\t/* 2n   */\n#define   r7    scratch\t\t\t\t/* 3n+1 */\n#define   r5    (pp + 3*n)\t\t\t/* 3n+1 */\n#define   v0    (pp + 3*n)\t\t\t/* n+1 */\n#define   v1    (pp + 4*n+1)\t\t\t/* n+1 */\n#define   v2    (pp + 5*n+2)\t\t\t/* n+1 */\n#define   v3    (pp + 6*n+3)\t\t\t/* n+1 */\n#define   r3    (scratch + 3 * n + 1)\t\t/* 3n+1 */\n#define   r1    (pp + 7*n)\t\t\t/* s+t <= 2*n */\n#define   ws    (scratch + 6 * n + 2)\t\t/* ??? */\n\n  /* Alloc also 3n+1 limbs for ws... mpn_toom_interpolate_8pts may\n     need all of them, when DO_mpn_sublsh_n usea a scratch  */\n/*   if (scratch == NULL) scratch = TMP_SALLOC_LIMBS (9 * n + 3); */\n\n  /********************** evaluation and recursive calls *********************/\n  /* $\\pm4$ */\n  sign = mpn_toom_eval_pm2exp (v2, v0, 5, ap, n, s, 2, pp);\n  pp[n] = mpn_lshift (pp, b1, n, 2); /* 4b1 */\n  /* FIXME: use addlsh */\n  v3[t] = mpn_lshift (v3, b2, t, 4);/* 16b2 */\n  if ( n == t )\n    v3[n]+= mpn_add_n (v3, v3, b0, n); /* 16b2+b0 */\n  else\n    v3[n] = mpn_add (v3, b0, n, v3, t+1); /* 16b2+b0 */\n  sign ^= abs_sub_add_n (v1, v3, pp, n + 1);\n  TOOM_63_MUL_N_REC(pp, v0, v1, n + 1, ws); /* A(-4)*B(-4) */\n  TOOM_63_MUL_N_REC(r3, v2, v3, n + 1, ws); /* A(+4)*B(+4) */\n  mpn_toom_couple_handling (r3, 2*n+1, pp, sign, n, 2, 4);\n\n  /* $\\pm1$ */\n  sign = mpn_toom_eval_pm1 (v2, v0, 5, ap, n, s,    pp);\n  /* Compute bs1 and bsm1. Code taken from toom33 */\n  cy = mpn_add (ws, b0, n, b2, t);\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (cy == 0 && mpn_cmp (ws, b1, n) < 0)\n    {\n      cy = mpn_add_n_sub_n (v3, v1, b1, ws, n);\n      v3[n] = cy >> 1;\n      v1[n] = 0;\n      sign = ~sign;\n    }\n  else\n    {\n      mp_limb_t cy2;\n      cy2 = mpn_add_n_sub_n (v3, v1, ws, b1, n);\n      v3[n] = cy + (cy2 >> 1);\n      v1[n] = cy - (cy2 & 1);\n    }\n#else\n  v3[n] = cy + mpn_add_n (v3, ws, b1, n);\n  if (cy == 0 && mpn_cmp (ws, b1, n) < 0)\n    {\n      mpn_sub_n (v1, b1, ws, n);\n      v1[n] = 0;\n      sign = ~sign;\n    }\n  else\n    {\n      cy -= mpn_sub_n (v1, ws, b1, n);\n      v1[n] = cy;\n    }\n#endif\n  TOOM_63_MUL_N_REC(pp, v0, v1, n + 1, ws); /* A(-1)*B(-1) */\n  TOOM_63_MUL_N_REC(r7, v2, v3, n + 1, ws); /* A(1)*B(1) */\n  mpn_toom_couple_handling (r7, 2*n+1, pp, sign, n, 0, 0);\n\n  /* $\\pm2$ */\n  sign = mpn_toom_eval_pm2 (v2, v0, 5, ap, n, s, pp);\n  pp[n] = mpn_lshift (pp, b1, n, 1); /* 2b1 */\n  /* FIXME: use addlsh or addlsh2 */\n  v3[t] = mpn_lshift (v3, b2, t, 2);/* 4b2 */\n  if ( n == t )\n    v3[n]+= mpn_add_n (v3, v3, b0, n); /* 4b2+b0 */\n  else\n    v3[n] = mpn_add (v3, b0, n, v3, t+1); /* 4b2+b0 */\n  sign ^= abs_sub_add_n (v1, v3, pp, n + 1);\n  TOOM_63_MUL_N_REC(pp, v0, v1, n + 1, ws); /* A(-2)*B(-2) */\n  TOOM_63_MUL_N_REC(r5, v2, v3, n + 1, ws); /* A(+2)*B(+2) */\n  mpn_toom_couple_handling (r5, 2*n+1, pp, sign, n, 1, 2);\n\n  /* A(0)*B(0) */\n  TOOM_63_MUL_N_REC(pp, ap, bp, n, ws);\n\n  /* Infinity */\n  if (s > t) {\n    TOOM_63_MUL_REC(r1, a5, s, b2, t, ws);\n  } else {\n    TOOM_63_MUL_REC(r1, b2, t, a5, s, ws);\n  };\n\n  mpn_toom_interpolate_8pts (pp, n, r3, r7, s + t, ws);\n\n#undef a5\n#undef b0\n#undef b1\n#undef b2\n#undef r1\n#undef r3\n#undef r5\n#undef v0\n#undef v1\n#undef v2\n#undef v3\n#undef r7\n#undef r8\n#undef ws\n}",
      "lines": 137,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom6h_mul.c": {
    "mpn_toom6h_mul": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "void\nmpn_toom6h_mul   (mp_ptr pp,\n\t\t  mp_srcptr ap, mp_size_t an,\n\t\t  mp_srcptr bp, mp_size_t bn, mp_ptr scratch)\n{\n  mp_size_t n, s, t;\n  int p, q, half;\n  int sign;\n\n  /***************************** decomposition *******************************/\n\n  ASSERT (an >= bn);\n  /* Can not handle too much unbalancement */\n  ASSERT (bn >= 42);\n  /* Can not handle too much unbalancement */\n  ASSERT ((an*3 <  bn * 8) || (bn >= 46 && an * 6 <  bn * 17));\n\n  /* Limit num/den is a rational number between\n     (12/11)^(log(4)/log(2*4-1)) and (12/11)^(log(6)/log(2*6-1))             */\n#define LIMIT_numerator (18)\n#define LIMIT_denominat (17)\n\n  if (LIKELY (an * LIMIT_denominat < LIMIT_numerator * bn)) /* is 6*... < 6*... */\n    {\n      n = 1 + (an - 1) / (size_t) 6;\n      p = q = 5;\n      half = 0;\n\n      s = an - 5 * n;\n      t = bn - 5 * n;\n    }\n  else {\n    if (an * 5 * LIMIT_numerator < LIMIT_denominat * 7 * bn)\n      { p = 7; q = 6; }\n    else if (an * 5 * LIMIT_denominat < LIMIT_numerator * 7 * bn)\n      { p = 7; q = 5; }\n    else if (an * LIMIT_numerator < LIMIT_denominat * 2 * bn)  /* is 4*... < 8*... */\n      { p = 8; q = 5; }\n    else if (an * LIMIT_denominat < LIMIT_numerator * 2 * bn)  /* is 4*... < 8*... */\n      { p = 8; q = 4; }\n    else\n      { p = 9; q = 4; }\n\n    half = (p ^ q) & 1;\n    n = 1 + (q * an >= p * bn ? (an - 1) / (size_t) p : (bn - 1) / (size_t) q);\n    p--; q--;\n\n    s = an - p * n;\n    t = bn - q * n;\n\n    /* With LIMIT = 16/15, the following recover is needed only if bn<=73*/\n    if (half) { /* Recover from badly chosen splitting */\n      if (UNLIKELY (s<1)) {p--; s+=n; half=0;}\n      else if (UNLIKELY (t<1)) {q--; t+=n; half=0;}\n    }\n  }\n#undef LIMIT_numerator\n#undef LIMIT_denominat\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n  ASSERT (half || s + t > 3);\n  ASSERT (n > 2);\n\n#define   r4    (pp + 3 * n)\t\t\t/* 3n+1 */\n#define   r2    (pp + 7 * n)\t\t\t/* 3n+1 */\n#define   r0    (pp +11 * n)\t\t\t/* s+t <= 2*n */\n#define   r5    (scratch)\t\t\t/* 3n+1 */\n#define   r3    (scratch + 3 * n + 1)\t\t/* 3n+1 */\n#define   r1    (scratch + 6 * n + 2)\t\t/* 3n+1 */\n#define   v0    (pp + 7 * n)\t\t\t/* n+1 */\n#define   v1    (pp + 8 * n+1)\t\t\t/* n+1 */\n#define   v2    (pp + 9 * n+2)\t\t\t/* n+1 */\n#define   v3    (scratch + 9 * n + 3)\t\t/* n+1 */\n#define   wsi   (scratch + 9 * n + 3)\t\t/* 3n+1 */\n#define   wse   (scratch +10 * n + 4)\t\t/* 2n+1 */\n\n  /* Alloc also 3n+1 limbs for wsi... toom_interpolate_12pts may\n     need all of them  */\n/*   if (scratch == NULL) */\n/*     scratch = TMP_SALLOC_LIMBS(mpn_toom6_sqr_itch(n * 6)); */\n  ASSERT (12 * n + 6 <= mpn_toom6h_mul_itch(an,bn));\n  ASSERT (12 * n + 6 <= mpn_toom6_sqr_itch(n * 6));\n\n  /********************** evaluation and recursive calls *********************/\n  /* $\\pm1/2$ */\n  sign = mpn_toom_eval_pm2rexp (v2, v0, p, ap, n, s, 1, pp) ^\n\t mpn_toom_eval_pm2rexp (v3, v1, q, bp, n, t, 1, pp);\n  /* A(-1/2)*B(-1/2)*2^. */ /* A(+1/2)*B(+1/2)*2^. */\n  TOOM6H_MUL_N_REC(pp, v0, v1, 2, r5, v2, v3, n + 1, wse);\n  mpn_toom_couple_handling (r5, 2 * n + 1, pp, sign, n, 1+half , half);\n\n  /* $\\pm1$ */\n  sign = mpn_toom_eval_pm1 (v2, v0, p, ap, n, s,    pp);\n  if (UNLIKELY (q == 3))\n    sign ^= mpn_toom_eval_dgr3_pm1 (v3, v1, bp, n, t,    pp);\n  else\n    sign ^= mpn_toom_eval_pm1 (v3, v1, q, bp, n, t,    pp);\n  /* A(-1)*B(-1) */ /* A(1)*B(1) */\n  TOOM6H_MUL_N_REC(pp, v0, v1, 2, r3, v2, v3, n + 1, wse);\n  mpn_toom_couple_handling (r3, 2 * n + 1, pp, sign, n, 0, 0);\n\n  /* $\\pm4$ */\n  sign = mpn_toom_eval_pm2exp (v2, v0, p, ap, n, s, 2, pp) ^\n\t mpn_toom_eval_pm2exp (v3, v1, q, bp, n, t, 2, pp);\n  /* A(-4)*B(-4) */\n  TOOM6H_MUL_N_REC(pp, v0, v1, 2, r1, v2, v3, n + 1, wse); /* A(+4)*B(+4) */\n  mpn_toom_couple_handling (r1, 2 * n + 1, pp, sign, n, 2, 4);\n\n  /* $\\pm1/4$ */\n  sign = mpn_toom_eval_pm2rexp (v2, v0, p, ap, n, s, 2, pp) ^\n\t mpn_toom_eval_pm2rexp (v3, v1, q, bp, n, t, 2, pp);\n  /* A(-1/4)*B(-1/4)*4^. */ /* A(+1/4)*B(+1/4)*4^. */\n  TOOM6H_MUL_N_REC(pp, v0, v1, 2, r4, v2, v3, n + 1, wse);\n  mpn_toom_couple_handling (r4, 2 * n + 1, pp, sign, n, 2*(1+half), 2*(half));\n\n  /* $\\pm2$ */\n  sign = mpn_toom_eval_pm2 (v2, v0, p, ap, n, s, pp) ^\n\t mpn_toom_eval_pm2 (v3, v1, q, bp, n, t, pp);\n  /* A(-2)*B(-2) */ /* A(+2)*B(+2) */\n  TOOM6H_MUL_N_REC(pp, v0, v1, 2, r2, v2, v3, n + 1, wse);\n  mpn_toom_couple_handling (r2, 2 * n + 1, pp, sign, n, 1, 2);\n\n#undef v0\n#undef v1\n#undef v2\n#undef v3\n#undef wse\n\n  /* A(0)*B(0) */\n  TOOM6H_MUL_N_REC(pp, ap, bp, 0, pp, ap, bp, n, wsi);\n\n  /* Infinity */\n  if (UNLIKELY (half != 0)) {\n    if (s > t) {\n      TOOM6H_MUL_REC(r0, ap + p * n, s, bp + q * n, t, wsi);\n    } else {\n      TOOM6H_MUL_REC(r0, bp + q * n, t, ap + p * n, s, wsi);\n    };\n  };\n\n  mpn_toom_interpolate_12pts (pp, r1, r3, r5, n, s+t, half, wsi);\n\n#undef r0\n#undef r1\n#undef r2\n#undef r3\n#undef r4\n#undef r5\n#undef wsi\n}",
      "lines": 151,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom6_sqr.c": {
    "mpn_toom6_sqr": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "void\nmpn_toom6_sqr  (mp_ptr pp, mp_srcptr ap, mp_size_t an, mp_ptr scratch)\n{\n  mp_size_t n, s;\n\n  /***************************** decomposition *******************************/\n\n  ASSERT( an >= 18 );\n\n  n = 1 + (an - 1) / (size_t) 6;\n\n  s = an - 5 * n;\n\n  ASSERT (0 < s && s <= n);\n\n#define   r4    (pp + 3 * n)\t\t\t/* 3n+1 */\n#define   r2    (pp + 7 * n)\t\t\t/* 3n+1 */\n#define   r0    (pp +11 * n)\t\t\t/* s+t <= 2*n */\n#define   r5    (scratch)\t\t\t/* 3n+1 */\n#define   r3    (scratch + 3 * n + 1)\t\t/* 3n+1 */\n#define   r1    (scratch + 6 * n + 2)\t\t/* 3n+1 */\n#define   v0    (pp + 7 * n)\t\t\t/* n+1 */\n#define   v2    (pp + 9 * n+2)\t\t\t/* n+1 */\n#define   wse   (scratch + 9 * n + 3)\t\t/* 3n+1 */\n\n  /* Alloc also 3n+1 limbs for ws... toom_interpolate_12pts may\n     need all of them, when DO_mpn_sublsh_n usea a scratch  */\n/*   if (scratch== NULL) */\n/*     scratch = TMP_SALLOC_LIMBS (12 * n + 6); */\n\n  /********************** evaluation and recursive calls *********************/\n  /* $\\pm1/2$ */\n  mpn_toom_eval_pm2rexp (v2, v0, 5, ap, n, s, 1, pp);\n  TOOM6_SQR_REC(pp, v0, n + 1, wse); /* A(-1/2)*B(-1/2)*2^. */\n  TOOM6_SQR_REC(r5, v2, n + 1, wse); /* A(+1/2)*B(+1/2)*2^. */\n  mpn_toom_couple_handling (r5, 2 * n + 1, pp, 0, n, 1, 0);\n\n  /* $\\pm1$ */\n  mpn_toom_eval_pm1 (v2, v0, 5, ap, n, s,    pp);\n  TOOM6_SQR_REC(pp, v0, n + 1, wse); /* A(-1)*B(-1) */\n  TOOM6_SQR_REC(r3, v2, n + 1, wse); /* A(1)*B(1) */\n  mpn_toom_couple_handling (r3, 2 * n + 1, pp, 0, n, 0, 0);\n\n  /* $\\pm4$ */\n  mpn_toom_eval_pm2exp (v2, v0, 5, ap, n, s, 2, pp);\n  TOOM6_SQR_REC(pp, v0, n + 1, wse); /* A(-4)*B(-4) */\n  TOOM6_SQR_REC(r1, v2, n + 1, wse); /* A(+4)*B(+4) */\n  mpn_toom_couple_handling (r1, 2 * n + 1, pp, 0, n, 2, 4);\n\n  /* $\\pm1/4$ */\n  mpn_toom_eval_pm2rexp (v2, v0, 5, ap, n, s, 2, pp);\n  TOOM6_SQR_REC(pp, v0, n + 1, wse); /* A(-1/4)*B(-1/4)*4^. */\n  TOOM6_SQR_REC(r4, v2, n + 1, wse); /* A(+1/4)*B(+1/4)*4^. */\n  mpn_toom_couple_handling (r4, 2 * n + 1, pp, 0, n, 2, 0);\n\n  /* $\\pm2$ */\n  mpn_toom_eval_pm2 (v2, v0, 5, ap, n, s, pp);\n  TOOM6_SQR_REC(pp, v0, n + 1, wse); /* A(-2)*B(-2) */\n  TOOM6_SQR_REC(r2, v2, n + 1, wse); /* A(+2)*B(+2) */\n  mpn_toom_couple_handling (r2, 2 * n + 1, pp, 0, n, 1, 2);\n\n#undef v0\n#undef v2\n\n  /* A(0)*B(0) */\n  TOOM6_SQR_REC(pp, ap, n, wse);\n\n  mpn_toom_interpolate_12pts (pp, r1, r3, r5, n, 2 * s, 0, wse);\n\n#undef r0\n#undef r1\n#undef r2\n#undef r3\n#undef r4\n#undef r5\n\n}",
      "lines": 77,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom8h_mul.c": {
    "mpn_toom8h_mul": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "void\nmpn_toom8h_mul   (mp_ptr pp,\n\t\t  mp_srcptr ap, mp_size_t an,\n\t\t  mp_srcptr bp, mp_size_t bn, mp_ptr scratch)\n{\n  mp_size_t n, s, t;\n  int p, q, half;\n  int sign;\n\n  /***************************** decomposition *******************************/\n\n  ASSERT (an >= bn);\n  /* Can not handle too small operands */\n  ASSERT (bn >= 86);\n  /* Can not handle too much unbalancement */\n  ASSERT (an <= bn*4);\n  ASSERT (GMP_NUMB_BITS > 11*3 || an*4 <= bn*11);\n  ASSERT (GMP_NUMB_BITS > 10*3 || an*1 <= bn* 2);\n  ASSERT (GMP_NUMB_BITS >  9*3 || an*2 <= bn* 3);\n\n  /* Limit num/den is a rational number between\n     (16/15)^(log(6)/log(2*6-1)) and (16/15)^(log(8)/log(2*8-1))             */\n#define LIMIT_numerator (21)\n#define LIMIT_denominat (20)\n\n  if (LIKELY (an == bn) || an * (LIMIT_denominat>>1) < LIMIT_numerator * (bn>>1) ) /* is 8*... < 8*... */\n    {\n      half = 0;\n      n = 1 + ((an - 1)>>3);\n      p = q = 7;\n      s = an - 7 * n;\n      t = bn - 7 * n;\n    }\n  else\n    {\n      if (an * 13 < 16 * bn) /* (an*7*LIMIT_numerator<LIMIT_denominat*9*bn) */\n\t{ p = 9; q = 8; }\n      else if (GMP_NUMB_BITS <= 9*3 ||\n\t       an *(LIMIT_denominat>>1) < (LIMIT_numerator/7*9) * (bn>>1))\n\t{ p = 9; q = 7; }\n      else if (an * 10 < 33 * (bn>>1)) /* (an*3*LIMIT_numerator<LIMIT_denominat*5*bn) */\n\t{ p =10; q = 7; }\n      else if (GMP_NUMB_BITS <= 10*3 ||\n\t       an * (LIMIT_denominat/5) < (LIMIT_numerator/3) * bn)\n\t{ p =10; q = 6; }\n      else if (an * 6 < 13 * bn) /*(an * 5 * LIMIT_numerator < LIMIT_denominat *11 * bn)*/\n\t{ p =11; q = 6; }\n      else if (GMP_NUMB_BITS <= 11*3 ||\n\t       an * 4 < 9 * bn)\n\t{ p =11; q = 5; }\n      else if (an *(LIMIT_numerator/3) < LIMIT_denominat * bn)  /* is 4*... <12*... */\n\t{ p =12; q = 5; }\n      else if (GMP_NUMB_BITS <= 12*3 ||\n\t       an * 9 < 28 * bn )  /* is 4*... <12*... */\n\t{ p =12; q = 4; }\n      else\n\t{ p =13; q = 4; }\n\n      half = (p+q)&1;\n      n = 1 + (q * an >= p * bn ? (an - 1) / (size_t) p : (bn - 1) / (size_t) q);\n      p--; q--;\n\n      s = an - p * n;\n      t = bn - q * n;\n\n      if(half) { /* Recover from badly chosen splitting */\n\tif (UNLIKELY (s<1)) {p--; s+=n; half=0;}\n\telse if (UNLIKELY (t<1)) {q--; t+=n; half=0;}\n      }\n    }\n#undef LIMIT_numerator\n#undef LIMIT_denominat\n\n  ASSERT (0 < s && s <= n);\n  ASSERT (0 < t && t <= n);\n  ASSERT (half || s + t > 3);\n  ASSERT (n > 2);\n\n#define   r6    (pp + 3 * n)\t\t\t/* 3n+1 */\n#define   r4    (pp + 7 * n)\t\t\t/* 3n+1 */\n#define   r2    (pp +11 * n)\t\t\t/* 3n+1 */\n#define   r0    (pp +15 * n)\t\t\t/* s+t <= 2*n */\n#define   r7    (scratch)\t\t\t/* 3n+1 */\n#define   r5    (scratch + 3 * n + 1)\t\t/* 3n+1 */\n#define   r3    (scratch + 6 * n + 2)\t\t/* 3n+1 */\n#define   r1    (scratch + 9 * n + 3)\t\t/* 3n+1 */\n#define   v0    (pp +11 * n)\t\t\t/* n+1 */\n#define   v1    (pp +12 * n+1)\t\t\t/* n+1 */\n#define   v2    (pp +13 * n+2)\t\t\t/* n+1 */\n#define   v3    (scratch +12 * n + 4)\t\t/* n+1 */\n#define   wsi   (scratch +12 * n + 4)\t\t/* 3n+1 */\n#define   wse   (scratch +13 * n + 5)\t\t/* 2n+1 */\n\n  /* Alloc also 3n+1 limbs for wsi... toom_interpolate_16pts may\n     need all of them  */\n/*   if (scratch == NULL) */\n/*     scratch = TMP_SALLOC_LIMBS(mpn_toom8_sqr_itch(n * 8)); */\n  ASSERT (15 * n + 6 <= mpn_toom8h_mul_itch (an, bn));\n  ASSERT (15 * n + 6 <= mpn_toom8_sqr_itch (n * 8));\n\n  /********************** evaluation and recursive calls *********************/\n\n  /* $\\pm1/8$ */\n  sign = mpn_toom_eval_pm2rexp (v2, v0, p, ap, n, s, 3, pp) ^\n\t mpn_toom_eval_pm2rexp (v3, v1, q, bp, n, t, 3, pp);\n  /* A(-1/8)*B(-1/8)*8^. */ /* A(+1/8)*B(+1/8)*8^. */\n  TOOM8H_MUL_N_REC(pp, v0, v1, 2, r7, v2, v3, n + 1, wse);\n  mpn_toom_couple_handling (r7, 2 * n + 1 + BIT_CORRECTION, pp, sign, n, 3*(1+half), 3*(half));\n\n  /* $\\pm1/4$ */\n  sign = mpn_toom_eval_pm2rexp (v2, v0, p, ap, n, s, 2, pp) ^\n\t mpn_toom_eval_pm2rexp (v3, v1, q, bp, n, t, 2, pp);\n  /* A(-1/4)*B(-1/4)*4^. */ /* A(+1/4)*B(+1/4)*4^. */\n  TOOM8H_MUL_N_REC(pp, v0, v1, 2, r5, v2, v3, n + 1, wse);\n  mpn_toom_couple_handling (r5, 2 * n + 1, pp, sign, n, 2*(1+half), 2*(half));\n\n  /* $\\pm2$ */\n  sign = mpn_toom_eval_pm2 (v2, v0, p, ap, n, s, pp) ^\n\t mpn_toom_eval_pm2 (v3, v1, q, bp, n, t, pp);\n  /* A(-2)*B(-2) */ /* A(+2)*B(+2) */\n  TOOM8H_MUL_N_REC(pp, v0, v1, 2, r3, v2, v3, n + 1, wse);\n  mpn_toom_couple_handling (r3, 2 * n + 1, pp, sign, n, 1, 2);\n\n  /* $\\pm8$ */\n  sign = mpn_toom_eval_pm2exp (v2, v0, p, ap, n, s, 3, pp) ^\n\t mpn_toom_eval_pm2exp (v3, v1, q, bp, n, t, 3, pp);\n  /* A(-8)*B(-8) */ /* A(+8)*B(+8) */\n  TOOM8H_MUL_N_REC(pp, v0, v1, 2, r1, v2, v3, n + 1, wse);\n  mpn_toom_couple_handling (r1, 2 * n + 1 + BIT_CORRECTION, pp, sign, n, 3, 6);\n\n  /* $\\pm1/2$ */\n  sign = mpn_toom_eval_pm2rexp (v2, v0, p, ap, n, s, 1, pp) ^\n\t mpn_toom_eval_pm2rexp (v3, v1, q, bp, n, t, 1, pp);\n  /* A(-1/2)*B(-1/2)*2^. */ /* A(+1/2)*B(+1/2)*2^. */\n  TOOM8H_MUL_N_REC(pp, v0, v1, 2, r6, v2, v3, n + 1, wse);\n  mpn_toom_couple_handling (r6, 2 * n + 1, pp, sign, n, 1+half, half);\n\n  /* $\\pm1$ */\n  sign = mpn_toom_eval_pm1 (v2, v0, p, ap, n, s,    pp);\n  if (GMP_NUMB_BITS > 12*3 && UNLIKELY (q == 3))\n    sign ^= mpn_toom_eval_dgr3_pm1 (v3, v1, bp, n, t,    pp);\n  else\n    sign ^= mpn_toom_eval_pm1 (v3, v1, q, bp, n, t,    pp);\n  /* A(-1)*B(-1) */ /* A(1)*B(1) */\n  TOOM8H_MUL_N_REC(pp, v0, v1, 2, r4, v2, v3, n + 1, wse);\n  mpn_toom_couple_handling (r4, 2 * n + 1, pp, sign, n, 0, 0);\n\n  /* $\\pm4$ */\n  sign = mpn_toom_eval_pm2exp (v2, v0, p, ap, n, s, 2, pp) ^\n\t mpn_toom_eval_pm2exp (v3, v1, q, bp, n, t, 2, pp);\n  /* A(-4)*B(-4) */ /* A(+4)*B(+4) */\n  TOOM8H_MUL_N_REC(pp, v0, v1, 2, r2, v2, v3, n + 1, wse);\n  mpn_toom_couple_handling (r2, 2 * n + 1, pp, sign, n, 2, 4);\n\n#undef v0\n#undef v1\n#undef v2\n#undef v3\n#undef wse\n\n  /* A(0)*B(0) */\n  TOOM8H_MUL_N_REC(pp, ap, bp, 0, pp, ap, bp, n, wsi);\n\n  /* Infinity */\n  if (UNLIKELY (half != 0)) {\n    if (s > t) {\n      TOOM8H_MUL_REC(r0, ap + p * n, s, bp + q * n, t, wsi);\n    } else {\n      TOOM8H_MUL_REC(r0, bp + q * n, t, ap + p * n, s, wsi);\n    };\n  };\n\n  mpn_toom_interpolate_16pts (pp, r1, r3, r5, r7, n, s+t, half, wsi);\n\n#undef r0\n#undef r1\n#undef r2\n#undef r3\n#undef r4\n#undef r5\n#undef r6\n#undef wsi\n}",
      "lines": 183,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom8_sqr.c": {
    "mpn_toom8_sqr": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "void\nmpn_toom8_sqr  (mp_ptr pp, mp_srcptr ap, mp_size_t an, mp_ptr scratch)\n{\n  mp_size_t n, s;\n\n  /***************************** decomposition *******************************/\n\n  ASSERT ( an >= 40 );\n\n  n = 1 + ((an - 1)>>3);\n\n  s = an - 7 * n;\n\n  ASSERT (0 < s && s <= n);\n  ASSERT ( s + s > 3 );\n\n#define   r6    (pp + 3 * n)\t\t\t/* 3n+1 */\n#define   r4    (pp + 7 * n)\t\t\t/* 3n+1 */\n#define   r2    (pp +11 * n)\t\t\t/* 3n+1 */\n#define   r0    (pp +15 * n)\t\t\t/* s+t <= 2*n */\n#define   r7    (scratch)\t\t\t/* 3n+1 */\n#define   r5    (scratch + 3 * n + 1)\t\t/* 3n+1 */\n#define   r3    (scratch + 6 * n + 2)\t\t/* 3n+1 */\n#define   r1    (scratch + 9 * n + 3)\t\t/* 3n+1 */\n#define   v0    (pp +11 * n)\t\t\t/* n+1 */\n#define   v2    (pp +13 * n+2)\t\t\t/* n+1 */\n#define   wse   (scratch +12 * n + 4)\t\t/* 3n+1 */\n\n  /* Alloc also 3n+1 limbs for ws... toom_interpolate_16pts may\n     need all of them, when DO_mpn_sublsh_n usea a scratch  */\n/*   if (scratch == NULL) */\n/*     scratch = TMP_SALLOC_LIMBS (30 * n + 6); */\n\n  /********************** evaluation and recursive calls *********************/\n  /* $\\pm1/8$ */\n  mpn_toom_eval_pm2rexp (v2, v0, 7, ap, n, s, 3, pp);\n  /* A(-1/8)*B(-1/8)*8^. */ /* A(+1/8)*B(+1/8)*8^. */\n  TOOM8_SQR_REC(pp, v0, 2, r7, v2, n + 1, wse);\n  mpn_toom_couple_handling (r7, 2 * n + 1 + BIT_CORRECTION, pp, 0, n, 3, 0);\n\n  /* $\\pm1/4$ */\n  mpn_toom_eval_pm2rexp (v2, v0, 7, ap, n, s, 2, pp);\n  /* A(-1/4)*B(-1/4)*4^. */ /* A(+1/4)*B(+1/4)*4^. */\n  TOOM8_SQR_REC(pp, v0, 2, r5, v2, n + 1, wse);\n  mpn_toom_couple_handling (r5, 2 * n + 1, pp, 0, n, 2, 0);\n\n  /* $\\pm2$ */\n  mpn_toom_eval_pm2 (v2, v0, 7, ap, n, s, pp);\n  /* A(-2)*B(-2) */ /* A(+2)*B(+2) */\n  TOOM8_SQR_REC(pp, v0, 2, r3, v2, n + 1, wse);\n  mpn_toom_couple_handling (r3, 2 * n + 1, pp, 0, n, 1, 2);\n\n  /* $\\pm8$ */\n  mpn_toom_eval_pm2exp (v2, v0, 7, ap, n, s, 3, pp);\n  /* A(-8)*B(-8) */ /* A(+8)*B(+8) */\n  TOOM8_SQR_REC(pp, v0, 2, r1, v2, n + 1, wse);\n  mpn_toom_couple_handling (r1, 2 * n + 1 + BIT_CORRECTION, pp, 0, n, 3, 6);\n\n  /* $\\pm1/2$ */\n  mpn_toom_eval_pm2rexp (v2, v0, 7, ap, n, s, 1, pp);\n  /* A(-1/2)*B(-1/2)*2^. */ /* A(+1/2)*B(+1/2)*2^. */\n  TOOM8_SQR_REC(pp, v0, 2, r6, v2, n + 1, wse);\n  mpn_toom_couple_handling (r6, 2 * n + 1, pp, 0, n, 1, 0);\n\n  /* $\\pm1$ */\n  mpn_toom_eval_pm1 (v2, v0, 7, ap, n, s,    pp);\n  /* A(-1)*B(-1) */ /* A(1)*B(1) */\n  TOOM8_SQR_REC(pp, v0, 2, r4, v2, n + 1, wse);\n  mpn_toom_couple_handling (r4, 2 * n + 1, pp, 0, n, 0, 0);\n\n  /* $\\pm4$ */\n  mpn_toom_eval_pm2exp (v2, v0, 7, ap, n, s, 2, pp);\n  /* A(-4)*B(-4) */ /* A(+4)*B(+4) */\n  TOOM8_SQR_REC(pp, v0, 2, r2, v2, n + 1, wse);\n  mpn_toom_couple_handling (r2, 2 * n + 1, pp, 0, n, 2, 4);\n\n#undef v0\n#undef v2\n\n  /* A(0)*B(0) */\n  TOOM8_SQR_REC(pp, ap, 0, pp, ap, n, wse);\n\n  mpn_toom_interpolate_16pts (pp, r1, r3, r5, r7, n, 2 * s, 0, wse);\n\n#undef r0\n#undef r1\n#undef r2\n#undef r3\n#undef r4\n#undef r5\n#undef r6\n#undef wse\n\n}",
      "lines": 94,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_couple_handling.c": {
    "mpn_toom_couple_handling": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nmpn_toom_couple_handling (mp_ptr pp, mp_size_t n, mp_ptr np,\n\t\t\t  int nsign, mp_size_t off, int ps, int ns)\n{\n  if (nsign) {\n#ifdef HAVE_NATIVE_mpn_rsh1sub_n\n    mpn_rsh1sub_n (np, pp, np, n);\n#else\n    mpn_sub_n (np, pp, np, n);\n    mpn_rshift (np, np, n, 1);\n#endif\n  } else {\n#ifdef HAVE_NATIVE_mpn_rsh1add_n\n    mpn_rsh1add_n (np, pp, np, n);\n#else\n    mpn_add_n (np, pp, np, n);\n    mpn_rshift (np, np, n, 1);\n#endif\n  }\n\n#ifdef HAVE_NATIVE_mpn_rsh1sub_n\n  if (ps == 1)\n    mpn_rsh1sub_n (pp, pp, np, n);\n  else\n#endif\n  {\n    mpn_sub_n (pp, pp, np, n);\n    if (ps > 0)\n      mpn_rshift (pp, pp, n, ps);\n  }\n  if (ns > 0)\n    mpn_rshift (np, np, n, ns);\n  pp[n] = mpn_add_n (pp+off, pp+off, np, n-off);\n  ASSERT_NOCARRY (mpn_add_1(pp+n, np+n-off, off, pp[n]) );\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_eval_dgr3_pm1.c": {
    "mpn_toom_eval_dgr3_pm1": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nmpn_toom_eval_dgr3_pm1 (mp_ptr xp1, mp_ptr xm1,\n\t\t\tmp_srcptr xp, mp_size_t n, mp_size_t x3n, mp_ptr tp)\n{\n  int neg;\n\n  ASSERT (x3n > 0);\n  ASSERT (x3n <= n);\n\n  xp1[n] = mpn_add_n (xp1, xp, xp + 2*n, n);\n  tp[n] = mpn_add (tp, xp + n, n, xp + 3*n, x3n);\n\n  neg = (mpn_cmp (xp1, tp, n + 1) < 0) ? ~0 : 0;\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (neg)\n    mpn_add_n_sub_n (xp1, xm1, tp, xp1, n + 1);\n  else\n    mpn_add_n_sub_n (xp1, xm1, xp1, tp, n + 1);\n#else\n  if (neg)\n    mpn_sub_n (xm1, tp, xp1, n + 1);\n  else\n    mpn_sub_n (xm1, xp1, tp, n + 1);\n\n  mpn_add_n (xp1, xp1, tp, n + 1);\n#endif\n\n  ASSERT (xp1[n] <= 3);\n  ASSERT (xm1[n] <= 1);\n\n  return neg;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_eval_dgr3_pm2.c": {
    "mpn_toom_eval_dgr3_pm2": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nmpn_toom_eval_dgr3_pm2 (mp_ptr xp2, mp_ptr xm2,\n\t\t\tmp_srcptr xp, mp_size_t n, mp_size_t x3n, mp_ptr tp)\n{\n  mp_limb_t cy;\n  int neg;\n\n  ASSERT (x3n > 0);\n  ASSERT (x3n <= n);\n\n  /* (x0 + 4 * x2) +/- (2 x1 + 8 x_3) */\n#if HAVE_NATIVE_mpn_addlsh_n || HAVE_NATIVE_mpn_addlsh2_n\n#if HAVE_NATIVE_mpn_addlsh2_n\n  xp2[n] = mpn_addlsh2_n (xp2, xp, xp + 2*n, n);\n\n  cy = mpn_addlsh2_n (tp, xp + n, xp + 3*n, x3n);\n#else /* HAVE_NATIVE_mpn_addlsh_n */\n  xp2[n] = mpn_addlsh_n (xp2, xp, xp + 2*n, n, 2);\n\n  cy = mpn_addlsh_n (tp, xp + n, xp + 3*n, x3n, 2);\n#endif\n  if (x3n < n)\n    cy = mpn_add_1 (tp + x3n, xp + n + x3n, n - x3n, cy);\n  tp[n] = cy;\n#else\n  cy = mpn_lshift (tp, xp + 2*n, n, 2);\n  xp2[n] = cy + mpn_add_n (xp2, tp, xp, n);\n\n  tp[x3n] = mpn_lshift (tp, xp + 3*n, x3n, 2);\n  if (x3n < n)\n    tp[n] = mpn_add (tp, xp + n, n, tp, x3n + 1);\n  else\n    tp[n] += mpn_add_n (tp, xp + n, tp, n);\n#endif\n  mpn_lshift (tp, tp, n+1, 1);\n\n  neg = (mpn_cmp (xp2, tp, n + 1) < 0) ? ~0 : 0;\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (neg)\n    mpn_add_n_sub_n (xp2, xm2, tp, xp2, n + 1);\n  else\n    mpn_add_n_sub_n (xp2, xm2, xp2, tp, n + 1);\n#else\n  if (neg)\n    mpn_sub_n (xm2, tp, xp2, n + 1);\n  else\n    mpn_sub_n (xm2, xp2, tp, n + 1);\n\n  mpn_add_n (xp2, xp2, tp, n + 1);\n#endif\n\n  ASSERT (xp2[n] < 15);\n  ASSERT (xm2[n] < 10);\n\n  return neg;\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_eval_pm1.c": {
    "mpn_toom_eval_pm1": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nmpn_toom_eval_pm1 (mp_ptr xp1, mp_ptr xm1, unsigned k,\n\t\t   mp_srcptr xp, mp_size_t n, mp_size_t hn, mp_ptr tp)\n{\n  unsigned i;\n  int neg;\n\n  ASSERT (k >= 4);\n\n  ASSERT (hn > 0);\n  ASSERT (hn <= n);\n\n  /* The degree k is also the number of full-size coefficients, so\n   * that last coefficient, of size hn, starts at xp + k*n. */\n\n  xp1[n] = mpn_add_n (xp1, xp, xp + 2*n, n);\n  for (i = 4; i < k; i += 2)\n    ASSERT_NOCARRY (mpn_add (xp1, xp1, n+1, xp+i*n, n));\n\n  tp[n] = mpn_add_n (tp, xp + n, xp + 3*n, n);\n  for (i = 5; i < k; i += 2)\n    ASSERT_NOCARRY (mpn_add (tp, tp, n+1, xp+i*n, n));\n\n  if (k & 1)\n    ASSERT_NOCARRY (mpn_add (tp, tp, n+1, xp+k*n, hn));\n  else\n    ASSERT_NOCARRY (mpn_add (xp1, xp1, n+1, xp+k*n, hn));\n\n  neg = (mpn_cmp (xp1, tp, n + 1) < 0) ? ~0 : 0;\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (neg)\n    mpn_add_n_sub_n (xp1, xm1, tp, xp1, n + 1);\n  else\n    mpn_add_n_sub_n (xp1, xm1, xp1, tp, n + 1);\n#else\n  if (neg)\n    mpn_sub_n (xm1, tp, xp1, n + 1);\n  else\n    mpn_sub_n (xm1, xp1, tp, n + 1);\n\n  mpn_add_n (xp1, xp1, tp, n + 1);\n#endif\n\n  ASSERT (xp1[n] <= k);\n  ASSERT (xm1[n] <= k/2 + 1);\n\n  return neg;\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_eval_pm2.c": {
    "mpn_toom_eval_pm2": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nmpn_toom_eval_pm2 (mp_ptr xp2, mp_ptr xm2, unsigned k,\n\t\t   mp_srcptr xp, mp_size_t n, mp_size_t hn, mp_ptr tp)\n{\n  int i;\n  int neg;\n  mp_limb_t cy;\n\n  ASSERT (k >= 3);\n  ASSERT (k < GMP_NUMB_BITS);\n\n  ASSERT (hn > 0);\n  ASSERT (hn <= n);\n\n  /* The degree k is also the number of full-size coefficients, so\n   * that last coefficient, of size hn, starts at xp + k*n. */\n\n  cy = 0;\n  DO_addlsh2 (xp2, xp + (k-2) * n, xp + k * n, hn, cy);\n  if (hn != n)\n    cy = mpn_add_1 (xp2 + hn, xp + (k-2) * n + hn, n - hn, cy);\n  for (i = k - 4; i >= 0; i -= 2)\n    DO_addlsh2 (xp2, xp + i * n, xp2, n, cy);\n  xp2[n] = cy;\n\n  k--;\n\n  cy = 0;\n  DO_addlsh2 (tp, xp + (k-2) * n, xp + k * n, n, cy);\n  for (i = k - 4; i >= 0; i -= 2)\n    DO_addlsh2 (tp, xp + i * n, tp, n, cy);\n  tp[n] = cy;\n\n  if (k & 1)\n    ASSERT_NOCARRY(mpn_lshift (tp , tp , n + 1, 1));\n  else\n    ASSERT_NOCARRY(mpn_lshift (xp2, xp2, n + 1, 1));\n\n  neg = (mpn_cmp (xp2, tp, n + 1) < 0) ? ~0 : 0;\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (neg)\n    mpn_add_n_sub_n (xp2, xm2, tp, xp2, n + 1);\n  else\n    mpn_add_n_sub_n (xp2, xm2, xp2, tp, n + 1);\n#else /* !HAVE_NATIVE_mpn_add_n_sub_n */\n  if (neg)\n    mpn_sub_n (xm2, tp, xp2, n + 1);\n  else\n    mpn_sub_n (xm2, xp2, tp, n + 1);\n\n  mpn_add_n (xp2, xp2, tp, n + 1);\n#endif /* !HAVE_NATIVE_mpn_add_n_sub_n */\n\n  ASSERT (xp2[n] < (1<<(k+2))-1);\n  ASSERT (xm2[n] < ((1<<(k+3))-1 - (1^k&1))/3);\n\n  neg ^= ((k & 1) - 1);\n\n  return neg;\n}",
      "lines": 61,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_eval_pm2exp.c": {
    "mpn_toom_eval_pm2exp": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\nmpn_toom_eval_pm2exp (mp_ptr xp2, mp_ptr xm2, unsigned k,\n\t\t      mp_srcptr xp, mp_size_t n, mp_size_t hn, unsigned shift,\n\t\t      mp_ptr tp)\n{\n  unsigned i;\n  int neg;\n#if HAVE_NATIVE_mpn_addlsh_n\n  mp_limb_t cy;\n#endif\n\n  ASSERT (k >= 3);\n  ASSERT (shift*k < GMP_NUMB_BITS);\n\n  ASSERT (hn > 0);\n  ASSERT (hn <= n);\n\n  /* The degree k is also the number of full-size coefficients, so\n   * that last coefficient, of size hn, starts at xp + k*n. */\n\n#if HAVE_NATIVE_mpn_addlsh_n\n  xp2[n] = mpn_addlsh_n (xp2, xp, xp + 2*n, n, 2*shift);\n  for (i = 4; i < k; i += 2)\n    xp2[n] += mpn_addlsh_n (xp2, xp2, xp + i*n, n, i*shift);\n\n  tp[n] = mpn_lshift (tp, xp+n, n, shift);\n  for (i = 3; i < k; i+= 2)\n    tp[n] += mpn_addlsh_n (tp, tp, xp+i*n, n, i*shift);\n\n  if (k & 1)\n    {\n      cy = mpn_addlsh_n (tp, tp, xp+k*n, hn, k*shift);\n      MPN_INCR_U (tp + hn, n+1 - hn, cy);\n    }\n  else\n    {\n      cy = mpn_addlsh_n (xp2, xp2, xp+k*n, hn, k*shift);\n      MPN_INCR_U (xp2 + hn, n+1 - hn, cy);\n    }\n\n#else /* !HAVE_NATIVE_mpn_addlsh_n */\n  xp2[n] = mpn_lshift (tp, xp+2*n, n, 2*shift);\n  xp2[n] += mpn_add_n (xp2, xp, tp, n);\n  for (i = 4; i < k; i += 2)\n    {\n      xp2[n] += mpn_lshift (tp, xp + i*n, n, i*shift);\n      xp2[n] += mpn_add_n (xp2, xp2, tp, n);\n    }\n\n  tp[n] = mpn_lshift (tp, xp+n, n, shift);\n  for (i = 3; i < k; i+= 2)\n    {\n      tp[n] += mpn_lshift (xm2, xp + i*n, n, i*shift);\n      tp[n] += mpn_add_n (tp, tp, xm2, n);\n    }\n\n  xm2[hn] = mpn_lshift (xm2, xp + k*n, hn, k*shift);\n  if (k & 1)\n    mpn_add (tp, tp, n+1, xm2, hn+1);\n  else\n    mpn_add (xp2, xp2, n+1, xm2, hn+1);\n#endif /* !HAVE_NATIVE_mpn_addlsh_n */\n\n  neg = (mpn_cmp (xp2, tp, n + 1) < 0) ? ~0 : 0;\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (neg)\n    mpn_add_n_sub_n (xp2, xm2, tp, xp2, n + 1);\n  else\n    mpn_add_n_sub_n (xp2, xm2, xp2, tp, n + 1);\n#else /* !HAVE_NATIVE_mpn_add_n_sub_n */\n  if (neg)\n    mpn_sub_n (xm2, tp, xp2, n + 1);\n  else\n    mpn_sub_n (xm2, xp2, tp, n + 1);\n\n  mpn_add_n (xp2, xp2, tp, n + 1);\n#endif /* !HAVE_NATIVE_mpn_add_n_sub_n */\n\n  /* FIXME: the following asserts are useless if (k+1)*shift >= GMP_LIMB_BITS */\n  ASSERT ((k+1)*shift >= GMP_LIMB_BITS ||\n\t  xp2[n] < ((CNST_LIMB(1)<<((k+1)*shift))-1)/((CNST_LIMB(1)<<shift)-1));\n  ASSERT ((k+2)*shift >= GMP_LIMB_BITS ||\n\t  xm2[n] < ((CNST_LIMB(1)<<((k+2)*shift))-((k&1)?(CNST_LIMB(1)<<shift):1))/((CNST_LIMB(1)<<(2*shift))-1));\n\n  return neg;\n}",
      "lines": 87,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_eval_pm2rexp.c": {
    "DO_mpn_addlsh_n": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static mp_limb_t\nDO_mpn_addlsh_n(mp_ptr dst, mp_srcptr src, mp_size_t n, unsigned int s, mp_ptr ws)\n{\n#if USE_MUL_1 && 0\n  return mpn_addmul_1(dst,src,n,CNST_LIMB(1) <<(s));\n#else\n  mp_limb_t __cy;\n  __cy = mpn_lshift(ws,src,n,s);\n  return    __cy + mpn_add_n(dst,dst,ws,n);\n#endif\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_toom_eval_pm2rexp": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nmpn_toom_eval_pm2rexp (mp_ptr rp, mp_ptr rm,\n\t\t      unsigned int q, mp_srcptr ap, mp_size_t n, mp_size_t t,\n\t\t      unsigned int s, mp_ptr ws)\n{\n  unsigned int i;\n  int neg;\n  /* {ap,q*n+t} -> {rp,n+1} {rm,n+1} , with {ws, n+1}*/\n  ASSERT (n >= t);\n  ASSERT (s != 0); /* or _eval_pm1 should be used */\n  ASSERT (q > 1);\n  ASSERT (s*q < GMP_NUMB_BITS);\n  rp[n] = mpn_lshift(rp, ap, n, s*q);\n  ws[n] = mpn_lshift(ws, ap+n, n, s*(q-1));\n  if( (q & 1) != 0) {\n    ASSERT_NOCARRY(mpn_add(ws,ws,n+1,ap+n*q,t));\n    rp[n] += DO_mpn_addlsh_n(rp, ap+n*(q-1), n, s, rm);\n  } else {\n    ASSERT_NOCARRY(mpn_add(rp,rp,n+1,ap+n*q,t));\n  }\n  for(i=2; i<q-1; i++)\n  {\n    rp[n] += DO_mpn_addlsh_n(rp, ap+n*i, n, s*(q-i), rm);\n    i++;\n    ws[n] += DO_mpn_addlsh_n(ws, ap+n*i, n, s*(q-i), rm);\n  };\n\n  neg = (mpn_cmp (rp, ws, n + 1) < 0) ? ~0 : 0;\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  if (neg)\n    mpn_add_n_sub_n (rp, rm, ws, rp, n + 1);\n  else\n    mpn_add_n_sub_n (rp, rm, rp, ws, n + 1);\n#else /* !HAVE_NATIVE_mpn_add_n_sub_n */\n  if (neg)\n    mpn_sub_n (rm, ws, rp, n + 1);\n  else\n    mpn_sub_n (rm, rp, ws, n + 1);\n\n  ASSERT_NOCARRY (mpn_add_n (rp, rp, ws, n + 1));\n#endif /* !HAVE_NATIVE_mpn_add_n_sub_n */\n\n  return neg;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_interpolate_12pts.c": {
    "DO_mpn_sublsh_n": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static mp_limb_t\nDO_mpn_sublsh_n(mp_ptr dst, mp_srcptr src, mp_size_t n, unsigned int s, mp_ptr ws)\n{\n#if USE_MUL_1 && 0\n  return mpn_submul_1(dst,src,n,CNST_LIMB(1) <<(s));\n#else\n  mp_limb_t __cy;\n  __cy = mpn_lshift(ws,src,n,s);\n  return    __cy + mpn_sub_n(dst,dst,ws,n);\n#endif\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "DO_mpn_addlsh_n": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static mp_limb_t\nDO_mpn_addlsh_n(mp_ptr dst, mp_srcptr src, mp_size_t n, unsigned int s, mp_ptr ws)\n{\n#if USE_MUL_1 && 0\n  return mpn_addmul_1(dst,src,n,CNST_LIMB(1) <<(s));\n#else\n  mp_limb_t __cy;\n  __cy = mpn_lshift(ws,src,n,s);\n  return    __cy + mpn_add_n(dst,dst,ws,n);\n#endif\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_toom_interpolate_12pts": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "void\nmpn_toom_interpolate_12pts (mp_ptr pp, mp_ptr r1, mp_ptr r3, mp_ptr r5,\n\t\t\tmp_size_t n, mp_size_t spt, int half, mp_ptr wsi)\n{\n  mp_limb_t cy;\n  mp_size_t n3;\n  mp_size_t n3p1;\n  n3 = 3 * n;\n  n3p1 = n3 + 1;\n\n#define   r4    (pp + n3)\t\t\t/* 3n+1 */\n#define   r2    (pp + 7 * n)\t\t\t/* 3n+1 */\n#define   r0    (pp +11 * n)\t\t\t/* s+t <= 2*n */\n\n  /******************************* interpolation *****************************/\n  if (half != 0) {\n    cy = mpn_sub_n (r3, r3, r0, spt);\n    MPN_DECR_U (r3 + spt, n3p1 - spt, cy);\n\n    cy = DO_mpn_sublsh_n (r2, r0, spt, 10, wsi);\n    MPN_DECR_U (r2 + spt, n3p1 - spt, cy);\n    DO_mpn_subrsh(r5, n3p1, r0, spt, 2, wsi);\n\n    cy = DO_mpn_sublsh_n (r1, r0, spt, 20, wsi);\n    MPN_DECR_U (r1 + spt, n3p1 - spt, cy);\n    DO_mpn_subrsh(r4, n3p1, r0, spt, 4, wsi);\n  };\n\n  r4[n3] -= DO_mpn_sublsh_n (r4 + n, pp, 2 * n, 20, wsi);\n  DO_mpn_subrsh(r1 + n, 2 * n + 1, pp, 2 * n, 4, wsi);\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  mpn_add_n_sub_n (r1, r4, r4, r1, n3p1);\n#else\n  ASSERT_NOCARRY(mpn_add_n (wsi, r1, r4, n3p1));\n  mpn_sub_n (r4, r4, r1, n3p1); /* can be negative */\n  MP_PTR_SWAP(r1, wsi);\n#endif\n\n  r5[n3] -= DO_mpn_sublsh_n (r5 + n, pp, 2 * n, 10, wsi);\n  DO_mpn_subrsh(r2 + n, 2 * n + 1, pp, 2 * n, 2, wsi);\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  mpn_add_n_sub_n (r2, r5, r5, r2, n3p1);\n#else\n  mpn_sub_n (wsi, r5, r2, n3p1); /* can be negative */\n  ASSERT_NOCARRY(mpn_add_n (r2, r2, r5, n3p1));\n  MP_PTR_SWAP(r5, wsi);\n#endif\n\n  r3[n3] -= mpn_sub_n (r3+n, r3+n, pp, 2 * n);\n\n#if AORSMUL_FASTER_AORS_AORSLSH\n  mpn_submul_1 (r4, r5, n3p1, 257); /* can be negative */\n#else\n  mpn_sub_n (r4, r4, r5, n3p1); /* can be negative */\n  DO_mpn_sublsh_n (r4, r5, n3p1, 8, wsi); /* can be negative */\n#endif\n  /* A division by 2835x4 follows. Warning: the operand can be negative! */\n  mpn_divexact_by2835x4(r4, r4, n3p1);\n  if ((r4[n3] & (GMP_NUMB_MAX << (GMP_NUMB_BITS-3))) != 0)\n    r4[n3] |= (GMP_NUMB_MAX << (GMP_NUMB_BITS-2));\n\n#if AORSMUL_FASTER_2AORSLSH\n  mpn_addmul_1 (r5, r4, n3p1, 60); /* can be negative */\n#else\n  DO_mpn_sublsh_n (r5, r4, n3p1, 2, wsi); /* can be negative */\n  DO_mpn_addlsh_n (r5, r4, n3p1, 6, wsi); /* can give a carry */\n#endif\n  mpn_divexact_by255(r5, r5, n3p1);\n\n  ASSERT_NOCARRY(DO_mpn_sublsh_n (r2, r3, n3p1, 5, wsi));\n\n#if AORSMUL_FASTER_3AORSLSH\n  ASSERT_NOCARRY(mpn_submul_1 (r1, r2, n3p1, 100));\n#else\n  ASSERT_NOCARRY(DO_mpn_sublsh_n (r1, r2, n3p1, 6, wsi));\n  ASSERT_NOCARRY(DO_mpn_sublsh_n (r1, r2, n3p1, 5, wsi));\n  ASSERT_NOCARRY(DO_mpn_sublsh_n (r1, r2, n3p1, 2, wsi));\n#endif\n  ASSERT_NOCARRY(DO_mpn_sublsh_n (r1, r3, n3p1, 9, wsi));\n  mpn_divexact_by42525(r1, r1, n3p1);\n\n#if AORSMUL_FASTER_AORS_2AORSLSH\n  ASSERT_NOCARRY(mpn_submul_1 (r2, r1, n3p1, 225));\n#else\n  ASSERT_NOCARRY(mpn_sub_n (r2, r2, r1, n3p1));\n  ASSERT_NOCARRY(DO_mpn_addlsh_n (r2, r1, n3p1, 5, wsi));\n  ASSERT_NOCARRY(DO_mpn_sublsh_n (r2, r1, n3p1, 8, wsi));\n#endif\n  mpn_divexact_by9x4(r2, r2, n3p1);\n\n  ASSERT_NOCARRY(mpn_sub_n (r3, r3, r2, n3p1));\n\n  mpn_sub_n (r4, r2, r4, n3p1);\n  ASSERT_NOCARRY(mpn_rshift(r4, r4, n3p1, 1));\n  ASSERT_NOCARRY(mpn_sub_n (r2, r2, r4, n3p1));\n\n  mpn_add_n (r5, r5, r1, n3p1);\n  ASSERT_NOCARRY(mpn_rshift(r5, r5, n3p1, 1));\n\n  /* last interpolation steps... */\n  ASSERT_NOCARRY(mpn_sub_n (r3, r3, r1, n3p1));\n  ASSERT_NOCARRY(mpn_sub_n (r1, r1, r5, n3p1));\n  /* ... could be mixed with recomposition\n\t||H-r5|M-r5|L-r5|   ||H-r1|M-r1|L-r1|\n  */\n\n  /***************************** recomposition *******************************/\n  /*\n    pp[] prior to operations:\n    |M r0|L r0|___||H r2|M r2|L r2|___||H r4|M r4|L r4|____|H_r6|L r6|pp\n\n    summation scheme for remaining operations:\n    |__12|n_11|n_10|n__9|n__8|n__7|n__6|n__5|n__4|n__3|n__2|n___|n___|pp\n    |M r0|L r0|___||H r2|M r2|L r2|___||H r4|M r4|L r4|____|H_r6|L r6|pp\n\t||H r1|M r1|L r1|   ||H r3|M r3|L r3|   ||H_r5|M_r5|L_r5|\n  */\n\n  cy = mpn_add_n (pp + n, pp + n, r5, n);\n  cy = mpn_add_1 (pp + 2 * n, r5 + n, n, cy);\n#if HAVE_NATIVE_mpn_add_nc\n  cy = r5[n3] + mpn_add_nc(pp + n3, pp + n3, r5 + 2 * n, n, cy);\n#else\n  MPN_INCR_U (r5 + 2 * n, n + 1, cy);\n  cy = r5[n3] + mpn_add_n (pp + n3, pp + n3, r5 + 2 * n, n);\n#endif\n  MPN_INCR_U (pp + n3 + n, 2 * n + 1, cy);\n\n  pp[2 * n3]+= mpn_add_n (pp + 5 * n, pp + 5 * n, r3, n);\n  cy = mpn_add_1 (pp + 2 * n3, r3 + n, n, pp[2 * n3]);\n#if HAVE_NATIVE_mpn_add_nc\n  cy = r3[n3] + mpn_add_nc(pp + 7 * n, pp + 7 * n, r3 + 2 * n, n, cy);\n#else\n  MPN_INCR_U (r3 + 2 * n, n + 1, cy);\n  cy = r3[n3] + mpn_add_n (pp + 7 * n, pp + 7 * n, r3 + 2 * n, n);\n#endif\n  MPN_INCR_U (pp + 8 * n, 2 * n + 1, cy);\n\n  pp[10*n]+=mpn_add_n (pp + 9 * n, pp + 9 * n, r1, n);\n  if (half) {\n    cy = mpn_add_1 (pp + 10 * n, r1 + n, n, pp[10 * n]);\n#if HAVE_NATIVE_mpn_add_nc\n    if (LIKELY (spt > n)) {\n      cy = r1[n3] + mpn_add_nc(pp + 11 * n, pp + 11 * n, r1 + 2 * n, n, cy);\n      MPN_INCR_U (pp + 4 * n3, spt - n, cy);\n    } else {\n      ASSERT_NOCARRY(mpn_add_nc(pp + 11 * n, pp + 11 * n, r1 + 2 * n, spt, cy));\n    }\n#else\n    MPN_INCR_U (r1 + 2 * n, n + 1, cy);\n    if (LIKELY (spt > n)) {\n      cy = r1[n3] + mpn_add_n (pp + 11 * n, pp + 11 * n, r1 + 2 * n, n);\n      MPN_INCR_U (pp + 4 * n3, spt - n, cy);\n    } else {\n      ASSERT_NOCARRY(mpn_add_n (pp + 11 * n, pp + 11 * n, r1 + 2 * n, spt));\n    }\n#endif\n  } else {\n    ASSERT_NOCARRY(mpn_add_1 (pp + 10 * n, r1 + n, spt, pp[10 * n]));\n  }\n\n#undef   r0\n#undef   r2\n#undef   r4\n}",
      "lines": 166,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_interpolate_16pts.c": {
    "DO_mpn_sublsh_n": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static mp_limb_t\nDO_mpn_sublsh_n(mp_ptr dst, mp_srcptr src, mp_size_t n, unsigned int s, mp_ptr ws)\n{\n#if USE_MUL_1 && 0\n  return mpn_submul_1(dst,src,n,CNST_LIMB(1) <<(s));\n#else\n  mp_limb_t __cy;\n  __cy = mpn_lshift(ws,src,n,s);\n  return    __cy + mpn_sub_n(dst,dst,ws,n);\n#endif\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "DO_mpn_addlsh_n": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static mp_limb_t\nDO_mpn_addlsh_n(mp_ptr dst, mp_srcptr src, mp_size_t n, unsigned int s, mp_ptr ws)\n{\n#if USE_MUL_1 && 0\n  return mpn_addmul_1(dst,src,n,CNST_LIMB(1) <<(s));\n#else\n  mp_limb_t __cy;\n  __cy = mpn_lshift(ws,src,n,s);\n  return    __cy + mpn_add_n(dst,dst,ws,n);\n#endif\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_toom_interpolate_16pts": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        526,
        1
      ],
      "content": "void\nmpn_toom_interpolate_16pts (mp_ptr pp, mp_ptr r1, mp_ptr r3, mp_ptr r5, mp_ptr r7,\n\t\t\tmp_size_t n, mp_size_t spt, int half, mp_ptr wsi)\n{\n  mp_limb_t cy;\n  mp_size_t n3;\n  mp_size_t n3p1;\n  n3 = 3 * n;\n  n3p1 = n3 + 1;\n\n#define   r6    (pp + n3)\t\t\t/* 3n+1 */\n#define   r4    (pp + 7 * n)\t\t\t/* 3n+1 */\n#define   r2    (pp +11 * n)\t\t\t/* 3n+1 */\n#define   r0    (pp +15 * n)\t\t\t/* s+t <= 2*n */\n\n  ASSERT( spt <= 2 * n );\n  /******************************* interpolation *****************************/\n  if( half != 0) {\n    cy = mpn_sub_n (r4, r4, r0, spt);\n    MPN_DECR_U (r4 + spt, n3p1 - spt, cy);\n\n    cy = DO_mpn_sublsh_n (r3, r0, spt, 14, wsi);\n    MPN_DECR_U (r3 + spt, n3p1 - spt, cy);\n    DO_mpn_subrsh(r6, n3p1, r0, spt, 2, wsi);\n\n    cy = DO_mpn_sublsh_n (r2, r0, spt, 28, wsi);\n    MPN_DECR_U (r2 + spt, n3p1 - spt, cy);\n    DO_mpn_subrsh(r5, n3p1, r0, spt, 4, wsi);\n\n    cy = DO_mpn_sublsh_n (r1 + BIT_CORRECTION, r0, spt, 42 - CORRECTION_BITS, wsi);\n#if BIT_CORRECTION\n    cy = mpn_sub_1 (r1 + spt + BIT_CORRECTION, r1 + spt + BIT_CORRECTION,\n\t\t    n3p1 - spt - BIT_CORRECTION, cy);\n    ASSERT (BIT_CORRECTION > 0 || cy == 0);\n    /* FIXME: assumes r7[n3p1] is writable (it is if r5 follows). */\n    cy = r7[n3p1];\n    r7[n3p1] = 0x80;\n#else\n    MPN_DECR_U (r1 + spt + BIT_CORRECTION, n3p1 - spt - BIT_CORRECTION, cy);\n#endif\n    DO_mpn_subrsh(r7, n3p1 + BIT_CORRECTION, r0, spt, 6, wsi);\n#if BIT_CORRECTION\n    /* FIXME: assumes r7[n3p1] is writable. */\n    ASSERT ( BIT_CORRECTION > 0 || r7[n3p1] == 0x80 );\n    r7[n3p1] = cy;\n#endif\n  };\n\n  r5[n3] -= DO_mpn_sublsh_n (r5 + n, pp, 2 * n, 28, wsi);\n  DO_mpn_subrsh(r2 + n, 2 * n + 1, pp, 2 * n, 4, wsi);\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  mpn_add_n_sub_n (r2, r5, r5, r2, n3p1);\n#else\n  mpn_sub_n (wsi, r5, r2, n3p1); /* can be negative */\n  ASSERT_NOCARRY(mpn_add_n (r2, r2, r5, n3p1));\n  MP_PTR_SWAP(r5, wsi);\n#endif\n\n  r6[n3] -= DO_mpn_sublsh_n (r6 + n, pp, 2 * n, 14, wsi);\n  DO_mpn_subrsh(r3 + n, 2 * n + 1, pp, 2 * n, 2, wsi);\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  mpn_add_n_sub_n (r3, r6, r6, r3, n3p1);\n#else\n  ASSERT_NOCARRY(mpn_add_n (wsi, r3, r6, n3p1));\n  mpn_sub_n (r6, r6, r3, n3p1); /* can be negative */\n  MP_PTR_SWAP(r3, wsi);\n#endif\n\n  cy = DO_mpn_sublsh_n (r7 + n + BIT_CORRECTION, pp, 2 * n, 42 - CORRECTION_BITS, wsi);\n#if BIT_CORRECTION\n  MPN_DECR_U (r1 + n, 2 * n + 1, pp[0] >> 6);\n  cy = DO_mpn_sublsh_n (r1 + n, pp + 1, 2 * n - 1, GMP_NUMB_BITS - 6, wsi);\n  cy = mpn_sub_1(r1 + 3 * n - 1, r1 + 3 * n - 1, 2, cy);\n  ASSERT ( BIT_CORRECTION > 0 || cy != 0 );\n#else\n  r7[n3] -= cy;\n  DO_mpn_subrsh(r1 + n, 2 * n + 1, pp, 2 * n, 6, wsi);\n#endif\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n  mpn_add_n_sub_n (r1, r7, r7, r1, n3p1);\n#else\n  mpn_sub_n (wsi, r7, r1, n3p1); /* can be negative */\n  mpn_add_n (r1, r1, r7, n3p1);  /* if BIT_CORRECTION != 0, can give a carry. */\n  MP_PTR_SWAP(r7, wsi);\n#endif\n\n  r4[n3] -= mpn_sub_n (r4+n, r4+n, pp, 2 * n);\n\n#if AORSMUL_FASTER_2AORSLSH\n  mpn_submul_1 (r5, r6, n3p1, 1028); /* can be negative */\n#else\n  DO_mpn_sublsh_n (r5, r6, n3p1, 2, wsi); /* can be negative */\n  DO_mpn_sublsh_n (r5, r6, n3p1,10, wsi); /* can be negative */\n#endif\n\n  mpn_submul_1 (r7, r5, n3p1, 1300); /* can be negative */\n#if AORSMUL_FASTER_3AORSLSH\n  mpn_submul_1 (r7, r6, n3p1, 1052688); /* can be negative */\n#else\n  DO_mpn_sublsh_n (r7, r6, n3p1, 4, wsi); /* can be negative */\n  DO_mpn_sublsh_n (r7, r6, n3p1,12, wsi); /* can be negative */\n  DO_mpn_sublsh_n (r7, r6, n3p1,20, wsi); /* can be negative */\n#endif\n  mpn_divexact_by255x188513325(r7, r7, n3p1);\n\n  mpn_submul_1 (r5, r7, n3p1, 12567555); /* can be negative */\n  /* A division by 2835x64 follows. Warning: the operand can be negative! */\n  mpn_divexact_by2835x64(r5, r5, n3p1);\n  if ((r5[n3] & (GMP_NUMB_MAX << (GMP_NUMB_BITS-7))) != 0)\n    r5[n3] |= (GMP_NUMB_MAX << (GMP_NUMB_BITS-6));\n\n#if AORSMUL_FASTER_AORS_AORSLSH\n  mpn_submul_1 (r6, r7, n3p1, 4095); /* can be negative */\n#else\n  mpn_add_n (r6, r6, r7, n3p1); /* can give a carry */\n  DO_mpn_sublsh_n (r6, r7, n3p1, 12, wsi); /* can be negative */\n#endif\n#if AORSMUL_FASTER_2AORSLSH\n  mpn_addmul_1 (r6, r5, n3p1, 240); /* can be negative */\n#else\n  DO_mpn_addlsh_n (r6, r5, n3p1, 8, wsi); /* can give a carry */\n  DO_mpn_sublsh_n (r6, r5, n3p1, 4, wsi); /* can be negative */\n#endif\n  /* A division by 255x4 follows. Warning: the operand can be negative! */\n  mpn_divexact_by255x4(r6, r6, n3p1);\n  if ((r6[n3] & (GMP_NUMB_MAX << (GMP_NUMB_BITS-3))) != 0)\n    r6[n3] |= (GMP_NUMB_MAX << (GMP_NUMB_BITS-2));\n\n  ASSERT_NOCARRY(DO_mpn_sublsh_n (r3, r4, n3p1, 7, wsi));\n\n  ASSERT_NOCARRY(DO_mpn_sublsh_n (r2, r4, n3p1, 13, wsi));\n  ASSERT_NOCARRY(mpn_submul_1 (r2, r3, n3p1, 400));\n\n  /* If GMP_NUMB_BITS < 42 next operations on r1 can give a carry!*/\n  DO_mpn_sublsh_n (r1, r4, n3p1, 19, wsi);\n  mpn_submul_1 (r1, r2, n3p1, 1428);\n  mpn_submul_1 (r1, r3, n3p1, 112896);\n  mpn_divexact_by255x182712915(r1, r1, n3p1);\n\n  ASSERT_NOCARRY(mpn_submul_1 (r2, r1, n3p1, 15181425));\n  mpn_divexact_by42525x16(r2, r2, n3p1);\n\n#if AORSMUL_FASTER_AORS_2AORSLSH\n  ASSERT_NOCARRY(mpn_submul_1 (r3, r1, n3p1, 3969));\n#else\n  ASSERT_NOCARRY(mpn_sub_n (r3, r3, r1, n3p1));\n  ASSERT_NOCARRY(DO_mpn_addlsh_n (r3, r1, n3p1, 7, wsi));\n  ASSERT_NOCARRY(DO_mpn_sublsh_n (r3, r1, n3p1, 12, wsi));\n#endif\n  ASSERT_NOCARRY(mpn_submul_1 (r3, r2, n3p1, 900));\n  mpn_divexact_by9x16(r3, r3, n3p1);\n\n  ASSERT_NOCARRY(mpn_sub_n (r4, r4, r1, n3p1));\n  ASSERT_NOCARRY(mpn_sub_n (r4, r4, r3, n3p1));\n  ASSERT_NOCARRY(mpn_sub_n (r4, r4, r2, n3p1));\n\n  mpn_add_n (r6, r2, r6, n3p1);\n  ASSERT_NOCARRY(mpn_rshift(r6, r6, n3p1, 1));\n  ASSERT_NOCARRY(mpn_sub_n (r2, r2, r6, n3p1));\n\n  mpn_sub_n (r5, r3, r5, n3p1);\n  ASSERT_NOCARRY(mpn_rshift(r5, r5, n3p1, 1));\n  ASSERT_NOCARRY(mpn_sub_n (r3, r3, r5, n3p1));\n\n  mpn_add_n (r7, r1, r7, n3p1);\n  ASSERT_NOCARRY(mpn_rshift(r7, r7, n3p1, 1));\n  ASSERT_NOCARRY(mpn_sub_n (r1, r1, r7, n3p1));\n\n  /* last interpolation steps... */\n  /* ... could be mixed with recomposition\n\t||H-r7|M-r7|L-r7|   ||H-r5|M-r5|L-r5|\n  */\n\n  /***************************** recomposition *******************************/\n  /*\n    pp[] prior to operations:\n    |M r0|L r0|___||H r2|M r2|L r2|___||H r4|M r4|L r4|___||H r6|M r6|L r6|____|H_r8|L r8|pp\n\n    summation scheme for remaining operations:\n    |__16|n_15|n_14|n_13|n_12|n_11|n_10|n__9|n__8|n__7|n__6|n__5|n__4|n__3|n__2|n___|n___|pp\n    |M r0|L r0|___||H r2|M r2|L r2|___||H r4|M r4|L r4|___||H r6|M r6|L r6|____|H_r8|L r8|pp\n\t||H r1|M r1|L r1|   ||H r3|M r3|L r3|   ||H_r5|M_r5|L_r5|   ||H r7|M r7|L r7|\n  */\n\n  cy = mpn_add_n (pp + n, pp + n, r7, n);\n  cy = mpn_add_1 (pp + 2 * n, r7 + n, n, cy);\n#if HAVE_NATIVE_mpn_add_nc\n  cy = r7[n3] + mpn_add_nc(pp + n3, pp + n3, r7 + 2 * n, n, cy);\n#else\n  MPN_INCR_U (r7 + 2 * n, n + 1, cy);\n  cy = r7[n3] + mpn_add_n (pp + n3, pp + n3, r7 + 2 * n, n);\n#endif\n  MPN_INCR_U (pp + 4 * n, 2 * n + 1, cy);\n\n  pp[2 * n3]+= mpn_add_n (pp + 5 * n, pp + 5 * n, r5, n);\n  cy = mpn_add_1 (pp + 2 * n3, r5 + n, n, pp[2 * n3]);\n#if HAVE_NATIVE_mpn_add_nc\n  cy = r5[n3] + mpn_add_nc(pp + 7 * n, pp + 7 * n, r5 + 2 * n, n, cy);\n#else\n  MPN_INCR_U (r5 + 2 * n, n + 1, cy);\n  cy = r5[n3] + mpn_add_n (pp + 7 * n, pp + 7 * n, r5 + 2 * n, n);\n#endif\n  MPN_INCR_U (pp + 8 * n, 2 * n + 1, cy);\n\n  pp[10 * n]+= mpn_add_n (pp + 9 * n, pp + 9 * n, r3, n);\n  cy = mpn_add_1 (pp + 10 * n, r3 + n, n, pp[10 * n]);\n#if HAVE_NATIVE_mpn_add_nc\n  cy = r3[n3] + mpn_add_nc(pp +11 * n, pp +11 * n, r3 + 2 * n, n, cy);\n#else\n  MPN_INCR_U (r3 + 2 * n, n + 1, cy);\n  cy = r3[n3] + mpn_add_n (pp +11 * n, pp +11 * n, r3 + 2 * n, n);\n#endif\n  MPN_INCR_U (pp +12 * n, 2 * n + 1, cy);\n\n  pp[14 * n]+=mpn_add_n (pp +13 * n, pp +13 * n, r1, n);\n  if ( half ) {\n    cy = mpn_add_1 (pp + 14 * n, r1 + n, n, pp[14 * n]);\n#if HAVE_NATIVE_mpn_add_nc\n    if(LIKELY(spt > n)) {\n      cy = r1[n3] + mpn_add_nc(pp + 15 * n, pp + 15 * n, r1 + 2 * n, n, cy);\n      MPN_INCR_U (pp + 16 * n, spt - n, cy);\n    } else {\n      ASSERT_NOCARRY(mpn_add_nc(pp + 15 * n, pp + 15 * n, r1 + 2 * n, spt, cy));\n    }\n#else\n    MPN_INCR_U (r1 + 2 * n, n + 1, cy);\n    if(LIKELY(spt > n)) {\n      cy = r1[n3] + mpn_add_n (pp + 15 * n, pp + 15 * n, r1 + 2 * n, n);\n      MPN_INCR_U (pp + 16 * n, spt - n, cy);\n    } else {\n      ASSERT_NOCARRY(mpn_add_n (pp + 15 * n, pp + 15 * n, r1 + 2 * n, spt));\n    }\n#endif\n  } else {\n    ASSERT_NOCARRY(mpn_add_1 (pp + 14 * n, r1 + n, spt, pp[14 * n]));\n  }\n\n#undef   r0\n#undef   r2\n#undef   r4\n#undef   r6\n}",
      "lines": 245,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_interpolate_5pts.c": {
    "mpn_toom_interpolate_5pts": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "void\nmpn_toom_interpolate_5pts (mp_ptr c, mp_ptr v2, mp_ptr vm1,\n\t\t\t   mp_size_t k, mp_size_t twor, int sa,\n\t\t\t   mp_limb_t vinf0)\n{\n  mp_limb_t cy, saved;\n  mp_size_t twok;\n  mp_size_t kk1;\n  mp_ptr c1, v1, c3, vinf;\n\n  twok = k + k;\n  kk1 = twok + 1;\n\n  c1 = c  + k;\n  v1 = c1 + k;\n  c3 = v1 + k;\n  vinf = c3 + k;\n\n#define v0 (c)\n  /* (1) v2 <- v2-vm1 < v2+|vm1|,       (16 8 4 2 1) - (1 -1 1 -1  1) =\n     thus 0 <= v2 < 50*B^(2k) < 2^6*B^(2k)             (15 9 3  3  0)\n  */\n  if (sa)\n    ASSERT_NOCARRY (mpn_add_n (v2, v2, vm1, kk1));\n  else\n    ASSERT_NOCARRY (mpn_sub_n (v2, v2, vm1, kk1));\n\n  /* {c,2k} {c+2k,2k+1} {c+4k+1,2r-1} {t,2k+1} {t+2k+1,2k+1} {t+4k+2,2r}\n       v0       v1       hi(vinf)       |vm1|     v2-vm1      EMPTY */\n\n  ASSERT_NOCARRY (mpn_divexact_by3 (v2, v2, kk1));    /* v2 <- v2 / 3 */\n\t\t\t\t\t\t      /* (5 3 1 1 0)*/\n\n  /* {c,2k} {c+2k,2k+1} {c+4k+1,2r-1} {t,2k+1} {t+2k+1,2k+1} {t+4k+2,2r}\n       v0       v1      hi(vinf)       |vm1|     (v2-vm1)/3    EMPTY */\n\n  /* (2) vm1 <- tm1 := (v1 - vm1) / 2  [(1 1 1 1 1) - (1 -1 1 -1 1)] / 2 =\n     tm1 >= 0                                         (0  1 0  1 0)\n     No carry comes out from {v1, kk1} +/- {vm1, kk1},\n     and the division by two is exact.\n     If (sa!=0) the sign of vm1 is negative */\n  if (sa)\n    {\n#ifdef HAVE_NATIVE_mpn_rsh1add_n\n      mpn_rsh1add_n (vm1, v1, vm1, kk1);\n#else\n      ASSERT_NOCARRY (mpn_add_n (vm1, v1, vm1, kk1));\n      ASSERT_NOCARRY (mpn_rshift (vm1, vm1, kk1, 1));\n#endif\n    }\n  else\n    {\n#ifdef HAVE_NATIVE_mpn_rsh1sub_n\n      mpn_rsh1sub_n (vm1, v1, vm1, kk1);\n#else\n      ASSERT_NOCARRY (mpn_sub_n (vm1, v1, vm1, kk1));\n      ASSERT_NOCARRY (mpn_rshift (vm1, vm1, kk1, 1));\n#endif\n    }\n\n  /* {c,2k} {c+2k,2k+1} {c+4k+1,2r-1} {t,2k+1} {t+2k+1,2k+1} {t+4k+2,2r}\n       v0       v1        hi(vinf)       tm1     (v2-vm1)/3    EMPTY */\n\n  /* (3) v1 <- t1 := v1 - v0    (1 1 1 1 1) - (0 0 0 0 1) = (1 1 1 1 0)\n     t1 >= 0\n  */\n  vinf[0] -= mpn_sub_n (v1, v1, c, twok);\n\n  /* {c,2k} {c+2k,2k+1} {c+4k+1,2r-1} {t,2k+1} {t+2k+1,2k+1} {t+4k+2,2r}\n       v0     v1-v0        hi(vinf)       tm1     (v2-vm1)/3    EMPTY */\n\n  /* (4) v2 <- t2 := ((v2-vm1)/3-t1)/2 = (v2-vm1-3*t1)/6\n     t2 >= 0                  [(5 3 1 1 0) - (1 1 1 1 0)]/2 = (2 1 0 0 0)\n  */\n#ifdef HAVE_NATIVE_mpn_rsh1sub_n\n  mpn_rsh1sub_n (v2, v2, v1, kk1);\n#else\n  ASSERT_NOCARRY (mpn_sub_n (v2, v2, v1, kk1));\n  ASSERT_NOCARRY (mpn_rshift (v2, v2, kk1, 1));\n#endif\n\n  /* {c,2k} {c+2k,2k+1} {c+4k+1,2r-1} {t,2k+1} {t+2k+1,2k+1} {t+4k+2,2r}\n       v0     v1-v0        hi(vinf)     tm1    (v2-vm1-3t1)/6    EMPTY */\n\n  /* (5) v1 <- t1-tm1           (1 1 1 1 0) - (0 1 0 1 0) = (1 0 1 0 0)\n     result is v1 >= 0\n  */\n  ASSERT_NOCARRY (mpn_sub_n (v1, v1, vm1, kk1));\n\n  /* We do not need to read the value in vm1, so we add it in {c+k, ...} */\n  cy = mpn_add_n (c1, c1, vm1, kk1);\n  MPN_INCR_U (c3 + 1, twor + k - 1, cy); /* 2n-(3k+1) = 2r+k-1 */\n  /* Memory allocated for vm1 is now free, it can be recycled ...*/\n\n  /* (6) v2 <- v2 - 2*vinf,     (2 1 0 0 0) - 2*(1 0 0 0 0) = (0 1 0 0 0)\n     result is v2 >= 0 */\n  saved = vinf[0];       /* Remember v1's highest byte (will be overwritten). */\n  vinf[0] = vinf0;       /* Set the right value for vinf0                     */\n#ifdef HAVE_NATIVE_mpn_sublsh1_n_ip1\n  cy = mpn_sublsh1_n_ip1 (v2, vinf, twor);\n#else\n  /* Overwrite unused vm1 */\n  cy = mpn_lshift (vm1, vinf, twor, 1);\n  cy += mpn_sub_n (v2, v2, vm1, twor);\n#endif\n  MPN_DECR_U (v2 + twor, kk1 - twor, cy);\n\n  /* Current matrix is\n     [1 0 0 0 0; vinf\n      0 1 0 0 0; v2\n      1 0 1 0 0; v1\n      0 1 0 1 0; vm1\n      0 0 0 0 1] v0\n     Some values already are in-place (we added vm1 in the correct position)\n     | vinf|  v1 |  v0 |\n\t      | vm1 |\n     One still is in a separated area\n\t| +v2 |\n     We have to compute v1-=vinf; vm1 -= v2,\n\t   |-vinf|\n\t      | -v2 |\n     Carefully reordering operations we can avoid to compute twice the sum\n     of the high half of v2 plus the low half of vinf.\n  */\n\n  /* Add the high half of t2 in {vinf} */\n  if ( LIKELY(twor > k + 1) ) { /* This is the expected flow  */\n    cy = mpn_add_n (vinf, vinf, v2 + k, k + 1);\n    MPN_INCR_U (c3 + kk1, twor - k - 1, cy); /* 2n-(5k+1) = 2r-k-1 */\n  } else { /* triggered only by very unbalanced cases like\n\t      (k+k+(k-2))x(k+k+1) , should be handled by toom32 */\n    ASSERT_NOCARRY (mpn_add_n (vinf, vinf, v2 + k, twor));\n  }\n  /* (7) v1 <- v1 - vinf,       (1 0 1 0 0) - (1 0 0 0 0) = (0 0 1 0 0)\n     result is >= 0 */\n  /* Side effect: we also subtracted (high half) vm1 -= v2 */\n  cy = mpn_sub_n (v1, v1, vinf, twor);          /* vinf is at most twor long.  */\n  vinf0 = vinf[0];                     /* Save again the right value for vinf0 */\n  vinf[0] = saved;\n  MPN_DECR_U (v1 + twor, kk1 - twor, cy);       /* Treat the last bytes.       */\n\n  /* (8) vm1 <- vm1-v2          (0 1 0 1 0) - (0 1 0 0 0) = (0 0 0 1 0)\n     Operate only on the low half.\n  */\n  cy = mpn_sub_n (c1, c1, v2, k);\n  MPN_DECR_U (v1, kk1, cy);\n\n  /********************* Beginning the final phase **********************/\n\n  /* Most of the recomposition was done */\n\n  /* add t2 in {c+3k, ...}, but only the low half */\n  cy = mpn_add_n (c3, c3, v2, k);\n  vinf[0] += cy;\n  ASSERT(vinf[0] >= cy); /* No carry */\n  MPN_INCR_U (vinf, twor, vinf0); /* Add vinf0, propagate carry. */\n\n#undef v0\n}",
      "lines": 159,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_interpolate_6pts.c": {
    "mpn_toom_interpolate_6pts": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "void\nmpn_toom_interpolate_6pts (mp_ptr pp, mp_size_t n, enum toom6_flags flags,\n\t\t\t   mp_ptr w4, mp_ptr w2, mp_ptr w1,\n\t\t\t   mp_size_t w0n)\n{\n  mp_limb_t cy;\n  /* cy6 can be stored in w1[2*n], cy4 in w4[0], embankment in w2[0] */\n  mp_limb_t cy4, cy6, embankment;\n\n  ASSERT( n > 0 );\n  ASSERT( 2*n >= w0n && w0n > 0 );\n\n#define w5  pp\t\t\t\t\t/* 2n   */\n#define w3  (pp + 2 * n)\t\t\t/* 2n+1 */\n#define w0  (pp + 5 * n)\t\t\t/* w0n  */\n\n  /* Interpolate with sequence:\n     W2 =(W1 - W2)>>2\n     W1 =(W1 - W5)>>1\n     W1 =(W1 - W2)>>1\n     W4 =(W3 - W4)>>1\n     W2 =(W2 - W4)/3\n     W3 = W3 - W4 - W5\n     W1 =(W1 - W3)/3\n     // Last steps are mixed with recomposition...\n     W2 = W2 - W0<<2\n     W4 = W4 - W2\n     W3 = W3 - W1\n     W2 = W2 - W0\n  */\n\n  /* W2 =(W1 - W2)>>2 */\n  if (flags & toom6_vm2_neg)\n    mpn_add_n (w2, w1, w2, 2 * n + 1);\n  else\n    mpn_sub_n (w2, w1, w2, 2 * n + 1);\n  mpn_rshift (w2, w2, 2 * n + 1, 2);\n\n  /* W1 =(W1 - W5)>>1 */\n  w1[2*n] -= mpn_sub_n (w1, w1, w5, 2*n);\n  mpn_rshift (w1, w1, 2 * n + 1, 1);\n\n  /* W1 =(W1 - W2)>>1 */\n#if HAVE_NATIVE_mpn_rsh1sub_n\n  mpn_rsh1sub_n (w1, w1, w2, 2 * n + 1);\n#else\n  mpn_sub_n (w1, w1, w2, 2 * n + 1);\n  mpn_rshift (w1, w1, 2 * n + 1, 1);\n#endif\n\n  /* W4 =(W3 - W4)>>1 */\n  if (flags & toom6_vm1_neg)\n    {\n#if HAVE_NATIVE_mpn_rsh1add_n\n      mpn_rsh1add_n (w4, w3, w4, 2 * n + 1);\n#else\n      mpn_add_n (w4, w3, w4, 2 * n + 1);\n      mpn_rshift (w4, w4, 2 * n + 1, 1);\n#endif\n    }\n  else\n    {\n#if HAVE_NATIVE_mpn_rsh1sub_n\n      mpn_rsh1sub_n (w4, w3, w4, 2 * n + 1);\n#else\n      mpn_sub_n (w4, w3, w4, 2 * n + 1);\n      mpn_rshift (w4, w4, 2 * n + 1, 1);\n#endif\n    }\n\n  /* W2 =(W2 - W4)/3 */\n  mpn_sub_n (w2, w2, w4, 2 * n + 1);\n  mpn_divexact_by3 (w2, w2, 2 * n + 1);\n\n  /* W3 = W3 - W4 - W5 */\n  mpn_sub_n (w3, w3, w4, 2 * n + 1);\n  w3[2 * n] -= mpn_sub_n (w3, w3, w5, 2 * n);\n\n  /* W1 =(W1 - W3)/3 */\n  mpn_sub_n (w1, w1, w3, 2 * n + 1);\n  mpn_divexact_by3 (w1, w1, 2 * n + 1);\n\n  /*\n    [1 0 0 0 0 0;\n     0 1 0 0 0 0;\n     1 0 1 0 0 0;\n     0 1 0 1 0 0;\n     1 0 1 0 1 0;\n     0 0 0 0 0 1]\n\n    pp[] prior to operations:\n     |_H w0__|_L w0__|______||_H w3__|_L w3__|_H w5__|_L w5__|\n\n    summation scheme for remaining operations:\n     |______________5|n_____4|n_____3|n_____2|n______|n______|pp\n     |_H w0__|_L w0__|______||_H w3__|_L w3__|_H w5__|_L w5__|\n\t\t\t\t    || H w4  | L w4  |\n\t\t    || H w2  | L w2  |\n\t    || H w1  | L w1  |\n\t\t\t    ||-H w1  |-L w1  |\n\t\t     |-H w0  |-L w0 ||-H w2  |-L w2  |\n  */\n  cy = mpn_add_n (pp + n, pp + n, w4, 2 * n + 1);\n  MPN_INCR_U (pp + 3 * n + 1, n, cy);\n\n  /* W2 -= W0<<2 */\n#if HAVE_NATIVE_mpn_sublsh_n || HAVE_NATIVE_mpn_sublsh2_n_ip1\n#if HAVE_NATIVE_mpn_sublsh2_n_ip1\n  cy = mpn_sublsh2_n_ip1 (w2, w0, w0n);\n#else\n  cy = mpn_sublsh_n (w2, w2, w0, w0n, 2);\n#endif\n#else\n  /* {W4,2*n+1} is now free and can be overwritten. */\n  cy = mpn_lshift(w4, w0, w0n, 2);\n  cy+= mpn_sub_n(w2, w2, w4, w0n);\n#endif\n  MPN_DECR_U (w2 + w0n, 2 * n + 1 - w0n, cy);\n\n  /* W4L = W4L - W2L */\n  cy = mpn_sub_n (pp + n, pp + n, w2, n);\n  MPN_DECR_U (w3, 2 * n + 1, cy);\n\n  /* W3H = W3H + W2L */\n  cy4 = w3[2 * n] + mpn_add_n (pp + 3 * n, pp + 3 * n, w2, n);\n  /* W1L + W2H */\n  cy = w2[2 * n] + mpn_add_n (pp + 4 * n, w1, w2 + n, n);\n  MPN_INCR_U (w1 + n, n + 1, cy);\n\n  /* W0 = W0 + W1H */\n  if (LIKELY (w0n > n))\n    cy6 = w1[2 * n] + mpn_add_n (w0, w0, w1 + n, n);\n  else\n    cy6 = mpn_add_n (w0, w0, w1 + n, w0n);\n\n  /*\n    summation scheme for the next operation:\n     |...____5|n_____4|n_____3|n_____2|n______|n______|pp\n     |...w0___|_w1_w2_|_H w3__|_L w3__|_H w5__|_L w5__|\n\t\t     ...-w0___|-w1_w2 |\n  */\n  /* if(LIKELY(w0n>n)) the two operands below DO overlap! */\n  cy = mpn_sub_n (pp + 2 * n, pp + 2 * n, pp + 4 * n, n + w0n);\n\n  /* embankment is a \"dirty trick\" to avoid carry/borrow propagation\n     beyond allocated memory */\n  embankment = w0[w0n - 1] - 1;\n  w0[w0n - 1] = 1;\n  if (LIKELY (w0n > n)) {\n    if (cy4 > cy6)\n      MPN_INCR_U (pp + 4 * n, w0n + n, cy4 - cy6);\n    else\n      MPN_DECR_U (pp + 4 * n, w0n + n, cy6 - cy4);\n    MPN_DECR_U (pp + 3 * n + w0n, 2 * n, cy);\n    MPN_INCR_U (w0 + n, w0n - n, cy6);\n  } else {\n    MPN_INCR_U (pp + 4 * n, w0n + n, cy4);\n    MPN_DECR_U (pp + 3 * n + w0n, 2 * n, cy + cy6);\n  }\n  w0[w0n - 1] += embankment;\n\n#undef w5\n#undef w3\n#undef w0\n\n}",
      "lines": 166,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_interpolate_7pts.c": {
    "mpn_toom_interpolate_7pts": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "void\nmpn_toom_interpolate_7pts (mp_ptr rp, mp_size_t n, enum toom7_flags flags,\n\t\t\t   mp_ptr w1, mp_ptr w3, mp_ptr w4, mp_ptr w5,\n\t\t\t   mp_size_t w6n, mp_ptr tp)\n{\n  mp_size_t m;\n  mp_limb_t cy;\n\n  m = 2*n + 1;\n#define w0 rp\n#define w2 (rp + 2*n)\n#define w6 (rp + 6*n)\n\n  ASSERT (w6n > 0);\n  ASSERT (w6n <= 2*n);\n\n  /* Using formulas similar to Marco Bodrato's\n\n     W5 = W5 + W4\n     W1 =(W4 - W1)/2\n     W4 = W4 - W0\n     W4 =(W4 - W1)/4 - W6*16\n     W3 =(W2 - W3)/2\n     W2 = W2 - W3\n\n     W5 = W5 - W2*65      May be negative.\n     W2 = W2 - W6 - W0\n     W5 =(W5 + W2*45)/2   Now >= 0 again.\n     W4 =(W4 - W2)/3\n     W2 = W2 - W4\n\n     W1 = W5 - W1         May be negative.\n     W5 =(W5 - W3*8)/9\n     W3 = W3 - W5\n     W1 =(W1/15 + W5)/2   Now >= 0 again.\n     W5 = W5 - W1\n\n     where W0 = f(0), W1 = f(-2), W2 = f(1), W3 = f(-1),\n\t   W4 = f(2), W5 = f(1/2), W6 = f(oo),\n\n     Note that most intermediate results are positive; the ones that\n     may be negative are represented in two's complement. We must\n     never shift right a value that may be negative, since that would\n     invalidate the sign bit. On the other hand, divexact by odd\n     numbers work fine with two's complement.\n  */\n\n  mpn_add_n (w5, w5, w4, m);\n  if (flags & toom7_w1_neg)\n    {\n#ifdef HAVE_NATIVE_mpn_rsh1add_n\n      mpn_rsh1add_n (w1, w1, w4, m);\n#else\n      mpn_add_n (w1, w1, w4, m);  ASSERT (!(w1[0] & 1));\n      mpn_rshift (w1, w1, m, 1);\n#endif\n    }\n  else\n    {\n#ifdef HAVE_NATIVE_mpn_rsh1sub_n\n      mpn_rsh1sub_n (w1, w4, w1, m);\n#else\n      mpn_sub_n (w1, w4, w1, m);  ASSERT (!(w1[0] & 1));\n      mpn_rshift (w1, w1, m, 1);\n#endif\n    }\n  mpn_sub (w4, w4, m, w0, 2*n);\n  mpn_sub_n (w4, w4, w1, m);  ASSERT (!(w4[0] & 3));\n  mpn_rshift (w4, w4, m, 2); /* w4>=0 */\n\n  tp[w6n] = mpn_lshift (tp, w6, w6n, 4);\n  mpn_sub (w4, w4, m, tp, w6n+1);\n\n  if (flags & toom7_w3_neg)\n    {\n#ifdef HAVE_NATIVE_mpn_rsh1add_n\n      mpn_rsh1add_n (w3, w3, w2, m);\n#else\n      mpn_add_n (w3, w3, w2, m);  ASSERT (!(w3[0] & 1));\n      mpn_rshift (w3, w3, m, 1);\n#endif\n    }\n  else\n    {\n#ifdef HAVE_NATIVE_mpn_rsh1sub_n\n      mpn_rsh1sub_n (w3, w2, w3, m);\n#else\n      mpn_sub_n (w3, w2, w3, m);  ASSERT (!(w3[0] & 1));\n      mpn_rshift (w3, w3, m, 1);\n#endif\n    }\n\n  mpn_sub_n (w2, w2, w3, m);\n\n  mpn_submul_1 (w5, w2, m, 65);\n  mpn_sub (w2, w2, m, w6, w6n);\n  mpn_sub (w2, w2, m, w0, 2*n);\n\n  mpn_addmul_1 (w5, w2, m, 45);  ASSERT (!(w5[0] & 1));\n  mpn_rshift (w5, w5, m, 1);\n  mpn_sub_n (w4, w4, w2, m);\n\n  mpn_divexact_by3 (w4, w4, m);\n  mpn_sub_n (w2, w2, w4, m);\n\n  mpn_sub_n (w1, w5, w1, m);\n  mpn_lshift (tp, w3, m, 3);\n  mpn_sub_n (w5, w5, tp, m);\n  mpn_divexact_by9 (w5, w5, m);\n  mpn_sub_n (w3, w3, w5, m);\n\n  mpn_divexact_by15 (w1, w1, m);\n  mpn_add_n (w1, w1, w5, m);  ASSERT (!(w1[0] & 1));\n  mpn_rshift (w1, w1, m, 1); /* w1>=0 now */\n  mpn_sub_n (w5, w5, w1, m);\n\n  /* These bounds are valid for the 4x4 polynomial product of toom44,\n   * and they are conservative for toom53 and toom62. */\n  ASSERT (w1[2*n] < 2);\n  ASSERT (w2[2*n] < 3);\n  ASSERT (w3[2*n] < 4);\n  ASSERT (w4[2*n] < 3);\n  ASSERT (w5[2*n] < 2);\n\n  /* Addition chain. Note carries and the 2n'th limbs that need to be\n   * added in.\n   *\n   * Special care is needed for w2[2n] and the corresponding carry,\n   * since the \"simple\" way of adding it all together would overwrite\n   * the limb at wp[2*n] and rp[4*n] (same location) with the sum of\n   * the high half of w3 and the low half of w4.\n   *\n   *         7    6    5    4    3    2    1    0\n   *    |    |    |    |    |    |    |    |    |\n   *                  ||w3 (2n+1)|\n   *             ||w4 (2n+1)|\n   *        ||w5 (2n+1)|        ||w1 (2n+1)|\n   *  + | w6 (w6n)|        ||w2 (2n+1)| w0 (2n) |  (share storage with r)\n   *  -----------------------------------------------\n   *  r |    |    |    |    |    |    |    |    |\n   *        c7   c6   c5   c4   c3                 Carries to propagate\n   */\n\n  cy = mpn_add_n (rp + n, rp + n, w1, m);\n  MPN_INCR_U (w2 + n + 1, n , cy);\n  cy = mpn_add_n (rp + 3*n, rp + 3*n, w3, n);\n  MPN_INCR_U (w3 + n, n + 1, w2[2*n] + cy);\n  cy = mpn_add_n (rp + 4*n, w3 + n, w4, n);\n  MPN_INCR_U (w4 + n, n + 1, w3[2*n] + cy);\n  cy = mpn_add_n (rp + 5*n, w4 + n, w5, n);\n  MPN_INCR_U (w5 + n, n + 1, w4[2*n] + cy);\n  if (w6n > n + 1)\n    {\n      cy = mpn_add_n (rp + 6*n, rp + 6*n, w5 + n, n + 1);\n      MPN_INCR_U (rp + 7*n + 1, w6n - n - 1, cy);\n    }\n  else\n    {\n      ASSERT_NOCARRY (mpn_add_n (rp + 6*n, rp + 6*n, w5 + n, w6n));\n#if WANT_ASSERT\n      {\n\tmp_size_t i;\n\tfor (i = w6n; i <= n; i++)\n\t  ASSERT (w5[n + i] == 0);\n      }\n#endif\n    }\n}",
      "lines": 168,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/toom_interpolate_8pts.c": {
    "DO_mpn_sublsh_n": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static mp_limb_t\nDO_mpn_sublsh_n (mp_ptr dst, mp_srcptr src, mp_size_t n, unsigned int s, mp_ptr ws)\n{\n#if USE_MUL_1 && 0\n  return mpn_submul_1(dst,src,n,CNST_LIMB(1) <<(s));\n#else\n  mp_limb_t __cy;\n  __cy = mpn_lshift (ws,src,n,s);\n  return __cy + mpn_sub_n (dst,dst,ws,n);\n#endif\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_toom_interpolate_8pts": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "void\nmpn_toom_interpolate_8pts (mp_ptr pp, mp_size_t n,\n\t\t\t   mp_ptr r3, mp_ptr r7,\n\t\t\t   mp_size_t spt, mp_ptr ws)\n{\n  mp_limb_signed_t cy;\n  mp_ptr r5, r1;\n  r5 = (pp + 3 * n);\t\t\t/* 3n+1 */\n  r1 = (pp + 7 * n);\t\t\t/* spt */\n\n  /******************************* interpolation *****************************/\n\n  DO_mpn_subrsh(r3+n, 2 * n + 1, pp, 2 * n, 4, ws);\n  cy = DO_mpn_sublsh_n (r3, r1, spt, 12, ws);\n  MPN_DECR_U (r3 + spt, 3 * n + 1 - spt, cy);\n\n  DO_mpn_subrsh(r5+n, 2 * n + 1, pp, 2 * n, 2, ws);\n  cy = DO_mpn_sublsh_n (r5, r1, spt, 6, ws);\n  MPN_DECR_U (r5 + spt, 3 * n + 1 - spt, cy);\n\n  r7[3*n] -= mpn_sub_n (r7+n, r7+n, pp, 2 * n);\n  cy = mpn_sub_n (r7, r7, r1, spt);\n  MPN_DECR_U (r7 + spt, 3 * n + 1 - spt, cy);\n\n  ASSERT_NOCARRY(mpn_sub_n (r3, r3, r5, 3 * n + 1));\n  ASSERT_NOCARRY(mpn_rshift(r3, r3, 3 * n + 1, 2));\n\n  ASSERT_NOCARRY(mpn_sub_n (r5, r5, r7, 3 * n + 1));\n\n  ASSERT_NOCARRY(mpn_sub_n (r3, r3, r5, 3 * n + 1));\n\n  mpn_divexact_by45 (r3, r3, 3 * n + 1);\n\n  ASSERT_NOCARRY(mpn_divexact_by3 (r5, r5, 3 * n + 1));\n\n  ASSERT_NOCARRY(DO_mpn_sublsh2_n (r5, r3, 3 * n + 1, ws));\n\n  /* last interpolation steps... */\n  /* ... are mixed with recomposition */\n\n  /***************************** recomposition *******************************/\n  /*\n    pp[] prior to operations:\n     |_H r1|_L r1|____||_H r5|_M_r5|_L r5|_____|_H r8|_L r8|pp\n\n    summation scheme for remaining operations:\n     |____8|n___7|n___6|n___5|n___4|n___3|n___2|n____|n____|pp\n     |_H r1|_L r1|____||_H*r5|_M r5|_L r5|_____|_H_r8|_L r8|pp\n\t  ||_H r3|_M r3|_L*r3|\n\t\t\t\t  ||_H_r7|_M_r7|_L_r7|\n\t\t      ||-H r3|-M r3|-L*r3|\n\t\t\t\t  ||-H*r5|-M_r5|-L_r5|\n  */\n\n  cy = mpn_add_n (pp + n, pp + n, r7, n); /* Hr8+Lr7-Lr5 */\n  cy-= mpn_sub_n (pp + n, pp + n, r5, n);\n  if (0 > cy)\n    MPN_DECR_U (r7 + n, 2*n + 1, 1);\n  else\n    MPN_INCR_U (r7 + n, 2*n + 1, cy);\n\n  cy = mpn_sub_n (pp + 2*n, r7 + n, r5 + n, n); /* Mr7-Mr5 */\n  MPN_DECR_U (r7 + 2*n, n + 1, cy);\n\n  cy = mpn_add_n (pp + 3*n, r5, r7+ 2*n, n+1); /* Hr7+Lr5 */\n  r5[3*n]+= mpn_add_n (r5 + 2*n, r5 + 2*n, r3, n); /* Hr5+Lr3 */\n  cy-= mpn_sub_n (pp + 3*n, pp + 3*n, r5 + 2*n, n+1); /* Hr7-Hr5+Lr5-Lr3 */\n  if (UNLIKELY(0 > cy))\n    MPN_DECR_U (r5 + n + 1, 2*n, 1);\n  else\n    MPN_INCR_U (r5 + n + 1, 2*n, cy);\n\n  ASSERT_NOCARRY(mpn_sub_n(pp + 4*n, r5 + n, r3 + n, 2*n +1)); /* Mr5-Mr3,Hr5-Hr3 */\n\n  cy = mpn_add_1 (pp + 6*n, r3 + n, n, pp[6*n]);\n  MPN_INCR_U (r3 + 2*n, n + 1, cy);\n  cy = mpn_add_n (pp + 7*n, pp + 7*n, r3 + 2*n, n);\n  if (LIKELY(spt != n))\n    MPN_INCR_U (pp + 8*n, spt - n, cy + r3[3*n]);\n  else\n    ASSERT (r3[3*n] + cy == 0);\n}",
      "lines": 82,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/trialdiv.c": {
    "mpn_trialdiv": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "mp_limb_t\nmpn_trialdiv (mp_srcptr tp, mp_size_t tn, mp_size_t nprimes, int *where)\n{\n  mp_limb_t ppp;\n  const mp_limb_t *cps;\n  const struct gmp_primes_dtab *dp;\n  long i, j, idx, np;\n  mp_limb_t r, q;\n\n  ASSERT (tn >= 1);\n\n  for (i = *where; i < PTAB_LINES; i++)\n    {\n      ppp = gmp_primes_ptab[i].ppp;\n      cps = gmp_primes_ptab[i].cps;\n\n      r = mpn_mod_1s_4p (tp, tn, ppp << cps[1], cps);\n\n      idx = gmp_primes_ptab[i].idx;\n      np = gmp_primes_ptab[i].np;\n\n      /* Check divisibility by individual primes.  */\n      dp = &gmp_primes_dtab[idx] + np;\n      for (j = -np; j < 0; j++)\n\t{\n\t  q = r * dp[j].binv;\n\t  if (q <= dp[j].lim)\n\t    {\n\t      *where = i;\n\t      return dp[j].binv;\n\t    }\n\t}\n\n      nprimes -= np;\n      if (nprimes <= 0)\n\treturn 0;\n    }\n  return 0;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/udiv_w_sdiv.c": {
    "mpn_udiv_w_sdiv": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "mp_limb_t\nmpn_udiv_w_sdiv (mp_limb_t *rp, mp_limb_t a1, mp_limb_t a0, mp_limb_t d)\n{\n  mp_limb_t q, r;\n  mp_limb_t c0, c1, b1;\n\n  ASSERT (d != 0);\n  ASSERT (a1 < d);\n\n  if ((mp_limb_signed_t) d >= 0)\n    {\n      if (a1 < d - a1 - (a0 >> (GMP_LIMB_BITS - 1)))\n\t{\n\t  /* dividend, divisor, and quotient are nonnegative */\n\t  sdiv_qrnnd (q, r, a1, a0, d);\n\t}\n      else\n\t{\n\t  /* Compute c1*2^32 + c0 = a1*2^32 + a0 - 2^31*d */\n\t  sub_ddmmss (c1, c0, a1, a0, d >> 1, d << (GMP_LIMB_BITS - 1));\n\t  /* Divide (c1*2^32 + c0) by d */\n\t  sdiv_qrnnd (q, r, c1, c0, d);\n\t  /* Add 2^31 to quotient */\n\t  q += (mp_limb_t) 1 << (GMP_LIMB_BITS - 1);\n\t}\n    }\n  else\n    {\n      b1 = d >> 1;\t\t\t/* d/2, between 2^30 and 2^31 - 1 */\n      c1 = a1 >> 1;\t\t\t/* A/2 */\n      c0 = (a1 << (GMP_LIMB_BITS - 1)) + (a0 >> 1);\n\n      if (a1 < b1)\t\t\t/* A < 2^32*b1, so A/2 < 2^31*b1 */\n\t{\n\t  sdiv_qrnnd (q, r, c1, c0, b1); /* (A/2) / (d/2) */\n\n\t  r = 2*r + (a0 & 1);\t\t/* Remainder from A/(2*b1) */\n\t  if ((d & 1) != 0)\n\t    {\n\t      if (r >= q)\n\t\tr = r - q;\n\t      else if (q - r <= d)\n\t\t{\n\t\t  r = r - q + d;\n\t\t  q--;\n\t\t}\n\t      else\n\t\t{\n\t\t  r = r - q + 2*d;\n\t\t  q -= 2;\n\t\t}\n\t    }\n\t}\n      else if (c1 < b1)\t\t\t/* So 2^31 <= (A/2)/b1 < 2^32 */\n\t{\n\t  c1 = (b1 - 1) - c1;\n\t  c0 = ~c0;\t\t\t/* logical NOT */\n\n\t  sdiv_qrnnd (q, r, c1, c0, b1); /* (A/2) / (d/2) */\n\n\t  q = ~q;\t\t\t/* (A/2)/b1 */\n\t  r = (b1 - 1) - r;\n\n\t  r = 2*r + (a0 & 1);\t\t/* A/(2*b1) */\n\n\t  if ((d & 1) != 0)\n\t    {\n\t      if (r >= q)\n\t\tr = r - q;\n\t      else if (q - r <= d)\n\t\t{\n\t\t  r = r - q + d;\n\t\t  q--;\n\t\t}\n\t      else\n\t\t{\n\t\t  r = r - q + 2*d;\n\t\t  q -= 2;\n\t\t}\n\t    }\n\t}\n      else\t\t\t\t/* Implies c1 = b1 */\n\t{\t\t\t\t/* Hence a1 = d - 1 = 2*b1 - 1 */\n\t  if (a0 >= -d)\n\t    {\n\t      q = -CNST_LIMB(1);\n\t      r = a0 + d;\n\t    }\n\t  else\n\t    {\n\t      q = -CNST_LIMB(2);\n\t      r = a0 + 2*d;\n\t    }\n\t}\n    }\n\n  *rp = r;\n  return q;\n}",
      "lines": 99,
      "depth": 17,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/zero.c": {
    "mpn_zero": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void\nmpn_zero (mp_ptr rp, mp_size_t n)\n{\n  mp_size_t i;\n\n  rp += n;\n  for (i = -n; i != 0; i++)\n    rp[i] = 0;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/generic/zero_p.c": {},
  "gmp/gmp-6.1.2/mpn/ia64/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/m68k/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/minithres/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/mips32/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/mips64/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/pa32/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/pa32/hppa1_1/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/pa32/hppa2_0/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/pa64/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/power/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc32/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc32/750/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc32/p3/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc32/p4/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc32/p5/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc32/p6/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc32/p7/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc64/mode32/p4/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc64/mode64/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc64/mode64/p3/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc64/mode64/p4/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc64/mode64/p5/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc64/mode64/p6/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/powerpc64/mode64/p7/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/s390_32/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/s390_32/esame/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/s390_64/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/s390_64/z10/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/sparc32/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/sparc32/ultrasparct1/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/sparc32/v8/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/sparc32/v8/supersparc/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/sparc32/v9/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/sparc64/dive_1.c": {
    "mpn_divexact_1": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void\nmpn_divexact_1 (mp_ptr dst, mp_srcptr src, mp_size_t size, mp_limb_t divisor)\n{\n  mp_limb_t  inverse, s, s_next, c, l, ls, q;\n  unsigned   rshift, lshift;\n  mp_limb_t  lshift_mask;\n  mp_limb_t  divisor_h;\n\n  ASSERT (size >= 1);\n  ASSERT (divisor != 0);\n  ASSERT (MPN_SAME_OR_SEPARATE_P (dst, src, size));\n  ASSERT_MPN (src, size);\n  ASSERT_LIMB (divisor);\n\n  s = *src++;                 /* src low limb */\n  size--;\n  if (size == 0)\n    {\n      *dst = s / divisor;\n      return;\n    }\n\n  if ((divisor & 1) == 0)\n    {\n      count_trailing_zeros (rshift, divisor);\n      divisor >>= rshift;\n    }\n  else\n    rshift = 0;\n\n  binvert_limb (inverse, divisor);\n\n  lshift = 64 - rshift;\n\n  /* lshift==64 means no shift, so must mask out other part in this case */\n  lshift_mask = (rshift == 0 ? 0 : MP_LIMB_T_MAX);\n\n  c = 0;\n  divisor_h = HIGH32 (divisor);\n\n  if (divisor_h == 0)\n    {\n      /* 32-bit divisor */\n      do\n        {\n          s_next = *src++;\n          ls = (s >> rshift) | ((s_next << lshift) & lshift_mask);\n          s = s_next;\n\n          SUBC_LIMB (c, l, ls, c);\n\n          q = l * inverse;\n          *dst++ = q;\n\n          umul_ppmm_half_lowequal (l, q, divisor, l);\n          c += l;\n\n          size--;\n        }\n      while (size != 0);\n\n      ls = s >> rshift;\n      l = ls - c;\n      q = l * inverse;\n      *dst = q;\n    }\n  else\n    {\n      /* 64-bit divisor */\n      mp_limb_t  divisor_l = LOW32 (divisor);\n      do\n        {\n          s_next = *src++;\n          ls = (s >> rshift) | ((s_next << lshift) & lshift_mask);\n          s = s_next;\n\n          SUBC_LIMB (c, l, ls, c);\n\n          q = l * inverse;\n          *dst++ = q;\n\n          umul_ppmm_lowequal (l, q, divisor, divisor_h, divisor_l, l);\n          c += l;\n\n          size--;\n        }\n      while (size != 0);\n\n      ls = s >> rshift;\n      l = ls - c;\n      q = l * inverse;\n      *dst = q;\n    }\n}",
      "lines": 94,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/sparc64/divrem_1.c": {
    "mpn_divrem_1": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "mp_limb_t\nmpn_divrem_1 (mp_ptr qp_limbptr, mp_size_t xsize_limbs,\n              mp_srcptr ap_limbptr, mp_size_t size_limbs, mp_limb_t d_limb)\n{\n  mp_size_t  total_size_limbs;\n  mp_size_t  i;\n\n  ASSERT (xsize_limbs >= 0);\n  ASSERT (size_limbs >= 0);\n  ASSERT (d_limb != 0);\n  /* FIXME: What's the correct overlap rule when xsize!=0? */\n  ASSERT (MPN_SAME_OR_SEPARATE_P (qp_limbptr + xsize_limbs,\n                                  ap_limbptr, size_limbs));\n\n  total_size_limbs = size_limbs + xsize_limbs;\n  if (UNLIKELY (total_size_limbs == 0))\n    return 0;\n\n  /* udivx is good for total_size==1, and no need to bother checking\n     limb<divisor, since if that's likely the caller should check */\n  if (UNLIKELY (total_size_limbs == 1))\n    {\n      mp_limb_t  a, q;\n      a = (LIKELY (size_limbs != 0) ? ap_limbptr[0] : 0);\n      q = a / d_limb;\n      qp_limbptr[0] = q;\n      return a - q*d_limb;\n    }\n\n  if (d_limb <= CNST_LIMB(0xFFFFFFFF))\n    {\n      mp_size_t  size, xsize, total_size, adj;\n      unsigned   *qp, n1, n0, q, r, nshift, norm_rmask;\n      mp_limb_t  dinv_limb;\n      const unsigned *ap;\n      int        norm, norm_rshift;\n\n      size = 2 * size_limbs;\n      xsize = 2 * xsize_limbs;\n      total_size = size + xsize;\n\n      ap = (unsigned *) ap_limbptr;\n      qp = (unsigned *) qp_limbptr;\n\n      qp += xsize;\n      r = 0;        /* initial remainder */\n\n      if (LIKELY (size != 0))\n        {\n          n1 = ap[size-1 + HALF_ENDIAN_ADJ(1)];\n\n          /* If the length of the source is uniformly distributed, then\n             there's a 50% chance of the high 32-bits being zero, which we\n             can skip.  */\n          if (n1 == 0)\n            {\n              n1 = ap[size-2 + HALF_ENDIAN_ADJ(0)];\n              total_size--;\n              size--;\n              ASSERT (size > 0);  /* because always even */\n              qp[size + HALF_ENDIAN_ADJ(1)] = 0;\n            }\n\n          /* Skip a division if high < divisor (high quotient 0).  Testing\n             here before before normalizing will still skip as often as\n             possible.  */\n          if (n1 < d_limb)\n            {\n              r = n1;\n              size--;\n              qp[size + HALF_ENDIAN_ADJ(size)] = 0;\n              total_size--;\n              if (total_size == 0)\n                return r;\n            }\n        }\n\n      count_leading_zeros_32 (norm, d_limb);\n      norm -= 32;\n      d_limb <<= norm;\n      r <<= norm;\n\n      norm_rshift = 32 - norm;\n      norm_rmask = (norm == 0 ? 0 : 0xFFFFFFFF);\n\n      invert_half_limb (dinv_limb, d_limb);\n\n      if (LIKELY (size != 0))\n        {\n          i = size - 1;\n          adj = HALF_ENDIAN_ADJ (i);\n          n1 = ap[i + adj];\n          adj = -adj;\n          r |= ((n1 >> norm_rshift) & norm_rmask);\n          for ( ; i > 0; i--)\n            {\n              n0 = ap[i-1 + adj];\n              adj = -adj;\n              nshift = (n1 << norm) | ((n0 >> norm_rshift) & norm_rmask);\n              udiv_qrnnd_half_preinv (q, r, r, nshift, d_limb, dinv_limb);\n              qp[i + adj] = q;\n              n1 = n0;\n            }\n          nshift = n1 << norm;\n          udiv_qrnnd_half_preinv (q, r, r, nshift, d_limb, dinv_limb);\n          qp[0 + HALF_ENDIAN_ADJ(0)] = q;\n        }\n      qp -= xsize;\n      adj = HALF_ENDIAN_ADJ (0);\n      for (i = xsize-1; i >= 0; i--)\n        {\n          udiv_qrnnd_half_preinv (q, r, r, 0, d_limb, dinv_limb);\n          adj = -adj;\n          qp[i + adj] = q;\n        }\n\n      return r >> norm;\n    }\n  else\n    {\n      mp_srcptr  ap;\n      mp_ptr     qp;\n      mp_size_t  size, xsize, total_size;\n      mp_limb_t  d, n1, n0, q, r, dinv, nshift, norm_rmask;\n      int        norm, norm_rshift;\n\n      ap = ap_limbptr;\n      qp = qp_limbptr;\n      size = size_limbs;\n      xsize = xsize_limbs;\n      total_size = total_size_limbs;\n      d = d_limb;\n\n      qp += total_size;   /* above high limb */\n      r = 0;              /* initial remainder */\n\n      if (LIKELY (size != 0))\n        {\n          /* Skip a division if high < divisor (high quotient 0).  Testing\n             here before before normalizing will still skip as often as\n             possible.  */\n          n1 = ap[size-1];\n          if (n1 < d)\n            {\n              r = n1;\n              *--qp = 0;\n              total_size--;\n              if (total_size == 0)\n                return r;\n              size--;\n            }\n        }\n\n      count_leading_zeros (norm, d);\n      d <<= norm;\n      r <<= norm;\n\n      norm_rshift = GMP_LIMB_BITS - norm;\n      norm_rmask = (norm == 0 ? 0 : ~CNST_LIMB(0));\n\n      invert_limb (dinv, d);\n\n      if (LIKELY (size != 0))\n        {\n          n1 = ap[size-1];\n          r |= ((n1 >> norm_rshift) & norm_rmask);\n          for (i = size-2; i >= 0; i--)\n            {\n              n0 = ap[i];\n              nshift = (n1 << norm) | ((n0 >> norm_rshift) & norm_rmask);\n              udiv_qrnnd_preinv (q, r, r, nshift, d, dinv);\n              *--qp = q;\n              n1 = n0;\n            }\n          nshift = n1 << norm;\n          udiv_qrnnd_preinv (q, r, r, nshift, d, dinv);\n          *--qp = q;\n        }\n      for (i = 0; i < xsize; i++)\n        {\n          udiv_qrnnd_preinv (q, r, r, CNST_LIMB(0), d, dinv);\n          *--qp = q;\n        }\n      return r >> norm;\n    }\n}",
      "lines": 186,
      "depth": 16,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/sparc64/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/sparc64/mode1o.c": {
    "mpn_modexact_1c_odd": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "mp_limb_t\nmpn_modexact_1c_odd (mp_srcptr src, mp_size_t size, mp_limb_t d, mp_limb_t orig_c)\n{\n  mp_limb_t  c = orig_c;\n  mp_limb_t  s, l, q, h, inverse;\n\n  ASSERT (size >= 1);\n  ASSERT (d & 1);\n  ASSERT_MPN (src, size);\n  ASSERT_LIMB (d);\n  ASSERT_LIMB (c);\n\n  /* udivx is faster than 10 or 12 mulx's for one limb via an inverse */\n  if (size == 1)\n    {\n      s = src[0];\n      if (s > c)\n\t{\n\t  l = s-c;\n\t  h = l % d;\n\t  if (h != 0)\n\t    h = d - h;\n\t}\n      else\n\t{\n\t  l = c-s;\n\t  h = l % d;\n\t}\n      return h;\n    }\n\n  binvert_limb (inverse, d);\n\n  if (d <= 0xFFFFFFFF)\n    {\n      s = *src++;\n      size--;\n      do\n        {\n          SUBC_LIMB (c, l, s, c);\n          s = *src++;\n          q = l * inverse;\n          umul_ppmm_half_lowequal (h, q, d, l);\n          c += h;\n          size--;\n        }\n      while (size != 0);\n\n      if (s <= d)\n        {\n          /* With high s <= d the final step can be a subtract and addback.\n             If c==0 then the addback will restore to l>=0.  If c==d then\n             will get l==d if s==0, but that's ok per the function\n             definition.  */\n\n          l = c - s;\n          l += (l > c ? d : 0);\n\n          ASSERT_RETVAL (l);\n          return l;\n        }\n      else\n        {\n          /* Can't skip a divide, just do the loop code once more. */\n          SUBC_LIMB (c, l, s, c);\n          q = l * inverse;\n          umul_ppmm_half_lowequal (h, q, d, l);\n          c += h;\n\n          ASSERT_RETVAL (c);\n          return c;\n        }\n    }\n  else\n    {\n      mp_limb_t  dl = LOW32 (d);\n      mp_limb_t  dh = HIGH32 (d);\n      long i;\n\n      s = *src++;\n      size--;\n      do\n        {\n          SUBC_LIMB (c, l, s, c);\n          s = *src++;\n          q = l * inverse;\n          umul_ppmm_lowequal (h, q, d, dh, dl, l);\n          c += h;\n          size--;\n        }\n      while (size != 0);\n\n      if (s <= d)\n        {\n          /* With high s <= d the final step can be a subtract and addback.\n             If c==0 then the addback will restore to l>=0.  If c==d then\n             will get l==d if s==0, but that's ok per the function\n             definition.  */\n\n          l = c - s;\n          l += (l > c ? d : 0);\n\n          ASSERT_RETVAL (l);\n          return l;\n        }\n      else\n        {\n          /* Can't skip a divide, just do the loop code once more. */\n          SUBC_LIMB (c, l, s, c);\n          q = l * inverse;\n          umul_ppmm_lowequal (h, q, d, dh, dl, l);\n          c += h;\n\n          ASSERT_RETVAL (c);\n          return c;\n        }\n    }\n}",
      "lines": 118,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/sparc64/mod_1.c": {
    "mpn_mod_1_anynorm": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static mp_limb_t\nmpn_mod_1_anynorm (mp_srcptr src_limbptr, mp_size_t size_limbs, mp_limb_t d_limb)\n{\n  int        norm, norm_rshift;\n  mp_limb_t  src_high_limb;\n  mp_size_t  i;\n\n  ASSERT (size_limbs >= 0);\n  ASSERT (d_limb != 0);\n\n  if (UNLIKELY (size_limbs == 0))\n    return 0;\n\n  src_high_limb = src_limbptr[size_limbs-1];\n\n  /* udivx is good for size==1, and no need to bother checking limb<divisor,\n     since if that's likely the caller should check */\n  if (UNLIKELY (size_limbs == 1))\n    return src_high_limb % d_limb;\n\n  if (d_limb <= CNST_LIMB(0xFFFFFFFF))\n    {\n      unsigned   *src, n1, n0, r, dummy_q, nshift, norm_rmask;\n      mp_size_t  size, adj;\n      mp_limb_t  dinv_limb;\n\n      size = 2 * size_limbs;    /* halfwords */\n      src = (unsigned *) src_limbptr;\n\n      /* prospective initial remainder, if < d */\n      r = src_high_limb >> 32;\n\n      /* If the length of the source is uniformly distributed, then there's\n         a 50% chance of the high 32-bits being zero, which we can skip.  */\n      if (r == 0)\n        {\n          r = (unsigned) src_high_limb;\n          size--;\n          ASSERT (size > 0);  /* because always even */\n        }\n\n      /* Skip a division if high < divisor.  Having the test here before\n         normalizing will still skip as often as possible.  */\n      if (r < d_limb)\n        {\n          size--;\n          ASSERT (size > 0);  /* because size==1 handled above */\n        }\n      else\n        r = 0;\n\n      count_leading_zeros_32 (norm, d_limb);\n      norm -= 32;\n      d_limb <<= norm;\n\n      norm_rshift = 32 - norm;\n      norm_rmask = (norm == 0 ? 0 : 0xFFFFFFFF);\n      i = size-1;\n      adj = HALF_ENDIAN_ADJ (i);\n      n1 = src [i + adj];\n      r = (r << norm) | ((n1 >> norm_rshift) & norm_rmask);\n\n      invert_half_limb (dinv_limb, d_limb);\n      adj = -adj;\n\n      for (i--; i >= 0; i--)\n        {\n          n0 = src [i + adj];\n          adj = -adj;\n          nshift = (n1 << norm) | ((n0 >> norm_rshift) & norm_rmask);\n          udiv_qrnnd_half_preinv (dummy_q, r, r, nshift, d_limb, dinv_limb);\n          n1 = n0;\n        }\n\n      /* same as loop, but without n0 */\n      nshift = n1 << norm;\n      udiv_qrnnd_half_preinv (dummy_q, r, r, nshift, d_limb, dinv_limb);\n\n      ASSERT ((r & ((1 << norm) - 1)) == 0);\n      return r >> norm;\n    }\n  else\n    {\n      mp_srcptr  src;\n      mp_size_t  size;\n      mp_limb_t  n1, n0, r, dinv, dummy_q, nshift, norm_rmask;\n\n      src = src_limbptr;\n      size = size_limbs;\n      r = src_high_limb;  /* initial remainder */\n\n      /* Skip a division if high < divisor.  Having the test here before\n         normalizing will still skip as often as possible.  */\n      if (r < d_limb)\n        {\n          size--;\n          ASSERT (size > 0);  /* because size==1 handled above */\n        }\n      else\n        r = 0;\n\n      count_leading_zeros (norm, d_limb);\n      d_limb <<= norm;\n\n      norm_rshift = GMP_LIMB_BITS - norm;\n      norm_rmask = (norm == 0 ? 0 : 0xFFFFFFFF);\n\n      src += size;\n      n1 = *--src;\n      r = (r << norm) | ((n1 >> norm_rshift) & norm_rmask);\n\n      invert_limb (dinv, d_limb);\n\n      for (i = size-2; i >= 0; i--)\n        {\n          n0 = *--src;\n          nshift = (n1 << norm) | ((n0 >> norm_rshift) & norm_rmask);\n          udiv_qrnnd_preinv (dummy_q, r, r, nshift, d_limb, dinv);\n          n1 = n0;\n        }\n\n      /* same as loop, but without n0 */\n      nshift = n1 << norm;\n      udiv_qrnnd_preinv (dummy_q, r, r, nshift, d_limb, dinv);\n\n      ASSERT ((r & ((CNST_LIMB(1) << norm) - 1)) == 0);\n      return r >> norm;\n    }\n}",
      "lines": 129,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_mod_1": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "mp_limb_t\nmpn_mod_1 (mp_srcptr ap, mp_size_t n, mp_limb_t b)\n{\n  ASSERT (n >= 0);\n  ASSERT (b != 0);\n\n  /* Should this be handled at all?  Rely on callers?  Note un==0 is currently\n     required by mpz/fdiv_r_ui.c and possibly other places.  */\n  if (n == 0)\n    return 0;\n\n  if (UNLIKELY ((b & GMP_NUMB_HIGHBIT) != 0))\n    {\n      if (BELOW_THRESHOLD (n, MOD_1N_TO_MOD_1_1_THRESHOLD))\n\t{\n\t  return mpn_mod_1_anynorm (ap, n, b);\n\t}\n      else\n\t{\n\t  mp_limb_t pre[4];\n\t  mpn_mod_1_1p_cps (pre, b);\n\t  return mpn_mod_1_1p (ap, n, b, pre);\n\t}\n    }\n  else\n    {\n      if (BELOW_THRESHOLD (n, MOD_1U_TO_MOD_1_1_THRESHOLD))\n\t{\n\t  return mpn_mod_1_anynorm (ap, n, b);\n\t}\n      else if (BELOW_THRESHOLD (n, MOD_1_1_TO_MOD_1_2_THRESHOLD))\n\t{\n\t  mp_limb_t pre[4];\n\t  mpn_mod_1_1p_cps (pre, b);\n\t  return mpn_mod_1_1p (ap, n, b << pre[1], pre);\n\t}\n      else if (BELOW_THRESHOLD (n, MOD_1_2_TO_MOD_1_4_THRESHOLD) || UNLIKELY (b > GMP_NUMB_MASK / 4))\n\t{\n\t  mp_limb_t pre[5];\n\t  mpn_mod_1s_2p_cps (pre, b);\n\t  return mpn_mod_1s_2p (ap, n, b << pre[1], pre);\n\t}\n      else\n\t{\n\t  mp_limb_t pre[7];\n\t  mpn_mod_1s_4p_cps (pre, b);\n\t  return mpn_mod_1s_4p (ap, n, b << pre[1], pre);\n\t}\n    }\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/sparc64/mod_1_4.c": {
    "mpn_mod_1s_4p_cps": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nmpn_mod_1s_4p_cps (mp_limb_t cps[7], mp_limb_t b)\n{\n  mp_limb_t bi;\n  mp_limb_t B1modb, B2modb, B3modb, B4modb, B5modb;\n  int cnt;\n\n  ASSERT (b <= (~(mp_limb_t) 0) / 4);\n\n  count_leading_zeros (cnt, b);\n\n  b <<= cnt;\n  invert_limb (bi, b);\n\n  cps[0] = bi;\n  cps[1] = cnt;\n\n  B1modb = -b * ((bi >> (GMP_LIMB_BITS-cnt)) | (CNST_LIMB(1) << cnt));\n  ASSERT (B1modb <= b);\t\t/* NB: not fully reduced mod b */\n  cps[2] = B1modb >> cnt;\n\n  udiv_rnnd_preinv (B2modb, B1modb, CNST_LIMB(0), b, bi);\n  cps[3] = B2modb >> cnt;\n\n  udiv_rnnd_preinv (B3modb, B2modb, CNST_LIMB(0), b, bi);\n  cps[4] = B3modb >> cnt;\n\n  udiv_rnnd_preinv (B4modb, B3modb, CNST_LIMB(0), b, bi);\n  cps[5] = B4modb >> cnt;\n\n  udiv_rnnd_preinv (B5modb, B4modb, CNST_LIMB(0), b, bi);\n  cps[6] = B5modb >> cnt;\n\n#if WANT_ASSERT\n  {\n    int i;\n    b = cps[2];\n    for (i = 3; i <= 6; i++)\n      {\n\tb += cps[i];\n\tASSERT (b >= cps[i]);\n      }\n  }\n#endif\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpn_mod_1s_4p": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "mp_limb_t\nmpn_mod_1s_4p (mp_srcptr ap, mp_size_t n, mp_limb_t b, const mp_limb_t cps[7])\n{\n  mp_limb_t rh, rl, bi, ph, pl, ch, cl, r;\n  mp_limb_t B1modb, B2modb, B3modb, B4modb, B5modb;\n  mp_size_t i;\n  int cnt;\n\n  ASSERT (n >= 1);\n\n  B1modb = cps[2];\n  B2modb = cps[3];\n  B3modb = cps[4];\n  B4modb = cps[5];\n  B5modb = cps[6];\n\n  if ((b >> 32) == 0)\n    {\n      switch (n & 3)\n\t{\n\tcase 0:\n\t  umul_ppmm_s (ph, pl, ap[n - 3], B1modb);\n\t  add_ssaaaa (ph, pl, ph, pl, CNST_LIMB(0), ap[n - 4]);\n\t  umul_ppmm_s (ch, cl, ap[n - 2], B2modb);\n\t  add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\t  umul_ppmm_s (rh, rl, ap[n - 1], B3modb);\n\t  add_ssaaaa (rh, rl, rh, rl, ph, pl);\n\t  n -= 4;\n\t  break;\n\tcase 1:\n\t  rh = 0;\n\t  rl = ap[n - 1];\n\t  n -= 1;\n\t  break;\n\tcase 2:\n\t  rh = ap[n - 1];\n\t  rl = ap[n - 2];\n\t  n -= 2;\n\t  break;\n\tcase 3:\n\t  umul_ppmm_s (ph, pl, ap[n - 2], B1modb);\n\t  add_ssaaaa (ph, pl, ph, pl, CNST_LIMB(0), ap[n - 3]);\n\t  umul_ppmm_s (rh, rl, ap[n - 1], B2modb);\n\t  add_ssaaaa (rh, rl, rh, rl, ph, pl);\n\t  n -= 3;\n\t  break;\n\t}\n\n      for (i = n - 4; i >= 0; i -= 4)\n\t{\n\t  /* rr = ap[i]\t\t\t\t< B\n\t\t+ ap[i+1] * (B mod b)\t\t<= (B-1)(b-1)\n\t\t+ ap[i+2] * (B^2 mod b)\t\t<= (B-1)(b-1)\n\t\t+ ap[i+3] * (B^3 mod b)\t\t<= (B-1)(b-1)\n\t\t+ LO(rr)  * (B^4 mod b)\t\t<= (B-1)(b-1)\n\t\t+ HI(rr)  * (B^5 mod b)\t\t<= (B-1)(b-1)\n\t  */\n\t  umul_ppmm_s (ph, pl, ap[i + 1], B1modb);\n\t  add_ssaaaa (ph, pl, ph, pl, CNST_LIMB(0), ap[i + 0]);\n\n\t  umul_ppmm_s (ch, cl, ap[i + 2], B2modb);\n\t  add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n\t  umul_ppmm_s (ch, cl, ap[i + 3], B3modb);\n\t  add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n\t  umul_ppmm_s (ch, cl, rl, B4modb);\n\t  add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n\t  umul_ppmm_s (rh, rl, rh, B5modb);\n\t  add_ssaaaa (rh, rl, rh, rl, ph, pl);\n\t}\n\n      umul_ppmm_s (rh, cl, rh, B1modb);\n      add_ssaaaa (rh, rl, rh, rl, CNST_LIMB(0), cl);\n    }\n  else\n    {\n      switch (n & 3)\n\t{\n\tcase 0:\n\t  umul_ppmm (ph, pl, ap[n - 3], B1modb);\n\t  add_ssaaaa (ph, pl, ph, pl, 0, ap[n - 4]);\n\t  umul_ppmm (ch, cl, ap[n - 2], B2modb);\n\t  add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\t  umul_ppmm (rh, rl, ap[n - 1], B3modb);\n\t  add_ssaaaa (rh, rl, rh, rl, ph, pl);\n\t  n -= 4;\n\t  break;\n\tcase 1:\n\t  rh = 0;\n\t  rl = ap[n - 1];\n\t  n -= 1;\n\t  break;\n\tcase 2:\n\t  rh = ap[n - 1];\n\t  rl = ap[n - 2];\n\t  n -= 2;\n\t  break;\n\tcase 3:\n\t  umul_ppmm (ph, pl, ap[n - 2], B1modb);\n\t  add_ssaaaa (ph, pl, ph, pl, 0, ap[n - 3]);\n\t  umul_ppmm (rh, rl, ap[n - 1], B2modb);\n\t  add_ssaaaa (rh, rl, rh, rl, ph, pl);\n\t  n -= 3;\n\t  break;\n\t}\n\n      for (i = n - 4; i >= 0; i -= 4)\n\t{\n\t  /* rr = ap[i]\t\t\t\t< B\n\t\t+ ap[i+1] * (B mod b)\t\t<= (B-1)(b-1)\n\t\t+ ap[i+2] * (B^2 mod b)\t\t<= (B-1)(b-1)\n\t\t+ ap[i+3] * (B^3 mod b)\t\t<= (B-1)(b-1)\n\t\t+ LO(rr)  * (B^4 mod b)\t\t<= (B-1)(b-1)\n\t\t+ HI(rr)  * (B^5 mod b)\t\t<= (B-1)(b-1)\n\t  */\n\t  umul_ppmm (ph, pl, ap[i + 1], B1modb);\n\t  add_ssaaaa (ph, pl, ph, pl, 0, ap[i + 0]);\n\n\t  umul_ppmm (ch, cl, ap[i + 2], B2modb);\n\t  add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n\t  umul_ppmm (ch, cl, ap[i + 3], B3modb);\n\t  add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n\t  umul_ppmm (ch, cl, rl, B4modb);\n\t  add_ssaaaa (ph, pl, ph, pl, ch, cl);\n\n\t  umul_ppmm (rh, rl, rh, B5modb);\n\t  add_ssaaaa (rh, rl, rh, rl, ph, pl);\n\t}\n\n      umul_ppmm (rh, cl, rh, B1modb);\n      add_ssaaaa (rh, rl, rh, rl, 0, cl);\n    }\n\n  bi = cps[0];\n  cnt = cps[1];\n\n  r = (rh << cnt) | (rl >> (GMP_LIMB_BITS - cnt));\n  udiv_rnnd_preinv (r, r, rl << cnt, b, bi);\n\n  return r >> cnt;\n}",
      "lines": 145,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/sparc64/sparc64.h": {},
  "gmp/gmp-6.1.2/mpn/sparc64/ultrasparc34/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/sparc64/ultrasparct1/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/vax/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/atom/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/bd1/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/bd2/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/bobcat/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/core2/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/coreihwl/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/coreinhm/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/coreisbr/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/com.c": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/fat.c": {
    "fake_cpuid_lookup": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static int\nfake_cpuid_lookup (void)\n{\n  char  *s;\n  int   i;\n\n  s = getenv (\"GMP_CPU_TYPE\");\n  if (s == NULL)\n    {\n      printf (\"Need GMP_CPU_TYPE environment variable for fake cpuid\\n\");\n      abort ();\n    }\n\n  for (i = 0; i < numberof (fake_cpuid_table); i++)\n    if (strcmp (s, fake_cpuid_table[i].name) == 0)\n      return i;\n\n  printf (\"GMP_CPU_TYPE=%s unknown\\n\", s);\n  abort ();\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fake_cpuid_available": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static int\nfake_cpuid_available (void)\n{\n  return fake_cpuid_table[fake_cpuid_lookup()].vendor[0] != '\\0';\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fake_cpuid": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static long\nfake_cpuid (char dst[12], int id)\n{\n  int  i = fake_cpuid_lookup();\n\n  switch (id) {\n  case 0:\n    memcpy (dst, fake_cpuid_table[i].vendor, 12);\n    return 0;\n  case 1:\n    return fake_cpuid_table[i].fms;\n  default:\n    printf (\"fake_cpuid(): oops, unknown id %d\\n\", id);\n    abort ();\n  }\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "__gmpn_cpuvec_init": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        486,
        1
      ],
      "content": "void\n__gmpn_cpuvec_init (void)\n{\n  struct cpuvec_t  decided_cpuvec;\n\n  TRACE (printf (\"__gmpn_cpuvec_init:\\n\"));\n\n  memset (&decided_cpuvec, '\\0', sizeof (decided_cpuvec));\n\n  CPUVEC_SETUP_x86;\n  CPUVEC_SETUP_fat;\n\n  if (! __gmpn_cpuid_available ())\n    {\n      TRACE (printf (\"  80386, or early 80486 without cpuid\\n\"));\n    }\n  else\n    {\n      char vendor_string[13];\n      char dummy_string[12];\n      long fms;\n      int family, model;\n\n      __gmpn_cpuid (vendor_string, 0);\n      vendor_string[12] = 0;\n\n      fms = __gmpn_cpuid (dummy_string, 1);\n      family = ((fms >> 8) & 0xf) + ((fms >> 20) & 0xff);\n      model = ((fms >> 4) & 0xf) + ((fms >> 12) & 0xf0);\n\n      if (strcmp (vendor_string, \"GenuineIntel\") == 0)\n        {\n          switch (family)\n            {\n            case 4:\n              TRACE (printf (\"  80486 with cpuid\\n\"));\n              break;\n\n            case 5:\n              TRACE (printf (\"  pentium\\n\"));\n              CPUVEC_SETUP_pentium;\n              if (model >= 4)\n                {\n                  TRACE (printf (\"  pentiummmx\\n\"));\n                  CPUVEC_SETUP_pentium_mmx;\n                }\n              break;\n\n            case 6:\n              TRACE (printf (\"  p6\\n\"));\n              CPUVEC_SETUP_p6;\n\t      switch (model)\n\t\t{\n\t\tcase 0x00:\n\t\tcase 0x01:\n\t\t  TRACE (printf (\"  pentiumpro\\n\"));\n\t\t  break;\n\n\t\tcase 0x02:\n\t\tcase 0x03:\n\t\tcase 0x04:\n\t\tcase 0x05:\n\t\tcase 0x06:\n\t\t  TRACE (printf (\"  pentium2\\n\"));\n                  CPUVEC_SETUP_p6_mmx;\n\t\t  break;\n\n\t\tcase 0x07:\n\t\tcase 0x08:\n\t\tcase 0x0a:\n\t\tcase 0x0b:\n\t\tcase 0x0c:\n\t\t  TRACE (printf (\"  pentium3\\n\"));\n                  CPUVEC_SETUP_p6_mmx;\n                  CPUVEC_SETUP_p6_p3mmx;\n\t\t  break;\n\n\t\tcase 0x09:\t\t/* Banias */\n\t\tcase 0x0d:\t\t/* Dothan */\n\t\tcase 0x0e:\t\t/* Yonah */\n\t\t  TRACE (printf (\"  Banias/Dothan/Yonah\\n\"));\n                  CPUVEC_SETUP_p6_mmx;\n                  CPUVEC_SETUP_p6_p3mmx;\n                  CPUVEC_SETUP_p6_sse2;\n\t\t  break;\n\n\t\tcase 0x0f:\t\t/* Conroe Merom Kentsfield Allendale */\n\t\tcase 0x10:\n\t\tcase 0x11:\n\t\tcase 0x12:\n\t\tcase 0x13:\n\t\tcase 0x14:\n\t\tcase 0x15:\n\t\tcase 0x16:\n\t\tcase 0x17:\t\t/* PNR Wolfdale Yorkfield */\n\t\tcase 0x18:\n\t\tcase 0x19:\n\t\tcase 0x1d:\t\t/* PNR Dunnington */\n\t\t  TRACE (printf (\"  Conroe\\n\"));\n                  CPUVEC_SETUP_p6_mmx;\n                  CPUVEC_SETUP_p6_p3mmx;\n                  CPUVEC_SETUP_p6_sse2;\n\t\t  CPUVEC_SETUP_core2;\n\t\t  break;\n\n\t\tcase 0x1c:\t\t/* Atom Silverthorne */\n\t\tcase 0x26:\t\t/* Atom Lincroft */\n\t\tcase 0x27:\t\t/* Atom Saltwell */\n\t\tcase 0x36:\t\t/* Atom Cedarview/Saltwell */\n\t\t  TRACE (printf (\"  atom\\n\"));\n\t\t  CPUVEC_SETUP_atom;\n\t\t  CPUVEC_SETUP_atom_mmx;\n\t\t  CPUVEC_SETUP_atom_sse2;\n\t\t  break;\n\n\t\tcase 0x1a:\t\t/* NHM Gainestown */\n\t\tcase 0x1b:\n\t\tcase 0x1e:\t\t/* NHM Lynnfield/Jasper */\n\t\tcase 0x1f:\n\t\tcase 0x20:\n\t\tcase 0x21:\n\t\tcase 0x22:\n\t\tcase 0x23:\n\t\tcase 0x24:\n\t\tcase 0x25:\t\t/* WSM Clarkdale/Arrandale */\n\t\tcase 0x28:\n\t\tcase 0x29:\n\t\tcase 0x2b:\n\t\tcase 0x2c:\t\t/* WSM Gulftown */\n\t\tcase 0x2e:\t\t/* NHM Beckton */\n\t\tcase 0x2f:\t\t/* WSM Eagleton */\n\t\t  TRACE (printf (\"  nehalem/westmere\\n\"));\n                  CPUVEC_SETUP_p6_mmx;\n                  CPUVEC_SETUP_p6_p3mmx;\n                  CPUVEC_SETUP_p6_sse2;\n\t\t  CPUVEC_SETUP_core2;\n\t\t  CPUVEC_SETUP_coreinhm;\n\t\t  break;\n\n\t\tcase 0x2a:\t\t/* SBR */\n\t\tcase 0x2d:\t\t/* SBR-EP */\n\t\tcase 0x3a:\t\t/* IBR */\n\t\tcase 0x3c:\t\t/* Haswell */\n\t\t  TRACE (printf (\"  sandybridge\\n\"));\n                  CPUVEC_SETUP_p6_mmx;\n                  CPUVEC_SETUP_p6_p3mmx;\n                  CPUVEC_SETUP_p6_sse2;\n\t\t  CPUVEC_SETUP_core2;\n\t\t  CPUVEC_SETUP_coreinhm;\n\t\t  CPUVEC_SETUP_coreisbr;\n\t\t  break;\n\t\t}\n              break;\n\n            case 15:\n              TRACE (printf (\"  pentium4\\n\"));\n              CPUVEC_SETUP_pentium4;\n              CPUVEC_SETUP_pentium4_mmx;\n              CPUVEC_SETUP_pentium4_sse2;\n              break;\n            }\n        }\n      else if (strcmp (vendor_string, \"AuthenticAMD\") == 0)\n        {\n          switch (family)\n            {\n            case 5:\n              if (model <= 3)\n                {\n                  TRACE (printf (\"  k5\\n\"));\n                }\n              else\n                {\n                  TRACE (printf (\"  k6\\n\"));\n                  CPUVEC_SETUP_k6;\n                  CPUVEC_SETUP_k6_mmx;\n                  if (model >= 8)\n                    {\n                      TRACE (printf (\"  k62\\n\"));\n                      CPUVEC_SETUP_k6_k62mmx;\n                    }\n                  if (model >= 9)\n                    {\n                      TRACE (printf (\"  k63\\n\"));\n                    }\n                }\n              break;\n            case 6:\n              TRACE (printf (\"  athlon\\n\"));\n              CPUVEC_SETUP_k7;\n              CPUVEC_SETUP_k7_mmx;\n              break;\n\n            case 0x0f:\t\t/* k8 */\n            case 0x11:\t\t/* \"fam 11h\", mix of k8 and k10 */\n            case 0x13:\t\t/* unknown, conservatively assume k8  */\n            case 0x16:\t\t/* unknown, conservatively assume k8  */\n            case 0x17:\t\t/* unknown, conservatively assume k8  */\n              TRACE (printf (\"  k8\\n\"));\n              CPUVEC_SETUP_k7;\n              CPUVEC_SETUP_k7_mmx;\n              CPUVEC_SETUP_k8;\n\t      break;\n\n            case 0x10:\t\t/* k10 */\n            case 0x12:\t\t/* k10 (llano) */\n              TRACE (printf (\"  k10\\n\"));\n              CPUVEC_SETUP_k7;\n              CPUVEC_SETUP_k7_mmx;\n\t      break;\n\n            case 0x14:\t\t/* bobcat */\n              TRACE (printf (\"  bobcat\\n\"));\n              CPUVEC_SETUP_k7;\n              CPUVEC_SETUP_k7_mmx;\n              CPUVEC_SETUP_bobcat;\n\t      break;\n\n            case 0x15:\t\t/* bulldozer */\n              TRACE (printf (\"  bulldozer\\n\"));\n              CPUVEC_SETUP_k7;\n              CPUVEC_SETUP_k7_mmx;\n\t      break;\n            }\n        }\n      else if (strcmp (vendor_string, \"CentaurHauls\") == 0)\n        {\n          switch (family)\n            {\n            case 6:\n              TRACE (printf (\"  viac3\\n\"));\n              if (model >= 9)\n                {\n                  TRACE (printf (\"  viac32\\n\"));\n                }\n\t      if (model >= 15)\n\t\t{\n                  TRACE (printf (\"  nano\\n\"));\n\t\t  CPUVEC_SETUP_nano;\n\t\t}\n              break;\n            }\n        }\n      else if (strcmp (vendor_string, \"CyrixInstead\") == 0)\n        {\n          /* Should recognize Cyrix' processors too.  */\n          TRACE (printf (\"  cyrix something\\n\"));\n        }\n    }\n\n  /* There's no x86 generic mpn_preinv_divrem_1 or mpn_preinv_mod_1.\n     Instead default to the plain versions from whichever CPU we detected.\n     The function arguments are compatible, no need for any glue code.  */\n  if (decided_cpuvec.preinv_divrem_1 == NULL)\n    decided_cpuvec.preinv_divrem_1 =(preinv_divrem_1_t)decided_cpuvec.divrem_1;\n  if (decided_cpuvec.preinv_mod_1 == NULL)\n    decided_cpuvec.preinv_mod_1    =(preinv_mod_1_t)   decided_cpuvec.mod_1;\n\n  ASSERT_CPUVEC (decided_cpuvec);\n  CPUVEC_INSTALL (decided_cpuvec);\n\n  /* Set this once the threshold fields are ready.\n     Use volatile to prevent it getting moved.  */\n  *((volatile int *) &__gmpn_cpuvec_initialized) = 1;\n}",
      "lines": 265,
      "depth": 21,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/x86/fat/gcd_1.c": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/lshiftc.c": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/mode1o.c": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/mod_1.c": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/mod_1_1.c": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/mod_1_2.c": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/mod_1_4.c": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/mullo_basecase.c": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/redc_1.c": {},
  "gmp/gmp-6.1.2/mpn/x86/fat/redc_2.c": {},
  "gmp/gmp-6.1.2/mpn/x86/geode/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/i486/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/k10/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/k6/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/k7/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/k8/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/nano/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/p6/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/p6/mmx/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/p6/sse2/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/pentium/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/pentium/mmx/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86/pentium4/sse2/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/atom/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/bd1/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/bd2/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/bobcat/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/core2/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/coreibwl/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/coreihwl/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/coreinhm/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/coreisbr/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/fat/fat.c": {
    "fake_cpuid_lookup": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static int\nfake_cpuid_lookup (void)\n{\n  char  *s;\n  int   i;\n\n  s = getenv (\"GMP_CPU_TYPE\");\n  if (s == NULL)\n    {\n      printf (\"Need GMP_CPU_TYPE environment variable for fake cpuid\\n\");\n      abort ();\n    }\n\n  for (i = 0; i < numberof (fake_cpuid_table); i++)\n    if (strcmp (s, fake_cpuid_table[i].name) == 0)\n      return i;\n\n  printf (\"GMP_CPU_TYPE=%s unknown\\n\", s);\n  abort ();\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fake_cpuid": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static long\nfake_cpuid (char dst[12], unsigned int id)\n{\n  int  i = fake_cpuid_lookup();\n\n  switch (id) {\n  case 0:\n    memcpy (dst, fake_cpuid_table[i].vendor, 12);\n    return 0;\n  case 1:\n    return fake_cpuid_table[i].fms;\n  case 7:\n    dst[0] = 0xff;\t\t\t\t/* BMI1, AVX2, etc */\n    dst[1] = 0xff;\t\t\t\t/* BMI2, etc */\n    return 0;\n  case 0x80000001:\n    dst[4 + 29 / 8] = (1 << (29 % 8));\t\t/* \"long\" mode */\n    return 0;\n  default:\n    printf (\"fake_cpuid(): oops, unknown id %d\\n\", id);\n    abort ();\n  }\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "gmp_workaround_skylake_cpuid_bug": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "static int\ngmp_workaround_skylake_cpuid_bug ()\n{\n  char feature_string[49];\n  char processor_name_string[49];\n  static const char *bad_cpus[] = {\" G44\", \" G45\", \" G39\" /* , \"6600\" */ };\n  int i;\n\n  /* Example strings:                                   */\n  /* \"Intel(R) Pentium(R) CPU G4400 @ 3.30GHz\"          */\n  /* \"Intel(R) Core(TM) i5-6600K CPU @ 3.50GHz\"         */\n  /*                  ^               ^               ^ */\n  /*     0x80000002       0x80000003      0x80000004    */\n  /* We match out just the 0x80000003 part here. */\n\n  /* In their infinitive wisdom, Intel decided to use one register order for\n     the vendor string, and another for the processor name string.  We shuffle\n     things about here, rather than write a new variant of our assembly cpuid.\n  */\n\n  unsigned int eax, ebx, ecx, edx;\n  eax = __gmpn_cpuid (feature_string, 0x80000003);\n  ebx = ((unsigned int *)feature_string)[0];\n  edx = ((unsigned int *)feature_string)[1];\n  ecx = ((unsigned int *)feature_string)[2];\n\n  ((unsigned int *) (processor_name_string))[0] = eax;\n  ((unsigned int *) (processor_name_string))[1] = ebx;\n  ((unsigned int *) (processor_name_string))[2] = ecx;\n  ((unsigned int *) (processor_name_string))[3] = edx;\n\n  processor_name_string[16] = 0;\n\n  for (i = 0; i < sizeof (bad_cpus) / sizeof (char *); i++)\n    {\n      if (strstr (processor_name_string, bad_cpus[i]) != 0)\n\treturn 1;\n    }\n  return 0;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__gmpn_cpuvec_init": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        451,
        1
      ],
      "content": "void\n__gmpn_cpuvec_init (void)\n{\n  struct cpuvec_t  decided_cpuvec;\n  char vendor_string[13];\n  char dummy_string[12];\n  long fms;\n  int family, model;\n\n  TRACE (printf (\"__gmpn_cpuvec_init:\\n\"));\n\n  memset (&decided_cpuvec, '\\0', sizeof (decided_cpuvec));\n\n  CPUVEC_SETUP_x86_64;\n  CPUVEC_SETUP_fat;\n\n  __gmpn_cpuid (vendor_string, 0);\n  vendor_string[12] = 0;\n\n  fms = __gmpn_cpuid (dummy_string, 1);\n  family = ((fms >> 8) & 0xf) + ((fms >> 20) & 0xff);\n  model = ((fms >> 4) & 0xf) + ((fms >> 12) & 0xf0);\n\n  /* Check extended feature flags */\n  __gmpn_cpuid (dummy_string, 0x80000001);\n  if ((dummy_string[4 + 29 / 8] & (1 << (29 % 8))) == 0)\n    abort (); /* longmode-capable-bit turned off! */\n\n  /*********************************************************/\n  /*** WARNING: keep this list in sync with config.guess ***/\n  /*********************************************************/\n  if (strcmp (vendor_string, \"GenuineIntel\") == 0)\n    {\n      switch (family)\n\t{\n\tcase 6:\n\t  switch (model)\n\t    {\n\t    case 0x0f:\t\t/* Conroe Merom Kentsfield Allendale */\n\t    case 0x10:\n\t    case 0x11:\n\t    case 0x12:\n\t    case 0x13:\n\t    case 0x14:\n\t    case 0x15:\n\t    case 0x16:\n\t    case 0x17:\t\t/* PNR Wolfdale Yorkfield */\n\t    case 0x18:\n\t    case 0x19:\n\t    case 0x1d:\t\t/* PNR Dunnington */\n\t      CPUVEC_SETUP_core2;\n\t      break;\n\n\t    case 0x1c:\t\t/* Atom Silverthorne */\n\t    case 0x26:\t\t/* Atom Lincroft */\n\t    case 0x27:\t\t/* Atom Saltwell? */\n\t    case 0x36:\t\t/* Atom Cedarview/Saltwell */\n\t      CPUVEC_SETUP_atom;\n\t      break;\n\n\t    case 0x1a:\t\t/* NHM Gainestown */\n\t    case 0x1b:\n\t    case 0x1e:\t\t/* NHM Lynnfield/Jasper */\n\t    case 0x1f:\n\t    case 0x20:\n\t    case 0x21:\n\t    case 0x22:\n\t    case 0x23:\n\t    case 0x24:\n\t    case 0x25:\t\t/* WSM Clarkdale/Arrandale */\n\t    case 0x28:\n\t    case 0x29:\n\t    case 0x2b:\n\t    case 0x2c:\t\t/* WSM Gulftown */\n\t    case 0x2e:\t\t/* NHM Beckton */\n\t    case 0x2f:\t\t/* WSM Eagleton */\n\t    case 0x37:\t\t/* Silvermont */\n\t    case 0x4a:\t\t/* Silvermont */\n\t    case 0x4c:\t\t/* Airmont */\n\t    case 0x4d:\t\t/* Silvermont/Avoton */\n\t    case 0x5a:\t\t/* Silvermont */\n\t    case 0x5c:\t\t/* Goldmont */\n\t    case 0x5f:\t\t/* Goldmont */\n\t      CPUVEC_SETUP_core2;\n\t      CPUVEC_SETUP_coreinhm;\n\t      break;\n\n\t    case 0x2a:\t\t/* SB */\n\t    case 0x2d:\t\t/* SBC-EP */\n\t    case 0x3a:\t\t/* IBR */\n\t    case 0x3e:\t\t/* IBR Ivytown */\n\t      CPUVEC_SETUP_core2;\n\t      CPUVEC_SETUP_coreinhm;\n\t      CPUVEC_SETUP_coreisbr;\n\t      break;\n\t    case 0x3c:\t\t/* Haswell client */\n\t    case 0x3f:\t\t/* Haswell server */\n\t    case 0x45:\t\t/* Haswell ULT */\n\t    case 0x46:\t\t/* Crystal Well */\n\t      CPUVEC_SETUP_core2;\n\t      CPUVEC_SETUP_coreinhm;\n\t      CPUVEC_SETUP_coreisbr;\n\t      /* Some Haswells lack BMI2.  Let them appear as Sandybridges for\n\t\t now.  */\n\t      __gmpn_cpuid (dummy_string, 7);\n\t      if ((dummy_string[0 + BMI2_BIT / 8] & (1 << (BMI2_BIT % 8))) == 0)\n\t\tbreak;\n\t      CPUVEC_SETUP_coreihwl;\n\t      break;\n\t    case 0x3d:\t\t/* Broadwell */\n\t    case 0x47:\t\t/* Broadwell */\n\t    case 0x4f:\t\t/* Broadwell server */\n\t    case 0x56:\t\t/* Broadwell microserver */\n\t      CPUVEC_SETUP_core2;\n\t      CPUVEC_SETUP_coreinhm;\n\t      CPUVEC_SETUP_coreisbr;\n\t      if ((dummy_string[0 + BMI2_BIT / 8] & (1 << (BMI2_BIT % 8))) == 0)\n\t\tbreak;\n\t      CPUVEC_SETUP_coreihwl;\n\t      CPUVEC_SETUP_coreibwl;\n\t      break;\n\t    case 0x4e:\t\t/* Skylake client */\n\t    case 0x55:\t\t/* Skylake server */\n\t    case 0x5e:\t\t/* Skylake */\n\t    case 0x8e:\t\t/* Kabylake */\n\t    case 0x9e:\t\t/* Kabylake */\n\t      CPUVEC_SETUP_core2;\n\t      CPUVEC_SETUP_coreinhm;\n\t      CPUVEC_SETUP_coreisbr;\n\t      if ((dummy_string[0 + BMI2_BIT / 8] & (1 << (BMI2_BIT % 8))) == 0)\n\t\tbreak;\n\t      if (gmp_workaround_skylake_cpuid_bug ())\n\t\tbreak;\n\t      CPUVEC_SETUP_coreihwl;\n\t      CPUVEC_SETUP_coreibwl;\n\t      CPUVEC_SETUP_skylake;\n\t      break;\n\t    }\n\t  break;\n\n\tcase 15:\n\t  CPUVEC_SETUP_pentium4;\n\t  break;\n\t}\n    }\n  else if (strcmp (vendor_string, \"AuthenticAMD\") == 0)\n    {\n      switch (family)\n\t{\n\tcase 0x0f:\t\t/* k8 */\n\tcase 0x11:\t\t/* \"fam 11h\", mix of k8 and k10 */\n\tcase 0x13:\n\tcase 0x17:\n\t  CPUVEC_SETUP_k8;\n\t  break;\n\n\tcase 0x10:\t\t/* k10 */\n\tcase 0x12:\t\t/* k10 (llano) */\n\t  CPUVEC_SETUP_k8;\n\t  CPUVEC_SETUP_k10;\n\t  break;\n\n\tcase 0x14:\t\t/* bobcat */\n\tcase 0x16:\t\t/* jaguar */\n\t  CPUVEC_SETUP_k8;\n\t  CPUVEC_SETUP_k10;\n\t  CPUVEC_SETUP_bobcat;\n\t  break;\n\n\tcase 0x15:\t    /* bulldozer, piledriver, steamroller, excavator */\n\t  CPUVEC_SETUP_k8;\n\t  CPUVEC_SETUP_k10;\n\t  CPUVEC_SETUP_bd1;\n\t}\n    }\n  else if (strcmp (vendor_string, \"CentaurHauls\") == 0)\n    {\n      switch (family)\n\t{\n\tcase 6:\n\t  if (model >= 15)\n\t    CPUVEC_SETUP_nano;\n\t  break;\n\t}\n    }\n\n  /* There's no x86 generic mpn_preinv_divrem_1 or mpn_preinv_mod_1.\n     Instead default to the plain versions from whichever CPU we detected.\n     The function arguments are compatible, no need for any glue code.  */\n  if (decided_cpuvec.preinv_divrem_1 == NULL)\n    decided_cpuvec.preinv_divrem_1 =(preinv_divrem_1_t)decided_cpuvec.divrem_1;\n  if (decided_cpuvec.preinv_mod_1 == NULL)\n    decided_cpuvec.preinv_mod_1    =(preinv_mod_1_t)   decided_cpuvec.mod_1;\n\n  ASSERT_CPUVEC (decided_cpuvec);\n  CPUVEC_INSTALL (decided_cpuvec);\n\n  /* Set this once the threshold fields are ready.\n     Use volatile to prevent it getting moved.  */\n  *((volatile int *) &__gmpn_cpuvec_initialized) = 1;\n}",
      "lines": 201,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpn/x86_64/fat/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/fat/mod_1.c": {},
  "gmp/gmp-6.1.2/mpn/x86_64/fat/mullo_basecase.c": {},
  "gmp/gmp-6.1.2/mpn/x86_64/fat/mul_basecase.c": {},
  "gmp/gmp-6.1.2/mpn/x86_64/fat/redc_1.c": {},
  "gmp/gmp-6.1.2/mpn/x86_64/fat/redc_2.c": {},
  "gmp/gmp-6.1.2/mpn/x86_64/fat/sqr_basecase.c": {},
  "gmp/gmp-6.1.2/mpn/x86_64/k10/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/k8/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/nano/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/pentium4/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpn/x86_64/skylake/gmp-mparam.h": {},
  "gmp/gmp-6.1.2/mpq/abs.c": {
    "mpq_abs": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\nmpq_abs (mpq_ptr dst, mpq_srcptr src)\n{\n  mp_size_t  num_abs_size = ABSIZ(NUM(src));\n\n  if (dst != src)\n    {\n      mp_size_t  den_size = SIZ(DEN(src));\n      mp_ptr dp;\n\n      dp = MPZ_NEWALLOC (NUM(dst), num_abs_size);\n      MPN_COPY (dp, PTR(NUM(src)), num_abs_size);\n\n      dp = MPZ_NEWALLOC (DEN(dst), den_size);\n      SIZ(DEN(dst)) = den_size;\n      MPN_COPY (dp, PTR(DEN(src)), den_size);\n    }\n\n  SIZ(NUM(dst)) = num_abs_size;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/aors.c": {
    "mpq_aors": {
      "start_point": [
        38,
        17
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static void\nmpq_aors (mpq_ptr rop, mpq_srcptr op1, mpq_srcptr op2,\n          void (*fun) (mpz_ptr, mpz_srcptr, mpz_srcptr))\n{\n  mpz_t gcd;\n  mpz_t tmp1, tmp2;\n  mp_size_t op1_num_size = ABSIZ(NUM(op1));\n  mp_size_t op1_den_size =   SIZ(DEN(op1));\n  mp_size_t op2_num_size = ABSIZ(NUM(op2));\n  mp_size_t op2_den_size =   SIZ(DEN(op2));\n  TMP_DECL;\n\n  TMP_MARK;\n  MPZ_TMP_INIT (gcd, MIN (op1_den_size, op2_den_size));\n  MPZ_TMP_INIT (tmp1, op1_num_size + op2_den_size);\n  MPZ_TMP_INIT (tmp2, op2_num_size + op1_den_size);\n\n  /* ROP might be identical to either operand, so don't store the\n     result there until we are finished with the input operands.  We\n     dare to overwrite the numerator of ROP when we are finished\n     with the numerators of OP1 and OP2.  */\n\n  mpz_gcd (gcd, DEN(op1), DEN(op2));\n  if (! MPZ_EQUAL_1_P (gcd))\n    {\n      mpz_t t;\n\n      MPZ_TMP_INIT (t, MAX (op1_num_size + op2_den_size,\n\t     op2_num_size + op1_den_size) + 2 - SIZ(gcd));\n\n      mpz_divexact_gcd (t, DEN(op2), gcd);\n      mpz_divexact_gcd (tmp2, DEN(op1), gcd);\n\n      mpz_mul (tmp1, NUM(op1), t);\n      mpz_mul (t, NUM(op2), tmp2);\n\n      (*fun) (t, tmp1, t);\n\n      mpz_gcd (gcd, t, gcd);\n      if (MPZ_EQUAL_1_P (gcd))\n        {\n          mpz_set (NUM(rop), t);\n          mpz_mul (DEN(rop), DEN(op2), tmp2);\n        }\n      else\n        {\n          mpz_divexact_gcd (NUM(rop), t, gcd);\n          mpz_divexact_gcd (tmp1, DEN(op2), gcd);\n          mpz_mul (DEN(rop), tmp1, tmp2);\n        }\n    }\n  else\n    {\n      /* The common divisor is 1.  This is the case (for random input) with\n\t probability 6/(pi**2), which is about 60.8%.  */\n      mpz_mul (tmp1, NUM(op1), DEN(op2));\n      mpz_mul (tmp2, NUM(op2), DEN(op1));\n      (*fun) (NUM(rop), tmp1, tmp2);\n      mpz_mul (DEN(rop), DEN(op1), DEN(op2));\n    }\n  TMP_FREE;\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpq_add": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nmpq_add (mpq_ptr rop, mpq_srcptr op1, mpq_srcptr op2)\n{\n  mpq_aors (rop, op1, op2, mpz_add);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpq_sub": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\nmpq_sub (mpq_ptr rop, mpq_srcptr op1, mpq_srcptr op2)\n{\n  mpq_aors (rop, op1, op2, mpz_sub);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/canonicalize.c": {
    "mpq_canonicalize": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\nmpq_canonicalize (mpq_t op)\n{\n  mpz_t gcd;\n  TMP_DECL;\n\n  if (SIZ(DEN(op)) < 0)\n    {\n      SIZ(NUM(op)) = -SIZ(NUM(op));\n      SIZ(DEN(op)) = -SIZ(DEN(op));\n    }\n  else if (UNLIKELY (SIZ(DEN(op)) == 0))\n    DIVIDE_BY_ZERO;\n\n  TMP_MARK;\n\n  /* ??? Dunno if the 1+ is needed.  */\n  MPZ_TMP_INIT (gcd, 1 + MAX (ABSIZ(NUM(op)),\n\t\t\t      SIZ(DEN(op))));\n\n  mpz_gcd (gcd, NUM(op), DEN(op));\n  if (! MPZ_EQUAL_1_P (gcd))\n    {\n      mpz_divexact_gcd (NUM(op), NUM(op), gcd);\n      mpz_divexact_gcd (DEN(op), DEN(op), gcd);\n    }\n  TMP_FREE;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/clear.c": {
    "mpq_clear": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\nmpq_clear (mpq_t x)\n{\n  __GMP_FREE_FUNC_LIMBS (PTR(NUM(x)), ALLOC(NUM(x)));\n  __GMP_FREE_FUNC_LIMBS (PTR(DEN(x)), ALLOC(DEN(x)));\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/clears.c": {
    "mpq_clears": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "void\nmpq_clears (mpq_ptr x, ...)\n{\n  va_list  ap;\n\n  va_start (ap, x);\n\n  while (x != NULL)\n    {\n      __GMP_FREE_FUNC_LIMBS (PTR(NUM(x)), ALLOC(NUM(x)));\n      __GMP_FREE_FUNC_LIMBS (PTR(DEN(x)), ALLOC(DEN(x)));\n      x = va_arg (ap, mpq_ptr);\n    }\n\n  va_end (ap);\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/cmp.c": {
    "mpq_cmp_numden": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\nmpq_cmp_numden (mpq_srcptr op1, mpz_srcptr num_op2, mpz_srcptr den_op2)\n{\n  mp_size_t num1_size = SIZ(NUM(op1));\n  mp_size_t den1_size = SIZ(DEN(op1));\n  mp_size_t num2_size = SIZ(num_op2);\n  mp_size_t den2_size = SIZ(den_op2);\n  int op2_is_int;\n  mp_limb_t d1h, d2h;\n  mp_size_t tmp1_size, tmp2_size;\n  mp_ptr tmp1_ptr, tmp2_ptr;\n  mp_size_t num1_sign;\n  int cc;\n  TMP_DECL;\n\n  /* need canonical signs to get right result */\n  ASSERT (den1_size > 0);\n  ASSERT (den2_size > 0);\n\n  if (num1_size == 0)\n    return -num2_size;\n  if (num2_size == 0)\n    return num1_size;\n  if ((num1_size ^ num2_size) < 0) /* I.e. are the signs different? */\n    return num1_size;\n\n  num1_sign = num1_size;\n  num1_size = ABS (num1_size);\n\n  /* THINK: Does storing d1h and d2h make sense? */\n  d1h = PTR(DEN(op1))[den1_size - 1];\n  d2h = PTR(den_op2)[den2_size - 1];\n  op2_is_int = (den2_size | d2h) == 1;\n  if (op2_is_int == (den1_size | d1h)) /* Both ops are integers */\n    /* return mpz_cmp (NUM (op1), num_op2); */\n    {\n      int cmp;\n\n      if (num1_sign != num2_size)\n\treturn num1_sign - num2_size;\n\n      cmp = mpn_cmp (PTR(NUM(op1)), PTR(num_op2), num1_size);\n      return (num1_sign > 0 ? cmp : -cmp);\n    }\n\n  num2_size = ABS (num2_size);\n\n  tmp1_size = num1_size + den2_size;\n  tmp2_size = num2_size + den1_size;\n\n  /* 1. Check to see if we can tell which operand is larger by just looking at\n     the number of limbs.  */\n\n  /* NUM1 x DEN2 is either TMP1_SIZE limbs or TMP1_SIZE-1 limbs.\n     Same for NUM1 x DEN1 with respect to TMP2_SIZE.  */\n  if (tmp1_size > tmp2_size + 1)\n    /* NUM1 x DEN2 is surely larger in magnitude than NUM2 x DEN1.  */\n    return num1_sign;\n  if (tmp2_size + op2_is_int > tmp1_size + 1)\n    /* NUM1 x DEN2 is surely smaller in magnitude than NUM2 x DEN1.  */\n    return -num1_sign;\n\n  /* 2. Same, but compare the number of significant bits.  */\n  {\n    int cnt1, cnt2;\n    mp_bitcnt_t bits1, bits2;\n\n    count_leading_zeros (cnt1, PTR(NUM(op1))[num1_size - 1]);\n    count_leading_zeros (cnt2, d2h);\n    bits1 = (mp_bitcnt_t) tmp1_size * GMP_NUMB_BITS - cnt1 - cnt2 + 2 * GMP_NAIL_BITS;\n\n    count_leading_zeros (cnt1, PTR(num_op2)[num2_size - 1]);\n    count_leading_zeros (cnt2, d1h);\n    bits2 = (mp_bitcnt_t) tmp2_size * GMP_NUMB_BITS - cnt1 - cnt2 + 2 * GMP_NAIL_BITS;\n\n    if (bits1 > bits2 + 1)\n      return num1_sign;\n    if (bits2 + op2_is_int > bits1 + 1)\n      return -num1_sign;\n  }\n\n  /* 3. Finally, cross multiply and compare.  */\n\n  TMP_MARK;\n  if (op2_is_int)\n    {\n      tmp2_ptr = TMP_ALLOC_LIMBS (tmp2_size);\n      tmp1_ptr = PTR(NUM(op1));\n      --tmp1_size;\n    }\n  else\n    {\n  TMP_ALLOC_LIMBS_2 (tmp1_ptr,tmp1_size, tmp2_ptr,tmp2_size);\n\n  if (num1_size >= den2_size)\n    tmp1_size -= 0 == mpn_mul (tmp1_ptr,\n\t\t\t       PTR(NUM(op1)), num1_size,\n\t\t\t       PTR(den_op2), den2_size);\n  else\n    tmp1_size -= 0 == mpn_mul (tmp1_ptr,\n\t\t\t       PTR(den_op2), den2_size,\n\t\t\t       PTR(NUM(op1)), num1_size);\n    }\n\n   if (num2_size >= den1_size)\n     tmp2_size -= 0 == mpn_mul (tmp2_ptr,\n\t\t\t\tPTR(num_op2), num2_size,\n\t\t\t\tPTR(DEN(op1)), den1_size);\n   else\n     tmp2_size -= 0 == mpn_mul (tmp2_ptr,\n\t\t\t\tPTR(DEN(op1)), den1_size,\n\t\t\t\tPTR(num_op2), num2_size);\n\n\n  cc = tmp1_size - tmp2_size != 0\n    ? tmp1_size - tmp2_size : mpn_cmp (tmp1_ptr, tmp2_ptr, tmp1_size);\n  TMP_FREE;\n  return num1_sign < 0 ? -cc : cc;\n}",
      "lines": 119,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpq_cmp": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "int\nmpq_cmp (mpq_srcptr op1, mpq_srcptr op2)\n{\n  return mpq_cmp_numden (op1, NUM(op2), DEN(op2));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mpq_cmp_z": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "int\nmpq_cmp_z (mpq_srcptr op1, mpz_srcptr op2)\n{\n  const static mp_limb_t one = 1;\n  const static mpz_t den = MPZ_ROINIT_N ((mp_limb_t *) &one, 1);\n\n  return mpq_cmp_numden (op1, op2, den);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/cmp_si.c": {
    "_mpq_cmp_si": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\n_mpq_cmp_si (mpq_srcptr q, long n, unsigned long d)\n{\n  /* need canonical sign to get right result */\n  ASSERT (SIZ(DEN(q)) > 0);\n\n  if (n >= 0)\n    return _mpq_cmp_ui (q, n, d);\n  if (SIZ(NUM(q)) >= 0)\n    {\n      return 1;                                /* >=0 cmp <0 */\n    }\n  else\n    {\n      mpq_t  qabs;\n      SIZ(NUM(qabs)) = -SIZ(NUM(q));\n      PTR(NUM(qabs)) = PTR(NUM(q));\n      SIZ(DEN(qabs)) = SIZ(DEN(q));\n      PTR(DEN(qabs)) = PTR(DEN(q));\n\n      return - _mpq_cmp_ui (qabs, NEG_CAST (unsigned long, n), d);    /* <0 cmp <0 */\n    }\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/cmp_ui.c": {
    "_mpq_cmp_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\n_mpq_cmp_ui (mpq_srcptr op1, unsigned long int num2, unsigned long int den2)\n{\n  mp_size_t num1_size = SIZ(NUM(op1));\n  mp_size_t den1_size = SIZ(DEN(op1));\n  mp_size_t tmp1_size, tmp2_size;\n  mp_ptr tmp1_ptr, tmp2_ptr;\n  mp_limb_t cy_limb;\n  int cc;\n  TMP_DECL;\n\n#if GMP_NAIL_BITS != 0\n  if ((num2 | den2) > GMP_NUMB_MAX)\n    {\n      mpq_t op2;\n      mpq_init (op2);\n      mpz_set_ui (mpq_numref (op2), num2);\n      mpz_set_ui (mpq_denref (op2), den2);\n      cc = mpq_cmp (op1, op2);\n      mpq_clear (op2);\n      return cc;\n    }\n#endif\n\n  /* need canonical sign to get right result */\n  ASSERT (den1_size > 0);\n\n  if (UNLIKELY (den2 == 0))\n    DIVIDE_BY_ZERO;\n\n  if (num2 == 0)\n    return num1_size;\n  if (num1_size <= 0)\n    return -1;\n\n  /* NUM1 x DEN2 is either TMP1_SIZE limbs or TMP1_SIZE-1 limbs.\n     Same for NUM1 x DEN1 with respect to TMP2_SIZE.  */\n  if (num1_size > den1_size + 1)\n    /* NUM1 x DEN2 is surely larger in magnitude than NUM2 x DEN1.  */\n    return num1_size;\n  if (den1_size > num1_size + 1)\n    /* NUM1 x DEN2 is surely smaller in magnitude than NUM2 x DEN1.  */\n    return -num1_size;\n\n  TMP_MARK;\n  TMP_ALLOC_LIMBS_2 (tmp1_ptr, num1_size + 1, tmp2_ptr, den1_size + 1);\n\n  cy_limb = mpn_mul_1 (tmp1_ptr, PTR(NUM(op1)), num1_size,\n                       (mp_limb_t) den2);\n  tmp1_ptr[num1_size] = cy_limb;\n  tmp1_size = num1_size + (cy_limb != 0);\n\n  cy_limb = mpn_mul_1 (tmp2_ptr, PTR(DEN(op1)), den1_size,\n                       (mp_limb_t) num2);\n  tmp2_ptr[den1_size] = cy_limb;\n  tmp2_size = den1_size + (cy_limb != 0);\n\n  cc = tmp1_size - tmp2_size != 0\n    ? tmp1_size - tmp2_size : mpn_cmp (tmp1_ptr, tmp2_ptr, tmp1_size);\n  TMP_FREE;\n  return cc;\n}",
      "lines": 62,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/div.c": {
    "mpq_div": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\nmpq_div (mpq_ptr quot, mpq_srcptr op1, mpq_srcptr op2)\n{\n  mpz_t gcd1, gcd2;\n  mpz_t tmp1, tmp2;\n  mp_size_t op1_size;\n  mp_size_t op2_size;\n  mp_size_t alloc;\n  TMP_DECL;\n\n  op2_size = SIZ(NUM(op2));\n\n  if (UNLIKELY (op2_size == 0))\n    DIVIDE_BY_ZERO;\n\n  if (UNLIKELY (quot == op2))\n    {\n      if (op1 == op2)\n\t{\n\t  PTR(NUM(quot))[0] = 1;\n\t  SIZ(NUM(quot)) = 1;\n\t  PTR(DEN(quot))[0] = 1;\n\t  SIZ(DEN(quot)) = 1;\n\t  return;\n\t}\n\n      /* We checked for op1 == op2: we are not in the x=x/x case.\n\t We compute x=y/x by computing x=inv(x)*y */\n      MPN_PTR_SWAP (PTR(NUM(quot)), ALLOC(NUM(quot)),\n\t\t    PTR(DEN(quot)), ALLOC(DEN(quot)));\n      if (op2_size > 0)\n\t{\n\t  SIZ(NUM(quot)) = SIZ(DEN(quot));\n\t  SIZ(DEN(quot)) = op2_size;\n\t}\n      else\n\t{\n\t  SIZ(NUM(quot)) = - SIZ(DEN(quot));\n\t  SIZ(DEN(quot)) = - op2_size;\n\t}\n      mpq_mul (quot, quot, op1);\n      return;\n    }\n\n  op1_size = ABSIZ(NUM(op1));\n\n  if (op1_size == 0)\n    {\n      /* We special case this to simplify allocation logic; gcd(0,x) = x\n\t is a singular case for the allocations.  */\n      SIZ(NUM(quot)) = 0;\n      PTR(DEN(quot))[0] = 1;\n      SIZ(DEN(quot)) = 1;\n      return;\n    }\n\n  op2_size = ABS(op2_size);\n\n  TMP_MARK;\n\n  alloc = MIN (op1_size, op2_size);\n  MPZ_TMP_INIT (gcd1, alloc);\n\n  alloc = MAX (op1_size, op2_size);\n  MPZ_TMP_INIT (tmp1, alloc);\n\n  op2_size = SIZ(DEN(op2));\n  op1_size = SIZ(DEN(op1));\n\n  alloc = MIN (op1_size, op2_size);\n  MPZ_TMP_INIT (gcd2, alloc);\n\n  alloc = MAX (op1_size, op2_size);\n  MPZ_TMP_INIT (tmp2, alloc);\n\n  /* QUOT might be identical to OP1, so don't store the result there\n     until we are finished with the input operand.  We can overwrite\n     the numerator of QUOT when we are finished with the numerator of\n     OP1. */\n\n  mpz_gcd (gcd1, NUM(op1), NUM(op2));\n  mpz_gcd (gcd2, DEN(op2), DEN(op1));\n\n  mpz_divexact_gcd (tmp1, NUM(op1), gcd1);\n  mpz_divexact_gcd (tmp2, DEN(op2), gcd2);\n\n  mpz_mul (NUM(quot), tmp1, tmp2);\n\n  mpz_divexact_gcd (tmp1, NUM(op2), gcd1);\n  mpz_divexact_gcd (tmp2, DEN(op1), gcd2);\n\n  mpz_mul (DEN(quot), tmp1, tmp2);\n\n  /* Keep the denominator positive.  */\n  if (SIZ(DEN(quot)) < 0)\n    {\n      SIZ(DEN(quot)) = -SIZ(DEN(quot));\n      SIZ(NUM(quot)) = -SIZ(NUM(quot));\n    }\n\n  TMP_FREE;\n}",
      "lines": 102,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/equal.c": {
    "mpq_equal": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nmpq_equal (mpq_srcptr op1, mpq_srcptr op2) __GMP_NOTHROW\n{\n  mp_size_t  num1_size, num2_size, den1_size, den2_size, i;\n  mp_srcptr  num1_ptr,  num2_ptr,  den1_ptr,  den2_ptr;\n\n  /* need fully canonical for correct results */\n  ASSERT_MPQ_CANONICAL (op1);\n  ASSERT_MPQ_CANONICAL (op2);\n\n  num1_size = SIZ(NUM(op1));\n  num2_size = SIZ(NUM(op2));\n  if (num1_size != num2_size)\n    return 0;\n\n  num1_ptr = PTR(NUM(op1));\n  num2_ptr = PTR(NUM(op2));\n  num1_size = ABS (num1_size);\n  for (i = 0; i < num1_size; i++)\n    if (num1_ptr[i] != num2_ptr[i])\n      return 0;\n\n  den1_size = SIZ(DEN(op1));\n  den2_size = SIZ(DEN(op2));\n  if (den1_size != den2_size)\n    return 0;\n\n  den1_ptr = PTR(DEN(op1));\n  den2_ptr = PTR(DEN(op2));\n  for (i = 0; i < den1_size; i++)\n    if (den1_ptr[i] != den2_ptr[i])\n      return 0;\n\n  return 1;\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "int",
        "mpq_equal (mpq_srcptr op1, mpq_srcptr op2)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/get_d.c": {
    "mpq_get_d": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "double\nmpq_get_d (mpq_srcptr src)\n{\n  double res;\n  mp_srcptr np, dp;\n  mp_ptr remp, tp;\n  mp_size_t nsize = SIZ(NUM(src));\n  mp_size_t dsize = SIZ(DEN(src));\n  mp_size_t qsize, prospective_qsize, zeros, chop, tsize;\n  mp_size_t sign_quotient = nsize;\n  long exp;\n#define N_QLIMBS (1 + (sizeof (double) + GMP_LIMB_BYTES-1) / GMP_LIMB_BYTES)\n  mp_limb_t qarr[N_QLIMBS + 1];\n  mp_ptr qp = qarr;\n  TMP_DECL;\n\n  ASSERT (dsize > 0);    /* canonical src */\n\n  /* mpn_get_d below requires a non-zero operand */\n  if (UNLIKELY (nsize == 0))\n    return 0.0;\n\n  TMP_MARK;\n  nsize = ABS (nsize);\n  dsize = ABS (dsize);\n  np = PTR(NUM(src));\n  dp = PTR(DEN(src));\n\n  prospective_qsize = nsize - dsize + 1;   /* from using given n,d */\n  qsize = N_QLIMBS + 1;                    /* desired qsize */\n\n  zeros = qsize - prospective_qsize;       /* padding n to get qsize */\n  exp = (long) -zeros * GMP_NUMB_BITS;     /* relative to low of qp */\n\n  chop = MAX (-zeros, 0);                  /* negative zeros means shorten n */\n  np += chop;\n  nsize -= chop;\n  zeros += chop;                           /* now zeros >= 0 */\n\n  tsize = nsize + zeros;                   /* size for possible copy of n */\n\n  if (WANT_TMP_DEBUG)\n    {\n      /* separate blocks, for malloc debugging */\n      remp = TMP_ALLOC_LIMBS (dsize);\n      tp = (zeros > 0 ? TMP_ALLOC_LIMBS (tsize) : NULL);\n    }\n  else\n    {\n      /* one block with conditionalized size, for efficiency */\n      remp = TMP_ALLOC_LIMBS (dsize + (zeros > 0 ? tsize : 0));\n      tp = remp + dsize;\n    }\n\n  /* zero extend n into temporary space, if necessary */\n  if (zeros > 0)\n    {\n      MPN_ZERO (tp, zeros);\n      MPN_COPY (tp+zeros, np, nsize);\n      np = tp;\n      nsize = tsize;\n    }\n\n  ASSERT (qsize == nsize - dsize + 1);\n  mpn_tdiv_qr (qp, remp, (mp_size_t) 0, np, nsize, dp, dsize);\n\n  /* strip possible zero high limb */\n  qsize -= (qp[qsize-1] == 0);\n\n  res = mpn_get_d (qp, qsize, sign_quotient, exp);\n  TMP_FREE;\n  return res;\n}",
      "lines": 73,
      "depth": 13,
      "decorators": [
        "double"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/get_den.c": {
    "mpq_get_den": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\nmpq_get_den (mpz_ptr den, mpq_srcptr src)\n{\n  mp_size_t size = SIZ(DEN(src));\n  mp_ptr dp;\n\n  dp = MPZ_NEWALLOC (den, size);\n  SIZ(den) = size;\n  MPN_COPY (dp, PTR(DEN(src)), size);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/get_num.c": {
    "mpq_get_num": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nmpq_get_num (mpz_ptr num, mpq_srcptr src)\n{\n  mp_size_t size = SIZ(NUM(src));\n  mp_size_t abs_size = ABS (size);\n  mp_ptr dp;\n\n  dp = MPZ_NEWALLOC (num, abs_size);\n  SIZ(num) = size;\n\n  MPN_COPY (dp, PTR(NUM(src)), abs_size);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/get_str.c": {
    "mpq_get_str": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "char *\nmpq_get_str (char *str, int base, mpq_srcptr q)\n{\n  size_t  str_alloc, len;\n\n  if (base > 62 || base < -36)\n    return NULL;\n\n  str_alloc = 0;\n  if (str == NULL)\n    {\n      /* This is an overestimate since we don't bother checking how much of\n\t the high limbs of num and den are used.  +2 for rounding up the\n\t chars per bit of num and den.  +3 for sign, slash and '\\0'.  */\n      DIGITS_IN_BASE_PER_LIMB (str_alloc, ABSIZ(NUM(q)) + SIZ(DEN(q)), ABS(base));\n      str_alloc += 6;\n\n      str = (char *) (*__gmp_allocate_func) (str_alloc);\n    }\n\n  mpz_get_str (str, base, mpq_numref(q));\n  len = strlen (str);\n  if (! MPZ_EQUAL_1_P (mpq_denref (q)))\n    {\n      str[len++] = '/';\n      mpz_get_str (str+len, base, mpq_denref(q));\n      len += strlen (str+len);\n    }\n\n  ASSERT (len == strlen(str));\n  ASSERT (str_alloc == 0 || len+1 <= str_alloc);\n  ASSERT (len+1 <=  /* size recommended to applications */\n\t  mpz_sizeinbase (mpq_numref(q), ABS(base)) +\n\t  mpz_sizeinbase (mpq_denref(q), ABS(base)) + 3);\n\n  if (str_alloc != 0)\n    __GMP_REALLOCATE_FUNC_MAYBE_TYPE (str, str_alloc, len+1, char);\n\n  return str;\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "char",
        "*\nmpq_get_str (char *str, int base, mpq_srcptr q)",
        "*"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/init.c": {
    "mpq_init": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nmpq_init (mpq_t x)\n{\n  ALLOC(NUM(x)) = 1;\n  PTR(NUM(x)) = __GMP_ALLOCATE_FUNC_LIMBS (1);\n  SIZ(NUM(x)) = 0;\n  ALLOC(DEN(x)) = 1;\n  PTR(DEN(x)) = __GMP_ALLOCATE_FUNC_LIMBS (1);\n  PTR(DEN(x))[0] = 1;\n  SIZ(DEN(x)) = 1;\n\n#ifdef __CHECKER__\n  /* let the low limb look initialized, for the benefit of mpz_get_ui etc */\n  PTR(NUM(x))[0] = 0;\n#endif\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/inits.c": {
    "mpq_inits": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nmpq_inits (mpq_ptr x, ...)\n{\n  va_list  ap;\n\n  va_start (ap, x);\n\n  while (x != NULL)\n    {\n      mpq_init (x);\n      x = va_arg (ap, mpq_ptr);\n    }\n\n  va_end (ap);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/inp_str.c": {
    "mpq_inp_str": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "size_t\nmpq_inp_str (mpq_ptr q, FILE *fp, int base)\n{\n  size_t  nread;\n  int     c;\n\n  if (fp == NULL)\n    fp = stdin;\n\n  SIZ(DEN(q)) = 1;\n  PTR(DEN(q))[0] = 1;\n\n  nread = mpz_inp_str (mpq_numref(q), fp, base);\n  if (nread == 0)\n    return 0;\n\n  c = getc (fp);\n  nread++;\n\n  if (c == '/')\n    {\n      c = getc (fp);\n      nread++;\n\n      nread = mpz_inp_str_nowhite (mpq_denref(q), fp, base, c, nread);\n      if (nread == 0)\n\t{\n\t  SIZ(NUM(q)) = 0;\n\t  SIZ(DEN(q)) = 1;\n\t  PTR(DEN(q))[0] = 1;\n\t}\n    }\n  else\n    {\n      ungetc (c, fp);\n      nread--;\n    }\n\n  return nread;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/inv.c": {
    "mpq_inv": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\nmpq_inv (mpq_ptr dest, mpq_srcptr src)\n{\n  mp_size_t num_size = SIZ(NUM(src));\n  mp_size_t den_size = SIZ(DEN(src));\n\n  if (num_size < 0)\n    {\n      num_size = -num_size;\n      den_size = -den_size;\n    }\n  else if (UNLIKELY (num_size == 0))\n    DIVIDE_BY_ZERO;\n\n  SIZ(DEN(dest)) = num_size;\n  SIZ(NUM(dest)) = den_size;\n\n  /* If dest == src we may just swap the numerator and denominator;\n     we ensured that the new denominator is positive.  */\n\n  if (dest == src)\n    {\n      MP_PTR_SWAP (PTR(NUM(dest)), PTR(DEN(dest)));\n      MP_SIZE_T_SWAP (ALLOC(NUM(dest)), ALLOC(DEN(dest)));\n    }\n  else\n    {\n      mp_ptr dp;\n\n      den_size = ABS (den_size);\n      dp = MPZ_NEWALLOC (NUM(dest), den_size);\n      MPN_COPY (dp, PTR(DEN(src)), den_size);\n\n      dp = MPZ_NEWALLOC (DEN(dest), num_size);\n      MPN_COPY (dp, PTR(NUM(src)), num_size);\n    }\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/md_2exp.c": {
    "mord_2exp": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\nmord_2exp (mpz_ptr ldst, mpz_ptr rdst, mpz_srcptr lsrc, mpz_srcptr rsrc,\n           mp_bitcnt_t n)\n{\n  mp_size_t  rsrc_size = SIZ(rsrc);\n  mp_size_t  len = ABS (rsrc_size);\n  mp_ptr     rsrc_ptr = PTR(rsrc);\n  mp_ptr     p, rdst_ptr;\n  mp_limb_t  plow;\n\n  p = rsrc_ptr;\n  plow = *p;\n  while (n >= GMP_NUMB_BITS && plow == 0)\n    {\n      n -= GMP_NUMB_BITS;\n      p++;\n      plow = *p;\n    }\n\n  /* no realloc here if rsrc==rdst, so p and rsrc_ptr remain valid */\n  len -= (p - rsrc_ptr);\n  rdst_ptr = MPZ_REALLOC (rdst, len);\n\n  if ((plow & 1) || n == 0)\n    {\n      /* need INCR when src==dst */\n      if (p != rdst_ptr)\n        MPN_COPY_INCR (rdst_ptr, p, len);\n    }\n  else\n    {\n      unsigned long  shift;\n      if (plow == 0)\n        shift = n;\n      else\n        {\n          count_trailing_zeros (shift, plow);\n          shift = MIN (shift, n);\n        }\n      mpn_rshift (rdst_ptr, p, len, shift);\n      len -= (rdst_ptr[len-1] == 0);\n      n -= shift;\n    }\n  SIZ(rdst) = (rsrc_size >= 0) ? len : -len;\n\n  if (n)\n    mpz_mul_2exp (ldst, lsrc, n);\n  else if (ldst != lsrc)\n    mpz_set (ldst, lsrc);\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpq_mul_2exp": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nmpq_mul_2exp (mpq_ptr dst, mpq_srcptr src, mp_bitcnt_t n)\n{\n  mord_2exp (NUM(dst), DEN(dst), NUM(src), DEN(src), n);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpq_div_2exp": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\nmpq_div_2exp (mpq_ptr dst, mpq_srcptr src, mp_bitcnt_t n)\n{\n  if (SIZ(NUM(src)) == 0)\n    {\n      SIZ(NUM(dst)) = 0;\n      SIZ(DEN(dst)) = 1;\n      PTR(DEN(dst))[0] = 1;\n      return;\n    }\n\n  mord_2exp (DEN(dst), NUM(dst), DEN(src), NUM(src), n);\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/mul.c": {
    "mpq_mul": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "void\nmpq_mul (mpq_ptr prod, mpq_srcptr op1, mpq_srcptr op2)\n{\n  mpz_t gcd1, gcd2;\n  mpz_t tmp1, tmp2;\n  mp_size_t op1_num_size;\n  mp_size_t op1_den_size;\n  mp_size_t op2_num_size;\n  mp_size_t op2_den_size;\n  mp_size_t alloc;\n  TMP_DECL;\n\n  if (op1 == op2)\n    {\n      /* No need for any GCDs when squaring. */\n      mpz_mul (mpq_numref (prod), mpq_numref (op1), mpq_numref (op1));\n      mpz_mul (mpq_denref (prod), mpq_denref (op1), mpq_denref (op1));\n      return;\n    }\n\n  op1_num_size = ABSIZ(NUM(op1));\n  op1_den_size =   SIZ(DEN(op1));\n  op2_num_size = ABSIZ(NUM(op2));\n  op2_den_size =   SIZ(DEN(op2));\n\n  if (op1_num_size == 0 || op2_num_size == 0)\n    {\n      /* We special case this to simplify allocation logic; gcd(0,x) = x\n\t is a singular case for the allocations.  */\n      SIZ(NUM(prod)) = 0;\n      PTR(DEN(prod))[0] = 1;\n      SIZ(DEN(prod)) = 1;\n      return;\n    }\n\n  TMP_MARK;\n\n  alloc = MIN (op1_num_size, op2_den_size);\n  MPZ_TMP_INIT (gcd1, alloc);\n\n  alloc = MIN (op2_num_size, op1_den_size);\n  MPZ_TMP_INIT (gcd2, alloc);\n\n  alloc = MAX (op1_num_size, op2_den_size);\n  MPZ_TMP_INIT (tmp1, alloc);\n\n  alloc = MAX (op2_num_size, op1_den_size);\n  MPZ_TMP_INIT (tmp2, alloc);\n\n  /* PROD might be identical to either operand, so don't store the result there\n     until we are finished with the input operands.  We can overwrite the\n     numerator of PROD when we are finished with the numerators of OP1 and\n     OP2.  */\n\n  mpz_gcd (gcd1, NUM(op1), DEN(op2));\n  mpz_gcd (gcd2, NUM(op2), DEN(op1));\n\n  mpz_divexact_gcd (tmp1, NUM(op1), gcd1);\n  mpz_divexact_gcd (tmp2, NUM(op2), gcd2);\n\n  mpz_mul (NUM(prod), tmp1, tmp2);\n\n  mpz_divexact_gcd (tmp1, DEN(op2), gcd1);\n  mpz_divexact_gcd (tmp2, DEN(op1), gcd2);\n\n  mpz_mul (DEN(prod), tmp1, tmp2);\n\n  TMP_FREE;\n}",
      "lines": 69,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/neg.c": {
    "mpq_neg": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\nmpq_neg (mpq_ptr dst, mpq_srcptr src)\n{\n  mp_size_t  num_size = SIZ(NUM(src));\n\n  if (src != dst)\n    {\n      mp_size_t  size;\n      mp_ptr dp;\n\n      size = ABS(num_size);\n      dp = MPZ_NEWALLOC (NUM(dst), size);\n      MPN_COPY (dp, PTR(NUM(src)), size);\n\n      size = SIZ(DEN(src));\n      dp = MPZ_NEWALLOC (DEN(dst), size);\n      SIZ(DEN(dst)) = size;\n      MPN_COPY (dp, PTR(DEN(src)), size);\n    }\n\n  SIZ(NUM(dst)) = -num_size;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/out_str.c": {
    "mpq_out_str": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "size_t\nmpq_out_str (FILE *stream, int base, mpq_srcptr q)\n{\n  size_t  written;\n\n  if (stream == NULL)\n    stream = stdout;\n\n  written = mpz_out_str (stream, base, mpq_numref (q));\n\n  if (mpz_cmp_ui (mpq_denref (q), 1) != 0)\n    {\n      putc ('/', stream);\n      written += 1 + mpz_out_str (stream, base, mpq_denref (q));\n    }\n\n  return ferror (stream) ? 0 : written;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/set.c": {
    "mpq_set": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\nmpq_set (mpq_ptr dest, mpq_srcptr src)\n{\n  mp_size_t num_size, den_size;\n  mp_size_t abs_num_size;\n  mp_ptr dp;\n\n  num_size = SIZ(NUM(src));\n  abs_num_size = ABS (num_size);\n  dp = MPZ_NEWALLOC (NUM(dest), abs_num_size);\n  SIZ(NUM(dest)) = num_size;\n  MPN_COPY (dp, PTR(NUM(src)), abs_num_size);\n\n  den_size = SIZ(DEN(src));\n  dp = MPZ_NEWALLOC (DEN(dest), den_size);\n  SIZ(DEN(dest)) = den_size;\n  MPN_COPY (dp, PTR(DEN(src)), den_size);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/set_d.c": {
    "mpq_set_d": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\nmpq_set_d (mpq_ptr dest, double d)\n{\n  int negative;\n  mp_exp_t exp;\n  mp_limb_t tp[LIMBS_PER_DOUBLE];\n  mp_ptr np, dp;\n  mp_size_t nn, dn;\n  int c;\n\n  DOUBLE_NAN_INF_ACTION (d,\n                         __gmp_invalid_operation (),\n                         __gmp_invalid_operation ());\n\n  negative = d < 0;\n  d = ABS (d);\n\n  exp = __gmp_extract_double (tp, d);\n\n  /* There are two main version of the conversion.  The `then' arm handles\n     numbers with a fractional part, while the `else' arm handles integers.  */\n#if LIMBS_PER_DOUBLE == 4\n  if (exp <= 1 || (exp == 2 && (tp[0] | tp[1]) != 0))\n#endif\n#if LIMBS_PER_DOUBLE == 3\n  if (exp <= 1 || (exp == 2 && tp[0] != 0))\n#endif\n#if LIMBS_PER_DOUBLE == 2\n  if (exp <= 1)\n#endif\n    {\n      if (d == 0.0)\n\t{\n\t  SIZ(NUM(dest)) = 0;\n\t  SIZ(DEN(dest)) = 1;\n\t  PTR(DEN(dest))[0] = 1;\n\t  return;\n\t}\n\n#if LIMBS_PER_DOUBLE == 4\n      np = MPZ_NEWALLOC (NUM(dest), 4);\n      if ((tp[0] | tp[1] | tp[2]) == 0)\n\tnp[0] = tp[3], nn = 1;\n      else if ((tp[0] | tp[1]) == 0)\n\tnp[1] = tp[3], np[0] = tp[2], nn = 2;\n      else if (tp[0] == 0)\n\tnp[2] = tp[3], np[1] = tp[2], np[0] = tp[1], nn = 3;\n      else\n\tnp[3] = tp[3], np[2] = tp[2], np[1] = tp[1], np[0] = tp[0], nn = 4;\n#endif\n#if LIMBS_PER_DOUBLE == 3\n      np = MPZ_NEWALLOC (NUM(dest), 3);\n      if ((tp[0] | tp[1]) == 0)\n\tnp[0] = tp[2], nn = 1;\n      else if (tp[0] == 0)\n\tnp[1] = tp[2], np[0] = tp[1], nn = 2;\n      else\n\tnp[2] = tp[2], np[1] = tp[1], np[0] = tp[0], nn = 3;\n#endif\n#if LIMBS_PER_DOUBLE == 2\n      np = MPZ_NEWALLOC (NUM(dest), 2);\n      if (tp[0] == 0)\n\tnp[0] = tp[1], nn = 1;\n      else\n\tnp[1] = tp[1], np[0] = tp[0], nn = 2;\n#endif\n      dn = nn + 1 - exp;\n      ASSERT (dn > 0); /* -exp >= -1; nn >= 1*/\n      dp = MPZ_NEWALLOC (DEN(dest), dn);\n      MPN_ZERO (dp, dn - 1);\n      dp[dn - 1] = 1;\n      count_trailing_zeros (c, np[0] | dp[0]);\n      if (c != 0)\n\t{\n\t  mpn_rshift (np, np, nn, c);\n\t  nn -= np[nn - 1] == 0;\n\t  --dn;\n\t  dp[dn - 1] = CNST_LIMB(1) << (GMP_LIMB_BITS - c);\n\t}\n      SIZ(DEN(dest)) = dn;\n    }\n  else\n    {\n      nn = exp;\n      np = MPZ_NEWALLOC (NUM(dest), nn);\n      switch (nn)\n        {\n\tdefault:\n\t  MPN_ZERO (np, nn - LIMBS_PER_DOUBLE);\n\t  np += nn - LIMBS_PER_DOUBLE;\n\t  /* fall through */\n#if LIMBS_PER_DOUBLE == 2\n\tcase 2:\n\t  np[1] = tp[1], np[0] = tp[0];\n\t  break;\n#endif\n#if LIMBS_PER_DOUBLE == 3\n\tcase 3:\n\t  np[2] = tp[2], np[1] = tp[1], np[0] = tp[0];\n\t  break;\n\tcase 2:\n\t  np[1] = tp[2], np[0] = tp[1];\n\t  break;\n#endif\n#if LIMBS_PER_DOUBLE == 4\n\tcase 4:\n\t  np[3] = tp[3], np[2] = tp[2], np[1] = tp[1], np[0] = tp[0];\n\t  break;\n\tcase 3:\n\t  np[2] = tp[3], np[1] = tp[2], np[0] = tp[1];\n\t  break;\n\tcase 2:\n\t  np[1] = tp[3], np[0] = tp[2];\n\t  break;\n#endif\n\t}\n      *PTR(DEN(dest)) = 1;\n      SIZ(DEN(dest)) = 1;\n    }\n  SIZ(NUM(dest)) = negative ? -nn : nn;\n}",
      "lines": 121,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/set_den.c": {
    "mpq_set_den": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nmpq_set_den (mpq_ptr dest, mpz_srcptr den)\n{\n  mp_size_t size = SIZ (den);\n  mp_size_t abs_size = ABS (size);\n  mp_ptr dp;\n\n  dp = MPZ_NEWALLOC (DEN(dest), abs_size);\n\n  SIZ(DEN(dest)) = size;\n  MPN_COPY (dp, PTR(den), abs_size);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/set_f.c": {
    "mpq_set_f": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nmpq_set_f (mpq_ptr q, mpf_srcptr f)\n{\n  mp_size_t  fexp = EXP(f);\n  mp_ptr     fptr = PTR(f);\n  mp_size_t  fsize = SIZ(f);\n  mp_size_t  abs_fsize = ABS(fsize);\n  mp_limb_t  flow;\n\n  if (fsize == 0)\n    {\n      /* set q=0 */\n      SIZ(NUM(q)) = 0;\n      SIZ(DEN(q)) = 1;\n      PTR(DEN(q))[0] = 1;\n      return;\n    }\n\n  /* strip low zero limbs from f */\n  flow = *fptr;\n  MPN_STRIP_LOW_ZEROS_NOT_ZERO (fptr, abs_fsize, flow);\n\n  if (fexp >= abs_fsize)\n    {\n      /* radix point is to the right of the limbs, no denominator */\n      mp_ptr  num_ptr;\n\n      num_ptr = MPZ_NEWALLOC (mpq_numref (q), fexp);\n      MPN_ZERO (num_ptr, fexp - abs_fsize);\n      MPN_COPY (num_ptr + fexp - abs_fsize, fptr, abs_fsize);\n\n      SIZ(NUM(q)) = fsize >= 0 ? fexp : -fexp;\n      SIZ(DEN(q)) = 1;\n      PTR(DEN(q))[0] = 1;\n    }\n  else\n    {\n      /* radix point is within or to the left of the limbs, use denominator */\n      mp_ptr     num_ptr, den_ptr;\n      mp_size_t  den_size;\n\n      den_size = abs_fsize - fexp;\n      num_ptr = MPZ_NEWALLOC (mpq_numref (q), abs_fsize);\n      den_ptr = MPZ_NEWALLOC (mpq_denref (q), den_size+1);\n\n      if (flow & 1)\n        {\n          /* no powers of two to strip from numerator */\n\n          MPN_COPY (num_ptr, fptr, abs_fsize);\n          MPN_ZERO (den_ptr, den_size);\n          den_ptr[den_size] = 1;\n        }\n      else\n        {\n          /* right shift numerator, adjust denominator accordingly */\n          int  shift;\n\n          den_size--;\n          count_trailing_zeros (shift, flow);\n\n          mpn_rshift (num_ptr, fptr, abs_fsize, shift);\n          abs_fsize -= (num_ptr[abs_fsize-1] == 0);\n\n          MPN_ZERO (den_ptr, den_size);\n          den_ptr[den_size] = GMP_LIMB_HIGHBIT >> (shift-1);\n        }\n\n      SIZ(NUM(q)) = fsize >= 0 ? abs_fsize : -abs_fsize;\n      SIZ(DEN(q)) = den_size + 1;\n    }\n}",
      "lines": 72,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/set_num.c": {
    "mpq_set_num": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nmpq_set_num (mpq_ptr dest, mpz_srcptr num)\n{\n  mp_size_t size = SIZ (num);\n  mp_size_t abs_size = ABS (size);\n  mp_ptr dp;\n\n  dp = MPZ_NEWALLOC (NUM(dest), abs_size);\n\n  SIZ(NUM(dest)) = size;\n  MPN_COPY (dp, PTR(num), abs_size);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/set_si.c": {
    "mpq_set_si": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\nmpq_set_si (mpq_t dest, signed long int num, unsigned long int den)\n{\n  unsigned long int abs_num;\n\n  if (GMP_NUMB_BITS < BITS_PER_ULONG)\n    {\n      if (num == 0)  /* Canonicalize 0/d to 0/1.  */\n        den = 1;\n      mpz_set_si (mpq_numref (dest), num);\n      mpz_set_ui (mpq_denref (dest), den);\n      return;\n    }\n\n  abs_num = ABS_CAST (unsigned long, num);\n\n  if (num == 0)\n    {\n      /* Canonicalize 0/d to 0/1.  */\n      den = 1;\n      SIZ(NUM(dest)) = 0;\n    }\n  else\n    {\n      PTR(NUM(dest))[0] = abs_num;\n      SIZ(NUM(dest)) = num > 0 ? 1 : -1;\n    }\n\n  PTR(DEN(dest))[0] = den;\n  SIZ(DEN(dest)) = (den != 0);\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/set_str.c": {
    "mpq_set_str": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nmpq_set_str (mpq_ptr q, const char *str, int base)\n{\n  const char  *slash;\n  char        *num;\n  size_t      numlen;\n  int         ret;\n\n  slash = strchr (str, '/');\n  if (slash == NULL)\n    {\n      SIZ(DEN(q)) = 1;\n      PTR(DEN(q))[0] = 1;\n\n      return mpz_set_str (mpq_numref(q), str, base);\n    }\n\n  numlen = slash - str;\n  num = __GMP_ALLOCATE_FUNC_TYPE (numlen+1, char);\n  memcpy (num, str, numlen);\n  num[numlen] = '\\0';\n  ret = mpz_set_str (mpq_numref(q), num, base);\n  (*__gmp_free_func) (num, numlen+1);\n\n  if (ret != 0)\n    return ret;\n\n  return mpz_set_str (mpq_denref(q), slash+1, base);\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/set_ui.c": {
    "mpq_set_ui": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\nmpq_set_ui (mpq_t dest, unsigned long int num, unsigned long int den)\n{\n  if (GMP_NUMB_BITS < BITS_PER_ULONG)\n    {\n      if (num == 0)  /* Canonicalize 0/d to 0/1.  */\n        den = 1;\n      mpz_set_ui (mpq_numref (dest), num);\n      mpz_set_ui (mpq_denref (dest), den);\n      return;\n    }\n\n  if (num == 0)\n    {\n      /* Canonicalize 0/n to 0/1.  */\n      den = 1;\n      SIZ(NUM(dest)) = 0;\n    }\n  else\n    {\n      PTR(NUM(dest))[0] = num;\n      SIZ(NUM(dest)) = 1;\n    }\n\n  PTR(DEN(dest))[0] = den;\n  SIZ(DEN(dest)) = (den != 0);\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/set_z.c": {
    "mpq_set_z": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nmpq_set_z (mpq_ptr dest, mpz_srcptr src)\n{\n  mp_size_t num_size;\n  mp_size_t abs_num_size;\n  mp_ptr dp;\n\n  num_size = SIZ (src);\n  abs_num_size = ABS (num_size);\n  dp = MPZ_NEWALLOC (NUM(dest), abs_num_size);\n  SIZ(NUM(dest)) = num_size;\n  MPN_COPY (dp, PTR(src), abs_num_size);\n\n  PTR(DEN(dest))[0] = 1;\n  SIZ(DEN(dest)) = 1;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpq/swap.c": {
    "mpq_swap": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\nmpq_swap (mpq_ptr u, mpq_ptr v) __GMP_NOTHROW\n{\n  mp_ptr up, vp;\n  mp_size_t usize, vsize;\n  mp_size_t ualloc, valloc;\n\n  ualloc = ALLOC(NUM(u));\n  valloc = ALLOC(NUM(v));\n  ALLOC(NUM(v)) = ualloc;\n  ALLOC(NUM(u)) = valloc;\n\n  usize = SIZ(NUM(u));\n  vsize = SIZ(NUM(v));\n  SIZ(NUM(v)) = usize;\n  SIZ(NUM(u)) = vsize;\n\n  up = PTR(NUM(u));\n  vp = PTR(NUM(v));\n  PTR(NUM(v)) = up;\n  PTR(NUM(u)) = vp;\n\n\n  ualloc = ALLOC(DEN(u));\n  valloc = ALLOC(DEN(v));\n  ALLOC(DEN(v)) = ualloc;\n  ALLOC(DEN(u)) = valloc;\n\n  usize = SIZ(DEN(u));\n  vsize = SIZ(DEN(v));\n  SIZ(DEN(v)) = usize;\n  SIZ(DEN(u)) = vsize;\n\n  up = PTR(DEN(u));\n  vp = PTR(DEN(v));\n  PTR(DEN(v)) = up;\n  PTR(DEN(u)) = vp;\n}",
      "lines": 38,
      "depth": 9,
      "decorators": [
        "void",
        "mpq_swap (mpq_ptr u, mpq_ptr v)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/2fac_ui.c": {
    "mpz_2fac_ui": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void\nmpz_2fac_ui (mpz_ptr x, unsigned long n)\n{\n  ASSERT (n <= GMP_NUMB_MAX);\n\n  if ((n & 1) == 0) { /* n is even, n = 2k, (2k)!! = k! 2^k */\n    mp_limb_t count;\n\n    if ((n <= TABLE_LIMIT_2N_MINUS_POPC_2N) & (n != 0))\n      count = __gmp_fac2cnt_table[n / 2 - 1];\n    else\n      {\n\tpopc_limb (count, n);\t/* popc(n) == popc(k) */\n\tcount = n - count;\t\t/* n - popc(n) == k + k - popc(k) */\n      }\n    mpz_oddfac_1 (x, n >> 1, 0);\n    mpz_mul_2exp (x, x, count);\n  } else { /* n is odd */\n    if (n <= ODD_DOUBLEFACTORIAL_TABLE_LIMIT) {\n\tPTR (x)[0] = __gmp_odd2fac_table[n >> 1];\n\tSIZ (x) = 1;\n    } else if (BELOW_THRESHOLD (n, FAC_2DSC_THRESHOLD)) { /* odd basecase, */\n      mp_limb_t *factors, prod, max_prod, j;\n      TMP_SDECL;\n\n      /* FIXME: we might alloc a fixed amount 1+FAC_2DSC_THRESHOLD/FACTORS_PER_LIMB */\n      TMP_SMARK;\n      factors = TMP_SALLOC_LIMBS (1 + n / (2 * FACTORS_PER_LIMB));\n\n      factors[0] = ODD_DOUBLEFACTORIAL_TABLE_MAX;\n      j = 1;\n      prod = n;\n\n      max_prod = GMP_NUMB_MAX / FAC_2DSC_THRESHOLD;\n      while ((n -= 2) > ODD_DOUBLEFACTORIAL_TABLE_LIMIT)\n\tFACTOR_LIST_STORE (n, prod, max_prod, factors, j);\n\n      factors[j++] = prod;\n      mpz_prodlimbs (x, factors, j);\n\n      TMP_SFREE;\n    } else { /* for the asymptotically fast odd case, let oddfac do the job. */\n      mpz_oddfac_1 (x, n, 1);\n    }\n  }\n}",
      "lines": 46,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/abs.c": {
    "mpz_abs": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\nmpz_abs (mpz_ptr w, mpz_srcptr u)\n{\n  mp_ptr wp;\n  mp_srcptr up;\n  mp_size_t size;\n\n  size = ABSIZ (u);\n\n  if (u != w)\n    {\n      wp = MPZ_NEWALLOC (w, size);\n\n      up = PTR (u);\n\n      MPN_COPY (wp, up, size);\n    }\n\n  SIZ (w) = size;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/add.c": {},
  "gmp/gmp-6.1.2/mpz/add_ui.c": {},
  "gmp/gmp-6.1.2/mpz/and.c": {
    "mpz_and": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\nmpz_and (mpz_ptr res, mpz_srcptr op1, mpz_srcptr op2)\n{\n  mp_srcptr op1_ptr, op2_ptr;\n  mp_size_t op1_size, op2_size;\n  mp_ptr res_ptr;\n  mp_size_t res_size;\n  mp_size_t i;\n  TMP_DECL;\n\n  TMP_MARK;\n  op1_size = SIZ(op1);\n  op2_size = SIZ(op2);\n\n  op1_ptr = PTR(op1);\n  op2_ptr = PTR(op2);\n\n  if (op1_size >= 0)\n    {\n      if (op2_size >= 0)\n\t{\n\t  res_size = MIN (op1_size, op2_size);\n\t  /* First loop finds the size of the result.  */\n\t  for (i = res_size - 1; i >= 0; i--)\n\t    if ((op1_ptr[i] & op2_ptr[i]) != 0)\n\t      break;\n\t  res_size = i + 1;\n\n\t  /* Handle allocation, now then we know exactly how much space is\n\t     needed for the result.  */\n\t  res_ptr = MPZ_REALLOC (res, res_size);\n\t  /* Don't re-read op1_ptr and op2_ptr.  Since res_size <=\n\t     MIN(op1_size, op2_size), res is not changed when op1\n\t     is identical to res or op2 is identical to res.  */\n\n\t  SIZ(res) = res_size;\n\t  if (LIKELY (res_size != 0))\n\t    mpn_and_n (res_ptr, op1_ptr, op2_ptr, res_size);\n\t  return;\n\t}\n      else /* op2_size < 0 */\n\t{\n\t  /* Fall through to the code at the end of the function.  */\n\t}\n    }\n  else\n    {\n      if (op2_size < 0)\n\t{\n\t  mp_ptr opx, opy;\n\t  mp_limb_t cy;\n\n\t  /* Both operands are negative, so will be the result.\n\t     -((-OP1) & (-OP2)) = -(~(OP1 - 1) & ~(OP2 - 1)) =\n\t     = ~(~(OP1 - 1) & ~(OP2 - 1)) + 1 =\n\t     = ((OP1 - 1) | (OP2 - 1)) + 1      */\n\n\t  /* It might seem as we could end up with an (invalid) result with\n\t     a leading zero-limb here when one of the operands is of the\n\t     type 1,,0,,..,,.0.  But some analysis shows that we surely\n\t     would get carry into the zero-limb in this situation...  */\n\n\t  op1_size = -op1_size;\n\t  op2_size = -op2_size;\n\n\t  if (op1_size > op2_size)\n\t    MPN_SRCPTR_SWAP (op1_ptr, op1_size, op2_ptr, op2_size);\n\n\t  TMP_ALLOC_LIMBS_2 (opx, op1_size, opy, op2_size);\n\t  mpn_sub_1 (opx, op1_ptr, op1_size, (mp_limb_t) 1);\n\t  op1_ptr = opx;\n\n\t  mpn_sub_1 (opy, op2_ptr, op2_size, (mp_limb_t) 1);\n\t  op2_ptr = opy;\n\n\t  res_ptr = MPZ_REALLOC (res, 1 + op2_size);\n\t  /* Don't re-read OP1_PTR and OP2_PTR.  They point to temporary\n\t     space--never to the space PTR(res) used to point to before\n\t     reallocation.  */\n\n\t  MPN_COPY (res_ptr + op1_size, op2_ptr + op1_size,\n\t\t    op2_size - op1_size);\n\t  mpn_ior_n (res_ptr, op1_ptr, op2_ptr, op1_size);\n\t  res_size = op2_size;\n\n\t  cy = mpn_add_1 (res_ptr, res_ptr, res_size, (mp_limb_t) 1);\n\t  res_ptr[res_size] = cy;\n\t  res_size += (cy != 0);\n\n\t  SIZ(res) = -res_size;\n\t  TMP_FREE;\n\t  return;\n\t}\n      else\n\t{\n\t  /* We should compute -OP1 & OP2.  Swap OP1 and OP2 and fall\n\t     through to the code that handles OP1 & -OP2.  */\n\t  MPN_SRCPTR_SWAP (op1_ptr, op1_size, op2_ptr, op2_size);\n\t}\n\n    }\n\n  {\n#if ANDNEW\n    mp_size_t op2_lim;\n    mp_size_t count;\n\n    /* OP2 must be negated as with infinite precision.\n\n       Scan from the low end for a non-zero limb.  The first non-zero\n       limb is simply negated (two's complement).  Any subsequent\n       limbs are one's complemented.  Of course, we don't need to\n       handle more limbs than there are limbs in the other, positive\n       operand as the result for those limbs is going to become zero\n       anyway.  */\n\n    /* Scan for the least significant non-zero OP2 limb, and zero the\n       result meanwhile for those limb positions.  (We will surely\n       find a non-zero limb, so we can write the loop with one\n       termination condition only.)  */\n    for (i = 0; op2_ptr[i] == 0; i++)\n      res_ptr[i] = 0;\n    op2_lim = i;\n\n    op2_size = -op2_size;\n\n    if (op1_size <= op2_size)\n      {\n\t/* The ones-extended OP2 is >= than the zero-extended OP1.\n\t   RES_SIZE <= OP1_SIZE.  Find the exact size.  */\n\tfor (i = op1_size - 1; i > op2_lim; i--)\n\t  if ((op1_ptr[i] & ~op2_ptr[i]) != 0)\n\t    break;\n\tres_size = i + 1;\n\tfor (i = res_size - 1; i > op2_lim; i--)\n\t  res_ptr[i] = op1_ptr[i] & ~op2_ptr[i];\n\tres_ptr[op2_lim] = op1_ptr[op2_lim] & -op2_ptr[op2_lim];\n\t/* Yes, this *can* happen!  */\n\tMPN_NORMALIZE (res_ptr, res_size);\n      }\n    else\n      {\n\t/* The ones-extended OP2 is < than the zero-extended OP1.\n\t   RES_SIZE == OP1_SIZE, since OP1 is normalized.  */\n\tres_size = op1_size;\n\tMPN_COPY (res_ptr + op2_size, op1_ptr + op2_size, op1_size - op2_size);\n\tfor (i = op2_size - 1; i > op2_lim; i--)\n\t  res_ptr[i] = op1_ptr[i] & ~op2_ptr[i];\n\tres_ptr[op2_lim] = op1_ptr[op2_lim] & -op2_ptr[op2_lim];\n      }\n\n    SIZ(res) = res_size;\n#else\n\n    /* OP1 is positive and zero-extended,\n       OP2 is negative and ones-extended.\n       The result will be positive.\n       OP1 & -OP2 = OP1 & ~(OP2 - 1).  */\n\n    mp_ptr opx;\n\n    op2_size = -op2_size;\n    opx = TMP_ALLOC_LIMBS (op2_size);\n    mpn_sub_1 (opx, op2_ptr, op2_size, (mp_limb_t) 1);\n    op2_ptr = opx;\n\n    if (op1_size > op2_size)\n      {\n\t/* The result has the same size as OP1, since OP1 is normalized\n\t   and longer than the ones-extended OP2.  */\n\tres_size = op1_size;\n\n\t/* Handle allocation, now then we know exactly how much space is\n\t   needed for the result.  */\n\tres_ptr = MPZ_REALLOC (res, res_size);\n\t/* Don't re-read OP1_PTR or OP2_PTR.  Since res_size = op1_size,\n\t   op1 is not changed if it is identical to res.\n\t   OP2_PTR points to temporary space.  */\n\n\tMPN_COPY (res_ptr + op2_size, op1_ptr + op2_size, res_size - op2_size);\n\tmpn_andn_n (res_ptr, op1_ptr, op2_ptr, op2_size);\n\n\tSIZ(res) = res_size;\n      }\n    else\n      {\n\t/* Find out the exact result size.  Ignore the high limbs of OP2,\n\t   OP1 is zero-extended and would make the result zero.  */\n\tfor (i = op1_size - 1; i >= 0; i--)\n\t  if ((op1_ptr[i] & ~op2_ptr[i]) != 0)\n\t    break;\n\tres_size = i + 1;\n\n\t/* Handle allocation, now then we know exactly how much space is\n\t   needed for the result.  */\n\tres_ptr = MPZ_REALLOC (res, res_size);\n\t/* Don't re-read OP1_PTR.  Since res_size <= op1_size,\n\t   op1 is not changed if it is identical to res.\n\t   Don't re-read OP2_PTR.  It points to temporary space--never\n\t   to the space PTR(res) used to point to before reallocation.  */\n\n\tif (LIKELY (res_size != 0))\n\t  mpn_andn_n (res_ptr, op1_ptr, op2_ptr, res_size);\n\n\tSIZ(res) = res_size;\n      }\n#endif\n  }\n  TMP_FREE;\n}",
      "lines": 210,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/aors.h": {
    "FUNCTION": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\nFUNCTION (mpz_ptr w, mpz_srcptr u, mpz_srcptr v)\n{\n  mp_srcptr up, vp;\n  mp_ptr wp;\n  mp_size_t usize, vsize, wsize;\n  mp_size_t abs_usize;\n  mp_size_t abs_vsize;\n\n  usize = SIZ(u);\n  vsize = VARIATION SIZ(v);\n  abs_usize = ABS (usize);\n  abs_vsize = ABS (vsize);\n\n  if (abs_usize < abs_vsize)\n    {\n      /* Swap U and V. */\n      MPZ_SRCPTR_SWAP (u, v);\n      MP_SIZE_T_SWAP (usize, vsize);\n      MP_SIZE_T_SWAP (abs_usize, abs_vsize);\n    }\n\n  /* True: ABS_USIZE >= ABS_VSIZE.  */\n\n  /* If not space for w (and possible carry), increase space.  */\n  wsize = abs_usize + 1;\n  wp = MPZ_REALLOC (w, wsize);\n\n  /* These must be after realloc (u or v may be the same as w).  */\n  up = PTR(u);\n  vp = PTR(v);\n\n  if ((usize ^ vsize) < 0)\n    {\n      /* U and V have different sign.  Need to compare them to determine\n\t which operand to subtract from which.  */\n\n      /* This test is right since ABS_USIZE >= ABS_VSIZE.  */\n      if (abs_usize != abs_vsize)\n\t{\n\t  mpn_sub (wp, up, abs_usize, vp, abs_vsize);\n\t  wsize = abs_usize;\n\t  MPN_NORMALIZE (wp, wsize);\n\t  if (usize < 0)\n\t    wsize = -wsize;\n\t}\n      else if (mpn_cmp (up, vp, abs_usize) < 0)\n\t{\n\t  mpn_sub_n (wp, vp, up, abs_usize);\n\t  wsize = abs_usize;\n\t  MPN_NORMALIZE (wp, wsize);\n\t  if (usize >= 0)\n\t    wsize = -wsize;\n\t}\n      else\n\t{\n\t  mpn_sub_n (wp, up, vp, abs_usize);\n\t  wsize = abs_usize;\n\t  MPN_NORMALIZE (wp, wsize);\n\t  if (usize < 0)\n\t    wsize = -wsize;\n\t}\n    }\n  else\n    {\n      /* U and V have same sign.  Add them.  */\n      mp_limb_t cy_limb = mpn_add (wp, up, abs_usize, vp, abs_vsize);\n      wp[abs_usize] = cy_limb;\n      wsize = abs_usize + cy_limb;\n      if (usize < 0)\n\twsize = -wsize;\n    }\n\n  SIZ(w) = wsize;\n}",
      "lines": 75,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/aorsmul.c": {
    "mpz_aorsmul": {
      "start_point": [
        50,
        17
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static void\nmpz_aorsmul (mpz_ptr w, mpz_srcptr x, mpz_srcptr y, mp_size_t sub)\n{\n  mp_size_t  xsize, ysize, tsize, wsize, wsize_signed;\n  mp_ptr     wp, tp;\n  mp_limb_t  c, high;\n  TMP_DECL;\n\n  /* w unaffected if x==0 or y==0 */\n  xsize = SIZ(x);\n  ysize = SIZ(y);\n  if (xsize == 0 || ysize == 0)\n    return;\n\n  /* make x the bigger of the two */\n  if (ABS(ysize) > ABS(xsize))\n    {\n      MPZ_SRCPTR_SWAP (x, y);\n      MP_SIZE_T_SWAP (xsize, ysize);\n    }\n\n  sub ^= ysize;\n  ysize = ABS(ysize);\n\n  /* use mpn_addmul_1/mpn_submul_1 if possible */\n  if (ysize == 1)\n    {\n      mpz_aorsmul_1 (w, x, PTR(y)[0], sub);\n      return;\n    }\n\n  sub ^= xsize;\n  xsize = ABS(xsize);\n\n  wsize_signed = SIZ(w);\n  sub ^= wsize_signed;\n  wsize = ABS(wsize_signed);\n\n  tsize = xsize + ysize;\n  wp = MPZ_REALLOC (w, MAX (wsize, tsize) + 1);\n\n  if (wsize_signed == 0)\n    {\n      /* Nothing to add to, just set w=x*y.  No w==x or w==y overlap here,\n\t since we know x,y!=0 but w==0.  */\n      high = mpn_mul (wp, PTR(x),xsize, PTR(y),ysize);\n      tsize -= (high == 0);\n      SIZ(w) = (sub >= 0 ? tsize : -tsize);\n      return;\n    }\n\n  TMP_MARK;\n  tp = TMP_ALLOC_LIMBS (tsize);\n\n  high = mpn_mul (tp, PTR(x),xsize, PTR(y),ysize);\n  tsize -= (high == 0);\n  ASSERT (tp[tsize-1] != 0);\n  if (sub >= 0)\n    {\n      mp_srcptr up    = wp;\n      mp_size_t usize = wsize;\n\n      if (usize < tsize)\n\t{\n\t  up\t= tp;\n\t  usize = tsize;\n\t  tp\t= wp;\n\t  tsize = wsize;\n\n\t  wsize = usize;\n\t}\n\n      c = mpn_add (wp, up,usize, tp,tsize);\n      wp[wsize] = c;\n      wsize += (c != 0);\n    }\n  else\n    {\n      mp_srcptr up    = wp;\n      mp_size_t usize = wsize;\n\n      if (mpn_cmp_twosizes_lt (up,usize, tp,tsize))\n\t{\n\t  up\t= tp;\n\t  usize = tsize;\n\t  tp\t= wp;\n\t  tsize = wsize;\n\n\t  wsize = usize;\n\t  wsize_signed = -wsize_signed;\n\t}\n\n      ASSERT_NOCARRY (mpn_sub (wp, up,usize, tp,tsize));\n      wsize = usize;\n      MPN_NORMALIZE (wp, wsize);\n    }\n\n  SIZ(w) = (wsize_signed >= 0 ? wsize : -wsize);\n\n  TMP_FREE;\n}",
      "lines": 101,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_addmul": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void\nmpz_addmul (mpz_ptr w, mpz_srcptr u, mpz_srcptr v)\n{\n  mpz_aorsmul (w, u, v, (mp_size_t) 0);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_submul": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "void\nmpz_submul (mpz_ptr w, mpz_srcptr u, mpz_srcptr v)\n{\n  mpz_aorsmul (w, u, v, (mp_size_t) -1);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/aorsmul_i.c": {
    "mpz_aorsmul_1": {
      "start_point": [
        68,
        16
      ],
      "end_point": [
        197,
        1
      ],
      "content": "void\nmpz_aorsmul_1 (mpz_ptr w, mpz_srcptr x, mp_limb_t y, mp_size_t sub)\n{\n  mp_size_t  xsize, wsize, wsize_signed, new_wsize, min_size, dsize;\n  mp_srcptr  xp;\n  mp_ptr     wp;\n  mp_limb_t  cy;\n\n  /* w unaffected if x==0 or y==0 */\n  xsize = SIZ (x);\n  if (xsize == 0 || y == 0)\n    return;\n\n  sub ^= xsize;\n  xsize = ABS (xsize);\n\n  wsize_signed = SIZ (w);\n  if (wsize_signed == 0)\n    {\n      /* nothing to add to, just set x*y, \"sub\" gives the sign */\n      wp = MPZ_REALLOC (w, xsize+1);\n      cy = mpn_mul_1 (wp, PTR(x), xsize, y);\n      wp[xsize] = cy;\n      xsize += (cy != 0);\n      SIZ (w) = (sub >= 0 ? xsize : -xsize);\n      return;\n    }\n\n  sub ^= wsize_signed;\n  wsize = ABS (wsize_signed);\n\n  new_wsize = MAX (wsize, xsize);\n  wp = MPZ_REALLOC (w, new_wsize+1);\n  xp = PTR (x);\n  min_size = MIN (wsize, xsize);\n\n  if (sub >= 0)\n    {\n      /* addmul of absolute values */\n\n      cy = mpn_addmul_1 (wp, xp, min_size, y);\n      wp += min_size;\n      xp += min_size;\n\n      dsize = xsize - wsize;\n#if HAVE_NATIVE_mpn_mul_1c\n      if (dsize > 0)\n\tcy = mpn_mul_1c (wp, xp, dsize, y, cy);\n      else if (dsize < 0)\n\t{\n\t  dsize = -dsize;\n\t  cy = mpn_add_1 (wp, wp, dsize, cy);\n\t}\n#else\n      if (dsize != 0)\n\t{\n\t  mp_limb_t  cy2;\n\t  if (dsize > 0)\n\t    cy2 = mpn_mul_1 (wp, xp, dsize, y);\n\t  else\n\t    {\n\t      dsize = -dsize;\n\t      cy2 = 0;\n\t    }\n\t  cy = cy2 + mpn_add_1 (wp, wp, dsize, cy);\n\t}\n#endif\n\n      wp[dsize] = cy;\n      new_wsize += (cy != 0);\n    }\n  else\n    {\n      /* submul of absolute values */\n\n      cy = mpn_submul_1 (wp, xp, min_size, y);\n      if (wsize >= xsize)\n\t{\n\t  /* if w bigger than x, then propagate borrow through it */\n\t  if (wsize != xsize)\n\t    cy = mpn_sub_1 (wp+xsize, wp+xsize, wsize-xsize, cy);\n\n\t  if (cy != 0)\n\t    {\n\t      /* Borrow out of w, take twos complement negative to get\n\t\t absolute value, flip sign of w.  */\n\t      wp[new_wsize] = ~-cy;  /* extra limb is 0-cy */\n\t      mpn_com (wp, wp, new_wsize);\n\t      new_wsize++;\n\t      MPN_INCR_U (wp, new_wsize, CNST_LIMB(1));\n\t      wsize_signed = -wsize_signed;\n\t    }\n\t}\n      else /* wsize < xsize */\n\t{\n\t  /* x bigger than w, so want x*y-w.  Submul has given w-x*y, so\n\t     take twos complement and use an mpn_mul_1 for the rest.  */\n\n\t  mp_limb_t  cy2;\n\n\t  /* -(-cy*b^n + w-x*y) = (cy-1)*b^n + ~(w-x*y) + 1 */\n\t  mpn_com (wp, wp, wsize);\n\t  cy += mpn_add_1 (wp, wp, wsize, CNST_LIMB(1));\n\t  cy -= 1;\n\n\t  /* If cy-1 == -1 then hold that -1 for latter.  mpn_submul_1 never\n\t     returns cy==MP_LIMB_T_MAX so that value always indicates a -1. */\n\t  cy2 = (cy == MP_LIMB_T_MAX);\n\t  cy += cy2;\n\t  MPN_MUL_1C (cy, wp+wsize, xp+wsize, xsize-wsize, y, cy);\n\t  wp[new_wsize] = cy;\n\t  new_wsize += (cy != 0);\n\n\t  /* Apply any -1 from above.  The value at wp+wsize is non-zero\n\t     because y!=0 and the high limb of x will be non-zero.  */\n\t  if (cy2)\n\t    MPN_DECR_U (wp+wsize, new_wsize-wsize, CNST_LIMB(1));\n\n\t  wsize_signed = -wsize_signed;\n\t}\n\n      /* submul can produce high zero limbs due to cancellation, both when w\n\t has more limbs or x has more  */\n      MPN_NORMALIZE (wp, new_wsize);\n    }\n\n  SIZ (w) = (wsize_signed >= 0 ? new_wsize : -new_wsize);\n\n  ASSERT (new_wsize == 0 || PTR(w)[new_wsize-1] != 0);\n}",
      "lines": 130,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "mpz_addmul_ui": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "void\nmpz_addmul_ui (mpz_ptr w, mpz_srcptr x, unsigned long y)\n{\n#if BITS_PER_ULONG > GMP_NUMB_BITS\n  if (UNLIKELY (y > GMP_NUMB_MAX))\n    {\n      mpz_t t;\n      mp_ptr tp;\n      mp_size_t xn;\n      TMP_DECL;\n      TMP_MARK;\n      xn = SIZ (x);\n      if (xn == 0) return;\n      MPZ_TMP_INIT (t, ABS (xn) + 1);\n      tp = PTR (t);\n      tp[0] = 0;\n      MPN_COPY (tp + 1, PTR(x), ABS (xn));\n      SIZ(t) = xn >= 0 ? xn + 1 : xn - 1;\n      mpz_aorsmul_1 (w, t, (mp_limb_t) y >> GMP_NUMB_BITS, (mp_size_t) 0);\n      PTR(t) = tp + 1;\n      SIZ(t) = xn;\n      mpz_aorsmul_1 (w, t, (mp_limb_t) y & GMP_NUMB_MASK, (mp_size_t) 0);\n      TMP_FREE;\n      return;\n    }\n#endif\n  mpz_aorsmul_1 (w, x, (mp_limb_t) y, (mp_size_t) 0);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpz_submul_ui": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "void\nmpz_submul_ui (mpz_ptr w, mpz_srcptr x, unsigned long y)\n{\n#if BITS_PER_ULONG > GMP_NUMB_BITS\n  if (y > GMP_NUMB_MAX)\n    {\n      mpz_t t;\n      mp_ptr tp;\n      mp_size_t xn;\n      TMP_DECL;\n      TMP_MARK;\n      xn = SIZ (x);\n      if (xn == 0) return;\n      MPZ_TMP_INIT (t, ABS (xn) + 1);\n      tp = PTR (t);\n      tp[0] = 0;\n      MPN_COPY (tp + 1, PTR(x), ABS (xn));\n      SIZ(t) = xn >= 0 ? xn + 1 : xn - 1;\n      mpz_aorsmul_1 (w, t, (mp_limb_t) y >> GMP_NUMB_BITS, (mp_size_t) -1);\n      PTR(t) = tp + 1;\n      SIZ(t) = xn;\n      mpz_aorsmul_1 (w, t, (mp_limb_t) y & GMP_NUMB_MASK, (mp_size_t) -1);\n      TMP_FREE;\n      return;\n    }\n#endif\n  mpz_aorsmul_1 (w, x, (mp_limb_t) y & GMP_NUMB_MASK, (mp_size_t) -1);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/aors_ui.h": {
    "FUNCTION": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "void\nFUNCTION (mpz_ptr w, mpz_srcptr u, unsigned long int vval)\n{\n  mp_srcptr up;\n  mp_ptr wp;\n  mp_size_t usize, wsize;\n  mp_size_t abs_usize;\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (vval > GMP_NUMB_MAX)\n    {\n      mpz_t v;\n      mp_limb_t vl[2];\n      PTR(v) = vl;\n      vl[0] = vval & GMP_NUMB_MASK;\n      vl[1] = vval >> GMP_NUMB_BITS;\n      SIZ(v) = 2;\n      FUNCTION2 (w, u, v);\n      return;\n    }\n#endif\n\n  usize = SIZ (u);\n  if (usize == 0)\n    {\n      PTR (w)[0] = vval;\n      SIZ (w) = VARIATION_NEG (vval != 0);\n      return;\n    }\n\n  abs_usize = ABS (usize);\n\n  /* If not space for W (and possible carry), increase space.  */\n  wp = MPZ_REALLOC (w, abs_usize + 1);\n\n  /* These must be after realloc (U may be the same as W).  */\n  up = PTR (u);\n\n  if (usize VARIATION_CMP 0)\n    {\n      mp_limb_t cy;\n      cy = mpn_add_1 (wp, up, abs_usize, (mp_limb_t) vval);\n      wp[abs_usize] = cy;\n      wsize = VARIATION_NEG (abs_usize + cy);\n    }\n  else\n    {\n      /* The signs are different.  Need exact comparison to determine\n\t which operand to subtract from which.  */\n      if (abs_usize == 1 && up[0] < vval)\n\t{\n\t  wp[0] = vval - up[0];\n\t  wsize = VARIATION_NEG 1;\n\t}\n      else\n\t{\n\t  mpn_sub_1 (wp, up, abs_usize, (mp_limb_t) vval);\n\t  /* Size can decrease with at most one limb.  */\n\t  wsize = VARIATION_UNNEG (abs_usize - (wp[abs_usize - 1] == 0));\n\t}\n    }\n\n  SIZ (w) = wsize;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/array_init.c": {
    "mpz_array_init": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "void\nmpz_array_init (mpz_ptr arr, mp_size_t arr_size, mp_size_t nbits)\n{\n  mp_ptr p;\n  mp_size_t i;\n  mp_size_t nlimbs;\n\n  nlimbs = nbits / GMP_NUMB_BITS + 1;\n  p = __GMP_ALLOCATE_FUNC_LIMBS (arr_size * nlimbs);\n\n  for (i = 0; i < arr_size; i++)\n    {\n      ALLOC (&arr[i]) = nlimbs + 1; /* Yes, lie a little... */\n      SIZ (&arr[i]) = 0;\n      PTR (&arr[i]) = p + i * nlimbs;\n    }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/bin_ui.c": {
    "mpz_bin_ui": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "void\nmpz_bin_ui (mpz_ptr r, mpz_srcptr n, unsigned long int k)\n{\n  mpz_t      ni;\n  mp_limb_t  i;\n  mpz_t      nacc;\n  mp_limb_t  kacc;\n  mp_size_t  negate;\n\n  if (SIZ (n) < 0)\n    {\n      /* bin(n,k) = (-1)^k * bin(-n+k-1,k), and set ni = -n+k-1 - k = -n-1 */\n      mpz_init (ni);\n      mpz_add_ui (ni, n, 1L);\n      mpz_neg (ni, ni);\n      negate = (k & 1);   /* (-1)^k */\n    }\n  else\n    {\n      /* bin(n,k) == 0 if k>n\n\t (no test for this under the n<0 case, since -n+k-1 >= k there) */\n      if (mpz_cmp_ui (n, k) < 0)\n\t{\n\t  SIZ (r) = 0;\n\t  return;\n\t}\n\n      /* set ni = n-k */\n      mpz_init (ni);\n      mpz_sub_ui (ni, n, k);\n      negate = 0;\n    }\n\n  /* Now wanting bin(ni+k,k), with ni positive, and \"negate\" is the sign (0\n     for positive, 1 for negative). */\n  SIZ (r) = 1; PTR (r)[0] = 1;\n\n  /* Rewrite bin(n,k) as bin(n,n-k) if that is smaller.  In this case it's\n     whether ni+k-k < k meaning ni<k, and if so change to denominator ni+k-k\n     = ni, and new ni of ni+k-ni = k.  */\n  if (mpz_cmp_ui (ni, k) < 0)\n    {\n      unsigned long  tmp;\n      tmp = k;\n      k = mpz_get_ui (ni);\n      mpz_set_ui (ni, tmp);\n    }\n\n  kacc = 1;\n  mpz_init_set_ui (nacc, 1L);\n\n  for (i = 1; i <= k; i++)\n    {\n      mp_limb_t k1, k0;\n\n#if 0\n      mp_limb_t nacclow;\n      int c;\n\n      nacclow = PTR(nacc)[0];\n      for (c = 0; (((kacc | nacclow) & 1) == 0); c++)\n\t{\n\t  kacc >>= 1;\n\t  nacclow >>= 1;\n\t}\n      mpz_div_2exp (nacc, nacc, c);\n#endif\n\n      mpz_add_ui (ni, ni, 1L);\n      mpz_mul (nacc, nacc, ni);\n      umul_ppmm (k1, k0, kacc, i << GMP_NAIL_BITS);\n      if (k1 != 0)\n\t{\n\t  /* Accumulator overflow.  Perform bignum step.  */\n\t  mpz_mul (r, r, nacc);\n\t  SIZ (nacc) = 1; PTR (nacc)[0] = 1;\n\t  DIVIDE ();\n\t  kacc = i;\n\t}\n      else\n\t{\n\t  /* Save new products in accumulators to keep accumulating.  */\n\t  kacc = k0 >> GMP_NAIL_BITS;\n\t}\n    }\n\n  mpz_mul (r, r, nacc);\n  DIVIDE ();\n  SIZ(r) = (SIZ(r) ^ -negate) + negate;\n\n  mpz_clear (nacc);\n  mpz_clear (ni);\n}",
      "lines": 93,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/bin_uiui.c": {
    "mul1": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static mp_limb_t\nmul1 (mp_limb_t m)\n{\n  return m;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mul2": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static mp_limb_t\nmul2 (mp_limb_t m)\n{\n  /* We need to shift before multiplying, to avoid an overflow. */\n  mp_limb_t m01 = (m | 1) * ((m + 1) >> 1);\n  return m01;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mul3": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static mp_limb_t\nmul3 (mp_limb_t m)\n{\n  mp_limb_t m01 = (m + 0) * (m + 1) >> 1;\n  mp_limb_t m2 = (m + 2);\n  return m01 * m2;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mul4": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static mp_limb_t\nmul4 (mp_limb_t m)\n{\n  mp_limb_t m01 = (m + 0) * (m + 1) >> 1;\n  mp_limb_t m23 = (m + 2) * (m + 3) >> 1;\n  return m01 * m23;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mul5": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static mp_limb_t\nmul5 (mp_limb_t m)\n{\n  mp_limb_t m012 = (m + 0) * (m + 1) * (m + 2) >> 1;\n  mp_limb_t m34 = (m + 3) * (m + 4) >> 1;\n  return m012 * m34;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mul6": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static mp_limb_t\nmul6 (mp_limb_t m)\n{\n  mp_limb_t m01 = (m + 0) * (m + 1);\n  mp_limb_t m23 = (m + 2) * (m + 3);\n  mp_limb_t m45 = (m + 4) * (m + 5) >> 1;\n  mp_limb_t m0123 = m01 * m23 >> 3;\n  return m0123 * m45;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mul7": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static mp_limb_t\nmul7 (mp_limb_t m)\n{\n  mp_limb_t m01 = (m + 0) * (m + 1);\n  mp_limb_t m23 = (m + 2) * (m + 3);\n  mp_limb_t m456 = (m + 4) * (m + 5) * (m + 6) >> 1;\n  mp_limb_t m0123 = m01 * m23 >> 3;\n  return m0123 * m456;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mul8": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static mp_limb_t\nmul8 (mp_limb_t m)\n{\n  mp_limb_t m01 = (m + 0) * (m + 1);\n  mp_limb_t m23 = (m + 2) * (m + 3);\n  mp_limb_t m45 = (m + 4) * (m + 5);\n  mp_limb_t m67 = (m + 6) * (m + 7);\n  mp_limb_t m0123 = m01 * m23 >> 3;\n  mp_limb_t m4567 = m45 * m67 >> 3;\n  return m0123 * m4567;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpz_bdiv_bin_uiui": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static void\nmpz_bdiv_bin_uiui (mpz_ptr r, unsigned long int n, unsigned long int k)\n{\n  int nmax, kmax, nmaxnow, numfac;\n  mp_ptr np, kp;\n  mp_size_t nn, kn, alloc;\n  mp_limb_t i, j, t, iii, jjj, cy, dinv;\n  mp_bitcnt_t i2cnt, j2cnt;\n  int cnt;\n  mp_size_t maxn;\n  TMP_DECL;\n\n  ASSERT (k > ODD_FACTORIAL_TABLE_LIMIT);\n  TMP_MARK;\n\n  maxn = 1 + n / GMP_NUMB_BITS;    /* absolutely largest result size (limbs) */\n\n  /* FIXME: This allocation might be insufficient, but is usually way too\n     large.  */\n  alloc = SOME_THRESHOLD - 1 + MAX (3 * maxn / 2, SOME_THRESHOLD);\n  alloc = MIN (alloc, k) + 1;\n  np = TMP_ALLOC_LIMBS (alloc);\n  kp = TMP_ALLOC_LIMBS (SOME_THRESHOLD + 1);\n\n  MAXFACS (nmax, n);\n  ASSERT (nmax <= M);\n  MAXFACS (kmax, k);\n  ASSERT (kmax <= M);\n  ASSERT (k >= M);\n\n  i = n - k + 1;\n\n  np[0] = 1; nn = 1;\n\n  i2cnt = 0;\t\t\t\t/* total low zeros in dividend */\n  j2cnt = __gmp_fac2cnt_table[ODD_FACTORIAL_TABLE_LIMIT / 2 - 1];\n\t\t\t\t\t/* total low zeros in divisor */\n\n  numfac = 1;\n  j = ODD_FACTORIAL_TABLE_LIMIT + 1;\n  jjj = ODD_FACTORIAL_TABLE_MAX;\n  ASSERT (__gmp_oddfac_table[ODD_FACTORIAL_TABLE_LIMIT] == ODD_FACTORIAL_TABLE_MAX);\n\n  while (1)\n    {\n      kp[0] = jjj;\t\t\t\t/* store new factors */\n      kn = 1;\n      t = k - j + 1;\n      kmax = MIN (kmax, t);\n\n      while (kmax != 0 && kn < SOME_THRESHOLD)\n\t{\n\t  jjj = mulfunc[kmax - 1] (j);\n\t  j += kmax;\t\t\t\t/* number of factors used */\n\t  count_trailing_zeros (cnt, jjj);\t/* count low zeros */\n\t  jjj >>= cnt;\t\t\t\t/* remove remaining low zeros */\n\t  j2cnt += tcnttab[kmax - 1] + cnt;\t/* update low zeros count */\n\t  cy = mpn_mul_1 (kp, kp, kn, jjj);\t/* accumulate new factors */\n\t  kp[kn] = cy;\n\t  kn += cy != 0;\n\t  t = k - j + 1;\n\t  kmax = MIN (kmax, t);\n\t}\n      numfac = j - numfac;\n\n      while (numfac != 0)\n\t{\n\t  nmaxnow = MIN (nmax, numfac);\n\t  iii = mulfunc[nmaxnow - 1] (i);\n\t  i += nmaxnow;\t\t\t\t/* number of factors used */\n\t  count_trailing_zeros (cnt, iii);\t/* count low zeros */\n\t  iii >>= cnt;\t\t\t\t/* remove remaining low zeros */\n\t  i2cnt += tcnttab[nmaxnow - 1] + cnt;\t/* update low zeros count */\n\t  cy = mpn_mul_1 (np, np, nn, iii);\t/* accumulate new factors */\n\t  np[nn] = cy;\n\t  nn += cy != 0;\n\t  numfac -= nmaxnow;\n\t}\n\n      ASSERT (nn < alloc);\n\n      binvert_limb (dinv, kp[0]);\n      nn += (np[nn - 1] >= kp[kn - 1]);\n      nn -= kn;\n      mpn_sbpi1_bdiv_q (np, np, nn, kp, MIN(kn,nn), -dinv);\n\n      if (kmax == 0)\n\tbreak;\n      numfac = j;\n\n      jjj = mulfunc[kmax - 1] (j);\n      j += kmax;\t\t\t\t/* number of factors used */\n      count_trailing_zeros (cnt, jjj);\t\t/* count low zeros */\n      jjj >>= cnt;\t\t\t\t/* remove remaining low zeros */\n      j2cnt += tcnttab[kmax - 1] + cnt;\t\t/* update low zeros count */\n    }\n\n  /* Put back the right number of factors of 2.  */\n  cnt = i2cnt - j2cnt;\n  if (cnt != 0)\n    {\n      ASSERT (cnt < GMP_NUMB_BITS); /* can happen, but not for intended use */\n      cy = mpn_lshift (np, np, nn, cnt);\n      np[nn] = cy;\n      nn += cy != 0;\n    }\n\n  nn -= np[nn - 1] == 0;\t/* normalisation */\n\n  kp = MPZ_NEWALLOC (r, nn);\n  SIZ(r) = nn;\n  MPN_COPY (kp, np, nn);\n  TMP_FREE;\n}",
      "lines": 114,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_smallk_bin_uiui": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "static void\nmpz_smallk_bin_uiui (mpz_ptr r, unsigned long int n, unsigned long int k)\n{\n  int nmax, numfac;\n  mp_ptr rp;\n  mp_size_t rn, alloc;\n  mp_limb_t i, iii, cy;\n  mp_bitcnt_t i2cnt, cnt;\n\n  count_leading_zeros (cnt, (mp_limb_t) n);\n  cnt = GMP_LIMB_BITS - cnt;\n  alloc = cnt * k / GMP_NUMB_BITS + 3;\t/* FIXME: ensure rounding is enough. */\n  rp = MPZ_NEWALLOC (r, alloc);\n\n  MAXFACS (nmax, n);\n  nmax = MIN (nmax, M);\n\n  i = n - k + 1;\n\n  nmax = MIN (nmax, k);\n  rp[0] = mulfunc[nmax - 1] (i);\n  rn = 1;\n  i += nmax;\t\t\t\t/* number of factors used */\n  i2cnt = tcnttab[nmax - 1];\t\t/* low zeros count */\n  numfac = k - nmax;\n  while (numfac != 0)\n    {\n      nmax = MIN (nmax, numfac);\n      iii = mulfunc[nmax - 1] (i);\n      i += nmax;\t\t\t/* number of factors used */\n      i2cnt += tcnttab[nmax - 1];\t/* update low zeros count */\n      cy = mpn_mul_1 (rp, rp, rn, iii);\t/* accumulate new factors */\n      rp[rn] = cy;\n      rn += cy != 0;\n      numfac -= nmax;\n    }\n\n  ASSERT (rn < alloc);\n\n  mpn_pi1_bdiv_q_1 (rp, rp, rn, __gmp_oddfac_table[k], facinv[k - 2],\n\t\t    __gmp_fac2cnt_table[k / 2 - 1] - i2cnt);\n  /* A two-fold, branch-free normalisation is possible :*/\n  /* rn -= rp[rn - 1] == 0; */\n  /* rn -= rp[rn - 1] == 0; */\n  MPN_NORMALIZE_NOT_ZERO (rp, rn);\n\n  SIZ(r) = rn;\n}",
      "lines": 48,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bc_bin_uiui": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "static mp_limb_t\nbc_bin_uiui (unsigned int n, unsigned int k)\n{\n  return ((__gmp_oddfac_table[n] * facinv[k - 2] * facinv[n - k - 2])\n    << (__gmp_fac2cnt_table[n / 2 - 1] - __gmp_fac2cnt_table[k / 2 - 1] - __gmp_fac2cnt_table[(n-k) / 2 - 1]))\n    & GMP_NUMB_MASK;\n}",
      "lines": 7,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpz_smallkdc_bin_uiui": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "static void\nmpz_smallkdc_bin_uiui (mpz_ptr r, unsigned long int n, unsigned long int k)\n{\n  mp_ptr rp;\n  mp_size_t rn;\n  unsigned long int hk;\n\n  hk = k >> 1;\n\n  if ((! BIN_UIUI_RECURSIVE_SMALLDC) || hk <= ODD_FACTORIAL_TABLE_LIMIT)\n    mpz_smallk_bin_uiui (r, n, hk);\n  else\n    mpz_smallkdc_bin_uiui (r, n, hk);\n  k -= hk;\n  n -= hk;\n  if (n <= ODD_FACTORIAL_EXTTABLE_LIMIT) {\n    mp_limb_t cy;\n    rn = SIZ (r);\n    rp = MPZ_REALLOC (r, rn + 1);\n    cy = mpn_mul_1 (rp, rp, rn, bc_bin_uiui (n, k));\n    rp [rn] = cy;\n    rn += cy != 0;\n  } else {\n    mp_limb_t buffer[ODD_CENTRAL_BINOMIAL_TABLE_LIMIT + 3];\n    mpz_t t;\n\n    ALLOC (t) = ODD_CENTRAL_BINOMIAL_TABLE_LIMIT + 3;\n    PTR (t) = buffer;\n    if ((! BIN_UIUI_RECURSIVE_SMALLDC) || k <= ODD_FACTORIAL_TABLE_LIMIT)\n      mpz_smallk_bin_uiui (t, n, k);\n    else\n      mpz_smallkdc_bin_uiui (t, n, k);\n    mpz_mul (r, r, t);\n    rp = PTR (r);\n    rn = SIZ (r);\n  }\n\n  mpn_pi1_bdiv_q_1 (rp, rp, rn, bin2kk[k - ODD_CENTRAL_BINOMIAL_OFFSET],\n\t\t    bin2kkinv[k - ODD_CENTRAL_BINOMIAL_OFFSET],\n\t\t    fac2bin[k - ODD_CENTRAL_BINOMIAL_OFFSET] - (k != hk));\n  /* A two-fold, branch-free normalisation is possible :*/\n  /* rn -= rp[rn - 1] == 0; */\n  /* rn -= rp[rn - 1] == 0; */\n  MPN_NORMALIZE_NOT_ZERO (rp, rn);\n\n  SIZ(r) = rn;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bit_to_n": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        516,
        48
      ],
      "content": "static mp_limb_t\nbit_to_n (mp_limb_t bit) { return (bit*3+4)|1; }",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "id_to_n": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        521,
        50
      ],
      "content": "static mp_limb_t\nid_to_n  (mp_limb_t id)  { return id*3+1+(id&1); }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "n_to_bit": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        525,
        47
      ],
      "content": "static mp_limb_t\nn_to_bit (mp_limb_t n) { return ((n-5)|1)/3U; }",
      "lines": 2,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "primesieve_size": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        528,
        73
      ],
      "content": "static mp_size_t\nprimesieve_size (mp_limb_t n) { return n_to_bit(n) / GMP_LIMB_BITS + 1; }",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "limb_apprsqrt": {
      "start_point": [
        560,
        0
      ],
      "end_point": [
        569,
        1
      ],
      "content": "static mp_limb_t\nlimb_apprsqrt (mp_limb_t x)\n{\n  int s;\n\n  ASSERT (x > 2);\n  count_leading_zeros (s, x - 1);\n  s = GMP_LIMB_BITS - 1 - s;\n  return (CNST_LIMB(1) << (s >> 1)) + (CNST_LIMB(1) << ((s - 1) >> 1));\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpz_goetgheluck_bin_uiui": {
      "start_point": [
        571,
        0
      ],
      "end_point": [
        648,
        1
      ],
      "content": "static void\nmpz_goetgheluck_bin_uiui (mpz_ptr r, unsigned long int n, unsigned long int k)\n{\n  mp_limb_t *sieve, *factors, count;\n  mp_limb_t prod, max_prod, j;\n  TMP_DECL;\n\n  ASSERT (BIN_GOETGHELUCK_THRESHOLD >= 13);\n  ASSERT (n >= 25);\n\n  TMP_MARK;\n  sieve = TMP_ALLOC_LIMBS (primesieve_size (n));\n\n  count = gmp_primesieve (sieve, n) + 1;\n  factors = TMP_ALLOC_LIMBS (count / log_n_max (n) + 1);\n\n  max_prod = GMP_NUMB_MAX / n;\n\n  /* Handle primes = 2, 3 separately. */\n  popc_limb (count, n - k);\n  popc_limb (j, k);\n  count += j;\n  popc_limb (j, n);\n  count -= j;\n  prod = CNST_LIMB(1) << count;\n\n  j = 0;\n  COUNT_A_PRIME (3, n, k, prod, max_prod, factors, j);\n\n  /* Accumulate prime factors from 5 to n/2 */\n    {\n      mp_limb_t s;\n\n      {\n\tmp_limb_t prime;\n\ts = limb_apprsqrt(n);\n\ts = n_to_bit (s);\n\tLOOP_ON_SIEVE_BEGIN (prime, n_to_bit (5), s, 0,sieve);\n\tCOUNT_A_PRIME (prime, n, k, prod, max_prod, factors, j);\n\tLOOP_ON_SIEVE_END;\n\ts++;\n      }\n\n      ASSERT (max_prod <= GMP_NUMB_MAX / 2);\n      max_prod <<= 1;\n      ASSERT (bit_to_n (s) * bit_to_n (s) > n);\n      ASSERT (s <= n_to_bit (n >> 1));\n      {\n\tmp_limb_t prime;\n\n\tLOOP_ON_SIEVE_BEGIN (prime, s, n_to_bit (n >> 1), 0,sieve);\n\tSH_COUNT_A_PRIME (prime, n, k, prod, max_prod, factors, j);\n\tLOOP_ON_SIEVE_END;\n      }\n      max_prod >>= 1;\n    }\n\n  /* Store primes from (n-k)+1 to n */\n  ASSERT (n_to_bit (n - k) < n_to_bit (n));\n    {\n      mp_limb_t prime;\n      LOOP_ON_SIEVE_BEGIN (prime, n_to_bit (n - k) + 1, n_to_bit (n), 0,sieve);\n      FACTOR_LIST_STORE (prime, prod, max_prod, factors, j);\n      LOOP_ON_SIEVE_END;\n    }\n\n  if (LIKELY (j != 0))\n    {\n      factors[j++] = prod;\n      mpz_prodlimbs (r, factors, j);\n    }\n  else\n    {\n      PTR (r)[0] = prod;\n      SIZ (r) = 1;\n    }\n  TMP_FREE;\n}",
      "lines": 78,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_bin_uiui": {
      "start_point": [
        661,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "void\nmpz_bin_uiui (mpz_ptr r, unsigned long int n, unsigned long int k)\n{\n  if (UNLIKELY (n < k)) {\n    SIZ (r) = 0;\n#if BITS_PER_ULONG > GMP_NUMB_BITS\n  } else if (UNLIKELY (n > GMP_NUMB_MAX)) {\n    mpz_t tmp;\n\n    mpz_init_set_ui (tmp, n);\n    mpz_bin_ui (r, tmp, k);\n    mpz_clear (tmp);\n#endif\n  } else {\n    ASSERT (n <= GMP_NUMB_MAX);\n    /* Rewrite bin(n,k) as bin(n,n-k) if that is smaller. */\n    k = MIN (k, n - k);\n    if (k < 2) {\n      PTR(r)[0] = k ? n : 1; /* 1 + ((-k) & (n-1)); */\n      SIZ(r) = 1;\n    } else if (n <= ODD_FACTORIAL_EXTTABLE_LIMIT) { /* k >= 2, n >= 4 */\n      PTR(r)[0] = bc_bin_uiui (n, k);\n      SIZ(r) = 1;\n    } else if (k <= ODD_FACTORIAL_TABLE_LIMIT)\n      mpz_smallk_bin_uiui (r, n, k);\n    else if (BIN_UIUI_ENABLE_SMALLDC &&\n\t     k <= (BIN_UIUI_RECURSIVE_SMALLDC ? ODD_CENTRAL_BINOMIAL_TABLE_LIMIT : ODD_FACTORIAL_TABLE_LIMIT)* 2)\n      mpz_smallkdc_bin_uiui (r, n, k);\n    else if (ABOVE_THRESHOLD (k, BIN_GOETGHELUCK_THRESHOLD) &&\n\t     k > (n >> 4)) /* k > ODD_FACTORIAL_TABLE_LIMIT */\n      mpz_goetgheluck_bin_uiui (r, n, k);\n    else\n      mpz_bdiv_bin_uiui (r, n, k);\n  }\n}",
      "lines": 35,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cdiv_q.c": {
    "mpz_cdiv_q": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\nmpz_cdiv_q (mpz_ptr quot, mpz_srcptr dividend, mpz_srcptr divisor)\n{\n  mp_size_t dividend_size = SIZ (dividend);\n  mp_size_t divisor_size = SIZ (divisor);\n  mpz_t rem;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  MPZ_TMP_INIT (rem, ABS (divisor_size));\n\n  mpz_tdiv_qr (quot, rem, dividend, divisor);\n\n  if ((divisor_size ^ dividend_size) >= 0 && SIZ (rem) != 0)\n    mpz_add_ui (quot, quot, 1L);\n\n  TMP_FREE;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cdiv_qr.c": {
    "mpz_cdiv_qr": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\nmpz_cdiv_qr (mpz_ptr quot, mpz_ptr rem, mpz_srcptr dividend, mpz_srcptr divisor)\n{\n  mp_size_t divisor_size = SIZ (divisor);\n  mp_size_t xsize;\n  mpz_t temp_divisor;\t\t/* N.B.: lives until function returns! */\n  TMP_DECL;\n\n  TMP_MARK;\n\n  /* We need the original value of the divisor after the quotient and\n     remainder have been preliminary calculated.  We have to copy it to\n     temporary space if it's the same variable as either QUOT or REM.  */\n  if (quot == divisor || rem == divisor)\n    {\n      MPZ_TMP_INIT (temp_divisor, ABS (divisor_size));\n      mpz_set (temp_divisor, divisor);\n      divisor = temp_divisor;\n    }\n\n  xsize = SIZ (dividend) ^ divisor_size;;\n  mpz_tdiv_qr (quot, rem, dividend, divisor);\n\n  if (xsize >= 0 && SIZ (rem) != 0)\n    {\n      mpz_add_ui (quot, quot, 1L);\n      mpz_sub (rem, rem, divisor);\n    }\n\n  TMP_FREE;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cdiv_qr_ui.c": {
    "mpz_cdiv_qr_ui": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "unsigned long int\nmpz_cdiv_qr_ui (mpz_ptr quot, mpz_ptr rem, mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn, qn;\n  mp_ptr np, qp;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      SIZ(quot) = 0;\n      SIZ(rem) = 0;\n      return 0;\n    }\n\n  nn = ABS(ns);\n  qp = MPZ_REALLOC (quot, nn);\n  np = PTR(dividend);\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2];\n      mp_ptr rp;\n      mp_size_t rn;\n\n      rp = MPZ_REALLOC (rem, 2);\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  qp[0] = 0;\n\t  qn = 1;\t\t/* a white lie, fixed below */\n\t  rl = np[0];\n\t  rp[0] = rl;\n\t}\n      else\n\t{\n\t  dp[0] = divisor & GMP_NUMB_MASK;\n\t  dp[1] = divisor >> GMP_NUMB_BITS;\n\t  mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n\t  rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n\t  qn = nn - 2 + 1;\n\t}\n\n      if (rl != 0 && ns >= 0)\n\t{\n\t  mpn_incr_u (qp, (mp_limb_t) 1);\n\t  rl = divisor - rl;\n\t  rp[0] = rl & GMP_NUMB_MASK;\n\t  rp[1] = rl >> GMP_NUMB_BITS;\n\t}\n\n      qn -= qp[qn - 1] == 0; qn -= qn != 0 && qp[qn - 1] == 0;\n      rn = 1 + (rl > GMP_NUMB_MAX);  rn -= (rp[rn - 1] == 0);\n      SIZ(rem) = -rn;\n    }\n  else\n#endif\n    {\n      rl = mpn_divrem_1 (qp, (mp_size_t) 0, np, nn, (mp_limb_t) divisor);\n      if (rl == 0)\n\tSIZ(rem) = 0;\n      else\n\t{\n\t  if (ns >= 0)\n\t    {\n\t      mpn_incr_u (qp, (mp_limb_t) 1);\n\t      rl = divisor - rl;\n\t    }\n\n\t  PTR(rem)[0] = rl;\n\t  SIZ(rem) = -(rl != 0);\n\t}\n      qn = nn - (qp[nn - 1] == 0);\n    }\n\n  SIZ(quot) = ns >= 0 ? qn : -qn;\n  return rl;\n}",
      "lines": 82,
      "depth": 14,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cdiv_q_ui.c": {
    "mpz_cdiv_q_ui": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "unsigned long int\nmpz_cdiv_q_ui (mpz_ptr quot, mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn, qn;\n  mp_ptr np, qp;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      SIZ(quot) = 0;\n      return 0;\n    }\n\n  nn = ABS(ns);\n  qp = MPZ_REALLOC (quot, nn);\n  np = PTR(dividend);\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2], rp[2];\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  qp[0] = 0;\n\t  rl = np[0];\n\t  qn = 1;\t\t/* a white lie, fixed below */\n\t}\n      else\n\t{\n\t  dp[0] = divisor & GMP_NUMB_MASK;\n\t  dp[1] = divisor >> GMP_NUMB_BITS;\n\t  mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n\t  rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n\t  qn = nn - 2 + 1;\n\t}\n\n      if (rl != 0 && ns >= 0)\n\t{\n\t  mpn_incr_u (qp, (mp_limb_t) 1);\n\t  rl = divisor - rl;\n\t}\n\n      qn -= qp[qn - 1] == 0; qn -= qn != 0 && qp[qn - 1] == 0;\n    }\n  else\n#endif\n    {\n      rl = mpn_divrem_1 (qp, (mp_size_t) 0, np, nn, (mp_limb_t) divisor);\n\n      if (rl != 0 && ns >= 0)\n\t{\n\t  mpn_incr_u (qp, (mp_limb_t) 1);\n\t  rl = divisor - rl;\n\t}\n\n      qn = nn - (qp[nn - 1] == 0);\n    }\n\n  SIZ(quot) = ns >= 0 ? qn : -qn;\n  return rl;\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cdiv_r.c": {
    "mpz_cdiv_r": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\nmpz_cdiv_r (mpz_ptr rem, mpz_srcptr dividend, mpz_srcptr divisor)\n{\n  mp_size_t divisor_size = SIZ (divisor);\n  mpz_t temp_divisor;\t\t/* N.B.: lives until function returns! */\n  TMP_DECL;\n\n  TMP_MARK;\n\n  /* We need the original value of the divisor after the remainder has been\n     preliminary calculated.  We have to copy it to temporary space if it's\n     the same variable as REM.  */\n  if (rem == divisor)\n    {\n\n      MPZ_TMP_INIT (temp_divisor, ABS (divisor_size));\n      mpz_set (temp_divisor, divisor);\n      divisor = temp_divisor;\n    }\n\n  mpz_tdiv_r (rem, dividend, divisor);\n\n  if ((divisor_size ^ SIZ (dividend)) >= 0 && SIZ (rem) != 0)\n    mpz_sub (rem, rem, divisor);\n\n  TMP_FREE;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cdiv_r_ui.c": {
    "mpz_cdiv_r_ui": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "unsigned long int\nmpz_cdiv_r_ui (mpz_ptr rem, mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn;\n  mp_ptr np;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      SIZ(rem) = 0;\n      return 0;\n    }\n\n  nn = ABS(ns);\n  np = PTR(dividend);\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2];\n      mp_ptr rp, qp;\n      mp_size_t rn;\n      TMP_DECL;\n\n      rp = MPZ_REALLOC (rem, 2);\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  rl = np[0];\n\t  rp[0] = rl;\n\t}\n      else\n\t{\n\t  TMP_MARK;\n\t  dp[0] = divisor & GMP_NUMB_MASK;\n\t  dp[1] = divisor >> GMP_NUMB_BITS;\n\t  qp = TMP_ALLOC_LIMBS (nn - 2 + 1);\n\t  mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n\t  TMP_FREE;\n\t  rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n\t}\n\n      if (rl != 0 && ns >= 0)\n\t{\n\t  rl = divisor - rl;\n\t  rp[0] = rl & GMP_NUMB_MASK;\n\t  rp[1] = rl >> GMP_NUMB_BITS;\n\t}\n\n      rn = 1 + (rl > GMP_NUMB_MAX);  rn -= (rp[rn - 1] == 0);\n      SIZ(rem) = -rn;\n    }\n  else\n#endif\n    {\n      rl = mpn_mod_1 (np, nn, (mp_limb_t) divisor);\n      if (rl == 0)\n\tSIZ(rem) = 0;\n      else\n\t{\n\t  if (ns >= 0)\n\t    rl = divisor - rl;\n\n\t  PTR(rem)[0] = rl;\n\t  SIZ(rem) = -1;\n\t}\n    }\n\n  return rl;\n}",
      "lines": 73,
      "depth": 14,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cdiv_ui.c": {
    "mpz_cdiv_ui": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "unsigned long int\nmpz_cdiv_ui (mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn;\n  mp_ptr np;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      return 0;\n    }\n\n  nn = ABS(ns);\n  np = PTR(dividend);\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2], rp[2];\n      mp_ptr qp;\n      mp_size_t rn;\n      TMP_DECL;\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  rl = np[0];\n\t  rp[0] = rl;\n\t}\n      else\n\t{\n\t  TMP_MARK;\n\t  dp[0] = divisor & GMP_NUMB_MASK;\n\t  dp[1] = divisor >> GMP_NUMB_BITS;\n\t  qp = TMP_ALLOC_LIMBS (nn - 2 + 1);\n\t  mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n\t  TMP_FREE;\n\t  rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n\t}\n\n      if (rl != 0 && ns >= 0)\n\t{\n\t  rl = divisor - rl;\n\t  rp[0] = rl & GMP_NUMB_MASK;\n\t  rp[1] = rl >> GMP_NUMB_BITS;\n\t}\n\n      rn = 1 + (rl > GMP_NUMB_MAX);  rn -= (rp[rn - 1] == 0);\n    }\n  else\n#endif\n    {\n      rl = mpn_mod_1 (np, nn, (mp_limb_t) divisor);\n      if (rl == 0)\n\t;\n      else\n\t{\n\t  if (ns >= 0)\n\t    rl = divisor - rl;\n\t}\n    }\n\n  return rl;\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cfdiv_q_2exp.c": {
    "cfdiv_q_2exp": {
      "start_point": [
        40,
        17
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ncfdiv_q_2exp (mpz_ptr w, mpz_srcptr u, mp_bitcnt_t cnt, int dir)\n{\n  mp_size_t  wsize, usize, abs_usize, limb_cnt, i;\n  mp_srcptr  up;\n  mp_ptr     wp;\n  mp_limb_t  round, rmask;\n\n  usize = SIZ (u);\n  abs_usize = ABS (usize);\n  limb_cnt = cnt / GMP_NUMB_BITS;\n  wsize = abs_usize - limb_cnt;\n  if (wsize <= 0)\n    {\n      /* u < 2**cnt, so result 1, 0 or -1 according to rounding */\n      PTR(w)[0] = 1;\n      SIZ(w) = (usize == 0 || (usize ^ dir) < 0 ? 0 : dir);\n      return;\n    }\n\n  /* +1 limb to allow for mpn_add_1 below */\n  wp = MPZ_REALLOC (w, wsize+1);\n\n  /* Check for rounding if direction matches u sign.\n     Set round if we're skipping non-zero limbs.  */\n  up = PTR(u);\n  round = 0;\n  rmask = ((usize ^ dir) >= 0 ? MP_LIMB_T_MAX : 0);\n  if (rmask != 0)\n    for (i = 0; i < limb_cnt && round == 0; i++)\n      round = up[i];\n\n  cnt %= GMP_NUMB_BITS;\n  if (cnt != 0)\n    {\n      round |= rmask & mpn_rshift (wp, up + limb_cnt, wsize, cnt);\n      wsize -= (wp[wsize - 1] == 0);\n    }\n  else\n    MPN_COPY_INCR (wp, up + limb_cnt, wsize);\n\n  if (round != 0)\n    {\n      if (wsize != 0)\n\t{\n\t  mp_limb_t cy;\n\t  cy = mpn_add_1 (wp, wp, wsize, CNST_LIMB(1));\n\t  wp[wsize] = cy;\n\t  wsize += cy;\n\t}\n      else\n\t{\n\t  /* We shifted something to zero.  */\n\t  wp[0] = 1;\n\t  wsize = 1;\n\t}\n    }\n  SIZ(w) = (usize >= 0 ? wsize : -wsize);\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_cdiv_q_2exp": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void\nmpz_cdiv_q_2exp (mpz_ptr w, mpz_srcptr u, mp_bitcnt_t cnt)\n{\n  cfdiv_q_2exp (w, u, cnt, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_q_2exp": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void\nmpz_fdiv_q_2exp (mpz_ptr w, mpz_srcptr u, mp_bitcnt_t cnt)\n{\n  cfdiv_q_2exp (w, u, cnt, -1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cfdiv_r_2exp.c": {
    "cfdiv_r_2exp": {
      "start_point": [
        43,
        17
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static void\ncfdiv_r_2exp (mpz_ptr w, mpz_srcptr u, mp_bitcnt_t cnt, int dir)\n{\n  mp_size_t  usize, abs_usize, limb_cnt, i;\n  mp_srcptr  up;\n  mp_ptr     wp;\n  mp_limb_t  high;\n\n  usize = SIZ(u);\n  if (usize == 0)\n    {\n      SIZ(w) = 0;\n      return;\n    }\n\n  limb_cnt = cnt / GMP_NUMB_BITS;\n  cnt %= GMP_NUMB_BITS;\n  abs_usize = ABS (usize);\n\n  /* MPZ_REALLOC(w) below is only when w!=u, so we can fetch PTR(u) here\n     nice and early */\n  up = PTR(u);\n\n  if ((usize ^ dir) < 0)\n    {\n      /* Round towards zero, means just truncate */\n\n      if (w == u)\n\t{\n\t  /* if already smaller than limb_cnt then do nothing */\n\t  if (abs_usize <= limb_cnt)\n\t    return;\n\t  wp = (mp_ptr) up;\n\t}\n      else\n\t{\n\t  i = MIN (abs_usize, limb_cnt+1);\n\t  wp = MPZ_NEWALLOC (w, i);\n\t  MPN_COPY (wp, up, i);\n\n\t  /* if smaller than limb_cnt then only the copy is needed */\n\t  if (abs_usize <= limb_cnt)\n\t    {\n\t      SIZ(w) = usize;\n\t      return;\n\t    }\n\t}\n    }\n  else\n    {\n      /* Round away from zero, means twos complement if non-zero */\n\n      /* if u!=0 and smaller than divisor, then must negate */\n      if (abs_usize <= limb_cnt)\n\tgoto negate;\n\n      /* if non-zero low limb, then must negate */\n      for (i = 0; i < limb_cnt; i++)\n\tif (up[i] != 0)\n\t  goto negate;\n\n      /* if non-zero partial limb, then must negate */\n      if ((up[limb_cnt] & LOW_MASK (cnt)) != 0)\n\tgoto negate;\n\n      /* otherwise low bits of u are zero, so that's the result */\n      SIZ(w) = 0;\n      return;\n\n    negate:\n      /* twos complement negation to get 2**cnt-u */\n\n      wp = MPZ_REALLOC (w, limb_cnt+1);\n      up = PTR(u);\n\n      /* Ones complement */\n      i = MIN (abs_usize, limb_cnt+1);\n      ASSERT_CARRY (mpn_neg (wp, up, i));\n      for ( ; i <= limb_cnt; i++)\n\twp[i] = GMP_NUMB_MAX;\n\n      usize = -usize;\n    }\n\n  /* Mask the high limb */\n  high = wp[limb_cnt];\n  high &= LOW_MASK (cnt);\n  wp[limb_cnt] = high;\n\n  /* Strip any consequent high zeros */\n  while (high == 0)\n    {\n      limb_cnt--;\n      if (limb_cnt < 0)\n\t{\n\t  SIZ(w) = 0;\n\t  return;\n\t}\n      high = wp[limb_cnt];\n    }\n\n  limb_cnt++;\n  SIZ(w) = (usize >= 0 ? limb_cnt : -limb_cnt);\n}",
      "lines": 104,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_cdiv_r_2exp": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "void\nmpz_cdiv_r_2exp (mpz_ptr w, mpz_srcptr u, mp_bitcnt_t cnt)\n{\n  cfdiv_r_2exp (w, u, cnt, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_r_2exp": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void\nmpz_fdiv_r_2exp (mpz_ptr w, mpz_srcptr u, mp_bitcnt_t cnt)\n{\n  cfdiv_r_2exp (w, u, cnt, -1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/clear.c": {
    "mpz_clear": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\nmpz_clear (mpz_ptr x)\n{\n  __GMP_FREE_FUNC_LIMBS (PTR (x), ALLOC(x));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/clears.c": {
    "mpz_clears": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nmpz_clears (mpz_ptr x, ...)\n{\n  va_list  ap;\n\n  va_start (ap, x);\n\n  while (x != NULL)\n    {\n      __GMP_FREE_FUNC_LIMBS (PTR (x), ALLOC(x));\n      x = va_arg (ap, mpz_ptr);\n    }\n\n  va_end (ap);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/clrbit.c": {
    "mpz_clrbit": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\nmpz_clrbit (mpz_ptr d, mp_bitcnt_t bit_idx)\n{\n  mp_size_t dsize = SIZ (d);\n  mp_ptr dp = PTR (d);\n  mp_size_t limb_idx;\n  mp_limb_t mask;\n\n  limb_idx = bit_idx / GMP_NUMB_BITS;\n  mask = CNST_LIMB(1) << (bit_idx % GMP_NUMB_BITS);\n  if (dsize >= 0)\n    {\n      if (limb_idx < dsize)\n\t{\n\t  mp_limb_t  dlimb;\n\t  dlimb = dp[limb_idx] & ~mask;\n\t  dp[limb_idx] = dlimb;\n\n\t  if (UNLIKELY ((dlimb == 0) + limb_idx == dsize)) /* dsize == limb_idx + 1 */\n\t    {\n\t      /* high limb became zero, must normalize */\n\t      MPN_NORMALIZE (dp, limb_idx);\n\t      SIZ (d) = limb_idx;\n\t    }\n\t}\n      else\n\t;\n    }\n  else\n    {\n      /* Simulate two's complement arithmetic, i.e. simulate\n\t 1. Set OP = ~(OP - 1) [with infinitely many leading ones].\n\t 2. clear the bit.\n\t 3. Set OP = ~OP + 1.  */\n\n      dsize = -dsize;\n\n      if (limb_idx < dsize)\n\t{\n\t  mp_size_t zero_bound;\n\n\t  /* No index upper bound on this loop, we're sure there's a non-zero limb\n\t     sooner or later.  */\n\t  zero_bound = 0;\n\t  while (dp[zero_bound] == 0)\n\t    zero_bound++;\n\n\t  if (limb_idx > zero_bound)\n\t    {\n\t      dp[limb_idx] |= mask;\n\t    }\n\t  else if (limb_idx == zero_bound)\n\t    {\n\t      mp_limb_t  dlimb;\n\t      dlimb = (((dp[limb_idx] - 1) | mask) + 1) & GMP_NUMB_MASK;\n\t      dp[limb_idx] = dlimb;\n\n\t      if (dlimb == 0)\n\t\t{\n\t\t  /* Increment at limb_idx + 1.  Extend the number with a zero limb\n\t\t     for simplicity.  */\n\t\t  dp = MPZ_REALLOC (d, dsize + 1);\n\t\t  dp[dsize] = 0;\n\t\t  MPN_INCR_U (dp + limb_idx + 1, dsize - limb_idx, 1);\n\t\t  dsize += dp[dsize];\n\n\t\t  SIZ (d) = -dsize;\n\t\t}\n\t    }\n\t  else\n\t    ;\n\t}\n      else\n\t{\n\t  /* Ugh.  The bit should be cleared outside of the end of the\n\t     number.  We have to increase the size of the number.  */\n\t  dp = MPZ_REALLOC (d, limb_idx + 1);\n\t  SIZ (d) = -(limb_idx + 1);\n\t  MPN_ZERO (dp + dsize, limb_idx - dsize);\n\t  dp[limb_idx] = mask;\n\t}\n    }\n}",
      "lines": 83,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cmp.c": {
    "mpz_cmp": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nmpz_cmp (mpz_srcptr u, mpz_srcptr v) __GMP_NOTHROW\n{\n  mp_size_t  usize, vsize, dsize, asize;\n  mp_srcptr  up, vp;\n  int        cmp;\n\n  usize = SIZ(u);\n  vsize = SIZ(v);\n  dsize = usize - vsize;\n  if (dsize != 0)\n    return dsize;\n\n  asize = ABS (usize);\n  up = PTR(u);\n  vp = PTR(v);\n  MPN_CMP (cmp, up, vp, asize);\n  return (usize >= 0 ? cmp : -cmp);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "int",
        "mpz_cmp (mpz_srcptr u, mpz_srcptr v)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cmpabs.c": {
    "mpz_cmpabs": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nmpz_cmpabs (mpz_srcptr u, mpz_srcptr v) __GMP_NOTHROW\n{\n  mp_size_t  usize, vsize, dsize;\n  mp_srcptr  up, vp;\n  int        cmp;\n\n  usize = ABSIZ (u);\n  vsize = ABSIZ (v);\n  dsize = usize - vsize;\n  if (dsize != 0)\n    return dsize;\n\n  up = PTR(u);\n  vp = PTR(v);\n  MPN_CMP (cmp, up, vp, usize);\n  return cmp;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "int",
        "mpz_cmpabs (mpz_srcptr u, mpz_srcptr v)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cmpabs_d.c": {
    "mpz_cmpabs_d": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\nmpz_cmpabs_d (mpz_srcptr z, double d)\n{\n  mp_limb_t  darray[LIMBS_PER_DOUBLE], zlimb, dlimb;\n  mp_srcptr  zp;\n  mp_size_t  zsize;\n  int        dexp;\n\n  /* d=NaN is an invalid operation, there's no sensible return value.\n     d=Inf or -Inf is always bigger than z.  */\n  DOUBLE_NAN_INF_ACTION (d, __gmp_invalid_operation (), return -1);\n\n  /* 1. Check for either operand zero. */\n  zsize = SIZ(z);\n  if (d == 0.0)\n    return (zsize != 0);\n  if (zsize == 0)\n    return -1; /* d != 0 */\n\n  /* 2. Ignore signs. */\n  zsize = ABS(zsize);\n  d = ABS(d);\n\n  /* 3. Small d, knowing abs(z) >= 1. */\n  if (d < 1.0)\n    return 1;\n\n  dexp = __gmp_extract_double (darray, d);\n  ASSERT (dexp >= 1);\n\n  /* 4. Check for different high limb positions. */\n  if (zsize != dexp)\n    return (zsize >= dexp ? 1 : -1);\n\n  /* 5. Limb data. */\n  zp = PTR(z);\n\n#if LIMBS_PER_DOUBLE == 2\n  RETURN_CMP (zp[zsize-1], darray[1]);\n  if (zsize == 1)\n    return (darray[0] != 0 ? -1 : 0);\n\n  RETURN_CMP (zp[zsize-2], darray[0]);\n  RETURN_NONZERO (zp, zsize-2, 1);\n#endif\n\n#if LIMBS_PER_DOUBLE == 3\n  RETURN_CMP (zp[zsize-1], darray[2]);\n  if (zsize == 1)\n    return ((darray[0] | darray[1]) != 0 ? -1 : 0);\n\n  RETURN_CMP (zp[zsize-2], darray[1]);\n  if (zsize == 2)\n    return (darray[0] != 0 ? -1 : 0);\n\n  RETURN_CMP (zp[zsize-3], darray[0]);\n  RETURN_NONZERO (zp, zsize-3, 1);\n#endif\n\n#if LIMBS_PER_DOUBLE >= 4\n  {\n    int i;\n    for (i = 1; i <= LIMBS_PER_DOUBLE; i++)\n      {\n\tRETURN_CMP (zp[zsize-i], darray[LIMBS_PER_DOUBLE-i]);\n\tif (i >= zsize)\n\t  RETURN_NONZERO (darray, LIMBS_PER_DOUBLE-i, -1);\n      }\n    RETURN_NONZERO (zp, zsize-LIMBS_PER_DOUBLE, 1);\n  }\n#endif\n}",
      "lines": 72,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cmpabs_ui.c": {
    "mpz_cmpabs_ui": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nmpz_cmpabs_ui (mpz_srcptr u, unsigned long int v_digit) __GMP_NOTHROW\n{\n  mp_ptr up;\n  mp_size_t un;\n  mp_limb_t ul;\n\n  up = PTR(u);\n  un = SIZ(u);\n\n  if (un == 0)\n    return -(v_digit != 0);\n\n  un = ABS (un);\n\n  if (un == 1)\n    {\n      ul = up[0];\n      if (ul > v_digit)\n\treturn 1;\n      if (ul < v_digit)\n\treturn -1;\n      return 0;\n    }\n\n#if GMP_NAIL_BITS != 0\n  if (v_digit > GMP_NUMB_MAX)\n    {\n      if (un == 2)\n\t{\n\t  ul = up[0] + (up[1] << GMP_NUMB_BITS);\n\n\t  if (ul > v_digit)\n\t    return 1;\n\t  if (ul < v_digit)\n\t    return -1;\n\t  return 0;\n\t}\n    }\n#endif\n\n  return 1;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "int",
        "mpz_cmpabs_ui (mpz_srcptr u, unsigned long int v_digit)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cmp_d.c": {
    "mpz_cmp_d": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "int\nmpz_cmp_d (mpz_srcptr z, double d)\n{\n  mp_limb_t  darray[LIMBS_PER_DOUBLE], zlimb, dlimb;\n  mp_srcptr  zp;\n  mp_size_t  zsize;\n  int        dexp, ret;\n\n  /* d=NaN is an invalid operation, there's no sensible return value.\n     d=Inf or -Inf is always bigger than z.  */\n  DOUBLE_NAN_INF_ACTION (d, __gmp_invalid_operation (), goto z_zero);\n\n  /* 1. Either operand zero. */\n  zsize = SIZ(z);\n  if (d == 0.0)\n    return zsize;\n  if (zsize == 0)\n    {\n    z_zero:\n      return (d < 0.0 ? 1 : -1);\n    }\n\n  /* 2. Opposite signs. */\n  if (zsize >= 0)\n    {\n      if (d < 0.0)\n\treturn 1;    /* >=0 cmp <0 */\n      ret = 1;\n    }\n  else\n    {\n      if (d >= 0.0)\n\treturn -1;   /* <0 cmp >=0 */\n      ret = -1;\n      d = -d;\n      zsize = -zsize;\n    }\n\n  /* 3. Small d, knowing abs(z) >= 1. */\n  if (d < 1.0)\n    return ret;\n\n  dexp = __gmp_extract_double (darray, d);\n  ASSERT (dexp >= 1);\n\n  /* 4. Check for different high limb positions. */\n  if (zsize != dexp)\n    return (zsize >= dexp ? ret : -ret);\n\n  /* 5. Limb data. */\n  zp = PTR(z);\n\n#if LIMBS_PER_DOUBLE == 2\n  RETURN_CMP (zp[zsize-1], darray[1]);\n  if (zsize == 1)\n    return (darray[0] != 0 ? -ret : 0);\n\n  RETURN_CMP (zp[zsize-2], darray[0]);\n  RETURN_NONZERO (zp, zsize-2, ret);\n#endif\n\n#if LIMBS_PER_DOUBLE == 3\n  RETURN_CMP (zp[zsize-1], darray[2]);\n  if (zsize == 1)\n    return ((darray[0] | darray[1]) != 0 ? -ret : 0);\n\n  RETURN_CMP (zp[zsize-2], darray[1]);\n  if (zsize == 2)\n    return (darray[0] != 0 ? -ret : 0);\n\n  RETURN_CMP (zp[zsize-3], darray[0]);\n  RETURN_NONZERO (zp, zsize-3, ret);\n#endif\n\n#if LIMBS_PER_DOUBLE >= 4\n  {\n    int i;\n    for (i = 1; i <= LIMBS_PER_DOUBLE; i++)\n      {\n\tRETURN_CMP (zp[zsize-i], darray[LIMBS_PER_DOUBLE-i]);\n\tif (i >= zsize)\n\t  RETURN_NONZERO (darray, LIMBS_PER_DOUBLE-i, -ret);\n      }\n    RETURN_NONZERO (zp, zsize-LIMBS_PER_DOUBLE, ret);\n  }\n#endif\n}",
      "lines": 87,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cmp_si.c": {
    "_mpz_cmp_si": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\n_mpz_cmp_si (mpz_srcptr u, signed long int v_digit) __GMP_NOTHROW\n{\n#if GMP_NAIL_BITS != 0\n  /* FIXME.  This isn't very pretty.  */\n  mpz_t tmp;\n  mp_limb_t tt[2];\n  PTR(tmp) = tt;\n  ALLOC(tmp) = 2;\n  mpz_set_si (tmp, v_digit);\n  return mpz_cmp (u, tmp);\n#else\n\n  mp_size_t vsize, usize;\n\n  usize = SIZ (u);\n  vsize = (v_digit > 0) - (v_digit < 0);\n\n  if ((usize == 0) | (usize != vsize))\n    return usize - vsize;\n  else {\n    mp_limb_t u_digit, absv_digit;\n\n    u_digit = PTR (u)[0];\n    absv_digit = ABS_CAST (unsigned long, v_digit);\n\n    if (u_digit == absv_digit)\n      return 0;\n\n    if (u_digit > absv_digit)\n      return usize;\n    else\n      return -usize;\n  }\n#endif\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "int",
        "_mpz_cmp_si (mpz_srcptr u, signed long int v_digit)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cmp_ui.c": {
    "_mpz_cmp_ui": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\n_mpz_cmp_ui (mpz_srcptr u, unsigned long int v_digit) __GMP_NOTHROW\n{\n  mp_ptr up;\n  mp_size_t un;\n  mp_limb_t ul;\n\n  up = PTR(u);\n  un = SIZ(u);\n\n  if (un == 0)\n    return -(v_digit != 0);\n\n  if (un == 1)\n    {\n      ul = up[0];\n      if (ul > v_digit)\n\treturn 1;\n      if (ul < v_digit)\n\treturn -1;\n      return 0;\n    }\n\n#if GMP_NAIL_BITS != 0\n  if (v_digit > GMP_NUMB_MAX)\n    {\n      if (un == 2)\n\t{\n\t  ul = up[0] + (up[1] << GMP_NUMB_BITS);\n\n\t  if ((up[1] >> GMP_NAIL_BITS) != 0)\n\t    return 1;\n\n\t  if (ul > v_digit)\n\t    return 1;\n\t  if (ul < v_digit)\n\t    return -1;\n\t  return 0;\n\t}\n    }\n#endif\n\n  return un > 0 ? 1 : -1;\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "int",
        "_mpz_cmp_ui (mpz_srcptr u, unsigned long int v_digit)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/com.c": {
    "mpz_com": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "void\nmpz_com (mpz_ptr dst, mpz_srcptr src)\n{\n  mp_size_t size = SIZ (src);\n  mp_srcptr src_ptr;\n  mp_ptr dst_ptr;\n\n  if (size >= 0)\n    {\n      /* As with infinite precision: one's complement, two's complement.\n\t But this can be simplified using the identity -x = ~x + 1.\n\t So we're going to compute (~~x) + 1 = x + 1!  */\n\n      if (UNLIKELY (size == 0))\n\t{\n\t  /* special case, as mpn_add_1 wants size!=0 */\n\t  PTR (dst)[0] = 1;\n\t  SIZ (dst) = -1;\n\t}\n      else\n\t{\n\t  mp_limb_t cy;\n\n\t  dst_ptr = MPZ_REALLOC (dst, size + 1);\n\n\t  src_ptr = PTR (src);\n\n\t  cy = mpn_add_1 (dst_ptr, src_ptr, size, (mp_limb_t) 1);\n\t  dst_ptr[size] = cy;\n\t  size += cy;\n\n\t  /* Store a negative size, to indicate ones-extension.  */\n\t  SIZ (dst) = -size;\n      }\n    }\n  else\n    {\n      /* As with infinite precision: two's complement, then one's complement.\n\t But that can be simplified using the identity -x = ~(x - 1).\n\t So we're going to compute ~~(x - 1) = x - 1!  */\n      size = -size;\n\n      dst_ptr = MPZ_REALLOC (dst, size);\n\n      src_ptr = PTR (src);\n\n      mpn_sub_1 (dst_ptr, src_ptr, size, (mp_limb_t) 1);\n      size -= dst_ptr[size - 1] == 0;\n\n      /* Store a positive size, to indicate zero-extension.  */\n      SIZ (dst) = size;\n    }\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/combit.c": {
    "mpz_combit": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void\nmpz_combit (mpz_ptr d, mp_bitcnt_t bit_index)\n{\n  mp_size_t dsize = SIZ(d);\n  mp_ptr dp = PTR(d);\n\n  mp_size_t limb_index = bit_index / GMP_NUMB_BITS;\n  mp_limb_t bit = (CNST_LIMB (1) << (bit_index % GMP_NUMB_BITS));\n\n  /* Check for the most common case: Positive input, no realloc or\n     normalization needed. */\n  if (limb_index + 1 < dsize)\n    dp[limb_index] ^= bit;\n\n  /* Check for the hairy case. d < 0, and we have all zero bits to the\n     right of the bit to toggle. */\n  else if (limb_index < -dsize\n\t   && (limb_index == 0 || mpn_zero_p (dp, limb_index))\n\t   && (dp[limb_index] & (bit - 1)) == 0)\n    {\n      ASSERT (dsize < 0);\n      dsize = -dsize;\n\n      if (dp[limb_index] & bit)\n\t{\n\t  /* We toggle the least significant one bit. Corresponds to\n\t     an add, with potential carry propagation, on the absolute\n\t     value. */\n\t  dp = MPZ_REALLOC (d, 1 + dsize);\n\t  dp[dsize] = 0;\n\t  MPN_INCR_U (dp + limb_index, 1 + dsize - limb_index, bit);\n\t  SIZ(d) = - dsize - dp[dsize];\n\t}\n      else\n\t{\n\t  /* We toggle a zero bit, subtract from the absolute value. */\n\t  MPN_DECR_U (dp + limb_index, dsize - limb_index, bit);\n\t  /* The absolute value shrinked by at most one bit. */\n\t  dsize -= dp[dsize - 1] == 0;\n\t  ASSERT (dsize > 0 && dp[dsize - 1] != 0);\n\t  SIZ (d) = -dsize;\n\t}\n    }\n  else\n    {\n      /* Simple case: Toggle the bit in the absolute value. */\n      dsize = ABS(dsize);\n      if (limb_index < dsize)\n\t{\n\t  mp_limb_t\t dlimb;\n\t  dlimb = dp[limb_index] ^ bit;\n\t  dp[limb_index] = dlimb;\n\n\t  /* Can happen only when limb_index = dsize - 1. Avoid SIZ(d)\n\t     bookkeeping in the common case. */\n\t  if (UNLIKELY ((dlimb == 0) + limb_index == dsize)) /* dsize == limb_index + 1 */\n\t    {\n\t      /* high limb became zero, must normalize */\n\t      MPN_NORMALIZE (dp, limb_index);\n\t      SIZ (d) = SIZ (d) >= 0 ? limb_index : -limb_index;\n\t    }\n\t}\n      else\n\t{\n\t  dp = MPZ_REALLOC (d, limb_index + 1);\n\t  MPN_ZERO(dp + dsize, limb_index - dsize);\n\t  dp[limb_index++] = bit;\n\t  SIZ(d) = SIZ(d) >= 0 ? limb_index : -limb_index;\n\t}\n    }\n}",
      "lines": 71,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cong.c": {
    "mpz_congruent_p": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "int\nmpz_congruent_p (mpz_srcptr a, mpz_srcptr c, mpz_srcptr d)\n{\n  mp_size_t  asize, csize, dsize, sign;\n  mp_srcptr  ap, cp, dp;\n  mp_ptr     xp;\n  mp_limb_t  alow, clow, dlow, dmask, r;\n  int        result;\n  TMP_DECL;\n\n  dsize = SIZ(d);\n  if (UNLIKELY (dsize == 0))\n    return (mpz_cmp (a, c) == 0);\n\n  dsize = ABS(dsize);\n  dp = PTR(d);\n\n  if (ABSIZ(a) < ABSIZ(c))\n    MPZ_SRCPTR_SWAP (a, c);\n\n  asize = SIZ(a);\n  csize = SIZ(c);\n  sign = (asize ^ csize);\n\n  asize = ABS(asize);\n  ap = PTR(a);\n\n  if (csize == 0)\n    return mpn_divisible_p (ap, asize, dp, dsize);\n\n  csize = ABS(csize);\n  cp = PTR(c);\n\n  alow = ap[0];\n  clow = cp[0];\n  dlow = dp[0];\n\n  /* Check a==c mod low zero bits of dlow.  This might catch a few cases of\n     a!=c quickly, and it helps the csize==1 special cases below.  */\n  dmask = LOW_ZEROS_MASK (dlow) & GMP_NUMB_MASK;\n  alow = (sign >= 0 ? alow : -alow);\n  if (((alow-clow) & dmask) != 0)\n    return 0;\n\n  if (csize == 1)\n    {\n      if (dsize == 1)\n\t{\n\tcong_1:\n\t  if (sign < 0)\n\t    NEG_MOD (clow, clow, dlow);\n\n\t  if (ABOVE_THRESHOLD (asize, BMOD_1_TO_MOD_1_THRESHOLD))\n\t    {\n\t      r = mpn_mod_1 (ap, asize, dlow);\n\t      if (clow < dlow)\n\t\treturn r == clow;\n\t      else\n\t\treturn r == (clow % dlow);\n\t    }\n\n\t  if ((dlow & 1) == 0)\n\t    {\n\t      /* Strip low zero bits to get odd d required by modexact.  If\n\t\t d==e*2^n then a==c mod d if and only if both a==c mod e and\n\t\t a==c mod 2^n, the latter having been done above.  */\n\t      unsigned\ttwos;\n\t      count_trailing_zeros (twos, dlow);\n\t      dlow >>= twos;\n\t    }\n\n\t  r = mpn_modexact_1c_odd (ap, asize, dlow, clow);\n\t  return r == 0 || r == dlow;\n\t}\n\n      /* dlow==0 is avoided since we don't want to bother handling extra low\n\t zero bits if dsecond is even (would involve borrow if a,c differ in\n\t sign and alow,clow!=0).  */\n      if (dsize == 2 && dlow != 0)\n\t{\n\t  mp_limb_t  dsecond = dp[1];\n\n\t  if (dsecond <= dmask)\n\t    {\n\t      unsigned\t twos;\n\t      count_trailing_zeros (twos, dlow);\n\t      dlow = (dlow >> twos) | (dsecond << (GMP_NUMB_BITS-twos));\n\t      ASSERT_LIMB (dlow);\n\n\t      /* dlow will be odd here, so the test for it even under cong_1\n\t\t is unnecessary, but the rest of that code is wanted. */\n\t      goto cong_1;\n\t    }\n\t}\n    }\n\n  TMP_MARK;\n  xp = TMP_ALLOC_LIMBS (asize+1);\n\n  /* calculate abs(a-c) */\n  if (sign >= 0)\n    {\n      /* same signs, subtract */\n      if (asize > csize || mpn_cmp (ap, cp, asize) >= 0)\n\tASSERT_NOCARRY (mpn_sub (xp, ap, asize, cp, csize));\n      else\n\tASSERT_NOCARRY (mpn_sub_n (xp, cp, ap, asize));\n      MPN_NORMALIZE (xp, asize);\n    }\n  else\n    {\n      /* different signs, add */\n      mp_limb_t  carry;\n      carry = mpn_add (xp, ap, asize, cp, csize);\n      xp[asize] = carry;\n      asize += (carry != 0);\n    }\n\n  result = mpn_divisible_p (xp, asize, dp, dsize);\n\n  TMP_FREE;\n  return result;\n}",
      "lines": 123,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cong_2exp.c": {
    "mpz_congruent_2exp_p": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "int\nmpz_congruent_2exp_p (mpz_srcptr a, mpz_srcptr c, mp_bitcnt_t d) __GMP_NOTHROW\n{\n  mp_size_t      i, dlimbs;\n  unsigned       dbits;\n  mp_ptr         ap, cp;\n  mp_limb_t      dmask, alimb, climb, sum;\n  mp_size_t      as, cs, asize, csize;\n\n  as = SIZ(a);\n  asize = ABS(as);\n\n  cs = SIZ(c);\n  csize = ABS(cs);\n\n  if (asize < csize)\n    {\n      MPZ_SRCPTR_SWAP (a, c);\n      MP_SIZE_T_SWAP (asize, csize);\n    }\n\n  dlimbs = d / GMP_NUMB_BITS;\n  dbits = d % GMP_NUMB_BITS;\n  dmask = (CNST_LIMB(1) << dbits) - 1;\n\n  ap = PTR(a);\n  cp = PTR(c);\n\n  if (csize == 0)\n    goto a_zeros;\n\n  if ((cs ^ as) >= 0)\n    {\n      /* same signs, direct comparison */\n\n      /* a==c for limbs in common */\n      if (mpn_cmp (ap, cp, MIN (csize, dlimbs)) != 0)\n\treturn 0;\n\n      /* if that's all of dlimbs, then a==c for remaining bits */\n      if (csize > dlimbs)\n\treturn ((ap[dlimbs]-cp[dlimbs]) & dmask) == 0;\n\n    a_zeros:\n      /* a remains, need all zero bits */\n\n      /* if d covers all of a and c, then must be exactly equal */\n      if (asize <= dlimbs)\n\treturn asize == csize;\n\n      /* whole limbs zero */\n      for (i = csize; i < dlimbs; i++)\n\tif (ap[i] != 0)\n\t  return 0;\n\n      /* partial limb zero */\n      return (ap[dlimbs] & dmask) == 0;\n    }\n  else\n    {\n      /* different signs, negated comparison */\n\n      /* common low zero limbs, stopping at first non-zeros, which must\n\t match twos complement */\n      i = 0;\n      do\n\t{\n\t  ASSERT (i < csize);  /* always have a non-zero limb on c */\n\t  alimb = ap[i];\n\t  climb = cp[i];\n\t  sum = (alimb + climb) & GMP_NUMB_MASK;\n\n\t  if (i >= dlimbs)\n\t    return (sum & dmask) == 0;\n\t  ++i;\n\n\t  /* require both zero, or first non-zeros as twos-complements */\n\t  if (sum != 0)\n\t    return 0;\n\t} while (alimb == 0);\n\n      /* further limbs matching as ones-complement */\n      for (; i < csize; ++i)\n\t{\n\t  alimb = ap[i];\n\t  climb = cp[i];\n\t  sum = alimb ^ climb ^ GMP_NUMB_MASK;\n\n\t  if (i >= dlimbs)\n\t    return (sum & dmask) == 0;\n\n\t  if (sum != 0)\n\t    return 0;\n\t}\n\n      /* no more c, so require all 1 bits in a */\n\n      if (asize < dlimbs)\n\treturn 0;   /* not enough a */\n\n      /* whole limbs */\n      for ( ; i < dlimbs; i++)\n\tif (ap[i] != GMP_NUMB_MAX)\n\t  return 0;\n\n      /* if only whole limbs, no further fetches from a */\n      if (dbits == 0)\n\treturn 1;\n\n      /* need enough a */\n      if (asize == dlimbs)\n\treturn 0;\n\n      return ((ap[dlimbs]+1) & dmask) == 0;\n    }\n}",
      "lines": 116,
      "depth": 13,
      "decorators": [
        "int",
        "mpz_congruent_2exp_p (mpz_srcptr a, mpz_srcptr c, mp_bitcnt_t d)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/cong_ui.c": {
    "mpz_congruent_ui_p": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nmpz_congruent_ui_p (mpz_srcptr a, unsigned long cu, unsigned long du)\n{\n  mp_srcptr  ap;\n  mp_size_t  asize;\n  mp_limb_t  c, d, r;\n\n  if (UNLIKELY (du == 0))\n    return (mpz_cmp_ui (a, cu) == 0);\n\n  asize = SIZ(a);\n  if (asize == 0)\n    {\n      if (cu < du)\n\treturn cu == 0;\n      else\n\treturn (cu % du) == 0;\n    }\n\n  /* For nails don't try to be clever if c or d is bigger than a limb, just\n     fake up some mpz_t's and go to the main mpz_congruent_p.  */\n  if (du > GMP_NUMB_MAX || cu > GMP_NUMB_MAX)\n    {\n      mp_limb_t  climbs[2], dlimbs[2];\n      mpz_t      cz, dz;\n\n      ALLOC(cz) = 2;\n      PTR(cz) = climbs;\n      ALLOC(dz) = 2;\n      PTR(dz) = dlimbs;\n\n      mpz_set_ui (cz, cu);\n      mpz_set_ui (dz, du);\n      return mpz_congruent_p (a, cz, dz);\n    }\n\n  /* NEG_MOD works on limbs, so convert ulong to limb */\n  c = cu;\n  d = du;\n\n  if (asize < 0)\n    {\n      asize = -asize;\n      NEG_MOD (c, c, d);\n    }\n\n  ap = PTR (a);\n\n  if (ABOVE_THRESHOLD (asize, BMOD_1_TO_MOD_1_THRESHOLD))\n    {\n      r = mpn_mod_1 (ap, asize, d);\n      if (c < d)\n\treturn r == c;\n      else\n\treturn r == (c % d);\n    }\n\n  if ((d & 1) == 0)\n    {\n      /* Strip low zero bits to get odd d required by modexact.  If\n\t d==e*2^n then a==c mod d if and only if both a==c mod 2^n\n\t and a==c mod e.  */\n\n      unsigned\ttwos;\n\n      if ((ap[0]-c) & LOW_ZEROS_MASK (d))\n\treturn 0;\n\n      count_trailing_zeros (twos, d);\n      d >>= twos;\n    }\n\n  r = mpn_modexact_1c_odd (ap, asize, d, c);\n  return r == 0 || r == d;\n}",
      "lines": 75,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/divegcd.c": {
    "mpz_divexact_by3": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\nmpz_divexact_by3 (mpz_ptr q, mpz_srcptr a)\n{\n  mp_size_t  size = SIZ(a);\n  mp_size_t  abs_size = ABS(size);\n  mp_ptr     qp;\n\n  qp = MPZ_REALLOC (q, abs_size);\n\n  mpn_bdiv_dbm1 (qp, PTR(a), abs_size, GMP_NUMB_MASK / 3);\n\n  abs_size -= (qp[abs_size-1] == 0);\n  SIZ(q) = (size>0 ? abs_size : -abs_size);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_divexact_by5": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static void\nmpz_divexact_by5 (mpz_ptr q, mpz_srcptr a)\n{\n  mp_size_t  size = SIZ(a);\n  mp_size_t  abs_size = ABS(size);\n  mp_ptr     qp;\n\n  qp = MPZ_REALLOC (q, abs_size);\n\n  mpn_bdiv_dbm1 (qp, PTR(a), abs_size, GMP_NUMB_MASK / 5);\n\n  abs_size -= (qp[abs_size-1] == 0);\n  SIZ(q) = (size>0 ? abs_size : -abs_size);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_divexact_limb": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static void\nmpz_divexact_limb (mpz_ptr q, mpz_srcptr a, mp_limb_t d)\n{\n  mp_size_t  size = SIZ(a);\n  mp_size_t  abs_size = ABS(size);\n  mp_ptr     qp;\n\n  qp = MPZ_REALLOC (q, abs_size);\n\n  mpn_divexact_1 (qp, PTR(a), abs_size, d);\n\n  abs_size -= (qp[abs_size-1] == 0);\n  SIZ(q) = (size>0 ? abs_size : -abs_size);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_divexact_gcd": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "void\nmpz_divexact_gcd (mpz_ptr q, mpz_srcptr a, mpz_srcptr d)\n{\n  ASSERT (mpz_sgn (d) > 0);\n\n  if (SIZ(a) == 0)\n    {\n      SIZ(q) = 0;\n      return;\n    }\n\n  if (SIZ(d) == 1)\n    {\n      mp_limb_t  dl = PTR(d)[0];\n      int        twos;\n\n      if ((dl & 1) == 0)\n\t{\n\t  count_trailing_zeros (twos, dl);\n\t  dl >>= twos;\n\t  mpz_tdiv_q_2exp (q, a, twos);\n\t  a = q;\n\t}\n\n      if (dl == 1)\n\t{\n\t  if (q != a)\n\t    mpz_set (q, a);\n\t  return;\n\t}\n#if GMP_NUMB_BITS % 2 == 0\n      if (dl == 3)\n\t{\n\t  mpz_divexact_by3 (q, a);\n\t  return;\n\t}\n#endif\n#if GMP_NUMB_BITS % 4 == 0\n      if (dl == 5)\n\t{\n\t  mpz_divexact_by5 (q, a);\n\t  return;\n\t}\n#endif\n\n      mpz_divexact_limb (q, a, dl);\n      return;\n    }\n\n  mpz_divexact (q, a, d);\n}",
      "lines": 51,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/divexact.c": {
    "mpz_divexact": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\nmpz_divexact (mpz_ptr quot, mpz_srcptr num, mpz_srcptr den)\n{\n  mp_ptr qp;\n  mp_size_t qn;\n  mp_srcptr np, dp;\n  mp_size_t nn, dn;\n  TMP_DECL;\n\n#if WANT_ASSERT\n  {\n    mpz_t  rem;\n    mpz_init (rem);\n    mpz_tdiv_r (rem, num, den);\n    ASSERT (SIZ(rem) == 0);\n    mpz_clear (rem);\n  }\n#endif\n\n  nn = ABSIZ (num);\n  dn = ABSIZ (den);\n\n  if (nn < dn)\n    {\n      /* This special case avoids segfaults below when the function is\n\t incorrectly called with |N| < |D|, N != 0.  It also handles the\n\t well-defined case N = 0.  */\n      SIZ(quot) = 0;\n      return;\n    }\n\n  qn = nn - dn + 1;\n\n  TMP_MARK;\n\n  if (quot == num || quot == den)\n    qp = TMP_ALLOC_LIMBS (qn);\n  else\n    qp = MPZ_REALLOC (quot, qn);\n\n  np = PTR(num);\n  dp = PTR(den);\n\n  mpn_divexact (qp, np, nn, dp, dn);\n  MPN_NORMALIZE (qp, qn);\n\n  if (qp != PTR(quot))\n    MPN_COPY (MPZ_REALLOC (quot, qn), qp, qn);\n\n  SIZ(quot) = (SIZ(num) ^ SIZ(den)) >= 0 ? qn : -qn;\n\n  TMP_FREE;\n}",
      "lines": 53,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/dive_ui.c": {
    "mpz_divexact_ui": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\nmpz_divexact_ui (mpz_ptr dst, mpz_srcptr src, unsigned long divisor)\n{\n  mp_size_t  size, abs_size;\n  mp_ptr     dst_ptr;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  /* For nails don't try to be clever if d is bigger than a limb, just fake\n     up an mpz_t and go to the main mpz_divexact.  */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t  dlimbs[2];\n      mpz_t      dz;\n      ALLOC(dz) = 2;\n      PTR(dz) = dlimbs;\n      mpz_set_ui (dz, divisor);\n      mpz_divexact (dst, src, dz);\n      return;\n    }\n\n  size = SIZ(src);\n  if (size == 0)\n    {\n      SIZ(dst) = 0;\n      return;\n    }\n  abs_size = ABS (size);\n\n  dst_ptr = MPZ_REALLOC (dst, abs_size);\n\n  MPN_DIVREM_OR_DIVEXACT_1 (dst_ptr, PTR(src), abs_size, (mp_limb_t) divisor);\n  abs_size -= (dst_ptr[abs_size-1] == 0);\n  SIZ(dst) = (size >= 0 ? abs_size : -abs_size);\n}",
      "lines": 36,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/divis.c": {
    "mpz_divisible_p": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmpz_divisible_p (mpz_srcptr a, mpz_srcptr d)\n{\n  mp_size_t dsize = SIZ(d);\n  mp_size_t asize = SIZ(a);\n\n  if (UNLIKELY (dsize == 0))\n    return (asize == 0);\n\n  return mpn_divisible_p (PTR(a), ABS(asize), PTR(d), ABS(dsize));\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/divis_2exp.c": {
    "mpz_divisible_2exp_p": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nmpz_divisible_2exp_p (mpz_srcptr a, mp_bitcnt_t d) __GMP_NOTHROW\n{\n  mp_size_t      i, dlimbs;\n  unsigned       dbits;\n  mp_ptr         ap;\n  mp_limb_t      dmask;\n  mp_size_t      asize;\n\n  asize = ABSIZ(a);\n  dlimbs = d / GMP_NUMB_BITS;\n\n  /* if d covers the whole of a, then only a==0 is divisible */\n  if (asize <= dlimbs)\n    return asize == 0;\n\n  /* whole limbs must be zero */\n  ap = PTR(a);\n  for (i = 0; i < dlimbs; i++)\n    if (ap[i] != 0)\n      return 0;\n\n  /* left over bits must be zero */\n  dbits = d % GMP_NUMB_BITS;\n  dmask = (CNST_LIMB(1) << dbits) - 1;\n  return (ap[dlimbs] & dmask) == 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "int",
        "mpz_divisible_2exp_p (mpz_srcptr a, mp_bitcnt_t d)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/divis_ui.c": {
    "mpz_divisible_ui_p": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\nmpz_divisible_ui_p (mpz_srcptr a, unsigned long d)\n{\n  mp_size_t  asize;\n  mp_ptr     ap;\n  unsigned   twos;\n\n  asize = SIZ(a);\n  if (UNLIKELY (d == 0))\n    return (asize == 0);\n\n  if (asize == 0)  /* 0 divisible by any d */\n    return 1;\n\n  /* For nails don't try to be clever if d is bigger than a limb, just fake\n     up an mpz_t and go to the main mpz_divisible_p.  */\n  if (d > GMP_NUMB_MAX)\n    {\n      mp_limb_t  dlimbs[2];\n      mpz_t      dz;\n      ALLOC(dz) = 2;\n      PTR(dz) = dlimbs;\n      mpz_set_ui (dz, d);\n      return mpz_divisible_p (a, dz);\n    }\n\n  ap = PTR(a);\n  asize = ABS(asize);  /* ignore sign of a */\n\n  if (ABOVE_THRESHOLD (asize, BMOD_1_TO_MOD_1_THRESHOLD))\n    return mpn_mod_1 (ap, asize, (mp_limb_t) d) == 0;\n\n  if (! (d & 1))\n    {\n      /* Strip low zero bits to get odd d required by modexact.  If d==e*2^n\n\t and a is divisible by 2^n and by e, then it's divisible by d. */\n\n      if ((ap[0] & LOW_ZEROS_MASK (d)) != 0)\n\treturn 0;\n\n      count_trailing_zeros (twos, (mp_limb_t) d);\n      d >>= twos;\n    }\n\n  return mpn_modexact_1_odd (ap, asize, (mp_limb_t) d) == 0;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/dump.c": {
    "mpz_dump": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nmpz_dump (mpz_srcptr u)\n{\n  char *str;\n\n  str = mpz_get_str (0, 10, u);\n  printf (\"%s\\n\", str);\n  (*__gmp_free_func) (str, strlen (str) + 1);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/export.c": {
    "mpz_export": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "void *\nmpz_export (void *data, size_t *countp, int order,\n\t    size_t size, int endian, size_t nail, mpz_srcptr z)\n{\n  mp_size_t      zsize;\n  mp_srcptr      zp;\n  size_t         count, dummy;\n  unsigned long  numb;\n  unsigned       align;\n\n  ASSERT (order == 1 || order == -1);\n  ASSERT (endian == 1 || endian == 0 || endian == -1);\n  ASSERT (nail <= 8*size);\n  ASSERT (nail <  8*size || SIZ(z) == 0); /* nail < 8*size+(SIZ(z)==0) */\n\n  if (countp == NULL)\n    countp = &dummy;\n\n  zsize = SIZ(z);\n  if (zsize == 0)\n    {\n      *countp = 0;\n      return data;\n    }\n\n  zsize = ABS (zsize);\n  zp = PTR(z);\n  numb = 8*size - nail;\n  MPN_SIZEINBASE_2EXP (count, zp, zsize, numb);\n  *countp = count;\n\n  if (data == NULL)\n    data = (*__gmp_allocate_func) (count*size);\n\n  if (endian == 0)\n    endian = HOST_ENDIAN;\n\n  align = ((char *) data - (char *) NULL) % sizeof (mp_limb_t);\n\n  if (nail == GMP_NAIL_BITS)\n    {\n      if (size == sizeof (mp_limb_t) && align == 0)\n\t{\n\t  if (order == -1 && endian == HOST_ENDIAN)\n\t    {\n\t      MPN_COPY ((mp_ptr) data, zp, (mp_size_t) count);\n\t      return data;\n\t    }\n\t  if (order == 1 && endian == HOST_ENDIAN)\n\t    {\n\t      MPN_REVERSE ((mp_ptr) data, zp, (mp_size_t) count);\n\t      return data;\n\t    }\n\n\t  if (order == -1 && endian == -HOST_ENDIAN)\n\t    {\n\t      MPN_BSWAP ((mp_ptr) data, zp, (mp_size_t) count);\n\t      return data;\n\t    }\n\t  if (order == 1 && endian == -HOST_ENDIAN)\n\t    {\n\t      MPN_BSWAP_REVERSE ((mp_ptr) data, zp, (mp_size_t) count);\n\t      return data;\n\t    }\n\t}\n    }\n\n  {\n    mp_limb_t      limb, wbitsmask;\n    size_t         i, numb;\n    mp_size_t      j, wbytes, woffset;\n    unsigned char  *dp;\n    int            lbits, wbits;\n    mp_srcptr      zend;\n\n    numb = size * 8 - nail;\n\n    /* whole bytes per word */\n    wbytes = numb / 8;\n\n    /* possible partial byte */\n    wbits = numb % 8;\n    wbitsmask = (CNST_LIMB(1) << wbits) - 1;\n\n    /* offset to get to the next word */\n    woffset = (endian >= 0 ? size : - (mp_size_t) size)\n      + (order < 0 ? size : - (mp_size_t) size);\n\n    /* least significant byte */\n    dp = (unsigned char *) data\n      + (order >= 0 ? (count-1)*size : 0) + (endian >= 0 ? size-1 : 0);\n\n#define EXTRACT(N, MASK)                                \\\n    do {                                                \\\n      if (lbits >= (N))                                 \\\n        {                                               \\\n          *dp = limb MASK;                              \\\n          limb >>= (N);                                 \\\n          lbits -= (N);                                 \\\n        }                                               \\\n      else                                              \\\n        {                                               \\\n          mp_limb_t  newlimb;                           \\\n          newlimb = (zp == zend ? 0 : *zp++);           \\\n          *dp = (limb | (newlimb << lbits)) MASK;       \\\n          limb = newlimb >> ((N)-lbits);                \\\n          lbits += GMP_NUMB_BITS - (N);                 \\\n        }                                               \\\n    } while (0)\n\n    zend = zp + zsize;\n    lbits = 0;\n    limb = 0;\n    for (i = 0; i < count; i++)\n      {\n\tfor (j = 0; j < wbytes; j++)\n\t  {\n\t    EXTRACT (8, + 0);\n\t    dp -= endian;\n\t  }\n\tif (wbits != 0)\n\t  {\n\t    EXTRACT (wbits, & wbitsmask);\n\t    dp -= endian;\n\t    j++;\n\t  }\n\tfor ( ; j < size; j++)\n\t  {\n\t    *dp = '\\0';\n\t    dp -= endian;\n\t  }\n\tdp += woffset;\n      }\n\n    ASSERT (zp == PTR(z) + ABSIZ(z));\n\n    /* low byte of word after most significant */\n    ASSERT (dp == (unsigned char *) data\n\t    + (order < 0 ? count*size : - (mp_size_t) size)\n\t    + (endian >= 0 ? (mp_size_t) size - 1 : 0));\n  }\n  return data;\n}",
      "lines": 143,
      "depth": 15,
      "decorators": [
        "void",
        "*\nmpz_export (void *data, size_t *countp, int order,\n\t    size_t size, int endian, size_t nail, mpz_srcptr z)",
        "*"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fac_ui.c": {
    "mpz_fac_ui": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void\nmpz_fac_ui (mpz_ptr x, unsigned long n)\n{\n  static const mp_limb_t table[] = { ONE_LIMB_FACTORIAL_TABLE };\n\n  ASSERT (n <= GMP_NUMB_MAX);\n\n  if (n < numberof (table))\n    {\n      PTR (x)[0] = table[n];\n      SIZ (x) = 1;\n    }\n  else if (BELOW_THRESHOLD (n, FAC_ODD_THRESHOLD))\n    {\n      mp_limb_t prod, max_prod;\n      mp_size_t j;\n      mp_ptr    factors;\n      TMP_SDECL;\n\n      TMP_SMARK;\n      factors = TMP_SALLOC_LIMBS (2 + (n - numberof (table)) / FACTORS_PER_LIMB);\n\n      factors[0] = table[numberof (table)-1];\n      j = 1;\n      prod = n;\n#if TUNE_PROGRAM_BUILD\n      max_prod = GMP_NUMB_MAX / FAC_DSC_THRESHOLD_LIMIT;\n#else\n      max_prod = GMP_NUMB_MAX / (FAC_ODD_THRESHOLD | 1);\n#endif\n      while (--n >= numberof (table))\n\tFACTOR_LIST_STORE (n, prod, max_prod, factors, j);\n\n      factors[j++] = prod;\n      mpz_prodlimbs (x, factors, j);\n\n      TMP_SFREE;\n    }\n  else\n    {\n      mp_limb_t count;\n      mpz_oddfac_1 (x, n, 0);\n      if (n <= TABLE_LIMIT_2N_MINUS_POPC_2N)\n\tcount = __gmp_fac2cnt_table[n / 2 - 1];\n      else\n\t{\n\t  popc_limb (count, n);\n\t  count = n - count;\n\t}\n      mpz_mul_2exp (x, x, count);\n    }\n}",
      "lines": 52,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fdiv_q.c": {
    "mpz_fdiv_q": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\nmpz_fdiv_q (mpz_ptr quot, mpz_srcptr dividend, mpz_srcptr divisor)\n{\n  mp_size_t dividend_size = SIZ (dividend);\n  mp_size_t divisor_size = SIZ (divisor);\n  mpz_t rem;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  MPZ_TMP_INIT (rem, ABS (divisor_size));\n\n  mpz_tdiv_qr (quot, rem, dividend, divisor);\n\n  if ((divisor_size ^ dividend_size) < 0 && SIZ (rem) != 0)\n    mpz_sub_ui (quot, quot, 1L);\n\n  TMP_FREE;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fdiv_qr.c": {
    "mpz_fdiv_qr": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\nmpz_fdiv_qr (mpz_ptr quot, mpz_ptr rem, mpz_srcptr dividend, mpz_srcptr divisor)\n{\n  mp_size_t divisor_size = SIZ (divisor);\n  mp_size_t xsize;\n  mpz_t temp_divisor;\t\t/* N.B.: lives until function returns! */\n  TMP_DECL;\n\n  TMP_MARK;\n\n  /* We need the original value of the divisor after the quotient and\n     remainder have been preliminary calculated.  We have to copy it to\n     temporary space if it's the same variable as either QUOT or REM.  */\n  if (quot == divisor || rem == divisor)\n    {\n      MPZ_TMP_INIT (temp_divisor, ABS (divisor_size));\n      mpz_set (temp_divisor, divisor);\n      divisor = temp_divisor;\n    }\n\n  xsize = SIZ (dividend) ^ divisor_size;;\n  mpz_tdiv_qr (quot, rem, dividend, divisor);\n\n  if (xsize < 0 && SIZ (rem) != 0)\n    {\n      mpz_sub_ui (quot, quot, 1L);\n      mpz_add (rem, rem, divisor);\n    }\n\n  TMP_FREE;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fdiv_qr_ui.c": {
    "mpz_fdiv_qr_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "unsigned long int\nmpz_fdiv_qr_ui (mpz_ptr quot, mpz_ptr rem, mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn, qn;\n  mp_ptr np, qp;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      SIZ(quot) = 0;\n      SIZ(rem) = 0;\n      return 0;\n    }\n\n  nn = ABS(ns);\n  qp = MPZ_REALLOC (quot, nn);\n  np = PTR(dividend);\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2];\n      mp_ptr rp;\n      mp_size_t rn;\n\n      MPZ_REALLOC (rem, 2);\n      rp = PTR(rem);\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  qp[0] = 0;\n\t  qn = 1;\t\t/* a white lie, fixed below */\n\t  rl = np[0];\n\t  rp[0] = rl;\n\t}\n      else\n\t{\n\t  dp[0] = divisor & GMP_NUMB_MASK;\n\t  dp[1] = divisor >> GMP_NUMB_BITS;\n\t  mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n\t  rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n\t  qn = nn - 2 + 1;\n\t}\n\n      if (rl != 0 && ns < 0)\n\t{\n\t  mpn_incr_u (qp, (mp_limb_t) 1);\n\t  rl = divisor - rl;\n\t  rp[0] = rl & GMP_NUMB_MASK;\n\t  rp[1] = rl >> GMP_NUMB_BITS;\n\t}\n\n      qn -= qp[qn - 1] == 0; qn -= qn != 0 && qp[qn - 1] == 0;\n      rn = 1 + (rl > GMP_NUMB_MAX);  rn -= (rp[rn - 1] == 0);\n      SIZ(rem) = rn;\n    }\n  else\n#endif\n    {\n      rl = mpn_divrem_1 (qp, (mp_size_t) 0, np, nn, (mp_limb_t) divisor);\n      if (rl == 0)\n\tSIZ(rem) = 0;\n      else\n\t{\n\t  if (ns < 0)\n\t    {\n\t      mpn_incr_u (qp, (mp_limb_t) 1);\n\t      rl = divisor - rl;\n\t    }\n\n\t  PTR(rem)[0] = rl;\n\t  SIZ(rem) = rl != 0;\n\t}\n      qn = nn - (qp[nn - 1] == 0);\n    }\n\n  SIZ(quot) = ns >= 0 ? qn : -qn;\n  return rl;\n}",
      "lines": 83,
      "depth": 14,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fdiv_q_ui.c": {
    "mpz_fdiv_q_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "unsigned long int\nmpz_fdiv_q_ui (mpz_ptr quot, mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn, qn;\n  mp_ptr np, qp;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      SIZ(quot) = 0;\n      return 0;\n    }\n\n  nn = ABS(ns);\n  qp = MPZ_REALLOC (quot, nn);\n  np = PTR(dividend);\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2], rp[2];\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  qp[0] = 0;\n\t  rl = np[0];\n\t  qn = 1;\t\t/* a white lie, fixed below */\n\t}\n      else\n\t{\n\t  dp[0] = divisor & GMP_NUMB_MASK;\n\t  dp[1] = divisor >> GMP_NUMB_BITS;\n\t  mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n\t  rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n\t  qn = nn - 2 + 1;\n\t}\n\n      if (rl != 0 && ns < 0)\n\t{\n\t  mpn_incr_u (qp, (mp_limb_t) 1);\n\t  rl = divisor - rl;\n\t}\n\n      qn -= qp[qn - 1] == 0; qn -= qn != 0 && qp[qn - 1] == 0;\n    }\n  else\n#endif\n    {\n      rl = mpn_divrem_1 (qp, (mp_size_t) 0, np, nn, (mp_limb_t) divisor);\n\n      if (rl != 0 && ns < 0)\n\t{\n\t  mpn_incr_u (qp, (mp_limb_t) 1);\n\t  rl = divisor - rl;\n\t}\n\n      qn = nn - (qp[nn - 1] == 0);\n    }\n\n  SIZ(quot) = ns >= 0 ? qn : -qn;\n  return rl;\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fdiv_r.c": {
    "mpz_fdiv_r": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nmpz_fdiv_r (mpz_ptr rem, mpz_srcptr dividend, mpz_srcptr divisor)\n{\n  mp_size_t divisor_size = SIZ (divisor);\n  mpz_t temp_divisor;\t\t/* N.B.: lives until function returns! */\n  TMP_DECL;\n\n  TMP_MARK;\n\n  /* We need the original value of the divisor after the remainder has been\n     preliminary calculated.  We have to copy it to temporary space if it's\n     the same variable as REM.  */\n  if (rem == divisor)\n    {\n      MPZ_TMP_INIT (temp_divisor, ABS (divisor_size));\n      mpz_set (temp_divisor, divisor);\n      divisor = temp_divisor;\n    }\n\n  mpz_tdiv_r (rem, dividend, divisor);\n\n  if ((divisor_size ^ SIZ (dividend)) < 0 && SIZ (rem) != 0)\n    mpz_add (rem, rem, divisor);\n\n  TMP_FREE;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fdiv_r_ui.c": {
    "mpz_fdiv_r_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "unsigned long int\nmpz_fdiv_r_ui (mpz_ptr rem, mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn;\n  mp_ptr np;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      SIZ(rem) = 0;\n      return 0;\n    }\n\n  nn = ABS(ns);\n  np = PTR(dividend);\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2];\n      mp_ptr rp, qp;\n      mp_size_t rn;\n      TMP_DECL;\n\n      rp = MPZ_REALLOC (rem, 2);\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  rl = np[0];\n\t  rp[0] = rl;\n\t}\n      else\n\t{\n\t  TMP_MARK;\n\t  dp[0] = divisor & GMP_NUMB_MASK;\n\t  dp[1] = divisor >> GMP_NUMB_BITS;\n\t  qp = TMP_ALLOC_LIMBS (nn - 2 + 1);\n\t  mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n\t  TMP_FREE;\n\t  rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n\t}\n\n      if (rl != 0 && ns < 0)\n\t{\n\t  rl = divisor - rl;\n\t  rp[0] = rl & GMP_NUMB_MASK;\n\t  rp[1] = rl >> GMP_NUMB_BITS;\n\t}\n\n      rn = 1 + (rl > GMP_NUMB_MAX);  rn -= (rp[rn - 1] == 0);\n      SIZ(rem) = rn;\n    }\n  else\n#endif\n    {\n      rl = mpn_mod_1 (np, nn, (mp_limb_t) divisor);\n      if (rl == 0)\n\tSIZ(rem) = 0;\n      else\n\t{\n\t  if (ns < 0)\n\t    rl = divisor - rl;\n\n\t  PTR(rem)[0] = rl;\n\t  SIZ(rem) = 1;\n\t}\n    }\n\n  return rl;\n}",
      "lines": 73,
      "depth": 14,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fdiv_ui.c": {
    "mpz_fdiv_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "unsigned long int\nmpz_fdiv_ui (mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn;\n  mp_ptr np;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      return 0;\n    }\n\n  nn = ABS(ns);\n  np = PTR(dividend);\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2], rp[2];\n      mp_ptr qp;\n      mp_size_t rn;\n      TMP_DECL;\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  rl = np[0];\n\t  rp[0] = rl;\n\t}\n      else\n\t{\n\t  TMP_MARK;\n\t  dp[0] = divisor & GMP_NUMB_MASK;\n\t  dp[1] = divisor >> GMP_NUMB_BITS;\n\t  qp = TMP_ALLOC_LIMBS (nn - 2 + 1);\n\t  mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n\t  TMP_FREE;\n\t  rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n\t}\n\n      if (rl != 0 && ns < 0)\n\t{\n\t  rl = divisor - rl;\n\t  rp[0] = rl & GMP_NUMB_MASK;\n\t  rp[1] = rl >> GMP_NUMB_BITS;\n\t}\n\n      rn = 1 + (rl > GMP_NUMB_MAX);  rn -= (rp[rn - 1] == 0);\n    }\n  else\n#endif\n    {\n      rl = mpn_mod_1 (np, nn, (mp_limb_t) divisor);\n      if (rl == 0)\n\t;\n      else\n\t{\n\t  if (ns < 0)\n\t    rl = divisor - rl;\n\t}\n    }\n\n  return rl;\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fib2_ui.c": {
    "mpz_fib2_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nmpz_fib2_ui (mpz_ptr fn, mpz_ptr fnsub1, unsigned long n)\n{\n  mp_ptr     fp, f1p;\n  mp_size_t  size;\n\n  if (n <= FIB_TABLE_LIMIT)\n    {\n      PTR(fn)[0] = FIB_TABLE (n);\n      SIZ(fn) = (n != 0);      /* F[0]==0, others are !=0 */\n      PTR(fnsub1)[0] = FIB_TABLE ((int) n - 1);\n      SIZ(fnsub1) = (n != 1);  /* F[1-1]==0, others are !=0 */\n      return;\n    }\n\n  size = MPN_FIB2_SIZE (n);\n  fp =  MPZ_NEWALLOC (fn,     size);\n  f1p = MPZ_NEWALLOC (fnsub1, size);\n\n  size = mpn_fib2_ui (fp, f1p, n);\n\n  SIZ(fn)     = size;\n  SIZ(fnsub1) = size - (f1p[size-1] == 0);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fib_ui.c": {
    "mpz_fib_ui": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\nmpz_fib_ui (mpz_ptr fn, unsigned long n)\n{\n  mp_ptr         fp, xp, yp;\n  mp_size_t      size, xalloc;\n  unsigned long  n2;\n  mp_limb_t      c;\n  TMP_DECL;\n\n  if (n <= FIB_TABLE_LIMIT)\n    {\n      PTR(fn)[0] = FIB_TABLE (n);\n      SIZ(fn) = (n != 0);      /* F[0]==0, others are !=0 */\n      return;\n    }\n\n  n2 = n/2;\n  xalloc = MPN_FIB2_SIZE (n2) + 1;\n  fp = MPZ_NEWALLOC (fn, 2 * xalloc);\n\n  TMP_MARK;\n  TMP_ALLOC_LIMBS_2 (xp,xalloc, yp,xalloc);\n  size = mpn_fib2_ui (xp, yp, n2);\n\n  TRACE (printf (\"mpz_fib_ui last step n=%lu size=%ld bit=%lu\\n\",\n\t\t n >> 1, size, n&1);\n\t mpn_trace (\"xp\", xp, size);\n\t mpn_trace (\"yp\", yp, size));\n\n  if (n & 1)\n    {\n      /* F[2k+1] = (2F[k]+F[k-1])*(2F[k]-F[k-1]) + 2*(-1)^k  */\n      mp_size_t  xsize, ysize;\n\n#if HAVE_NATIVE_mpn_add_n_sub_n\n      xp[size] = mpn_lshift (xp, xp, size, 1);\n      yp[size] = 0;\n      ASSERT_NOCARRY (mpn_add_n_sub_n (xp, yp, xp, yp, size+1));\n      xsize = size + (xp[size] != 0);\n      ASSERT (yp[size] <= 1);\n      ysize = size + yp[size];\n#else\n      mp_limb_t  c2;\n\n      c2 = mpn_lshift (fp, xp, size, 1);\n      c = c2 + mpn_add_n (xp, fp, yp, size);\n      xp[size] = c;\n      xsize = size + (c != 0);\n      c2 -= mpn_sub_n (yp, fp, yp, size);\n      yp[size] = c2;\n      ASSERT (c2 <= 1);\n      ysize = size + c2;\n#endif\n\n      size = xsize + ysize;\n      c = mpn_mul (fp, xp, xsize, yp, ysize);\n\n#if GMP_NUMB_BITS >= BITS_PER_ULONG\n      /* no overflow, see comments above */\n      ASSERT (n & 2 ? fp[0] >= 2 : fp[0] <= GMP_NUMB_MAX-2);\n      fp[0] += (n & 2 ? -CNST_LIMB(2) : CNST_LIMB(2));\n#else\n      if (n & 2)\n\t{\n\t  ASSERT (fp[0] >= 2);\n\t  fp[0] -= 2;\n\t}\n      else\n\t{\n\t  ASSERT (c != GMP_NUMB_MAX); /* because it's the high of a mul */\n\t  c += mpn_add_1 (fp, fp, size-1, CNST_LIMB(2));\n\t  fp[size-1] = c;\n\t}\n#endif\n    }\n  else\n    {\n      /* F[2k] = F[k]*(F[k]+2F[k-1]) */\n\n      mp_size_t  xsize, ysize;\n#if HAVE_NATIVE_mpn_addlsh1_n\n      c = mpn_addlsh1_n (yp, xp, yp, size);\n#else\n      c = mpn_lshift (yp, yp, size, 1);\n      c += mpn_add_n (yp, yp, xp, size);\n#endif\n      yp[size] = c;\n      xsize = size;\n      ysize = size + (c != 0);\n      size += ysize;\n      c = mpn_mul (fp, yp, ysize, xp, xsize);\n    }\n\n  /* one or two high zeros */\n  size -= (c == 0);\n  size -= (fp[size-1] == 0);\n  SIZ(fn) = size;\n\n  TRACE (printf (\"done special, size=%ld\\n\", size);\n\t mpn_trace (\"fp \", fp, size));\n\n  TMP_FREE;\n}",
      "lines": 103,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fits_s.h": {
    "FUNCTION": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nFUNCTION (mpz_srcptr z) __GMP_NOTHROW\n{\n  mp_size_t n = SIZ(z);\n  mp_ptr p = PTR(z);\n  mp_limb_t limb = p[0];\n\n  if (n == 0)\n    return 1;\n  if (n == 1)\n    return limb <= MAXIMUM;\n  if (n == -1)\n    return limb <= NEG_CAST (mp_limb_t, MINIMUM);\n#if GMP_NAIL_BITS != 0\n  {\n    if ((p[1] >> GMP_NAIL_BITS) == 0)\n      {\n\tlimb += p[1] << GMP_NUMB_BITS;\n\tif (n == 2)\n\t  return limb <= MAXIMUM;\n\tif (n == -2)\n\t  return limb <= NEG_CAST (mp_limb_t, MINIMUM);\n      }\n  }\n#endif\n  return 0;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "int",
        "FUNCTION (mpz_srcptr z)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/fits_sint.c": {},
  "gmp/gmp-6.1.2/mpz/fits_slong.c": {},
  "gmp/gmp-6.1.2/mpz/fits_sshort.c": {},
  "gmp/gmp-6.1.2/mpz/fits_uint.c": {},
  "gmp/gmp-6.1.2/mpz/fits_ulong.c": {},
  "gmp/gmp-6.1.2/mpz/fits_ushort.c": {},
  "gmp/gmp-6.1.2/mpz/gcd.c": {
    "mpz_gcd": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\nmpz_gcd (mpz_ptr g, mpz_srcptr u, mpz_srcptr v)\n{\n  unsigned long int g_zero_bits, u_zero_bits, v_zero_bits;\n  mp_size_t g_zero_limbs, u_zero_limbs, v_zero_limbs;\n  mp_ptr tp;\n  mp_ptr up;\n  mp_size_t usize;\n  mp_ptr vp;\n  mp_size_t vsize;\n  mp_size_t gsize;\n  TMP_DECL;\n\n  up = PTR(u);\n  usize = ABSIZ (u);\n  vp = PTR(v);\n  vsize = ABSIZ (v);\n  /* GCD(0, V) == V.  */\n  if (usize == 0)\n    {\n      SIZ (g) = vsize;\n      if (g == v)\n\treturn;\n      MPZ_REALLOC (g, vsize);\n      MPN_COPY (PTR (g), vp, vsize);\n      return;\n    }\n\n  /* GCD(U, 0) == U.  */\n  if (vsize == 0)\n    {\n      SIZ (g) = usize;\n      if (g == u)\n\treturn;\n      MPZ_REALLOC (g, usize);\n      MPN_COPY (PTR (g), up, usize);\n      return;\n    }\n\n  if (usize == 1)\n    {\n      SIZ (g) = 1;\n      PTR (g)[0] = mpn_gcd_1 (vp, vsize, up[0]);\n      return;\n    }\n\n  if (vsize == 1)\n    {\n      SIZ(g) = 1;\n      PTR (g)[0] = mpn_gcd_1 (up, usize, vp[0]);\n      return;\n    }\n\n  TMP_MARK;\n\n  /*  Eliminate low zero bits from U and V and move to temporary storage.  */\n  while (*up == 0)\n    up++;\n  u_zero_limbs = up - PTR(u);\n  usize -= u_zero_limbs;\n  count_trailing_zeros (u_zero_bits, *up);\n  tp = up;\n  up = TMP_ALLOC_LIMBS (usize);\n  if (u_zero_bits != 0)\n    {\n      mpn_rshift (up, tp, usize, u_zero_bits);\n      usize -= up[usize - 1] == 0;\n    }\n  else\n    MPN_COPY (up, tp, usize);\n\n  while (*vp == 0)\n    vp++;\n  v_zero_limbs = vp - PTR (v);\n  vsize -= v_zero_limbs;\n  count_trailing_zeros (v_zero_bits, *vp);\n  tp = vp;\n  vp = TMP_ALLOC_LIMBS (vsize);\n  if (v_zero_bits != 0)\n    {\n      mpn_rshift (vp, tp, vsize, v_zero_bits);\n      vsize -= vp[vsize - 1] == 0;\n    }\n  else\n    MPN_COPY (vp, tp, vsize);\n\n  if (u_zero_limbs > v_zero_limbs)\n    {\n      g_zero_limbs = v_zero_limbs;\n      g_zero_bits = v_zero_bits;\n    }\n  else if (u_zero_limbs < v_zero_limbs)\n    {\n      g_zero_limbs = u_zero_limbs;\n      g_zero_bits = u_zero_bits;\n    }\n  else  /*  Equal.  */\n    {\n      g_zero_limbs = u_zero_limbs;\n      g_zero_bits = MIN (u_zero_bits, v_zero_bits);\n    }\n\n  /*  Call mpn_gcd.  The 2nd argument must not have more bits than the 1st.  */\n  vsize = (usize < vsize || (usize == vsize && up[usize-1] < vp[vsize-1]))\n    ? mpn_gcd (vp, vp, vsize, up, usize)\n    : mpn_gcd (vp, up, usize, vp, vsize);\n\n  /*  Here G <-- V << (g_zero_limbs*GMP_LIMB_BITS + g_zero_bits).  */\n  gsize = vsize + g_zero_limbs;\n  if (g_zero_bits != 0)\n    {\n      mp_limb_t cy_limb;\n      gsize += (vp[vsize - 1] >> (GMP_NUMB_BITS - g_zero_bits)) != 0;\n      MPZ_REALLOC (g, gsize);\n      MPN_ZERO (PTR (g), g_zero_limbs);\n\n      tp = PTR(g) + g_zero_limbs;\n      cy_limb = mpn_lshift (tp, vp, vsize, g_zero_bits);\n      if (cy_limb != 0)\n\ttp[vsize] = cy_limb;\n    }\n  else\n    {\n      MPZ_REALLOC (g, gsize);\n      MPN_ZERO (PTR (g), g_zero_limbs);\n      MPN_COPY (PTR (g) + g_zero_limbs, vp, vsize);\n    }\n\n  SIZ (g) = gsize;\n  TMP_FREE;\n}",
      "lines": 131,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/gcdext.c": {
    "mpz_gcdext": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\nmpz_gcdext (mpz_ptr g, mpz_ptr s, mpz_ptr t, mpz_srcptr a, mpz_srcptr b)\n{\n  mp_size_t asize, bsize;\n  mp_ptr tmp_ap, tmp_bp;\n  mp_size_t gsize, ssize, tmp_ssize;\n  mp_ptr gp, tmp_gp, tmp_sp;\n  TMP_DECL;\n\n  /* mpn_gcdext requires that Usize >= Vsize.  Therefore, we often\n     have to swap U and V.  The computed cofactor will be the\n     \"smallest\" one, which is faster to produce.  The wanted one will\n     be computed here; this is needed anyway when both are requested.  */\n\n  asize = ABSIZ (a);\n  bsize = ABSIZ (b);\n\n  if (asize < bsize)\n    {\n      MPZ_SRCPTR_SWAP (a, b);\n      MP_SIZE_T_SWAP (asize, bsize);\n      MPZ_PTR_SWAP (s, t);\n    }\n\n  if (bsize == 0)\n    {\n      /* g = |a|, s = sgn(a), t = 0. */\n      ssize = SIZ (a) >= 0 ? (asize != 0) : -1;\n\n      gp = MPZ_REALLOC (g, asize);\n      MPN_COPY (gp, PTR (a), asize);\n      SIZ (g) = asize;\n\n      if (t != NULL)\n\tSIZ (t) = 0;\n      if (s != NULL)\n\t{\n\t  SIZ (s) = ssize;\n\t  PTR (s)[0] = 1;\n\t}\n      return;\n    }\n\n  TMP_MARK;\n\n  TMP_ALLOC_LIMBS_2 (tmp_ap, asize, tmp_bp, bsize);\n  MPN_COPY (tmp_ap, PTR (a), asize);\n  MPN_COPY (tmp_bp, PTR (b), bsize);\n\n  TMP_ALLOC_LIMBS_2 (tmp_gp, bsize, tmp_sp, bsize + 1);\n\n  gsize = mpn_gcdext (tmp_gp, tmp_sp, &tmp_ssize, tmp_ap, asize, tmp_bp, bsize);\n\n  ssize = ABS (tmp_ssize);\n  tmp_ssize = SIZ (a) >= 0 ? tmp_ssize : -tmp_ssize;\n\n  if (t != NULL)\n    {\n      mpz_t x;\n      __mpz_struct gtmp, stmp;\n\n      PTR (&gtmp) = tmp_gp;\n      SIZ (&gtmp) = gsize;\n\n      PTR (&stmp) = tmp_sp;\n      SIZ (&stmp) = tmp_ssize;\n\n      MPZ_TMP_INIT (x, ssize + asize + 1);\n      mpz_mul (x, &stmp, a);\n      mpz_sub (x, &gtmp, x);\n      mpz_divexact (t, x, b);\n    }\n\n  if (s != NULL)\n    {\n      mp_ptr sp;\n\n      sp = MPZ_REALLOC (s, ssize);\n      MPN_COPY (sp, tmp_sp, ssize);\n      SIZ (s) = tmp_ssize;\n    }\n\n  gp = MPZ_REALLOC (g, gsize);\n  MPN_COPY (gp, tmp_gp, gsize);\n  SIZ (g) = gsize;\n\n  TMP_FREE;\n}",
      "lines": 88,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/gcd_ui.c": {
    "mpz_gcd_ui": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "unsigned long int\nmpz_gcd_ui (mpz_ptr w, mpz_srcptr u, unsigned long int v)\n{\n  mp_size_t un;\n  mp_limb_t res;\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (v > GMP_NUMB_MAX)\n    {\n      mpz_t vz;\n      mp_limb_t vlimbs[2];\n      vlimbs[0] = v & GMP_NUMB_MASK;\n      vlimbs[1] = v >> GMP_NUMB_BITS;\n      PTR(vz) = vlimbs;\n      SIZ(vz) = 2;\n      mpz_gcd (w, u, vz);\n      /* because v!=0 we will have w<=v hence fitting a ulong */\n      ASSERT (mpz_fits_ulong_p (w));\n      return mpz_get_ui (w);\n    }\n#endif\n\n  un = ABSIZ(u);\n\n  if (un == 0)\n    res = v;\n  else if (v == 0)\n    {\n      if (w != NULL)\n\t{\n\t  if (u != w)\n\t    {\n\t      MPZ_REALLOC (w, un);\n\t      MPN_COPY (PTR(w), PTR(u), un);\n\t    }\n\t  SIZ(w) = un;\n\t}\n      /* Return u if it fits a ulong, otherwise 0. */\n      res = PTR(u)[0];\n      return (un == 1 && res <= ULONG_MAX ? res : 0);\n    }\n  else\n    res = mpn_gcd_1 (PTR(u), un, (mp_limb_t) v);\n\n  if (w != NULL)\n    {\n      PTR(w)[0] = res;\n      SIZ(w) = res != 0;\n    }\n  return res;\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/getlimbn.c": {},
  "gmp/gmp-6.1.2/mpz/get_d.c": {
    "mpz_get_d": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "double\nmpz_get_d (mpz_srcptr z)\n{\n  mp_size_t size;\n\n  size = SIZ (z);\n  if (UNLIKELY (size == 0))\n    return 0.0;\n\n  return mpn_get_d (PTR (z), ABS (size), size, 0L);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "double"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/get_d_2exp.c": {
    "mpz_get_d_2exp": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "double\nmpz_get_d_2exp (signed long int *exp2, mpz_srcptr src)\n{\n  mp_size_t size, abs_size;\n  mp_srcptr ptr;\n  long exp;\n\n  size = SIZ(src);\n  if (UNLIKELY (size == 0))\n    {\n      *exp2 = 0;\n      return 0.0;\n    }\n\n  ptr = PTR(src);\n  abs_size = ABS(size);\n  MPN_SIZEINBASE_2EXP(exp, ptr, abs_size, 1);\n  *exp2 = exp;\n  return mpn_get_d (ptr, abs_size, size, -exp);\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "double"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/get_si.c": {
    "mpz_get_si": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "signed long int\nmpz_get_si (mpz_srcptr z) __GMP_NOTHROW\n{\n  mp_ptr zp = PTR (z);\n  mp_size_t size = SIZ (z);\n  mp_limb_t zl = zp[0];\n\n#if GMP_NAIL_BITS != 0\n  if (ULONG_MAX > GMP_NUMB_MAX && ABS (size) >= 2)\n    zl |= zp[1] << GMP_NUMB_BITS;\n#endif\n\n  if (size > 0)\n    return zl & LONG_MAX;\n  else if (size < 0)\n    /* This expression is necessary to properly handle 0x80000000 */\n    return -1 - (long) ((zl - 1) & LONG_MAX);\n  else\n    return 0;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "signed long int",
        "signed",
        "long",
        "int",
        "mpz_get_si (mpz_srcptr z)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/get_str.c": {
    "mpz_get_str": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "char *\nmpz_get_str (char *res_str, int base, mpz_srcptr x)\n{\n  mp_ptr xp;\n  mp_size_t x_size = SIZ (x);\n  char *return_str;\n  size_t str_size;\n  size_t alloc_size = 0;\n  const char *num_to_text;\n  int i;\n  TMP_DECL;\n\n  if (base >= 0)\n    {\n      num_to_text = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n      if (base <= 1)\n\tbase = 10;\n      else if (base > 36)\n\t{\n\t  num_to_text = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\t  if (base > 62)\n\t    return NULL;\n\t}\n    }\n  else\n    {\n      base = -base;\n      if (base <= 1)\n\tbase = 10;\n      else if (base > 36)\n\treturn NULL;\n      num_to_text = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    }\n\n  /* allocate string for the user if necessary */\n  if (res_str == NULL)\n    {\n      /* digits, null terminator, possible minus sign */\n      MPN_SIZEINBASE (alloc_size, PTR(x), ABS(x_size), base);\n      alloc_size += 1 + (x_size<0);\n      res_str = (char *) (*__gmp_allocate_func) (alloc_size);\n    }\n  return_str = res_str;\n\n  if (x_size < 0)\n    {\n      *res_str++ = '-';\n      x_size = -x_size;\n    }\n\n  /* mpn_get_str clobbers its input on non power-of-2 bases */\n  TMP_MARK;\n  xp = PTR (x);\n  if (! POW2_P (base))\n    {\n      xp = TMP_ALLOC_LIMBS (x_size | 1);  /* |1 in case x_size==0 */\n      MPN_COPY (xp, PTR (x), x_size);\n    }\n\n  str_size = mpn_get_str ((unsigned char *) res_str, base, xp, x_size);\n  ASSERT (alloc_size == 0 || str_size <= alloc_size - (SIZ(x) < 0));\n\n  /* Convert result to printable chars.  */\n  for (i = 0; i < str_size; i++)\n    res_str[i] = num_to_text[(int) res_str[i]];\n  res_str[str_size] = 0;\n\n  TMP_FREE;\n\n  /* if allocated then resize down to the actual space required */\n  if (alloc_size != 0)\n    {\n      size_t  actual_size = str_size + 1 + (res_str - return_str);\n      ASSERT (actual_size == strlen (return_str) + 1);\n      __GMP_REALLOCATE_FUNC_MAYBE_TYPE (return_str, alloc_size, actual_size,\n\t\t\t\t\tchar);\n    }\n  return return_str;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "char",
        "*\nmpz_get_str (char *res_str, int base, mpz_srcptr x)",
        "*"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/get_ui.c": {},
  "gmp/gmp-6.1.2/mpz/hamdist.c": {
    "mpz_hamdist": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_hamdist (mpz_srcptr u, mpz_srcptr v) __GMP_NOTHROW\n{\n  mp_srcptr      up, vp;\n  mp_size_t      usize, vsize;\n  mp_bitcnt_t    count;\n\n  usize = SIZ(u);\n  vsize = SIZ(v);\n\n  up = PTR(u);\n  vp = PTR(v);\n\n  if (usize >= 0)\n    {\n      if (vsize < 0)\n\treturn ~ (mp_bitcnt_t) 0;\n\n      /* positive/positive */\n\n      if (usize < vsize)\n\tMPN_SRCPTR_SWAP (up,usize, vp,vsize);\n\n      count = 0;\n      if (vsize != 0)\n\tcount = mpn_hamdist (up, vp, vsize);\n\n      usize -= vsize;\n      if (usize != 0)\n\tcount += mpn_popcount (up + vsize, usize);\n\n      return count;\n    }\n  else\n    {\n      mp_limb_t  ulimb, vlimb;\n      mp_size_t  old_vsize, step;\n\n      if (vsize >= 0)\n\treturn ~ (mp_bitcnt_t) 0;\n\n      /* negative/negative */\n\n      usize = -usize;\n      vsize = -vsize;\n\n      /* skip common low zeros */\n      for (;;)\n\t{\n\t  ASSERT (usize > 0);\n\t  ASSERT (vsize > 0);\n\n\t  usize--;\n\t  vsize--;\n\n\t  ulimb = *up++;\n\t  vlimb = *vp++;\n\n\t  if (ulimb != 0)\n\t    break;\n\n\t  if (vlimb != 0)\n\t    {\n\t      MPN_SRCPTR_SWAP (up,usize, vp,vsize);\n\t      ulimb = vlimb;\n\t      vlimb = 0;\n\t      break;\n\t    }\n\t}\n\n      /* twos complement first non-zero limbs (ulimb is non-zero, but vlimb\n\t might be zero) */\n      ulimb = -ulimb;\n      vlimb = -vlimb;\n      popc_limb (count, (ulimb ^ vlimb) & GMP_NUMB_MASK);\n\n      if (vlimb == 0)\n\t{\n\t  mp_bitcnt_t  twoscount;\n\n\t  /* first non-zero of v */\n\t  old_vsize = vsize;\n\t  do\n\t    {\n\t      ASSERT (vsize > 0);\n\t      vsize--;\n\t      vlimb = *vp++;\n\t    }\n\t  while (vlimb == 0);\n\n\t  /* part of u corresponding to skipped v zeros */\n\t  step = old_vsize - vsize - 1;\n\t  count += step * GMP_NUMB_BITS;\n\t  step = MIN (step, usize);\n\t  if (step != 0)\n\t    {\n\t      count -= mpn_popcount (up, step);\n\t      usize -= step;\n\t      up += step;\n\t    }\n\n\t  /* First non-zero vlimb as twos complement, xor with ones\n\t     complement ulimb.  Note -v^(~0^u) == (v-1)^u. */\n\t  vlimb--;\n\t  if (usize != 0)\n\t    {\n\t      usize--;\n\t      vlimb ^= *up++;\n\t    }\n\t  popc_limb (twoscount, vlimb);\n\t  count += twoscount;\n\t}\n\n      /* Overlapping part of u and v, if any.  Ones complement both, so just\n\t plain hamdist. */\n      step = MIN (usize, vsize);\n      if (step != 0)\n\t{\n\t  count += mpn_hamdist (up, vp, step);\n\t  usize -= step;\n\t  vsize -= step;\n\t  up += step;\n\t  vp += step;\n\t}\n\n      /* Remaining high part of u or v, if any, ones complement but xor\n\t against all ones in the other, so plain popcount. */\n      if (usize != 0)\n\t{\n\tremaining:\n\t  count += mpn_popcount (up, usize);\n\t}\n      else if (vsize != 0)\n\t{\n\t  up = vp;\n\t  usize = vsize;\n\t  goto remaining;\n\t}\n      return count;\n    }\n}",
      "lines": 141,
      "depth": 13,
      "decorators": [
        "mp_bitcnt_t",
        "mpz_hamdist (mpz_srcptr u, mpz_srcptr v)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/import.c": {
    "mpz_import": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void\nmpz_import (mpz_ptr z, size_t count, int order,\n\t    size_t size, int endian, size_t nail, const void *data)\n{\n  mp_size_t  zsize;\n  mp_ptr     zp;\n\n  ASSERT (order == 1 || order == -1);\n  ASSERT (endian == 1 || endian == 0 || endian == -1);\n  ASSERT (nail <= 8*size);\n\n  zsize = BITS_TO_LIMBS (count * (8*size - nail));\n  zp = MPZ_NEWALLOC (z, zsize);\n\n  if (endian == 0)\n    endian = HOST_ENDIAN;\n\n  /* Can't use these special cases with nails currently, since they don't\n     mask out the nail bits in the input data.  */\n  if (nail == 0 && GMP_NAIL_BITS == 0)\n    {\n      unsigned  align = ((char *) data - (char *) NULL) % sizeof (mp_limb_t);\n\n      if (order == -1\n\t  && size == sizeof (mp_limb_t)\n\t  && endian == HOST_ENDIAN\n\t  && align == 0)\n\t{\n\t  MPN_COPY (zp, (mp_srcptr) data, (mp_size_t) count);\n\t  goto done;\n\t}\n\n      if (order == -1\n\t  && size == sizeof (mp_limb_t)\n\t  && endian == - HOST_ENDIAN\n\t  && align == 0)\n\t{\n\t  MPN_BSWAP (zp, (mp_srcptr) data, (mp_size_t) count);\n\t  goto done;\n\t}\n\n      if (order == 1\n\t  && size == sizeof (mp_limb_t)\n\t  && endian == HOST_ENDIAN\n\t  && align == 0)\n\t{\n\t  MPN_REVERSE (zp, (mp_srcptr) data, (mp_size_t) count);\n\t  goto done;\n\t}\n    }\n\n  {\n    mp_limb_t      limb, byte, wbitsmask;\n    size_t         i, j, numb, wbytes;\n    mp_size_t      woffset;\n    unsigned char  *dp;\n    int            lbits, wbits;\n\n    numb = size * 8 - nail;\n\n    /* whole bytes to process */\n    wbytes = numb / 8;\n\n    /* partial byte to process */\n    wbits = numb % 8;\n    wbitsmask = (CNST_LIMB(1) << wbits) - 1;\n\n    /* offset to get to the next word after processing wbytes and wbits */\n    woffset = (numb + 7) / 8;\n    woffset = (endian >= 0 ? woffset : -woffset)\n      + (order < 0 ? size : - (mp_size_t) size);\n\n    /* least significant byte */\n    dp = (unsigned char *) data\n      + (order >= 0 ? (count-1)*size : 0) + (endian >= 0 ? size-1 : 0);\n\n#define ACCUMULATE(N)                                   \\\n    do {                                                \\\n      ASSERT (lbits < GMP_NUMB_BITS);                   \\\n      ASSERT (limb <= (CNST_LIMB(1) << lbits) - 1);     \\\n                                                        \\\n      limb |= (mp_limb_t) byte << lbits;                \\\n      lbits += (N);                                     \\\n      if (lbits >= GMP_NUMB_BITS)                       \\\n        {                                               \\\n          *zp++ = limb & GMP_NUMB_MASK;                 \\\n          lbits -= GMP_NUMB_BITS;                       \\\n          ASSERT (lbits < (N));                         \\\n          limb = byte >> ((N) - lbits);                 \\\n        }                                               \\\n    } while (0)\n\n    limb = 0;\n    lbits = 0;\n    for (i = 0; i < count; i++)\n      {\n\tfor (j = 0; j < wbytes; j++)\n\t  {\n\t    byte = *dp;\n\t    dp -= endian;\n\t    ACCUMULATE (8);\n\t  }\n\tif (wbits != 0)\n\t  {\n\t    byte = *dp & wbitsmask;\n\t    dp -= endian;\n\t    ACCUMULATE (wbits);\n\t  }\n\tdp += woffset;\n      }\n\n    if (lbits != 0)\n      {\n\tASSERT (lbits <= GMP_NUMB_BITS);\n\tASSERT_LIMB (limb);\n\t*zp++ = limb;\n      }\n\n    ASSERT (zp == PTR(z) + zsize);\n\n    /* low byte of word after most significant */\n    ASSERT (dp == (unsigned char *) data\n\t    + (order < 0 ? count*size : - (mp_size_t) size)\n\t    + (endian >= 0 ? (mp_size_t) size - 1 : 0));\n\n  }\n\n done:\n  zp = PTR(z);\n  MPN_NORMALIZE (zp, zsize);\n  SIZ(z) = zsize;\n}",
      "lines": 132,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/init.c": {
    "mpz_init": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nmpz_init (mpz_ptr x)\n{\n  ALLOC (x) = 1;\n  PTR (x) = __GMP_ALLOCATE_FUNC_LIMBS (1);\n  SIZ (x) = 0;\n\n#ifdef __CHECKER__\n  /* let the low limb look initialized, for the benefit of mpz_get_ui etc */\n  PTR (x)[0] = 0;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/init2.c": {
    "mpz_init2": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\nmpz_init2 (mpz_ptr x, mp_bitcnt_t bits)\n{\n  mp_size_t  new_alloc;\n\n  bits -= (bits != 0);\t\t/* Round down, except if 0 */\n  new_alloc = 1 + bits / GMP_NUMB_BITS;\n\n  if (sizeof (unsigned long) > sizeof (int)) /* param vs _mp_size field */\n    {\n      if (UNLIKELY (new_alloc > INT_MAX))\n\t{\n\t  fprintf (stderr, \"gmp: overflow in mpz type\\n\");\n\t  abort ();\n\t}\n    }\n\n  PTR(x) = __GMP_ALLOCATE_FUNC_LIMBS (new_alloc);\n  ALLOC(x) = new_alloc;\n  SIZ(x) = 0;\n\n#ifdef __CHECKER__\n  /* let the low limb look initialized, for the benefit of mpz_get_ui etc */\n  PTR(x)[0] = 0;\n#endif\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/inits.c": {
    "mpz_inits": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\nmpz_inits (mpz_ptr x, ...)\n{\n  va_list  ap;\n\n  va_start (ap, x);\n\n  while (x != NULL)\n    {\n      ALLOC (x) = 1;\n      PTR (x) = __GMP_ALLOCATE_FUNC_LIMBS (1);\n      SIZ (x) = 0;\n\n#ifdef __CHECKER__\n      /* let the low limb look initialized, for the benefit of mpz_get_ui etc */\n      PTR (x)[0] = 0;\n#endif\n\n      x = va_arg (ap, mpz_ptr);\n    }\n\n  va_end (ap);\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/inp_raw.c": {
    "mpz_inp_raw": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "size_t\nmpz_inp_raw (mpz_ptr x, FILE *fp)\n{\n  unsigned char  csize_bytes[4];\n  mp_size_t      csize, abs_xsize, i;\n  size_t         size;\n  size_t         abs_csize;\n  char           *cp;\n  mp_ptr         xp, sp, ep;\n  mp_limb_t      slimb, elimb;\n\n  if (fp == 0)\n    fp = stdin;\n\n  /* 4 bytes for size */\n  if (fread (csize_bytes, sizeof (csize_bytes), 1, fp) != 1)\n    return 0;\n\n  size = (((size_t) csize_bytes[0] << 24) + ((size_t) csize_bytes[1] << 16) +\n\t  ((size_t) csize_bytes[2] << 8)  + ((size_t) csize_bytes[3]));\n\n  if (size < 0x80000000u)\n    csize = size;\n  else\n    csize = size - 0x80000000u - 0x80000000u;\n\n  abs_csize = ABS (csize);\n\n  /* round up to a multiple of limbs */\n  abs_xsize = BITS_TO_LIMBS (abs_csize*8);\n\n  if (abs_xsize != 0)\n    {\n      xp = MPZ_NEWALLOC (x, abs_xsize);\n\n      /* Get limb boundaries right in the read, for the benefit of the\n\t non-nails case.  */\n      xp[0] = 0;\n      cp = (char *) (xp + abs_xsize) - abs_csize;\n      if (fread (cp, abs_csize, 1, fp) != 1)\n\treturn 0;\n\n      if (GMP_NAIL_BITS == 0)\n\t{\n\t  /* Reverse limbs to least significant first, and byte swap.  If\n\t     abs_xsize is odd then on the last iteration elimb and slimb are\n\t     the same.  It doesn't seem extra code to handle that case\n\t     separately, to save an NTOH.  */\n\t  sp = xp;\n\t  ep = xp + abs_xsize-1;\n\t  for (i = 0; i < (abs_xsize+1)/2; i++)\n\t    {\n\t      NTOH_LIMB_FETCH (elimb, ep);\n\t      NTOH_LIMB_FETCH (slimb, sp);\n\t      *sp++ = elimb;\n\t      *ep-- = slimb;\n\t    }\n\t}\n      else\n\t{\n\t  /* It ought to be possible to do the transformation in-place, but\n\t     for now it's easier to use an extra temporary area.  */\n\t  mp_limb_t  byte, limb;\n\t  int\t     bits;\n\t  mp_size_t  tpos;\n\t  mp_ptr     tp;\n\t  TMP_DECL;\n\n\t  TMP_MARK;\n\t  tp = TMP_ALLOC_LIMBS (abs_xsize);\n\t  limb = 0;\n\t  bits = 0;\n\t  tpos = 0;\n\t  for (i = abs_csize-1; i >= 0; i--)\n\t    {\n\t      byte = (unsigned char) cp[i];\n\t      limb |= (byte << bits);\n\t      bits += 8;\n\t      if (bits >= GMP_NUMB_BITS)\n\t\t{\n\t\t  ASSERT (tpos < abs_xsize);\n\t\t  tp[tpos++] = limb & GMP_NUMB_MASK;\n\t\t  bits -= GMP_NUMB_BITS;\n\t\t  ASSERT (bits < 8);\n\t\t  limb = byte >> (8 - bits);\n\t\t}\n\t    }\n\t  if (bits != 0)\n\t    {\n\t      ASSERT (tpos < abs_xsize);\n\t      tp[tpos++] = limb;\n\t    }\n\t  ASSERT (tpos == abs_xsize);\n\n\t  MPN_COPY (xp, tp, abs_xsize);\n\t  TMP_FREE;\n\t}\n\n      /* GMP 1.x mpz_out_raw wrote high zero bytes, strip any high zero\n\t limbs resulting from this.  Should be a non-zero value here, but\n\t for safety don't assume that. */\n      MPN_NORMALIZE (xp, abs_xsize);\n    }\n\n  SIZ(x) = (csize >= 0 ? abs_xsize : -abs_xsize);\n  return abs_csize + 4;\n}",
      "lines": 107,
      "depth": 16,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/inp_str.c": {
    "mpz_inp_str": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "size_t\nmpz_inp_str (mpz_ptr x, FILE *stream, int base)\n{\n  int c;\n  size_t nread;\n\n  if (stream == 0)\n    stream = stdin;\n\n  nread = 0;\n\n  /* Skip whitespace.  */\n  do\n    {\n      c = getc (stream);\n      nread++;\n    }\n  while (isspace (c));\n\n  return mpz_inp_str_nowhite (x, stream, base, c, nread);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    },
    "mpz_inp_str_nowhite": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "size_t\nmpz_inp_str_nowhite (mpz_ptr x, FILE *stream, int base, int c, size_t nread)\n{\n  char *str;\n  size_t alloc_size, str_size;\n  int negative;\n  mp_size_t xsize;\n  const unsigned char *digit_value;\n\n  ASSERT_ALWAYS (EOF == -1);\t/* FIXME: handle this by adding explicit */\n\t\t\t\t/* comparisons of c and EOF before each  */\n\t\t\t\t/* read of digit_value[].  */\n\n  digit_value = digit_value_tab;\n  if (base > 36)\n    {\n      /* For bases > 36, use the collating sequence\n\t 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.  */\n      digit_value += 208;\n      if (base > 62)\n\treturn 0;\t\t/* too large base */\n    }\n\n  negative = 0;\n  if (c == '-')\n    {\n      negative = 1;\n      c = getc (stream);\n      nread++;\n    }\n\n  if (c == EOF || digit_value[c] >= (base == 0 ? 10 : base))\n    return 0;\t\t\t/* error if no digits */\n\n  /* If BASE is 0, try to find out the base by looking at the initial\n     characters.  */\n  if (base == 0)\n    {\n      base = 10;\n      if (c == '0')\n\t{\n\t  base = 8;\n\t  c = getc (stream);\n\t  nread++;\n\t  if (c == 'x' || c == 'X')\n\t    {\n\t      base = 16;\n\t      c = getc (stream);\n\t      nread++;\n\t    }\n\t  else if (c == 'b' || c == 'B')\n\t    {\n\t      base = 2;\n\t      c = getc (stream);\n\t      nread++;\n\t    }\n\t}\n    }\n\n  /* Skip leading zeros.  */\n  while (c == '0')\n    {\n      c = getc (stream);\n      nread++;\n    }\n\n  alloc_size = 100;\n  str = (char *) (*__gmp_allocate_func) (alloc_size);\n  str_size = 0;\n\n  while (c != EOF)\n    {\n      int dig;\n      dig = digit_value[c];\n      if (dig >= base)\n\tbreak;\n      if (str_size >= alloc_size)\n\t{\n\t  size_t old_alloc_size = alloc_size;\n\t  alloc_size = alloc_size * 3 / 2;\n\t  str = (char *) (*__gmp_reallocate_func) (str, old_alloc_size, alloc_size);\n\t}\n      str[str_size++] = dig;\n      c = getc (stream);\n    }\n  nread += str_size;\n\n  ungetc (c, stream);\n  nread--;\n\n  /* Make sure the string is not empty, mpn_set_str would fail.  */\n  if (str_size == 0)\n    {\n      SIZ (x) = 0;\n    }\n  else\n    {\n      LIMBS_PER_DIGIT_IN_BASE (xsize, str_size, base);\n      MPZ_REALLOC (x, xsize);\n\n      /* Convert the byte array in base BASE to our bignum format.  */\n      xsize = mpn_set_str (PTR (x), (unsigned char *) str, str_size, base);\n      SIZ (x) = negative ? -xsize : xsize;\n    }\n  (*__gmp_free_func) (str, alloc_size);\n  return nread;\n}",
      "lines": 107,
      "depth": 14,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/invert.c": {
    "mpz_invert": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nmpz_invert (mpz_ptr inverse, mpz_srcptr x, mpz_srcptr n)\n{\n  mpz_t gcd, tmp;\n  mp_size_t xsize, nsize, size;\n  TMP_DECL;\n\n  xsize = ABSIZ (x);\n  nsize = ABSIZ (n);\n\n  size = MAX (xsize, nsize) + 1;\n  TMP_MARK;\n\n  MPZ_TMP_INIT (gcd, size);\n  MPZ_TMP_INIT (tmp, size);\n  mpz_gcdext (gcd, tmp, (mpz_ptr) 0, x, n);\n\n  /* If no inverse existed, return with an indication of that.  */\n  if (!MPZ_EQUAL_1_P (gcd))\n    {\n      TMP_FREE;\n      return 0;\n    }\n\n  /* Make sure we return a positive inverse.  */\n  if (SIZ (tmp) < 0)\n    {\n      if (SIZ (n) < 0)\n\tmpz_sub (inverse, tmp, n);\n      else\n\tmpz_add (inverse, tmp, n);\n    }\n  else\n    mpz_set (inverse, tmp);\n\n  TMP_FREE;\n  return 1;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/ior.c": {
    "mpz_ior": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "void\nmpz_ior (mpz_ptr res, mpz_srcptr op1, mpz_srcptr op2)\n{\n  mp_srcptr op1_ptr, op2_ptr;\n  mp_size_t op1_size, op2_size;\n  mp_ptr res_ptr;\n  mp_size_t res_size;\n  mp_size_t i;\n  TMP_DECL;\n\n  TMP_MARK;\n  op1_size = SIZ(op1);\n  op2_size = SIZ(op2);\n\n  op1_ptr = PTR(op1);\n  op2_ptr = PTR(op2);\n  res_ptr = PTR(res);\n\n  if (op1_size >= 0)\n    {\n      if (op2_size >= 0)\n\t{\n\t  if (op1_size >= op2_size)\n\t    {\n\t      if (ALLOC(res) < op1_size)\n\t\t{\n\t\t  res_ptr = MPZ_REALLOC (res, op1_size);\n\t\t  /* No overlapping possible: op1_ptr = PTR(op1); */\n\t\t  op2_ptr = PTR(op2);\n\t\t}\n\n\t      if (res_ptr != op1_ptr)\n\t\tMPN_COPY (res_ptr + op2_size, op1_ptr + op2_size,\n\t\t\t  op1_size - op2_size);\n\t      if (LIKELY (op2_size != 0))\n\t\tmpn_ior_n (res_ptr, op1_ptr, op2_ptr, op2_size);\n\t      res_size = op1_size;\n\t    }\n\t  else\n\t    {\n\t      if (ALLOC(res) < op2_size)\n\t\t{\n\t\t  res_ptr = MPZ_REALLOC (res, op2_size);\n\t\t  op1_ptr = PTR(op1);\n\t\t  /* No overlapping possible: op2_ptr = PTR(op2); */\n\t\t}\n\n\t      if (res_ptr != op2_ptr)\n\t\tMPN_COPY (res_ptr + op1_size, op2_ptr + op1_size,\n\t\t\t  op2_size - op1_size);\n\t      if (LIKELY (op1_size != 0))\n\t\tmpn_ior_n (res_ptr, op1_ptr, op2_ptr, op1_size);\n\t      res_size = op2_size;\n\t    }\n\n\t  SIZ(res) = res_size;\n\t  return;\n\t}\n      else /* op2_size < 0 */\n\t{\n\t  /* Fall through to the code at the end of the function.  */\n\t}\n    }\n  else\n    {\n      if (op2_size < 0)\n\t{\n\t  mp_ptr opx, opy;\n\n\t  /* Both operands are negative, so will be the result.\n\t     -((-OP1) | (-OP2)) = -(~(OP1 - 1) | ~(OP2 - 1)) =\n\t     = ~(~(OP1 - 1) | ~(OP2 - 1)) + 1 =\n\t     = ((OP1 - 1) & (OP2 - 1)) + 1      */\n\n\t  op1_size = -op1_size;\n\t  op2_size = -op2_size;\n\n\t  res_size = MIN (op1_size, op2_size);\n\n\t  /* Possible optimization: Decrease mpn_sub precision,\n\t     as we won't use the entire res of both.  */\n\t  TMP_ALLOC_LIMBS_2 (opx, res_size, opy, res_size);\n\t  mpn_sub_1 (opx, op1_ptr, res_size, (mp_limb_t) 1);\n\t  op1_ptr = opx;\n\n\t  mpn_sub_1 (opy, op2_ptr, res_size, (mp_limb_t) 1);\n\t  op2_ptr = opy;\n\n\t  /* First loop finds the size of the result.  */\n\t  for (i = res_size - 1; i >= 0; i--)\n\t    if ((op1_ptr[i] & op2_ptr[i]) != 0)\n\t      break;\n\t  res_size = i + 1;\n\n\t  if (res_size != 0)\n\t    {\n\t      res_ptr = MPZ_NEWALLOC (res, res_size + 1);\n\n\t      /* Second loop computes the real result.  */\n\t      mpn_and_n (res_ptr, op1_ptr, op2_ptr, res_size);\n\n\t      res_ptr[res_size] = 0;\n\t      MPN_INCR_U (res_ptr, res_size + 1, 1);\n\t      res_size += res_ptr[res_size];\n\t    }\n\t  else\n\t    {\n\t      res_ptr[0] = 1;\n\t      res_size = 1;\n\t    }\n\n\t  SIZ(res) = -res_size;\n\t  TMP_FREE;\n\t  return;\n\t}\n      else\n\t{\n\t  /* We should compute -OP1 | OP2.  Swap OP1 and OP2 and fall\n\t     through to the code that handles OP1 | -OP2.  */\n\t  MPZ_SRCPTR_SWAP (op1, op2);\n\t  MPN_SRCPTR_SWAP (op1_ptr,op1_size, op2_ptr,op2_size);\n\t}\n    }\n\n  {\n    mp_ptr opx;\n    mp_limb_t cy;\n    mp_size_t res_alloc;\n    mp_size_t count;\n\n    /* Operand 2 negative, so will be the result.\n       -(OP1 | (-OP2)) = -(OP1 | ~(OP2 - 1)) =\n       = ~(OP1 | ~(OP2 - 1)) + 1 =\n       = (~OP1 & (OP2 - 1)) + 1      */\n\n    op2_size = -op2_size;\n\n    res_alloc = op2_size;\n\n    opx = TMP_ALLOC_LIMBS (op2_size);\n    mpn_sub_1 (opx, op2_ptr, op2_size, (mp_limb_t) 1);\n    op2_ptr = opx;\n    op2_size -= op2_ptr[op2_size - 1] == 0;\n\n    if (ALLOC(res) < res_alloc)\n      {\n\t_mpz_realloc (res, res_alloc);\n\top1_ptr = PTR(op1);\n\t/* op2_ptr points to temporary space.  */\n\tres_ptr = PTR(res);\n      }\n\n    if (op1_size >= op2_size)\n      {\n\t/* We can just ignore the part of OP1 that stretches above OP2,\n\t   because the result limbs are zero there.  */\n\n\t/* First loop finds the size of the result.  */\n\tfor (i = op2_size - 1; i >= 0; i--)\n\t  if ((~op1_ptr[i] & op2_ptr[i]) != 0)\n\t    break;\n\tres_size = i + 1;\n\tcount = res_size;\n      }\n    else\n      {\n\tres_size = op2_size;\n\n\t/* Copy the part of OP2 that stretches above OP1, to RES.  */\n\tMPN_COPY (res_ptr + op1_size, op2_ptr + op1_size, op2_size - op1_size);\n\tcount = op1_size;\n      }\n\n    if (res_size != 0)\n      {\n\t/* Second loop computes the real result.  */\n\tif (LIKELY (count != 0))\n\t  mpn_andn_n (res_ptr, op2_ptr, op1_ptr, count);\n\n\tcy = mpn_add_1 (res_ptr, res_ptr, res_size, (mp_limb_t) 1);\n\tif (cy)\n\t  {\n\t    res_ptr[res_size] = cy;\n\t    res_size++;\n\t  }\n      }\n    else\n      {\n\tres_ptr[0] = 1;\n\tres_size = 1;\n      }\n\n    SIZ(res) = -res_size;\n  }\n  TMP_FREE;\n}",
      "lines": 196,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/iset.c": {
    "mpz_init_set": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nmpz_init_set (mpz_ptr w, mpz_srcptr u)\n{\n  mp_ptr wp, up;\n  mp_size_t usize, size;\n\n  usize = SIZ (u);\n  size = ABS (usize);\n\n  ALLOC (w) = MAX (size, 1);\n  PTR (w) = __GMP_ALLOCATE_FUNC_LIMBS (ALLOC (w));\n\n  wp = PTR (w);\n  up = PTR (u);\n\n  MPN_COPY (wp, up, size);\n  SIZ (w) = usize;\n\n#ifdef __CHECKER__\n  /* let the low limb look initialized, for the benefit of mpz_get_ui etc */\n  if (size == 0)\n    wp[0] = 0;\n#endif\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/iset_d.c": {
    "mpz_init_set_d": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void\nmpz_init_set_d (mpz_ptr dest, double val)\n{\n  ALLOC (dest) = 1;\n  PTR (dest) = __GMP_ALLOCATE_FUNC_LIMBS (1);\n  SIZ (dest) = 0;\n  mpz_set_d (dest, val);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/iset_si.c": {
    "mpz_init_set_si": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nmpz_init_set_si (mpz_ptr dest, signed long int val)\n{\n  mp_size_t size;\n  mp_limb_t vl;\n\n  ALLOC (dest) = 1;\n  PTR (dest) = __GMP_ALLOCATE_FUNC_LIMBS (1);\n\n  vl = (mp_limb_t) ABS_CAST (unsigned long int, val);\n\n  PTR (dest)[0] = vl & GMP_NUMB_MASK;\n  size = vl != 0;\n\n#if GMP_NAIL_BITS != 0\n  if (vl > GMP_NUMB_MAX)\n    {\n      MPZ_REALLOC (dest, 2);\n      PTR (dest)[1] = vl >> GMP_NUMB_BITS;\n      size = 2;\n    }\n#endif\n\n  SIZ (dest) = val >= 0 ? size : -size;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/iset_str.c": {
    "mpz_init_set_str": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmpz_init_set_str (mpz_ptr x, const char *str, int base)\n{\n  ALLOC (x) = 1;\n  PTR (x) = __GMP_ALLOCATE_FUNC_LIMBS (1);\n\n  /* if str has no digits mpz_set_str leaves x->_mp_size unset */\n  SIZ (x) = 0;\n\n#ifdef __CHECKER__\n  /* let the low limb look initialized, for the benefit of mpz_get_ui etc */\n  PTR (x)[0] = 0;\n#endif\n\n  return mpz_set_str (x, str, base);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/iset_ui.c": {
    "mpz_init_set_ui": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nmpz_init_set_ui (mpz_ptr dest, unsigned long int val)\n{\n  mp_size_t size;\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (val > GMP_NUMB_MAX)\n    {\n      ALLOC (dest) = 2;\n      PTR (dest) = __GMP_ALLOCATE_FUNC_LIMBS (2);\n      PTR (dest)[1] = val >> GMP_NUMB_BITS;\n      size = 2;\n    }\n  else\n#endif\n    {\n      ALLOC (dest) = 1;\n      PTR (dest) = __GMP_ALLOCATE_FUNC_LIMBS (1);\n\n      size = val != 0;\n    }\n  PTR (dest)[0] = val & GMP_NUMB_MASK;\n\n  SIZ (dest) = size;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/jacobi.c": {
    "mpz_jacobi": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "int\nmpz_jacobi (mpz_srcptr a, mpz_srcptr b)\n{\n  mp_srcptr  asrcp, bsrcp;\n  mp_size_t  asize, bsize;\n  mp_limb_t  alow, blow;\n  mp_ptr     ap, bp;\n  unsigned   btwos;\n  int        result_bit1;\n  int        res;\n  TMP_DECL;\n\n  asize = SIZ(a);\n  asrcp = PTR(a);\n  alow = asrcp[0];\n\n  bsize = SIZ(b);\n  bsrcp = PTR(b);\n  blow = bsrcp[0];\n\n  /* The MPN jacobi functions require positive a and b, and b odd. So\n     we must to handle the cases of a or b zero, then signs, and then\n     the case of even b.\n  */\n\n  if (bsize == 0)\n    /* (a/0) = [ a = 1 or a = -1 ] */\n    return JACOBI_LS0 (alow, asize);\n\n  if (asize == 0)\n    /* (0/b) = [ b = 1 or b = - 1 ] */\n    return JACOBI_0LS (blow, bsize);\n\n  if ( (((alow | blow) & 1) == 0))\n    /* Common factor of 2 ==> (a/b) = 0 */\n    return 0;\n\n  if (bsize < 0)\n    {\n      /* (a/-1) = -1 if a < 0, +1 if a >= 0 */\n      result_bit1 = (asize < 0) << 1;\n      bsize = -bsize;\n    }\n  else\n    result_bit1 = 0;\n\n  JACOBI_STRIP_LOW_ZEROS (result_bit1, alow, bsrcp, bsize, blow);\n\n  count_trailing_zeros (btwos, blow);\n  blow >>= btwos;\n\n  if (bsize > 1 && btwos > 0)\n    {\n      mp_limb_t b1 = bsrcp[1];\n      blow |= b1 << (GMP_NUMB_BITS - btwos);\n      if (bsize == 2 && (b1 >> btwos) == 0)\n\tbsize = 1;\n    }\n\n  if (asize < 0)\n    {\n      /* (-1/b) = -1 iff b = 3 (mod 4) */\n      result_bit1 ^= JACOBI_N1B_BIT1(blow);\n      asize = -asize;\n    }\n\n  JACOBI_STRIP_LOW_ZEROS (result_bit1, blow, asrcp, asize, alow);\n\n  /* Ensure asize >= bsize. Take advantage of the generalized\n     reciprocity law (a/b*2^n) = (b*2^n / a) * RECIP(a,b) */\n\n  if (asize < bsize)\n    {\n      MPN_SRCPTR_SWAP (asrcp, asize, bsrcp, bsize);\n      MP_LIMB_T_SWAP (alow, blow);\n\n      /* NOTE: The value of alow (old blow) is a bit subtle. For this code\n\t path, we get alow as the low, always odd, limb of shifted A. Which is\n\t what we need for the reciprocity update below.\n\n\t However, all other uses of alow assumes that it is *not*\n\t shifted. Luckily, alow matters only when either\n\n\t + btwos > 0, in which case A is always odd\n\n\t + asize == bsize == 1, in which case this code path is never\n\t   taken. */\n\n      count_trailing_zeros (btwos, blow);\n      blow >>= btwos;\n\n      if (bsize > 1 && btwos > 0)\n\t{\n\t  mp_limb_t b1 = bsrcp[1];\n\t  blow |= b1 << (GMP_NUMB_BITS - btwos);\n\t  if (bsize == 2 && (b1 >> btwos) == 0)\n\t    bsize = 1;\n\t}\n\n      result_bit1 ^= JACOBI_RECIP_UU_BIT1 (alow, blow);\n    }\n\n  if (bsize == 1)\n    {\n      result_bit1 ^= JACOBI_TWOS_U_BIT1(btwos, alow);\n\n      if (blow == 1)\n\treturn JACOBI_BIT1_TO_PN (result_bit1);\n\n      if (asize > 1)\n\tJACOBI_MOD_OR_MODEXACT_1_ODD (result_bit1, alow, asrcp, asize, blow);\n\n      return mpn_jacobi_base (alow, blow, result_bit1);\n    }\n\n  /* Allocation strategy: For A, we allocate a working copy only for A % B, but\n     when A is much larger than B, we have to allocate space for the large\n     quotient. We use the same area, pointed to by bp, for both the quotient\n     A/B and the working copy of B. */\n\n  TMP_MARK;\n\n  if (asize >= 2*bsize)\n    TMP_ALLOC_LIMBS_2 (ap, bsize, bp, asize - bsize + 1);\n  else\n    TMP_ALLOC_LIMBS_2 (ap, bsize, bp, bsize);\n\n  /* In the case of even B, we conceptually shift out the powers of two first,\n     and then divide A mod B. Hence, when taking those powers of two into\n     account, we must use alow *before* the division. Doing the actual division\n     first is ok, because the point is to remove multiples of B from A, and\n     multiples of 2^k B are good enough. */\n  if (asize > bsize)\n    mpn_tdiv_qr (bp, ap, 0, asrcp, asize, bsrcp, bsize);\n  else\n    MPN_COPY (ap, asrcp, bsize);\n\n  if (btwos > 0)\n    {\n      result_bit1 ^= JACOBI_TWOS_U_BIT1(btwos, alow);\n\n      ASSERT_NOCARRY (mpn_rshift (bp, bsrcp, bsize, btwos));\n      bsize -= (ap[bsize-1] | bp[bsize-1]) == 0;\n    }\n  else\n    MPN_COPY (bp, bsrcp, bsize);\n\n  ASSERT (blow == bp[0]);\n  res = mpn_jacobi_n (ap, bp, bsize,\n\t\t      mpn_jacobi_init (ap[0], blow, (result_bit1>>1) & 1));\n\n  TMP_FREE;\n  return res;\n}",
      "lines": 154,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/kronsz.c": {
    "mpz_si_kronecker": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nmpz_si_kronecker (long a, mpz_srcptr b)\n{\n  mp_srcptr  b_ptr;\n  mp_limb_t  b_low;\n  mp_size_t  b_size;\n  mp_size_t  b_abs_size;\n  mp_limb_t  a_limb, b_rem;\n  unsigned   twos;\n  int        result_bit1;\n\n#if GMP_NUMB_BITS < BITS_PER_ULONG\n  if (a > GMP_NUMB_MAX || a < -GMP_NUMB_MAX)\n    {\n      mp_limb_t  alimbs[2];\n      mpz_t      az;\n      ALLOC(az) = numberof (alimbs);\n      PTR(az) = alimbs;\n      mpz_set_si (az, a);\n      return mpz_kronecker (az, b);\n    }\n#endif\n\n  b_size = SIZ (b);\n  if (b_size == 0)\n    return JACOBI_S0 (a);  /* (a/0) */\n\n  /* account for the effect of the sign of b, then ignore it */\n  result_bit1 = JACOBI_BSGN_SS_BIT1 (a, b_size);\n\n  b_ptr = PTR(b);\n  b_low = b_ptr[0];\n  b_abs_size = ABS (b_size);\n\n  if ((b_low & 1) != 0)\n    {\n      /* b odd */\n\n      result_bit1 ^= JACOBI_ASGN_SU_BIT1 (a, b_low);\n      a_limb = ABS_CAST(mp_limb_t, a);\n\n      if ((a_limb & 1) == 0)\n\t{\n\t  /* (0/b)=1 for b=+/-1, 0 otherwise */\n\t  if (a_limb == 0)\n\t    return (b_abs_size == 1 && b_low == 1);\n\n\t  /* a even, b odd */\n\t  count_trailing_zeros (twos, a_limb);\n\t  a_limb >>= twos;\n\t  /* (a*2^n/b) = (a/b) * twos(n,a) */\n\t  result_bit1 ^= JACOBI_TWOS_U_BIT1 (twos, b_low);\n\t}\n    }\n  else\n    {\n      /* (even/even)=0, and (0/b)=0 for b!=+/-1 */\n      if ((a & 1) == 0)\n\treturn 0;\n\n      /* a odd, b even\n\n\t Establish shifted b_low with valid bit1 for ASGN and RECIP below.\n\t Zero limbs stripped are accounted for, but zero bits on b_low are\n\t not because they remain in {b_ptr,b_abs_size} for the\n\t JACOBI_MOD_OR_MODEXACT_1_ODD. */\n\n      JACOBI_STRIP_LOW_ZEROS (result_bit1, a, b_ptr, b_abs_size, b_low);\n      if ((b_low & 1) == 0)\n\t{\n\t  if (UNLIKELY (b_low == GMP_NUMB_HIGHBIT))\n\t    {\n\t      /* need b_ptr[1] to get bit1 in b_low */\n\t      if (b_abs_size == 1)\n\t\t{\n\t\t  /* (a/0x80000000) = (a/2)^(BPML-1) */\n\t\t  if ((GMP_NUMB_BITS % 2) == 0)\n\t\t    result_bit1 ^= JACOBI_TWO_U_BIT1 (a);\n\t\t  return JACOBI_BIT1_TO_PN (result_bit1);\n\t\t}\n\n\t      /* b_abs_size > 1 */\n\t      b_low = b_ptr[1] << 1;\n\t    }\n\t  else\n\t    {\n\t      count_trailing_zeros (twos, b_low);\n\t      b_low >>= twos;\n\t    }\n\t}\n\n      result_bit1 ^= JACOBI_ASGN_SU_BIT1 (a, b_low);\n      a_limb = (unsigned long) ABS(a);\n    }\n\n  if (a_limb == 1)\n    return JACOBI_BIT1_TO_PN (result_bit1);  /* (1/b)=1 */\n\n  /* (a/b*2^n) = (b*2^n mod a / a) * recip(a,b) */\n  JACOBI_MOD_OR_MODEXACT_1_ODD (result_bit1, b_rem, b_ptr, b_abs_size, a_limb);\n  result_bit1 ^= JACOBI_RECIP_UU_BIT1 (a_limb, b_low);\n  return mpn_jacobi_base (b_rem, a_limb, result_bit1);\n}",
      "lines": 103,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/kronuz.c": {
    "mpz_ui_kronecker": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\nmpz_ui_kronecker (unsigned long a, mpz_srcptr b)\n{\n  mp_srcptr  b_ptr;\n  mp_limb_t  b_low;\n  int        b_abs_size;\n  mp_limb_t  b_rem;\n  int        twos;\n  int        result_bit1;\n\n  /* (a/-1)=1 when a>=0, so the sign of b is ignored */\n  b_abs_size = ABSIZ (b);\n\n  if (b_abs_size == 0)\n    return JACOBI_U0 (a);  /* (a/0) */\n\n  if (a > GMP_NUMB_MAX)\n    {\n      mp_limb_t  alimbs[2];\n      mpz_t      az;\n      ALLOC(az) = numberof (alimbs);\n      PTR(az) = alimbs;\n      mpz_set_ui (az, a);\n      return mpz_kronecker (az, b);\n    }\n\n  b_ptr = PTR(b);\n  b_low = b_ptr[0];\n  result_bit1 = 0;\n\n  if (! (b_low & 1))\n    {\n      /* (0/b)=0 for b!=+/-1; and (even/even)=0 */\n      if (! (a & 1))\n\treturn 0;\n\n      /* a odd, b even\n\n\t Establish shifted b_low with valid bit1 for the RECIP below.  Zero\n\t limbs stripped are accounted for, but zero bits on b_low are not\n\t because they remain in {b_ptr,b_abs_size} for\n\t JACOBI_MOD_OR_MODEXACT_1_ODD. */\n\n      JACOBI_STRIP_LOW_ZEROS (result_bit1, a, b_ptr, b_abs_size, b_low);\n      if (! (b_low & 1))\n\t{\n\t  if (UNLIKELY (b_low == GMP_NUMB_HIGHBIT))\n\t    {\n\t      /* need b_ptr[1] to get bit1 in b_low */\n\t      if (b_abs_size == 1)\n\t\t{\n\t\t  /* (a/0x80...00) == (a/2)^(NUMB-1) */\n\t\t  if ((GMP_NUMB_BITS % 2) == 0)\n\t\t    {\n\t\t      /* JACOBI_STRIP_LOW_ZEROS does nothing to result_bit1\n\t\t\t when GMP_NUMB_BITS is even, so it's still 0. */\n\t\t      ASSERT (result_bit1 == 0);\n\t\t      result_bit1 = JACOBI_TWO_U_BIT1 (a);\n\t\t    }\n\t\t  return JACOBI_BIT1_TO_PN (result_bit1);\n\t\t}\n\n\t      /* b_abs_size > 1 */\n\t      b_low = b_ptr[1] << 1;\n\t    }\n\t  else\n\t    {\n\t      count_trailing_zeros (twos, b_low);\n\t      b_low >>= twos;\n\t    }\n\t}\n    }\n  else\n    {\n      if (a == 0)        /* (0/b)=1 for b=+/-1, 0 otherwise */\n\treturn (b_abs_size == 1 && b_low == 1);\n\n      if (! (a & 1))\n\t{\n\t  /* a even, b odd */\n\t  count_trailing_zeros (twos, a);\n\t  a >>= twos;\n\t  /* (a*2^n/b) = (a/b) * (2/a)^n */\n\t  result_bit1 = JACOBI_TWOS_U_BIT1 (twos, b_low);\n\t}\n    }\n\n  if (a == 1)\n    return JACOBI_BIT1_TO_PN (result_bit1);  /* (1/b)=1 */\n\n  /* (a/b*2^n) = (b*2^n mod a / a) * RECIP(a,b) */\n  JACOBI_MOD_OR_MODEXACT_1_ODD (result_bit1, b_rem, b_ptr, b_abs_size, a);\n  result_bit1 ^= JACOBI_RECIP_UU_BIT1 (a, b_low);\n  return mpn_jacobi_base (b_rem, (mp_limb_t) a, result_bit1);\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/kronzs.c": {
    "mpz_kronecker_si": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\nmpz_kronecker_si (mpz_srcptr a, long b)\n{\n  mp_srcptr  a_ptr;\n  mp_size_t  a_size;\n  mp_limb_t  a_rem, b_limb;\n  int        result_bit1;\n\n  a_size = SIZ(a);\n  if (a_size == 0)\n    return JACOBI_0S (b);\n\n#if GMP_NUMB_BITS < BITS_PER_ULONG\n  if (b > GMP_NUMB_MAX || b < -GMP_NUMB_MAX)\n    {\n      mp_limb_t  blimbs[2];\n      mpz_t      bz;\n      ALLOC(bz) = numberof (blimbs);\n      PTR(bz) = blimbs;\n      mpz_set_si (bz, b);\n      return mpz_kronecker (a, bz);\n    }\n#endif\n\n  result_bit1 = JACOBI_BSGN_SS_BIT1 (a_size, b);\n  b_limb = ABS_CAST (unsigned long, b);\n  a_ptr = PTR(a);\n\n  if ((b_limb & 1) == 0)\n    {\n      mp_limb_t  a_low = a_ptr[0];\n      int        twos;\n\n      if (b_limb == 0)\n\treturn JACOBI_LS0 (a_low, a_size);   /* (a/0) */\n\n      if (! (a_low & 1))\n\treturn 0;  /* (even/even)=0 */\n\n      /* (a/2)=(2/a) for a odd */\n      count_trailing_zeros (twos, b_limb);\n      b_limb >>= twos;\n      result_bit1 ^= JACOBI_TWOS_U_BIT1 (twos, a_low);\n    }\n\n  if (b_limb == 1)\n    return JACOBI_BIT1_TO_PN (result_bit1);  /* (a/1)=1 for any a */\n\n  result_bit1 ^= JACOBI_ASGN_SU_BIT1 (a_size, b_limb);\n  a_size = ABS(a_size);\n\n  /* (a/b) = (a mod b / b) */\n  JACOBI_MOD_OR_MODEXACT_1_ODD (result_bit1, a_rem, a_ptr, a_size, b_limb);\n  return mpn_jacobi_base (a_rem, b_limb, result_bit1);\n}",
      "lines": 55,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/kronzu.c": {
    "mpz_kronecker_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nmpz_kronecker_ui (mpz_srcptr a, unsigned long b)\n{\n  mp_srcptr  a_ptr;\n  mp_size_t  a_size;\n  mp_limb_t  a_rem;\n  int        result_bit1;\n\n  a_size = SIZ(a);\n  if (a_size == 0)\n    return JACOBI_0U (b);\n\n  if (b > GMP_NUMB_MAX)\n    {\n      mp_limb_t  blimbs[2];\n      mpz_t      bz;\n      ALLOC(bz) = numberof (blimbs);\n      PTR(bz) = blimbs;\n      mpz_set_ui (bz, b);\n      return mpz_kronecker (a, bz);\n    }\n\n  a_ptr = PTR(a);\n  if ((b & 1) != 0)\n    {\n      result_bit1 = JACOBI_ASGN_SU_BIT1 (a_size, b);\n    }\n  else\n    {\n      mp_limb_t  a_low = a_ptr[0];\n      int        twos;\n\n      if (b == 0)\n\treturn JACOBI_LS0 (a_low, a_size);   /* (a/0) */\n\n      if (! (a_low & 1))\n\treturn 0;  /* (even/even)=0 */\n\n      /* (a/2)=(2/a) for a odd */\n      count_trailing_zeros (twos, b);\n      b >>= twos;\n      result_bit1 = (JACOBI_TWOS_U_BIT1 (twos, a_low)\n\t\t     ^ JACOBI_ASGN_SU_BIT1 (a_size, b));\n    }\n\n  if (b == 1)\n    return JACOBI_BIT1_TO_PN (result_bit1);  /* (a/1)=1 for any a */\n\n  a_size = ABS(a_size);\n\n  /* (a/b) = (a mod b / b) */\n  JACOBI_MOD_OR_MODEXACT_1_ODD (result_bit1, a_rem, a_ptr, a_size, b);\n  return mpn_jacobi_base (a_rem, (mp_limb_t) b, result_bit1);\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/lcm.c": {
    "mpz_lcm": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "void\nmpz_lcm (mpz_ptr r, mpz_srcptr u, mpz_srcptr v)\n{\n  mpz_t g;\n  mp_size_t usize, vsize;\n  TMP_DECL;\n\n  usize = SIZ (u);\n  vsize = SIZ (v);\n  if (usize == 0 || vsize == 0)\n    {\n      SIZ (r) = 0;\n      return;\n    }\n  usize = ABS (usize);\n  vsize = ABS (vsize);\n\n  if (vsize == 1 || usize == 1)\n    {\n      mp_limb_t  vl, gl, c;\n      mp_srcptr  up;\n      mp_ptr     rp;\n\n      if (usize == 1)\n\t{\n\t  usize = vsize;\n\t  MPZ_SRCPTR_SWAP (u, v);\n\t}\n\n      MPZ_REALLOC (r, usize+1);\n\n      up = PTR(u);\n      vl = PTR(v)[0];\n      gl = mpn_gcd_1 (up, usize, vl);\n      vl /= gl;\n\n      rp = PTR(r);\n      c = mpn_mul_1 (rp, up, usize, vl);\n      rp[usize] = c;\n      usize += (c != 0);\n      SIZ(r) = usize;\n      return;\n    }\n\n  TMP_MARK;\n  MPZ_TMP_INIT (g, usize); /* v != 0 implies |gcd(u,v)| <= |u| */\n\n  mpz_gcd (g, u, v);\n  mpz_divexact (g, u, g);\n  mpz_mul (r, g, v);\n\n  SIZ (r) = ABS (SIZ (r));\t/* result always positive */\n\n  TMP_FREE;\n}",
      "lines": 55,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/lcm_ui.c": {
    "mpz_lcm_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\nmpz_lcm_ui (mpz_ptr r, mpz_srcptr u, unsigned long v)\n{\n  mp_size_t      usize;\n  mp_srcptr      up;\n  mp_ptr         rp;\n  unsigned long  g;\n  mp_limb_t      c;\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (v > GMP_NUMB_MAX)\n    {\n      mpz_t vz;\n      mp_limb_t vlimbs[2];\n      vlimbs[0] = v & GMP_NUMB_MASK;\n      vlimbs[1] = v >> GMP_NUMB_BITS;\n      PTR(vz) = vlimbs;\n      SIZ(vz) = 2;\n      mpz_lcm (r, u, vz);\n      return;\n    }\n#endif\n\n  /* result zero if either operand zero */\n  usize = SIZ(u);\n  if (usize == 0 || v == 0)\n    {\n      SIZ(r) = 0;\n      return;\n    }\n  usize = ABS(usize);\n\n  MPZ_REALLOC (r, usize+1);\n\n  up = PTR(u);\n  g = (unsigned long) mpn_gcd_1 (up, usize, (mp_limb_t) v);\n  v /= g;\n\n  rp = PTR(r);\n  c = mpn_mul_1 (rp, up, usize, (mp_limb_t) v);\n  rp[usize] = c;\n  usize += (c != 0);\n  SIZ(r) = usize;\n}",
      "lines": 44,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/limbs_finish.c": {
    "mpz_limbs_finish": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\nmpz_limbs_finish (mpz_ptr x, mp_size_t xs)\n{\n  mp_size_t xn = ABS(xs);\n  MPN_NORMALIZE (PTR (x), xn);\n  SIZ (x) = xs < 0 ? -xn : xn;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/limbs_modify.c": {
    "mpz_limbs_modify": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "mp_ptr\nmpz_limbs_modify (mpz_ptr x, mp_size_t n)\n{\n  ASSERT (n > 0);\n  return MPZ_REALLOC (x, n);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "mp_ptr"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/limbs_read.c": {
    "mpz_limbs_read": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "mp_srcptr\nmpz_limbs_read (mpz_srcptr x)\n{\n  return PTR(x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_srcptr"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/limbs_write.c": {
    "mpz_limbs_write": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "mp_ptr\nmpz_limbs_write (mpz_ptr x, mp_size_t n)\n{\n  ASSERT (n > 0);\n  return MPZ_NEWALLOC (x, n);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "mp_ptr"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/lucnum2_ui.c": {
    "mpz_lucnum2_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nmpz_lucnum2_ui (mpz_ptr ln, mpz_ptr lnsub1, unsigned long n)\n{\n  mp_ptr     lp, l1p, f1p;\n  mp_size_t  size;\n  mp_limb_t  c;\n  TMP_DECL;\n\n  ASSERT (ln != lnsub1);\n\n  /* handle small n quickly, and hide the special case for L[-1]=-1 */\n  if (n <= FIB_TABLE_LUCNUM_LIMIT)\n    {\n      mp_limb_t  f  = FIB_TABLE (n);\n      mp_limb_t  f1 = FIB_TABLE ((int) n - 1);\n\n      /* L[n] = F[n] + 2F[n-1] */\n      PTR(ln)[0] = f + 2*f1;\n      SIZ(ln) = 1;\n\n      /* L[n-1] = 2F[n] - F[n-1], but allow for L[-1]=-1 */\n      PTR(lnsub1)[0] = (n == 0 ? 1 : 2*f - f1);\n      SIZ(lnsub1) = (n == 0 ? -1 : 1);\n\n      return;\n    }\n\n  TMP_MARK;\n  size = MPN_FIB2_SIZE (n);\n  f1p = TMP_ALLOC_LIMBS (size);\n\n  lp  = MPZ_REALLOC (ln,     size+1);\n  l1p = MPZ_REALLOC (lnsub1, size+1);\n\n  size = mpn_fib2_ui (l1p, f1p, n);\n\n  /* L[n] = F[n] + 2F[n-1] */\n#if HAVE_NATIVE_mpn_addlsh1_n\n  c = mpn_addlsh1_n (lp, l1p, f1p, size);\n#else\n  c = mpn_lshift (lp, f1p, size, 1);\n  c += mpn_add_n (lp, lp, l1p, size);\n#endif\n  lp[size] = c;\n  SIZ(ln) = size + (c != 0);\n\n  /* L[n-1] = 2F[n] - F[n-1] */\n  c = mpn_lshift (l1p, l1p, size, 1);\n  c -= mpn_sub_n (l1p, l1p, f1p, size);\n  ASSERT ((mp_limb_signed_t) c >= 0);\n  l1p[size] = c;\n  SIZ(lnsub1) = size + (c != 0);\n\n  TMP_FREE;\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/lucnum_ui.c": {
    "mpz_lucnum_ui": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "void\nmpz_lucnum_ui (mpz_ptr ln, unsigned long n)\n{\n  mp_size_t  lalloc, xalloc, lsize, xsize;\n  mp_ptr     lp, xp;\n  mp_limb_t  c;\n  int        zeros;\n  TMP_DECL;\n\n  TRACE (printf (\"mpn_lucnum_ui n=%lu\\n\", n));\n\n  if (n <= FIB_TABLE_LUCNUM_LIMIT)\n    {\n      /* L[n] = F[n] + 2F[n-1] */\n      PTR(ln)[0] = FIB_TABLE(n) + 2 * FIB_TABLE ((int) n - 1);\n      SIZ(ln) = 1;\n      return;\n    }\n\n  /* +1 since L[n]=F[n]+2F[n-1] might be 1 limb bigger than F[n], further +1\n     since square or mul used below might need an extra limb over the true\n     size */\n  lalloc = MPN_FIB2_SIZE (n) + 2;\n  lp = MPZ_REALLOC (ln, lalloc);\n\n  TMP_MARK;\n  xalloc = lalloc;\n  xp = TMP_ALLOC_LIMBS (xalloc);\n\n  /* Strip trailing zeros from n, until either an odd number is reached\n     where the L[2k+1] formula can be used, or until n fits within the\n     FIB_TABLE data.  The table is preferred of course.  */\n  zeros = 0;\n  for (;;)\n    {\n      if (n & 1)\n\t{\n\t  /* L[2k+1] = 5*F[k-1]*(2*F[k]+F[k-1]) - 4*(-1)^k */\n\n\t  mp_size_t  yalloc, ysize;\n\t  mp_ptr     yp;\n\n\t  TRACE (printf (\"  initial odd n=%lu\\n\", n));\n\n\t  yalloc = MPN_FIB2_SIZE (n/2);\n\t  yp = TMP_ALLOC_LIMBS (yalloc);\n\t  ASSERT (xalloc >= yalloc);\n\n\t  xsize = mpn_fib2_ui (xp, yp, n/2);\n\n\t  /* possible high zero on F[k-1] */\n\t  ysize = xsize;\n\t  ysize -= (yp[ysize-1] == 0);\n\t  ASSERT (yp[ysize-1] != 0);\n\n\t  /* xp = 2*F[k] + F[k-1] */\n#if HAVE_NATIVE_mpn_addlsh1_n\n\t  c = mpn_addlsh1_n (xp, yp, xp, xsize);\n#else\n\t  c = mpn_lshift (xp, xp, xsize, 1);\n\t  c += mpn_add_n (xp, xp, yp, xsize);\n#endif\n\t  ASSERT (xalloc >= xsize+1);\n\t  xp[xsize] = c;\n\t  xsize += (c != 0);\n\t  ASSERT (xp[xsize-1] != 0);\n\n\t  ASSERT (lalloc >= xsize + ysize);\n\t  c = mpn_mul (lp, xp, xsize, yp, ysize);\n\t  lsize = xsize + ysize;\n\t  lsize -= (c == 0);\n\n\t  /* lp = 5*lp */\n#if HAVE_NATIVE_mpn_addlsh2_n\n\t  c = mpn_addlsh2_n (lp, lp, lp, lsize);\n#else\n\t  /* FIXME: Is this faster than mpn_mul_1 ? */\n\t  c = mpn_lshift (xp, lp, lsize, 2);\n\t  c += mpn_add_n (lp, lp, xp, lsize);\n#endif\n\t  ASSERT (lalloc >= lsize+1);\n\t  lp[lsize] = c;\n\t  lsize += (c != 0);\n\n\t  /* lp = lp - 4*(-1)^k */\n\t  if (n & 2)\n\t    {\n\t      /* no overflow, see comments above */\n\t      ASSERT (lp[0] <= MP_LIMB_T_MAX-4);\n\t      lp[0] += 4;\n\t    }\n\t  else\n\t    {\n\t      /* won't go negative */\n\t      MPN_DECR_U (lp, lsize, CNST_LIMB(4));\n\t    }\n\n\t  TRACE (mpn_trace (\"  l\",lp, lsize));\n\t  break;\n\t}\n\n      MP_PTR_SWAP (xp, lp); /* balance the swaps wanted in the L[2k] below */\n      zeros++;\n      n /= 2;\n\n      if (n <= FIB_TABLE_LUCNUM_LIMIT)\n\t{\n\t  /* L[n] = F[n] + 2F[n-1] */\n\t  lp[0] = FIB_TABLE (n) + 2 * FIB_TABLE ((int) n - 1);\n\t  lsize = 1;\n\n\t  TRACE (printf (\"  initial small n=%lu\\n\", n);\n\t\t mpn_trace (\"  l\",lp, lsize));\n\t  break;\n\t}\n    }\n\n  for ( ; zeros != 0; zeros--)\n    {\n      /* L[2k] = L[k]^2 + 2*(-1)^k */\n\n      TRACE (printf (\"  zeros=%d\\n\", zeros));\n\n      ASSERT (xalloc >= 2*lsize);\n      mpn_sqr (xp, lp, lsize);\n      lsize *= 2;\n      lsize -= (xp[lsize-1] == 0);\n\n      /* First time around the loop k==n determines (-1)^k, after that k is\n\t always even and we set n=0 to indicate that.  */\n      if (n & 1)\n\t{\n\t  /* L[n]^2 == 0 or 1 mod 4, like all squares, so +2 gives no carry */\n\t  ASSERT (xp[0] <= MP_LIMB_T_MAX-2);\n\t  xp[0] += 2;\n\t  n = 0;\n\t}\n      else\n\t{\n\t  /* won't go negative */\n\t  MPN_DECR_U (xp, lsize, CNST_LIMB(2));\n\t}\n\n      MP_PTR_SWAP (xp, lp);\n      ASSERT (lp[lsize-1] != 0);\n    }\n\n  /* should end up in the right spot after all the xp/lp swaps */\n  ASSERT (lp == PTR(ln));\n  SIZ(ln) = lsize;\n\n  TMP_FREE;\n}",
      "lines": 153,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/mfac_uiui.c": {
    "mpz_mfac_uiui": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "void\nmpz_mfac_uiui (mpz_ptr x, unsigned long n, unsigned long m)\n{\n  ASSERT (n <= GMP_NUMB_MAX);\n  ASSERT (m != 0);\n\n  if ((n < 3) | (n - 3 < m - 1)) { /* (n < 3 || n - 1 <= m || m == 0) */\n    PTR (x)[0] = n + (n == 0);\n    SIZ (x) = 1;\n  } else { /* m < n - 1 < GMP_NUMB_MAX */\n    mp_limb_t g, sn;\n    mpz_t     t;\n\n    sn = n;\n    g = mpn_gcd_1 (&sn, 1, m);\n    if (g > 1) { n/=g; m/=g; }\n\n    if (m <= 2) { /* fac or 2fac */\n      if (m == 1) {\n\tif (g > 2) {\n\t  mpz_init (t);\n\t  mpz_fac_ui (t, n);\n\t  sn = n;\n\t} else {\n\t  if (g == 2)\n\t    mpz_2fac_ui (x, n << 1);\n\t  else\n\t    mpz_fac_ui (x, n);\n\t  return;\n\t}\n      } else { /* m == 2 */\n\tif (g > 1) {\n\t  mpz_init (t);\n\t  mpz_2fac_ui (t, n);\n\t  sn = n / 2 + 1;\n\t} else {\n\t  mpz_2fac_ui (x, n);\n\t  return;\n\t}\n      }\n    } else { /* m >= 3, gcd(n,m) = 1 */\n      mp_limb_t *factors;\n      mp_limb_t prod, max_prod, j;\n      TMP_DECL;\n\n      sn = n / m + 1;\n\n      j = 0;\n      prod = n;\n      n -= m;\n      max_prod = GMP_NUMB_MAX / n;\n\n      if (g > 1)\n\tfactors = MPZ_NEWALLOC (x, sn / log_n_max (n) + 2);\n      else {\n\tTMP_MARK;\n\tfactors = TMP_ALLOC_LIMBS (sn / log_n_max (n) + 2);\n      }\n\n      for (; n > m; n -= m)\n\tFACTOR_LIST_STORE (n, prod, max_prod, factors, j);\n\n      factors[j++] = n;\n      factors[j++] = prod;\n\n      if (g > 1) {\n\tmpz_init (t);\n\tmpz_prodlimbs (t, factors, j);\n      } else {\n\tmpz_prodlimbs (x, factors, j);\n\tTMP_FREE;\n\treturn;\n      }\n    }\n\n    {\n      mpz_t p;\n\n      mpz_init (p);\n      mpz_ui_pow_ui (p, g, sn); /* g^sn */\n      mpz_mul (x, p, t);\n      mpz_clear (p);\n      mpz_clear (t);\n    }\n  }\n}",
      "lines": 86,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/millerrabin.c": {
    "mpz_millerrabin": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int\nmpz_millerrabin (mpz_srcptr n, int reps)\n{\n  int r;\n  mpz_t nm1, nm3, x, y, q;\n  unsigned long int k;\n  gmp_randstate_t rstate;\n  int is_prime;\n  TMP_DECL;\n  TMP_MARK;\n\n  MPZ_TMP_INIT (nm1, SIZ (n) + 1);\n  mpz_sub_ui (nm1, n, 1L);\n\n  MPZ_TMP_INIT (x, SIZ (n) + 1);\n  MPZ_TMP_INIT (y, 2 * SIZ (n)); /* mpz_powm_ui needs excessive memory!!! */\n\n  /* Perform a Fermat test.  */\n  mpz_set_ui (x, 210L);\n  mpz_powm (y, x, nm1, n);\n  if (mpz_cmp_ui (y, 1L) != 0)\n    {\n      TMP_FREE;\n      return 0;\n    }\n\n  MPZ_TMP_INIT (q, SIZ (n));\n\n  /* Find q and k, where q is odd and n = 1 + 2**k * q.  */\n  k = mpz_scan1 (nm1, 0L);\n  mpz_tdiv_q_2exp (q, nm1, k);\n\n  /* n-3 */\n  MPZ_TMP_INIT (nm3, SIZ (n) + 1);\n  mpz_sub_ui (nm3, n, 3L);\n  ASSERT (mpz_cmp_ui (nm3, 1L) >= 0);\n\n  gmp_randinit_default (rstate);\n\n  is_prime = 1;\n  for (r = 0; r < reps && is_prime; r++)\n    {\n      /* 2 to n-2 inclusive, don't want 1, 0 or -1 */\n      mpz_urandomm (x, rstate, nm3);\n      mpz_add_ui (x, x, 2L);\n\n      is_prime = millerrabin (n, nm1, x, y, q, k);\n    }\n\n  gmp_randclear (rstate);\n\n  TMP_FREE;\n  return is_prime;\n}",
      "lines": 54,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "millerrabin": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static int\nmillerrabin (mpz_srcptr n, mpz_srcptr nm1, mpz_ptr x, mpz_ptr y,\n\t     mpz_srcptr q, unsigned long int k)\n{\n  unsigned long int i;\n\n  mpz_powm (y, x, q, n);\n\n  if (mpz_cmp_ui (y, 1L) == 0 || mpz_cmp (y, nm1) == 0)\n    return 1;\n\n  for (i = 1; i < k; i++)\n    {\n      mpz_powm_ui (y, y, 2L, n);\n      if (mpz_cmp (y, nm1) == 0)\n\treturn 1;\n      /* y == 1 means that the previous y was a non-trivial square root\n\t of 1 (mod n). y == 0 means that n is a power of the base.\n\t In either case, n is not prime. */\n      if (mpz_cmp_ui (y, 1L) <= 0)\n\treturn 0;\n    }\n  return 0;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/mod.c": {
    "mpz_mod": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nmpz_mod (mpz_ptr rem, mpz_srcptr dividend, mpz_srcptr divisor)\n{\n  mp_size_t rn, bn;\n  mpz_t temp_divisor;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  bn = ABSIZ(divisor);\n\n  /* We need the original value of the divisor after the remainder has been\n     preliminary calculated.  We have to copy it to temporary space if it's\n     the same variable as REM.  */\n  if (rem == divisor)\n    {\n      PTR(temp_divisor) = TMP_ALLOC_LIMBS (bn);\n      MPN_COPY (PTR(temp_divisor), PTR(divisor), bn);\n    }\n  else\n    {\n      PTR(temp_divisor) = PTR(divisor);\n    }\n  SIZ(temp_divisor) = bn;\n  divisor = temp_divisor;\n\n  mpz_tdiv_r (rem, dividend, divisor);\n\n  rn = SIZ (rem);\n  if (rn < 0)\n    mpz_add (rem, rem, divisor);\n\n  TMP_FREE;\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/mul.c": {
    "mpz_mul": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "void\nmpz_mul (mpz_ptr w, mpz_srcptr u, mpz_srcptr v)\n{\n  mp_size_t usize;\n  mp_size_t vsize;\n  mp_size_t wsize;\n  mp_size_t sign_product;\n  mp_ptr up, vp;\n  mp_ptr wp;\n  mp_ptr free_me;\n  size_t free_me_size;\n  mp_limb_t cy_limb;\n  TMP_DECL;\n\n  usize = SIZ (u);\n  vsize = SIZ (v);\n  sign_product = usize ^ vsize;\n  usize = ABS (usize);\n  vsize = ABS (vsize);\n\n  if (usize < vsize)\n    {\n      MPZ_SRCPTR_SWAP (u, v);\n      MP_SIZE_T_SWAP (usize, vsize);\n    }\n\n  if (vsize == 0)\n    {\n      SIZ (w) = 0;\n      return;\n    }\n\n#if HAVE_NATIVE_mpn_mul_2\n  if (vsize <= 2)\n    {\n      wp = MPZ_REALLOC (w, usize+vsize);\n      if (vsize == 1)\n\tcy_limb = mpn_mul_1 (wp, PTR (u), usize, PTR (v)[0]);\n      else\n\t{\n\t  cy_limb = mpn_mul_2 (wp, PTR (u), usize, PTR (v));\n\t  usize++;\n\t}\n      wp[usize] = cy_limb;\n      usize += (cy_limb != 0);\n      SIZ (w) = (sign_product >= 0 ? usize : -usize);\n      return;\n    }\n#else\n  if (vsize == 1)\n    {\n      wp = MPZ_REALLOC (w, usize+1);\n      cy_limb = mpn_mul_1 (wp, PTR (u), usize, PTR (v)[0]);\n      wp[usize] = cy_limb;\n      usize += (cy_limb != 0);\n      SIZ (w) = (sign_product >= 0 ? usize : -usize);\n      return;\n    }\n#endif\n\n  TMP_MARK;\n  free_me = NULL;\n  up = PTR (u);\n  vp = PTR (v);\n  wp = PTR (w);\n\n  /* Ensure W has space enough to store the result.  */\n  wsize = usize + vsize;\n  if (ALLOC (w) < wsize)\n    {\n      if (wp == up || wp == vp)\n\t{\n\t  free_me = wp;\n\t  free_me_size = ALLOC (w);\n\t}\n      else\n\t(*__gmp_free_func) (wp, (size_t) ALLOC (w) * GMP_LIMB_BYTES);\n\n      ALLOC (w) = wsize;\n      wp = __GMP_ALLOCATE_FUNC_LIMBS (wsize);\n      PTR (w) = wp;\n    }\n  else\n    {\n      /* Make U and V not overlap with W.  */\n      if (wp == up)\n\t{\n\t  /* W and U are identical.  Allocate temporary space for U.  */\n\t  up = TMP_ALLOC_LIMBS (usize);\n\t  /* Is V identical too?  Keep it identical with U.  */\n\t  if (wp == vp)\n\t    vp = up;\n\t  /* Copy to the temporary space.  */\n\t  MPN_COPY (up, wp, usize);\n\t}\n      else if (wp == vp)\n\t{\n\t  /* W and V are identical.  Allocate temporary space for V.  */\n\t  vp = TMP_ALLOC_LIMBS (vsize);\n\t  /* Copy to the temporary space.  */\n\t  MPN_COPY (vp, wp, vsize);\n\t}\n    }\n\n  if (up == vp)\n    {\n      mpn_sqr (wp, up, usize);\n      cy_limb = wp[wsize - 1];\n    }\n  else\n    {\n      cy_limb = mpn_mul (wp, up, usize, vp, vsize);\n    }\n\n  wsize -= cy_limb == 0;\n\n  SIZ (w) = sign_product < 0 ? -wsize : wsize;\n  if (free_me != NULL)\n    (*__gmp_free_func) (free_me, free_me_size * GMP_LIMB_BYTES);\n  TMP_FREE;\n}",
      "lines": 121,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/mul_2exp.c": {
    "mpz_mul_2exp": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\nmpz_mul_2exp (mpz_ptr r, mpz_srcptr u, mp_bitcnt_t cnt)\n{\n  mp_size_t un, rn;\n  mp_size_t limb_cnt;\n  mp_ptr rp;\n  mp_srcptr up;\n  mp_limb_t rlimb;\n\n  un = ABSIZ (u);\n  limb_cnt = cnt / GMP_NUMB_BITS;\n  rn = un + limb_cnt;\n\n  if (un == 0)\n    rn = 0;\n  else\n    {\n      rp = MPZ_REALLOC (r, rn + 1);\n      up = PTR(u);\n\n      cnt %= GMP_NUMB_BITS;\n      if (cnt != 0)\n\t{\n\t  rlimb = mpn_lshift (rp + limb_cnt, up, un, cnt);\n\t  rp[rn] = rlimb;\n\t  rn += (rlimb != 0);\n\t}\n      else\n\t{\n\t  MPN_COPY_DECR (rp + limb_cnt, up, un);\n\t}\n\n      /* Zero all whole limbs at low end.  Do it here and not before calling\n\t mpn_lshift, not to lose for U == R.  */\n      MPN_ZERO (rp, limb_cnt);\n    }\n\n  SIZ(r) = SIZ(u) >= 0 ? rn : -rn;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/mul_i.h": {
    "FUNCTION": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nFUNCTION (mpz_ptr prod, mpz_srcptr mult,\n          MULTIPLICAND_UNSIGNED long int small_mult)\n{\n  mp_size_t size;\n  mp_size_t sign_product;\n  mp_limb_t sml;\n  mp_limb_t cy;\n  mp_ptr pp;\n\n  sign_product = SIZ(mult);\n  if (sign_product == 0 || small_mult == 0)\n    {\n      SIZ(prod) = 0;\n      return;\n    }\n\n  size = ABS (sign_product);\n\n  sml = MULTIPLICAND_ABS (small_mult);\n\n  if (sml <= GMP_NUMB_MAX)\n    {\n      pp = MPZ_REALLOC (prod, size + 1);\n      cy = mpn_mul_1 (pp, PTR(mult), size, sml);\n      pp[size] = cy;\n      size += cy != 0;\n    }\n#if GMP_NAIL_BITS != 0\n  else\n    {\n      /* Operand too large for the current nails size.  Use temporary for\n\t intermediate products, to allow prod and mult being identical.  */\n      mp_ptr tp;\n      TMP_DECL;\n      TMP_MARK;\n\n      tp = TMP_ALLOC_LIMBS (size + 2);\n\n      /* Use, maybe, mpn_mul_2? */\n      cy = mpn_mul_1 (tp, PTR(mult), size, sml & GMP_NUMB_MASK);\n      tp[size] = cy;\n      cy = mpn_addmul_1 (tp + 1, PTR(mult), size, sml >> GMP_NUMB_BITS);\n      tp[size + 1] = cy;\n      size += 2;\n      MPN_NORMALIZE_NOT_ZERO (tp, size); /* too general, need to trim one or two limb */\n      pp = MPZ_REALLOC (prod, size);\n      MPN_COPY (pp, tp, size);\n      TMP_FREE;\n    }\n#endif\n\n  SIZ(prod) = ((sign_product < 0) ^ (small_mult < 0)) ? -size : size;\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/mul_si.c": {},
  "gmp/gmp-6.1.2/mpz/mul_ui.c": {},
  "gmp/gmp-6.1.2/mpz/neg.c": {
    "mpz_neg": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\nmpz_neg (mpz_ptr w, mpz_srcptr u)\n{\n  mp_ptr wp;\n  mp_srcptr up;\n  mp_size_t usize, size;\n\n  usize = SIZ (u);\n\n  if (u != w)\n    {\n      size = ABS (usize);\n\n      wp = MPZ_NEWALLOC (w, size);\n\n      up = PTR (u);\n\n      MPN_COPY (wp, up, size);\n    }\n\n  SIZ (w) = -usize;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/nextprime.c": {
    "mpz_nextprime": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "void\nmpz_nextprime (mpz_ptr p, mpz_srcptr n)\n{\n  unsigned short *moduli;\n  unsigned long difference;\n  int i;\n  unsigned prime_limit;\n  unsigned long prime;\n  mp_size_t pn;\n  mp_bitcnt_t nbits;\n  unsigned incr;\n  TMP_SDECL;\n\n  /* First handle tiny numbers */\n  if (mpz_cmp_ui (n, 2) < 0)\n    {\n      mpz_set_ui (p, 2);\n      return;\n    }\n  mpz_add_ui (p, n, 1);\n  mpz_setbit (p, 0);\n\n  if (mpz_cmp_ui (p, 7) <= 0)\n    return;\n\n  pn = SIZ(p);\n  MPN_SIZEINBASE_2EXP(nbits, PTR(p), pn, 1);\n  if (nbits / 2 >= NUMBER_OF_PRIMES)\n    prime_limit = NUMBER_OF_PRIMES - 1;\n  else\n    prime_limit = nbits / 2;\n\n  TMP_SMARK;\n\n  /* Compute residues modulo small odd primes */\n  moduli = TMP_SALLOC_TYPE (prime_limit * sizeof moduli[0], unsigned short);\n\n  for (;;)\n    {\n      /* FIXME: Compute lazily? */\n      prime = 3;\n      for (i = 0; i < prime_limit; i++)\n\t{\n\t  moduli[i] = mpz_fdiv_ui (p, prime);\n\t  prime += primegap[i];\n\t}\n\n#define INCR_LIMIT 0x10000\t/* deep science */\n\n      for (difference = incr = 0; incr < INCR_LIMIT; difference += 2)\n\t{\n\t  /* First check residues */\n\t  prime = 3;\n\t  for (i = 0; i < prime_limit; i++)\n\t    {\n\t      unsigned r;\n\t      /* FIXME: Reduce moduli + incr and store back, to allow for\n\t\t division-free reductions.  Alternatively, table primes[]'s\n\t\t inverses (mod 2^16).  */\n\t      r = (moduli[i] + incr) % prime;\n\t      prime += primegap[i];\n\n\t      if (r == 0)\n\t\tgoto next;\n\t    }\n\n\t  mpz_add_ui (p, p, difference);\n\t  difference = 0;\n\n\t  /* Miller-Rabin test */\n\t  if (mpz_millerrabin (p, 25))\n\t    goto done;\n\tnext:;\n\t  incr += 2;\n\t}\n      mpz_add_ui (p, p, difference);\n      difference = 0;\n    }\n done:\n  TMP_SFREE;\n}",
      "lines": 81,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/n_pow_ui.c": {
    "mpz_n_pow_ui": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "void\nmpz_n_pow_ui (mpz_ptr r, mp_srcptr bp, mp_size_t bsize, unsigned long int e)\n{\n  mp_ptr         rp;\n  mp_size_t      rtwos_limbs, ralloc, rsize;\n  int            rneg, i, cnt, btwos, r_bp_overlap;\n  mp_limb_t      blimb, rl;\n  mp_bitcnt_t    rtwos_bits;\n#if HAVE_NATIVE_mpn_mul_2\n  mp_limb_t      blimb_low, rl_high;\n#else\n  mp_limb_t      b_twolimbs[2];\n#endif\n  TMP_DECL;\n\n  TRACE (printf (\"mpz_n_pow_ui rp=0x%lX bp=0x%lX bsize=%ld e=%lu (0x%lX)\\n\",\n\t\t PTR(r), bp, bsize, e, e);\n\t mpn_trace (\"b\", bp, bsize));\n\n  ASSERT (bsize == 0 || bp[ABS(bsize)-1] != 0);\n  ASSERT (MPN_SAME_OR_SEPARATE2_P (PTR(r), ALLOC(r), bp, ABS(bsize)));\n\n  /* b^0 == 1, including 0^0 == 1 */\n  if (e == 0)\n    {\n      PTR(r)[0] = 1;\n      SIZ(r) = 1;\n      return;\n    }\n\n  /* 0^e == 0 apart from 0^0 above */\n  if (bsize == 0)\n    {\n      SIZ(r) = 0;\n      return;\n    }\n\n  /* Sign of the final result. */\n  rneg = (bsize < 0 && (e & 1) != 0);\n  bsize = ABS (bsize);\n  TRACE (printf (\"rneg %d\\n\", rneg));\n\n  r_bp_overlap = (PTR(r) == bp);\n\n  /* Strip low zero limbs from b. */\n  rtwos_limbs = 0;\n  for (blimb = *bp; blimb == 0; blimb = *++bp)\n    {\n      rtwos_limbs += e;\n      bsize--; ASSERT (bsize >= 1);\n    }\n  TRACE (printf (\"trailing zero rtwos_limbs=%ld\\n\", rtwos_limbs));\n\n  /* Strip low zero bits from b. */\n  count_trailing_zeros (btwos, blimb);\n  blimb >>= btwos;\n  rtwos_bits = e * btwos;\n  rtwos_limbs += rtwos_bits / GMP_NUMB_BITS;\n  rtwos_bits %= GMP_NUMB_BITS;\n  TRACE (printf (\"trailing zero btwos=%d rtwos_limbs=%ld rtwos_bits=%lu\\n\",\n\t\t btwos, rtwos_limbs, rtwos_bits));\n\n  TMP_MARK;\n\n  rl = 1;\n#if HAVE_NATIVE_mpn_mul_2\n  rl_high = 0;\n#endif\n\n  if (bsize == 1)\n    {\n    bsize_1:\n      /* Power up as far as possible within blimb.  We start here with e!=0,\n\t but if e is small then we might reach e==0 and the whole b^e in rl.\n\t Notice this code works when blimb==1 too, reaching e==0.  */\n\n      while (blimb <= GMP_NUMB_HALFMAX)\n\t{\n\t  TRACE (printf (\"small e=0x%lX blimb=0x%lX rl=0x%lX\\n\",\n\t\t\t e, blimb, rl));\n\t  ASSERT (e != 0);\n\t  if ((e & 1) != 0)\n\t    rl *= blimb;\n\t  e >>= 1;\n\t  if (e == 0)\n\t    goto got_rl;\n\t  blimb *= blimb;\n\t}\n\n#if HAVE_NATIVE_mpn_mul_2\n      TRACE (printf (\"single power, e=0x%lX b=0x%lX rl=0x%lX\\n\",\n\t\t     e, blimb, rl));\n\n      /* Can power b once more into blimb:blimb_low */\n      bsize = 2;\n      ASSERT (e != 0);\n      if ((e & 1) != 0)\n\t{\n\t  umul_ppmm (rl_high, rl, rl, blimb << GMP_NAIL_BITS);\n\t  rl >>= GMP_NAIL_BITS;\n\t}\n      e >>= 1;\n      umul_ppmm (blimb, blimb_low, blimb, blimb << GMP_NAIL_BITS);\n      blimb_low >>= GMP_NAIL_BITS;\n\n    got_rl:\n      TRACE (printf (\"double power e=0x%lX blimb=0x%lX:0x%lX rl=0x%lX:%lX\\n\",\n\t\t     e, blimb, blimb_low, rl_high, rl));\n\n      /* Combine left-over rtwos_bits into rl_high:rl to be handled by the\n\t final mul_1 or mul_2 rather than a separate lshift.\n\t - rl_high:rl mustn't be 1 (since then there's no final mul)\n\t - rl_high mustn't overflow\n\t - rl_high mustn't change to non-zero, since mul_1+lshift is\n\t probably faster than mul_2 (FIXME: is this true?)  */\n\n      if (rtwos_bits != 0\n\t  && ! (rl_high == 0 && rl == 1)\n\t  && (rl_high >> (GMP_NUMB_BITS-rtwos_bits)) == 0)\n\t{\n\t  mp_limb_t  new_rl_high = (rl_high << rtwos_bits)\n\t    | (rl >> (GMP_NUMB_BITS-rtwos_bits));\n\t  if (! (rl_high == 0 && new_rl_high != 0))\n\t    {\n\t      rl_high = new_rl_high;\n\t      rl <<= rtwos_bits;\n\t      rtwos_bits = 0;\n\t      TRACE (printf (\"merged rtwos_bits, rl=0x%lX:%lX\\n\",\n\t\t\t     rl_high, rl));\n\t    }\n\t}\n#else\n    got_rl:\n      TRACE (printf (\"small power e=0x%lX blimb=0x%lX rl=0x%lX\\n\",\n\t\t     e, blimb, rl));\n\n      /* Combine left-over rtwos_bits into rl to be handled by the final\n\t mul_1 rather than a separate lshift.\n\t - rl mustn't be 1 (since then there's no final mul)\n\t - rl mustn't overflow\t*/\n\n      if (rtwos_bits != 0\n\t  && rl != 1\n\t  && (rl >> (GMP_NUMB_BITS-rtwos_bits)) == 0)\n\t{\n\t  rl <<= rtwos_bits;\n\t  rtwos_bits = 0;\n\t  TRACE (printf (\"merged rtwos_bits, rl=0x%lX\\n\", rl));\n\t}\n#endif\n    }\n  else if (bsize == 2)\n    {\n      mp_limb_t  bsecond = bp[1];\n      if (btwos != 0)\n\tblimb |= (bsecond << (GMP_NUMB_BITS - btwos)) & GMP_NUMB_MASK;\n      bsecond >>= btwos;\n      if (bsecond == 0)\n\t{\n\t  /* Two limbs became one after rshift. */\n\t  bsize = 1;\n\t  goto bsize_1;\n\t}\n\n      TRACE (printf (\"bsize==2 using b=0x%lX:%lX\", bsecond, blimb));\n#if HAVE_NATIVE_mpn_mul_2\n      blimb_low = blimb;\n#else\n      bp = b_twolimbs;\n      b_twolimbs[0] = blimb;\n      b_twolimbs[1] = bsecond;\n#endif\n      blimb = bsecond;\n    }\n  else\n    {\n      if (r_bp_overlap || btwos != 0)\n\t{\n\t  mp_ptr tp = TMP_ALLOC_LIMBS (bsize);\n\t  MPN_RSHIFT_OR_COPY (tp, bp, bsize, btwos);\n\t  bp = tp;\n\t  TRACE (printf (\"rshift or copy bp,bsize, new bsize=%ld\\n\", bsize));\n\t}\n#if HAVE_NATIVE_mpn_mul_2\n      /* in case 3 limbs rshift to 2 and hence use the mul_2 loop below */\n      blimb_low = bp[0];\n#endif\n      blimb = bp[bsize-1];\n\n      TRACE (printf (\"big bsize=%ld  \", bsize);\n\t     mpn_trace (\"b\", bp, bsize));\n    }\n\n  /* At this point blimb is the most significant limb of the base to use.\n\n     Each factor of b takes (bsize*BPML-cnt) bits and there's e of them; +1\n     limb to round up the division; +1 for multiplies all using an extra\n     limb over the true size; +2 for rl at the end; +1 for lshift at the\n     end.\n\n     The size calculation here is reasonably accurate.  The base is at least\n     half a limb, so in 32 bits the worst case is 2^16+1 treated as 17 bits\n     when it will power up as just over 16, an overestimate of 17/16 =\n     6.25%.  For a 64-bit limb it's half that.\n\n     If e==0 then blimb won't be anything useful (though it will be\n     non-zero), but that doesn't matter since we just end up with ralloc==5,\n     and that's fine for 2 limbs of rl and 1 of lshift.  */\n\n  ASSERT (blimb != 0);\n  count_leading_zeros (cnt, blimb);\n  ralloc = (bsize*GMP_NUMB_BITS - cnt + GMP_NAIL_BITS) * e / GMP_NUMB_BITS + 5;\n  TRACE (printf (\"ralloc %ld, from bsize=%ld blimb=0x%lX cnt=%d\\n\",\n\t\t ralloc, bsize, blimb, cnt));\n  rp = MPZ_REALLOC (r, ralloc + rtwos_limbs);\n\n  /* Low zero limbs resulting from powers of 2. */\n  MPN_ZERO (rp, rtwos_limbs);\n  rp += rtwos_limbs;\n\n  if (e == 0)\n    {\n      /* Any e==0 other than via bsize==1 or bsize==2 is covered at the\n\t start. */\n      rp[0] = rl;\n      rsize = 1;\n#if HAVE_NATIVE_mpn_mul_2\n      rp[1] = rl_high;\n      rsize += (rl_high != 0);\n#endif\n      ASSERT (rp[rsize-1] != 0);\n    }\n  else\n    {\n      mp_ptr     tp;\n      mp_size_t  talloc;\n\n      /* In the mpn_mul_1 or mpn_mul_2 loops or in the mpn_mul loop when the\n\t low bit of e is zero, tp only has to hold the second last power\n\t step, which is half the size of the final result.  There's no need\n\t to round up the divide by 2, since ralloc includes a +2 for rl\n\t which not needed by tp.  In the mpn_mul loop when the low bit of e\n\t is 1, tp must hold nearly the full result, so just size it the same\n\t as rp.  */\n\n      talloc = ralloc;\n#if HAVE_NATIVE_mpn_mul_2\n      if (bsize <= 2 || (e & 1) == 0)\n\ttalloc /= 2;\n#else\n      if (bsize <= 1 || (e & 1) == 0)\n\ttalloc /= 2;\n#endif\n      TRACE (printf (\"talloc %ld\\n\", talloc));\n      tp = TMP_ALLOC_LIMBS (talloc);\n\n      /* Go from high to low over the bits of e, starting with i pointing at\n\t the bit below the highest 1 (which will mean i==-1 if e==1).  */\n      count_leading_zeros (cnt, (mp_limb_t) e);\n      i = GMP_LIMB_BITS - cnt - 2;\n\n#if HAVE_NATIVE_mpn_mul_2\n      if (bsize <= 2)\n\t{\n\t  mp_limb_t  mult[2];\n\n\t  /* Any bsize==1 will have been powered above to be two limbs. */\n\t  ASSERT (bsize == 2);\n\t  ASSERT (blimb != 0);\n\n\t  /* Arrange the final result ends up in r, not in the temp space */\n\t  if ((i & 1) == 0)\n\t    SWAP_RP_TP;\n\n\t  rp[0] = blimb_low;\n\t  rp[1] = blimb;\n\t  rsize = 2;\n\n\t  mult[0] = blimb_low;\n\t  mult[1] = blimb;\n\n\t  for ( ; i >= 0; i--)\n\t    {\n\t      TRACE (printf (\"mul_2 loop i=%d e=0x%lX, rsize=%ld ralloc=%ld talloc=%ld\\n\",\n\t\t\t     i, e, rsize, ralloc, talloc);\n\t\t     mpn_trace (\"r\", rp, rsize));\n\n\t      MPN_SQR (tp, talloc, rp, rsize);\n\t      SWAP_RP_TP;\n\t      if ((e & (1L << i)) != 0)\n\t\tMPN_MUL_2 (rp, rsize, ralloc, mult);\n\t    }\n\n\t  TRACE (mpn_trace (\"mul_2 before rl, r\", rp, rsize));\n\t  if (rl_high != 0)\n\t    {\n\t      mult[0] = rl;\n\t      mult[1] = rl_high;\n\t      MPN_MUL_2 (rp, rsize, ralloc, mult);\n\t    }\n\t  else if (rl != 1)\n\t    MPN_MUL_1 (rp, rsize, ralloc, rl);\n\t}\n#else\n      if (bsize == 1)\n\t{\n\t  /* Arrange the final result ends up in r, not in the temp space */\n\t  if ((i & 1) == 0)\n\t    SWAP_RP_TP;\n\n\t  rp[0] = blimb;\n\t  rsize = 1;\n\n\t  for ( ; i >= 0; i--)\n\t    {\n\t      TRACE (printf (\"mul_1 loop i=%d e=0x%lX, rsize=%ld ralloc=%ld talloc=%ld\\n\",\n\t\t\t     i, e, rsize, ralloc, talloc);\n\t\t     mpn_trace (\"r\", rp, rsize));\n\n\t      MPN_SQR (tp, talloc, rp, rsize);\n\t      SWAP_RP_TP;\n\t      if ((e & (1L << i)) != 0)\n\t\tMPN_MUL_1 (rp, rsize, ralloc, blimb);\n\t    }\n\n\t  TRACE (mpn_trace (\"mul_1 before rl, r\", rp, rsize));\n\t  if (rl != 1)\n\t    MPN_MUL_1 (rp, rsize, ralloc, rl);\n\t}\n#endif\n      else\n\t{\n\t  int  parity;\n\n\t  /* Arrange the final result ends up in r, not in the temp space */\n\t  ULONG_PARITY (parity, e);\n\t  if (((parity ^ i) & 1) != 0)\n\t    SWAP_RP_TP;\n\n\t  MPN_COPY (rp, bp, bsize);\n\t  rsize = bsize;\n\n\t  for ( ; i >= 0; i--)\n\t    {\n\t      TRACE (printf (\"mul loop i=%d e=0x%lX, rsize=%ld ralloc=%ld talloc=%ld\\n\",\n\t\t\t     i, e, rsize, ralloc, talloc);\n\t\t     mpn_trace (\"r\", rp, rsize));\n\n\t      MPN_SQR (tp, talloc, rp, rsize);\n\t      SWAP_RP_TP;\n\t      if ((e & (1L << i)) != 0)\n\t\t{\n\t\t  MPN_MUL (tp, talloc, rp, rsize, bp, bsize);\n\t\t  SWAP_RP_TP;\n\t\t}\n\t    }\n\t}\n    }\n\n  ASSERT (rp == PTR(r) + rtwos_limbs);\n  TRACE (mpn_trace (\"end loop r\", rp, rsize));\n  TMP_FREE;\n\n  /* Apply any partial limb factors of 2. */\n  if (rtwos_bits != 0)\n    {\n      MPN_LSHIFT (rp, rsize, ralloc, (unsigned) rtwos_bits);\n      TRACE (mpn_trace (\"lshift r\", rp, rsize));\n    }\n\n  rsize += rtwos_limbs;\n  SIZ(r) = (rneg ? -rsize : rsize);\n}",
      "lines": 373,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/oddfac_1.c": {
    "bit_to_n": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        100,
        48
      ],
      "content": "static mp_limb_t\nbit_to_n (mp_limb_t bit) { return (bit*3+4)|1; }",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "id_to_n": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        105,
        50
      ],
      "content": "static mp_limb_t\nid_to_n  (mp_limb_t id)  { return id*3+1+(id&1); }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "n_to_bit": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        109,
        47
      ],
      "content": "static mp_limb_t\nn_to_bit (mp_limb_t n) { return ((n-5)|1)/3U; }",
      "lines": 2,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "primesieve_size": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        113,
        73
      ],
      "content": "static mp_size_t\nprimesieve_size (mp_limb_t n) { return n_to_bit(n) / GMP_LIMB_BITS + 1; }",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "limb_apprsqrt": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static mp_limb_t\nlimb_apprsqrt (mp_limb_t x)\n{\n  int s;\n\n  ASSERT (x > 2);\n  count_leading_zeros (s, x - 1);\n  s = GMP_LIMB_BITS - 1 - s;\n  return (CNST_LIMB(1) << (s >> 1)) + (CNST_LIMB(1) << ((s - 1) >> 1));\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpz_2multiswing_1": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "static void\nmpz_2multiswing_1 (mpz_ptr x, mp_limb_t n, mp_ptr sieve, mp_ptr factors)\n{\n  mp_limb_t prod, max_prod;\n  mp_size_t j;\n\n  ASSERT (n >= 26);\n\n  j = 0;\n  prod  = -(n & 1);\n  n &= ~ CNST_LIMB(1); /* n-1, if n is odd */\n\n  prod = (prod & n) + 1; /* the original n, if it was odd, 1 otherwise */\n  max_prod = GMP_NUMB_MAX / (n-1);\n\n  /* Handle prime = 3 separately. */\n  SWING_A_PRIME (3, n, prod, max_prod, factors, j);\n\n  /* Swing primes from 5 to n/3 */\n  {\n    mp_limb_t s;\n\n    {\n      mp_limb_t prime;\n\n      s = limb_apprsqrt(n);\n      ASSERT (s >= 5);\n      s = n_to_bit (s);\n      LOOP_ON_SIEVE_BEGIN (prime, n_to_bit (5), s, 0,sieve);\n      SWING_A_PRIME (prime, n, prod, max_prod, factors, j);\n      LOOP_ON_SIEVE_END;\n      s++;\n    }\n\n    ASSERT (max_prod <= GMP_NUMB_MAX / 3);\n    ASSERT (bit_to_n (s) * bit_to_n (s) > n);\n    ASSERT (s <= n_to_bit (n / 3));\n    {\n      mp_limb_t prime;\n      mp_limb_t l_max_prod = max_prod * 3;\n\n      LOOP_ON_SIEVE_BEGIN (prime, s, n_to_bit (n/3), 0, sieve);\n      SH_SWING_A_PRIME (prime, n, prod, l_max_prod, factors, j);\n      LOOP_ON_SIEVE_END;\n    }\n  }\n\n  /* Store primes from (n+1)/2 to n */\n  {\n    mp_limb_t prime;\n    LOOP_ON_SIEVE_BEGIN (prime, n_to_bit (n >> 1) + 1, n_to_bit (n), 0,sieve);\n    FACTOR_LIST_STORE (prime, prod, max_prod, factors, j);\n    LOOP_ON_SIEVE_END;\n  }\n\n  if (LIKELY (j != 0))\n    {\n      factors[j++] = prod;\n      mpz_prodlimbs (x, factors, j);\n    }\n  else\n    {\n      PTR (x)[0] = prod;\n      SIZ (x) = 1;\n    }\n}",
      "lines": 66,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_oddfac_1": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "void\nmpz_oddfac_1 (mpz_ptr x, mp_limb_t n, unsigned flag)\n{\n  ASSERT (n <= GMP_NUMB_MAX);\n  ASSERT (flag == 0 || (flag == 1 && n > ODD_FACTORIAL_TABLE_LIMIT && ABOVE_THRESHOLD (n, FAC_DSC_THRESHOLD)));\n\n  if (n <= ODD_FACTORIAL_TABLE_LIMIT)\n    {\n      PTR (x)[0] = __gmp_oddfac_table[n];\n      SIZ (x) = 1;\n    }\n  else if (n <= ODD_DOUBLEFACTORIAL_TABLE_LIMIT + 1)\n    {\n      mp_ptr   px;\n\n      px = MPZ_NEWALLOC (x, 2);\n      umul_ppmm (px[1], px[0], __gmp_odd2fac_table[(n - 1) >> 1], __gmp_oddfac_table[n >> 1]);\n      SIZ (x) = 2;\n    }\n  else\n    {\n      unsigned s;\n      mp_ptr   factors;\n\n      s = 0;\n      {\n\tmp_limb_t tn;\n\tmp_limb_t prod, max_prod, i;\n\tmp_size_t j;\n\tTMP_SDECL;\n\n#if TUNE_PROGRAM_BUILD\n\tASSERT (FAC_DSC_THRESHOLD_LIMIT >= FAC_DSC_THRESHOLD);\n\tASSERT (FAC_DSC_THRESHOLD >= 2 * (ODD_DOUBLEFACTORIAL_TABLE_LIMIT + 2));\n#endif\n\n\t/* Compute the number of recursive steps for the DSC algorithm. */\n\tfor (tn = n; ABOVE_THRESHOLD (tn, FAC_DSC_THRESHOLD); s++)\n\t  tn >>= 1;\n\n\tj = 0;\n\n\tTMP_SMARK;\n\tfactors = TMP_SALLOC_LIMBS (1 + tn / FACTORS_PER_LIMB);\n\tASSERT (tn >= FACTORS_PER_LIMB);\n\n\tprod = 1;\n#if TUNE_PROGRAM_BUILD\n\tmax_prod = GMP_NUMB_MAX / FAC_DSC_THRESHOLD_LIMIT;\n#else\n\tmax_prod = GMP_NUMB_MAX / FAC_DSC_THRESHOLD;\n#endif\n\n\tASSERT (tn > ODD_DOUBLEFACTORIAL_TABLE_LIMIT + 1);\n\tdo {\n\t  i = ODD_DOUBLEFACTORIAL_TABLE_LIMIT + 2;\n\t  factors[j++] = ODD_DOUBLEFACTORIAL_TABLE_MAX;\n\t  do {\n\t    FACTOR_LIST_STORE (i, prod, max_prod, factors, j);\n\t    i += 2;\n\t  } while (i <= tn);\n\t  max_prod <<= 1;\n\t  tn >>= 1;\n\t} while (tn > ODD_DOUBLEFACTORIAL_TABLE_LIMIT + 1);\n\n\tfactors[j++] = prod;\n\tfactors[j++] = __gmp_odd2fac_table[(tn - 1) >> 1];\n\tfactors[j++] = __gmp_oddfac_table[tn >> 1];\n\tmpz_prodlimbs (x, factors, j);\n\n\tTMP_SFREE;\n      }\n\n      if (s != 0)\n\t/* Use the algorithm described by Peter Luschny in \"Divide,\n\t   Swing and Conquer the Factorial!\".\n\n\t   Improvement: there are two temporary buffers, factors and\n\t   square, that are never used together; with a good estimate\n\t   of the maximal needed size, they could share a single\n\t   allocation.\n\t*/\n\t{\n\t  mpz_t mswing;\n\t  mp_ptr sieve;\n\t  mp_size_t size;\n\t  TMP_DECL;\n\n\t  TMP_MARK;\n\n\t  flag--;\n\t  size = n / GMP_NUMB_BITS + 4;\n\t  ASSERT (primesieve_size (n - 1) <= size - (size / 2 + 1));\n\t  /* 2-multiswing(n) < 2^(n-1)*sqrt(n/pi) < 2^(n+GMP_NUMB_BITS);\n\t     one more can be overwritten by mul, another for the sieve */\n\t  MPZ_TMP_INIT (mswing, size);\n\t  /* Initialize size, so that ASSERT can check it correctly. */\n\t  ASSERT_CODE (SIZ (mswing) = 0);\n\n\t  /* Put the sieve on the second half, it will be overwritten by the last mswing. */\n\t  sieve = PTR (mswing) + size / 2 + 1;\n\n\t  size = (gmp_primesieve (sieve, n - 1) + 1) / log_n_max (n) + 1;\n\n\t  factors = TMP_ALLOC_LIMBS (size);\n\t  do {\n\t    mp_ptr    square, px;\n\t    mp_size_t nx, ns;\n\t    mp_limb_t cy;\n\t    TMP_DECL;\n\n\t    s--;\n\t    ASSERT (ABSIZ (mswing) < ALLOC (mswing) / 2); /* Check: sieve has not been overwritten */\n\t    mpz_2multiswing_1 (mswing, n >> s, sieve, factors);\n\n\t    TMP_MARK;\n\t    nx = SIZ (x);\n\t    if (s == flag) {\n\t      size = nx;\n\t      square = TMP_ALLOC_LIMBS (size);\n\t      MPN_COPY (square, PTR (x), nx);\n\t    } else {\n\t      size = nx << 1;\n\t      square = TMP_ALLOC_LIMBS (size);\n\t      mpn_sqr (square, PTR (x), nx);\n\t      size -= (square[size - 1] == 0);\n\t    }\n\t    ns = SIZ (mswing);\n\t    nx = size + ns;\n\t    px = MPZ_NEWALLOC (x, nx);\n\t    ASSERT (ns <= size);\n\t    cy = mpn_mul (px, square, size, PTR(mswing), ns); /* n!= n$ * floor(n/2)!^2 */\n\n\t    TMP_FREE;\n\t    SIZ(x) = nx - (cy == 0);\n\t  } while (s != 0);\n\t  TMP_FREE;\n\t}\n    }\n}",
      "lines": 140,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/out_raw.c": {
    "mpz_out_raw": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "size_t\nmpz_out_raw (FILE *fp, mpz_srcptr x)\n{\n  mp_size_t   xsize, abs_xsize, bytes, i;\n  mp_srcptr   xp;\n  char        *tp, *bp;\n  mp_limb_t   xlimb;\n  int         zeros;\n  size_t      tsize, ssize;\n\n  xsize = SIZ(x);\n  abs_xsize = ABS (xsize);\n  bytes = (abs_xsize * GMP_NUMB_BITS + 7) / 8;\n  tsize = ROUND_UP_MULTIPLE ((unsigned) 4, GMP_LIMB_BYTES) + bytes;\n\n  tp = __GMP_ALLOCATE_FUNC_TYPE (tsize, char);\n  bp = tp + ROUND_UP_MULTIPLE ((unsigned) 4, GMP_LIMB_BYTES);\n\n  if (bytes != 0)\n    {\n      bp += bytes;\n      xp = PTR (x);\n      i = abs_xsize;\n\n      if (GMP_NAIL_BITS == 0)\n\t{\n\t  /* reverse limb order, and byte swap if necessary */\n#ifdef _CRAY\n\t  _Pragma (\"_CRI ivdep\");\n#endif\n\t  do\n\t    {\n\t      bp -= GMP_LIMB_BYTES;\n\t      xlimb = *xp;\n\t      HTON_LIMB_STORE ((mp_ptr) bp, xlimb);\n\t      xp++;\n\t    }\n\t  while (--i > 0);\n\n\t  /* strip high zero bytes (without fetching from bp) */\n\t  count_leading_zeros (zeros, xlimb);\n\t  zeros /= 8;\n\t  bp += zeros;\n\t  bytes -= zeros;\n\t}\n      else\n\t{\n\t  mp_limb_t  new_xlimb;\n\t  int        bits;\n\t  ASSERT_CODE (char *bp_orig = bp - bytes);\n\n\t  ASSERT_ALWAYS (GMP_NUMB_BITS >= 8);\n\n\t  bits = 0;\n\t  xlimb = 0;\n\t  for (;;)\n\t    {\n\t      while (bits >= 8)\n\t\t{\n\t\t  ASSERT (bp > bp_orig);\n\t\t  *--bp = xlimb & 0xFF;\n\t\t  xlimb >>= 8;\n\t\t  bits -= 8;\n\t\t}\n\n\t      if (i == 0)\n\t\tbreak;\n\n\t      new_xlimb = *xp++;\n\t      i--;\n\t      ASSERT (bp > bp_orig);\n\t      *--bp = (xlimb | (new_xlimb << bits)) & 0xFF;\n\t      xlimb = new_xlimb >> (8 - bits);\n\t      bits += GMP_NUMB_BITS - 8;\n\t    }\n\n\t  if (bits != 0)\n\t    {\n\t      ASSERT (bp > bp_orig);\n\t      *--bp = xlimb;\n\t    }\n\n\t  ASSERT (bp == bp_orig);\n\t  while (*bp == 0)\n\t    {\n\t      bp++;\n\t      bytes--;\n\t    }\n\t}\n    }\n\n  /* total bytes to be written */\n  ssize = 4 + bytes;\n\n  /* twos complement negative for the size value */\n  bytes = (xsize >= 0 ? bytes : -bytes);\n\n  /* so we don't rely on sign extension in \">>\" */\n  ASSERT_ALWAYS (sizeof (bytes) >= 4);\n\n  bp[-4] = bytes >> 24;\n  bp[-3] = bytes >> 16;\n  bp[-2] = bytes >> 8;\n  bp[-1] = bytes;\n  bp -= 4;\n\n  if (fp == 0)\n    fp = stdout;\n  if (fwrite (bp, ssize, 1, fp) != 1)\n    ssize = 0;\n\n  (*__gmp_free_func) (tp, tsize);\n  return ssize;\n}",
      "lines": 114,
      "depth": 16,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/out_str.c": {
    "mpz_out_str": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "size_t\nmpz_out_str (FILE *stream, int base, mpz_srcptr x)\n{\n  mp_ptr xp;\n  mp_size_t x_size = SIZ (x);\n  unsigned char *str;\n  size_t str_size;\n  size_t i;\n  size_t written;\n  const char *num_to_text;\n  TMP_DECL;\n\n  if (stream == 0)\n    stream = stdout;\n\n  if (base >= 0)\n    {\n      num_to_text = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n      if (base <= 1)\n\tbase = 10;\n      else if (base > 36)\n\t{\n\t  num_to_text = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\t  if (base > 62)\n\t    return 0;\n\t}\n    }\n  else\n    {\n      base = -base;\n      if (base <= 1)\n\tbase = 10;\n      else if (base > 36)\n\treturn 0;\n      num_to_text = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    }\n\n  written = 0;\n\n  if (x_size < 0)\n    {\n      fputc ('-', stream);\n      x_size = -x_size;\n      written = 1;\n    }\n\n  TMP_MARK;\n\n  DIGITS_IN_BASE_PER_LIMB (str_size, x_size, base);\n  str_size += 3;\n  str = (unsigned char *) TMP_ALLOC (str_size);\n\n  xp = PTR (x);\n  if (! POW2_P (base))\n    {\n      xp = TMP_ALLOC_LIMBS (x_size | 1);  /* |1 in case x_size==0 */\n      MPN_COPY (xp, PTR (x), x_size);\n    }\n\n  str_size = mpn_get_str (str, base, xp, x_size);\n\n  /* Convert result to printable chars.  */\n  for (i = 0; i < str_size; i++)\n    str[i] = num_to_text[str[i]];\n  str[str_size] = 0;\n\n  {\n    size_t fwret;\n    fwret = fwrite ((char *) str, 1, str_size, stream);\n    written += fwret;\n  }\n\n  TMP_FREE;\n  return ferror (stream) ? 0 : written;\n}",
      "lines": 75,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/perfpow.c": {
    "mpz_perfect_power_p": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nmpz_perfect_power_p (mpz_srcptr u)\n{\n  return mpn_perfect_power_p (PTR (u), SIZ (u));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/perfsqr.c": {},
  "gmp/gmp-6.1.2/mpz/popcount.c": {},
  "gmp/gmp-6.1.2/mpz/powm.c": {
    "mpz_powm": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void\nmpz_powm (mpz_ptr r, mpz_srcptr b, mpz_srcptr e, mpz_srcptr m)\n{\n  mp_size_t n, nodd, ncnt;\n  int cnt;\n  mp_ptr rp, tp;\n  mp_srcptr bp, ep, mp;\n  mp_size_t rn, bn, es, en, itch;\n  mpz_t new_b;\t\t\t/* note: value lives long via 'b' */\n  TMP_DECL;\n\n  n = ABSIZ(m);\n  if (UNLIKELY (n == 0))\n    DIVIDE_BY_ZERO;\n\n  mp = PTR(m);\n\n  TMP_MARK;\n\n  es = SIZ(e);\n  if (UNLIKELY (es <= 0))\n    {\n      if (es == 0)\n\t{\n\t  /* b^0 mod m,  b is anything and m is non-zero.\n\t     Result is 1 mod m, i.e., 1 or 0 depending on if m = 1.  */\n\t  SIZ(r) = n != 1 || mp[0] != 1;\n\t  PTR(r)[0] = 1;\n\t  TMP_FREE;\t/* we haven't really allocated anything here */\n\t  return;\n\t}\n#if HANDLE_NEGATIVE_EXPONENT\n      MPZ_TMP_INIT (new_b, n + 1);\n\n      if (UNLIKELY (! mpz_invert (new_b, b, m)))\n\tDIVIDE_BY_ZERO;\n      b = new_b;\n      es = -es;\n#else\n      DIVIDE_BY_ZERO;\n#endif\n    }\n  en = es;\n\n  bn = ABSIZ(b);\n\n  if (UNLIKELY (bn == 0))\n    {\n      SIZ(r) = 0;\n      TMP_FREE;\n      return;\n    }\n\n  ep = PTR(e);\n\n  /* Handle (b^1 mod m) early, since mpn_pow* do not handle that case.  */\n  if (UNLIKELY (en == 1 && ep[0] == 1))\n    {\n      rp = TMP_ALLOC_LIMBS (n);\n      bp = PTR(b);\n      if (bn >= n)\n\t{\n\t  mp_ptr qp = TMP_ALLOC_LIMBS (bn - n + 1);\n\t  mpn_tdiv_qr (qp, rp, 0L, bp, bn, mp, n);\n\t  rn = n;\n\t  MPN_NORMALIZE (rp, rn);\n\n\t  if (SIZ(b) < 0 && rn != 0)\n\t    {\n\t      mpn_sub (rp, mp, n, rp, rn);\n\t      rn = n;\n\t      MPN_NORMALIZE (rp, rn);\n\t    }\n\t}\n      else\n\t{\n\t  if (SIZ(b) < 0)\n\t    {\n\t      mpn_sub (rp, mp, n, bp, bn);\n\t      rn = n;\n\t      rn -= (rp[rn - 1] == 0);\n\t    }\n\t  else\n\t    {\n\t      MPN_COPY (rp, bp, bn);\n\t      rn = bn;\n\t    }\n\t}\n      goto ret;\n    }\n\n  /* Remove low zero limbs from M.  This loop will terminate for correctly\n     represented mpz numbers.  */\n  ncnt = 0;\n  while (UNLIKELY (mp[0] == 0))\n    {\n      mp++;\n      ncnt++;\n    }\n  nodd = n - ncnt;\n  cnt = 0;\n  if (mp[0] % 2 == 0)\n    {\n      mp_ptr newmp = TMP_ALLOC_LIMBS (nodd);\n      count_trailing_zeros (cnt, mp[0]);\n      mpn_rshift (newmp, mp, nodd, cnt);\n      nodd -= newmp[nodd - 1] == 0;\n      mp = newmp;\n      ncnt++;\n    }\n\n  if (ncnt != 0)\n    {\n      /* We will call both mpn_powm and mpn_powlo.  */\n      /* rp needs n, mpn_powlo needs 4n, the 2 mpn_binvert might need more */\n      mp_size_t n_largest_binvert = MAX (ncnt, nodd);\n      mp_size_t itch_binvert = mpn_binvert_itch (n_largest_binvert);\n      itch = 3 * n + MAX (itch_binvert, 2 * n);\n    }\n  else\n    {\n      /* We will call just mpn_powm.  */\n      mp_size_t itch_binvert = mpn_binvert_itch (nodd);\n      itch = n + MAX (itch_binvert, 2 * n);\n    }\n  tp = TMP_ALLOC_LIMBS (itch);\n\n  rp = tp;  tp += n;\n\n  bp = PTR(b);\n  mpn_powm (rp, bp, bn, ep, en, mp, nodd, tp);\n\n  rn = n;\n\n  if (ncnt != 0)\n    {\n      mp_ptr r2, xp, yp, odd_inv_2exp;\n      unsigned long t;\n      int bcnt;\n\n      if (bn < ncnt)\n\t{\n\t  mp_ptr newbp = TMP_ALLOC_LIMBS (ncnt);\n\t  MPN_COPY (newbp, bp, bn);\n\t  MPN_ZERO (newbp + bn, ncnt - bn);\n\t  bp = newbp;\n\t}\n\n      r2 = tp;\n\n      if (bp[0] % 2 == 0)\n\t{\n\t  if (en > 1)\n\t    {\n\t      MPN_ZERO (r2, ncnt);\n\t      goto zero;\n\t    }\n\n\t  ASSERT (en == 1);\n\t  t = (ncnt - (cnt != 0)) * GMP_NUMB_BITS + cnt;\n\n\t  /* Count number of low zero bits in B, up to 3.  */\n\t  bcnt = (0x1213 >> ((bp[0] & 7) << 1)) & 0x3;\n\t  /* Note that ep[0] * bcnt might overflow, but that just results\n\t     in a missed optimization.  */\n\t  if (ep[0] * bcnt >= t)\n\t    {\n\t      MPN_ZERO (r2, ncnt);\n\t      goto zero;\n\t    }\n\t}\n\n      mpn_powlo (r2, bp, ep, en, ncnt, tp + ncnt);\n\n    zero:\n      if (nodd < ncnt)\n\t{\n\t  mp_ptr newmp = TMP_ALLOC_LIMBS (ncnt);\n\t  MPN_COPY (newmp, mp, nodd);\n\t  MPN_ZERO (newmp + nodd, ncnt - nodd);\n\t  mp = newmp;\n\t}\n\n      odd_inv_2exp = tp + n;\n      mpn_binvert (odd_inv_2exp, mp, ncnt, tp + 2 * n);\n\n      mpn_sub (r2, r2, ncnt, rp, nodd > ncnt ? ncnt : nodd);\n\n      xp = tp + 2 * n;\n      mpn_mullo_n (xp, odd_inv_2exp, r2, ncnt);\n\n      if (cnt != 0)\n\txp[ncnt - 1] &= (CNST_LIMB(1) << cnt) - 1;\n\n      yp = tp;\n      if (ncnt > nodd)\n\tmpn_mul (yp, xp, ncnt, mp, nodd);\n      else\n\tmpn_mul (yp, mp, nodd, xp, ncnt);\n\n      mpn_add (rp, yp, n, rp, nodd);\n\n      ASSERT (nodd + ncnt >= n);\n      ASSERT (nodd + ncnt <= n + 1);\n    }\n\n  MPN_NORMALIZE (rp, rn);\n\n  if ((ep[0] & 1) && SIZ(b) < 0 && rn != 0)\n    {\n      mpn_sub (rp, PTR(m), n, rp, rn);\n      rn = n;\n      MPN_NORMALIZE (rp, rn);\n    }\n\n ret:\n  MPZ_REALLOC (r, rn);\n  SIZ(r) = rn;\n  MPN_COPY (PTR(r), rp, rn);\n\n  TMP_FREE;\n}",
      "lines": 222,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/powm_sec.c": {
    "mpz_powm_sec": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void\nmpz_powm_sec (mpz_ptr r, mpz_srcptr b, mpz_srcptr e, mpz_srcptr m)\n{\n  mp_size_t n;\n  mp_ptr rp, tp;\n  mp_srcptr bp, ep, mp;\n  mp_size_t rn, bn, es, en;\n  TMP_DECL;\n\n  n = ABSIZ(m);\n\n  mp = PTR(m);\n\n  if (UNLIKELY ((n == 0) || (mp[0] % 2 == 0)))\n    DIVIDE_BY_ZERO;\n\n  es = SIZ(e);\n  if (UNLIKELY (es <= 0))\n    {\n      if (es == 0)\n\t{\n\t  /* b^0 mod m,  b is anything and m is non-zero.\n\t     Result is 1 mod m, i.e., 1 or 0 depending on if m = 1.  */\n\t  SIZ(r) = n != 1 || mp[0] != 1;\n\t  PTR(r)[0] = 1;\n\t  return;\n\t}\n      DIVIDE_BY_ZERO;\n    }\n  en = es;\n\n  bn = ABSIZ(b);\n\n  if (UNLIKELY (bn == 0))\n    {\n      SIZ(r) = 0;\n      return;\n    }\n\n  TMP_MARK;\n  tp = TMP_ALLOC_LIMBS (n + mpn_sec_powm_itch (bn, en * GMP_NUMB_BITS, n));\n\n  rp = tp;  tp += n;\n\n  bp = PTR(b);\n  ep = PTR(e);\n\n  mpn_sec_powm (rp, bp, bn, ep, en * GMP_NUMB_BITS, mp, n, tp);\n\n  rn = n;\n\n  MPN_NORMALIZE (rp, rn);\n\n  if ((ep[0] & 1) && SIZ(b) < 0 && rn != 0)\n    {\n      mpn_sub (rp, PTR(m), n, rp, rn);\n      rn = n;\n      MPN_NORMALIZE (rp, rn);\n    }\n\n  MPZ_REALLOC (r, rn);\n  SIZ(r) = rn;\n  MPN_COPY (PTR(r), rp, rn);\n\n  TMP_FREE;\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/powm_ui.c": {
    "mod": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static void\nmod (mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, gmp_pi1_t *dinv, mp_ptr tp)\n{\n  mp_ptr qp;\n  TMP_DECL;\n  TMP_MARK;\n\n  qp = tp;\n\n  if (dn == 1)\n    {\n      np[0] = mpn_divrem_1 (qp, (mp_size_t) 0, np, nn, dp[0]);\n    }\n  else if (dn == 2)\n    {\n      mpn_div_qr_2n_pi1 (qp, np, np, nn, dp[1], dp[0], dinv->inv32);\n    }\n  else if (BELOW_THRESHOLD (dn, DC_DIV_QR_THRESHOLD) ||\n\t   BELOW_THRESHOLD (nn - dn, DC_DIV_QR_THRESHOLD))\n    {\n      mpn_sbpi1_div_qr (qp, np, nn, dp, dn, dinv->inv32);\n    }\n  else if (BELOW_THRESHOLD (dn, MUPI_DIV_QR_THRESHOLD) ||   /* fast condition */\n\t   BELOW_THRESHOLD (nn, 2 * MU_DIV_QR_THRESHOLD) || /* fast condition */\n\t   (double) (2 * (MU_DIV_QR_THRESHOLD - MUPI_DIV_QR_THRESHOLD)) * dn /* slow... */\n\t   + (double) MUPI_DIV_QR_THRESHOLD * nn > (double) dn * nn)    /* ...condition */\n    {\n      mpn_dcpi1_div_qr (qp, np, nn, dp, dn, dinv);\n    }\n  else\n    {\n      /* We need to allocate separate remainder area, since mpn_mu_div_qr does\n\t not handle overlap between the numerator and remainder areas.\n\t FIXME: Make it handle such overlap.  */\n      mp_ptr rp = TMP_BALLOC_LIMBS (dn);\n      mp_size_t itch = mpn_mu_div_qr_itch (nn, dn, 0);\n      mp_ptr scratch = TMP_BALLOC_LIMBS (itch);\n      mpn_mu_div_qr (qp, rp, np, nn, dp, dn, scratch);\n      MPN_COPY (np, rp, dn);\n    }\n\n  TMP_FREE;\n}",
      "lines": 43,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "reduce": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static void\nreduce (mp_ptr tp, mp_srcptr ap, mp_size_t an, mp_srcptr mp, mp_size_t mn, gmp_pi1_t *dinv)\n{\n  mp_ptr rp, scratch;\n  TMP_DECL;\n  TMP_MARK;\n\n  rp = TMP_ALLOC_LIMBS (an);\n  scratch = TMP_ALLOC_LIMBS (an - mn + 1);\n  MPN_COPY (rp, ap, an);\n  mod (rp, an, mp, mn, dinv, scratch);\n  MPN_COPY (tp, rp, mn);\n\n  TMP_FREE;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_powm_ui": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "void\nmpz_powm_ui (mpz_ptr r, mpz_srcptr b, unsigned long int el, mpz_srcptr m)\n{\n  if (el < 20)\n    {\n      mp_ptr xp, tp, mp, bp, scratch;\n      mp_size_t xn, tn, mn, bn;\n      int m_zero_cnt;\n      int c;\n      mp_limb_t e, m2;\n      gmp_pi1_t dinv;\n      TMP_DECL;\n\n      mp = PTR(m);\n      mn = ABSIZ(m);\n      if (UNLIKELY (mn == 0))\n\tDIVIDE_BY_ZERO;\n\n      if (el == 0)\n\t{\n\t  /* Exponent is zero, result is 1 mod M, i.e., 1 or 0 depending on if\n\t     M equals 1.  */\n\t  SIZ(r) = (mn == 1 && mp[0] == 1) ? 0 : 1;\n\t  PTR(r)[0] = 1;\n\t  return;\n\t}\n\n      TMP_MARK;\n\n      /* Normalize m (i.e. make its most significant bit set) as required by\n\t division functions below.  */\n      count_leading_zeros (m_zero_cnt, mp[mn - 1]);\n      m_zero_cnt -= GMP_NAIL_BITS;\n      if (m_zero_cnt != 0)\n\t{\n\t  mp_ptr new_mp = TMP_ALLOC_LIMBS (mn);\n\t  mpn_lshift (new_mp, mp, mn, m_zero_cnt);\n\t  mp = new_mp;\n\t}\n\n      m2 = mn == 1 ? 0 : mp[mn - 2];\n      invert_pi1 (dinv, mp[mn - 1], m2);\n\n      bn = ABSIZ(b);\n      bp = PTR(b);\n      if (bn > mn)\n\t{\n\t  /* Reduce possibly huge base.  Use a function call to reduce, since we\n\t     don't want the quotient allocation to live until function return.  */\n\t  mp_ptr new_bp = TMP_ALLOC_LIMBS (mn);\n\t  reduce (new_bp, bp, bn, mp, mn, &dinv);\n\t  bp = new_bp;\n\t  bn = mn;\n\t  /* Canonicalize the base, since we are potentially going to multiply with\n\t     it quite a few times.  */\n\t  MPN_NORMALIZE (bp, bn);\n\t}\n\n      if (bn == 0)\n\t{\n\t  SIZ(r) = 0;\n\t  TMP_FREE;\n\t  return;\n\t}\n\n      tp = TMP_ALLOC_LIMBS (2 * mn + 1);\n      xp = TMP_ALLOC_LIMBS (mn);\n      scratch = TMP_ALLOC_LIMBS (mn + 1);\n\n      MPN_COPY (xp, bp, bn);\n      xn = bn;\n\n      e = el;\n      count_leading_zeros (c, e);\n      e = (e << c) << 1;\t\t/* shift the exp bits to the left, lose msb */\n      c = GMP_LIMB_BITS - 1 - c;\n\n      if (c == 0)\n\t{\n\t  /* If m is already normalized (high bit of high limb set), and b is\n\t     the same size, but a bigger value, and e==1, then there's no\n\t     modular reductions done and we can end up with a result out of\n\t     range at the end. */\n\t  if (xn == mn && mpn_cmp (xp, mp, mn) >= 0)\n\t    mpn_sub_n (xp, xp, mp, mn);\n\t}\n      else\n\t{\n\t  /* Main loop. */\n\t  do\n\t    {\n\t      mpn_sqr (tp, xp, xn);\n\t      tn = 2 * xn; tn -= tp[tn - 1] == 0;\n\t      if (tn < mn)\n\t\t{\n\t\t  MPN_COPY (xp, tp, tn);\n\t\t  xn = tn;\n\t\t}\n\t      else\n\t\t{\n\t\t  mod (tp, tn, mp, mn, &dinv, scratch);\n\t\t  MPN_COPY (xp, tp, mn);\n\t\t  xn = mn;\n\t\t}\n\n\t      if ((mp_limb_signed_t) e < 0)\n\t\t{\n\t\t  mpn_mul (tp, xp, xn, bp, bn);\n\t\t  tn = xn + bn; tn -= tp[tn - 1] == 0;\n\t\t  if (tn < mn)\n\t\t    {\n\t\t      MPN_COPY (xp, tp, tn);\n\t\t      xn = tn;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      mod (tp, tn, mp, mn, &dinv, scratch);\n\t\t      MPN_COPY (xp, tp, mn);\n\t\t      xn = mn;\n\t\t    }\n\t\t}\n\t      e <<= 1;\n\t      c--;\n\t    }\n\t  while (c != 0);\n\t}\n\n      /* We shifted m left m_zero_cnt steps.  Adjust the result by reducing it\n\t with the original M.  */\n      if (m_zero_cnt != 0)\n\t{\n\t  mp_limb_t cy;\n\t  cy = mpn_lshift (tp, xp, xn, m_zero_cnt);\n\t  tp[xn] = cy; xn += cy != 0;\n\n\t  if (xn < mn)\n\t    {\n\t      MPN_COPY (xp, tp, xn);\n\t    }\n\t  else\n\t    {\n\t      mod (tp, xn, mp, mn, &dinv, scratch);\n\t      MPN_COPY (xp, tp, mn);\n\t      xn = mn;\n\t    }\n\t  mpn_rshift (xp, xp, xn, m_zero_cnt);\n\t}\n      MPN_NORMALIZE (xp, xn);\n\n      if ((el & 1) != 0 && SIZ(b) < 0 && xn != 0)\n\t{\n\t  mp = PTR(m);\t\t\t/* want original, unnormalized m */\n\t  mpn_sub (xp, mp, mn, xp, xn);\n\t  xn = mn;\n\t  MPN_NORMALIZE (xp, xn);\n\t}\n      MPZ_REALLOC (r, xn);\n      SIZ (r) = xn;\n      MPN_COPY (PTR(r), xp, xn);\n\n      TMP_FREE;\n    }\n  else\n    {\n      /* For large exponents, fake an mpz_t exponent and deflect to the more\n\t sophisticated mpz_powm.  */\n      mpz_t e;\n      mp_limb_t ep[LIMBS_PER_ULONG];\n      MPZ_FAKE_UI (e, ep, el);\n      mpz_powm (r, b, e, m);\n    }\n}",
      "lines": 172,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/pow_ui.c": {
    "mpz_pow_ui": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\nmpz_pow_ui (mpz_ptr r, mpz_srcptr b, unsigned long int e)\n{\n  /* We test some small exponents here, mainly to avoid the overhead of\n     mpz_n_pow_ui for small bases and exponents.  */\n  switch (e)\n    {\n    case 0:\n      mpz_set_ui (r, 1);\n      break;\n    case 1:\n      mpz_set (r, b);\n      break;\n    case 2:\n      mpz_mul (r, b, b);\n      break;\n    default:\n      mpz_n_pow_ui (r, PTR(b), (mp_size_t) SIZ(b), e);\n    }\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/pprime_p.c": {
    "mpz_probab_prime_p": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\nmpz_probab_prime_p (mpz_srcptr n, int reps)\n{\n  mp_limb_t r;\n  mpz_t n2;\n\n  /* Handle small and negative n.  */\n  if (mpz_cmp_ui (n, 1000000L) <= 0)\n    {\n      int is_prime;\n      if (mpz_cmpabs_ui (n, 1000000L) <= 0)\n\t{\n\t  is_prime = isprime (mpz_get_ui (n));\n\t  return is_prime ? 2 : 0;\n\t}\n      /* Negative number.  Negate and fall out.  */\n      PTR(n2) = PTR(n);\n      SIZ(n2) = -SIZ(n);\n      n = n2;\n    }\n\n  /* If n is now even, it is not a prime.  */\n  if ((mpz_get_ui (n) & 1) == 0)\n    return 0;\n\n#if defined (PP)\n  /* Check if n has small factors.  */\n#if defined (PP_INVERTED)\n  r = MPN_MOD_OR_PREINV_MOD_1 (PTR(n), (mp_size_t) SIZ(n), (mp_limb_t) PP,\n\t\t\t       (mp_limb_t) PP_INVERTED);\n#else\n  r = mpn_mod_1 (PTR(n), (mp_size_t) SIZ(n), (mp_limb_t) PP);\n#endif\n  if (r % 3 == 0\n#if GMP_LIMB_BITS >= 4\n      || r % 5 == 0\n#endif\n#if GMP_LIMB_BITS >= 8\n      || r % 7 == 0\n#endif\n#if GMP_LIMB_BITS >= 16\n      || r % 11 == 0 || r % 13 == 0\n#endif\n#if GMP_LIMB_BITS >= 32\n      || r % 17 == 0 || r % 19 == 0 || r % 23 == 0 || r % 29 == 0\n#endif\n#if GMP_LIMB_BITS >= 64\n      || r % 31 == 0 || r % 37 == 0 || r % 41 == 0 || r % 43 == 0\n      || r % 47 == 0 || r % 53 == 0\n#endif\n      )\n    {\n      return 0;\n    }\n#endif /* PP */\n\n  /* Do more dividing.  We collect small primes, using umul_ppmm, until we\n     overflow a single limb.  We divide our number by the small primes product,\n     and look for factors in the remainder.  */\n  {\n    unsigned long int ln2;\n    unsigned long int q;\n    mp_limb_t p1, p0, p;\n    unsigned int primes[15];\n    int nprimes;\n\n    nprimes = 0;\n    p = 1;\n    ln2 = mpz_sizeinbase (n, 2);\t/* FIXME: tune this limit */\n    for (q = PP_FIRST_OMITTED; q < ln2; q += 2)\n      {\n\tif (isprime (q))\n\t  {\n\t    umul_ppmm (p1, p0, p, q);\n\t    if (p1 != 0)\n\t      {\n\t\tr = MPN_MOD_OR_MODEXACT_1_ODD (PTR(n), (mp_size_t) SIZ(n), p);\n\t\twhile (--nprimes >= 0)\n\t\t  if (r % primes[nprimes] == 0)\n\t\t    {\n\t\t      ASSERT_ALWAYS (mpn_mod_1 (PTR(n), (mp_size_t) SIZ(n), (mp_limb_t) primes[nprimes]) == 0);\n\t\t      return 0;\n\t\t    }\n\t\tp = q;\n\t\tnprimes = 0;\n\t      }\n\t    else\n\t      {\n\t\tp = p0;\n\t      }\n\t    primes[nprimes++] = q;\n\t  }\n      }\n  }\n\n  /* Perform a number of Miller-Rabin tests.  */\n  return mpz_millerrabin (n, reps);\n}",
      "lines": 98,
      "depth": 23,
      "decorators": [
        "int"
      ]
    },
    "isprime": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static int\nisprime (unsigned long int t)\n{\n  unsigned long int q, r, d;\n\n  if (t < 3 || (t & 1) == 0)\n    return t == 2;\n\n  for (d = 3, r = 1; r != 0; d += 2)\n    {\n      q = t / d;\n      r = t - q * d;\n      if (q < d)\n\treturn 1;\n    }\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/primorial_ui.c": {
    "bit_to_n": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        87,
        48
      ],
      "content": "static mp_limb_t\nbit_to_n (mp_limb_t bit) { return (bit*3+4)|1; }",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "id_to_n": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        92,
        50
      ],
      "content": "static mp_limb_t\nid_to_n  (mp_limb_t id)  { return id*3+1+(id&1); }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "n_to_bit": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        96,
        47
      ],
      "content": "static mp_limb_t\nn_to_bit (mp_limb_t n) { return ((n-5)|1)/3U; }",
      "lines": 2,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "primesieve_size": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        100,
        73
      ],
      "content": "static mp_size_t\nprimesieve_size (mp_limb_t n) { return n_to_bit(n) / GMP_LIMB_BITS + 1; }",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpz_primorial_ui": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "void\nmpz_primorial_ui (mpz_ptr x, unsigned long n)\n{\n  static const mp_limb_t table[] = { 1, 1, 2, 6, 6 };\n\n  ASSERT (n <= GMP_NUMB_MAX);\n\n  if (n < numberof (table))\n    {\n      PTR (x)[0] = table[n];\n      SIZ (x) = 1;\n    }\n  else\n    {\n      mp_limb_t *sieve, *factors;\n      mp_size_t size;\n      mp_limb_t prod;\n      mp_limb_t j;\n      TMP_DECL;\n\n      size = 1 + n / GMP_NUMB_BITS + n / (2*GMP_NUMB_BITS);\n      ASSERT (size >= primesieve_size (n));\n      sieve = MPZ_NEWALLOC (x, size);\n      size = (gmp_primesieve (sieve, n) + 1) / log_n_max (n) + 1;\n\n      TMP_MARK;\n      factors = TMP_ALLOC_LIMBS (size);\n\n      j = 0;\n\n      prod = table[numberof (table)-1];\n\n      /* Store primes from 5 to n */\n      {\n\tmp_limb_t prime, max_prod;\n\n\tmax_prod = GMP_NUMB_MAX / n;\n\n\tLOOP_ON_SIEVE_BEGIN (prime, n_to_bit(numberof (table)), n_to_bit (n), 0, sieve);\n\tFACTOR_LIST_STORE (prime, prod, max_prod, factors, j);\n\tLOOP_ON_SIEVE_END;\n      }\n\n      if (LIKELY (j != 0))\n\t{\n\t  factors[j++] = prod;\n\t  mpz_prodlimbs (x, factors, j);\n\t}\n      else\n\t{\n\t  PTR (x)[0] = prod;\n\t  SIZ (x) = 1;\n\t}\n\n      TMP_FREE;\n    }\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/prodlimbs.c": {
    "mpz_prodlimbs": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "mp_size_t\nmpz_prodlimbs (mpz_ptr x, mp_ptr factors, mp_size_t j)\n{\n  mp_limb_t cy;\n  mp_size_t size, i;\n  mp_ptr    prod;\n\n  ASSERT (j > 1);\n  ASSERT (RECURSIVE_PROD_THRESHOLD > 3);\n\n  if (BELOW_THRESHOLD (j, RECURSIVE_PROD_THRESHOLD)) {\n    j--;\n    size = 1;\n\n    for (i = 1; i < j; i++)\n      {\n\tcy = mpn_mul_1 (factors, factors, size, factors[i]);\n\tfactors[size] = cy;\n\tsize += cy != 0;\n      };\n\n    prod = MPZ_NEWALLOC (x, size + 1);\n\n    cy = mpn_mul_1 (prod, factors, size, factors[i]);\n    prod[size] = cy;\n    return SIZ (x) = size + (cy != 0);\n  } else {\n    mpz_t x1, x2;\n    TMP_DECL;\n\n    i = j >> 1;\n    j -= i;\n    TMP_MARK;\n\n    MPZ_TMP_INIT (x2, j);\n\n    PTR (x1) = factors + i;\n    ALLOC (x1) = j;\n    j = mpz_prodlimbs (x2, factors + i, j);\n    i = mpz_prodlimbs (x1, factors, i);\n    size = i + j;\n    prod = MPZ_NEWALLOC (x, size);\n    if (i >= j)\n      cy = mpn_mul (prod, PTR(x1), i, PTR(x2), j);\n    else\n      cy = mpn_mul (prod, PTR(x2), j, PTR(x1), i);\n    TMP_FREE;\n\n    return SIZ (x) = size - (cy == 0);\n  }\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/random.c": {
    "mpz_random": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\nmpz_random (mpz_ptr x, mp_size_t size)\n{\n  mpz_urandomb (x, RANDS, (unsigned long) (ABS (size) * GMP_NUMB_BITS));\n  if (size < 0)\n    SIZ(x) = -SIZ(x);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/random2.c": {
    "mpz_random2": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\nmpz_random2 (mpz_ptr x, mp_size_t size)\n{\n  mp_size_t abs_size;\n  mp_ptr xp;\n\n  abs_size = ABS (size);\n  if (abs_size != 0)\n    {\n      xp = MPZ_REALLOC (x, abs_size);\n\n      mpn_random2 (xp, abs_size);\n    }\n\n  SIZ (x) = size;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/realloc.c": {
    "_mpz_realloc": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void *\n_mpz_realloc (mpz_ptr m, mp_size_t new_alloc)\n{\n  mp_ptr mp;\n\n  /* Never allocate zero space. */\n  new_alloc = MAX (new_alloc, 1);\n\n  if (sizeof (mp_size_t) == sizeof (int))\n    {\n      if (UNLIKELY (new_alloc > ULONG_MAX / GMP_NUMB_BITS))\n\t{\n\t  fprintf (stderr, \"gmp: overflow in mpz type\\n\");\n\t  abort ();\n\t}\n    }\n  else\n    {\n      if (UNLIKELY (new_alloc > INT_MAX))\n\t{\n\t  fprintf (stderr, \"gmp: overflow in mpz type\\n\");\n\t  abort ();\n\t}\n    }\n\n  mp = __GMP_REALLOCATE_FUNC_LIMBS (PTR(m), ALLOC(m), new_alloc);\n  PTR(m) = mp;\n  ALLOC(m) = new_alloc;\n\n  /* Don't create an invalid number; if the current value doesn't fit after\n     reallocation, clear it to 0.  */\n  if (ABSIZ(m) > new_alloc)\n    SIZ(m) = 0;\n\n  return (void *) mp;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "void",
        "*\n_mpz_realloc (mpz_ptr m, mp_size_t new_alloc)",
        "*"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/realloc2.c": {
    "mpz_realloc2": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nmpz_realloc2 (mpz_ptr m, mp_bitcnt_t bits)\n{\n  mp_size_t new_alloc;\n\n  bits -= (bits != 0);\t\t/* Round down, except if 0 */\n  new_alloc = 1 + bits / GMP_NUMB_BITS;\n\n  if (sizeof (unsigned long) > sizeof (int)) /* param vs _mp_size field */\n    {\n      if (UNLIKELY (new_alloc > INT_MAX))\n\t{\n\t  fprintf (stderr, \"gmp: overflow in mpz type\\n\");\n\t  abort ();\n\t}\n    }\n\n  PTR(m) = __GMP_REALLOCATE_FUNC_LIMBS (PTR(m), ALLOC(m), new_alloc);\n  ALLOC(m) = new_alloc;\n\n  /* Don't create an invalid number; if the current value doesn't fit after\n     reallocation, clear it to 0.  */\n  if (ABSIZ(m) > new_alloc)\n    SIZ(m) = 0;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/remove.c": {
    "mpz_remove": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_remove (mpz_ptr dest, mpz_srcptr src, mpz_srcptr f)\n{\n  mp_bitcnt_t pwr;\n  mp_srcptr fp;\n  mp_size_t sn, fn, afn;\n  mp_limb_t fp0;\n\n  sn = SIZ (src);\n  fn = SIZ (f);\n  fp = PTR (f);\n  afn = ABS (fn);\n  fp0 = fp[0];\n\n  if (UNLIKELY ((afn <= (fp0 == 1)) /* mpz_cmpabs_ui (f, 1) <= 0 */\n\t\t| (sn == 0)))\n    {\n      /*  f = 0 or f = +- 1 or src = 0 */\n      if (afn == 0)\n\tDIVIDE_BY_ZERO;\n      mpz_set (dest, src);\n      return 0;\n    }\n\n  if ((fp0 & 1) != 0)\n    { /* f is odd */\n      mp_ptr dp;\n      mp_size_t dn;\n\n      dn = ABS (sn);\n      dp = MPZ_REALLOC (dest, dn);\n\n      pwr = mpn_remove (dp, &dn, PTR(src), dn, PTR(f), afn, ~(mp_bitcnt_t) 0);\n\n      SIZ (dest) = ((pwr & (fn < 0)) ^ (sn < 0)) ? -dn : dn;\n    }\n  else if (afn == (fp0 == 2))\n    { /* mpz_cmpabs_ui (f, 2) == 0 */\n      pwr = mpz_scan1 (src, 0);\n      mpz_div_2exp (dest, src, pwr);\n      if (pwr & (fn < 0)) /*((pwr % 2 == 1) && (SIZ (f) < 0))*/\n\tmpz_neg (dest, dest);\n    }\n  else\n    { /* f != +-2 */\n      mpz_t x, rem;\n\n      mpz_init (rem);\n      mpz_init (x);\n\n      pwr = 0;\n      mpz_tdiv_qr (x, rem, src, f);\n      if (SIZ (rem) == 0)\n\t{\n\t  mpz_t fpow[GMP_LIMB_BITS];\t\t/* Really MP_SIZE_T_BITS */\n\t  int p;\n\n#if WANT_ORIGINAL_DEST\n\t  mp_ptr dp;\n\t  dp = PTR (dest);\n#endif\n      /* We could perhaps compute mpz_scan1(src,0)/mpz_scan1(f,0).  It is an\n\t upper bound of the result we're seeking.  We could also shift down the\n\t operands so that they become odd, to make intermediate values\n\t smaller.  */\n\t  mpz_init_set (fpow[0], f);\n\t  mpz_swap (dest, x);\n\n\t  p = 1;\n      /* Divide by f, f^2 ... f^(2^k) until we get a remainder for f^(2^k).  */\n\t  while (ABSIZ (dest) >= 2 * ABSIZ (fpow[p - 1]) - 1)\n\t    {\n\t      mpz_init (fpow[p]);\n\t      mpz_mul (fpow[p], fpow[p - 1], fpow[p - 1]);\n\t      mpz_tdiv_qr (x, rem, dest, fpow[p]);\n\t      if (SIZ (rem) != 0) {\n\t\tmpz_clear (fpow[p]);\n\t\tbreak;\n\t      }\n\t      mpz_swap (dest, x);\n\t      p++;\n\t    }\n\n\t  pwr = ((mp_bitcnt_t)1 << p) - 1;\n\n      /* Divide by f^(2^(k-1)), f^(2^(k-2)), ..., f for all divisors that give\n\t a zero remainder.  */\n\t  while (--p >= 0)\n\t    {\n\t      mpz_tdiv_qr (x, rem, dest, fpow[p]);\n\t      if (SIZ (rem) == 0)\n\t\t{\n\t\t  pwr += (mp_bitcnt_t)1 << p;\n\t\t  mpz_swap (dest, x);\n\t\t}\n\t      mpz_clear (fpow[p]);\n\t    }\n\n#if WANT_ORIGINAL_DEST\n\t  if (PTR (x) == dp) {\n\t    mpz_swap (dest, x);\n\t    mpz_set (dest, x);\n\t  }\n#endif\n\t}\n      else\n\tmpz_set (dest, src);\n\n      mpz_clear (x);\n      mpz_clear (rem);\n    }\n\n  return pwr;\n}",
      "lines": 114,
      "depth": 17,
      "decorators": [
        "mp_bitcnt_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/roinit_n.c": {
    "mpz_roinit_n": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "mpz_srcptr\nmpz_roinit_n (mpz_ptr x, mp_srcptr xp, mp_size_t xs)\n{\n  mp_size_t xn = ABS(xs);\n  MPN_NORMALIZE (xp, xn);\n\n  ALLOC (x) = 0;\n  SIZ (x) = xs < 0 ? -xn : xn;\n  PTR (x) = (mp_ptr) xp;\n  return x;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "mpz_srcptr"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/root.c": {
    "mpz_root": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\nmpz_root (mpz_ptr root, mpz_srcptr u, unsigned long int nth)\n{\n  mp_ptr rootp, up;\n  mp_size_t us, un, rootn, remn;\n  TMP_DECL;\n\n  us = SIZ(u);\n\n  /* even roots of negatives provoke an exception */\n  if (UNLIKELY (us < 0 && (nth & 1) == 0))\n    SQRT_OF_NEGATIVE;\n\n  /* root extraction interpreted as c^(1/nth) means a zeroth root should\n     provoke a divide by zero, do this even if c==0 */\n  if (UNLIKELY (nth == 0))\n    DIVIDE_BY_ZERO;\n\n  if (us == 0)\n    {\n      if (root != NULL)\n\tSIZ(root) = 0;\n      return 1;\t\t\t/* exact result */\n    }\n\n  un = ABS (us);\n  rootn = (un - 1) / nth + 1;\n\n  TMP_MARK;\n\n  /* FIXME: Perhaps disallow root == NULL */\n  if (root != NULL && u != root)\n    rootp = MPZ_REALLOC (root, rootn);\n  else\n    rootp = TMP_ALLOC_LIMBS (rootn);\n\n  up = PTR(u);\n\n  if (nth == 1)\n    {\n      MPN_COPY (rootp, up, un);\n      remn = 0;\n    }\n  else\n    {\n      remn = mpn_rootrem (rootp, NULL, up, un, (mp_limb_t) nth);\n    }\n\n  if (root != NULL)\n    {\n      SIZ(root) = us >= 0 ? rootn : -rootn;\n      if (u == root)\n\tMPN_COPY (up, rootp, rootn);\n    }\n\n  TMP_FREE;\n  return remn == 0;\n}",
      "lines": 58,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/rootrem.c": {
    "mpz_rootrem": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "void\nmpz_rootrem (mpz_ptr root, mpz_ptr rem, mpz_srcptr u, unsigned long int nth)\n{\n  mp_ptr rootp, up, remp;\n  mp_size_t us, un, rootn, remn;\n  TMP_DECL;\n\n  us = SIZ(u);\n\n  /* even roots of negatives provoke an exception */\n  if (UNLIKELY (us < 0 && (nth & 1) == 0))\n    SQRT_OF_NEGATIVE;\n\n  /* root extraction interpreted as c^(1/nth) means a zeroth root should\n     provoke a divide by zero, do this even if c==0 */\n  if (UNLIKELY (nth == 0))\n    DIVIDE_BY_ZERO;\n\n  if (us == 0)\n    {\n      if (root != NULL)\n\tSIZ(root) = 0;\n      SIZ(rem) = 0;\n      return;\n    }\n\n  un = ABS (us);\n  rootn = (un - 1) / nth + 1;\n\n  TMP_MARK;\n\n  /* FIXME: Perhaps disallow root == NULL */\n  if (root != NULL && u != root)\n    rootp = MPZ_REALLOC (root, rootn);\n  else\n    rootp = TMP_ALLOC_LIMBS (rootn);\n\n  if (u != rem)\n    remp = MPZ_REALLOC (rem, un);\n  else\n    remp = TMP_ALLOC_LIMBS (un);\n\n  up = PTR(u);\n\n  if (nth == 1)\n    {\n      MPN_COPY (rootp, up, un);\n      remn = 0;\n    }\n  else\n    {\n      remn = mpn_rootrem (rootp, remp, up, un, (mp_limb_t) nth);\n    }\n\n  if (root != NULL)\n    {\n      SIZ(root) = us >= 0 ? rootn : -rootn;\n      if (u == root)\n\tMPN_COPY (up, rootp, rootn);\n    }\n\n  if (u == rem)\n    MPN_COPY (up, remp, remn);\n  SIZ(rem) = us >= 0 ? remn : -remn;\n  TMP_FREE;\n}",
      "lines": 66,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/rrandomb.c": {
    "mpz_rrandomb": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nmpz_rrandomb (mpz_ptr x, gmp_randstate_t rstate, mp_bitcnt_t nbits)\n{\n  mp_size_t nl;\n  mp_ptr xp;\n\n  nl = BITS_TO_LIMBS (nbits);\n  if (nbits != 0)\n    {\n      xp = MPZ_NEWALLOC (x, nl);\n      gmp_rrandomb (xp, rstate, nbits);\n    }\n\n  SIZ(x) = nl;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gmp_rrandomb": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static void\ngmp_rrandomb (mp_ptr rp, gmp_randstate_t rstate, mp_bitcnt_t nbits)\n{\n  mp_bitcnt_t bi;\n  mp_limb_t ranm;\t\t/* buffer for random bits */\n  unsigned cap_chunksize, chunksize;\n  mp_size_t i;\n\n  /* Set entire result to 111..1  */\n  i = BITS_TO_LIMBS (nbits) - 1;\n  rp[i] = GMP_NUMB_MAX >> (GMP_NUMB_BITS - (nbits % GMP_NUMB_BITS)) % GMP_NUMB_BITS;\n  for (i = i - 1; i >= 0; i--)\n    rp[i] = GMP_NUMB_MAX;\n\n  _gmp_rand (&ranm, rstate, BITS_PER_RANDCALL);\n  cap_chunksize = nbits / (ranm % 4 + 1);\n  cap_chunksize += cap_chunksize == 0; /* make it at least 1 */\n\n  bi = nbits;\n\n  for (;;)\n    {\n      _gmp_rand (&ranm, rstate, BITS_PER_RANDCALL);\n      chunksize = 1 + ranm % cap_chunksize;\n      bi = (bi < chunksize) ? 0 : bi - chunksize;\n\n      if (bi == 0)\n\tbreak;\t\t\t/* low chunk is ...1 */\n\n      rp[bi / GMP_NUMB_BITS] ^= CNST_LIMB (1) << bi % GMP_NUMB_BITS;\n\n      _gmp_rand (&ranm, rstate, BITS_PER_RANDCALL);\n      chunksize = 1 + ranm % cap_chunksize;\n      bi = (bi < chunksize) ? 0 : bi - chunksize;\n\n      mpn_incr_u (rp + bi / GMP_NUMB_BITS, CNST_LIMB (1) << bi % GMP_NUMB_BITS);\n\n      if (bi == 0)\n\tbreak;\t\t\t/* low chunk is ...0 */\n    }\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/scan0.c": {
    "mpz_scan0": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_scan0 (mpz_srcptr u, mp_bitcnt_t starting_bit) __GMP_NOTHROW\n{\n  mp_srcptr      u_ptr = PTR(u);\n  mp_size_t      size = SIZ(u);\n  mp_size_t      abs_size = ABS(size);\n  mp_srcptr      u_end = u_ptr + abs_size;\n  mp_size_t      starting_limb = starting_bit / GMP_NUMB_BITS;\n  mp_srcptr      p = u_ptr + starting_limb;\n  mp_limb_t      limb;\n  int            cnt;\n\n  /* When past end, there's an immediate 0 bit for u>=0, or no 0 bits for\n     u<0.  Notice this test picks up all cases of u==0 too. */\n  if (starting_limb >= abs_size)\n    return (size >= 0 ? starting_bit : ~(mp_bitcnt_t) 0);\n\n  limb = *p;\n\n  if (size >= 0)\n    {\n      /* Mask to 1 all bits before starting_bit, thus ignoring them. */\n      limb |= (CNST_LIMB(1) << (starting_bit % GMP_NUMB_BITS)) - 1;\n\n      /* Search for a limb which isn't all ones.  If the end is reached then\n\t the zero bit immediately past the end is returned.  */\n      while (limb == GMP_NUMB_MAX)\n\t{\n\t  p++;\n\t  if (p == u_end)\n\t    return (mp_bitcnt_t) abs_size * GMP_NUMB_BITS;\n\t  limb = *p;\n\t}\n\n      /* Now seek low 1 bit. */\n      limb = ~limb;\n    }\n  else\n    {\n      mp_srcptr  q;\n\n      /* If there's a non-zero limb before ours then we're in the ones\n\t complement region.  Search from *(p-1) downwards since that might\n\t give better cache locality, and since a non-zero in the middle of a\n\t number is perhaps a touch more likely than at the end.  */\n      q = p;\n      while (q != u_ptr)\n\t{\n\t  q--;\n\t  if (*q != 0)\n\t    goto inverted;\n\t}\n\n      /* Adjust so ~limb implied by searching for 1 bit below becomes -limb.\n\t If limb==0 here then this isn't the beginning of twos complement\n\t inversion, but that doesn't matter because limb==0 is a zero bit\n\t immediately (-1 is all ones for below).  */\n      limb--;\n\n    inverted:\n      /* Now seeking a 1 bit. */\n\n      /* Mask to 0 all bits before starting_bit, thus ignoring them. */\n      limb &= (MP_LIMB_T_MAX << (starting_bit % GMP_NUMB_BITS));\n\n      if (limb == 0)\n\t{\n\t  /* If the high limb is zero after masking, then no 1 bits past\n\t     starting_bit.  */\n\t  p++;\n\t  if (p == u_end)\n\t    return ~(mp_bitcnt_t) 0;\n\n\t  /* Search further for a non-zero limb.  The high limb is non-zero,\n\t     if nothing else.  */\n\t  for (;;)\n\t    {\n\t      limb = *p;\n\t      if (limb != 0)\n\t\tbreak;\n\t      p++;\n\t      ASSERT (p < u_end);\n\t    }\n\t}\n    }\n\n  ASSERT (limb != 0);\n  count_trailing_zeros (cnt, limb);\n  return (mp_bitcnt_t) (p - u_ptr) * GMP_NUMB_BITS + cnt;\n}",
      "lines": 90,
      "depth": 13,
      "decorators": [
        "mp_bitcnt_t",
        "mpz_scan0 (mpz_srcptr u, mp_bitcnt_t starting_bit)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/scan1.c": {
    "mpz_scan1": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_scan1 (mpz_srcptr u, mp_bitcnt_t starting_bit) __GMP_NOTHROW\n{\n  mp_srcptr      u_ptr = PTR(u);\n  mp_size_t      size = SIZ(u);\n  mp_size_t      abs_size = ABS(size);\n  mp_srcptr      u_end = u_ptr + abs_size - 1;\n  mp_size_t      starting_limb = starting_bit / GMP_NUMB_BITS;\n  mp_srcptr      p = u_ptr + starting_limb;\n  mp_limb_t      limb;\n  int            cnt;\n\n  /* Past the end there's no 1 bits for u>=0, or an immediate 1 bit for u<0.\n     Notice this test picks up any u==0 too. */\n  if (starting_limb >= abs_size)\n    return (size >= 0 ? ~(mp_bitcnt_t) 0 : starting_bit);\n\n  /* This is an important case, where sign is not relevant! */\n  if (starting_bit == 0)\n    goto short_cut;\n\n  limb = *p;\n\n  if (size >= 0)\n    {\n      /* Mask to 0 all bits before starting_bit, thus ignoring them. */\n      limb &= (MP_LIMB_T_MAX << (starting_bit % GMP_NUMB_BITS));\n\n      if (limb == 0)\n\t{\n\t  /* If it's the high limb which is zero after masking, then there's\n\t     no 1 bits after starting_bit.  */\n\t  if (p == u_end)\n\t    return ~(mp_bitcnt_t) 0;\n\n\t  /* Otherwise search further for a non-zero limb.  The high limb is\n\t     non-zero, if nothing else.  */\n\tsearch_nonzero:\n\t  do\n\t    {\n\t      ASSERT (p != u_end);\n\t      p++;\n\t    short_cut:\n\t      limb = *p;\n\t    }\n\t  while (limb == 0);\n\t}\n    }\n  else\n    {\n      /* If there's a non-zero limb before ours then we're in the ones\n\t complement region.  */\n      if (starting_limb == 0 || mpn_zero_p (u_ptr, starting_limb)) {\n\tif (limb == 0)\n\t  /* Seeking for the first non-zero bit, it is the same for u and -u. */\n\t  goto search_nonzero;\n\n\t/* Adjust so ~limb implied by searching for 0 bit becomes -limb.  */\n\tlimb--;\n      }\n\n      /* Now seeking a 0 bit. */\n\n      /* Mask to 1 all bits before starting_bit, thus ignoring them. */\n      limb |= (CNST_LIMB(1) << (starting_bit % GMP_NUMB_BITS)) - 1;\n\n      /* Search for a limb which is not all ones.  If the end is reached\n\t then the zero immediately past the end is the result.  */\n      while (limb == GMP_NUMB_MAX)\n\t{\n\t  if (p == u_end)\n\t    return (mp_bitcnt_t) abs_size * GMP_NUMB_BITS;\n\t  p++;\n\t  limb = *p;\n\t}\n\n      /* Now seeking low 1 bit. */\n      limb = ~limb;\n    }\n\n  ASSERT (limb != 0);\n  count_trailing_zeros (cnt, limb);\n  return (mp_bitcnt_t) (p - u_ptr) * GMP_NUMB_BITS + cnt;\n}",
      "lines": 84,
      "depth": 14,
      "decorators": [
        "mp_bitcnt_t",
        "mpz_scan1 (mpz_srcptr u, mp_bitcnt_t starting_bit)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/set.c": {
    "mpz_set": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "void\nmpz_set (mpz_ptr w, mpz_srcptr u)\n{\n  mp_ptr wp, up;\n  mp_size_t usize, size;\n\n  usize = SIZ(u);\n  size = ABS (usize);\n\n  wp = MPZ_REALLOC (w, size);\n\n  up = PTR(u);\n\n  MPN_COPY (wp, up, size);\n  SIZ(w) = usize;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/setbit.c": {
    "mpz_setbit": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void\nmpz_setbit (mpz_ptr d, mp_bitcnt_t bit_idx)\n{\n  mp_size_t dsize = SIZ (d);\n  mp_ptr dp = PTR (d);\n  mp_size_t limb_idx;\n  mp_limb_t mask;\n\n  limb_idx = bit_idx / GMP_NUMB_BITS;\n  mask = CNST_LIMB(1) << (bit_idx % GMP_NUMB_BITS);\n  if (dsize >= 0)\n    {\n      if (limb_idx < dsize)\n\t{\n\t  dp[limb_idx] |= mask;\n\t}\n      else\n\t{\n\t  /* Ugh.  The bit should be set outside of the end of the\n\t     number.  We have to increase the size of the number.  */\n\t  dp = MPZ_REALLOC (d, limb_idx + 1);\n\t  SIZ (d) = limb_idx + 1;\n\t  MPN_ZERO (dp + dsize, limb_idx - dsize);\n\t  dp[limb_idx] = mask;\n\t}\n    }\n  else\n    {\n      /* Simulate two's complement arithmetic, i.e. simulate\n\t 1. Set OP = ~(OP - 1) [with infinitely many leading ones].\n\t 2. Set the bit.\n\t 3. Set OP = ~OP + 1.  */\n\n      dsize = -dsize;\n\n      if (limb_idx < dsize)\n\t{\n\t  mp_size_t zero_bound;\n\t  /* No index upper bound on this loop, we're sure there's a non-zero limb\n\t     sooner or later.  */\n\t  zero_bound = 0;\n\t  while (dp[zero_bound] == 0)\n\t    zero_bound++;\n\n\t  if (limb_idx > zero_bound)\n\t    {\n\t      mp_limb_t\t dlimb;\n\t      dlimb = dp[limb_idx] & ~mask;\n\t      dp[limb_idx] = dlimb;\n\n\t      if (UNLIKELY ((dlimb == 0) + limb_idx == dsize)) /* dsize == limb_idx + 1 */\n\t\t{\n\t\t  /* high limb became zero, must normalize */\n\t\t  MPN_NORMALIZE (dp, limb_idx);\n\t\t  SIZ (d) = -limb_idx;\n\t\t}\n\t    }\n\t  else if (limb_idx == zero_bound)\n\t    {\n\t      dp[limb_idx] = ((dp[limb_idx] - 1) & ~mask) + 1;\n\t      ASSERT (dp[limb_idx] != 0);\n\t    }\n\t  else\n\t    {\n\t      MPN_DECR_U (dp + limb_idx, dsize - limb_idx, mask);\n\t      dsize -= dp[dsize - 1] == 0;\n\t      SIZ (d) = -dsize;\n\t    }\n\t}\n    }\n}",
      "lines": 71,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/set_d.c": {
    "mpz_set_d": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\nmpz_set_d (mpz_ptr r, double d)\n{\n  int negative;\n  mp_limb_t tp[LIMBS_PER_DOUBLE];\n  mp_ptr rp;\n  mp_size_t rn;\n\n  DOUBLE_NAN_INF_ACTION (d,\n\t\t\t __gmp_invalid_operation (),\n\t\t\t __gmp_invalid_operation ());\n\n  negative = d < 0;\n  d = ABS (d);\n\n  rn = __gmp_extract_double (tp, d);\n\n  if (ALLOC(r) < rn)\n    _mpz_realloc (r, rn);\n\n  if (rn <= 0)\n    rn = 0;\n\n  rp = PTR (r);\n\n  switch (rn)\n    {\n    default:\n      MPN_ZERO (rp, rn - LIMBS_PER_DOUBLE);\n      rp += rn - LIMBS_PER_DOUBLE;\n      /* fall through */\n#if LIMBS_PER_DOUBLE == 2\n    case 2:\n      rp[1] = tp[1], rp[0] = tp[0];\n      break;\n    case 1:\n      rp[0] = tp[1];\n      break;\n#endif\n#if LIMBS_PER_DOUBLE == 3\n    case 3:\n      rp[2] = tp[2], rp[1] = tp[1], rp[0] = tp[0];\n      break;\n    case 2:\n      rp[1] = tp[2], rp[0] = tp[1];\n      break;\n    case 1:\n      rp[0] = tp[2];\n      break;\n#endif\n#if LIMBS_PER_DOUBLE == 4\n    case 4:\n      rp[3] = tp[3], rp[2] = tp[2], rp[1] = tp[1], rp[0] = tp[0];\n      break;\n    case 3:\n      rp[2] = tp[3], rp[1] = tp[2], rp[0] = tp[1];\n      break;\n    case 2:\n      rp[1] = tp[3], rp[0] = tp[2];\n      break;\n    case 1:\n      rp[0] = tp[3];\n      break;\n#endif\n    case 0:\n      break;\n    }\n\n  SIZ(r) = negative ? -rn : rn;\n}",
      "lines": 70,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/set_f.c": {
    "mpz_set_f": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\nmpz_set_f (mpz_ptr w, mpf_srcptr u)\n{\n  mp_ptr    wp, up;\n  mp_size_t size;\n  mp_exp_t  exp;\n\n  /* abs(u)<1 truncates to zero */\n  exp = EXP (u);\n  if (exp <= 0)\n    {\n      SIZ(w) = 0;\n      return;\n    }\n\n  wp = MPZ_REALLOC (w, exp);\n  up = PTR(u);\n\n  size = SIZ (u);\n  SIZ(w) = (size >= 0 ? exp : -exp);\n  size = ABS (size);\n\n  if (exp > size)\n    {\n      /* pad with low zeros to get a total \"exp\" many limbs */\n      mp_size_t  zeros = exp - size;\n      MPN_ZERO (wp, zeros);\n      wp += zeros;\n    }\n  else\n    {\n      /* exp<=size, truncate to the high \"exp\" many limbs */\n      up += (size - exp);\n      size = exp;\n    }\n\n  MPN_COPY (wp, up, size);\n}",
      "lines": 38,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/set_q.c": {},
  "gmp/gmp-6.1.2/mpz/set_si.c": {
    "mpz_set_si": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\nmpz_set_si (mpz_ptr dest, signed long int val)\n{\n  mp_size_t size;\n  mp_limb_t vl;\n\n  vl = (mp_limb_t) ABS_CAST (unsigned long int, val);\n\n  PTR (dest)[0] = vl & GMP_NUMB_MASK;\n  size = vl != 0;\n\n#if GMP_NAIL_BITS != 0\n  if (vl > GMP_NUMB_MAX)\n    {\n      MPZ_REALLOC (dest, 2);\n      PTR (dest)[1] = vl >> GMP_NUMB_BITS;\n      size = 2;\n    }\n#endif\n\n  SIZ (dest) = val >= 0 ? size : -size;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/set_str.c": {
    "mpz_set_str": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "int\nmpz_set_str (mpz_ptr x, const char *str, int base)\n{\n  size_t str_size;\n  char *s, *begs;\n  size_t i;\n  mp_size_t xsize;\n  int c;\n  int negative;\n  const unsigned char *digit_value;\n  TMP_DECL;\n\n  digit_value = digit_value_tab;\n  if (base > 36)\n    {\n      /* For bases > 36, use the collating sequence\n\t 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.  */\n      digit_value += 208;\n      if (base > 62)\n\treturn -1;\t\t/* too large base */\n    }\n\n  /* Skip whitespace.  */\n  do\n    c = (unsigned char) *str++;\n  while (isspace (c));\n\n  negative = 0;\n  if (c == '-')\n    {\n      negative = 1;\n      c = (unsigned char) *str++;\n    }\n\n  if (digit_value[c] >= (base == 0 ? 10 : base))\n    return -1;\t\t\t/* error if no valid digits */\n\n  /* If BASE is 0, try to find out the base by looking at the initial\n     characters.  */\n  if (base == 0)\n    {\n      base = 10;\n      if (c == '0')\n\t{\n\t  base = 8;\n\t  c = (unsigned char) *str++;\n\t  if (c == 'x' || c == 'X')\n\t    {\n\t      base = 16;\n\t      c = (unsigned char) *str++;\n\t    }\n\t  else if (c == 'b' || c == 'B')\n\t    {\n\t      base = 2;\n\t      c = (unsigned char) *str++;\n\t    }\n\t}\n    }\n\n  /* Skip leading zeros and white space.  */\n  while (c == '0' || isspace (c))\n    c = (unsigned char) *str++;\n  /* Make sure the string does not become empty, mpn_set_str would fail.  */\n  if (c == 0)\n    {\n      SIZ (x) = 0;\n      return 0;\n    }\n\n  TMP_MARK;\n  str_size = strlen (str - 1);\n  s = begs = (char *) TMP_ALLOC (str_size + 1);\n\n  /* Remove spaces from the string and convert the result from ASCII to a\n     byte array.  */\n  for (i = 0; i < str_size; i++)\n    {\n      if (!isspace (c))\n\t{\n\t  int dig = digit_value[c];\n\t  if (dig >= base)\n\t    {\n\t      TMP_FREE;\n\t      return -1;\n\t    }\n\t  *s++ = dig;\n\t}\n      c = (unsigned char) *str++;\n    }\n\n  str_size = s - begs;\n\n  LIMBS_PER_DIGIT_IN_BASE (xsize, str_size, base);\n  MPZ_REALLOC (x, xsize);\n\n  /* Convert the byte array in base BASE to our bignum format.  */\n  xsize = mpn_set_str (PTR (x), (unsigned char *) begs, str_size, base);\n  SIZ (x) = negative ? -xsize : xsize;\n\n  TMP_FREE;\n  return 0;\n}",
      "lines": 102,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/set_ui.c": {
    "mpz_set_ui": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\nmpz_set_ui (mpz_ptr dest, unsigned long int val)\n{\n  mp_size_t size;\n\n  PTR (dest)[0] = val & GMP_NUMB_MASK;\n  size = val != 0;\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (val > GMP_NUMB_MAX)\n    {\n      MPZ_REALLOC (dest, 2);\n      PTR (dest)[1] = val >> GMP_NUMB_BITS;\n      size = 2;\n    }\n#endif\n\n  SIZ (dest) = size;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/size.c": {},
  "gmp/gmp-6.1.2/mpz/sizeinbase.c": {
    "mpz_sizeinbase": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "size_t\nmpz_sizeinbase (mpz_srcptr x, int base) __GMP_NOTHROW\n{\n  size_t  result;\n  MPN_SIZEINBASE (result, PTR(x), ABSIZ(x), base);\n  return result;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "size_t",
        "mpz_sizeinbase (mpz_srcptr x, int base)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/sqrt.c": {
    "mpz_sqrt": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\nmpz_sqrt (mpz_ptr root, mpz_srcptr op)\n{\n  mp_size_t op_size, root_size;\n  mp_ptr root_ptr, op_ptr;\n\n  op_size = SIZ (op);\n  if (UNLIKELY (op_size <= 0))\n    {\n      if (op_size < 0)\n\tSQRT_OF_NEGATIVE;\n      SIZ(root) = 0;\n      return;\n    }\n\n  /* The size of the root is accurate after this simple calculation.  */\n  root_size = (op_size + 1) / 2;\n  SIZ (root) = root_size;\n\n  op_ptr = PTR (op);\n\n  if (root == op)\n    {\n      /* Allocate temp space for the root, which we then copy to the\n\t shared OP/ROOT variable.  */\n      TMP_DECL;\n      TMP_MARK;\n\n      root_ptr = TMP_ALLOC_LIMBS (root_size);\n      mpn_sqrtrem (root_ptr, NULL, op_ptr, op_size);\n\n      MPN_COPY (op_ptr, root_ptr, root_size);\n\n      TMP_FREE;\n    }\n  else\n    {\n      root_ptr = MPZ_NEWALLOC (root, root_size);\n\n      mpn_sqrtrem (root_ptr, NULL, op_ptr, op_size);\n    }\n}",
      "lines": 42,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/sqrtrem.c": {
    "mpz_sqrtrem": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\nmpz_sqrtrem (mpz_ptr root, mpz_ptr rem, mpz_srcptr op)\n{\n  mp_size_t op_size, root_size, rem_size;\n  mp_ptr root_ptr, op_ptr, rem_ptr;\n\n  op_size = SIZ (op);\n  if (UNLIKELY (op_size <= 0))\n    {\n      if (op_size < 0)\n\tSQRT_OF_NEGATIVE;\n      SIZ(root) = 0;\n      SIZ(rem) = 0;\n      return;\n    }\n\n  rem_ptr = MPZ_REALLOC (rem, op_size);\n\n  /* The size of the root is accurate after this simple calculation.  */\n  root_size = (op_size + 1) / 2;\n  SIZ (root) = root_size;\n\n  op_ptr = PTR (op);\n\n  if (root == op)\n    {\n      /* Allocate temp space for the root, which we then copy to the\n\t shared OP/ROOT variable.  */\n      TMP_DECL;\n      TMP_MARK;\n\n      root_ptr = TMP_ALLOC_LIMBS (root_size);\n      rem_size = mpn_sqrtrem (root_ptr, rem_ptr, op_ptr, op_size);\n\n      if (rem != root)\t/* Don't overwrite remainder */\n\tMPN_COPY (op_ptr, root_ptr, root_size);\n\n      TMP_FREE;\n    }\n  else\n    {\n      root_ptr = MPZ_NEWALLOC (root, root_size);\n\n      rem_size = mpn_sqrtrem (root_ptr, rem_ptr, op_ptr, op_size);\n    }\n\n  /* Write remainder size last, to make this function give only the square root\n     remainder, when passed ROOT == REM.  */\n  SIZ (rem) = rem_size;\n}",
      "lines": 50,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/sub.c": {},
  "gmp/gmp-6.1.2/mpz/sub_ui.c": {},
  "gmp/gmp-6.1.2/mpz/swap.c": {
    "mpz_swap": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\nmpz_swap (mpz_ptr u, mpz_ptr v) __GMP_NOTHROW\n{\n  MP_SIZE_T_SWAP (ALLOC(u), ALLOC(v));\n  MP_SIZE_T_SWAP (SIZ(u), SIZ(v));\n  MP_PTR_SWAP (PTR(v), PTR(u));\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void",
        "mpz_swap (mpz_ptr u, mpz_ptr v)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/tdiv_q.c": {
    "mpz_tdiv_q": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\nmpz_tdiv_q (mpz_ptr quot, mpz_srcptr num, mpz_srcptr den)\n{\n  mp_size_t ql;\n  mp_size_t ns, ds, nl, dl;\n  mp_ptr np, dp, qp;\n  TMP_DECL;\n\n  ns = SIZ (num);\n  ds = SIZ (den);\n  nl = ABS (ns);\n  dl = ABS (ds);\n  ql = nl - dl + 1;\n\n  if (UNLIKELY (dl == 0))\n    DIVIDE_BY_ZERO;\n\n  if (ql <= 0)\n    {\n      SIZ (quot) = 0;\n      return;\n    }\n\n  qp = MPZ_REALLOC (quot, ql);\n\n  TMP_MARK;\n  np = PTR (num);\n  dp = PTR (den);\n\n  /* Copy denominator to temporary space if it overlaps with the quotient.  */\n  if (dp == qp)\n    {\n      mp_ptr tp;\n      tp = TMP_ALLOC_LIMBS (dl);\n      MPN_COPY (tp, dp, dl);\n      dp = tp;\n    }\n  /* Copy numerator to temporary space if it overlaps with the quotient.  */\n  if (np == qp)\n    {\n      mp_ptr tp;\n      tp = TMP_ALLOC_LIMBS (nl + 1);\n      MPN_COPY (tp, np, nl);\n      /* Overlap dividend and scratch.  */\n      mpn_div_q (qp, tp, nl, dp, dl, tp);\n    }\n  else\n    {\n      mp_ptr tp;\n      tp = TMP_ALLOC_LIMBS (nl + 1);\n      mpn_div_q (qp, np, nl, dp, dl, tp);\n    }\n\n  ql -=  qp[ql - 1] == 0;\n\n  SIZ (quot) = (ns ^ ds) >= 0 ? ql : -ql;\n  TMP_FREE;\n}",
      "lines": 58,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/tdiv_qr.c": {
    "mpz_tdiv_qr": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nmpz_tdiv_qr (mpz_ptr quot, mpz_ptr rem, mpz_srcptr num, mpz_srcptr den)\n{\n  mp_size_t ql;\n  mp_size_t ns, ds, nl, dl;\n  mp_ptr np, dp, qp, rp;\n  TMP_DECL;\n\n  ns = SIZ (num);\n  ds = SIZ (den);\n  nl = ABS (ns);\n  dl = ABS (ds);\n  ql = nl - dl + 1;\n\n  if (UNLIKELY (dl == 0))\n    DIVIDE_BY_ZERO;\n\n  rp = MPZ_REALLOC (rem, dl);\n\n  if (ql <= 0)\n    {\n      if (num != rem)\n\t{\n\t  np = PTR (num);\n\t  MPN_COPY (rp, np, nl);\n\t  SIZ (rem) = SIZ (num);\n\t}\n      /* This needs to follow the assignment to rem, in case the\n\t numerator and quotient are the same.  */\n      SIZ (quot) = 0;\n      return;\n    }\n\n  qp = MPZ_REALLOC (quot, ql);\n\n  TMP_MARK;\n  np = PTR (num);\n  dp = PTR (den);\n\n  /* FIXME: We should think about how to handle the temporary allocation.\n     Perhaps mpn_tdiv_qr should handle it, since it anyway often needs to\n     allocate temp space.  */\n\n  /* Copy denominator to temporary space if it overlaps with the quotient\n     or remainder.  */\n  if (dp == rp || dp == qp)\n    {\n      mp_ptr tp;\n      tp = TMP_ALLOC_LIMBS (dl);\n      MPN_COPY (tp, dp, dl);\n      dp = tp;\n    }\n  /* Copy numerator to temporary space if it overlaps with the quotient or\n     remainder.  */\n  if (np == rp || np == qp)\n    {\n      mp_ptr tp;\n      tp = TMP_ALLOC_LIMBS (nl);\n      MPN_COPY (tp, np, nl);\n      np = tp;\n    }\n\n  mpn_tdiv_qr (qp, rp, 0L, np, nl, dp, dl);\n\n  ql -=  qp[ql - 1] == 0;\n  MPN_NORMALIZE (rp, dl);\n\n  SIZ (quot) = (ns ^ ds) >= 0 ? ql : -ql;\n  SIZ (rem) = ns >= 0 ? dl : -dl;\n  TMP_FREE;\n}",
      "lines": 71,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/tdiv_qr_ui.c": {
    "mpz_tdiv_qr_ui": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "unsigned long int\nmpz_tdiv_qr_ui (mpz_ptr quot, mpz_ptr rem, mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn, qn;\n  mp_ptr np, qp;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      SIZ(quot) = 0;\n      SIZ(rem) = 0;\n      return 0;\n    }\n\n  nn = ABS(ns);\n  qp = MPZ_REALLOC (quot, nn);\n  np = PTR(dividend);\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2];\n      mp_ptr rp;\n      mp_size_t rn;\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  SIZ(quot) = 0;\n\t  rl = np[0];\n\t  SIZ(rem) = ns >= 0 ? 1 : -1;\n\t  PTR(rem)[0] = rl;\n\t  return rl;\n\t}\n\n      rp = MPZ_REALLOC (rem, 2);\n\n      dp[0] = divisor & GMP_NUMB_MASK;\n      dp[1] = divisor >> GMP_NUMB_BITS;\n      mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n      rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n      qn = nn - 2 + 1; qn -= qp[qn - 1] == 0; qn -= qn != 0 && qp[qn - 1] == 0;\n      rn = 2 - (rp[1] == 0);  rn -= (rp[rn - 1] == 0);\n      SIZ(rem) = ns >= 0 ? rn : -rn;\n    }\n  else\n#endif\n    {\n      rl = mpn_divrem_1 (qp, (mp_size_t) 0, np, nn, (mp_limb_t) divisor);\n      if (rl == 0)\n\tSIZ(rem) = 0;\n      else\n\t{\n\t  /* Store the single-limb remainder.  We don't check if there's space\n\t     for just one limb, since no function ever makes zero space.  */\n\t  SIZ(rem) = ns >= 0 ? 1 : -1;\n\t  PTR(rem)[0] = rl;\n\t}\n      qn = nn - (qp[nn - 1] == 0);\n    }\n\n  SIZ(quot) = ns >= 0 ? qn : -qn;\n  return rl;\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/tdiv_q_2exp.c": {
    "mpz_tdiv_q_2exp": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nmpz_tdiv_q_2exp (mpz_ptr r, mpz_srcptr u, mp_bitcnt_t cnt)\n{\n  mp_size_t un, rn;\n  mp_size_t limb_cnt;\n  mp_ptr rp;\n  mp_srcptr up;\n\n  un = SIZ(u);\n  limb_cnt = cnt / GMP_NUMB_BITS;\n  rn = ABS (un) - limb_cnt;\n\n  if (rn <= 0)\n    rn = 0;\n  else\n    {\n      rp = MPZ_REALLOC (r, rn);\n      up = PTR(u) + limb_cnt;\n\n      cnt %= GMP_NUMB_BITS;\n      if (cnt != 0)\n\t{\n\t  mpn_rshift (rp, up, rn, cnt);\n\t  rn -= rp[rn - 1] == 0;\n\t}\n      else\n\t{\n\t  MPN_COPY_INCR (rp, up, rn);\n\t}\n    }\n\n  SIZ(r) = un >= 0 ? rn : -rn;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/tdiv_q_ui.c": {
    "mpz_tdiv_q_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "unsigned long int\nmpz_tdiv_q_ui (mpz_ptr quot, mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn, qn;\n  mp_ptr np, qp;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      SIZ(quot) = 0;\n      return 0;\n    }\n\n  nn = ABS(ns);\n  qp = MPZ_REALLOC (quot, nn);\n  np = PTR(dividend);\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2], rp[2];\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  SIZ(quot) = 0;\n\t  rl = np[0];\n\t  return rl;\n\t}\n\n      dp[0] = divisor & GMP_NUMB_MASK;\n      dp[1] = divisor >> GMP_NUMB_BITS;\n      mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n      rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n      qn = nn - 2 + 1; qn -= qp[qn - 1] == 0; qn -= qn != 0 && qp[qn - 1] == 0;\n    }\n  else\n#endif\n    {\n      rl = mpn_divrem_1 (qp, (mp_size_t) 0, np, nn, (mp_limb_t) divisor);\n      qn = nn - (qp[nn - 1] == 0);\n    }\n\n  SIZ(quot) = ns >= 0 ? qn : -qn;\n  return rl;\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/tdiv_r.c": {
    "mpz_tdiv_r": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\nmpz_tdiv_r (mpz_ptr rem, mpz_srcptr num, mpz_srcptr den)\n{\n  mp_size_t ql;\n  mp_size_t ns, ds, nl, dl;\n  mp_ptr np, dp, qp, rp;\n  TMP_DECL;\n\n  ns = SIZ (num);\n  ds = SIZ (den);\n  nl = ABS (ns);\n  dl = ABS (ds);\n  ql = nl - dl + 1;\n\n  if (UNLIKELY (dl == 0))\n    DIVIDE_BY_ZERO;\n\n  rp = MPZ_REALLOC (rem, dl);\n\n  if (ql <= 0)\n    {\n      if (num != rem)\n\t{\n\t  np = PTR (num);\n\t  MPN_COPY (rp, np, nl);\n\t  SIZ (rem) = SIZ (num);\n\t}\n      return;\n    }\n\n  TMP_MARK;\n  qp = TMP_ALLOC_LIMBS (ql);\n  np = PTR (num);\n  dp = PTR (den);\n\n  /* FIXME: We should think about how to handle the temporary allocation.\n     Perhaps mpn_tdiv_qr should handle it, since it anyway often needs to\n     allocate temp space.  */\n\n  /* Copy denominator to temporary space if it overlaps with the remainder.  */\n  if (dp == rp)\n    {\n      mp_ptr tp;\n      tp = TMP_ALLOC_LIMBS (dl);\n      MPN_COPY (tp, dp, dl);\n      dp = tp;\n    }\n  /* Copy numerator to temporary space if it overlaps with the remainder.  */\n  if (np == rp)\n    {\n      mp_ptr tp;\n      tp = TMP_ALLOC_LIMBS (nl);\n      MPN_COPY (tp, np, nl);\n      np = tp;\n    }\n\n  mpn_tdiv_qr (qp, rp, 0L, np, nl, dp, dl);\n\n  MPN_NORMALIZE (rp, dl);\n\n  SIZ (rem) = ns >= 0 ? dl : -dl;\n  TMP_FREE;\n}",
      "lines": 63,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/tdiv_r_2exp.c": {
    "mpz_tdiv_r_2exp": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\nmpz_tdiv_r_2exp (mpz_ptr res, mpz_srcptr in, mp_bitcnt_t cnt)\n{\n  mp_size_t in_size = ABSIZ (in);\n  mp_size_t res_size;\n  mp_size_t limb_cnt = cnt / GMP_NUMB_BITS;\n  mp_srcptr in_ptr = PTR (in);\n\n  if (in_size > limb_cnt)\n    {\n      /* The input operand is (probably) greater than 2**CNT.  */\n      mp_limb_t x;\n\n      x = in_ptr[limb_cnt] & (((mp_limb_t) 1 << cnt % GMP_NUMB_BITS) - 1);\n      if (x != 0)\n\t{\n\t  res_size = limb_cnt + 1;\n\t  MPZ_REALLOC (res, res_size);\n\n\t  PTR (res)[limb_cnt] = x;\n\t}\n      else\n\t{\n\t  res_size = limb_cnt;\n\t  MPN_NORMALIZE (in_ptr, res_size);\n\n\t  MPZ_REALLOC (res, res_size);\n\n\t  limb_cnt = res_size;\n\t}\n    }\n  else\n    {\n      /* The input operand is smaller than 2**CNT.  We perform a no-op,\n\t apart from that we might need to copy IN to RES.  */\n      res_size = in_size;\n      MPZ_REALLOC (res, res_size);\n\n      limb_cnt = res_size;\n    }\n\n  if (res != in)\n    MPN_COPY (PTR (res), PTR (in), limb_cnt);\n  SIZ (res) = SIZ (in) >= 0 ? res_size : -res_size;\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/tdiv_r_ui.c": {
    "mpz_tdiv_r_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "unsigned long int\nmpz_tdiv_r_ui (mpz_ptr rem, mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn;\n  mp_ptr np;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      SIZ(rem) = 0;\n      return 0;\n    }\n\n  nn = ABS(ns);\n  np = PTR(dividend);\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2];\n      mp_ptr rp, qp;\n      mp_size_t rn;\n      TMP_DECL;\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  rl = np[0];\n\t  SIZ(rem) = ns >= 0 ? 1 : -1;\n\t  PTR(rem)[0] = rl;\n\t  return rl;\n\t}\n\n      rp = MPZ_REALLOC (rem, 2);\n\n      TMP_MARK;\n      dp[0] = divisor & GMP_NUMB_MASK;\n      dp[1] = divisor >> GMP_NUMB_BITS;\n      qp = TMP_ALLOC_LIMBS (nn - 2 + 1);\n      mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n      TMP_FREE;\n      rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n      rn = 2 - (rp[1] == 0);  rn -= (rp[rn - 1] == 0);\n      SIZ(rem) = ns >= 0 ? rn : -rn;\n    }\n  else\n#endif\n    {\n      rl = mpn_mod_1 (np, nn, (mp_limb_t) divisor);\n      if (rl == 0)\n\tSIZ(rem) = 0;\n      else\n\t{\n\t  /* Store the single-limb remainder.  We don't check if there's space\n\t     for just one limb, since no function ever makes zero space.  */\n\t  SIZ(rem) = ns >= 0 ? 1 : -1;\n\t  PTR(rem)[0] = rl;\n\t}\n    }\n\n  return rl;\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/tdiv_ui.c": {
    "mpz_tdiv_ui": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "unsigned long int\nmpz_tdiv_ui (mpz_srcptr dividend, unsigned long int divisor)\n{\n  mp_size_t ns, nn;\n  mp_ptr np;\n  mp_limb_t rl;\n\n  if (UNLIKELY (divisor == 0))\n    DIVIDE_BY_ZERO;\n\n  ns = SIZ(dividend);\n  if (ns == 0)\n    {\n      return 0;\n    }\n\n  nn = ABS(ns);\n  np = PTR(dividend);\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (divisor > GMP_NUMB_MAX)\n    {\n      mp_limb_t dp[2], rp[2];\n      mp_ptr qp;\n      mp_size_t rn;\n      TMP_DECL;\n\n      if (nn == 1)\t\t/* tdiv_qr requirements; tested above for 0 */\n\t{\n\t  rl = np[0];\n\t  return rl;\n\t}\n\n      TMP_MARK;\n      dp[0] = divisor & GMP_NUMB_MASK;\n      dp[1] = divisor >> GMP_NUMB_BITS;\n      qp = TMP_ALLOC_LIMBS (nn - 2 + 1);\n      mpn_tdiv_qr (qp, rp, (mp_size_t) 0, np, nn, dp, (mp_size_t) 2);\n      TMP_FREE;\n      rl = rp[0] + (rp[1] << GMP_NUMB_BITS);\n      rn = 2 - (rp[1] == 0);  rn -= (rp[rn - 1] == 0);\n    }\n  else\n#endif\n    {\n      rl = mpn_mod_1 (np, nn, (mp_limb_t) divisor);\n    }\n\n  return rl;\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/tstbit.c": {
    "mpz_tstbit": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\nmpz_tstbit (mpz_srcptr u, mp_bitcnt_t bit_index) __GMP_NOTHROW\n{\n  mp_srcptr      u_ptr      = PTR(u);\n  mp_size_t      size       = SIZ(u);\n  unsigned       abs_size   = ABS(size);\n  mp_size_t      limb_index = bit_index / GMP_NUMB_BITS;\n  mp_srcptr      p          = u_ptr + limb_index;\n  mp_limb_t      limb;\n\n  if (limb_index >= abs_size)\n    return (size < 0);\n\n  limb = *p;\n  if (size < 0)\n    {\n      limb = -limb;     /* twos complement */\n\n      while (p != u_ptr)\n\t{\n\t  p--;\n\t  if (*p != 0)\n\t    {\n\t      limb--;\t/* make it a ones complement instead */\n\t      break;\n\t    }\n\t}\n    }\n\n  return (limb >> (bit_index % GMP_NUMB_BITS)) & 1;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int",
        "mpz_tstbit (mpz_srcptr u, mp_bitcnt_t bit_index)"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/ui_pow_ui.c": {
    "mpz_ui_pow_ui": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nmpz_ui_pow_ui (mpz_ptr r, unsigned long b, unsigned long e)\n{\n#if GMP_NAIL_BITS != 0\n  if (b > GMP_NUMB_MAX)\n    {\n      mp_limb_t bb[2];\n      bb[0] = b & GMP_NUMB_MASK;\n      bb[1] = b >> GMP_NUMB_BITS;\n      mpz_n_pow_ui (r, bb, (mp_size_t) 2, e);\n    }\n  else\n#endif\n    {\n#ifdef _LONG_LONG_LIMB\n      /* i386 gcc 2.95.3 doesn't recognise blimb can be eliminated when\n\t mp_limb_t is an unsigned long, so only use a separate blimb when\n\t necessary.  */\n      mp_limb_t  blimb = b;\n      mpz_n_pow_ui (r, &blimb, (mp_size_t) (b != 0), e);\n#else\n      mpz_n_pow_ui (r, &b,     (mp_size_t) (b != 0), e);\n#endif\n    }\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/ui_sub.c": {
    "mpz_ui_sub": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void\nmpz_ui_sub (mpz_ptr w, unsigned long int uval, mpz_srcptr v)\n{\n  mp_ptr vp, wp;\n  mp_size_t vn, wn;\n  mp_limb_t cy;\n\n#if BITS_PER_ULONG > GMP_NUMB_BITS  /* avoid warnings about shift amount */\n  if (uval > GMP_NUMB_MAX)\n    {\n      mpz_t u;\n      mp_limb_t ul[2];\n      PTR(u) = ul;\n      ul[0] = uval & GMP_NUMB_MASK;\n      ul[1] = uval >> GMP_NUMB_BITS;\n      SIZ(u) = 2;\n      mpz_sub (w, u, v);\n      return;\n    }\n#endif\n\n  vp = PTR(v);\n  vn = SIZ(v);\n\n  wp = PTR(w);\n\n  if (vn > 1)\n    {\n      wp = MPZ_REALLOC (w, vn);\n      vp = PTR(v);\n      mpn_sub_1 (wp, vp, vn, (mp_limb_t) uval);\n      wn = -(vn - (wp[vn - 1] == 0));\n    }\n  else if (vn == 1)\n    {\n      if (uval >= vp[0])\n\t{\n\t  wp[0] = uval - vp[0];\n\t  wn = wp[0] != 0;\n\t}\n      else\n\t{\n\t  wp[0] = vp[0] - uval;\n\t  wn = -1;\n\t}\n    }\n  else if (vn == 0)\n    {\n      wp[0] = uval;\n      wn = uval != 0;\n    }\n  else /* (vn < 0) */\n    {\n      vn = -vn;\n      wp = MPZ_REALLOC (w, vn + 1);\n      vp = PTR(v);\n      cy = mpn_add_1 (wp, vp, vn, (mp_limb_t) uval);\n      wp[vn] = cy;\n      wn = vn + (cy != 0);\n    }\n\n  SIZ(w) = wn;\n}",
      "lines": 63,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/urandomb.c": {
    "mpz_urandomb": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\nmpz_urandomb (mpz_ptr rop, gmp_randstate_t rstate, mp_bitcnt_t nbits)\n{\n  mp_ptr rp;\n  mp_size_t size;\n\n  size = BITS_TO_LIMBS (nbits);\n  rp = MPZ_NEWALLOC (rop, size);\n\n  _gmp_rand (rp, rstate, nbits);\n  MPN_NORMALIZE (rp, size);\n  SIZ (rop) = size;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/urandomm.c": {
    "mpz_urandomm": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void\nmpz_urandomm (mpz_ptr rop, gmp_randstate_t rstate, mpz_srcptr n)\n{\n  mp_ptr rp, np, nlast;\n  mp_size_t nbits, size;\n  int count;\n  int pow2;\n  int cmp;\n  TMP_DECL;\n\n  size = ABSIZ (n);\n  if (UNLIKELY (size == 0))\n    DIVIDE_BY_ZERO;\n\n  nlast = &PTR (n)[size - 1];\n\n  /* Detect whether n is a power of 2.  */\n  pow2 = POW2_P (*nlast);\n  if (pow2 != 0)\n    for (np = PTR (n); np < nlast; np++)\n      if (*np != 0)\n\t{\n\t  pow2 = 0;\t\t/* Mark n as `not a power of two'.  */\n\t  break;\n\t}\n\n  count_leading_zeros (count, *nlast);\n  nbits = size * GMP_NUMB_BITS - (count - GMP_NAIL_BITS) - pow2;\n  if (nbits == 0)\t\t/* nbits == 0 means that n was == 1.  */\n    {\n      SIZ (rop) = 0;\n      return;\n    }\n\n  TMP_MARK;\n  np = PTR (n);\n  if (rop == n)\n    {\n      mp_ptr tp;\n      tp = TMP_ALLOC_LIMBS (size);\n      MPN_COPY (tp, np, size);\n      np = tp;\n    }\n\n  /* Here the allocated size can be one too much if n is a power of\n     (2^GMP_NUMB_BITS) but it's convenient for using mpn_cmp below.  */\n  rp = MPZ_REALLOC (rop, size);\n  /* Clear last limb to prevent the case in which size is one too much.  */\n  rp[size - 1] = 0;\n\n  count = MAX_URANDOMM_ITER;\t/* Set iteration count limit.  */\n  do\n    {\n      _gmp_rand (rp, rstate, nbits);\n      MPN_CMP (cmp, rp, np, size);\n    }\n  while (cmp >= 0 && --count != 0);\n\n  if (count == 0)\n    /* Too many iterations; return result mod n == result - n */\n    mpn_sub_n (rp, rp, np, size);\n\n  MPN_NORMALIZE (rp, size);\n  SIZ (rop) = size;\n  TMP_FREE;\n}",
      "lines": 66,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/mpz/xor.c": {
    "mpz_xor": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void\nmpz_xor (mpz_ptr res, mpz_srcptr op1, mpz_srcptr op2)\n{\n  mp_srcptr op1_ptr, op2_ptr;\n  mp_size_t op1_size, op2_size;\n  mp_ptr res_ptr;\n  mp_size_t res_size, res_alloc;\n  TMP_DECL;\n\n  TMP_MARK;\n  op1_size = SIZ(op1);\n  op2_size = SIZ(op2);\n\n  op1_ptr = PTR(op1);\n  op2_ptr = PTR(op2);\n  res_ptr = PTR(res);\n\n  if (op1_size >= 0)\n    {\n      if (op2_size >= 0)\n\t{\n\t  if (op1_size >= op2_size)\n\t    {\n\t      if (ALLOC(res) < op1_size)\n\t\t{\n\t\t  _mpz_realloc (res, op1_size);\n\t\t  /* No overlapping possible: op1_ptr = PTR(op1); */\n\t\t  op2_ptr = PTR(op2);\n\t\t  res_ptr = PTR(res);\n\t\t}\n\n\t      if (res_ptr != op1_ptr)\n\t\tMPN_COPY (res_ptr + op2_size, op1_ptr + op2_size,\n\t\t\t  op1_size - op2_size);\n\t      if (LIKELY (op2_size != 0))\n\t\tmpn_xor_n (res_ptr, op1_ptr, op2_ptr, op2_size);\n\t      res_size = op1_size;\n\t    }\n\t  else\n\t    {\n\t      if (ALLOC(res) < op2_size)\n\t\t{\n\t\t  _mpz_realloc (res, op2_size);\n\t\t  op1_ptr = PTR(op1);\n\t\t  /* No overlapping possible: op2_ptr = PTR(op2); */\n\t\t  res_ptr = PTR(res);\n\t\t}\n\n\t      if (res_ptr != op2_ptr)\n\t\tMPN_COPY (res_ptr + op1_size, op2_ptr + op1_size,\n\t\t\t  op2_size - op1_size);\n\t      if (LIKELY (op1_size != 0))\n\t\tmpn_xor_n (res_ptr, op1_ptr, op2_ptr, op1_size);\n\t      res_size = op2_size;\n\t    }\n\n\t  MPN_NORMALIZE (res_ptr, res_size);\n\t  SIZ(res) = res_size;\n\t  return;\n\t}\n      else /* op2_size < 0 */\n\t{\n\t  /* Fall through to the code at the end of the function.  */\n\t}\n    }\n  else\n    {\n      if (op2_size < 0)\n\t{\n\t  mp_ptr opx, opy;\n\n\t  /* Both operands are negative, the result will be positive.\n\t      (-OP1) ^ (-OP2) =\n\t     = ~(OP1 - 1) ^ ~(OP2 - 1) =\n\t     = (OP1 - 1) ^ (OP2 - 1)  */\n\n\t  op1_size = -op1_size;\n\t  op2_size = -op2_size;\n\n\t  /* Possible optimization: Decrease mpn_sub precision,\n\t     as we won't use the entire res of both.  */\n\t  TMP_ALLOC_LIMBS_2 (opx, op1_size, opy, op2_size);\n\t  mpn_sub_1 (opx, op1_ptr, op1_size, (mp_limb_t) 1);\n\t  op1_ptr = opx;\n\n\t  mpn_sub_1 (opy, op2_ptr, op2_size, (mp_limb_t) 1);\n\t  op2_ptr = opy;\n\n\t  if (op1_size > op2_size)\n\t    MPN_SRCPTR_SWAP (op1_ptr,op1_size, op2_ptr,op2_size);\n\n\t  res_alloc = op2_size;\n\t  res_ptr = MPZ_REALLOC (res, res_alloc);\n\n\t  MPN_COPY (res_ptr + op1_size, op2_ptr + op1_size,\n\t\t    op2_size - op1_size);\n\t  mpn_xor_n (res_ptr, op1_ptr, op2_ptr, op1_size);\n\t  res_size = op2_size;\n\n\t  MPN_NORMALIZE (res_ptr, res_size);\n\t  SIZ(res) = res_size;\n\t  TMP_FREE;\n\t  return;\n\t}\n      else\n\t{\n\t  /* We should compute -OP1 ^ OP2.  Swap OP1 and OP2 and fall\n\t     through to the code that handles OP1 ^ -OP2.  */\n\t  MPZ_SRCPTR_SWAP (op1, op2);\n\t  MPN_SRCPTR_SWAP (op1_ptr,op1_size, op2_ptr,op2_size);\n\t}\n    }\n\n  {\n    mp_ptr opx;\n    mp_limb_t cy;\n\n    /* Operand 2 negative, so will be the result.\n       -(OP1 ^ (-OP2)) = -(OP1 ^ ~(OP2 - 1)) =\n       = ~(OP1 ^ ~(OP2 - 1)) + 1 =\n       = (OP1 ^ (OP2 - 1)) + 1      */\n\n    op2_size = -op2_size;\n\n    opx = TMP_ALLOC_LIMBS (op2_size);\n    mpn_sub_1 (opx, op2_ptr, op2_size, (mp_limb_t) 1);\n    op2_ptr = opx;\n\n    res_alloc = MAX (op1_size, op2_size) + 1;\n    if (ALLOC(res) < res_alloc)\n      {\n\t_mpz_realloc (res, res_alloc);\n\top1_ptr = PTR(op1);\n\t/* op2_ptr points to temporary space.  */\n\tres_ptr = PTR(res);\n      }\n\n    if (op1_size > op2_size)\n      {\n\tMPN_COPY (res_ptr + op2_size, op1_ptr + op2_size, op1_size - op2_size);\n\tmpn_xor_n (res_ptr, op1_ptr, op2_ptr, op2_size);\n\tres_size = op1_size;\n      }\n    else\n      {\n\tMPN_COPY (res_ptr + op1_size, op2_ptr + op1_size, op2_size - op1_size);\n\tif (LIKELY (op1_size != 0))\n\t  mpn_xor_n (res_ptr, op1_ptr, op2_ptr, op1_size);\n\tres_size = op2_size;\n      }\n\n    cy = mpn_add_1 (res_ptr, res_ptr, res_size, (mp_limb_t) 1);\n    res_ptr[res_size] = cy;\n    res_size += (cy != 0);\n\n    MPN_NORMALIZE (res_ptr, res_size);\n    SIZ(res) = -res_size;\n    TMP_FREE;\n  }\n}",
      "lines": 160,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/asprintf.c": {
    "gmp_asprintf": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\ngmp_asprintf (char **result, const char *fmt, ...)\n{\n  va_list  ap;\n  int      ret;\n\n  va_start (ap, fmt);\n\n  ret = gmp_vasprintf (result, fmt, ap);\n  va_end (ap);\n  return ret;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/asprntffuns.c": {
    "__gmp_asprintf_memory": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\n__gmp_asprintf_memory (struct gmp_asprintf_t *d, const char *str, size_t len)\n{\n  GMP_ASPRINTF_T_NEED (d, len);\n  memcpy (d->buf + d->size, str, len);\n  d->size += len;\n  return len;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "__gmp_asprintf_reps": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\n__gmp_asprintf_reps (struct gmp_asprintf_t *d, int c, int reps)\n{\n  GMP_ASPRINTF_T_NEED (d, reps);\n  memset (d->buf + d->size, c, reps);\n  d->size += reps;\n  return reps;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "__gmp_asprintf_final": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\n__gmp_asprintf_final (struct gmp_asprintf_t *d)\n{\n  char  *buf = d->buf;\n  ASSERT (d->alloc >= d->size + 1);\n  buf[d->size] = '\\0';\n  __GMP_REALLOCATE_FUNC_MAYBE_TYPE (buf, d->alloc, d->size+1, char);\n  *d->result = buf;\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/doprnt.c": {
    "__gmp_doprnt": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "int\n__gmp_doprnt (const struct doprnt_funs_t *funs, void *data,\n\t      const char *orig_fmt, va_list orig_ap)\n{\n  va_list  ap, this_ap, last_ap;\n  size_t   alloc_fmt_size, orig_fmt_size;\n  char     *fmt, *alloc_fmt, *last_fmt, *this_fmt, *gmp_str;\n  int      retval = 0;\n  int      type, fchar, *value, seen_precision;\n  struct doprnt_params_t param;\n\n  TRACE (printf (\"gmp_doprnt \\\"%s\\\"\\n\", orig_fmt));\n\n  /* Don't modify orig_ap, if va_list is actually an array and hence call by\n     reference.  It could be argued that it'd be more efficient to leave the\n     caller to make a copy if it cared, but doing so here is going to be a\n     very small part of the total work, and we may as well keep applications\n     out of trouble.  */\n  va_copy (ap, orig_ap);\n\n  /* The format string is chopped up into pieces to be passed to\n     funs->format.  Unfortunately that means it has to be copied so each\n     piece can be null-terminated.  We're not going to be very fast here, so\n     use __gmp_allocate_func rather than TMP_ALLOC, to avoid overflowing the\n     stack if a long output string is given.  */\n  alloc_fmt_size = orig_fmt_size = strlen (orig_fmt) + 1;\n#if _LONG_LONG_LIMB\n  /* for a long long limb we change %Mx to %llx, so could need an extra 1\n     char for every 3 existing */\n  alloc_fmt_size += alloc_fmt_size / 3;\n#endif\n  alloc_fmt = __GMP_ALLOCATE_FUNC_TYPE (alloc_fmt_size, char);\n  fmt = alloc_fmt;\n  memcpy (fmt, orig_fmt, orig_fmt_size);\n\n  /* last_fmt and last_ap are just after the last output, and hence where\n     the next output will begin, when that's done */\n  last_fmt = fmt;\n  va_copy (last_ap, ap);\n\n  for (;;)\n    {\n      TRACE (printf (\"next: \\\"%s\\\"\\n\", fmt));\n\n      fmt = strchr (fmt, '%');\n      if (fmt == NULL)\n\tbreak;\n\n      /* this_fmt and this_ap are the current '%' sequence being considered */\n      this_fmt = fmt;\n      va_copy (this_ap, ap);\n      fmt++; /* skip the '%' */\n\n      TRACE (printf (\"considering\\n\");\n\t     printf (\"  last: \\\"%s\\\"\\n\", last_fmt);\n\t     printf (\"  this: \\\"%s\\\"\\n\", this_fmt));\n\n      type = '\\0';\n      value = &param.width;\n\n      param.base = 10;\n      param.conv = 0;\n      param.expfmt = \"e%c%02ld\";\n      param.exptimes4 = 0;\n      param.fill = ' ';\n      param.justify = DOPRNT_JUSTIFY_RIGHT;\n      param.prec = 6;\n      param.showbase = DOPRNT_SHOWBASE_NO;\n      param.showpoint = 0;\n      param.showtrailing = 1;\n      param.sign = '\\0';\n      param.width = 0;\n      seen_precision = 0;\n\n      /* This loop parses a single % sequence.  \"break\" from the switch\n\t means continue with this %, \"goto next\" means the conversion\n\t character has been seen and a new % should be sought.  */\n      for (;;)\n\t{\n\t  fchar = *fmt++;\n\t  if (fchar == '\\0')\n\t    break;\n\n\t  switch (fchar) {\n\n\t  case 'a':\n\t    /* %a behaves like %e, but defaults to all significant digits,\n\t       and there's no leading zeros on the exponent (which is in\n\t       fact bit-based) */\n\t    param.base = 16;\n\t    param.expfmt = \"p%c%ld\";\n\t    goto conv_a;\n\t  case 'A':\n\t    param.base = -16;\n\t    param.expfmt = \"P%c%ld\";\n\t  conv_a:\n\t    param.conv = DOPRNT_CONV_SCIENTIFIC;\n\t    param.exptimes4 = 1;\n\t    if (! seen_precision)\n\t      param.prec = -1;  /* default to all digits */\n\t    param.showbase = DOPRNT_SHOWBASE_YES;\n\t    param.showtrailing = 1;\n\t    goto floating_a;\n\n\t  case 'c':\n\t    /* Let's assume wchar_t will be promoted to \"int\" in the call,\n\t       the same as char will be. */\n\t    (void) va_arg (ap, int);\n\t    goto next;\n\n\t  case 'd':\n\t  case 'i':\n\t  case 'u':\n\t  integer:\n\t    TRACE (printf (\"integer, base=%d\\n\", param.base));\n\t    if (! seen_precision)\n\t      param.prec = -1;\n\t    switch (type) {\n\t    case 'j':\n\t      /* Let's assume uintmax_t is the same size as intmax_t. */\n#if HAVE_INTMAX_T\n\t      (void) va_arg (ap, intmax_t);\n#else\n\t      ASSERT_FAIL (intmax_t not available);\n#endif\n\t      break;\n\t    case 'l':\n\t      (void) va_arg (ap, long);\n\t      break;\n\t    case 'L':\n#if HAVE_LONG_LONG\n\t      (void) va_arg (ap, long long);\n#else\n\t      ASSERT_FAIL (long long not available);\n#endif\n\t      break;\n\t    case 'N':\n\t      {\n\t\tmp_ptr     xp;\n\t\tmp_size_t  xsize, abs_xsize;\n\t\tmpz_t      z;\n\t\tFLUSH ();\n\t\txp = va_arg (ap, mp_ptr);\n\t\tPTR(z) = xp;\n\t\txsize = (int) va_arg (ap, mp_size_t);\n\t\tabs_xsize = ABS (xsize);\n\t\tMPN_NORMALIZE (xp, abs_xsize);\n\t\tSIZ(z) = (xsize >= 0 ? abs_xsize : -abs_xsize);\n\t\tASSERT_CODE (ALLOC(z) = abs_xsize);\n\t\tgmp_str = mpz_get_str (NULL, param.base, z);\n\t\tgoto gmp_integer;\n\t      }\n\t      /* break; */\n\t    case 'q':\n\t      /* quad_t is probably the same as long long, but let's treat\n\t\t it separately just to be sure.  Also let's assume u_quad_t\n\t\t will be the same size as quad_t.  */\n#if HAVE_QUAD_T\n\t      (void) va_arg (ap, quad_t);\n#else\n\t      ASSERT_FAIL (quad_t not available);\n#endif\n\t      break;\n\t    case 'Q':\n\t      FLUSH ();\n\t      gmp_str = mpq_get_str (NULL, param.base, va_arg(ap, mpq_srcptr));\n\t      goto gmp_integer;\n\t    case 't':\n#if HAVE_PTRDIFF_T\n\t      (void) va_arg (ap, ptrdiff_t);\n#else\n\t      ASSERT_FAIL (ptrdiff_t not available);\n#endif\n\t      break;\n\t    case 'z':\n\t      (void) va_arg (ap, size_t);\n\t      break;\n\t    case 'Z':\n\t      {\n\t\tint   ret;\n\t\tFLUSH ();\n\t\tgmp_str = mpz_get_str (NULL, param.base,\n\t\t\t\t       va_arg (ap, mpz_srcptr));\n\t      gmp_integer:\n\t\tret = __gmp_doprnt_integer (funs, data, &param, gmp_str);\n\t\t(*__gmp_free_func) (gmp_str, strlen(gmp_str)+1);\n\t\tDOPRNT_ACCUMULATE (ret);\n\t\tva_copy (last_ap, ap);\n\t\tlast_fmt = fmt;\n\t      }\n\t      break;\n\t    default:\n\t      /* default is an \"int\", and this includes h=short and hh=char\n\t\t since they're promoted to int in a function call */\n\t      (void) va_arg (ap, int);\n\t      break;\n\t    }\n\t    goto next;\n\n\t  case 'E':\n\t    param.base = -10;\n\t    param.expfmt = \"E%c%02ld\";\n\t    /*FALLTHRU*/\n\t  case 'e':\n\t    param.conv = DOPRNT_CONV_SCIENTIFIC;\n\t  floating:\n\t    if (param.showbase == DOPRNT_SHOWBASE_NONZERO)\n\t      {\n\t\t/* # in %e, %f and %g */\n\t\tparam.showpoint = 1;\n\t\tparam.showtrailing = 1;\n\t      }\n\t  floating_a:\n\t    switch (type) {\n\t    case 'F':\n\t      FLUSH ();\n\t      DOPRNT_ACCUMULATE (__gmp_doprnt_mpf (funs, data, &param,\n\t\t\t\t\t\t   GMP_DECIMAL_POINT,\n\t\t\t\t\t\t   va_arg (ap, mpf_srcptr)));\n\t      va_copy (last_ap, ap);\n\t      last_fmt = fmt;\n\t      break;\n\t    case 'L':\n#if HAVE_LONG_DOUBLE\n\t      (void) va_arg (ap, long double);\n#else\n\t      ASSERT_FAIL (long double not available);\n#endif\n\t      break;\n\t    default:\n\t      (void) va_arg (ap, double);\n\t      break;\n\t    }\n\t    goto next;\n\n\t  case 'f':\n\t    param.conv = DOPRNT_CONV_FIXED;\n\t    goto floating;\n\n\t  case 'F': /* mpf_t     */\n\t  case 'j': /* intmax_t  */\n\t  case 'L': /* long long */\n\t  case 'N': /* mpn       */\n\t  case 'q': /* quad_t    */\n\t  case 'Q': /* mpq_t     */\n\t  case 't': /* ptrdiff_t */\n\t  case 'z': /* size_t    */\n\t  case 'Z': /* mpz_t     */\n\t  set_type:\n\t    type = fchar;\n\t    break;\n\n\t  case 'G':\n\t    param.base = -10;\n\t    param.expfmt = \"E%c%02ld\";\n\t    /*FALLTHRU*/\n\t  case 'g':\n\t    param.conv = DOPRNT_CONV_GENERAL;\n\t    param.showtrailing = 0;\n\t    goto floating;\n\n\t  case 'h':\n\t    if (type != 'h')\n\t      goto set_type;\n\t    type = 'H';   /* internal code for \"hh\" */\n\t    break;\n\n\t  case 'l':\n\t    if (type != 'l')\n\t      goto set_type;\n\t    type = 'L';   /* \"ll\" means \"L\" */\n\t    break;\n\n\t  case 'm':\n\t    /* glibc strerror(errno), no argument */\n\t    goto next;\n\n\t  case 'M': /* mp_limb_t */\n\t    /* mung format string to l or ll and let plain printf handle it */\n#if _LONG_LONG_LIMB\n\t    memmove (fmt+1, fmt, strlen (fmt)+1);\n\t    fmt[-1] = 'l';\n\t    fmt[0] = 'l';\n\t    fmt++;\n\t    type = 'L';\n#else\n\t    fmt[-1] = 'l';\n\t    type = 'l';\n#endif\n\t    break;\n\n\t  case 'n':\n\t    {\n\t      void  *p;\n\t      FLUSH ();\n\t      p = va_arg (ap, void *);\n\t      switch (type) {\n\t      case '\\0': * (int       *) p = retval; break;\n\t      case 'F':  mpf_set_si ((mpf_ptr) p, (long) retval); break;\n\t      case 'H':  * (char      *) p = retval; break;\n\t      case 'h':  * (short     *) p = retval; break;\n#if HAVE_INTMAX_T\n\t      case 'j':  * (intmax_t  *) p = retval; break;\n#else\n\t      case 'j':  ASSERT_FAIL (intmax_t not available); break;\n#endif\n\t      case 'l':  * (long      *) p = retval; break;\n#if HAVE_QUAD_T && HAVE_LONG_LONG\n\t      case 'q':\n\t\tASSERT_ALWAYS (sizeof (quad_t) == sizeof (long long));\n\t\t/*FALLTHRU*/\n#else\n\t      case 'q':  ASSERT_FAIL (quad_t not available); break;\n#endif\n#if HAVE_LONG_LONG\n\t      case 'L':  * (long long *) p = retval; break;\n#else\n\t      case 'L':  ASSERT_FAIL (long long not available); break;\n#endif\n\t      case 'N':\n\t\t{\n\t\t  mp_size_t  n;\n\t\t  n = va_arg (ap, mp_size_t);\n\t\t  n = ABS (n);\n\t\t  if (n != 0)\n\t\t    {\n\t\t      * (mp_ptr) p = retval;\n\t\t      MPN_ZERO ((mp_ptr) p + 1, n - 1);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      case 'Q':  mpq_set_si ((mpq_ptr) p, (long) retval, 1L); break;\n#if HAVE_PTRDIFF_T\n\t      case 't':  * (ptrdiff_t *) p = retval; break;\n#else\n\t      case 't':  ASSERT_FAIL (ptrdiff_t not available); break;\n#endif\n\t      case 'z':  * (size_t    *) p = retval; break;\n\t      case 'Z':  mpz_set_si ((mpz_ptr) p, (long) retval); break;\n\t      }\n\t    }\n\t    va_copy (last_ap, ap);\n\t    last_fmt = fmt;\n\t    goto next;\n\n\t  case 'o':\n\t    param.base = 8;\n\t    goto integer;\n\n\t  case 'p':\n\t  case 's':\n\t    /* \"void *\" will be good enough for \"char *\" or \"wchar_t *\", no\n\t       need for separate code.  */\n\t    (void) va_arg (ap, const void *);\n\t    goto next;\n\n\t  case 'x':\n\t    param.base = 16;\n\t    goto integer;\n\t  case 'X':\n\t    param.base = -16;\n\t    goto integer;\n\n\t  case '%':\n\t    goto next;\n\n\t  case '#':\n\t    param.showbase = DOPRNT_SHOWBASE_NONZERO;\n\t    break;\n\n\t  case '\\'':\n\t    /* glibc digit grouping, just pass it through, no support for it\n\t       on gmp types */\n\t    break;\n\n\t  case '+':\n\t  case ' ':\n\t    param.sign = fchar;\n\t    break;\n\n\t  case '-':\n\t    param.justify = DOPRNT_JUSTIFY_LEFT;\n\t    break;\n\t  case '.':\n\t    seen_precision = 1;\n\t    param.prec = -1; /* \".\" alone means all necessary digits */\n\t    value = &param.prec;\n\t    break;\n\n\t  case '*':\n\t    {\n\t      int n = va_arg (ap, int);\n\n\t      if (value == &param.width)\n\t\t{\n\t\t  /* negative width means left justify */\n\t\t  if (n < 0)\n\t\t    {\n\t\t      param.justify = DOPRNT_JUSTIFY_LEFT;\n\t\t      n = -n;\n\t\t    }\n\t\t  param.width = n;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* don't allow negative precision */\n\t\t  param.prec = MAX (0, n);\n\t\t}\n\t    }\n\t    break;\n\n\t  case '0':\n\t    if (value == &param.width)\n\t      {\n\t\t/* in width field, set fill */\n\t\tparam.fill = '0';\n\n\t\t/* for right justify, put the fill after any minus sign */\n\t\tif (param.justify == DOPRNT_JUSTIFY_RIGHT)\n\t\t  param.justify = DOPRNT_JUSTIFY_INTERNAL;\n\t      }\n\t    else\n\t      {\n\t\t/* in precision field, set value */\n\t\t*value = 0;\n\t      }\n\t    break;\n\n\t  case '1': case '2': case '3': case '4': case '5':\n\t  case '6': case '7': case '8': case '9':\n\t    /* process all digits to form a value */\n\t    {\n\t      int  n = 0;\n\t      do {\n\t\tn = n * 10 + (fchar-'0');\n\t\tfchar = *fmt++;\n\t      } while (isascii (fchar) && isdigit (fchar));\n\t      fmt--; /* unget the non-digit */\n\t      *value = n;\n\t    }\n\t    break;\n\n\t  default:\n\t    /* something invalid */\n\t    ASSERT (0);\n\t    goto next;\n\t  }\n\t}\n\n    next:\n      /* Stop parsing the current \"%\" format, look for a new one. */\n      ;\n    }\n\n  TRACE (printf (\"remainder: \\\"%s\\\"\\n\", last_fmt));\n  if (*last_fmt != '\\0')\n    DOPRNT_FORMAT (last_fmt, last_ap);\n\n  if (funs->final != NULL)\n    if ((*funs->final) (data) == -1)\n      goto error;\n\n done:\n  (*__gmp_free_func) (alloc_fmt, alloc_fmt_size);\n  return retval;\n\n error:\n  retval = -1;\n  goto done;\n}",
      "lines": 470,
      "depth": 23,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/doprntf.c": {
    "__gmp_doprnt_mpf": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "int\n__gmp_doprnt_mpf (const struct doprnt_funs_t *funs,\n\t\t  void *data,\n\t\t  const struct doprnt_params_t *p,\n\t\t  const char *point,\n\t\t  mpf_srcptr f)\n{\n  int         prec, ndigits, free_size, len, newlen, justify, justlen, explen;\n  int         showbaselen, sign, signlen, intlen, intzeros, pointlen;\n  int         fraczeros, fraclen, preczeros;\n  char        *s, *free_ptr;\n  mp_exp_t    exp;\n  char        exponent[GMP_LIMB_BITS + 10];\n  const char  *showbase;\n  int         retval = 0;\n\n  TRACE (printf (\"__gmp_doprnt_float\\n\");\n\t printf (\"  conv=%d prec=%d\\n\", p->conv, p->prec));\n\n  prec = p->prec;\n  if (prec <= -1)\n    {\n      /* all digits */\n      ndigits = 0;\n\n      /* arrange the fixed/scientific decision on a \"prec\" implied by how\n\t many significant digits there are */\n      if (p->conv == DOPRNT_CONV_GENERAL)\n\tMPF_SIGNIFICANT_DIGITS (prec, PREC(f), ABS(p->base));\n    }\n  else\n    {\n      switch (p->conv) {\n      case DOPRNT_CONV_FIXED:\n\t/* Precision is digits after the radix point.  Try not to generate\n\t   too many more than will actually be required.  If f>=1 then\n\t   overestimate the integer part, and add prec.  If f<1 then\n\t   underestimate the zeros between the radix point and the first\n\t   digit and subtract that from prec.  In either case add 2 so the\n\t   round to nearest can be applied accurately.  Finally, we add 1 to\n\t   handle the case of 1-eps where EXP(f) = 0 but mpf_get_str returns\n\t   exp as 1.  */\n\tndigits = prec + 2 + 1\n\t  + EXP(f) * (mp_bases[ABS(p->base)].chars_per_limb + (EXP(f)>=0));\n\tndigits = MAX (ndigits, 1);\n\tbreak;\n\n      case DOPRNT_CONV_SCIENTIFIC:\n\t/* precision is digits after the radix point, and there's one digit\n\t   before */\n\tndigits = prec + 1;\n\tbreak;\n\n      default:\n\tASSERT (0);\n\t/*FALLTHRU*/\n\n      case DOPRNT_CONV_GENERAL:\n\t/* precision is total digits, but be sure to ask mpf_get_str for at\n\t   least 1, not 0 */\n\tndigits = MAX (prec, 1);\n\tbreak;\n      }\n    }\n  TRACE (printf (\"  ndigits %d\\n\", ndigits));\n\n  s = mpf_get_str (NULL, &exp, p->base, ndigits, f);\n  len = strlen (s);\n  free_ptr = s;\n  free_size = len + 1;\n  TRACE (printf (\"  s   %s\\n\", s);\n\t printf (\"  exp %ld\\n\", exp);\n\t printf (\"  len %d\\n\", len));\n\n  /* For fixed mode check the ndigits formed above was in fact enough for\n     the integer part plus p->prec after the radix point. */\n  ASSERT ((p->conv == DOPRNT_CONV_FIXED && p->prec > -1)\n\t  ? ndigits >= MAX (1, exp + p->prec + 2) : 1);\n\n  sign = p->sign;\n  if (s[0] == '-')\n    {\n      sign = s[0];\n      s++, len--;\n    }\n  signlen = (sign != '\\0');\n  TRACE (printf (\"  sign %c  signlen %d\\n\", sign, signlen));\n\n  switch (p->conv) {\n  case DOPRNT_CONV_FIXED:\n    if (prec <= -1)\n      prec = MAX (0, len-exp);   /* retain all digits */\n\n    /* Truncate if necessary so fraction will be at most prec digits. */\n    ASSERT (prec >= 0);\n    newlen = exp + prec;\n    if (newlen < 0)\n      {\n\t/* first non-zero digit is below target prec, and at least one zero\n\t   digit in between, so print zero */\n\tlen = 0;\n\texp = 0;\n      }\n    else if (len <= newlen)\n      {\n\t/* already got few enough digits */\n      }\n    else\n      {\n\t/* discard excess digits and round to nearest */\n\n\tconst char  *num_to_text = (p->base >= 0\n\t\t\t\t    ? \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\t\t\t\t    : \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n\tint  base = ABS(p->base);\n\tint  n;\n\n\tASSERT (base <= 36);\n\n\tlen = newlen;\n\tn = DIGIT_VALUE (s[len]);\n\tTRACE (printf (\"  rounding with %d\\n\", n));\n\tif (n >= (base + 1) / 2)\n\t  {\n\t    /* propagate a carry */\n\t    for (;;)\n\t      {\n\t\tif (len == 0)\n\t\t  {\n\t\t    s[0] = '1';\n\t\t    len = 1;\n\t\t    exp++;\n\t\t    break;\n\t\t  }\n\t\tn = DIGIT_VALUE (s[len-1]);\n\t\tASSERT (n >= 0 && n < base);\n\t\tn++;\n\t\tif (n != base)\n\t\t  {\n\t\t    TRACE (printf (\"  storing now %d\\n\", n));\n\t\t    s[len-1] = num_to_text[n];\n\t\t    break;\n\t\t  }\n\t\tlen--;\n\t      }\n\t  }\n\telse\n\t  {\n\t    /* truncate only, strip any trailing zeros now exposed */\n\t    while (len > 0 && s[len-1] == '0')\n\t      len--;\n\t  }\n\n\t/* Can have newlen==0, in which case the truncate was just to check\n\t   for a carry turning it into \"1\".  If we're left with len==0 then\n\t   adjust exp to match.  */\n\tif (len == 0)\n\t  exp = 0;\n      }\n\n  fixed:\n    ASSERT (len == 0 ? exp == 0 : 1);\n    if (exp <= 0)\n      {\n\tTRACE (printf (\"  fixed 0.000sss\\n\"));\n\tintlen = 0;\n\tintzeros = 1;\n\tfraczeros = -exp;\n\tfraclen = len;\n      }\n    else\n      {\n\tTRACE (printf (\"  fixed sss.sss or sss000\\n\"));\n\tintlen = MIN (len, exp);\n\tintzeros = exp - intlen;\n\tfraczeros = 0;\n\tfraclen = len - intlen;\n      }\n    explen = 0;\n    break;\n\n  case DOPRNT_CONV_SCIENTIFIC:\n    {\n      long int expval;\n      char  expsign;\n\n      if (prec <= -1)\n\tprec = MAX (0, len-1);   /* retain all digits */\n\n    scientific:\n      TRACE (printf (\"  scientific s.sss\\n\"));\n\n      intlen = MIN (1, len);\n      intzeros = (intlen == 0 ? 1 : 0);\n      fraczeros = 0;\n      fraclen = len - intlen;\n\n      expval = (exp-intlen);\n      if (p->exptimes4)\n\texpval <<= 2;\n\n      /* Split out the sign since %o or %x in expfmt give negatives as twos\n\t complement, not with a sign. */\n      expsign = (expval >= 0 ? '+' : '-');\n      expval = ABS (expval);\n\n#if HAVE_VSNPRINTF\n      explen = snprintf (exponent, sizeof(exponent),\n\t\t\t p->expfmt, expsign, expval);\n      /* test for < sizeof-1 since a glibc 2.0.x return of sizeof-1 might\n\t mean truncation */\n      ASSERT (explen >= 0 && explen < sizeof(exponent)-1);\n#else\n      sprintf (exponent, p->expfmt, expsign, expval);\n      explen = strlen (exponent);\n      ASSERT (explen < sizeof(exponent));\n#endif\n      TRACE (printf (\"  expfmt %s gives %s\\n\", p->expfmt, exponent));\n    }\n    break;\n\n  default:\n    ASSERT (0);\n    /*FALLTHRU*/  /* to stop variables looking uninitialized */\n\n  case DOPRNT_CONV_GENERAL:\n    /* The exponent for \"scientific\" will be exp-1, choose scientific if\n       this is < -4 or >= prec (and minimum 1 for prec).  For f==0 will have\n       exp==0 and get the desired \"fixed\".  This rule follows glibc.  For\n       fixed there's no need to truncate, the desired ndigits will already\n       be as required.  */\n    if (exp-1 < -4 || exp-1 >= MAX (1, prec))\n      goto scientific;\n    else\n      goto fixed;\n  }\n\n  TRACE (printf (\"  intlen %d intzeros %d fraczeros %d fraclen %d\\n\",\n\t\t intlen, intzeros, fraczeros, fraclen));\n  ASSERT (p->prec <= -1\n\t  ? intlen + fraclen == strlen (s)\n\t  : intlen + fraclen <= strlen (s));\n\n  if (p->showtrailing)\n    {\n      /* Pad to requested precision with trailing zeros, for general this is\n\t all digits, for fixed and scientific just the fraction.  */\n      preczeros = prec - (fraczeros + fraclen\n\t\t\t  + (p->conv == DOPRNT_CONV_GENERAL\n\t\t\t     ? intlen + intzeros : 0));\n      preczeros = MAX (0, preczeros);\n    }\n  else\n    preczeros = 0;\n  TRACE (printf (\"  prec=%d showtrailing=%d, pad with preczeros %d\\n\",\n\t\t prec, p->showtrailing, preczeros));\n\n  /* radix point if needed, or if forced */\n  pointlen = ((fraczeros + fraclen + preczeros) != 0 || p->showpoint != 0)\n    ? strlen (point) : 0;\n  TRACE (printf (\"  point |%s|  pointlen %d\\n\", point, pointlen));\n\n  /* Notice the test for a non-zero value is done after any truncation for\n     DOPRNT_CONV_FIXED. */\n  showbase = NULL;\n  showbaselen = 0;\n  switch (p->showbase) {\n  default:\n    ASSERT (0);\n    /*FALLTHRU*/\n  case DOPRNT_SHOWBASE_NO:\n    break;\n  case DOPRNT_SHOWBASE_NONZERO:\n    if (intlen == 0 && fraclen == 0)\n      break;\n    /*FALLTHRU*/\n  case DOPRNT_SHOWBASE_YES:\n    switch (p->base) {\n    case 16:  showbase = \"0x\"; showbaselen = 2; break;\n    case -16: showbase = \"0X\"; showbaselen = 2; break;\n    case 8:   showbase = \"0\";  showbaselen = 1; break;\n    }\n    break;\n  }\n  TRACE (printf (\"  showbase %s showbaselen %d\\n\",\n\t\t showbase == NULL ? \"\" : showbase, showbaselen));\n\n  /* left over field width */\n  justlen = p->width - (signlen + showbaselen + intlen + intzeros + pointlen\n\t\t\t+ fraczeros + fraclen + preczeros + explen);\n  TRACE (printf (\"  justlen %d fill 0x%X\\n\", justlen, p->fill));\n\n  justify = p->justify;\n  if (justlen <= 0) /* no justifying if exceed width */\n    justify = DOPRNT_JUSTIFY_NONE;\n\n  TRACE (printf (\"  justify type %d  intlen %d pointlen %d fraclen %d\\n\",\n\t\t justify, intlen, pointlen, fraclen));\n\n  if (justify == DOPRNT_JUSTIFY_RIGHT)         /* pad for right */\n    DOPRNT_REPS (p->fill, justlen);\n\n  if (signlen)                                 /* sign */\n    DOPRNT_REPS (sign, 1);\n\n  DOPRNT_MEMORY_MAYBE (showbase, showbaselen); /* base */\n\n  if (justify == DOPRNT_JUSTIFY_INTERNAL)      /* pad for internal */\n    DOPRNT_REPS (p->fill, justlen);\n\n  DOPRNT_MEMORY (s, intlen);                   /* integer */\n  DOPRNT_REPS_MAYBE ('0', intzeros);\n\n  DOPRNT_MEMORY_MAYBE (point, pointlen);       /* point */\n\n  DOPRNT_REPS_MAYBE ('0', fraczeros);          /* frac */\n  DOPRNT_MEMORY_MAYBE (s+intlen, fraclen);\n\n  DOPRNT_REPS_MAYBE ('0', preczeros);          /* prec */\n\n  DOPRNT_MEMORY_MAYBE (exponent, explen);      /* exp */\n\n  if (justify == DOPRNT_JUSTIFY_LEFT)          /* pad for left */\n    DOPRNT_REPS (p->fill, justlen);\n\n done:\n  (*__gmp_free_func) (free_ptr, free_size);\n  return retval;\n\n error:\n  retval = -1;\n  goto done;\n}",
      "lines": 333,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/doprnti.c": {
    "__gmp_doprnt_integer": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "int\n__gmp_doprnt_integer (const struct doprnt_funs_t *funs,\n\t\t      void *data,\n\t\t      const struct doprnt_params_t *p,\n\t\t      const char *s)\n{\n  int         retval = 0;\n  int         slen, justlen, showbaselen, sign, signlen, slashlen, zeros;\n  int         justify, den_showbaselen;\n  const char  *slash, *showbase;\n\n  /* '+' or ' ' if wanted, and don't already have '-' */\n  sign = p->sign;\n  if (s[0] == '-')\n    {\n      sign = s[0];\n      s++;\n    }\n  signlen = (sign != '\\0');\n\n  /* if the precision was explicitly 0, print nothing for a 0 value */\n  if (*s == '0' && p->prec == 0)\n    s++;\n\n  slen = strlen (s);\n  slash = strchr (s, '/');\n\n  showbase = NULL;\n  showbaselen = 0;\n\n  if (p->showbase != DOPRNT_SHOWBASE_NO)\n    {\n      switch (p->base) {\n      case 16:  showbase = \"0x\"; showbaselen = 2; break;\n      case -16: showbase = \"0X\"; showbaselen = 2; break;\n      case 8:   showbase = \"0\";  showbaselen = 1; break;\n      }\n    }\n\n  den_showbaselen = showbaselen;\n  if (slash == NULL\n      || (p->showbase == DOPRNT_SHOWBASE_NONZERO && slash[1] == '0'))\n    den_showbaselen = 0;\n\n  if (p->showbase == DOPRNT_SHOWBASE_NONZERO && s[0] == '0')\n    showbaselen = 0;\n\n  /* the influence of p->prec on mpq is currently undefined */\n  zeros = MAX (0, p->prec - slen);\n\n  /* space left over after actual output length */\n  justlen = p->width\n    - (strlen(s) + signlen + showbaselen + den_showbaselen + zeros);\n\n  justify = p->justify;\n  if (justlen <= 0) /* no justifying if exceed width */\n    justify = DOPRNT_JUSTIFY_NONE;\n\n  if (justify == DOPRNT_JUSTIFY_RIGHT)             /* pad right */\n    DOPRNT_REPS (p->fill, justlen);\n\n  DOPRNT_REPS_MAYBE (sign, signlen);               /* sign */\n\n  DOPRNT_MEMORY_MAYBE (showbase, showbaselen);     /* base */\n\n  DOPRNT_REPS_MAYBE ('0', zeros);                  /* zeros */\n\n  if (justify == DOPRNT_JUSTIFY_INTERNAL)          /* pad internal */\n    DOPRNT_REPS (p->fill, justlen);\n\n  /* if there's a showbase on the denominator, then print the numerator\n     separately so it can be inserted */\n  if (den_showbaselen != 0)\n    {\n      ASSERT (slash != NULL);\n      slashlen = slash+1 - s;\n      DOPRNT_MEMORY (s, slashlen);                 /* numerator and slash */\n      slen -= slashlen;\n      s += slashlen;\n      DOPRNT_MEMORY (showbase, den_showbaselen);\n    }\n\n  DOPRNT_MEMORY (s, slen);                         /* number, or denominator */\n\n  if (justify == DOPRNT_JUSTIFY_LEFT)              /* pad left */\n    DOPRNT_REPS (p->fill, justlen);\n\n done:\n  return retval;\n\n error:\n  retval = -1;\n  goto done;\n}",
      "lines": 94,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/fprintf.c": {
    "gmp_fprintf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\ngmp_fprintf (FILE *fp, const char *fmt, ...)\n{\n  va_list  ap;\n  int      ret;\n\n  va_start (ap, fmt);\n\n  ret = __gmp_doprnt (&__gmp_fprintf_funs, fp, fmt, ap);\n  va_end (ap);\n  return ret;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/obprintf.c": {
    "gmp_obstack_printf": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\ngmp_obstack_printf (struct obstack *ob, const char *fmt, ...)\n{\n  va_list  ap;\n  int      ret;\n\n  va_start (ap, fmt);\n\n  ASSERT (! MEM_OVERLAP_P (obstack_base(ob), obstack_object_size(ob),\n                           fmt, strlen(fmt)+1));\n\n  ret = __gmp_doprnt (&__gmp_obstack_printf_funs, ob, fmt, ap);\n  va_end (ap);\n  return ret;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/obprntffuns.c": {
    "gmp_obstack_memory": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static int\ngmp_obstack_memory (struct obstack *ob, const char *ptr, size_t len)\n{\n  obstack_grow (ob, ptr, len);\n  return len;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gmp_obstack_reps": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static int\ngmp_obstack_reps (struct obstack *ob, int c, int reps)\n{\n  obstack_blank (ob, reps);\n  memset ((char *) obstack_next_free(ob) - reps, c, reps);\n  return reps;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/obvprintf.c": {
    "gmp_obstack_vprintf": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\ngmp_obstack_vprintf (struct obstack *ob, const char *fmt, va_list ap)\n{\n  ASSERT (! MEM_OVERLAP_P (obstack_base(ob), obstack_object_size(ob),\n                           fmt, strlen(fmt)+1));\n\n  return __gmp_doprnt (&__gmp_obstack_printf_funs, ob, fmt, ap);\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/printf.c": {
    "gmp_printf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\ngmp_printf (const char *fmt, ...)\n{\n  va_list  ap;\n  int      ret;\n\n  va_start (ap, fmt);\n\n  ret = __gmp_doprnt (&__gmp_fprintf_funs, stdout, fmt, ap);\n  va_end (ap);\n  return ret;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/printffuns.c": {
    "gmp_fprintf_memory": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static int\ngmp_fprintf_memory (FILE *fp, const char *str, size_t len)\n{\n  return fwrite (str, 1, len, fp);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gmp_fprintf_reps": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static int\ngmp_fprintf_reps (FILE *fp, int c, int reps)\n{\n  char  buf[256];\n  int   i, piece, ret;\n  ASSERT (reps >= 0);\n\n  memset (buf, c, MIN (reps, sizeof (buf)));\n  for (i = reps; i > 0; i -= sizeof (buf))\n    {\n      piece = MIN (i, sizeof (buf));\n      ret = fwrite (buf, 1, piece, fp);\n      if (ret == -1)\n        return ret;\n      ASSERT (ret == piece);\n    }\n\n  return reps;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/repl-vsnprintf.c": {
    "strnlen": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static size_t\nstrnlen (const char *s, size_t n)\n{\n  size_t  i;\n  for (i = 0; i < n; i++)\n    if (s[i] == '\\0')\n      break;\n  return i;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "__gmp_replacement_vsnprintf": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "int\n__gmp_replacement_vsnprintf (char *buf, size_t buf_size,\n\t\t\t     const char *orig_fmt, va_list orig_ap)\n{\n  va_list     ap;\n  const char  *fmt;\n  size_t      total_width, integer_sizeof, floating_sizeof, len;\n  char        fchar, type;\n  int         width, prec, seen_prec, double_digits, long_double_digits;\n  int         *value;\n\n  /* preserve orig_ap for use after size estimation */\n  va_copy (ap, orig_ap);\n\n  fmt = orig_fmt;\n  total_width = strlen (fmt) + 1;   /* 1 extra for the '\\0' */\n\n  integer_sizeof = sizeof (long);\n#if HAVE_LONG_LONG\n  integer_sizeof = MAX (integer_sizeof, sizeof (long long));\n#endif\n#if HAVE_QUAD_T\n  integer_sizeof = MAX (integer_sizeof, sizeof (quad_t));\n#endif\n\n  floating_sizeof = sizeof (double);\n#if HAVE_LONG_DOUBLE\n  floating_sizeof = MAX (floating_sizeof, sizeof (long double));\n#endif\n\n  /* IEEE double or VAX G floats have an 11 bit exponent, so the default is\n     a maximum 308 decimal digits.  VAX D floats have only an 8 bit\n     exponent, but we don't bother trying to detect that directly.  */\n  double_digits = 308;\n#ifdef DBL_MAX_10_EXP\n  /* but in any case prefer a value the compiler says */\n  double_digits = DBL_MAX_10_EXP;\n#endif\n\n  /* IEEE 128-bit quad, Intel 80-bit temporary, or VAX H floats all have 15\n     bit exponents, so the default is a maximum 4932 decimal digits.  */\n  long_double_digits = 4932;\n  /* but if double == long double, then go with that size */\n#if HAVE_LONG_DOUBLE\n  if (sizeof (double) == sizeof (long double))\n    long_double_digits = double_digits;\n#endif\n#ifdef LDBL_MAX_10_EXP\n  /* but in any case prefer a value the compiler says */\n  long_double_digits = LDBL_MAX_10_EXP;\n#endif\n\n  for (;;)\n    {\n      fmt = strchr (fmt, '%');\n      if (fmt == NULL)\n\tbreak;\n      fmt++;\n\n      type = '\\0';\n      width = 0;\n      prec = 6;\n      seen_prec = 0;\n      value = &width;\n\n      for (;;)\n\t{\n\t  fchar = *fmt++;\n\t  switch (fchar) {\n\n\t  case 'c':\n\t    /* char, already accounted for by strlen(fmt) */\n\t    goto next;\n\n\t  case 'd':\n\t  case 'i':\n\t  case 'o':\n\t  case 'x':\n\t  case 'X':\n\t  case 'u':\n\t    /* at most 3 digits per byte in hex, dec or octal, plus a sign */\n\t    total_width += 3 * integer_sizeof + 1;\n\n\t    switch (type) {\n\t    case 'j':\n\t      /* Let's assume uintmax_t is the same size as intmax_t. */\n#if HAVE_INTMAX_T\n\t      (void) va_arg (ap, intmax_t);\n#else\n\t      ASSERT_FAIL (intmax_t not available);\n#endif\n\t      break;\n\t    case 'l':\n\t      (void) va_arg (ap, long);\n\t      break;\n\t    case 'L':\n#if HAVE_LONG_LONG\n\t      (void) va_arg (ap, long long);\n#else\n\t      ASSERT_FAIL (long long not available);\n#endif\n\t      break;\n\t    case 'q':\n\t      /* quad_t is probably the same as long long, but let's treat\n\t\t it separately just to be sure.  Also let's assume u_quad_t\n\t\t will be the same size as quad_t.  */\n#if HAVE_QUAD_T\n\t      (void) va_arg (ap, quad_t);\n#else\n\t      ASSERT_FAIL (quad_t not available);\n#endif\n\t      break;\n\t    case 't':\n#if HAVE_PTRDIFF_T\n\t      (void) va_arg (ap, ptrdiff_t);\n#else\n\t      ASSERT_FAIL (ptrdiff_t not available);\n#endif\n\t      break;\n\t    case 'z':\n\t      (void) va_arg (ap, size_t);\n\t      break;\n\t    default:\n\t      /* default is an \"int\", and this includes h=short and hh=char\n\t\t since they're promoted to int in a function call */\n\t      (void) va_arg (ap, int);\n\t      break;\n\t    }\n\t    goto next;\n\n\t  case 'E':\n\t  case 'e':\n\t  case 'G':\n\t  case 'g':\n\t    /* Requested decimals, sign, point and e, plus an overestimate\n\t       of exponent digits (the assumption is all the float is\n\t       exponent!).  */\n\t    total_width += prec + 3 + floating_sizeof * 3;\n\t    if (type == 'L')\n\t      {\n#if HAVE_LONG_DOUBLE\n\t\t(void) va_arg (ap, long double);\n#else\n\t\tASSERT_FAIL (long double not available);\n#endif\n\t      }\n\t    else\n\t      (void) va_arg (ap, double);\n\t    break;\n\n\t  case 'f':\n\t    /* Requested decimals, sign and point, and a margin for error,\n\t       then add the maximum digits that can be in the integer part,\n\t       based on the maximum exponent value. */\n\t    total_width += prec + 2 + 10;\n\t    if (type == 'L')\n\t      {\n#if HAVE_LONG_DOUBLE\n\t\t(void) va_arg (ap, long double);\n\t\ttotal_width += long_double_digits;\n#else\n\t\tASSERT_FAIL (long double not available);\n#endif\n\t      }\n\t    else\n\t      {\n\t\t(void) va_arg (ap, double);\n\t\ttotal_width += double_digits;\n\t      }\n\t    break;\n\n\t  case 'h':  /* short or char */\n\t  case 'j':  /* intmax_t */\n\t  case 'L':  /* long long or long double */\n\t  case 'q':  /* quad_t */\n\t  case 't':  /* ptrdiff_t */\n\t  case 'z':  /* size_t */\n\t  set_type:\n\t    type = fchar;\n\t    break;\n\n\t  case 'l':\n\t    /* long or long long */\n\t    if (type != 'l')\n\t      goto set_type;\n\t    type = 'L';   /* \"ll\" means \"L\" */\n\t    break;\n\n\t  case 'n':\n\t    /* bytes written, no output as such */\n\t    (void) va_arg (ap, void *);\n\t    goto next;\n\n\t  case 's':\n\t    /* If no precision was given, then determine the string length\n\t       and put it there, to be added to the total under \"next\".  If\n\t       a precision was given then that's already the maximum from\n\t       this field, but see whether the string is shorter than that,\n\t       in case the limit was very big.  */\n\t    {\n\t      const char  *s = va_arg (ap, const char *);\n\t      prec = (seen_prec ? strnlen (s, prec) : strlen (s));\n\t    }\n\t    goto next;\n\n\t  case 'p':\n\t    /* pointer, let's assume at worst it's octal with some padding */\n\t    (void) va_arg (ap, const void *);\n\t    total_width += 3 * sizeof (void *) + 16;\n\t    goto next;\n\n\t  case '%':\n\t    /* literal %, already accounted for by strlen(fmt) */\n\t    goto next;\n\n\t  case '#':\n\t    /* showbase, at most 2 for \"0x\" */\n\t    total_width += 2;\n\t    break;\n\n\t  case '+':\n\t  case ' ':\n\t    /* sign, already accounted for under numerics */\n\t    break;\n\n\t  case '-':\n\t    /* left justify, no effect on total width */\n\t    break;\n\n\t  case '.':\n\t    seen_prec = 1;\n\t    value = &prec;\n\t    break;\n\n\t  case '*':\n\t    {\n\t      /* negative width means left justify which can be ignored,\n\t\t negative prec would be invalid, just use absolute value */\n\t      int n = va_arg (ap, int);\n\t      *value = ABS (n);\n\t    }\n\t    break;\n\n\t  case '0': case '1': case '2': case '3': case '4':\n\t  case '5': case '6': case '7': case '8': case '9':\n\t    /* process all digits to form a value */\n\t    {\n\t      int  n = 0;\n\t      do {\n\t\tn = n * 10 + (fchar-'0');\n\t\tfchar = *fmt++;\n\t      } while (isascii (fchar) && isdigit (fchar));\n\t      fmt--; /* unget the non-digit */\n\t      *value = n;\n\t    }\n\t    break;\n\n\t  default:\n\t    /* incomplete or invalid % sequence */\n\t    ASSERT (0);\n\t    goto next;\n\t  }\n\t}\n\n    next:\n      total_width += width;\n      total_width += prec;\n    }\n\n  if (total_width <= buf_size)\n    {\n      vsprintf (buf, orig_fmt, orig_ap);\n      len = strlen (buf);\n    }\n  else\n    {\n      char  *s;\n\n      s = __GMP_ALLOCATE_FUNC_TYPE (total_width, char);\n      vsprintf (s, orig_fmt, orig_ap);\n      len = strlen (s);\n      if (buf_size != 0)\n\t{\n\t  size_t  copylen = MIN (len, buf_size-1);\n\t  memcpy (buf, s, copylen);\n\t  buf[copylen] = '\\0';\n\t}\n      (*__gmp_free_func) (s, total_width);\n    }\n\n  /* If total_width was somehow wrong then chances are we've already\n     clobbered memory, but maybe this check will still work.  */\n  ASSERT_ALWAYS (len < total_width);\n\n  return len;\n}",
      "lines": 296,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/snprintf.c": {
    "gmp_snprintf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\ngmp_snprintf (char *buf, size_t size, const char *fmt, ...)\n{\n  struct gmp_snprintf_t d;\n  va_list  ap;\n  int      ret;\n\n  va_start (ap, fmt);\n  d.buf = buf;\n  d.size = size;\n\n  ASSERT (! MEM_OVERLAP_P (buf, size, fmt, strlen(fmt)+1));\n\n  ret = __gmp_doprnt (&__gmp_snprintf_funs, &d, fmt, ap);\n  va_end (ap);\n  return ret;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/snprntffuns.c": {
    "gmp_snprintf_format": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static int\ngmp_snprintf_format (struct gmp_snprintf_t *d, const char *fmt,\n                     va_list orig_ap)\n{\n  int      ret, step, alloc, avail;\n  va_list  ap;\n  char     *p;\n\n  ASSERT (d->size >= 0);\n\n  avail = d->size;\n  if (avail > 1)\n    {\n      va_copy (ap, orig_ap);\n      ret = vsnprintf (d->buf, avail, fmt, ap);\n      if (ret == -1)\n        {\n          ASSERT (strlen (d->buf) == avail-1);\n          ret = avail-1;\n        }\n\n      step = MIN (ret, avail-1);\n      d->size -= step;\n      d->buf += step;\n\n      if (ret != avail-1)\n        return ret;\n\n      /* probably glibc 2.0.x truncated output, probe for actual size */\n      alloc = MAX (128, ret);\n    }\n  else\n    {\n      /* no space to write anything, just probe for size */\n      alloc = 128;\n    }\n\n  do\n    {\n      alloc *= 2;\n      p = __GMP_ALLOCATE_FUNC_TYPE (alloc, char);\n      va_copy (ap, orig_ap);\n      ret = vsnprintf (p, alloc, fmt, ap);\n      (*__gmp_free_func) (p, alloc);\n    }\n  while (ret == alloc-1 || ret == -1);\n\n  return ret;\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gmp_snprintf_memory": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int\ngmp_snprintf_memory (struct gmp_snprintf_t *d, const char *str, size_t len)\n{\n  size_t n;\n\n  ASSERT (d->size >= 0);\n\n  if (d->size > 1)\n    {\n      n = MIN (d->size-1, len);\n      memcpy (d->buf, str, n);\n      d->buf += n;\n      d->size -= n;\n    }\n  return len;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gmp_snprintf_reps": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static int\ngmp_snprintf_reps (struct gmp_snprintf_t *d, int c, int reps)\n{\n  size_t n;\n\n  ASSERT (reps >= 0);\n  ASSERT (d->size >= 0);\n\n  if (d->size > 1)\n    {\n      n = MIN (d->size-1, reps);\n      memset (d->buf, c, n);\n      d->buf += n;\n      d->size -= n;\n    }\n  return reps;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gmp_snprintf_final": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static int\ngmp_snprintf_final (struct gmp_snprintf_t *d)\n{\n  if (d->size >= 1)\n    d->buf[0] = '\\0';\n  return 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/sprintf.c": {
    "gmp_sprintf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\ngmp_sprintf (char *buf, const char *fmt, ...)\n{\n#if WANT_ASSERT\n  int      fmtlen = strlen(fmt);\n#endif\n  va_list  ap;\n  int      ret;\n\n  va_start (ap, fmt);\n\n  ret = __gmp_doprnt (&__gmp_sprintf_funs, &buf, fmt, ap);\n  va_end (ap);\n\n  ASSERT (! MEM_OVERLAP_P (buf, strlen(buf)+1, fmt, fmtlen+1));\n\n  return ret;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/sprintffuns.c": {
    "gmp_sprintf_format": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static int\ngmp_sprintf_format (char **bufp, const char *fmt, va_list ap)\n{\n  char  *buf = *bufp;\n  int   ret;\n  vsprintf (buf, fmt, ap);\n  ret = strlen (buf);\n  *bufp = buf + ret;\n  return ret;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gmp_sprintf_memory": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static int\ngmp_sprintf_memory (char **bufp, const char *str, size_t len)\n{\n  char  *buf = *bufp;\n  *bufp = buf + len;\n  memcpy (buf, str, len);\n  return len;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gmp_sprintf_reps": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\ngmp_sprintf_reps (char **bufp, int c, int reps)\n{\n  char  *buf = *bufp;\n  ASSERT (reps >= 0);\n  *bufp = buf + reps;\n  memset (buf, c, reps);\n  return reps;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gmp_sprintf_final": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ngmp_sprintf_final (char **bufp)\n{\n  char  *buf = *bufp;\n  *buf = '\\0';\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/vasprintf.c": {
    "gmp_asprintf_format": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static int\ngmp_asprintf_format (struct gmp_asprintf_t *d, const char *fmt,\n                     va_list orig_ap)\n{\n  int      ret;\n  va_list  ap;\n  size_t   space = 256;\n\n  for (;;)\n    {\n      GMP_ASPRINTF_T_NEED (d, space);\n      space = d->alloc - d->size;\n      va_copy (ap, orig_ap);\n      ret = vsnprintf (d->buf + d->size, space, fmt, ap);\n      if (ret == -1)\n        {\n          ASSERT (strlen (d->buf + d->size) == space-1);\n          ret = space-1;\n        }\n\n      /* done if output fits in our space */\n      if (ret < space-1)\n        break;\n\n      if (ret == space-1)\n        space *= 2;     /* possible glibc 2.0.x, so double */\n      else\n        space = ret+2;  /* C99, so now know space required */\n    }\n\n  d->size += ret;\n  return ret;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gmp_vasprintf": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\ngmp_vasprintf (char **result, const char *fmt, va_list ap)\n{\n  struct gmp_asprintf_t  d;\n  GMP_ASPRINTF_T_INIT (d, result);\n  return __gmp_doprnt (&__gmp_asprintf_funs, &d, fmt, ap);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/vfprintf.c": {
    "gmp_vfprintf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\ngmp_vfprintf (FILE *fp, const char *fmt, va_list ap)\n{\n  return __gmp_doprnt (&__gmp_fprintf_funs, fp, fmt, ap);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/vprintf.c": {
    "gmp_vprintf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\ngmp_vprintf (const char *fmt, va_list ap)\n{\n  return __gmp_doprnt (&__gmp_fprintf_funs, stdout, fmt, ap);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/vsnprintf.c": {
    "gmp_vsnprintf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\ngmp_vsnprintf (char *buf, size_t size, const char *fmt, va_list ap)\n{\n  struct gmp_snprintf_t d;\n\n  ASSERT (! MEM_OVERLAP_P (buf, size, fmt, strlen(fmt)+1));\n\n  d.buf = buf;\n  d.size = size;\n  return __gmp_doprnt (&__gmp_snprintf_funs, &d, fmt, ap);\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/printf/vsprintf.c": {
    "gmp_vsprintf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\ngmp_vsprintf (char *buf, const char *fmt, va_list ap)\n{\n#if WANT_ASSERT\n  int  fmtlen = strlen(fmt);\n#endif\n  int  ret;\n\n  ret = __gmp_doprnt (&__gmp_sprintf_funs, &buf, fmt, ap);\n\n  ASSERT (! MEM_OVERLAP_P (buf, strlen(buf)+1, fmt, fmtlen+1));\n\n  return ret;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/rand.c": {
    "gmp_randinit": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\ngmp_randinit (gmp_randstate_t rstate, gmp_randalg_t alg, ...)\n{\n  va_list ap;\n  va_start (ap, alg);\n\n  switch (alg) {\n  case GMP_RAND_ALG_LC:\n    if (! gmp_randinit_lc_2exp_size (rstate, va_arg (ap, unsigned long)))\n      gmp_errno |= GMP_ERROR_INVALID_ARGUMENT;\n    break;\n  default:\n    gmp_errno |= GMP_ERROR_UNSUPPORTED_ARGUMENT;\n    break;\n  }\n  va_end (ap);\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/randbui.c": {
    "gmp_urandomb_ui": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "unsigned long\ngmp_urandomb_ui (gmp_randstate_ptr rstate, unsigned long bits)\n{\n  mp_limb_t  a[LIMBS_PER_ULONG];\n\n  /* start with zeros, since if bits==0 then _gmp_rand will store nothing at\n     all, or if bits <= GMP_NUMB_BITS then it will store only a[0] */\n  a[0] = 0;\n#if LIMBS_PER_ULONG > 1\n  a[1] = 0;\n#endif\n\n  _gmp_rand (a, rstate, MIN (bits, BITS_PER_ULONG));\n\n#if LIMBS_PER_ULONG == 1\n  return a[0];\n#else\n  return a[0] | (a[1] << GMP_NUMB_BITS);\n#endif\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/randclr.c": {
    "gmp_randclear": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\ngmp_randclear (gmp_randstate_t rstate)\n{\n  (*((gmp_randfnptr_t *) RNG_FNPTR (rstate))->randclear_fn) (rstate);\n}",
      "lines": 5,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/randdef.c": {
    "gmp_randinit_default": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\ngmp_randinit_default (gmp_randstate_t rstate)\n{\n  gmp_randinit_mt (rstate);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/randiset.c": {
    "gmp_randinit_set": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\ngmp_randinit_set (gmp_randstate_ptr dst, gmp_randstate_srcptr src)\n{\n  (*((gmp_randfnptr_t *) RNG_FNPTR (src))->randiset_fn) (dst, src);\n}",
      "lines": 5,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/randlc2s.c": {
    "gmp_randinit_lc_2exp_size": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\ngmp_randinit_lc_2exp_size (gmp_randstate_t rstate, mp_bitcnt_t size)\n{\n  const struct __gmp_rand_lc_scheme_struct *sp;\n  mpz_t a;\n\n  /* Pick a scheme.  */\n  for (sp = __gmp_rand_lc_scheme; sp->m2exp != 0; sp++)\n    if (sp->m2exp / 2 >= size)\n      goto found;\n  return 0;\n\n found:\n  /* Install scheme.  */\n  mpz_init_set_str (a, sp->astr, 16);\n  gmp_randinit_lc_2exp (rstate, a, sp->c, sp->m2exp);\n  mpz_clear (a);\n  return 1;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/randlc2x.c": {
    "lc": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static unsigned long int\nlc (mp_ptr rp, gmp_randstate_t rstate)\n{\n  mp_ptr tp, seedp, ap;\n  mp_size_t ta;\n  mp_size_t tn, seedn, an;\n  unsigned long int m2exp;\n  unsigned long int bits;\n  int cy;\n  mp_size_t xn;\n  gmp_rand_lc_struct *p;\n  TMP_DECL;\n\n  p = (gmp_rand_lc_struct *) RNG_STATE (rstate);\n\n  m2exp = p->_mp_m2exp;\n\n  seedp = PTR (p->_mp_seed);\n  seedn = SIZ (p->_mp_seed);\n\n  ap = PTR (p->_mp_a);\n  an = SIZ (p->_mp_a);\n\n  /* Allocate temporary storage.  Let there be room for calculation of\n     (A * seed + C) % M, or M if bigger than that.  */\n\n  TMP_MARK;\n\n  ta = an + seedn + 1;\n  tn = BITS_TO_LIMBS (m2exp);\n  if (ta <= tn) /* that is, if (ta < tn + 1) */\n    {\n      mp_size_t tmp = an + seedn;\n      ta = tn + 1;\n      tp = TMP_ALLOC_LIMBS (ta);\n      MPN_ZERO (&tp[tmp], ta - tmp); /* mpn_mul won't zero it out.  */\n    }\n  else\n    tp = TMP_ALLOC_LIMBS (ta);\n\n  /* t = a * seed.  NOTE: an is always > 0; see initialization.  */\n  ASSERT (seedn >= an && an > 0);\n  mpn_mul (tp, seedp, seedn, ap, an);\n\n  /* t = t + c.  NOTE: tn is always >= p->_cn (precondition for __GMPN_ADD);\n     see initialization.  */\n  ASSERT (tn >= p->_cn);\n  __GMPN_ADD (cy, tp, tp, tn, p->_cp, p->_cn);\n\n  /* t = t % m */\n  tp[m2exp / GMP_NUMB_BITS] &= (CNST_LIMB (1) << m2exp % GMP_NUMB_BITS) - 1;\n\n  /* Save result as next seed.  */\n  MPN_COPY (PTR (p->_mp_seed), tp, tn);\n\n  /* Discard the lower m2exp/2 of the result.  */\n  bits = m2exp / 2;\n  xn = bits / GMP_NUMB_BITS;\n\n  tn -= xn;\n  if (tn > 0)\n    {\n      unsigned int cnt = bits % GMP_NUMB_BITS;\n      if (cnt != 0)\n\t{\n\t  mpn_rshift (tp, tp + xn, tn, cnt);\n\t  MPN_COPY_INCR (rp, tp, xn + 1);\n\t}\n      else\t\t\t/* Even limb boundary.  */\n\tMPN_COPY_INCR (rp, tp + xn, tn);\n    }\n\n  TMP_FREE;\n\n  /* Return number of valid bits in the result.  */\n  return (m2exp + 1) / 2;\n}",
      "lines": 77,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    },
    "randget_lc": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "static void\nrandget_lc (gmp_randstate_t rstate, mp_ptr rp, unsigned long int nbits)\n{\n  unsigned long int rbitpos;\n  int chunk_nbits;\n  mp_ptr tp;\n  mp_size_t tn;\n  gmp_rand_lc_struct *p;\n  TMP_DECL;\n\n  p = (gmp_rand_lc_struct *) RNG_STATE (rstate);\n\n  TMP_MARK;\n\n  chunk_nbits = p->_mp_m2exp / 2;\n  tn = BITS_TO_LIMBS (chunk_nbits);\n\n  tp = TMP_ALLOC_LIMBS (tn);\n\n  rbitpos = 0;\n  while (rbitpos + chunk_nbits <= nbits)\n    {\n      mp_ptr r2p = rp + rbitpos / GMP_NUMB_BITS;\n\n      if (rbitpos % GMP_NUMB_BITS != 0)\n\t{\n\t  mp_limb_t savelimb, rcy;\n\t  /* Target of new chunk is not bit aligned.  Use temp space\n\t     and align things by shifting it up.  */\n\t  lc (tp, rstate);\n\t  savelimb = r2p[0];\n\t  rcy = mpn_lshift (r2p, tp, tn, rbitpos % GMP_NUMB_BITS);\n\t  r2p[0] |= savelimb;\n\t  /* bogus */\n\t  if ((chunk_nbits % GMP_NUMB_BITS + rbitpos % GMP_NUMB_BITS)\n\t      > GMP_NUMB_BITS)\n\t    r2p[tn] = rcy;\n\t}\n      else\n\t{\n\t  /* Target of new chunk is bit aligned.  Let `lc' put bits\n\t     directly into our target variable.  */\n\t  lc (r2p, rstate);\n\t}\n      rbitpos += chunk_nbits;\n    }\n\n  /* Handle last [0..chunk_nbits) bits.  */\n  if (rbitpos != nbits)\n    {\n      mp_ptr r2p = rp + rbitpos / GMP_NUMB_BITS;\n      int last_nbits = nbits - rbitpos;\n      tn = BITS_TO_LIMBS (last_nbits);\n      lc (tp, rstate);\n      if (rbitpos % GMP_NUMB_BITS != 0)\n\t{\n\t  mp_limb_t savelimb, rcy;\n\t  /* Target of new chunk is not bit aligned.  Use temp space\n\t     and align things by shifting it up.  */\n\t  savelimb = r2p[0];\n\t  rcy = mpn_lshift (r2p, tp, tn, rbitpos % GMP_NUMB_BITS);\n\t  r2p[0] |= savelimb;\n\t  if (rbitpos + tn * GMP_NUMB_BITS - rbitpos % GMP_NUMB_BITS < nbits)\n\t    r2p[tn] = rcy;\n\t}\n      else\n\t{\n\t  MPN_COPY (r2p, tp, tn);\n\t}\n      /* Mask off top bits if needed.  */\n      if (nbits % GMP_NUMB_BITS != 0)\n\trp[nbits / GMP_NUMB_BITS]\n\t  &= ~(~CNST_LIMB (0) << nbits % GMP_NUMB_BITS);\n    }\n\n  TMP_FREE;\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "randseed_lc": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "static void\nrandseed_lc (gmp_randstate_t rstate, mpz_srcptr seed)\n{\n  gmp_rand_lc_struct *p = (gmp_rand_lc_struct *) RNG_STATE (rstate);\n  mpz_ptr seedz = p->_mp_seed;\n  mp_size_t seedn = BITS_TO_LIMBS (p->_mp_m2exp);\n\n  /* Store p->_mp_seed as an unnormalized integer with size enough\n     for numbers up to 2^m2exp-1.  That size can't be zero.  */\n  mpz_fdiv_r_2exp (seedz, seed, p->_mp_m2exp);\n  MPN_ZERO (&PTR (seedz)[SIZ (seedz)], seedn - SIZ (seedz));\n  SIZ (seedz) = seedn;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "randclear_lc": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static void\nrandclear_lc (gmp_randstate_t rstate)\n{\n  gmp_rand_lc_struct *p = (gmp_rand_lc_struct *) RNG_STATE (rstate);\n\n  mpz_clear (p->_mp_seed);\n  mpz_clear (p->_mp_a);\n  (*__gmp_free_func) (p, sizeof (gmp_rand_lc_struct));\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "randiset_lc": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static void\nrandiset_lc (gmp_randstate_ptr dst, gmp_randstate_srcptr src)\n{\n  gmp_rand_lc_struct *dstp, *srcp;\n\n  srcp = (gmp_rand_lc_struct *) RNG_STATE (src);\n  dstp = (gmp_rand_lc_struct *) (*__gmp_allocate_func) (sizeof (gmp_rand_lc_struct));\n\n  RNG_STATE (dst) = (mp_limb_t *) (void *) dstp;\n  RNG_FNPTR (dst) = (void *) &Linear_Congruential_Generator;\n\n  /* _mp_seed and _mp_a might be unnormalized (high zero limbs), but\n     mpz_init_set won't worry about that */\n  mpz_init_set (dstp->_mp_seed, srcp->_mp_seed);\n  mpz_init_set (dstp->_mp_a,    srcp->_mp_a);\n\n  dstp->_cn = srcp->_cn;\n\n  dstp->_cp[0] = srcp->_cp[0];\n  if (LIMBS_PER_ULONG > 1)\n    dstp->_cp[1] = srcp->_cp[1];\n  if (LIMBS_PER_ULONG > 2)  /* usually there's only 1 or 2 */\n    MPN_COPY (dstp->_cp + 2, srcp->_cp + 2, LIMBS_PER_ULONG - 2);\n\n  dstp->_mp_m2exp = srcp->_mp_m2exp;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gmp_randinit_lc_2exp": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "void\ngmp_randinit_lc_2exp (gmp_randstate_t rstate,\n\t\t      mpz_srcptr a,\n\t\t      unsigned long int c,\n\t\t      mp_bitcnt_t m2exp)\n{\n  gmp_rand_lc_struct *p;\n  mp_size_t seedn = BITS_TO_LIMBS (m2exp);\n\n  ASSERT_ALWAYS (m2exp != 0);\n\n  p = __GMP_ALLOCATE_FUNC_TYPE (1, gmp_rand_lc_struct);\n  RNG_STATE (rstate) = (mp_limb_t *) (void *) p;\n  RNG_FNPTR (rstate) = (void *) &Linear_Congruential_Generator;\n\n  /* allocate m2exp bits of space for p->_mp_seed, and initial seed \"1\" */\n  mpz_init2 (p->_mp_seed, m2exp);\n  MPN_ZERO (PTR (p->_mp_seed), seedn);\n  SIZ (p->_mp_seed) = seedn;\n  PTR (p->_mp_seed)[0] = 1;\n\n  /* \"a\", forced to 0 to 2^m2exp-1 */\n  mpz_init (p->_mp_a);\n  mpz_fdiv_r_2exp (p->_mp_a, a, m2exp);\n\n  /* Avoid SIZ(a) == 0 to avoid checking for special case in lc().  */\n  if (SIZ (p->_mp_a) == 0)\n    {\n      SIZ (p->_mp_a) = 1;\n      PTR (p->_mp_a)[0] = CNST_LIMB (0);\n    }\n\n  MPN_SET_UI (p->_cp, p->_cn, c);\n\n  /* Internally we may discard any bits of c above m2exp.  The following\n     code ensures that __GMPN_ADD in lc() will always work.  */\n  if (seedn < p->_cn)\n    p->_cn = (p->_cp[0] != 0);\n\n  p->_mp_m2exp = m2exp;\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/randmt.c": {
    "__gmp_mt_recalc_buffer": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "void\n__gmp_mt_recalc_buffer (gmp_uint_least32_t mt[])\n{\n  gmp_uint_least32_t y;\n  int kk;\n\n  for (kk = 0; kk < N - M; kk++)\n    {\n      y = (mt[kk] & 0x80000000) | (mt[kk + 1] & 0x7FFFFFFF);\n      mt[kk] = mt[kk + M] ^ (y >> 1) ^ ((y & 0x01) != 0 ? MATRIX_A : 0);\n    }\n  for (; kk < N - 1; kk++)\n    {\n      y = (mt[kk] & 0x80000000) | (mt[kk + 1] & 0x7FFFFFFF);\n      mt[kk] = mt[kk - (N - M)] ^ (y >> 1) ^ ((y & 0x01) != 0 ? MATRIX_A : 0);\n    }\n\n  y = (mt[N - 1] & 0x80000000) | (mt[0] & 0x7FFFFFFF);\n  mt[N - 1] = mt[M - 1] ^ (y >> 1) ^ ((y & 0x01) != 0 ? MATRIX_A : 0);\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "__gmp_randget_mt": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "void\n__gmp_randget_mt (gmp_randstate_t rstate, mp_ptr dest, unsigned long int nbits)\n{\n  gmp_uint_least32_t y;\n  int rbits;\n  mp_size_t i;\n  mp_size_t nlimbs;\n  int *pmti;\n  gmp_uint_least32_t *mt;\n\n  pmti = &((gmp_rand_mt_struct *) RNG_STATE (rstate))->mti;\n  mt = ((gmp_rand_mt_struct *) RNG_STATE (rstate))->mt;\n\n  nlimbs = nbits / GMP_NUMB_BITS;\n  rbits = nbits % GMP_NUMB_BITS;\n\n#define NEXT_RANDOM\t\t\t\\\n  do\t\t\t\t\t\\\n    {\t\t\t\t\t\\\n      if (*pmti >= N)\t\t\t\\\n\t{\t\t\t\t\\\n\t  __gmp_mt_recalc_buffer (mt);  \\\n\t  *pmti = 0;\t\t\t\\\n\t}\t\t\t\t\\\n      y = mt[(*pmti)++];\t\t\\\n      y ^= (y >> 11);\t\t\t\\\n      y ^= (y << 7) & MASK_1;\t\t\\\n      y ^= (y << 15) & MASK_2;\t\t\\\n      y ^= (y >> 18);\t\t\t\\\n    }\t\t\t\t\t\\\n  while (0)\n\n\n  /* Handle the common cases of 32- or 64-bit limbs with fast,\n     optimized routines, and the rest of cases with a general\n     routine.  In all cases, no more than 31 bits are rejected\n     for the last limb so that every version of the code is\n     consistent with the others.  */\n\n#if (GMP_NUMB_BITS == 32)\n\n  for (i = 0; i < nlimbs; i++)\n    {\n      NEXT_RANDOM;\n      dest[i] = (mp_limb_t) y;\n    }\n  if (rbits)\n    {\n      NEXT_RANDOM;\n      dest[nlimbs] = (mp_limb_t) (y & ~(ULONG_MAX << rbits));\n    }\n\n#else /* GMP_NUMB_BITS != 32 */\n#if (GMP_NUMB_BITS == 64)\n\n  for (i = 0; i < nlimbs; i++)\n    {\n      NEXT_RANDOM;\n      dest[i] = (mp_limb_t) y;\n      NEXT_RANDOM;\n      dest[i] |= (mp_limb_t) y << 32;\n    }\n  if (rbits)\n    {\n      if (rbits < 32)\n\t{\n\t  NEXT_RANDOM;\n\t  dest[nlimbs] = (mp_limb_t) (y & ~(ULONG_MAX << rbits));\n\t}\n      else\n\t{\n\t  NEXT_RANDOM;\n\t  dest[nlimbs] = (mp_limb_t) y;\n\t  if (rbits > 32)\n\t    {\n\t      NEXT_RANDOM;\n\t      dest[nlimbs] |=\n\t\t((mp_limb_t) (y & ~(ULONG_MAX << (rbits-32)))) << 32;\n\t    }\n\t}\n    }\n\n#else /* GMP_NUMB_BITS != 64 */\n\n  {\n    /* Fall back to a general algorithm.  This algorithm works by\n       keeping a pool of up to 64 bits (2 outputs from MT) acting\n       as a shift register from which bits are consumed as needed.\n       Bits are consumed using the LSB bits of bitpool_l, and\n       inserted via bitpool_h and shifted to the right place.  */\n\n    gmp_uint_least32_t bitpool_h = 0;\n    gmp_uint_least32_t bitpool_l = 0;\n    int bits_in_pool = 0;\t/* Holds number of valid bits in the pool.  */\n    int bits_to_fill;\t\t/* Holds total number of bits to put in\n\t\t\t\t   destination.  */\n    int bitidx;\t\t\t/* Holds the destination bit position.  */\n    mp_size_t nlimbs2;\t\t/* Number of whole+partial limbs to fill.  */\n\n    nlimbs2 = nlimbs + (rbits != 0);\n\n    for (i = 0; i < nlimbs2; i++)\n      {\n\tbitidx = 0;\n\tif (i < nlimbs)\n\t  bits_to_fill = GMP_NUMB_BITS;\n\telse\n\t  bits_to_fill = rbits;\n\n\tdest[i] = CNST_LIMB (0);\n\twhile (bits_to_fill >= 32) /* Process whole 32-bit blocks first.  */\n\t  {\n\t    if (bits_in_pool < 32)\t/* Need more bits.  */\n\t      {\n\t\t/* 64-bit right shift.  */\n\t\tNEXT_RANDOM;\n\t\tbitpool_h = y;\n\t\tbitpool_l |= (bitpool_h << bits_in_pool) & 0xFFFFFFFF;\n\t\tif (bits_in_pool == 0)\n\t\t  bitpool_h = 0;\n\t\telse\n\t\t  bitpool_h >>= 32 - bits_in_pool;\n\t\tbits_in_pool += 32;\t/* We've got 32 more bits.  */\n\t      }\n\n\t    /* Fill a 32-bit chunk.  */\n\t    dest[i] |= ((mp_limb_t) bitpool_l) << bitidx;\n\t    bitpool_l = bitpool_h;\n\t    bits_in_pool -= 32;\n\t    bits_to_fill -= 32;\n\t    bitidx += 32;\n\t  }\n\n\t/* Cover the case where GMP_NUMB_BITS is not a multiple of 32.  */\n\tif (bits_to_fill != 0)\n\t  {\n\t    if (bits_in_pool < bits_to_fill)\n\t      {\n\t\tNEXT_RANDOM;\n\t\tbitpool_h = y;\n\t\tbitpool_l |= (bitpool_h << bits_in_pool) & 0xFFFFFFFF;\n\t\tif (bits_in_pool == 0)\n\t\t  bitpool_h = 0;\n\t\telse\n\t\t  bitpool_h >>= 32 - bits_in_pool;\n\t\tbits_in_pool += 32;\n\t      }\n\n\t    dest[i] |= (((mp_limb_t) bitpool_l\n\t\t\t & ~(~CNST_LIMB (0) << bits_to_fill))\n\t\t\t<< bitidx);\n\t    bitpool_l = ((bitpool_l >> bits_to_fill)\n\t\t\t | (bitpool_h << (32 - bits_to_fill))) & 0xFFFFFFFF;\n\t    bitpool_h >>= bits_to_fill;\n\t    bits_in_pool -= bits_to_fill;\n\t  }\n      }\n  }\n\n#endif /* GMP_NUMB_BITS != 64 */\n#endif /* GMP_NUMB_BITS != 32 */\n}",
      "lines": 162,
      "depth": 24,
      "decorators": [
        "void"
      ]
    },
    "__gmp_randclear_mt": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "void\n__gmp_randclear_mt (gmp_randstate_t rstate)\n{\n  (*__gmp_free_func) ((void *) RNG_STATE (rstate),\n\t\t      ALLOC (rstate->_mp_seed) * GMP_LIMB_BYTES);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "__gmp_randiset_mt": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "void\n__gmp_randiset_mt (gmp_randstate_ptr dst, gmp_randstate_srcptr src)\n{\n  const mp_size_t sz = ((sizeof (gmp_rand_mt_struct) - 1) / GMP_LIMB_BYTES) + 1;\n  gmp_rand_mt_struct *dstp, *srcp;\n  mp_size_t i;\n\n  /* Set the generator functions.  */\n  RNG_FNPTR (dst) = (void *) &Mersenne_Twister_Generator_Noseed;\n\n  /* Allocate the MT-specific state.  */\n  dstp = (gmp_rand_mt_struct *) __GMP_ALLOCATE_FUNC_LIMBS (sz);\n  RNG_STATE (dst) = (mp_ptr) dstp;\n  ALLOC (dst->_mp_seed) = sz;     /* Initialize alloc field to placate Camm.  */\n\n  /* Copy state.  */\n  srcp = (gmp_rand_mt_struct *) RNG_STATE (src);\n  for (i = 0; i < N; i++)\n    dstp->mt[i] = srcp->mt[i];\n\n  dstp->mti = srcp->mti;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "__gmp_randinit_mt_noseed": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "void\n__gmp_randinit_mt_noseed (gmp_randstate_ptr dst)\n{\n  const mp_size_t sz = ((sizeof (gmp_rand_mt_struct) - 1) / GMP_LIMB_BYTES) + 1;\n  gmp_rand_mt_struct *dstp;\n  mp_size_t i;\n\n  /* Set the generator functions.  */\n  RNG_FNPTR (dst) = (void *) &Mersenne_Twister_Generator_Noseed;\n\n  /* Allocate the MT-specific state.  */\n  dstp = (gmp_rand_mt_struct *) __GMP_ALLOCATE_FUNC_LIMBS (sz);\n  RNG_STATE (dst) = (mp_ptr) dstp;\n  ALLOC (dst->_mp_seed) = sz;     /* Initialize alloc field to placate Camm.  */\n\n  /* Set state for default seed.  */\n  for (i = 0; i < N; i++)\n    dstp->mt[i] = default_state[i];\n\n  dstp->mti = WARM_UP % N;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/randmt.h": {},
  "gmp/gmp-6.1.2/rand/randmts.c": {
    "mangle_seed": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static void\nmangle_seed (mpz_ptr r)\n{\n  mpz_t          t, b;\n  unsigned long  e = 0x40118124;\n  unsigned long  bit = 0x20000000;\n\n  mpz_init2 (t, 19937L);\n  mpz_init_set (b, r);\n\n  do\n    {\n      mpz_mul (r, r, r);\n\n    reduce:\n      for (;;)\n        {\n          mpz_tdiv_q_2exp (t, r, 19937L);\n          if (SIZ (t) == 0)\n            break;\n          mpz_tdiv_r_2exp (r, r, 19937L);\n          mpz_addmul_ui (r, t, 20023L);\n        }\n\n      if ((e & bit) != 0)\n        {\n          e ^= bit;\n          mpz_mul (r, r, b);\n          goto reduce;\n        }\n\n      bit >>= 1;\n    }\n  while (bit != 0);\n\n  mpz_clear (t);\n  mpz_clear (b);\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "randseed_mt": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static void\nrandseed_mt (gmp_randstate_t rstate, mpz_srcptr seed)\n{\n  int i;\n  size_t cnt;\n\n  gmp_rand_mt_struct *p;\n  mpz_t mod;    /* Modulus.  */\n  mpz_t seed1;  /* Intermediate result.  */\n\n  p = (gmp_rand_mt_struct *) RNG_STATE (rstate);\n\n  mpz_init2 (mod, 19938L);\n  mpz_init2 (seed1, 19937L);\n\n  mpz_setbit (mod, 19937L);\n  mpz_sub_ui (mod, mod, 20027L);\n  mpz_mod (seed1, seed, mod);\t/* Reduce `seed' modulo `mod'.  */\n  mpz_clear (mod);\n  mpz_add_ui (seed1, seed1, 2L);\t/* seed1 is now ready.  */\n  mangle_seed (seed1);\t/* Perform the mangling by powering.  */\n\n  /* Copy the last bit into bit 31 of mt[0] and clear it.  */\n  p->mt[0] = (mpz_tstbit (seed1, 19936L) != 0) ? 0x80000000 : 0;\n  mpz_clrbit (seed1, 19936L);\n\n  /* Split seed1 into N-1 32-bit chunks.  */\n  mpz_export (&p->mt[1], &cnt, -1, sizeof (p->mt[1]), 0,\n              8 * sizeof (p->mt[1]) - 32, seed1);\n  mpz_clear (seed1);\n  cnt++;\n  ASSERT (cnt <= N);\n  while (cnt < N)\n    p->mt[cnt++] = 0;\n\n  /* Warm the generator up if necessary.  */\n  if (WARM_UP != 0)\n    for (i = 0; i < WARM_UP / N; i++)\n      __gmp_mt_recalc_buffer (p->mt);\n\n  p->mti = WARM_UP % N;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gmp_randinit_mt": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\ngmp_randinit_mt (gmp_randstate_t rstate)\n{\n  __gmp_randinit_mt_noseed (rstate);\n  RNG_FNPTR (rstate) = (void *) &Mersenne_Twister_Generator;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/randmui.c": {
    "gmp_urandomm_ui": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "unsigned long\ngmp_urandomm_ui (gmp_randstate_ptr rstate, unsigned long n)\n{\n  mp_limb_t      a[LIMBS_PER_ULONG];\n  unsigned long  ret, bits, leading;\n  int            i;\n\n  if (UNLIKELY (n == 0))\n    DIVIDE_BY_ZERO;\n\n  /* start with zeros, since if bits==0 then _gmp_rand will store nothing at\n     all (bits==0 arises when n==1), or if bits <= GMP_NUMB_BITS then it\n     will store only a[0].  */\n  a[0] = 0;\n#if LIMBS_PER_ULONG > 1\n  a[1] = 0;\n#endif\n\n  count_leading_zeros (leading, (mp_limb_t) n);\n  bits = GMP_LIMB_BITS - leading - (POW2_P(n) != 0);\n\n  for (i = 0; i < MAX_URANDOMM_ITER; i++)\n    {\n      _gmp_rand (a, rstate, bits);\n#if LIMBS_PER_ULONG == 1\n      ret = a[0];\n#else\n      ret = a[0] | (a[1] << GMP_NUMB_BITS);\n#endif\n      if (LIKELY (ret < n))   /* usually one iteration suffices */\n        goto done;\n    }\n\n  /* Too many iterations, there must be something degenerate about the\n     rstate algorithm.  Return r%n.  */\n  ret -= n;\n  ASSERT (ret < n);\n\n done:\n  return ret;\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/rands.c": {},
  "gmp/gmp-6.1.2/rand/randsd.c": {
    "gmp_randseed": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\ngmp_randseed (gmp_randstate_t rstate,\n\t      mpz_srcptr seed)\n{\n  (*((gmp_randfnptr_t *) RNG_FNPTR (rstate))->randseed_fn) (rstate, seed);\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/rand/randsdui.c": {
    "gmp_randseed_ui": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\ngmp_randseed_ui (gmp_randstate_t rstate,\n                 unsigned long int seed)\n{\n  mpz_t zseed;\n  mp_limb_t zlimbs[LIMBS_PER_ULONG];\n\n  MPZ_FAKE_UI (zseed, zlimbs, seed);\n  gmp_randseed (rstate, zseed);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/scanf/doscan.c": {
    "gmpscan": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "static int\ngmpscan (const struct gmp_doscan_funs_t *funs, void *data,\n\t const struct gmp_doscan_params_t *p, void *dst)\n{\n  int\t  chars, c, base, first, width, seen_point, seen_digit, hexfloat;\n  size_t  s_upto, s_alloc, hexexp;\n  char\t  *s;\n  int\t  invalid = 0;\n\n  TRACE (printf (\"gmpscan\\n\"));\n\n  ASSERT (p->type == 'F' || p->type == 'Q' || p->type == 'Z');\n\n  c = (*funs->get) (data);\n  if (c == EOF)\n    return -2;\n\n  chars = 1;\n  first = 1;\n  seen_point = 0;\n  width = (p->width == 0 ? INT_MAX-1 : p->width);\n  base = p->base;\n  s_alloc = S_ALLOC_STEP;\n  s = __GMP_ALLOCATE_FUNC_TYPE (s_alloc, char);\n  s_upto = 0;\n  hexfloat = 0;\n  hexexp = 0;\n\n another:\n  seen_digit = 0;\n  if (c == '-')\n    {\n      STORE (c);\n      goto get_for_sign;\n    }\n  else if (c == '+')\n    {\n      /* don't store '+', it's not accepted by mpz_set_str etc */\n    get_for_sign:\n      GET (c);\n    }\n\n  if (base == 0)\n    {\n      base = 10;\t\t  /* decimal if no base indicator */\n      if (c == '0')\n\t{\n\t  seen_digit = 1;\t  /* 0 alone is a valid number */\n\t  if (p->type != 'F')\n\t    base = 8;\t\t  /* leading 0 is octal, for non-floats */\n\t  STORE (c);\n\t  GET (c);\n\t  if (c == 'x' || c == 'X')\n\t    {\n\t      base = 16;\n\t      seen_digit = 0;\t  /* must have digits after an 0x */\n\t      if (p->type == 'F') /* don't pass 'x' to mpf_set_str_point */\n\t\thexfloat = 1;\n\t      else\n\t\tSTORE (c);\n\t      GET (c);\n\t    }\n\t}\n    }\n\n digits:\n  for (;;)\n    {\n      if (base == 16)\n\t{\n\t  if (! isxdigit (c))\n\t    break;\n\t}\n      else\n\t{\n\t  if (! isdigit (c))\n\t    break;\n\t  if (base == 8 && (c == '8' || c == '9'))\n\t    break;\n\t}\n\n      seen_digit = 1;\n      STORE (c);\n      GET (c);\n    }\n\n  if (first)\n    {\n      /* decimal point */\n      if (p->type == 'F' && ! seen_point)\n\t{\n\t  /* For a multi-character decimal point, if the first character is\n\t     present then all of it must be, otherwise the input is\n\t     considered invalid.  */\n\t  const char  *point = GMP_DECIMAL_POINT;\n\t  int\t      pc = (unsigned char) *point++;\n\t  if (c == pc)\n\t    {\n\t      for (;;)\n\t\t{\n\t\t  STORE (c);\n\t\t  GET (c);\n\t\t  pc = (unsigned char) *point++;\n\t\t  if (pc == '\\0')\n\t\t    break;\n\t\t  if (c != pc)\n\t\t    goto set_invalid;\n\t\t}\n\t      seen_point = 1;\n\t      goto digits;\n\t    }\n\t}\n\n      /* exponent */\n      if (p->type == 'F')\n\t{\n\t  if (hexfloat && (c == 'p' || c == 'P'))\n\t    {\n\t      hexexp = s_upto; /* exponent location */\n\t      base = 10;       /* exponent in decimal */\n\t      goto exponent;\n\t    }\n\t  else if (! hexfloat && (c == 'e' || c == 'E'))\n\t    {\n\t    exponent:\n\t      /* must have at least one digit in the mantissa, just an exponent\n\t\t is not good enough */\n\t      if (! seen_digit)\n\t\tgoto set_invalid;\n\n\t    do_second:\n\t      first = 0;\n\t      STORE (c);\n\t      GET (c);\n\t      goto another;\n\t    }\n\t}\n\n      /* denominator */\n      if (p->type == 'Q' && c == '/')\n\t{\n\t  /* must have at least one digit in the numerator */\n\t  if (! seen_digit)\n\t    goto set_invalid;\n\n\t  /* now look for at least one digit in the denominator */\n\t  seen_digit = 0;\n\n\t  /* allow the base to be redetermined for \"%i\" */\n\t  base = p->base;\n\t  goto do_second;\n\t}\n    }\n\n convert:\n  if (! seen_digit)\n    {\n    set_invalid:\n      invalid = 1;\n      goto done;\n    }\n\n  if (! p->ignore)\n    {\n      STORE ('\\0');\n      TRACE (printf (\"\tconvert \\\"%s\\\"\\n\", s));\n\n      /* We ought to have parsed out a valid string above, so just test\n\t mpz_set_str etc with an ASSERT.  */\n      switch (p->type) {\n      case 'F':\n\t{\n\t  mpf_ptr  f = (mpf_ptr) dst;\n\t  if (hexexp != 0)\n\t    s[hexexp] = '\\0';\n\t  ASSERT_NOCARRY (mpf_set_str (f, s, hexfloat ? 16 : 10));\n\t  if (hexexp != 0)\n\t    {\n\t      char *dummy;\n\t      long  exp;\n\t      exp = strtol (s + hexexp + 1, &dummy, 10);\n\t      if (exp >= 0)\n\t\tmpf_mul_2exp (f, f, (unsigned long) exp);\n\t      else\n\t\tmpf_div_2exp (f, f, - (unsigned long) exp);\n\t    }\n\t}\n\tbreak;\n      case 'Q':\n\tASSERT_NOCARRY (mpq_set_str ((mpq_ptr) dst, s, p->base));\n\tbreak;\n      case 'Z':\n\tASSERT_NOCARRY (mpz_set_str ((mpz_ptr) dst, s, p->base));\n\tbreak;\n      default:\n\tASSERT (0);\n\t/*FALLTHRU*/\n\tbreak;\n      }\n    }\n\n done:\n  ASSERT (chars <= width+1);\n  if (chars != width+1)\n    {\n      (*funs->unget) (c, data);\n      TRACE (printf (\"\tungetc %d, to give %d chars\\n\", c, chars-1));\n    }\n  chars--;\n\n  (*__gmp_free_func) (s, s_alloc);\n\n  if (invalid)\n    {\n      TRACE (printf (\"\tinvalid\\n\"));\n      return -1;\n    }\n\n  TRACE (printf (\"  return %d chars (cf width %d)\\n\", chars, width));\n  return chars;\n}",
      "lines": 221,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "skip_white": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        464,
        1
      ],
      "content": "static int\nskip_white (const struct gmp_doscan_funs_t *funs, void *data)\n{\n  int  c;\n  int  ret = 0;\n\n  do\n    {\n      c = (funs->get) (data);\n      ret++;\n    }\n  while (isspace (c));\n\n  (funs->unget) (c, data);\n  ret--;\n\n  TRACE (printf (\"  skip white %d\\n\", ret));\n  return ret;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__gmp_doscan": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        767,
        1
      ],
      "content": "int\n__gmp_doscan (const struct gmp_doscan_funs_t *funs, void *data,\n\t      const char *orig_fmt, va_list orig_ap)\n{\n  struct gmp_doscan_params_t  param;\n  va_list     ap;\n  char\t      *alloc_fmt;\n  const char  *fmt, *this_fmt, *end_fmt;\n  size_t      orig_fmt_len, alloc_fmt_size, len;\n  int\t      new_fields, new_chars;\n  char\t      fchar;\n  int\t      fields = 0;\n  int\t      chars = 0;\n\n  TRACE (printf (\"__gmp_doscan \\\"%s\\\"\\n\", orig_fmt);\n\t if (funs->scan == (gmp_doscan_scan_t) sscanf)\n\t   printf (\"  s=\\\"%s\\\"\\n\", * (const char **) data));\n\n  /* Don't modify orig_ap, if va_list is actually an array and hence call by\n     reference.  It could be argued that it'd be more efficient to leave\n     callers to make a copy if they care, but doing so here is going to be a\n     very small part of the total work, and we may as well keep applications\n     out of trouble.  */\n  va_copy (ap, orig_ap);\n\n  /* Parts of the format string are going to be copied so that a \" %n\" can\n     be appended.  alloc_fmt is some space for that.  orig_fmt_len+4 will be\n     needed if fmt consists of a single \"%\" specifier, but otherwise is an\n     overestimate.  We're not going to be very fast here, so use\n     __gmp_allocate_func rather than TMP_ALLOC.  */\n  orig_fmt_len = strlen (orig_fmt);\n  alloc_fmt_size = orig_fmt_len + 4;\n  alloc_fmt = __GMP_ALLOCATE_FUNC_TYPE (alloc_fmt_size, char);\n\n  fmt = orig_fmt;\n  end_fmt = orig_fmt + orig_fmt_len;\n\n  for (;;)\n    {\n    next:\n      fchar = *fmt++;\n\n      if (fchar == '\\0')\n\tbreak;\n\n      if (isspace (fchar))\n\t{\n\t  chars += skip_white (funs, data);\n\t  continue;\n\t}\n\n      if (fchar != '%')\n\t{\n\t  int  c;\n\tliteral:\n\t  c = (funs->get) (data);\n\t  if (c != fchar)\n\t    {\n\t      (funs->unget) (c, data);\n\t      if (c == EOF)\n\t\t{\n\t\teof_no_match:\n\t\t  if (fields == 0)\n\t\t    fields = EOF;\n\t\t}\n\t      goto done;\n\t    }\n\t  chars++;\n\t  continue;\n\t}\n\n      param.type = '\\0';\n      param.base = 0;\t /* for e,f,g,i */\n      param.ignore = 0;\n      param.width = 0;\n\n      this_fmt = fmt-1;\n      TRACE (printf (\"\tthis_fmt \\\"%s\\\"\\n\", this_fmt));\n\n      for (;;)\n\t{\n\t  ASSERT (fmt <= end_fmt);\n\n\t  fchar = *fmt++;\n\t  switch (fchar) {\n\n\t  case '\\0':  /* unterminated % sequence */\n\t    ASSERT (0);\n\t    goto done;\n\n\t  case '%':   /* literal % */\n\t    goto literal;\n\n\t  case '[':   /* character range */\n\t    fchar = *fmt++;\n\t    if (fchar == '^')\n\t      fchar = *fmt++;\n\t    /* ']' allowed as the first char (possibly after '^') */\n\t    if (fchar == ']')\n\t      fchar = *fmt++;\n\t    for (;;)\n\t      {\n\t\tASSERT (fmt <= end_fmt);\n\t\tif (fchar == '\\0')\n\t\t  {\n\t\t    /* unterminated % sequence */\n\t\t    ASSERT (0);\n\t\t    goto done;\n\t\t  }\n\t\tif (fchar == ']')\n\t\t  break;\n\t\tfchar = *fmt++;\n\t      }\n\t    /*FALLTHRU*/\n\t  case 'c':   /* characters */\n\t  case 's':   /* string of non-whitespace */\n\t  case 'p':   /* pointer */\n\t  libc_type:\n\t    len = fmt - this_fmt;\n\t    memcpy (alloc_fmt, this_fmt, len);\n\t    alloc_fmt[len++] = '%';\n\t    alloc_fmt[len++] = 'n';\n\t    alloc_fmt[len] = '\\0';\n\n\t    TRACE (printf (\"  scan \\\"%s\\\"\\n\", alloc_fmt);\n\t\t   if (funs->scan == (gmp_doscan_scan_t) sscanf)\n\t\t     printf (\"\ts=\\\"%s\\\"\\n\", * (const char **) data));\n\n\t    new_chars = -1;\n\t    if (param.ignore)\n\t      {\n\t\tnew_fields = (*funs->scan) (data, alloc_fmt, &new_chars, NULL);\n\t\tASSERT (new_fields == 0 || new_fields == EOF);\n\t      }\n\t    else\n\t      {\n\t\tvoid *arg = va_arg (ap, void *);\n\t\tnew_fields = (*funs->scan) (data, alloc_fmt, arg, &new_chars);\n\t\tASSERT (new_fields==0 || new_fields==1 || new_fields==EOF);\n\n\t\tif (new_fields == 0)\n\t\t  goto done;  /* invalid input */\n\n\t\tif (new_fields == 1)\n\t\t  ASSERT (new_chars != -1);\n\t      }\n\t    TRACE (printf (\"  new_fields %d   new_chars %d\\n\",\n\t\t\t   new_fields, new_chars));\n\n\t    if (new_fields == -1)\n\t      goto eof_no_match;  /* EOF before anything matched */\n\n\t    /* Under param.ignore, when new_fields==0 we don't know if\n\t       it's a successful match or an invalid field.  new_chars\n\t       won't have been assigned if it was an invalid field.  */\n\t    if (new_chars == -1)\n\t      goto done;  /* invalid input */\n\n\t    chars += new_chars;\n\t    (*funs->step) (data, new_chars);\n\n\t  increment_fields:\n\t    if (! param.ignore)\n\t      fields++;\n\t    goto next;\n\n\t  case 'd':   /* decimal */\n\t  case 'u':   /* decimal */\n\t    param.base = 10;\n\t    goto numeric;\n\n\t  case 'e':   /* float */\n\t  case 'E':   /* float */\n\t  case 'f':   /* float */\n\t  case 'g':   /* float */\n\t  case 'G':   /* float */\n\t  case 'i':   /* integer with base marker */\n\t  numeric:\n\t    if (param.type != 'F' && param.type != 'Q' && param.type != 'Z')\n\t      goto libc_type;\n\n\t    chars += skip_white (funs, data);\n\n\t    new_chars = gmpscan (funs, data, &param,\n\t\t\t\t param.ignore ? NULL : va_arg (ap, void*));\n\t    if (new_chars == -2)\n\t      goto eof_no_match;\n\t    if (new_chars == -1)\n\t      goto done;\n\n\t    ASSERT (new_chars >= 0);\n\t    chars += new_chars;\n\t    goto increment_fields;\n\n\t  case 'a':   /* glibc allocate string */\n\t  case '\\'':  /* glibc digit groupings */\n\t    break;\n\n\t  case 'F':   /* mpf_t */\n\t  case 'j':   /* intmax_t */\n\t  case 'L':   /* long long */\n\t  case 'q':   /* quad_t */\n\t  case 'Q':   /* mpq_t */\n\t  case 't':   /* ptrdiff_t */\n\t  case 'z':   /* size_t */\n\t  case 'Z':   /* mpz_t */\n\t  set_type:\n\t    param.type = fchar;\n\t    break;\n\n\t  case 'h':   /* short or char */\n\t    if (param.type != 'h')\n\t      goto set_type;\n\t    param.type = 'H';\t/* internal code for \"hh\" */\n\t    break;\n\n\t    goto numeric;\n\n\t  case 'l':   /* long, long long, double or long double */\n\t    if (param.type != 'l')\n\t      goto set_type;\n\t    param.type = 'L';\t/* \"ll\" means \"L\" */\n\t    break;\n\n\t  case 'n':\n\t    if (! param.ignore)\n\t      {\n\t\tvoid  *p;\n\t\tp = va_arg (ap, void *);\n\t\tTRACE (printf (\"  store %%n to %p\\n\", p));\n\t\tswitch (param.type) {\n\t\tcase '\\0': * (int\t*) p = chars; break;\n\t\tcase 'F':  mpf_set_si ((mpf_ptr) p, (long) chars); break;\n\t\tcase 'H':  * (char\t*) p = chars; break;\n\t\tcase 'h':  * (short\t*) p = chars; break;\n#if HAVE_INTMAX_T\n\t\tcase 'j':  * (intmax_t\t*) p = chars; break;\n#else\n\t\tcase 'j':  ASSERT_FAIL (intmax_t not available); break;\n#endif\n\t\tcase 'l':  * (long\t*) p = chars; break;\n#if HAVE_QUAD_T && HAVE_LONG_LONG\n\t\tcase 'q':\n\t\t  ASSERT_ALWAYS (sizeof (quad_t) == sizeof (long long));\n\t\t  /*FALLTHRU*/\n#else\n\t\tcase 'q':  ASSERT_FAIL (quad_t not available); break;\n#endif\n#if HAVE_LONG_LONG\n\t\tcase 'L':  * (long long *) p = chars; break;\n#else\n\t\tcase 'L':  ASSERT_FAIL (long long not available); break;\n#endif\n\t\tcase 'Q':  mpq_set_si ((mpq_ptr) p, (long) chars, 1L); break;\n#if HAVE_PTRDIFF_T\n\t\tcase 't':  * (ptrdiff_t *) p = chars; break;\n#else\n\t\tcase 't':  ASSERT_FAIL (ptrdiff_t not available); break;\n#endif\n\t\tcase 'z':  * (size_t\t*) p = chars; break;\n\t\tcase 'Z':  mpz_set_si ((mpz_ptr) p, (long) chars); break;\n\t\tdefault: ASSERT (0); break;\n\t\t}\n\t      }\n\t    goto next;\n\n\t  case 'o':\n\t    param.base = 8;\n\t    goto numeric;\n\n\t  case 'x':\n\t  case 'X':\n\t    param.base = 16;\n\t    goto numeric;\n\n\t  case '0': case '1': case '2': case '3': case '4':\n\t  case '5': case '6': case '7': case '8': case '9':\n\t    param.width = 0;\n\t    do {\n\t      param.width = param.width * 10 + (fchar-'0');\n\t      fchar = *fmt++;\n\t    } while (isdigit (fchar));\n\t    fmt--; /* unget the non-digit */\n\t    break;\n\n\t  case '*':\n\t    param.ignore = 1;\n\t    break;\n\n\t  default:\n\t    /* something invalid in a % sequence */\n\t    ASSERT (0);\n\t    goto next;\n\t  }\n\t}\n    }\n\n done:\n  (*__gmp_free_func) (alloc_fmt, alloc_fmt_size);\n  return fields;\n}",
      "lines": 301,
      "depth": 23,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/scanf/fscanf.c": {
    "gmp_fscanf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\ngmp_fscanf (FILE *fp, const char *fmt, ...)\n{\n  va_list  ap;\n  int      ret;\n  va_start (ap, fmt);\n\n  ret = __gmp_doscan (&__gmp_fscanf_funs, fp, fmt, ap);\n  va_end (ap);\n  return ret;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/scanf/fscanffuns.c": {
    "step": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\nstep (FILE *fp, int n)\n{\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/scanf/scanf.c": {
    "gmp_scanf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\ngmp_scanf (const char *fmt, ...)\n{\n  va_list  ap;\n  int      ret;\n  va_start (ap, fmt);\n\n  ret = __gmp_doscan (&__gmp_fscanf_funs, stdin, fmt, ap);\n  va_end (ap);\n  return ret;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/scanf/sscanf.c": {
    "gmp_sscanf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\ngmp_sscanf (const char *s, const char *fmt, ...)\n{\n  va_list  ap;\n  int      ret;\n  va_start (ap, fmt);\n\n#if SSCANF_WRITABLE_INPUT\n  /* let gmp_vsscanf handle the copying */\n  ret = gmp_vsscanf (s, fmt, ap);\n#else\n  ret = __gmp_doscan (&__gmp_sscanf_funs, (void *) &s, fmt, ap);\n#endif\n  va_end (ap);\n  return ret;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/scanf/sscanffuns.c": {
    "scan": [
      {
        "start_point": [
          41,
          0
        ],
        "end_point": [
          52,
          1
        ],
        "content": "static int\nscan (const char **sp, const char *fmt, ...)\n{\n    va_list ap;\n    int ret;\n\n    va_start(ap, fmt);\n    ret = vsscanf(*sp, fmt, ap);\n    va_end(ap);\n\n    return ret;\n}",
        "lines": 12,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          54,
          0
        ],
        "end_point": [
          70,
          1
        ],
        "content": "static int\nscan (const char **sp, const char *fmt, ...)\n{\n  va_list ap;\n  void *p1, *p2;\n  int ret;\n\n  va_start (ap, fmt);\n  p1 = va_arg (ap, void *);\n  p2 = va_arg (ap, void *);\n\n  ret = sscanf (*sp, fmt, p1, p2);\n\n  va_end (ap);\n\n  return ret;\n}",
        "lines": 17,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "step": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static void\nstep (const char **sp, int n)\n{\n  ASSERT (n >= 0);\n\n  /* shouldn't push us past the end of the string */\n#if WANT_ASSERT\n  {\n    int  i;\n    for (i = 0; i < n; i++)\n      ASSERT ((*sp)[i] != '\\0');\n  }\n#endif\n\n  (*sp) += n;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static int\nget (const char **sp)\n{\n  const char  *s;\n  int  c;\n  s = *sp;\n  c = (unsigned char) *s++;\n  if (c == '\\0')\n    return EOF;\n  *sp = s;\n  return c;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "unget": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static void\nunget (int c, const char **sp)\n{\n  const char  *s;\n  s = *sp;\n  if (c == EOF)\n    {\n      ASSERT (*s == '\\0');\n      return;\n    }\n  s--;\n  ASSERT ((unsigned char) *s == c);\n  *sp = s;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/scanf/vfscanf.c": {
    "gmp_vfscanf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\ngmp_vfscanf (FILE *fp, const char *fmt, va_list ap)\n{\n  return __gmp_doscan (&__gmp_fscanf_funs, fp, fmt, ap);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/scanf/vscanf.c": {
    "gmp_vscanf": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\ngmp_vscanf (const char *fmt, va_list ap)\n{\n  return __gmp_doscan (&__gmp_fscanf_funs, stdin, fmt, ap);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/scanf/vsscanf.c": {
    "gmp_vsscanf": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\ngmp_vsscanf (const char *s, const char *fmt, va_list ap)\n{\n#if SSCANF_WRITABLE_INPUT\n  /* We only actually need this if there's standard C types in fmt, and if\n     \"s\" is not already writable, but it's too much trouble to check that,\n     and in any case this writable sscanf input business is only for a few\n     old systems. */\n  size_t size;\n  char   *alloc;\n  int    ret;\n  size = strlen (s) + 1;\n  alloc = (char *) (*__gmp_allocate_func) (size);\n  memcpy (alloc, s, size);\n  s = alloc;\n  ret = __gmp_doscan (&__gmp_sscanf_funs, (void *) &s, fmt, ap);\n  (*__gmp_free_func) (alloc, size);\n  return ret;\n\n#else\n  return __gmp_doscan (&__gmp_sscanf_funs, (void *) &s, fmt, ap);\n#endif\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/amd64check.c": {
    "calling_conventions_check": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "int\ncalling_conventions_check (void)\n{\n  const char  *header = \"Violated calling conventions:\\n\";\n  int  ret = 1;\n  int i;\n\n#define CHECK(callreg, regstr, value)\t\t\t\\\n  if (callreg != value)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      printf (\"%s   %s\tgot 0x%016lX want 0x%016lX\\n\",\t\\\n\t      header, regstr, callreg, value);\t\t\\\n      header = \"\";\t\t\t\t\t\\\n      ret = 0;\t\t\t\t\t\t\\\n    }\n\n  for (i = 0; i < 6; i++)\n    {\n      CHECK (calling_conventions_values[VAL+i], regname[i], calling_conventions_values[WANT+i]);\n    }\n\n  if (DIR_BIT (calling_conventions_values[RFLAGS]) != 0)\n    {\n      printf (\"%s   rflags dir bit  got %d want 0\\n\",\n\t      header, DIR_BIT (calling_conventions_values[RFLAGS]));\n      header = \"\";\n      ret = 0;\n    }\n\n  if ((calling_conventions_fenv.tag & 0xFFFF) != 0xFFFF)\n    {\n      printf (\"%s   fpu tags  got 0x%X want 0xFFFF\\n\",\n\t      header, calling_conventions_fenv.tag & 0xFFFF);\n      header = \"\";\n      ret = 0;\n    }\n\n  return ret;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/arm32check.c": {
    "calling_conventions_check": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\ncalling_conventions_check (void)\n{\n  const char  *header = \"Violated calling conventions:\\n\";\n  int  ret = 1;\n  int i;\n\n#define CHECK(callreg, regnum, value)\t\t\t\t\t\\\n  if (callreg != value)\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      printf (\"%s   r%d\tgot 0x%08lX want 0x%08lX\\n\",\t\t\t\\\n\t      header, regnum, callreg, value);\t\t\t\t\\\n      header = \"\";\t\t\t\t\t\t\t\\\n      ret = 0;\t\t\t\t\t\t\t\t\\\n    }\n\n  for (i = 0; i < 8; i++)\n    {\n      CHECK (calling_conventions_values[GOT_CALLEE_SAVES + i],\n\t     i + 4,\n\t     calling_conventions_values[WANT_CALLEE_SAVES + i]);\n    }\n\n  return ret;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/memory.c": {
    "tests_memory_find": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "struct header **\ntests_memory_find (void *ptr)\n{\n  struct header  **hp;\n\n  for (hp = &tests_memory_list; *hp != NULL; hp = &((*hp)->next))\n    if ((*hp)->ptr == ptr)\n      return hp;\n\n  return NULL;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "struct header",
        "struct",
        "header",
        "**\ntests_memory_find (void *ptr)",
        "*",
        "*\ntests_memory_find (void *ptr)",
        "*"
      ]
    },
    "tests_memory_valid": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\ntests_memory_valid (void *ptr)\n{\n  return (tests_memory_find (ptr) != NULL);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "tests_allocate": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void *\ntests_allocate (size_t size)\n{\n  struct header  *h;\n  void *rptr, *ptr;\n  mp_limb_t PATTERN2_var;\n\n  if (size == 0)\n    {\n      fprintf (stderr, \"tests_allocate(): attempt to allocate 0 bytes\\n\");\n      abort ();\n    }\n\n  h = (struct header *) __gmp_default_allocate (sizeof (*h));\n  h->next = tests_memory_list;\n  tests_memory_list = h;\n\n  rptr = __gmp_default_allocate (size + 2 * sizeof (mp_limb_t));\n  ptr = (void *) ((gmp_intptr_t) rptr + sizeof (mp_limb_t));\n\n  *((mp_limb_t *) ((gmp_intptr_t) ptr - sizeof (mp_limb_t)))\n    = PATTERN1 - PTRLIMB (ptr);\n  PATTERN2_var = PATTERN2 - PTRLIMB (ptr);\n  memcpy ((void *) ((gmp_intptr_t) ptr + size), &PATTERN2_var, sizeof (mp_limb_t));\n\n  h->size = size;\n  h->ptr = ptr;\n  return h->ptr;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void",
        "*\ntests_allocate (size_t size)",
        "*"
      ]
    },
    "tests_reallocate": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void *\ntests_reallocate (void *ptr, size_t old_size, size_t new_size)\n{\n  struct header  **hp, *h;\n  void *rptr;\n  mp_limb_t PATTERN2_var;\n\n  if (new_size == 0)\n    {\n      fprintf (stderr, \"tests_reallocate(): attempt to reallocate %p to 0 bytes\\n\",\n\t       ptr);\n      abort ();\n    }\n\n  hp = tests_memory_find (ptr);\n  if (hp == NULL)\n    {\n      fprintf (stderr, \"tests_reallocate(): attempt to reallocate bad pointer %p\\n\",\n\t       ptr);\n      abort ();\n    }\n  h = *hp;\n\n  if (h->size != old_size)\n    {\n      fprintf (stderr, \"tests_reallocate(): bad old size %lu, should be %lu\\n\",\n\t       (unsigned long) old_size, (unsigned long) h->size);\n      abort ();\n    }\n\n  if (*((mp_limb_t *) ((gmp_intptr_t) ptr - sizeof (mp_limb_t)))\n      != PATTERN1 - PTRLIMB (ptr))\n    {\n      fprintf (stderr, \"in realloc: redzone clobbered before block\\n\");\n      abort ();\n    }\n  PATTERN2_var = PATTERN2 - PTRLIMB (ptr);\n  if (memcmp ((void *) ((gmp_intptr_t) ptr + h->size), &PATTERN2_var, sizeof (mp_limb_t)))\n    {\n      fprintf (stderr, \"in realloc: redzone clobbered after block\\n\");\n      abort ();\n    }\n\n  rptr = __gmp_default_reallocate ((void *) ((gmp_intptr_t) ptr - sizeof (mp_limb_t)),\n\t\t\t\t old_size + 2 * sizeof (mp_limb_t),\n\t\t\t\t new_size + 2 * sizeof (mp_limb_t));\n  ptr = (void *) ((gmp_intptr_t) rptr + sizeof (mp_limb_t));\n\n  *((mp_limb_t *) ((gmp_intptr_t) ptr - sizeof (mp_limb_t)))\n    = PATTERN1 - PTRLIMB (ptr);\n  PATTERN2_var = PATTERN2 - PTRLIMB (ptr);\n  memcpy ((void *) ((gmp_intptr_t) ptr + new_size), &PATTERN2_var, sizeof (mp_limb_t));\n\n  h->size = new_size;\n  h->ptr = ptr;\n  return h->ptr;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "void",
        "*\ntests_reallocate (void *ptr, size_t old_size, size_t new_size)",
        "*"
      ]
    },
    "tests_free_find": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "struct header **\ntests_free_find (void *ptr)\n{\n  struct header  **hp = tests_memory_find (ptr);\n  if (hp == NULL)\n    {\n      fprintf (stderr, \"tests_free(): attempt to free bad pointer %p\\n\",\n\t       ptr);\n      abort ();\n    }\n  return hp;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "struct header",
        "struct",
        "header",
        "**\ntests_free_find (void *ptr)",
        "*",
        "*\ntests_free_find (void *ptr)",
        "*"
      ]
    },
    "tests_free_nosize": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void\ntests_free_nosize (void *ptr)\n{\n  struct header  **hp = tests_free_find (ptr);\n  struct header  *h = *hp;\n  mp_limb_t PATTERN2_var;\n\n  *hp = h->next;  /* unlink */\n\n  if (*((mp_limb_t *) ((gmp_intptr_t) ptr - sizeof (mp_limb_t)))\n      != PATTERN1 - PTRLIMB (ptr))\n    {\n      fprintf (stderr, \"in free: redzone clobbered before block\\n\");\n      abort ();\n    }\n  PATTERN2_var = PATTERN2 - PTRLIMB (ptr);\n  if (memcmp ((void *) ((gmp_intptr_t) ptr + h->size), &PATTERN2_var, sizeof (mp_limb_t)))\n    {\n      fprintf (stderr, \"in free: redzone clobbered after block\\n\");\n      abort ();\n    }\n\n  __gmp_default_free ((void *) ((gmp_intptr_t) ptr - sizeof(mp_limb_t)),\n\t\t      h->size + 2 * sizeof (mp_limb_t));\n  __gmp_default_free (h, sizeof (*h));\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "tests_free": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "void\ntests_free (void *ptr, size_t size)\n{\n  struct header  **hp = tests_free_find (ptr);\n  struct header  *h = *hp;\n\n  if (h->size != size)\n    {\n      fprintf (stderr, \"tests_free(): bad size %lu, should be %lu\\n\",\n\t       (unsigned long) size, (unsigned long) h->size);\n      abort ();\n    }\n\n  tests_free_nosize (ptr);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "tests_memory_start": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "void\ntests_memory_start (void)\n{\n  mp_set_memory_functions (tests_allocate, tests_reallocate, tests_free);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "tests_memory_end": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "void\ntests_memory_end (void)\n{\n  if (tests_memory_list != NULL)\n    {\n      struct header  *h;\n      unsigned  count;\n\n      fprintf (stderr, \"tests_memory_end(): not all memory freed\\n\");\n\n      count = 0;\n      for (h = tests_memory_list; h != NULL; h = h->next)\n\tcount++;\n\n      fprintf (stderr, \"    %u blocks remaining\\n\", count);\n      abort ();\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/misc.c": {
    "tests_start": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\ntests_start (void)\n{\n  char version[10];\n  snprintf (version, 10, \"%u.%u.%u\",\n\t    __GNU_MP_VERSION,\n\t    __GNU_MP_VERSION_MINOR,\n\t    __GNU_MP_VERSION_PATCHLEVEL);\n\n  if (strcmp (gmp_version, version) != 0)\n    {\n      fprintf (stderr, \"tests are not linked to the newly compiled library\\n\");\n      fprintf (stderr, \"  local version is: %s\\n\", version);\n      fprintf (stderr, \"  linked version is: %s\\n\", gmp_version);\n      abort ();\n    }\n\n  /* don't buffer, so output is not lost if a test causes a segv etc */\n  setbuf (stdout, NULL);\n  setbuf (stderr, NULL);\n\n  tests_memory_start ();\n  tests_rand_start ();\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "tests_end": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\ntests_end (void)\n{\n  tests_rand_end ();\n  tests_memory_end ();\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "tests_rand_start": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void\ntests_rand_start (void)\n{\n  gmp_randstate_ptr  rands;\n  char           *perform_seed;\n  unsigned long  seed;\n\n  if (__gmp_rands_initialized)\n    {\n      printf (\"Please let tests_start() initialize the global __gmp_rands.\\n\");\n      printf (\"ie. ensure that function is called before the first use of RANDS.\\n\");\n      abort ();\n    }\n\n  gmp_randinit_default (__gmp_rands);\n  __gmp_rands_initialized = 1;\n  rands = __gmp_rands;\n\n  perform_seed = getenv (\"GMP_CHECK_RANDOMIZE\");\n  if (perform_seed != NULL)\n    {\n#ifdef HAVE_STRTOUL\n      seed = strtoul (perform_seed, 0, 0);\n#else\n      /* This will not work right for seeds >= 2^31 on 64-bit machines.\n\t Perhaps use atol unconditionally?  Is that ubiquitous?  */\n      seed = atoi (perform_seed);\n#endif\n      if (! (seed == 0 || seed == 1))\n        {\n          printf (\"Re-seeding with GMP_CHECK_RANDOMIZE=%lu\\n\", seed);\n          gmp_randseed_ui (rands, seed);\n        }\n      else\n        {\n#if HAVE_GETTIMEOFDAY\n          struct timeval  tv;\n          gettimeofday (&tv, NULL);\n          seed = tv.tv_sec ^ ((unsigned long) tv.tv_usec << 12);\n\t  seed &= 0xffffffff;\n#else\n          time_t  tv;\n          time (&tv);\n          seed = tv;\n#endif\n          gmp_randseed_ui (rands, seed);\n          printf (\"Seed GMP_CHECK_RANDOMIZE=%lu (include this in bug reports)\\n\", seed);\n        }\n      fflush (stdout);\n    }\n}",
      "lines": 51,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "tests_rand_end": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\ntests_rand_end (void)\n{\n  RANDS_CLEAR ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "align_pointer": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void *\nalign_pointer (void *p, size_t align)\n{\n  gmp_intptr_t d;\n  d = ((gmp_intptr_t) p) & (align-1);\n  d = (d != 0 ? align-d : 0);\n  return (void *) (((char *) p) + d);\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "void",
        "*\nalign_pointer (void *p, size_t align)",
        "*"
      ]
    },
    "__gmp_allocate_func_aligned": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "void *\n__gmp_allocate_func_aligned (size_t bytes, size_t align)\n{\n  return align_pointer ((*__gmp_allocate_func) (bytes + align-1), align);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void",
        "*\n__gmp_allocate_func_aligned (size_t bytes, size_t align)",
        "*"
      ]
    },
    "__gmp_allocate_or_reallocate": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void *\n__gmp_allocate_or_reallocate (void *ptr, size_t oldsize, size_t newsize)\n{\n  if (ptr == NULL)\n    return (*__gmp_allocate_func) (newsize);\n  else\n    return (*__gmp_reallocate_func) (ptr, oldsize, newsize);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void",
        "*\n__gmp_allocate_or_reallocate (void *ptr, size_t oldsize, size_t newsize)",
        "*"
      ]
    },
    "__gmp_allocate_strdup": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "char *\n__gmp_allocate_strdup (const char *s)\n{\n  size_t  len;\n  char    *t;\n  len = strlen (s);\n  t = (char *) (*__gmp_allocate_func) (len+1);\n  memcpy (t, s, len+1);\n  return t;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "char",
        "*\n__gmp_allocate_strdup (const char *s)",
        "*"
      ]
    },
    "strtoupper": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "char *\nstrtoupper (char *s_orig)\n{\n  char  *s;\n  for (s = s_orig; *s != '\\0'; s++)\n    if (isascii (*s))\n      *s = toupper (*s);\n  return s_orig;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "char",
        "*\nstrtoupper (char *s_orig)",
        "*"
      ]
    },
    "mpz_set_n": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "void\nmpz_set_n (mpz_ptr z, mp_srcptr p, mp_size_t size)\n{\n  ASSERT (size >= 0);\n  MPN_NORMALIZE (p, size);\n  MPZ_REALLOC (z, size);\n  MPN_COPY (PTR(z), p, size);\n  SIZ(z) = size;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_init_set_n": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "void\nmpz_init_set_n (mpz_ptr z, mp_srcptr p, mp_size_t size)\n{\n  ASSERT (size >= 0);\n\n  MPN_NORMALIZE (p, size);\n  ALLOC(z) = MAX (size, 1);\n  PTR(z) = __GMP_ALLOCATE_FUNC_LIMBS (ALLOC(z));\n  SIZ(z) = size;\n  MPN_COPY (PTR(z), p, size);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_diff_lowest": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "mp_size_t\nmpn_diff_lowest (mp_srcptr p1, mp_srcptr p2, mp_size_t size)\n{\n  mp_size_t  i;\n\n  for (i = 0; i < size; i++)\n    if (p1[i] != p2[i])\n      return i;\n\n  /* no differences */\n  return -1;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_diff_highest": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "mp_size_t\nmpn_diff_highest (mp_srcptr p1, mp_srcptr p2, mp_size_t size)\n{\n  mp_size_t  i;\n\n  for (i = size-1; i >= 0; i--)\n    if (p1[i] != p2[i])\n      return i;\n\n  /* no differences */\n  return -1;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "mp_size_t"
      ]
    },
    "byte_diff_lowest": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "mp_size_t\nbyte_diff_lowest (const void *p1, const void *p2, mp_size_t size)\n{\n  mp_size_t  i;\n\n  for (i = 0; i < size; i++)\n    if (((const char *) p1)[i] != ((const char *) p2)[i])\n      return i;\n\n  /* no differences */\n  return -1;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "mp_size_t"
      ]
    },
    "byte_diff_highest": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "mp_size_t\nbyte_diff_highest (const void *p1, const void *p2, mp_size_t size)\n{\n  mp_size_t  i;\n\n  for (i = size-1; i >= 0; i--)\n    if (((const char *) p1)[i] != ((const char *) p2)[i])\n      return i;\n\n  /* no differences */\n  return -1;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpz_set_str_or_abort": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "void\nmpz_set_str_or_abort (mpz_ptr z, const char *str, int base)\n{\n  if (mpz_set_str (z, str, base) != 0)\n    {\n      fprintf (stderr, \"ERROR: mpz_set_str failed\\n\");\n      fprintf (stderr, \"   str  = \\\"%s\\\"\\n\", str);\n      fprintf (stderr, \"   base = %d\\n\", base);\n      abort();\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpq_set_str_or_abort": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "void\nmpq_set_str_or_abort (mpq_ptr q, const char *str, int base)\n{\n  if (mpq_set_str (q, str, base) != 0)\n    {\n      fprintf (stderr, \"ERROR: mpq_set_str failed\\n\");\n      fprintf (stderr, \"   str  = \\\"%s\\\"\\n\", str);\n      fprintf (stderr, \"   base = %d\\n\", base);\n      abort();\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpf_set_str_or_abort": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "void\nmpf_set_str_or_abort (mpf_ptr f, const char *str, int base)\n{\n  if (mpf_set_str (f, str, base) != 0)\n    {\n      fprintf (stderr, \"ERROR mpf_set_str failed\\n\");\n      fprintf (stderr, \"   str  = \\\"%s\\\"\\n\", str);\n      fprintf (stderr, \"   base = %d\\n\", base);\n      abort();\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_pow2abs_p": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "int\nmpz_pow2abs_p (mpz_srcptr z)\n{\n  mp_size_t  size, i;\n  mp_srcptr  ptr;\n\n  size = SIZ (z);\n  if (size == 0)\n    return 0;  /* zero is not a power of 2 */\n  size = ABS (size);\n\n  ptr = PTR (z);\n  for (i = 0; i < size-1; i++)\n    if (ptr[i] != 0)\n      return 0;  /* non-zero low limb means not a power of 2 */\n\n  return POW2_P (ptr[i]);  /* high limb power of 2 */\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mpz_erandomb": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        348,
        1
      ],
      "content": "void\nmpz_erandomb (mpz_ptr rop, gmp_randstate_t rstate, unsigned long nbits)\n{\n  mpz_urandomb (rop, rstate, gmp_urandomm_ui (rstate, nbits));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_erandomb_nonzero": {
      "start_point": [
        350,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "void\nmpz_erandomb_nonzero (mpz_ptr rop, gmp_randstate_t rstate, unsigned long nbits)\n{\n  mpz_erandomb (rop, rstate, nbits);\n  if (mpz_sgn (rop) == 0)\n    mpz_set_ui (rop, 1L);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_errandomb": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "void\nmpz_errandomb (mpz_ptr rop, gmp_randstate_t rstate, unsigned long nbits)\n{\n  mpz_rrandomb (rop, rstate, gmp_urandomm_ui (rstate, nbits));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_errandomb_nonzero": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "void\nmpz_errandomb_nonzero (mpz_ptr rop, gmp_randstate_t rstate, unsigned long nbits)\n{\n  mpz_errandomb (rop, rstate, nbits);\n  if (mpz_sgn (rop) == 0)\n    mpz_set_ui (rop, 1L);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_negrandom": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "void\nmpz_negrandom (mpz_ptr rop, gmp_randstate_t rstate)\n{\n  mp_limb_t  n;\n  _gmp_rand (&n, rstate, 1);\n  if (n != 0)\n    mpz_neg (rop, rop);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "urandom": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "mp_limb_t\nurandom (void)\n{\n#if GMP_NAIL_BITS == 0\n  mp_limb_t  n;\n  _gmp_rand (&n, RANDS, GMP_LIMB_BITS);\n  return n;\n#else\n  mp_limb_t n[2];\n  _gmp_rand (n, RANDS, GMP_LIMB_BITS);\n  return n[0] + (n[1] << GMP_NUMB_BITS);\n#endif\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "call_rand_algs": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "void\ncall_rand_algs (void (*func) (const char *, gmp_randstate_ptr))\n{\n  gmp_randstate_t  rstate;\n  mpz_t            a;\n\n  mpz_init (a);\n\n  gmp_randinit_default (rstate);\n  (*func) (\"gmp_randinit_default\", rstate);\n  gmp_randclear (rstate);\n\n  gmp_randinit_mt (rstate);\n  (*func) (\"gmp_randinit_mt\", rstate);\n  gmp_randclear (rstate);\n\n  gmp_randinit_lc_2exp_size (rstate, 8L);\n  (*func) (\"gmp_randinit_lc_2exp_size 8\", rstate);\n  gmp_randclear (rstate);\n\n  gmp_randinit_lc_2exp_size (rstate, 16L);\n  (*func) (\"gmp_randinit_lc_2exp_size 16\", rstate);\n  gmp_randclear (rstate);\n\n  gmp_randinit_lc_2exp_size (rstate, 128L);\n  (*func) (\"gmp_randinit_lc_2exp_size 128\", rstate);\n  gmp_randclear (rstate);\n\n  /* degenerate always zeros */\n  mpz_set_ui (a, 0L);\n  gmp_randinit_lc_2exp (rstate, a, 0L, 8L);\n  (*func) (\"gmp_randinit_lc_2exp a=0 c=0 m=8\", rstate);\n  gmp_randclear (rstate);\n\n  /* degenerate always FFs */\n  mpz_set_ui (a, 0L);\n  gmp_randinit_lc_2exp (rstate, a, 0xFFL, 8L);\n  (*func) (\"gmp_randinit_lc_2exp a=0 c=0xFF m=8\", rstate);\n  gmp_randclear (rstate);\n\n  mpz_clear (a);\n}",
      "lines": 42,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "tests_infinity_d": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "double\ntests_infinity_d (void)\n{\n#if _GMP_IEEE_FLOATS\n  union ieee_double_extract x;\n  x.s.exp = 2047;\n  x.s.manl = 0;\n  x.s.manh = 0;\n  x.s.sig = 0;\n  return x.d;\n#else\n  return 0;\n#endif\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "tests_isinf": {
      "start_point": [
        462,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "int\ntests_isinf (double d)\n{\n#if _GMP_IEEE_FLOATS\n  union ieee_double_extract x;\n  x.d = d;\n  return (x.s.exp == 2047 && x.s.manl == 0 && x.s.manh == 0);\n#else\n  return 0;\n#endif\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "tests_hardware_setround": {
      "start_point": [
        478,
        0
      ],
      "end_point": [
        496,
        1
      ],
      "content": "int\ntests_hardware_setround (int mode)\n{\n#if ! defined NO_ASM && HAVE_HOST_CPU_FAMILY_x86\n  int  rc;\n  switch (mode) {\n  case 0: rc = 0; break;  /* nearest */\n  case 1: rc = 3; break;  /* tozero  */\n  case 2: rc = 2; break;  /* up      */\n  case 3: rc = 1; break;  /* down    */\n  default:\n    return 0;\n  }\n  x86_fldcw ((x86_fstcw () & ~0xC00) | (rc << 10));\n  return 1;\n#endif\n\n  return 0;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "tests_hardware_getround": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "int\ntests_hardware_getround (void)\n{\n#if ! defined NO_ASM && HAVE_HOST_CPU_FAMILY_x86\n  switch ((x86_fstcw () & ~0xC00) >> 10) {\n  case 0: return 0; break;  /* nearest */\n  case 1: return 3; break;  /* down    */\n  case 2: return 2; break;  /* up      */\n  case 3: return 1; break;  /* tozero  */\n  }\n#endif\n\n  return -1;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "tests_dbl_mant_bits": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "int\ntests_dbl_mant_bits (void)\n{\n  static int n = -1;\n  volatile double x, y, d;\n\n  if (n != -1)\n    return n;\n\n  n = 1;\n  x = 2.0;\n  for (;;)\n    {\n      /* see if 2^(n+1)+1 can be formed without rounding, if so then\n         continue, if not then \"n\" is the answer */\n      y = x + 1.0;\n      d = y - x;\n      if (d != 1.0)\n        {\n#if defined (DBL_MANT_DIG) && DBL_RADIX == 2\n          if (n != DBL_MANT_DIG)\n            printf (\"Warning, tests_dbl_mant_bits got %d but DBL_MANT_DIG says %d\\n\", n, DBL_MANT_DIG);\n#endif\n          break;\n        }\n\n      x *= 2;\n      n++;\n\n      if (n > 1000)\n        {\n          printf (\"Oops, tests_dbl_mant_bits can't determine mantissa size\\n\");\n          n = 0;\n          break;\n        }\n    }\n  return n;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "tests_sigfpe_handler": {
      "start_point": [
        568,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "RETSIGTYPE\ntests_sigfpe_handler (int sig)\n{\n  longjmp (tests_sigfpe_target, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "RETSIGTYPE"
      ]
    },
    "tests_sigfpe_done": {
      "start_point": [
        574,
        0
      ],
      "end_point": [
        578,
        1
      ],
      "content": "void\ntests_sigfpe_done (void)\n{\n  signal (SIGFPE, SIG_DFL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/refmpf.c": {
    "refmpf_add": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\nrefmpf_add (mpf_ptr w, mpf_srcptr u, mpf_srcptr v)\n{\n  mp_size_t hi, lo, size;\n  mp_ptr ut, vt, wt;\n  int neg;\n  mp_exp_t exp;\n  mp_limb_t cy;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  if (SIZ (u) == 0)\n    {\n      size = ABSIZ (v);\n      wt = TMP_ALLOC_LIMBS (size + 1);\n      MPN_COPY (wt, PTR (v), size);\n      exp = EXP (v);\n      neg = SIZ (v) < 0;\n      goto done;\n    }\n  if (SIZ (v) == 0)\n    {\n      size = ABSIZ (u);\n      wt = TMP_ALLOC_LIMBS (size + 1);\n      MPN_COPY (wt, PTR (u), size);\n      exp = EXP (u);\n      neg = SIZ (u) < 0;\n      goto done;\n    }\n  if ((SIZ (u) ^ SIZ (v)) < 0)\n    {\n      mpf_t tmp;\n      SIZ (tmp) = -SIZ (v);\n      EXP (tmp) = EXP (v);\n      PTR (tmp) = PTR (v);\n      refmpf_sub (w, u, tmp);\n      return;\n    }\n  neg = SIZ (u) < 0;\n\n  /* Compute the significance of the hi and lo end of the result.  */\n  hi = MAX (EXP (u), EXP (v));\n  lo = MIN (EXP (u) - ABSIZ (u), EXP (v) - ABSIZ (v));\n  size = hi - lo;\n  ut = TMP_ALLOC_LIMBS (size + 1);\n  vt = TMP_ALLOC_LIMBS (size + 1);\n  wt = TMP_ALLOC_LIMBS (size + 1);\n  MPN_ZERO (ut, size);\n  MPN_ZERO (vt, size);\n  {int off;\n  off = size + (EXP (u) - hi) - ABSIZ (u);\n  MPN_COPY (ut + off, PTR (u), ABSIZ (u));\n  off = size + (EXP (v) - hi) - ABSIZ (v);\n  MPN_COPY (vt + off, PTR (v), ABSIZ (v));\n  }\n\n  cy = mpn_add_n (wt, ut, vt, size);\n  wt[size] = cy;\n  size += cy;\n  exp = hi + cy;\n\ndone:\n  if (size > PREC (w))\n    {\n      wt += size - PREC (w);\n      size = PREC (w);\n    }\n  MPN_COPY (PTR (w), wt, size);\n  SIZ (w) = neg == 0 ? size : -size;\n  EXP (w) = exp;\n  TMP_FREE;\n}",
      "lines": 73,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "refmpf_add_ulp": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "void\nrefmpf_add_ulp (mpf_ptr f)\n{\n  mp_ptr     fp = PTR(f);\n  mp_size_t  fsize = SIZ(f);\n  mp_size_t  abs_fsize = ABSIZ(f);\n  mp_limb_t  c;\n\n  if (fsize == 0)\n    {\n      printf (\"Oops, refmpf_add_ulp called with f==0\\n\");\n      abort ();\n    }\n\n  c = refmpn_add_1 (fp, fp, abs_fsize, CNST_LIMB(1));\n  if (c != 0)\n    {\n      if (abs_fsize >= PREC(f) + 1)\n        {\n          printf (\"Oops, refmpf_add_ulp carried out of prec+1 limbs\\n\");\n          abort ();\n        }\n\n      fp[abs_fsize] = c;\n      abs_fsize++;\n      SIZ(f) = (fsize > 0 ? abs_fsize : - abs_fsize);\n      EXP(f)++;\n    }\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "refmpf_fill": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\nrefmpf_fill (mpf_ptr f, mp_size_t size, mp_limb_t value)\n{\n  ASSERT (size >= 0);\n  size = MIN (PREC(f) + 1, size);\n  SIZ(f) = size;\n  EXP(f) = size;\n  refmpn_fill (PTR(f), size, value);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "refmpf_normalize": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\nrefmpf_normalize (mpf_ptr f)\n{\n  while (SIZ(f) != 0 && PTR(f)[ABSIZ(f)-1] == 0)\n    {\n      SIZ(f) = (SIZ(f) >= 0 ? SIZ(f)-1 : SIZ(f)+1);\n      EXP(f) --;\n    }\n  if (SIZ(f) == 0)\n    EXP(f) = 0;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "refmpf_set_overlap": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "unsigned long\nrefmpf_set_overlap (mpf_ptr dst, mpf_srcptr src)\n{\n  mp_size_t  dprec = PREC(dst);\n  mp_size_t  ssize = ABSIZ(src);\n  unsigned long  ret;\n\n  refmpf_set_prec_limbs (dst, (unsigned long) MAX (dprec, ssize));\n  mpf_set (dst, src);\n\n  ret = mpf_get_prec (dst);\n  PREC(dst) = dprec;\n  return ret;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "refmpf_set_prec_limbs": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "void\nrefmpf_set_prec_limbs (mpf_ptr f, unsigned long prec)\n{\n  mpf_set_prec (f, __GMPF_PREC_TO_BITS (prec));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpf_sub": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "void\nrefmpf_sub (mpf_ptr w, mpf_srcptr u, mpf_srcptr v)\n{\n  mp_size_t hi, lo, size;\n  mp_ptr ut, vt, wt;\n  int neg;\n  mp_exp_t exp;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  if (SIZ (u) == 0)\n    {\n      size = ABSIZ (v);\n      wt = TMP_ALLOC_LIMBS (size + 1);\n      MPN_COPY (wt, PTR (v), size);\n      exp = EXP (v);\n      neg = SIZ (v) > 0;\n      goto done;\n    }\n  if (SIZ (v) == 0)\n    {\n      size = ABSIZ (u);\n      wt = TMP_ALLOC_LIMBS (size + 1);\n      MPN_COPY (wt, PTR (u), size);\n      exp = EXP (u);\n      neg = SIZ (u) < 0;\n      goto done;\n    }\n  if ((SIZ (u) ^ SIZ (v)) < 0)\n    {\n      mpf_t tmp;\n      SIZ (tmp) = -SIZ (v);\n      EXP (tmp) = EXP (v);\n      PTR (tmp) = PTR (v);\n      refmpf_add (w, u, tmp);\n      if (SIZ (u) < 0)\n\tmpf_neg (w, w);\n      return;\n    }\n  neg = SIZ (u) < 0;\n\n  /* Compute the significance of the hi and lo end of the result.  */\n  hi = MAX (EXP (u), EXP (v));\n  lo = MIN (EXP (u) - ABSIZ (u), EXP (v) - ABSIZ (v));\n  size = hi - lo;\n  ut = TMP_ALLOC_LIMBS (size + 1);\n  vt = TMP_ALLOC_LIMBS (size + 1);\n  wt = TMP_ALLOC_LIMBS (size + 1);\n  MPN_ZERO (ut, size);\n  MPN_ZERO (vt, size);\n  {int off;\n  off = size + (EXP (u) - hi) - ABSIZ (u);\n  MPN_COPY (ut + off, PTR (u), ABSIZ (u));\n  off = size + (EXP (v) - hi) - ABSIZ (v);\n  MPN_COPY (vt + off, PTR (v), ABSIZ (v));\n  }\n\n  if (mpn_cmp (ut, vt, size) >= 0)\n    mpn_sub_n (wt, ut, vt, size);\n  else\n    {\n      mpn_sub_n (wt, vt, ut, size);\n      neg ^= 1;\n    }\n  exp = hi;\n  while (size != 0 && wt[size - 1] == 0)\n    {\n      size--;\n      exp--;\n    }\n\ndone:\n  if (size > PREC (w))\n    {\n      wt += size - PREC (w);\n      size = PREC (w);\n    }\n  MPN_COPY (PTR (w), wt, size);\n  SIZ (w) = neg == 0 ? size : -size;\n  EXP (w) = exp;\n  TMP_FREE;\n}",
      "lines": 83,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "refmpf_validate": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "int\nrefmpf_validate (const char *name, mpf_srcptr got, mpf_srcptr want)\n{\n  int  bad = 0;\n  mp_size_t  gsize, wsize, cmpsize, i;\n  mp_srcptr  gp, wp;\n  mp_limb_t  glimb, wlimb;\n\n  MPF_CHECK_FORMAT (got);\n\n  if (EXP (got) != EXP (want))\n    {\n      printf (\"%s: wrong exponent\\n\", name);\n      bad = 1;\n    }\n\n  gsize = SIZ (got);\n  wsize = SIZ (want);\n  if ((gsize < 0 && wsize > 0) || (gsize > 0 && wsize < 0))\n    {\n      printf (\"%s: wrong sign\\n\", name);\n      bad = 1;\n    }\n\n  gsize = ABS (gsize);\n  wsize = ABS (wsize);\n\n  /* most significant limb of respective data */\n  gp = PTR (got) + gsize - 1;\n  wp = PTR (want) + wsize - 1;\n\n  /* compare limb data */\n  cmpsize = MAX (PREC (got), gsize);\n  for (i = 0; i < cmpsize; i++)\n    {\n      glimb = (i < gsize ? gp[-i] : 0);\n      wlimb = (i < wsize ? wp[-i] : 0);\n\n      if (glimb != wlimb)\n        {\n          printf (\"%s: wrong data starting at index %ld from top\\n\",\n                  name, (long) i);\n          bad = 1;\n          break;\n        }\n    }\n\n  if (bad)\n    {\n      printf (\"  prec       %d\\n\", PREC(got));\n      printf (\"  exp got    %ld\\n\", (long) EXP(got));\n      printf (\"  exp want   %ld\\n\", (long) EXP(want));\n      printf (\"  size got   %d\\n\", SIZ(got));\n      printf (\"  size want  %d\\n\", SIZ(want));\n      printf (\"  limbs (high to low)\\n\");\n      printf (\"   got  \");\n      for (i = ABSIZ(got)-1; i >= 0; i--)\n        {\n          gmp_printf (\"%MX\", PTR(got)[i]);\n          if (i != 0)\n            printf (\",\");\n        }\n      printf (\"\\n\");\n      printf (\"   want \");\n      for (i = ABSIZ(want)-1; i >= 0; i--)\n        {\n          gmp_printf (\"%MX\", PTR(want)[i]);\n          if (i != 0)\n            printf (\",\");\n        }\n      printf (\"\\n\");\n      return 0;\n    }\n\n  return 1;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "refmpf_validate_division": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "int\nrefmpf_validate_division (const char *name, mpf_srcptr got,\n                          mpf_srcptr n, mpf_srcptr d)\n{\n  mp_size_t  nsize, dsize, sign, prec, qsize, tsize;\n  mp_srcptr  np, dp;\n  mp_ptr     tp, qp, rp;\n  mpf_t      want;\n  int        ret;\n\n  nsize = SIZ (n);\n  dsize = SIZ (d);\n  ASSERT_ALWAYS (dsize != 0);\n\n  sign = nsize ^ dsize;\n  nsize = ABS (nsize);\n  dsize = ABS (dsize);\n\n  np = PTR (n);\n  dp = PTR (d);\n  prec = PREC (got);\n\n  EXP (want) = EXP (n) - EXP (d) + 1;\n\n  qsize = prec + 2;            /* at least prec+1 limbs, after high zero */\n  tsize = qsize + dsize - 1;   /* dividend size to give desired qsize */\n\n  /* dividend n, extended or truncated */\n  tp = refmpn_malloc_limbs (tsize);\n  refmpn_copy_extend (tp, tsize, np, nsize);\n\n  qp = refmpn_malloc_limbs (qsize);\n  rp = refmpn_malloc_limbs (dsize);  /* remainder, unused */\n\n  ASSERT_ALWAYS (qsize == tsize - dsize + 1);\n  refmpn_tdiv_qr (qp, rp, (mp_size_t) 0, tp, tsize, dp, dsize);\n\n  PTR (want) = qp;\n  SIZ (want) = (sign >= 0 ? qsize : -qsize);\n  refmpf_normalize (want);\n\n  ret = refmpf_validate (name, got, want);\n\n  free (tp);\n  free (qp);\n  free (rp);\n\n  return ret;\n}",
      "lines": 49,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/refmpn.c": {
    "byte_overlap_p": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nbyte_overlap_p (const void *v_xp, mp_size_t xsize,\n\t\tconst void *v_yp, mp_size_t ysize)\n{\n  const char *xp = (const char *) v_xp;\n  const char *yp = (const char *) v_yp;\n\n  ASSERT (xsize >= 0);\n  ASSERT (ysize >= 0);\n\n  /* no wraparounds */\n  ASSERT (xp+xsize >= xp);\n  ASSERT (yp+ysize >= yp);\n\n  if (xp + xsize <= yp)\n    return 0;\n\n  if (yp + ysize <= xp)\n    return 0;\n\n  return 1;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "refmpn_overlap_p": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nrefmpn_overlap_p (mp_srcptr xp, mp_size_t xsize, mp_srcptr yp, mp_size_t ysize)\n{\n  return byte_overlap_p (xp, xsize * GMP_LIMB_BYTES,\n\t\t\t yp, ysize * GMP_LIMB_BYTES);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "refmpn_overlap_low_to_high_p": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nrefmpn_overlap_low_to_high_p (mp_srcptr dst, mp_srcptr src, mp_size_t size)\n{\n  return (dst <= src || ! refmpn_overlap_p (dst, size, src, size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "refmpn_overlap_high_to_low_p": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nrefmpn_overlap_high_to_low_p (mp_srcptr dst, mp_srcptr src, mp_size_t size)\n{\n  return (dst >= src || ! refmpn_overlap_p (dst, size, src, size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "refmpn_overlap_fullonly_p": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nrefmpn_overlap_fullonly_p (mp_srcptr dst, mp_srcptr src, mp_size_t size)\n{\n  return (dst == src || ! refmpn_overlap_p (dst, size, src, size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "refmpn_overlap_fullonly_two_p": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\nrefmpn_overlap_fullonly_two_p (mp_srcptr dst, mp_srcptr src1, mp_srcptr src2,\n\t\t\t       mp_size_t size)\n{\n  return (refmpn_overlap_fullonly_p (dst, src1, size)\n\t  && refmpn_overlap_fullonly_p (dst, src2, size));\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "refmpn_malloc_limbs": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "mp_ptr\nrefmpn_malloc_limbs (mp_size_t size)\n{\n  mp_ptr  p;\n  ASSERT (size >= 0);\n  if (size == 0)\n    size = 1;\n  p = (mp_ptr) malloc ((size_t) (size * GMP_LIMB_BYTES));\n  ASSERT (p != NULL);\n  return p;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "mp_ptr"
      ]
    },
    "refmpn_free_limbs": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void\nrefmpn_free_limbs (mp_ptr p)\n{\n  free (p);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "refmpn_memdup_limbs": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "mp_ptr\nrefmpn_memdup_limbs (mp_srcptr ptr, mp_size_t size)\n{\n  mp_ptr  p;\n  p = refmpn_malloc_limbs (size);\n  refmpn_copyi (p, ptr, size);\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "mp_ptr"
      ]
    },
    "refmpn_malloc_limbs_aligned": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "mp_ptr\nrefmpn_malloc_limbs_aligned (mp_size_t n, size_t m)\n{\n  return (mp_ptr) align_pointer (refmpn_malloc_limbs (n + m-1), m);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "mp_ptr"
      ]
    },
    "refmpn_fill": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nrefmpn_fill (mp_ptr ptr, mp_size_t size, mp_limb_t value)\n{\n  mp_size_t  i;\n  ASSERT (size >= 0);\n  for (i = 0; i < size; i++)\n    ptr[i] = value;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "refmpn_zero": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "void\nrefmpn_zero (mp_ptr ptr, mp_size_t size)\n{\n  refmpn_fill (ptr, size, CNST_LIMB(0));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_zero_extend": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "void\nrefmpn_zero_extend (mp_ptr ptr, mp_size_t oldsize, mp_size_t newsize)\n{\n  ASSERT (newsize >= oldsize);\n  refmpn_zero (ptr+oldsize, newsize-oldsize);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "refmpn_zero_p": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "int\nrefmpn_zero_p (mp_srcptr ptr, mp_size_t size)\n{\n  mp_size_t  i;\n  for (i = 0; i < size; i++)\n    if (ptr[i] != 0)\n      return 0;\n  return 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "refmpn_normalize": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "mp_size_t\nrefmpn_normalize (mp_srcptr ptr, mp_size_t size)\n{\n  ASSERT (size >= 0);\n  while (size > 0 && ptr[size-1] == 0)\n    size--;\n  return size;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "mp_size_t"
      ]
    },
    "refmpn_msbone": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "mp_limb_t\nrefmpn_msbone (mp_limb_t x)\n{\n  mp_limb_t  n = (mp_limb_t) 1 << (GMP_LIMB_BITS-1);\n\n  while (n != 0)\n    {\n      if (x & n)\n\tbreak;\n      n >>= 1;\n    }\n  return n;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_msbone_mask": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "mp_limb_t\nrefmpn_msbone_mask (mp_limb_t x)\n{\n  if (x == 0)\n    return 0;\n\n  return (refmpn_msbone (x) << 1) - 1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_chars_per_limb": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "int\nrefmpn_chars_per_limb (int base)\n{\n  mp_limb_t  limit[2], b[2];\n  int        chars_per_limb;\n\n  ASSERT (base >= 2);\n\n  limit[0] = 0;  /* limit = 2^GMP_NUMB_BITS */\n  limit[1] = 1;\n  b[0] = 1;      /* b = 1 */\n  b[1] = 0;\n\n  chars_per_limb = 0;\n  for (;;)\n    {\n      if (refmpn_mul_1 (b, b, (mp_size_t) 2, (mp_limb_t) base))\n\tbreak;\n      if (refmpn_cmp (b, limit, (mp_size_t) 2) > 0)\n\tbreak;\n      chars_per_limb++;\n    }\n  return chars_per_limb;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "refmpn_big_base": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "mp_limb_t\nrefmpn_big_base (int base)\n{\n  int        chars_per_limb = refmpn_chars_per_limb (base);\n  int        i;\n  mp_limb_t  bb;\n\n  ASSERT (base >= 2);\n  bb = 1;\n  for (i = 0; i < chars_per_limb; i++)\n    bb *= base;\n  return bb;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_setbit": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "void\nrefmpn_setbit (mp_ptr ptr, unsigned long bit)\n{\n  ptr[bit/GMP_NUMB_BITS] |= CNST_LIMB(1) << (bit%GMP_NUMB_BITS);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_clrbit": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "void\nrefmpn_clrbit (mp_ptr ptr, unsigned long bit)\n{\n  ptr[bit/GMP_NUMB_BITS] &= ~ (CNST_LIMB(1) << (bit%GMP_NUMB_BITS));\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "refmpn_tstbit": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "int\nrefmpn_tstbit (mp_srcptr ptr, unsigned long bit)\n{\n  return REFMPN_TSTBIT (ptr, bit);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "refmpn_scan0": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "unsigned long\nrefmpn_scan0 (mp_srcptr ptr, unsigned long bit)\n{\n  while (REFMPN_TSTBIT (ptr, bit) != 0)\n    bit++;\n  return bit;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "refmpn_scan1": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "unsigned long\nrefmpn_scan1 (mp_srcptr ptr, unsigned long bit)\n{\n  while (REFMPN_TSTBIT (ptr, bit) == 0)\n    bit++;\n  return bit;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "refmpn_copy": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "void\nrefmpn_copy (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  ASSERT (refmpn_overlap_fullonly_p (rp, sp, size));\n  refmpn_copyi (rp, sp, size);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_copyi": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "void\nrefmpn_copyi (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  mp_size_t i;\n\n  ASSERT (refmpn_overlap_low_to_high_p (rp, sp, size));\n  ASSERT (size >= 0);\n\n  for (i = 0; i < size; i++)\n    rp[i] = sp[i];\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_copyd": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\nrefmpn_copyd (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  mp_size_t i;\n\n  ASSERT (refmpn_overlap_high_to_low_p (rp, sp, size));\n  ASSERT (size >= 0);\n\n  for (i = size-1; i >= 0; i--)\n    rp[i] = sp[i];\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_copy_extend": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "void\nrefmpn_copy_extend (mp_ptr wp, mp_size_t wsize, mp_srcptr xp, mp_size_t xsize)\n{\n  ASSERT (wsize >= 0);\n  ASSERT (xsize >= 0);\n\n  /* high part of x if x bigger than w */\n  if (xsize > wsize)\n    {\n      xp += xsize - wsize;\n      xsize = wsize;\n    }\n\n  refmpn_copy (wp + wsize-xsize, xp, xsize);\n  refmpn_zero (wp, wsize-xsize);\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_cmp": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "int\nrefmpn_cmp (mp_srcptr xp, mp_srcptr yp, mp_size_t size)\n{\n  mp_size_t  i;\n\n  ASSERT (size >= 1);\n  ASSERT_MPN (xp, size);\n  ASSERT_MPN (yp, size);\n\n  for (i = size-1; i >= 0; i--)\n    {\n      if (xp[i] > yp[i])  return 1;\n      if (xp[i] < yp[i])  return -1;\n    }\n  return 0;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "refmpn_cmp_allowzero": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "int\nrefmpn_cmp_allowzero (mp_srcptr xp, mp_srcptr yp, mp_size_t size)\n{\n  if (size == 0)\n    return 0;\n  else\n    return refmpn_cmp (xp, yp, size);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "refmpn_cmp_twosizes": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "int\nrefmpn_cmp_twosizes (mp_srcptr xp, mp_size_t xsize,\n\t\t     mp_srcptr yp, mp_size_t ysize)\n{\n  int  opp, cmp;\n\n  ASSERT_MPN (xp, xsize);\n  ASSERT_MPN (yp, ysize);\n\n  opp = (xsize < ysize);\n  if (opp)\n    MPN_SRCPTR_SWAP (xp,xsize, yp,ysize);\n\n  if (! refmpn_zero_p (xp+ysize, xsize-ysize))\n    cmp = 1;\n  else\n    cmp = refmpn_cmp (xp, yp, ysize);\n\n  return (opp ? -cmp : cmp);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "refmpn_equal_anynail": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "int\nrefmpn_equal_anynail (mp_srcptr xp, mp_srcptr yp, mp_size_t size)\n{\n  mp_size_t  i;\n  ASSERT (size >= 0);\n\n  for (i = 0; i < size; i++)\n      if (xp[i] != yp[i])\n\treturn 0;\n  return 1;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "refmpn_and_n": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "void\nrefmpn_and_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  LOGOPS (s1p[i] & s2p[i]);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_andn_n": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        420,
        1
      ],
      "content": "void\nrefmpn_andn_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  LOGOPS (s1p[i] & ~s2p[i]);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "refmpn_nand_n": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "void\nrefmpn_nand_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  LOGOPS ((s1p[i] & s2p[i]) ^ GMP_NUMB_MASK);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "refmpn_ior_n": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "void\nrefmpn_ior_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  LOGOPS (s1p[i] | s2p[i]);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_iorn_n": {
      "start_point": [
        431,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "void\nrefmpn_iorn_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  LOGOPS (s1p[i] | (s2p[i] ^ GMP_NUMB_MASK));\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "refmpn_nior_n": {
      "start_point": [
        436,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "void\nrefmpn_nior_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  LOGOPS ((s1p[i] | s2p[i]) ^ GMP_NUMB_MASK);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "refmpn_xor_n": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "void\nrefmpn_xor_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  LOGOPS (s1p[i] ^ s2p[i]);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_xnor_n": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "void\nrefmpn_xnor_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  LOGOPS ((s1p[i] ^ s2p[i]) ^ GMP_NUMB_MASK);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "refmpn_sub_ddmmss": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "void\nrefmpn_sub_ddmmss (mp_limb_t *dh, mp_limb_t *dl,\n\t\t   mp_limb_t mh, mp_limb_t ml, mp_limb_t sh, mp_limb_t sl)\n{\n  *dl = ml - sl;\n  *dh = mh - sh - (ml < sl);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ref_addc_limb": {
      "start_point": [
        464,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "mp_limb_t\nref_addc_limb (mp_limb_t *w, mp_limb_t x, mp_limb_t y)\n{\n  mp_limb_t  sum, cy;\n\n  ASSERT_LIMB (x);\n  ASSERT_LIMB (y);\n\n  sum = x + y;\n#if GMP_NAIL_BITS == 0\n  *w = sum;\n  cy = (sum < x);\n#else\n  *w = sum & GMP_NUMB_MASK;\n  cy = (sum >> GMP_NUMB_BITS);\n#endif\n  return cy;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "ref_subc_limb": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "mp_limb_t\nref_subc_limb (mp_limb_t *w, mp_limb_t x, mp_limb_t y)\n{\n  mp_limb_t  diff, cy;\n\n  ASSERT_LIMB (x);\n  ASSERT_LIMB (y);\n\n  diff = x - y;\n#if GMP_NAIL_BITS == 0\n  *w = diff;\n  cy = (diff > x);\n#else\n  *w = diff & GMP_NUMB_MASK;\n  cy = (diff >> GMP_NUMB_BITS) & 1;\n#endif\n  return cy;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "adc": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "mp_limb_t\nadc (mp_limb_t *w, mp_limb_t x, mp_limb_t y, mp_limb_t c)\n{\n  mp_limb_t  r;\n\n  ASSERT_LIMB (x);\n  ASSERT_LIMB (y);\n  ASSERT (c == 0 || c == 1);\n\n  r = ref_addc_limb (w, x, y);\n  return r + ref_addc_limb (w, *w, c);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "sbb": {
      "start_point": [
        518,
        0
      ],
      "end_point": [
        529,
        1
      ],
      "content": "mp_limb_t\nsbb (mp_limb_t *w, mp_limb_t x, mp_limb_t y, mp_limb_t c)\n{\n  mp_limb_t  r;\n\n  ASSERT_LIMB (x);\n  ASSERT_LIMB (y);\n  ASSERT (c == 0 || c == 1);\n\n  r = ref_subc_limb (w, x, y);\n  return r + ref_subc_limb (w, *w, c);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_add_1": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        550,
        1
      ],
      "content": "mp_limb_t\nrefmpn_add_1 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_limb_t n)\n{\n  AORS_1 (ref_addc_limb);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sub_1": {
      "start_point": [
        551,
        0
      ],
      "end_point": [
        555,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sub_1 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_limb_t n)\n{\n  AORS_1 (ref_subc_limb);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_add_nc": {
      "start_point": [
        572,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "mp_limb_t\nrefmpn_add_nc (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size,\n\t       mp_limb_t carry)\n{\n  AORS_NC (adc);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sub_nc": {
      "start_point": [
        578,
        0
      ],
      "end_point": [
        583,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sub_nc (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size,\n\t       mp_limb_t carry)\n{\n  AORS_NC (sbb);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_add_n": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "mp_limb_t\nrefmpn_add_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  return refmpn_add_nc (rp, s1p, s2p, size, CNST_LIMB(0));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sub_n": {
      "start_point": [
        591,
        0
      ],
      "end_point": [
        595,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sub_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  return refmpn_sub_nc (rp, s1p, s2p, size, CNST_LIMB(0));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_cnd_add_n": {
      "start_point": [
        597,
        0
      ],
      "end_point": [
        607,
        1
      ],
      "content": "mp_limb_t\nrefmpn_cnd_add_n (mp_limb_t cnd, mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  if (cnd != 0)\n    return refmpn_add_n (rp, s1p, s2p, size);\n  else\n    {\n      refmpn_copyi (rp, s1p, size);\n      return 0;\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_cnd_sub_n": {
      "start_point": [
        608,
        0
      ],
      "end_point": [
        618,
        1
      ],
      "content": "mp_limb_t\nrefmpn_cnd_sub_n (mp_limb_t cnd, mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  if (cnd != 0)\n    return refmpn_sub_n (rp, s1p, s2p, size);\n  else\n    {\n      refmpn_copyi (rp, s1p, size);\n      return 0;\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_add_err1_n": {
      "start_point": [
        655,
        0
      ],
      "end_point": [
        661,
        1
      ],
      "content": "mp_limb_t\nrefmpn_add_err1_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p,\n\t\t   mp_ptr ep, mp_srcptr yp,\n\t\t   mp_size_t size, mp_limb_t carry)\n{\n  AORS_ERR1_N (adc);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sub_err1_n": {
      "start_point": [
        662,
        0
      ],
      "end_point": [
        668,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sub_err1_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p,\n\t\t   mp_ptr ep, mp_srcptr yp,\n\t\t   mp_size_t size, mp_limb_t carry)\n{\n  AORS_ERR1_N (sbb);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_add_err2_n": {
      "start_point": [
        712,
        0
      ],
      "end_point": [
        718,
        1
      ],
      "content": "mp_limb_t\nrefmpn_add_err2_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p,\n\t\t   mp_ptr ep, mp_srcptr y1p, mp_srcptr y2p,\n\t\t   mp_size_t size, mp_limb_t carry)\n{\n  AORS_ERR2_N (adc);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sub_err2_n": {
      "start_point": [
        719,
        0
      ],
      "end_point": [
        725,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sub_err2_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p,\n\t\t   mp_ptr ep, mp_srcptr y1p, mp_srcptr y2p,\n\t\t   mp_size_t size, mp_limb_t carry)\n{\n  AORS_ERR2_N (sbb);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_add_err3_n": {
      "start_point": [
        776,
        0
      ],
      "end_point": [
        782,
        1
      ],
      "content": "mp_limb_t\nrefmpn_add_err3_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p,\n\t\t   mp_ptr ep, mp_srcptr y1p, mp_srcptr y2p, mp_srcptr y3p,\n\t\t   mp_size_t size, mp_limb_t carry)\n{\n  AORS_ERR3_N (adc);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sub_err3_n": {
      "start_point": [
        783,
        0
      ],
      "end_point": [
        789,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sub_err3_n (mp_ptr rp, mp_srcptr s1p, mp_srcptr s2p,\n\t\t   mp_ptr ep, mp_srcptr y1p, mp_srcptr y2p, mp_srcptr y3p,\n\t\t   mp_size_t size, mp_limb_t carry)\n{\n  AORS_ERR3_N (sbb);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh_n": {
      "start_point": [
        792,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n\t\t mp_size_t n, unsigned int s)\n{\n  mp_limb_t cy;\n  mp_ptr tp;\n\n  ASSERT (refmpn_overlap_fullonly_two_p (rp, up, vp, n));\n  ASSERT (n >= 1);\n  ASSERT (0 < s && s < GMP_NUMB_BITS);\n  ASSERT_MPN (up, n);\n  ASSERT_MPN (vp, n);\n\n  tp = refmpn_malloc_limbs (n);\n  cy  = refmpn_lshift (tp, vp, n, s);\n  cy += refmpn_add_n (rp, up, tp, n);\n  free (tp);\n  return cy;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh1_n": {
      "start_point": [
        811,
        0
      ],
      "end_point": [
        815,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh1_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_addlsh_n (rp, up, vp, n, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh2_n": {
      "start_point": [
        816,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh2_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_addlsh_n (rp, up, vp, n, 2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh_n_ip1": {
      "start_point": [
        821,
        0
      ],
      "end_point": [
        825,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh_n_ip1 (mp_ptr rp, mp_srcptr vp, mp_size_t n, unsigned int s)\n{\n  return refmpn_addlsh_n (rp, rp, vp, n, s);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh1_n_ip1": {
      "start_point": [
        826,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh1_n_ip1 (mp_ptr rp, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_addlsh_n (rp, rp, vp, n, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh2_n_ip1": {
      "start_point": [
        831,
        0
      ],
      "end_point": [
        835,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh2_n_ip1 (mp_ptr rp, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_addlsh_n (rp, rp, vp, n, 2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh_n_ip2": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh_n_ip2 (mp_ptr rp, mp_srcptr vp, mp_size_t n, unsigned int s)\n{\n  return refmpn_addlsh_n (rp, vp, rp, n, s);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh1_n_ip2": {
      "start_point": [
        841,
        0
      ],
      "end_point": [
        845,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh1_n_ip2 (mp_ptr rp, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_addlsh_n (rp, vp, rp, n, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh2_n_ip2": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh2_n_ip2 (mp_ptr rp, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_addlsh_n (rp, vp, rp, n, 2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh_nc": {
      "start_point": [
        851,
        0
      ],
      "end_point": [
        862,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh_nc (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n\t\t  mp_size_t n, unsigned int s, mp_limb_t carry)\n{\n  mp_limb_t cy;\n\n  ASSERT (carry <= (CNST_LIMB(1) << s));\n\n  cy = refmpn_addlsh_n (rp, up, vp, n, s);\n  cy += refmpn_add_1 (rp, rp, n, carry);\n  return cy;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh1_nc": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        867,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh1_nc (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n, mp_limb_t carry)\n{\n  return refmpn_addlsh_nc (rp, up, vp, n, 1, carry);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addlsh2_nc": {
      "start_point": [
        868,
        0
      ],
      "end_point": [
        872,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addlsh2_nc (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n, mp_limb_t carry)\n{\n  return refmpn_addlsh_nc (rp, up, vp, n, 2, carry);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh_n": {
      "start_point": [
        874,
        0
      ],
      "end_point": [
        892,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n\t\t mp_size_t n, unsigned int s)\n{\n  mp_limb_t cy;\n  mp_ptr tp;\n\n  ASSERT (refmpn_overlap_fullonly_two_p (rp, up, vp, n));\n  ASSERT (n >= 1);\n  ASSERT (0 < s && s < GMP_NUMB_BITS);\n  ASSERT_MPN (up, n);\n  ASSERT_MPN (vp, n);\n\n  tp = refmpn_malloc_limbs (n);\n  cy  = mpn_lshift (tp, vp, n, s);\n  cy += mpn_sub_n (rp, up, tp, n);\n  free (tp);\n  return cy;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh1_n": {
      "start_point": [
        893,
        0
      ],
      "end_point": [
        897,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh1_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_sublsh_n (rp, up, vp, n, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh2_n": {
      "start_point": [
        898,
        0
      ],
      "end_point": [
        902,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh2_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_sublsh_n (rp, up, vp, n, 2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh_n_ip1": {
      "start_point": [
        903,
        0
      ],
      "end_point": [
        907,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh_n_ip1 (mp_ptr rp, mp_srcptr vp, mp_size_t n, unsigned int s)\n{\n  return refmpn_sublsh_n (rp, rp, vp, n, s);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh1_n_ip1": {
      "start_point": [
        908,
        0
      ],
      "end_point": [
        912,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh1_n_ip1 (mp_ptr rp, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_sublsh_n (rp, rp, vp, n, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh2_n_ip1": {
      "start_point": [
        913,
        0
      ],
      "end_point": [
        917,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh2_n_ip1 (mp_ptr rp, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_sublsh_n (rp, rp, vp, n, 2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh_n_ip2": {
      "start_point": [
        918,
        0
      ],
      "end_point": [
        922,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh_n_ip2 (mp_ptr rp, mp_srcptr vp, mp_size_t n, unsigned int s)\n{\n  return refmpn_sublsh_n (rp, vp, rp, n, s);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh1_n_ip2": {
      "start_point": [
        923,
        0
      ],
      "end_point": [
        927,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh1_n_ip2 (mp_ptr rp, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_sublsh_n (rp, vp, rp, n, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh2_n_ip2": {
      "start_point": [
        928,
        0
      ],
      "end_point": [
        932,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh2_n_ip2 (mp_ptr rp, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_sublsh_n (rp, vp, rp, n, 2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh_nc": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        944,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh_nc (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n\t\t  mp_size_t n, unsigned int s, mp_limb_t carry)\n{\n  mp_limb_t cy;\n\n  ASSERT (carry <= (CNST_LIMB(1) << s));\n\n  cy = refmpn_sublsh_n (rp, up, vp, n, s);\n  cy += refmpn_sub_1 (rp, rp, n, carry);\n  return cy;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh1_nc": {
      "start_point": [
        945,
        0
      ],
      "end_point": [
        949,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh1_nc (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n, mp_limb_t carry)\n{\n  return refmpn_sublsh_nc (rp, up, vp, n, 1, carry);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sublsh2_nc": {
      "start_point": [
        950,
        0
      ],
      "end_point": [
        954,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sublsh2_nc (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n, mp_limb_t carry)\n{\n  return refmpn_sublsh_nc (rp, up, vp, n, 2, carry);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_rsblsh_n": {
      "start_point": [
        956,
        0
      ],
      "end_point": [
        974,
        1
      ],
      "content": "mp_limb_signed_t\nrefmpn_rsblsh_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n\t\t mp_size_t n, unsigned int s)\n{\n  mp_limb_signed_t cy;\n  mp_ptr tp;\n\n  ASSERT (refmpn_overlap_fullonly_two_p (rp, up, vp, n));\n  ASSERT (n >= 1);\n  ASSERT (0 < s && s < GMP_NUMB_BITS);\n  ASSERT_MPN (up, n);\n  ASSERT_MPN (vp, n);\n\n  tp = refmpn_malloc_limbs (n);\n  cy  = mpn_lshift (tp, vp, n, s);\n  cy -= mpn_sub_n (rp, tp, up, n);\n  free (tp);\n  return cy;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "mp_limb_signed_t"
      ]
    },
    "refmpn_rsblsh1_n": {
      "start_point": [
        975,
        0
      ],
      "end_point": [
        979,
        1
      ],
      "content": "mp_limb_signed_t\nrefmpn_rsblsh1_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_rsblsh_n (rp, up, vp, n, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_signed_t"
      ]
    },
    "refmpn_rsblsh2_n": {
      "start_point": [
        980,
        0
      ],
      "end_point": [
        984,
        1
      ],
      "content": "mp_limb_signed_t\nrefmpn_rsblsh2_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  return refmpn_rsblsh_n (rp, up, vp, n, 2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_signed_t"
      ]
    },
    "refmpn_rsblsh_nc": {
      "start_point": [
        985,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "mp_limb_signed_t\nrefmpn_rsblsh_nc (mp_ptr rp, mp_srcptr up, mp_srcptr vp,\n\t\t  mp_size_t n, unsigned int s, mp_limb_signed_t carry)\n{\n  mp_limb_signed_t cy;\n\n  ASSERT (carry == -1 || (carry >> s) == 0);\n\n  cy = refmpn_rsblsh_n (rp, up, vp, n, s);\n  if (carry > 0)\n    cy += refmpn_add_1 (rp, rp, n, carry);\n  else\n    cy -= refmpn_sub_1 (rp, rp, n, -carry);\n  return cy;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "mp_limb_signed_t"
      ]
    },
    "refmpn_rsblsh1_nc": {
      "start_point": [
        1000,
        0
      ],
      "end_point": [
        1004,
        1
      ],
      "content": "mp_limb_signed_t\nrefmpn_rsblsh1_nc (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n, mp_limb_signed_t carry)\n{\n  return refmpn_rsblsh_nc (rp, up, vp, n, 1, carry);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_signed_t"
      ]
    },
    "refmpn_rsblsh2_nc": {
      "start_point": [
        1005,
        0
      ],
      "end_point": [
        1009,
        1
      ],
      "content": "mp_limb_signed_t\nrefmpn_rsblsh2_nc (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n, mp_limb_signed_t carry)\n{\n  return refmpn_rsblsh_nc (rp, up, vp, n, 2, carry);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_signed_t"
      ]
    },
    "refmpn_rsh1add_n": {
      "start_point": [
        1011,
        0
      ],
      "end_point": [
        1025,
        1
      ],
      "content": "mp_limb_t\nrefmpn_rsh1add_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_limb_t cya, cys;\n\n  ASSERT (refmpn_overlap_fullonly_two_p (rp, up, vp, n));\n  ASSERT (n >= 1);\n  ASSERT_MPN (up, n);\n  ASSERT_MPN (vp, n);\n\n  cya = mpn_add_n (rp, up, vp, n);\n  cys = mpn_rshift (rp, rp, n, 1) >> (GMP_NUMB_BITS - 1);\n  rp[n - 1] |= cya << (GMP_NUMB_BITS - 1);\n  return cys;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_rsh1sub_n": {
      "start_point": [
        1026,
        0
      ],
      "end_point": [
        1040,
        1
      ],
      "content": "mp_limb_t\nrefmpn_rsh1sub_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  mp_limb_t cya, cys;\n\n  ASSERT (refmpn_overlap_fullonly_two_p (rp, up, vp, n));\n  ASSERT (n >= 1);\n  ASSERT_MPN (up, n);\n  ASSERT_MPN (vp, n);\n\n  cya = mpn_sub_n (rp, up, vp, n);\n  cys = mpn_rshift (rp, rp, n, 1) >> (GMP_NUMB_BITS - 1);\n  rp[n - 1] |= cya << (GMP_NUMB_BITS - 1);\n  return cys;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_neg": {
      "start_point": [
        1043,
        0
      ],
      "end_point": [
        1056,
        1
      ],
      "content": "mp_limb_t\nrefmpn_neg (mp_ptr dst, mp_srcptr src, mp_size_t size)\n{\n  mp_ptr     zeros;\n  mp_limb_t  ret;\n\n  ASSERT (size >= 1);\n\n  zeros = refmpn_malloc_limbs (size);\n  refmpn_fill (zeros, size, CNST_LIMB(0));\n  ret = refmpn_sub_n (dst, zeros, src, size);\n  free (zeros);\n  return ret;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_add": {
      "start_point": [
        1069,
        0
      ],
      "end_point": [
        1075,
        1
      ],
      "content": "mp_limb_t\nrefmpn_add (mp_ptr rp,\n\t    mp_srcptr s1p, mp_size_t s1size,\n\t    mp_srcptr s2p, mp_size_t s2size)\n{\n  AORS (refmpn_add_n, refmpn_add_1);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_sub": {
      "start_point": [
        1076,
        0
      ],
      "end_point": [
        1082,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sub (mp_ptr rp,\n\t    mp_srcptr s1p, mp_size_t s1size,\n\t    mp_srcptr s2p, mp_size_t s2size)\n{\n  AORS (refmpn_sub_n, refmpn_sub_1);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_umul_ppmm": {
      "start_point": [
        1095,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "mp_limb_t\nrefmpn_umul_ppmm (mp_limb_t *lo, mp_limb_t x, mp_limb_t y)\n{\n  mp_limb_t  hi, s;\n\n  *lo = LOWPART(x) * LOWPART(y);\n  hi = HIGHPART(x) * HIGHPART(y);\n\n  s = LOWPART(x) * HIGHPART(y);\n  hi += HIGHPART(s);\n  s = SHIFTHIGH(LOWPART(s));\n  *lo += s;\n  hi += (*lo < s);\n\n  s = HIGHPART(x) * LOWPART(y);\n  hi += HIGHPART(s);\n  s = SHIFTHIGH(LOWPART(s));\n  *lo += s;\n  hi += (*lo < s);\n\n  return hi;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_umul_ppmm_r": {
      "start_point": [
        1118,
        0
      ],
      "end_point": [
        1122,
        1
      ],
      "content": "mp_limb_t\nrefmpn_umul_ppmm_r (mp_limb_t x, mp_limb_t y, mp_limb_t *lo)\n{\n  return refmpn_umul_ppmm (lo, x, y);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mul_1c": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1147,
        1
      ],
      "content": "mp_limb_t\nrefmpn_mul_1c (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_limb_t multiplier,\n\t       mp_limb_t carry)\n{\n  mp_size_t  i;\n  mp_limb_t  hi, lo;\n\n  ASSERT (refmpn_overlap_low_to_high_p (rp, sp, size));\n  ASSERT (size >= 1);\n  ASSERT_MPN (sp, size);\n  ASSERT_LIMB (multiplier);\n  ASSERT_LIMB (carry);\n\n  multiplier <<= GMP_NAIL_BITS;\n  for (i = 0; i < size; i++)\n    {\n      hi = refmpn_umul_ppmm (&lo, sp[i], multiplier);\n      lo >>= GMP_NAIL_BITS;\n      ASSERT_NOCARRY (ref_addc_limb (&hi, hi, ref_addc_limb (&lo, lo, carry)));\n      rp[i] = lo;\n      carry = hi;\n    }\n  return carry;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mul_1": {
      "start_point": [
        1149,
        0
      ],
      "end_point": [
        1153,
        1
      ],
      "content": "mp_limb_t\nrefmpn_mul_1 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_limb_t multiplier)\n{\n  return refmpn_mul_1c (rp, sp, size, multiplier, CNST_LIMB(0));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mul_N": {
      "start_point": [
        1156,
        0
      ],
      "end_point": [
        1181,
        1
      ],
      "content": "mp_limb_t\nrefmpn_mul_N (mp_ptr dst, mp_srcptr src, mp_size_t size,\n\t      mp_srcptr mult, mp_size_t msize)\n{\n  mp_ptr     src_copy;\n  mp_limb_t  ret;\n  mp_size_t  i;\n\n  ASSERT (refmpn_overlap_fullonly_p (dst, src, size));\n  ASSERT (! refmpn_overlap_p (dst, size+msize-1, mult, msize));\n  ASSERT (size >= msize);\n  ASSERT_MPN (mult, msize);\n\n  /* in case dst==src */\n  src_copy = refmpn_malloc_limbs (size);\n  refmpn_copyi (src_copy, src, size);\n  src = src_copy;\n\n  dst[size] = refmpn_mul_1 (dst, src, size, mult[0]);\n  for (i = 1; i < msize-1; i++)\n    dst[size+i] = refmpn_addmul_1 (dst+i, src, size, mult[i]);\n  ret = refmpn_addmul_1 (dst+i, src, size, mult[i]);\n\n  free (src_copy);\n  return ret;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mul_2": {
      "start_point": [
        1183,
        0
      ],
      "end_point": [
        1187,
        1
      ],
      "content": "mp_limb_t\nrefmpn_mul_2 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_mul_N (rp, sp, size, mult, (mp_size_t) 2);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mul_3": {
      "start_point": [
        1188,
        0
      ],
      "end_point": [
        1192,
        1
      ],
      "content": "mp_limb_t\nrefmpn_mul_3 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_mul_N (rp, sp, size, mult, (mp_size_t) 3);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mul_4": {
      "start_point": [
        1193,
        0
      ],
      "end_point": [
        1197,
        1
      ],
      "content": "mp_limb_t\nrefmpn_mul_4 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_mul_N (rp, sp, size, mult, (mp_size_t) 4);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mul_5": {
      "start_point": [
        1198,
        0
      ],
      "end_point": [
        1202,
        1
      ],
      "content": "mp_limb_t\nrefmpn_mul_5 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_mul_N (rp, sp, size, mult, (mp_size_t) 5);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mul_6": {
      "start_point": [
        1203,
        0
      ],
      "end_point": [
        1207,
        1
      ],
      "content": "mp_limb_t\nrefmpn_mul_6 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_mul_N (rp, sp, size, mult, (mp_size_t) 6);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addmul_1c": {
      "start_point": [
        1224,
        0
      ],
      "end_point": [
        1229,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addmul_1c (mp_ptr rp, mp_srcptr sp, mp_size_t size,\n\t\t  mp_limb_t multiplier, mp_limb_t carry)\n{\n  AORSMUL_1C (refmpn_add_n);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_submul_1c": {
      "start_point": [
        1230,
        0
      ],
      "end_point": [
        1235,
        1
      ],
      "content": "mp_limb_t\nrefmpn_submul_1c (mp_ptr rp, mp_srcptr sp, mp_size_t size,\n\t\t  mp_limb_t multiplier, mp_limb_t carry)\n{\n  AORSMUL_1C (refmpn_sub_n);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addmul_1": {
      "start_point": [
        1238,
        0
      ],
      "end_point": [
        1242,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addmul_1 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_limb_t multiplier)\n{\n  return refmpn_addmul_1c (rp, sp, size, multiplier, CNST_LIMB(0));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_submul_1": {
      "start_point": [
        1243,
        0
      ],
      "end_point": [
        1247,
        1
      ],
      "content": "mp_limb_t\nrefmpn_submul_1 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_limb_t multiplier)\n{\n  return refmpn_submul_1c (rp, sp, size, multiplier, CNST_LIMB(0));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addmul_N": {
      "start_point": [
        1250,
        0
      ],
      "end_point": [
        1274,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addmul_N (mp_ptr dst, mp_srcptr src, mp_size_t size,\n\t\t mp_srcptr mult, mp_size_t msize)\n{\n  mp_ptr     src_copy;\n  mp_limb_t  ret;\n  mp_size_t  i;\n\n  ASSERT (dst == src || ! refmpn_overlap_p (dst, size+msize-1, src, size));\n  ASSERT (! refmpn_overlap_p (dst, size+msize-1, mult, msize));\n  ASSERT (size >= msize);\n  ASSERT_MPN (mult, msize);\n\n  /* in case dst==src */\n  src_copy = refmpn_malloc_limbs (size);\n  refmpn_copyi (src_copy, src, size);\n  src = src_copy;\n\n  for (i = 0; i < msize-1; i++)\n    dst[size+i] = refmpn_addmul_1 (dst+i, src, size, mult[i]);\n  ret = refmpn_addmul_1 (dst+i, src, size, mult[i]);\n\n  free (src_copy);\n  return ret;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addmul_2": {
      "start_point": [
        1276,
        0
      ],
      "end_point": [
        1280,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addmul_2 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_addmul_N (rp, sp, size, mult, (mp_size_t) 2);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addmul_3": {
      "start_point": [
        1281,
        0
      ],
      "end_point": [
        1285,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addmul_3 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_addmul_N (rp, sp, size, mult, (mp_size_t) 3);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addmul_4": {
      "start_point": [
        1286,
        0
      ],
      "end_point": [
        1290,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addmul_4 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_addmul_N (rp, sp, size, mult, (mp_size_t) 4);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addmul_5": {
      "start_point": [
        1291,
        0
      ],
      "end_point": [
        1295,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addmul_5 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_addmul_N (rp, sp, size, mult, (mp_size_t) 5);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addmul_6": {
      "start_point": [
        1296,
        0
      ],
      "end_point": [
        1300,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addmul_6 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_addmul_N (rp, sp, size, mult, (mp_size_t) 6);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addmul_7": {
      "start_point": [
        1301,
        0
      ],
      "end_point": [
        1305,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addmul_7 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_addmul_N (rp, sp, size, mult, (mp_size_t) 7);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_addmul_8": {
      "start_point": [
        1306,
        0
      ],
      "end_point": [
        1310,
        1
      ],
      "content": "mp_limb_t\nrefmpn_addmul_8 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_srcptr mult)\n{\n  return refmpn_addmul_N (rp, sp, size, mult, (mp_size_t) 8);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_add_n_sub_nc": {
      "start_point": [
        1312,
        0
      ],
      "end_point": [
        1335,
        1
      ],
      "content": "mp_limb_t\nrefmpn_add_n_sub_nc (mp_ptr r1p, mp_ptr r2p,\n\t\t  mp_srcptr s1p, mp_srcptr s2p, mp_size_t size,\n\t\t  mp_limb_t carry)\n{\n  mp_ptr p;\n  mp_limb_t acy, scy;\n\n  /* Destinations can't overlap. */\n  ASSERT (! refmpn_overlap_p (r1p, size, r2p, size));\n  ASSERT (refmpn_overlap_fullonly_two_p (r1p, s1p, s2p, size));\n  ASSERT (refmpn_overlap_fullonly_two_p (r2p, s1p, s2p, size));\n  ASSERT (size >= 1);\n\n  /* in case r1p==s1p or r1p==s2p */\n  p = refmpn_malloc_limbs (size);\n\n  acy = refmpn_add_nc (p, s1p, s2p, size, carry >> 1);\n  scy = refmpn_sub_nc (r2p, s1p, s2p, size, carry & 1);\n  refmpn_copyi (r1p, p, size);\n\n  free (p);\n  return 2 * acy + scy;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_add_n_sub_n": {
      "start_point": [
        1337,
        0
      ],
      "end_point": [
        1342,
        1
      ],
      "content": "mp_limb_t\nrefmpn_add_n_sub_n (mp_ptr r1p, mp_ptr r2p,\n\t\t mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  return refmpn_add_n_sub_nc (r1p, r2p, s1p, s2p, size, CNST_LIMB(0));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "rshift_make": {
      "start_point": [
        1347,
        0
      ],
      "end_point": [
        1355,
        1
      ],
      "content": "mp_limb_t\nrshift_make (mp_limb_t hi, mp_limb_t lo, unsigned shift)\n{\n  ASSERT (shift < GMP_NUMB_BITS);\n  if (shift == 0)\n    return lo;\n  else\n    return ((hi << (GMP_NUMB_BITS-shift)) | (lo >> shift)) & GMP_NUMB_MASK;\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "lshift_make": {
      "start_point": [
        1359,
        0
      ],
      "end_point": [
        1367,
        1
      ],
      "content": "mp_limb_t\nlshift_make (mp_limb_t hi, mp_limb_t lo, unsigned shift)\n{\n  ASSERT (shift < GMP_NUMB_BITS);\n  if (shift == 0)\n    return hi;\n  else\n    return ((hi << shift) | (lo >> (GMP_NUMB_BITS-shift))) & GMP_NUMB_MASK;\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_rshift": {
      "start_point": [
        1370,
        0
      ],
      "end_point": [
        1388,
        1
      ],
      "content": "mp_limb_t\nrefmpn_rshift (mp_ptr rp, mp_srcptr sp, mp_size_t size, unsigned shift)\n{\n  mp_limb_t  ret;\n  mp_size_t  i;\n\n  ASSERT (refmpn_overlap_low_to_high_p (rp, sp, size));\n  ASSERT (size >= 1);\n  ASSERT (shift >= 1 && shift < GMP_NUMB_BITS);\n  ASSERT_MPN (sp, size);\n\n  ret = rshift_make (sp[0], CNST_LIMB(0), shift);\n\n  for (i = 0; i < size-1; i++)\n    rp[i] = rshift_make (sp[i+1], sp[i], shift);\n\n  rp[i] = rshift_make (CNST_LIMB(0), sp[i], shift);\n  return ret;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_lshift": {
      "start_point": [
        1390,
        0
      ],
      "end_point": [
        1408,
        1
      ],
      "content": "mp_limb_t\nrefmpn_lshift (mp_ptr rp, mp_srcptr sp, mp_size_t size, unsigned shift)\n{\n  mp_limb_t  ret;\n  mp_size_t  i;\n\n  ASSERT (refmpn_overlap_high_to_low_p (rp, sp, size));\n  ASSERT (size >= 1);\n  ASSERT (shift >= 1 && shift < GMP_NUMB_BITS);\n  ASSERT_MPN (sp, size);\n\n  ret = lshift_make (CNST_LIMB(0), sp[size-1], shift);\n\n  for (i = size-2; i >= 0; i--)\n    rp[i+1] = lshift_make (sp[i+1], sp[i], shift);\n\n  rp[i+1] = lshift_make (sp[i+1], CNST_LIMB(0), shift);\n  return ret;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_com": {
      "start_point": [
        1410,
        0
      ],
      "end_point": [
        1420,
        1
      ],
      "content": "void\nrefmpn_com (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  mp_size_t i;\n\n  /* We work downwards since mpn_lshiftc needs that. */\n  ASSERT (refmpn_overlap_high_to_low_p (rp, sp, size));\n\n  for (i = size - 1; i >= 0; i--)\n    rp[i] = (~sp[i]) & GMP_NUMB_MASK;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "refmpn_lshiftc": {
      "start_point": [
        1422,
        0
      ],
      "end_point": [
        1432,
        1
      ],
      "content": "mp_limb_t\nrefmpn_lshiftc (mp_ptr rp, mp_srcptr sp, mp_size_t size, unsigned shift)\n{\n  mp_limb_t res;\n\n  /* No asserts here, refmpn_lshift will assert what we need. */\n\n  res = refmpn_lshift (rp, sp, size, shift);\n  refmpn_com (rp, rp, size);\n  return res;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_rshift_or_copy": {
      "start_point": [
        1435,
        0
      ],
      "end_point": [
        1447,
        1
      ],
      "content": "mp_limb_t\nrefmpn_rshift_or_copy (mp_ptr rp, mp_srcptr sp, mp_size_t size, unsigned shift)\n{\n  if (shift == 0)\n    {\n      refmpn_copyi (rp, sp, size);\n      return 0;\n    }\n  else\n    {\n      return refmpn_rshift (rp, sp, size, shift);\n    }\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_lshift_or_copy": {
      "start_point": [
        1448,
        0
      ],
      "end_point": [
        1460,
        1
      ],
      "content": "mp_limb_t\nrefmpn_lshift_or_copy (mp_ptr rp, mp_srcptr sp, mp_size_t size, unsigned shift)\n{\n  if (shift == 0)\n    {\n      refmpn_copyd (rp, sp, size);\n      return 0;\n    }\n  else\n    {\n      return refmpn_lshift (rp, sp, size, shift);\n    }\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_rshift_or_copy_any": {
      "start_point": [
        1463,
        0
      ],
      "end_point": [
        1468,
        1
      ],
      "content": "mp_limb_t\nrefmpn_rshift_or_copy_any (mp_ptr rp, mp_srcptr sp, mp_size_t size,\n\t\t\t   unsigned shift)\n{\n  return (size == 0 ? 0 : refmpn_rshift_or_copy (rp, sp, size, shift));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_lshift_or_copy_any": {
      "start_point": [
        1469,
        0
      ],
      "end_point": [
        1474,
        1
      ],
      "content": "mp_limb_t\nrefmpn_lshift_or_copy_any (mp_ptr rp, mp_srcptr sp, mp_size_t size,\n\t\t\t   unsigned shift)\n{\n  return (size == 0 ? 0 : refmpn_lshift_or_copy (rp, sp, size, shift));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_udiv_qrnnd": {
      "start_point": [
        1480,
        0
      ],
      "end_point": [
        1508,
        1
      ],
      "content": "mp_limb_t\nrefmpn_udiv_qrnnd (mp_limb_t *rp, mp_limb_t h, mp_limb_t l, mp_limb_t d)\n{\n  mp_limb_t  q, r;\n  int  n;\n\n  ASSERT (d != 0);\n  ASSERT (h < d);\n\n#if 0\n  udiv_qrnnd (q, r, h, l, d);\n  *rp = r;\n  return q;\n#endif\n\n  n = refmpn_count_leading_zeros (d);\n  d <<= n;\n\n  if (n != 0)\n    {\n      h = (h << n) | (l >> (GMP_LIMB_BITS - n));\n      l <<= n;\n    }\n\n  __udiv_qrnnd_c (q, r, h, l, d);\n  r >>= n;\n  *rp = r;\n  return q;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_udiv_qrnnd_r": {
      "start_point": [
        1510,
        0
      ],
      "end_point": [
        1514,
        1
      ],
      "content": "mp_limb_t\nrefmpn_udiv_qrnnd_r (mp_limb_t h, mp_limb_t l, mp_limb_t d, mp_limb_t *rp)\n{\n  return refmpn_udiv_qrnnd (rp, h, l, d);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_divmod_1c_workaround": {
      "start_point": [
        1518,
        0
      ],
      "end_point": [
        1532,
        1
      ],
      "content": "static mp_limb_t\nrefmpn_divmod_1c_workaround (mp_ptr rp, mp_srcptr sp, mp_size_t size,\n\t\t\t     mp_limb_t divisor, mp_limb_t carry)\n{\n  mp_size_t  i;\n  mp_limb_t rem[1];\n  for (i = size-1; i >= 0; i--)\n    {\n      rp[i] = refmpn_udiv_qrnnd (rem, carry,\n\t\t\t\t sp[i] << GMP_NAIL_BITS,\n\t\t\t\t divisor << GMP_NAIL_BITS);\n      carry = *rem >> GMP_NAIL_BITS;\n    }\n  return carry;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "refmpn_divmod_1c": {
      "start_point": [
        1534,
        0
      ],
      "end_point": [
        1573,
        1
      ],
      "content": "mp_limb_t\nrefmpn_divmod_1c (mp_ptr rp, mp_srcptr sp, mp_size_t size,\n\t\t  mp_limb_t divisor, mp_limb_t carry)\n{\n  mp_ptr     sp_orig;\n  mp_ptr     prod;\n  mp_limb_t  carry_orig;\n\n  ASSERT (refmpn_overlap_fullonly_p (rp, sp, size));\n  ASSERT (size >= 0);\n  ASSERT (carry < divisor);\n  ASSERT_MPN (sp, size);\n  ASSERT_LIMB (divisor);\n  ASSERT_LIMB (carry);\n\n  if (size == 0)\n    return carry;\n\n  sp_orig = refmpn_memdup_limbs (sp, size);\n  prod = refmpn_malloc_limbs (size);\n  carry_orig = carry;\n\n  carry = refmpn_divmod_1c_workaround (rp, sp, size, divisor, carry);\n\n  /* check by multiplying back */\n#if 0\n  printf (\"size=%ld divisor=0x%lX carry=0x%lX remainder=0x%lX\\n\",\n\t  size, divisor, carry_orig, carry);\n  mpn_trace(\"s\",sp_copy,size);\n  mpn_trace(\"r\",rp,size);\n  printf (\"mul_1c %lX\\n\", refmpn_mul_1c (prod, rp, size, divisor, carry));\n  mpn_trace(\"p\",prod,size);\n#endif\n  ASSERT (refmpn_mul_1c (prod, rp, size, divisor, carry) == carry_orig);\n  ASSERT (refmpn_cmp (prod, sp_orig, size) == 0);\n  free (sp_orig);\n  free (prod);\n\n  return carry;\n}",
      "lines": 40,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_divmod_1": {
      "start_point": [
        1575,
        0
      ],
      "end_point": [
        1579,
        1
      ],
      "content": "mp_limb_t\nrefmpn_divmod_1 (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_limb_t divisor)\n{\n  return refmpn_divmod_1c (rp, sp, size, divisor, CNST_LIMB(0));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mod_1c": {
      "start_point": [
        1582,
        0
      ],
      "end_point": [
        1590,
        1
      ],
      "content": "mp_limb_t\nrefmpn_mod_1c (mp_srcptr sp, mp_size_t size, mp_limb_t divisor,\n\t       mp_limb_t carry)\n{\n  mp_ptr  p = refmpn_malloc_limbs (size);\n  carry = refmpn_divmod_1c (p, sp, size, divisor, carry);\n  free (p);\n  return carry;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mod_1": {
      "start_point": [
        1592,
        0
      ],
      "end_point": [
        1596,
        1
      ],
      "content": "mp_limb_t\nrefmpn_mod_1 (mp_srcptr sp, mp_size_t size, mp_limb_t divisor)\n{\n  return refmpn_mod_1c (sp, size, divisor, CNST_LIMB(0));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_preinv_mod_1": {
      "start_point": [
        1598,
        0
      ],
      "end_point": [
        1605,
        1
      ],
      "content": "mp_limb_t\nrefmpn_preinv_mod_1 (mp_srcptr sp, mp_size_t size, mp_limb_t divisor,\n\t\t     mp_limb_t inverse)\n{\n  ASSERT (divisor & GMP_NUMB_HIGHBIT);\n  ASSERT (inverse == refmpn_invert_limb (divisor));\n  return refmpn_mod_1 (sp, size, divisor);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mod_34lsub1": {
      "start_point": [
        1609,
        0
      ],
      "end_point": [
        1614,
        1
      ],
      "content": "mp_limb_t\nrefmpn_mod_34lsub1 (mp_srcptr p, mp_size_t n)\n{\n  ASSERT ((GMP_NUMB_BITS % 4) == 0);\n  return mpn_mod_1 (p, n, (CNST_LIMB(1) << (3 * GMP_NUMB_BITS / 4)) - 1);\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_divrem_1c": {
      "start_point": [
        1617,
        0
      ],
      "end_point": [
        1632,
        1
      ],
      "content": "mp_limb_t\nrefmpn_divrem_1c (mp_ptr rp, mp_size_t xsize,\n\t\t  mp_srcptr sp, mp_size_t size, mp_limb_t divisor,\n\t\t  mp_limb_t carry)\n{\n  mp_ptr  z;\n\n  z = refmpn_malloc_limbs (xsize);\n  refmpn_fill (z, xsize, CNST_LIMB(0));\n\n  carry = refmpn_divmod_1c (rp+xsize, sp, size, divisor, carry);\n  carry = refmpn_divmod_1c (rp, z, xsize, divisor, carry);\n\n  free (z);\n  return carry;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_divrem_1": {
      "start_point": [
        1634,
        0
      ],
      "end_point": [
        1639,
        1
      ],
      "content": "mp_limb_t\nrefmpn_divrem_1 (mp_ptr rp, mp_size_t xsize,\n\t\t mp_srcptr sp, mp_size_t size, mp_limb_t divisor)\n{\n  return refmpn_divrem_1c (rp, xsize, sp, size, divisor, CNST_LIMB(0));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_preinv_divrem_1": {
      "start_point": [
        1641,
        0
      ],
      "end_point": [
        1651,
        1
      ],
      "content": "mp_limb_t\nrefmpn_preinv_divrem_1 (mp_ptr rp, mp_size_t xsize,\n\t\t\tmp_srcptr sp, mp_size_t size,\n\t\t\tmp_limb_t divisor, mp_limb_t inverse, unsigned shift)\n{\n  ASSERT (size >= 0);\n  ASSERT (shift == refmpn_count_leading_zeros (divisor));\n  ASSERT (inverse == refmpn_invert_limb (divisor << shift));\n\n  return refmpn_divrem_1 (rp, xsize, sp, size, divisor);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_divrem_2": {
      "start_point": [
        1653,
        0
      ],
      "end_point": [
        1668,
        1
      ],
      "content": "mp_limb_t\nrefmpn_divrem_2 (mp_ptr qp, mp_size_t qxn,\n\t\t mp_ptr np, mp_size_t nn,\n\t\t mp_srcptr dp)\n{\n  mp_ptr tp;\n  mp_limb_t qh;\n\n  tp = refmpn_malloc_limbs (nn + qxn);\n  refmpn_zero (tp, qxn);\n  refmpn_copyi (tp + qxn, np, nn);\n  qh = refmpn_sb_div_qr (qp, tp, nn + qxn, dp, 2);\n  refmpn_copyi (np, tp, 2);\n  free (tp);\n  return qh;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_invert_limb": {
      "start_point": [
        1674,
        0
      ],
      "end_point": [
        1680,
        1
      ],
      "content": "mp_limb_t\nrefmpn_invert_limb (mp_limb_t d)\n{\n  mp_limb_t r;\n  ASSERT (d & GMP_LIMB_HIGHBIT);\n  return refmpn_udiv_qrnnd (&r, -d-1, MP_LIMB_T_MAX, d);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_invert": {
      "start_point": [
        1682,
        0
      ],
      "end_point": [
        1698,
        1
      ],
      "content": "void\nrefmpn_invert (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_ptr scratch)\n{\n  mp_ptr qp, tp;\n  TMP_DECL;\n  TMP_MARK;\n\n  tp = TMP_ALLOC_LIMBS (2 * n);\n  qp = TMP_ALLOC_LIMBS (n + 1);\n\n  MPN_ZERO (tp, 2 * n);  mpn_sub_1 (tp, tp, 2 * n, 1);\n\n  refmpn_tdiv_qr (qp, rp, 0, tp, 2 * n, up, n);\n  refmpn_copyi (rp, qp, n);\n\n  TMP_FREE;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_binvert": {
      "start_point": [
        1700,
        0
      ],
      "end_point": [
        1723,
        1
      ],
      "content": "void\nrefmpn_binvert (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_ptr scratch)\n{\n  mp_ptr tp;\n  mp_limb_t binv;\n  TMP_DECL;\n  TMP_MARK;\n\n  /* We use the library mpn_sbpi1_bdiv_q here, which isn't kosher in testing\n     code.  To make up for it, we check that the inverse is correct using a\n     multiply.  */\n\n  tp = TMP_ALLOC_LIMBS (2 * n);\n\n  MPN_ZERO (tp, n);\n  tp[0] = 1;\n  binvert_limb (binv, up[0]);\n  mpn_sbpi1_bdiv_q (rp, tp, n, up, n, -binv);\n\n  refmpn_mul_n (tp, rp, up, n);\n  ASSERT_ALWAYS (tp[0] == 1 && mpn_zero_p (tp + 1, n - 1));\n\n  TMP_FREE;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "refmpn_divexact_by3c": {
      "start_point": [
        1745,
        0
      ],
      "end_point": [
        1770,
        1
      ],
      "content": "mp_limb_t\nrefmpn_divexact_by3c (mp_ptr rp, mp_srcptr sp, mp_size_t size, mp_limb_t carry)\n{\n  mp_ptr     spcopy;\n  mp_limb_t  c, cs;\n\n  ASSERT (refmpn_overlap_fullonly_p (rp, sp, size));\n  ASSERT (size >= 1);\n  ASSERT (carry <= 2);\n  ASSERT_MPN (sp, size);\n\n  spcopy = refmpn_malloc_limbs (size);\n  cs = refmpn_sub_1 (spcopy, sp, size, carry);\n\n  for (c = 0; c <= 2; c++)\n    if (refmpn_divmod_1c (rp, spcopy, size, CNST_LIMB(3), c) == 0)\n      goto done;\n  ASSERT_FAIL (no value of c satisfies);\n\n done:\n  c += cs;\n  ASSERT (c <= 2);\n\n  free (spcopy);\n  return c;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_divexact_by3": {
      "start_point": [
        1772,
        0
      ],
      "end_point": [
        1776,
        1
      ],
      "content": "mp_limb_t\nrefmpn_divexact_by3 (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  return refmpn_divexact_by3c (rp, sp, size, CNST_LIMB(0));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_mul_basecase": {
      "start_point": [
        1780,
        0
      ],
      "end_point": [
        1797,
        1
      ],
      "content": "void\nrefmpn_mul_basecase (mp_ptr prodp,\n\t\t     mp_srcptr up, mp_size_t usize,\n\t\t     mp_srcptr vp, mp_size_t vsize)\n{\n  mp_size_t i;\n\n  ASSERT (! refmpn_overlap_p (prodp, usize+vsize, up, usize));\n  ASSERT (! refmpn_overlap_p (prodp, usize+vsize, vp, vsize));\n  ASSERT (usize >= vsize);\n  ASSERT (vsize >= 1);\n  ASSERT_MPN (up, usize);\n  ASSERT_MPN (vp, vsize);\n\n  prodp[usize] = refmpn_mul_1 (prodp, up, usize, vp[0]);\n  for (i = 1; i < vsize; i++)\n    prodp[usize+i] = refmpn_addmul_1 (prodp+i, up, usize, vp[i]);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "refmpn_mulmid_basecase": {
      "start_point": [
        1801,
        0
      ],
      "end_point": [
        1825,
        1
      ],
      "content": "void\nrefmpn_mulmid_basecase (mp_ptr rp,\n\t\t\tmp_srcptr up, mp_size_t un,\n\t\t\tmp_srcptr vp, mp_size_t vn)\n{\n  mp_limb_t cy;\n  mp_size_t i;\n\n  ASSERT (un >= vn);\n  ASSERT (vn >= 1);\n  ASSERT (! refmpn_overlap_p (rp, un - vn + 3, up, un));\n  ASSERT (! refmpn_overlap_p (rp, un - vn + 3, vp, vn));\n  ASSERT_MPN (up, un);\n  ASSERT_MPN (vp, vn);\n\n  rp[un - vn + 1] = refmpn_mul_1 (rp, up + vn - 1, un - vn + 1, vp[0]);\n  rp[un - vn + 2] = CNST_LIMB (0);\n  for (i = 1; i < vn; i++)\n    {\n      cy = refmpn_addmul_1 (rp, up + vn - i - 1, un - vn + 1, vp[i]);\n      cy = ref_addc_limb (&rp[un - vn + 1], rp[un - vn + 1], cy);\n      cy = ref_addc_limb (&rp[un - vn + 2], rp[un - vn + 2], cy);\n      ASSERT (cy == 0);\n    }\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "refmpn_toom42_mulmid": {
      "start_point": [
        1827,
        0
      ],
      "end_point": [
        1832,
        1
      ],
      "content": "void\nrefmpn_toom42_mulmid (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n,\n\t\t      mp_ptr scratch)\n{\n  refmpn_mulmid_basecase (rp, up, 2*n - 1, vp, n);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_mulmid_n": {
      "start_point": [
        1834,
        0
      ],
      "end_point": [
        1840,
        1
      ],
      "content": "void\nrefmpn_mulmid_n (mp_ptr rp, mp_srcptr up, mp_srcptr vp, mp_size_t n)\n{\n  /* FIXME: this could be made faster by using refmpn_mul and then subtracting\n     off products near the middle product region boundary */\n  refmpn_mulmid_basecase (rp, up, 2*n - 1, vp, n);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_mulmid": {
      "start_point": [
        1842,
        0
      ],
      "end_point": [
        1849,
        1
      ],
      "content": "void\nrefmpn_mulmid (mp_ptr rp, mp_srcptr up, mp_size_t un,\n\t       mp_srcptr vp, mp_size_t vn)\n{\n  /* FIXME: this could be made faster by using refmpn_mul and then subtracting\n     off products near the middle product region boundary */\n  refmpn_mulmid_basecase (rp, up, un, vp, vn);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "refmpn_mul": {
      "start_point": [
        1862,
        0
      ],
      "end_point": [
        1921,
        1
      ],
      "content": "void\nrefmpn_mul (mp_ptr wp, mp_srcptr up, mp_size_t un, mp_srcptr vp, mp_size_t vn)\n{\n  mp_ptr tp, rp;\n  mp_size_t tn;\n\n  if (vn < TOOM3_THRESHOLD)\n    {\n      /* In the mpn_mul_basecase and toom2 ranges, use our own mul_basecase. */\n      if (vn != 0)\n\trefmpn_mul_basecase (wp, up, un, vp, vn);\n      else\n\tMPN_ZERO (wp, un);\n      return;\n    }\n\n  MPN_ZERO (wp, vn);\n  rp = refmpn_malloc_limbs (2 * vn);\n\n  if (vn < TOOM4_THRESHOLD)\n    tn = mpn_toom22_mul_itch (vn, vn);\n  else if (vn < TOOM6_THRESHOLD)\n    tn = mpn_toom33_mul_itch (vn, vn);\n  else if (vn < FFT_THRESHOLD)\n    tn = mpn_toom44_mul_itch (vn, vn);\n  else\n    tn = mpn_toom6h_mul_itch (vn, vn);\n  tp = refmpn_malloc_limbs (tn);\n\n  while (un >= vn)\n    {\n      if (vn < TOOM4_THRESHOLD)\n\t/* In the toom3 range, use mpn_toom22_mul.  */\n\tmpn_toom22_mul (rp, up, vn, vp, vn, tp);\n      else if (vn < TOOM6_THRESHOLD)\n\t/* In the toom4 range, use mpn_toom33_mul.  */\n\tmpn_toom33_mul (rp, up, vn, vp, vn, tp);\n      else if (vn < FFT_THRESHOLD)\n\t/* In the toom6 range, use mpn_toom44_mul.  */\n\tmpn_toom44_mul (rp, up, vn, vp, vn, tp);\n      else\n\t/* For the largest operands, use mpn_toom6h_mul.  */\n\tmpn_toom6h_mul (rp, up, vn, vp, vn, tp);\n\n      ASSERT_NOCARRY (refmpn_add (wp, rp, 2 * vn, wp, vn));\n      wp += vn;\n\n      up += vn;\n      un -= vn;\n    }\n\n  free (tp);\n\n  if (un != 0)\n    {\n      refmpn_mul (rp, vp, vn, up, un);\n      ASSERT_NOCARRY (refmpn_add (wp, rp, un + vn, wp, vn));\n    }\n  free (rp);\n}",
      "lines": 60,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "refmpn_mul_n": {
      "start_point": [
        1923,
        0
      ],
      "end_point": [
        1927,
        1
      ],
      "content": "void\nrefmpn_mul_n (mp_ptr prodp, mp_srcptr up, mp_srcptr vp, mp_size_t size)\n{\n  refmpn_mul (prodp, up, size, vp, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "refmpn_mullo_n": {
      "start_point": [
        1929,
        0
      ],
      "end_point": [
        1936,
        1
      ],
      "content": "void\nrefmpn_mullo_n (mp_ptr prodp, mp_srcptr up, mp_srcptr vp, mp_size_t size)\n{\n  mp_ptr tp = refmpn_malloc_limbs (2*size);\n  refmpn_mul (tp, up, size, vp, size);\n  refmpn_copyi (prodp, tp, size);\n  free (tp);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_sqr": {
      "start_point": [
        1938,
        0
      ],
      "end_point": [
        1942,
        1
      ],
      "content": "void\nrefmpn_sqr (mp_ptr dst, mp_srcptr src, mp_size_t size)\n{\n  refmpn_mul (dst, src, size, src, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "refmpn_sqrlo": {
      "start_point": [
        1944,
        0
      ],
      "end_point": [
        1948,
        1
      ],
      "content": "void\nrefmpn_sqrlo (mp_ptr dst, mp_srcptr src, mp_size_t size)\n{\n  refmpn_mullo_n (dst, src, src, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "refmpn_mul_any": {
      "start_point": [
        1951,
        0
      ],
      "end_point": [
        1979,
        1
      ],
      "content": "void\nrefmpn_mul_any (mp_ptr prodp,\n\t\t     mp_srcptr up, mp_size_t usize,\n\t\t     mp_srcptr vp, mp_size_t vsize)\n{\n  ASSERT (! refmpn_overlap_p (prodp, usize+vsize, up, usize));\n  ASSERT (! refmpn_overlap_p (prodp, usize+vsize, vp, vsize));\n  ASSERT (usize >= 0);\n  ASSERT (vsize >= 0);\n  ASSERT_MPN (up, usize);\n  ASSERT_MPN (vp, vsize);\n\n  if (usize == 0)\n    {\n      refmpn_fill (prodp, vsize, CNST_LIMB(0));\n      return;\n    }\n\n  if (vsize == 0)\n    {\n      refmpn_fill (prodp, usize, CNST_LIMB(0));\n      return;\n    }\n\n  if (usize >= vsize)\n    refmpn_mul (prodp, up, usize, vp, vsize);\n  else\n    refmpn_mul (prodp, vp, vsize, up, usize);\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "refmpn_gcd_1": {
      "start_point": [
        1982,
        0
      ],
      "end_point": [
        2019,
        1
      ],
      "content": "mp_limb_t\nrefmpn_gcd_1 (mp_srcptr xp, mp_size_t xsize, mp_limb_t y)\n{\n  mp_limb_t  x;\n  int  twos;\n\n  ASSERT (y != 0);\n  ASSERT (! refmpn_zero_p (xp, xsize));\n  ASSERT_MPN (xp, xsize);\n  ASSERT_LIMB (y);\n\n  x = refmpn_mod_1 (xp, xsize, y);\n  if (x == 0)\n    return y;\n\n  twos = 0;\n  while ((x & 1) == 0 && (y & 1) == 0)\n    {\n      x >>= 1;\n      y >>= 1;\n      twos++;\n    }\n\n  for (;;)\n    {\n      while ((x & 1) == 0)  x >>= 1;\n      while ((y & 1) == 0)  y >>= 1;\n\n      if (x < y)\n\tMP_LIMB_T_SWAP (x, y);\n\n      x -= y;\n      if (x == 0)\n\tbreak;\n    }\n\n  return y << twos;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_count_leading_zeros": {
      "start_point": [
        2023,
        0
      ],
      "end_point": [
        2036,
        1
      ],
      "content": "unsigned\nrefmpn_count_leading_zeros (mp_limb_t x)\n{\n  unsigned  n = 0;\n\n  ASSERT (x != 0);\n\n  while ((x & GMP_LIMB_HIGHBIT) == 0)\n    {\n      x <<= 1;\n      n++;\n    }\n  return n;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    },
    "refmpn_count_trailing_zeros": {
      "start_point": [
        2039,
        0
      ],
      "end_point": [
        2053,
        1
      ],
      "content": "unsigned\nrefmpn_count_trailing_zeros (mp_limb_t x)\n{\n  unsigned  n = 0;\n\n  ASSERT (x != 0);\n  ASSERT_LIMB (x);\n\n  while ((x & 1) == 0)\n    {\n      x >>= 1;\n      n++;\n    }\n  return n;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    },
    "refmpn_strip_twos": {
      "start_point": [
        2057,
        0
      ],
      "end_point": [
        2078,
        1
      ],
      "content": "mp_size_t\nrefmpn_strip_twos (mp_ptr p, mp_size_t size)\n{\n  mp_size_t  limbs;\n  unsigned   shift;\n\n  ASSERT (size >= 1);\n  ASSERT (! refmpn_zero_p (p, size));\n  ASSERT_MPN (p, size);\n\n  for (limbs = 0; p[0] == 0; limbs++)\n    {\n      refmpn_copyi (p, p+1, size-1);\n      p[size-1] = 0;\n    }\n\n  shift = refmpn_count_trailing_zeros (p[0]);\n  if (shift)\n    refmpn_rshift (p, p, size, shift);\n\n  return limbs*GMP_NUMB_BITS + shift;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "mp_size_t"
      ]
    },
    "refmpn_gcd": {
      "start_point": [
        2080,
        0
      ],
      "end_point": [
        2119,
        1
      ],
      "content": "mp_limb_t\nrefmpn_gcd (mp_ptr gp, mp_ptr xp, mp_size_t xsize, mp_ptr yp, mp_size_t ysize)\n{\n  int       cmp;\n\n  ASSERT (ysize >= 1);\n  ASSERT (xsize >= ysize);\n  ASSERT ((xp[0] & 1) != 0);\n  ASSERT ((yp[0] & 1) != 0);\n  /* ASSERT (xp[xsize-1] != 0); */  /* don't think x needs to be odd */\n  ASSERT (yp[ysize-1] != 0);\n  ASSERT (refmpn_overlap_fullonly_p (gp, xp, xsize));\n  ASSERT (refmpn_overlap_fullonly_p (gp, yp, ysize));\n  ASSERT (! refmpn_overlap_p (xp, xsize, yp, ysize));\n  if (xsize == ysize)\n    ASSERT (refmpn_msbone (xp[xsize-1]) >= refmpn_msbone (yp[ysize-1]));\n  ASSERT_MPN (xp, xsize);\n  ASSERT_MPN (yp, ysize);\n\n  refmpn_strip_twos (xp, xsize);\n  MPN_NORMALIZE (xp, xsize);\n  MPN_NORMALIZE (yp, ysize);\n\n  for (;;)\n    {\n      cmp = refmpn_cmp_twosizes (xp, xsize, yp, ysize);\n      if (cmp == 0)\n\tbreak;\n      if (cmp < 0)\n\tMPN_PTR_SWAP (xp,xsize, yp,ysize);\n\n      ASSERT_NOCARRY (refmpn_sub (xp, xp, xsize, yp, ysize));\n\n      refmpn_strip_twos (xp, xsize);\n      MPN_NORMALIZE (xp, xsize);\n    }\n\n  refmpn_copyi (gp, xp, xsize);\n  return xsize;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "ref_popc_limb": {
      "start_point": [
        2121,
        0
      ],
      "end_point": [
        2134,
        1
      ],
      "content": "unsigned long\nref_popc_limb (mp_limb_t src)\n{\n  unsigned long  count;\n  int  i;\n\n  count = 0;\n  for (i = 0; i < GMP_LIMB_BITS; i++)\n    {\n      count += (src & 1);\n      src >>= 1;\n    }\n  return count;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "refmpn_popcount": {
      "start_point": [
        2136,
        0
      ],
      "end_point": [
        2148,
        1
      ],
      "content": "unsigned long\nrefmpn_popcount (mp_srcptr sp, mp_size_t size)\n{\n  unsigned long  count = 0;\n  mp_size_t  i;\n\n  ASSERT (size >= 0);\n  ASSERT_MPN (sp, size);\n\n  for (i = 0; i < size; i++)\n    count += ref_popc_limb (sp[i]);\n  return count;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "refmpn_hamdist": {
      "start_point": [
        2150,
        0
      ],
      "end_point": [
        2168,
        1
      ],
      "content": "unsigned long\nrefmpn_hamdist (mp_srcptr s1p, mp_srcptr s2p, mp_size_t size)\n{\n  mp_ptr  d;\n  unsigned long  count;\n\n  ASSERT (size >= 0);\n  ASSERT_MPN (s1p, size);\n  ASSERT_MPN (s2p, size);\n\n  if (size == 0)\n    return 0;\n\n  d = refmpn_malloc_limbs (size);\n  refmpn_xor_n (d, s1p, s2p, size);\n  count = refmpn_popcount (d, size);\n  free (d);\n  return count;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "refmpn_mod2": {
      "start_point": [
        2172,
        0
      ],
      "end_point": [
        2206,
        1
      ],
      "content": "void\nrefmpn_mod2 (mp_limb_t r[2], const mp_limb_t a[2], const mp_limb_t d[2])\n{\n  mp_limb_t  D[2];\n  int        n;\n\n  ASSERT (! refmpn_overlap_p (r, (mp_size_t) 2, d, (mp_size_t) 2));\n  ASSERT_MPN (a, 2);\n  ASSERT_MPN (d, 2);\n\n  D[1] = d[1], D[0] = d[0];\n  r[1] = a[1], r[0] = a[0];\n  n = 0;\n\n  for (;;)\n    {\n      if (D[1] & GMP_NUMB_HIGHBIT)\n\tbreak;\n      if (refmpn_cmp (r, D, (mp_size_t) 2) <= 0)\n\tbreak;\n      refmpn_lshift (D, D, (mp_size_t) 2, 1);\n      n++;\n      ASSERT (n <= GMP_NUMB_BITS);\n    }\n\n  while (n >= 0)\n    {\n      if (refmpn_cmp (r, D, (mp_size_t) 2) >= 0)\n\tASSERT_NOCARRY (refmpn_sub_n (r, r, D, (mp_size_t) 2));\n      refmpn_rshift (D, D, (mp_size_t) 2, 1);\n      n--;\n    }\n\n  ASSERT (refmpn_cmp (r, d, (mp_size_t) 2) < 0);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "refmpn_sb_div_qr": {
      "start_point": [
        2212,
        0
      ],
      "end_point": [
        2286,
        1
      ],
      "content": "mp_limb_t\nrefmpn_sb_div_qr (mp_ptr qp,\n\t\t  mp_ptr np, mp_size_t nsize,\n\t\t  mp_srcptr dp, mp_size_t dsize)\n{\n  mp_limb_t  retval = 0;\n  mp_size_t  i;\n  mp_limb_t  d1 = dp[dsize-1];\n  mp_ptr     np_orig = refmpn_memdup_limbs (np, nsize);\n\n  ASSERT (nsize >= dsize);\n  /* ASSERT (dsize > 2); */\n  ASSERT (dsize >= 2);\n  ASSERT (dp[dsize-1] & GMP_NUMB_HIGHBIT);\n  ASSERT (! refmpn_overlap_p (qp, nsize-dsize, np, nsize) || qp+dsize >= np);\n  ASSERT_MPN (np, nsize);\n  ASSERT_MPN (dp, dsize);\n\n  i = nsize-dsize;\n  if (refmpn_cmp (np+i, dp, dsize) >= 0)\n    {\n      ASSERT_NOCARRY (refmpn_sub_n (np+i, np+i, dp, dsize));\n      retval = 1;\n    }\n\n  for (i--; i >= 0; i--)\n    {\n      mp_limb_t  n0 = np[i+dsize];\n      mp_limb_t  n1 = np[i+dsize-1];\n      mp_limb_t  q, dummy_r;\n\n      ASSERT (n0 <= d1);\n      if (n0 == d1)\n\tq = GMP_NUMB_MAX;\n      else\n\tq = refmpn_udiv_qrnnd (&dummy_r, n0, n1 << GMP_NAIL_BITS,\n\t\t\t       d1 << GMP_NAIL_BITS);\n\n      n0 -= refmpn_submul_1 (np+i, dp, dsize, q);\n      ASSERT (n0 == 0 || n0 == MP_LIMB_T_MAX);\n      if (n0)\n\t{\n\t  q--;\n\t  if (! refmpn_add_n (np+i, np+i, dp, dsize))\n\t    {\n\t      q--;\n\t      ASSERT_CARRY (refmpn_add_n (np+i, np+i, dp, dsize));\n\t    }\n\t}\n      np[i+dsize] = 0;\n\n      qp[i] = q;\n    }\n\n  /* remainder < divisor */\n#if 0\t\t/* ASSERT triggers gcc 4.2.1 bug */\n  ASSERT (refmpn_cmp (np, dp, dsize) < 0);\n#endif\n\n  /* multiply back to original */\n  {\n    mp_ptr  mp = refmpn_malloc_limbs (nsize);\n\n    refmpn_mul_any (mp, qp, nsize-dsize, dp, dsize);\n    if (retval)\n      ASSERT_NOCARRY (refmpn_add_n (mp+nsize-dsize,mp+nsize-dsize, dp, dsize));\n    ASSERT_NOCARRY (refmpn_add (mp, mp, nsize, np, dsize));\n    ASSERT (refmpn_cmp (mp, np_orig, nsize) == 0);\n\n    free (mp);\n  }\n\n  free (np_orig);\n  return retval;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_tdiv_qr": {
      "start_point": [
        2290,
        0
      ],
      "end_point": [
        2322,
        1
      ],
      "content": "void\nrefmpn_tdiv_qr (mp_ptr qp, mp_ptr rp, mp_size_t qxn,\n\t\tmp_ptr np, mp_size_t nsize,\n\t\tmp_srcptr dp, mp_size_t dsize)\n{\n  ASSERT (qxn == 0);\n  ASSERT_MPN (np, nsize);\n  ASSERT_MPN (dp, dsize);\n  ASSERT (dsize > 0);\n  ASSERT (dp[dsize-1] != 0);\n\n  if (dsize == 1)\n    {\n      rp[0] = refmpn_divmod_1 (qp, np, nsize, dp[0]);\n      return;\n    }\n  else\n    {\n      mp_ptr  n2p = refmpn_malloc_limbs (nsize+1);\n      mp_ptr  d2p = refmpn_malloc_limbs (dsize);\n      int     norm = refmpn_count_leading_zeros (dp[dsize-1]) - GMP_NAIL_BITS;\n\n      n2p[nsize] = refmpn_lshift_or_copy (n2p, np, nsize, norm);\n      ASSERT_NOCARRY (refmpn_lshift_or_copy (d2p, dp, dsize, norm));\n\n      refmpn_sb_div_qr (qp, n2p, nsize+1, d2p, dsize);\n      refmpn_rshift_or_copy (rp, n2p, dsize, norm);\n\n      /* ASSERT (refmpn_zero_p (tp+dsize, nsize-dsize)); */\n      free (n2p);\n      free (d2p);\n    }\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "refmpn_redc_1": {
      "start_point": [
        2324,
        0
      ],
      "end_point": [
        2342,
        1
      ],
      "content": "mp_limb_t\nrefmpn_redc_1 (mp_ptr rp, mp_ptr up, mp_srcptr mp, mp_size_t n, mp_limb_t invm)\n{\n  mp_size_t j;\n  mp_limb_t cy;\n\n  ASSERT_MPN (up, 2*n);\n  /* ASSERT about directed overlap rp, up */\n  /* ASSERT about overlap rp, mp */\n  /* ASSERT about overlap up, mp */\n\n  for (j = n - 1; j >= 0; j--)\n    {\n      up[0] = refmpn_addmul_1 (up, mp, n, (up[0] * invm) & GMP_NUMB_MASK);\n      up++;\n    }\n  cy = mpn_add_n (rp, up, up - n, n);\n  return cy;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_get_str": {
      "start_point": [
        2344,
        0
      ],
      "end_point": [
        2394,
        1
      ],
      "content": "size_t\nrefmpn_get_str (unsigned char *dst, int base, mp_ptr src, mp_size_t size)\n{\n  unsigned char  *d;\n  size_t  dsize;\n\n  ASSERT (size >= 0);\n  ASSERT (base >= 2);\n  ASSERT (base < numberof (mp_bases));\n  ASSERT (size == 0 || src[size-1] != 0);\n  ASSERT_MPN (src, size);\n\n  MPN_SIZEINBASE (dsize, src, size, base);\n  ASSERT (dsize >= 1);\n  ASSERT (! byte_overlap_p (dst, (mp_size_t) dsize, src, size * GMP_LIMB_BYTES));\n\n  if (size == 0)\n    {\n      dst[0] = 0;\n      return 1;\n    }\n\n  /* don't clobber input for power of 2 bases */\n  if (POW2_P (base))\n    src = refmpn_memdup_limbs (src, size);\n\n  d = dst + dsize;\n  do\n    {\n      d--;\n      ASSERT (d >= dst);\n      *d = refmpn_divrem_1 (src, (mp_size_t) 0, src, size, (mp_limb_t) base);\n      size -= (src[size-1] == 0);\n    }\n  while (size != 0);\n\n  /* Move result back and decrement dsize if we didn't generate\n     the maximum possible digits.  */\n  if (d != dst)\n    {\n      size_t i;\n      dsize -= d - dst;\n      for (i = 0; i < dsize; i++)\n\tdst[i] = d[i];\n    }\n\n  if (POW2_P (base))\n    free (src);\n\n  return dsize;\n}",
      "lines": 51,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "ref_bswap_limb": {
      "start_point": [
        2397,
        0
      ],
      "end_point": [
        2410,
        1
      ],
      "content": "mp_limb_t\nref_bswap_limb (mp_limb_t src)\n{\n  mp_limb_t  dst;\n  int        i;\n\n  dst = 0;\n  for (i = 0; i < GMP_LIMB_BYTES; i++)\n    {\n      dst = (dst << 8) + (src & 0xFF);\n      src >>= 8;\n    }\n  return dst;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_random_half": {
      "start_point": [
        2427,
        0
      ],
      "end_point": [
        2432,
        1
      ],
      "content": "mp_limb_t\nrefmpn_random_half (void)\n{\n  refmpn_random_seed = refmpn_random_seed * RAND_A + 1;\n  return (refmpn_random_seed >> GMP_LIMB_BITS/2);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_random_limb": {
      "start_point": [
        2434,
        0
      ],
      "end_point": [
        2439,
        1
      ],
      "content": "mp_limb_t\nrefmpn_random_limb (void)\n{\n  return ((refmpn_random_half () << (GMP_LIMB_BITS/2))\n\t   | refmpn_random_half ()) & GMP_NUMB_MASK;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "refmpn_random": {
      "start_point": [
        2441,
        0
      ],
      "end_point": [
        2453,
        1
      ],
      "content": "void\nrefmpn_random (mp_ptr ptr, mp_size_t size)\n{\n  mp_size_t  i;\n  if (GMP_NAIL_BITS == 0)\n    {\n      mpn_random (ptr, size);\n      return;\n    }\n\n  for (i = 0; i < size; i++)\n    ptr[i] = refmpn_random_limb ();\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpn_random2": {
      "start_point": [
        2455,
        0
      ],
      "end_point": [
        2495,
        1
      ],
      "content": "void\nrefmpn_random2 (mp_ptr ptr, mp_size_t size)\n{\n  mp_size_t  i;\n  mp_limb_t  bit, mask, limb;\n  int        run;\n\n  if (GMP_NAIL_BITS == 0)\n    {\n      mpn_random2 (ptr, size);\n      return;\n    }\n\n#define RUN_MODULUS  32\n\n  /* start with ones at a random pos in the high limb */\n  bit = CNST_LIMB(1) << (refmpn_random_half () % GMP_NUMB_BITS);\n  mask = 0;\n  run = 0;\n\n  for (i = size-1; i >= 0; i--)\n    {\n      limb = 0;\n      do\n\t{\n\t  if (run == 0)\n\t    {\n\t      run = (refmpn_random_half () % RUN_MODULUS) + 1;\n\t      mask = ~mask;\n\t    }\n\n\t  limb |= (bit & mask);\n\t  bit >>= 1;\n\t  run--;\n\t}\n      while (bit != 0);\n\n      ptr[i] = limb;\n      bit = GMP_NUMB_HIGHBIT;\n    }\n}",
      "lines": 41,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "refmpn_sqrtrem": {
      "start_point": [
        2499,
        0
      ],
      "end_point": [
        2581,
        1
      ],
      "content": "mp_size_t\nrefmpn_sqrtrem (mp_ptr sp, mp_ptr rp, mp_srcptr np, mp_size_t nsize)\n{\n  mp_ptr     tp, dp;\n  mp_size_t  ssize, talloc, tsize, dsize, ret, ilimbs;\n  unsigned   ibit;\n  long       i;\n  mp_limb_t  c;\n\n  ASSERT (nsize >= 0);\n\n  /* If n==0, then s=0 and r=0.  */\n  if (nsize == 0)\n    return 0;\n\n  ASSERT (np[nsize - 1] != 0);\n  ASSERT (rp == NULL || MPN_SAME_OR_SEPARATE_P (np, rp, nsize));\n  ASSERT (rp == NULL || ! MPN_OVERLAP_P (sp, (nsize + 1) / 2, rp, nsize));\n  ASSERT (! MPN_OVERLAP_P (sp, (nsize + 1) / 2, np, nsize));\n\n  /* root */\n  ssize = (nsize+1)/2;\n  refmpn_zero (sp, ssize);\n\n  /* the remainder so far */\n  dp = refmpn_memdup_limbs (np, nsize);\n  dsize = nsize;\n\n  /* temporary */\n  talloc = 2*ssize + 1;\n  tp = refmpn_malloc_limbs (talloc);\n\n  for (i = GMP_NUMB_BITS * ssize - 1; i >= 0; i--)\n    {\n      /* t = 2*s*2^i + 2^(2*i), being the amount s^2 will increase by if 2^i\n\t is added to it */\n\n      ilimbs = (i+1) / GMP_NUMB_BITS;\n      ibit = (i+1) % GMP_NUMB_BITS;\n      refmpn_zero (tp, ilimbs);\n      c = refmpn_lshift_or_copy (tp+ilimbs, sp, ssize, ibit);\n      tsize = ilimbs + ssize;\n      tp[tsize] = c;\n      tsize += (c != 0);\n\n      ilimbs = (2*i) / GMP_NUMB_BITS;\n      ibit = (2*i) % GMP_NUMB_BITS;\n      if (ilimbs + 1 > tsize)\n\t{\n\t  refmpn_zero_extend (tp, tsize, ilimbs + 1);\n\t  tsize = ilimbs + 1;\n\t}\n      c = refmpn_add_1 (tp+ilimbs, tp+ilimbs, tsize-ilimbs,\n\t\t\tCNST_LIMB(1) << ibit);\n      ASSERT (tsize < talloc);\n      tp[tsize] = c;\n      tsize += (c != 0);\n\n      if (refmpn_cmp_twosizes (dp, dsize, tp, tsize) >= 0)\n\t{\n\t  /* set this bit in s and subtract from the remainder */\n\t  refmpn_setbit (sp, i);\n\n\t  ASSERT_NOCARRY (refmpn_sub_n (dp, dp, tp, dsize));\n\t  dsize = refmpn_normalize (dp, dsize);\n\t}\n    }\n\n  if (rp == NULL)\n    {\n      ret = ! refmpn_zero_p (dp, dsize);\n    }\n  else\n    {\n      ASSERT (dsize == 0 || dp[dsize-1] != 0);\n      refmpn_copy (rp, dp, dsize);\n      ret = dsize;\n    }\n\n  free (dp);\n  free (tp);\n  return ret;\n}",
      "lines": 83,
      "depth": 13,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/refmpq.c": {
    "refmpq_add": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "void\nrefmpq_add (mpq_ptr w, mpq_srcptr x, mpq_srcptr y)\n{\n  mpz_mul    (mpq_numref(w), mpq_numref(x), mpq_denref(y));\n  mpz_addmul (mpq_numref(w), mpq_denref(x), mpq_numref(y));\n  mpz_mul    (mpq_denref(w), mpq_denref(x), mpq_denref(y));\n  mpq_canonicalize (w);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "refmpq_sub": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nrefmpq_sub (mpq_ptr w, mpq_srcptr x, mpq_srcptr y)\n{\n  mpz_mul    (mpq_numref(w), mpq_numref(x), mpq_denref(y));\n  mpz_submul (mpq_numref(w), mpq_denref(x), mpq_numref(y));\n  mpz_mul    (mpq_denref(w), mpq_denref(x), mpq_denref(y));\n  mpq_canonicalize (w);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/refmpz.c": {
    "refmpz_combit": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\nrefmpz_combit (mpz_ptr r, unsigned long bit)\n{\n  if (mpz_tstbit (r, bit))\n    mpz_clrbit (r, bit);\n  else\n    mpz_setbit (r, bit);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "refmpz_hamdist": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "unsigned long\nrefmpz_hamdist (mpz_srcptr x, mpz_srcptr y)\n{\n  mp_size_t      xsize, ysize, tsize;\n  mp_ptr         xp, yp;\n  unsigned long  ret;\n\n  if ((SIZ(x) < 0 && SIZ(y) >= 0)\n      || (SIZ(y) < 0 && SIZ(x) >= 0))\n    return ULONG_MAX;\n\n  xsize = ABSIZ(x);\n  ysize = ABSIZ(y);\n  tsize = MAX (xsize, ysize);\n\n  xp = refmpn_malloc_limbs (tsize);\n  refmpn_zero (xp, tsize);\n  refmpn_copy (xp, PTR(x), xsize);\n\n  yp = refmpn_malloc_limbs (tsize);\n  refmpn_zero (yp, tsize);\n  refmpn_copy (yp, PTR(y), ysize);\n\n  if (SIZ(x) < 0)\n    refmpn_neg (xp, xp, tsize);\n\n  if (SIZ(x) < 0)\n    refmpn_neg (yp, yp, tsize);\n\n  ret = refmpn_hamdist (xp, yp, tsize);\n\n  free (xp);\n  free (yp);\n  return ret;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "refmpz_kronecker": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nrefmpz_kronecker (mpz_srcptr a_orig, mpz_srcptr b_orig)\n{\n  unsigned long  twos;\n  mpz_t  a, b;\n  int    result_bit1 = 0;\n\n  if (mpz_sgn (b_orig) == 0)\n    return JACOBI_Z0 (a_orig);  /* (a/0) */\n\n  if (mpz_sgn (a_orig) == 0)\n    return JACOBI_0Z (b_orig);  /* (0/b) */\n\n  if (mpz_even_p (a_orig) && mpz_even_p (b_orig))\n    return 0;\n\n  if (mpz_cmp_ui (b_orig, 1) == 0)\n    return 1;\n\n  mpz_init_set (a, a_orig);\n  mpz_init_set (b, b_orig);\n\n  if (mpz_sgn (b) < 0)\n    {\n      result_bit1 ^= JACOBI_BSGN_ZZ_BIT1 (a, b);\n      mpz_neg (b, b);\n    }\n  if (mpz_even_p (b))\n    {\n      twos = mpz_scan1 (b, 0L);\n      mpz_tdiv_q_2exp (b, b, twos);\n      result_bit1 ^= JACOBI_TWOS_U_BIT1 (twos, PTR(a)[0]);\n    }\n\n  if (mpz_sgn (a) < 0)\n    {\n      result_bit1 ^= JACOBI_N1B_BIT1 (PTR(b)[0]);\n      mpz_neg (a, a);\n    }\n  if (mpz_even_p (a))\n    {\n      twos = mpz_scan1 (a, 0L);\n      mpz_tdiv_q_2exp (a, a, twos);\n      result_bit1 ^= JACOBI_TWOS_U_BIT1 (twos, PTR(b)[0]);\n    }\n\n  for (;;)\n    {\n      ASSERT (mpz_odd_p (a));\n      ASSERT (mpz_odd_p (b));\n      ASSERT (mpz_sgn (a) > 0);\n      ASSERT (mpz_sgn (b) > 0);\n\n      TRACE (printf (\"top\\n\");\n\t     mpz_trace (\" a\", a);\n\t     mpz_trace (\" b\", b));\n\n      if (mpz_cmp (a, b) < 0)\n\t{\n\t  TRACE (printf (\"swap\\n\"));\n\t  mpz_swap (a, b);\n\t  result_bit1 ^= JACOBI_RECIP_UU_BIT1 (PTR(a)[0], PTR(b)[0]);\n\t}\n\n      if (mpz_cmp_ui (b, 1) == 0)\n\tbreak;\n\n      mpz_sub (a, a, b);\n      TRACE (printf (\"sub\\n\");\n\t     mpz_trace (\" a\", a));\n      if (mpz_sgn (a) == 0)\n\tgoto zero;\n\n      twos = mpz_scan1 (a, 0L);\n      mpz_fdiv_q_2exp (a, a, twos);\n      TRACE (printf (\"twos %lu\\n\", twos);\n\t     mpz_trace (\" a\", a));\n      result_bit1 ^= JACOBI_TWOS_U_BIT1 (twos, PTR(b)[0]);\n    }\n\n  mpz_clear (a);\n  mpz_clear (b);\n  return JACOBI_BIT1_TO_PN (result_bit1);\n\n zero:\n  mpz_clear (a);\n  mpz_clear (b);\n  return 0;\n}",
      "lines": 89,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "refmpz_jacobi": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nrefmpz_jacobi (mpz_srcptr a, mpz_srcptr b)\n{\n  ASSERT_ALWAYS (mpz_sgn (b) > 0);\n  ASSERT_ALWAYS (mpz_odd_p (b));\n\n  return refmpz_kronecker (a, b);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "refmpz_legendre": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "int\nrefmpz_legendre (mpz_srcptr a, mpz_srcptr p)\n{\n  int res;\n\n  mpz_t r;\n  mpz_t e;\n\n  ASSERT_ALWAYS (mpz_sgn (p) > 0);\n  ASSERT_ALWAYS (mpz_odd_p (p));\n\n  mpz_init (r);\n  mpz_init (e);\n\n  mpz_fdiv_r (r, a, p);\n\n  mpz_set (e, p);\n  mpz_sub_ui (e, e, 1);\n  mpz_fdiv_q_2exp (e, e, 1);\n  mpz_powm (r, r, e, p);\n\n  /* Normalize to a more or less symmetric range around zero */\n  if (mpz_cmp (r, e) > 0)\n    mpz_sub (r, r, p);\n\n  ASSERT_ALWAYS (mpz_cmpabs_ui (r, 1) <= 0);\n\n  res = mpz_sgn (r);\n\n  mpz_clear (r);\n  mpz_clear (e);\n\n  return res;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "refmpz_kronecker_ui": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "int\nrefmpz_kronecker_ui (mpz_srcptr a, unsigned long b)\n{\n  mpz_t  bz;\n  int    ret;\n  mpz_init_set_ui (bz, b);\n  ret = refmpz_kronecker (a, bz);\n  mpz_clear (bz);\n  return ret;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "refmpz_kronecker_si": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "int\nrefmpz_kronecker_si (mpz_srcptr a, long b)\n{\n  mpz_t  bz;\n  int    ret;\n  mpz_init_set_si (bz, b);\n  ret = refmpz_kronecker (a, bz);\n  mpz_clear (bz);\n  return ret;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "refmpz_ui_kronecker": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "int\nrefmpz_ui_kronecker (unsigned long a, mpz_srcptr b)\n{\n  mpz_t  az;\n  int    ret;\n  mpz_init_set_ui (az, a);\n  ret = refmpz_kronecker (az, b);\n  mpz_clear (az);\n  return ret;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "refmpz_si_kronecker": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "int\nrefmpz_si_kronecker (long a, mpz_srcptr b)\n{\n  mpz_t  az;\n  int    ret;\n  mpz_init_set_si (az, a);\n  ret = refmpz_kronecker (az, b);\n  mpz_clear (az);\n  return ret;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "refmpz_pow_ui": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "void\nrefmpz_pow_ui (mpz_ptr w, mpz_srcptr b, unsigned long e)\n{\n  mpz_t          s, t;\n  unsigned long  i;\n\n  mpz_init_set_ui (t, 1L);\n  mpz_init_set (s, b);\n\n  if ((e & 1) != 0)\n    mpz_mul (t, t, s);\n\n  for (i = 2; i <= e; i <<= 1)\n    {\n      mpz_mul (s, s, s);\n      if ((i & e) != 0)\n\tmpz_mul (t, t, s);\n    }\n\n  mpz_set (w, t);\n\n  mpz_clear (s);\n  mpz_clear (t);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/spinner.c": {
    "spinner_signal": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "RETSIGTYPE\nspinner_signal (int signum)\n{\n  spinner_tick = 1;\n\n  if (signal (SIGALRM, spinner_signal) == SIG_ERR)\n    {\n      printf (\"spinner_signal(): Oops, cannot reinstall SIGALRM\\n\");\n      abort ();\n    }\n  alarm (1);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "RETSIGTYPE"
      ]
    },
    "spinner_init": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\nspinner_init (void)\n{\n  spinner_wanted = isatty (fileno (stdout));\n  if (spinner_wanted == -1)\n    abort ();\n\n  if (!spinner_wanted)\n    return;\n\n  if (signal (SIGALRM, spinner_signal) == SIG_ERR)\n    {\n      printf (\"(no spinner)\\r\");\n      spinner_tick = 0;\n      return;\n    }\n  alarm (1);\n\n  /* unbuffered output so the spinner will show up */\n  setbuf (stdout, NULL);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spinner": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "void\nspinner (void)\n{\n  static const char  data[] = { '|', '/', '-', '\\\\' };\n  static int         pos = 0;\n\n  char  buf[128];\n\n  SPINNER_WANTED_INIT ();\n\n  if (spinner_tick)\n    {\n      buf[0] = data[pos];\n      pos = (pos + 1) % numberof (data);\n      spinner_tick = 0;\n\n      if (spinner_count != 0)\n\t{\n\t  sprintf (buf+1, \" %lu\\r\", spinner_count);\n\t}\n      else\n\t{\n\t  buf[1] = '\\r';\n\t  buf[2] = '\\0';\n\t}\n      fputs (buf, stdout);\n    }\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/t-bswap.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nmain (void)\n{\n  mp_limb_t  src, want, got;\n  int        i;\n\n  tests_start ();\n  mp_trace_base = -16;\n\n  for (i = 0; i < 1000; i++)\n    {\n      mpn_random (&src, (mp_size_t) 1);\n\n      want = ref_bswap_limb (src);\n\n      BSWAP_LIMB (got, src);\n      if (got != want)\n        {\n          printf (\"BSWAP_LIMB wrong result\\n\");\n        error:\n          mpn_trace (\"  src \", &src,  (mp_size_t) 1);\n          mpn_trace (\"  want\", &want, (mp_size_t) 1);\n          mpn_trace (\"  got \", &got,  (mp_size_t) 1);\n          abort ();\n        }\n\n      BSWAP_LIMB_FETCH (got, &src);\n      if (got != want)\n        {\n          printf (\"BSWAP_LIMB_FETCH wrong result\\n\");\n          goto error;\n        }\n\n      BSWAP_LIMB_STORE (&got, src);\n      if (got != want)\n        {\n          printf (\"BSWAP_LIMB_STORE wrong result\\n\");\n          goto error;\n        }\n    }\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/t-constants.c": {
    "main": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int  error = 0;\n\n  CHECK_INT (GMP_LIMB_BYTES, (int) sizeof(mp_limb_t));\n  CHECK_INT (mp_bits_per_limb, GMP_LIMB_BITS);\n\n  CHECK_BITS (GMP_LIMB_BITS, mp_limb_t);\n  CHECK_BITS (BITS_PER_ULONG, unsigned long);\n\n  CHECK_HIGHBIT (GMP_LIMB_HIGHBIT, mp_limb_t,      LL(\"0x%lX\",\"0x%llX\"));\n  CHECK_HIGHBIT (ULONG_HIGHBIT,     unsigned long,  \"0x%lX\");\n  CHECK_HIGHBIT (UINT_HIGHBIT,      unsigned int,   \"0x%X\");\n  CHECK_HIGHBIT (USHRT_HIGHBIT,     unsigned short, \"0x%hX\");\n#if 0 /* Bad! */\n  CHECK_HIGHBIT (LONG_HIGHBIT,      long,           \"0x%lX\");\n  CHECK_HIGHBIT (INT_HIGHBIT,       int,            \"0x%X\");\n  CHECK_HIGHBIT (SHRT_HIGHBIT,      short,          \"0x%hX\");\n#endif\n\n#if 0 /* Bad! */\n  CHECK_MAX (LONG_MAX,      LONG_MIN,      long,           \"%ld\");\n  CHECK_MAX (INT_MAX,       INT_MIN,       int,            \"%d\");\n  CHECK_MAX (SHRT_MAX,      SHRT_MIN,      short,          \"%hd\");\n#endif\n  CHECK_MAX (ULONG_MAX,     0,             unsigned long,  \"%lu\");\n  CHECK_MAX (UINT_MAX,      0,             unsigned int,   \"%u\");\n  CHECK_MAX (USHRT_MAX,     0,             unsigned short, \"%hu\");\n#if 0 /* Bad! */\n  CHECK_MAX (MP_SIZE_T_MAX, MP_SIZE_T_MIN, mp_size_t,      SS(\"%d\",\"%ld\"));\n#endif\n\n  /* UHWtype should have at least enough bits for half a UWtype */\n  {\n    int  bits_per_UWtype, bits_per_UHWtype;\n    CALC_BITS (bits_per_UWtype,  UWtype);\n    CALC_BITS (bits_per_UHWtype, UHWtype);\n    CHECK_CONDITION (2*bits_per_UHWtype >= bits_per_UWtype);\n  }\n\n  ASSERT_ALWAYS_LIMB (MODLIMB_INVERSE_3);\n  {\n    mp_limb_t  modlimb_inverse_3_calc;\n    binvert_limb (modlimb_inverse_3_calc, CNST_LIMB(3));\n    ASSERT_ALWAYS_LIMB (modlimb_inverse_3_calc);\n    CHECK_LIMB (MODLIMB_INVERSE_3, modlimb_inverse_3_calc);\n  }\n  {\n    mp_limb_t  MODLIMB_INVERSE_3_times_3\n      = (MODLIMB_INVERSE_3 * CNST_LIMB(3)) & GMP_NUMB_MASK;\n    CHECK_LIMB (MODLIMB_INVERSE_3_times_3, CNST_LIMB(1));\n  }\n\n  {\n    mp_limb_t  hi, lo;\n    hi = refmpn_umul_ppmm (&lo, GMP_NUMB_CEIL_MAX_DIV3-1,\n                           CNST_LIMB(3) << GMP_NAIL_BITS);\n    if (! (hi < 1))\n      {\n        printf (\"GMP_NUMB_CEIL_MAX_DIV3 too big\\n\");\n        error = 1;\n      }\n    hi = refmpn_umul_ppmm (&lo, GMP_NUMB_CEIL_MAX_DIV3,\n                           CNST_LIMB(3) << GMP_NAIL_BITS);\n    if (! (hi >= 1))\n      {\n        printf (\"GMP_NUMB_CEIL_MAX_DIV3 too small\\n\");\n        error = 1;\n      }\n  }\n\n  {\n    mp_limb_t  hi, lo;\n    hi = refmpn_umul_ppmm (&lo, GMP_NUMB_CEIL_2MAX_DIV3-1,\n                           CNST_LIMB(3) << GMP_NAIL_BITS);\n    if (! (hi < 2))\n      {\n        printf (\"GMP_NUMB_CEIL_2MAX_DIV3 too big\\n\");\n        error = 1;\n      }\n    hi = refmpn_umul_ppmm (&lo, GMP_NUMB_CEIL_2MAX_DIV3,\n                           CNST_LIMB(3) << GMP_NAIL_BITS);\n    if (! (hi >= 2))\n      {\n        printf (\"GMP_NUMB_CEIL_2MAX_DIV3 too small\\n\");\n        error = 1;\n      }\n  }\n\n#ifdef PP_INVERTED\n  {\n    mp_limb_t  pp_inverted_calc;\n    invert_limb (pp_inverted_calc, PP);\n    CHECK_LIMB (PP_INVERTED, pp_inverted_calc);\n  }\n#endif\n\n  if (argc >= 2 || error)\n    {\n      int  bits;\n\n      printf (\"\\n\");\n      printf (\"After gmp.h,\\n\");\n      printf (\"  ULONG_MAX  %s\\n\", ulong_max_def);\n      printf (\"  LONG_MAX   %s\\n\", long_max_def);\n      printf (\"  UINT_MAX   %s\\n\", uint_max_def);\n      printf (\"  INT_MAX    %s\\n\", int_max_def);\n      printf (\"  USHRT_MAX  %s\\n\", ushrt_max_def);\n      printf (\"  SHRT_MAX   %s\\n\", shrt_max_def);\n      printf (\"\\n\");\n\n#ifdef _CRAY\n      printf (\"_CRAY is defined, so limits.h is being used\\n\");\n#endif\n\n      printf (\"ULONG_MAX      %lX\\n\", ULONG_MAX);\n      printf (\"ULONG_HIGHBIT  %lX\\n\", ULONG_HIGHBIT);\n      printf (\"LONG_MAX       %lX\\n\", LONG_MAX);\n      printf (\"LONG_MIN       %lX\\n\", LONG_MIN);\n\n      printf (\"UINT_MAX       %X\\n\", UINT_MAX);\n      printf (\"UINT_HIGHBIT   %X\\n\", UINT_HIGHBIT);\n      printf (\"INT_MAX        %X\\n\", INT_MAX);\n      printf (\"INT_MIN        %X\\n\", INT_MIN);\n\n      printf (\"USHRT_MAX      %X\\n\", USHRT_MAX);\n      printf (\"USHRT_HIGHBIT  %X\\n\", USHRT_HIGHBIT);\n      printf (\"SHRT_MAX       %X\\n\", SHRT_MAX);\n      printf (\"SHRT_MIN       %X\\n\", SHRT_MIN);\n\n      printf (\"\\n\");\n      printf (\"Bits\\n\");\n      CALC_BITS (bits, long);           printf (\"  long           %d\\n\", bits);\n      CALC_BITS (bits, int);            printf (\"  int            %d\\n\", bits);\n      CALC_BITS (bits, short);          printf (\"  short          %d\\n\", bits);\n      CALC_BITS (bits, unsigned long);  printf (\"  unsigned long  %d\\n\", bits);\n      CALC_BITS (bits, unsigned int);   printf (\"  unsigned int   %d\\n\", bits);\n      CALC_BITS (bits, unsigned short); printf (\"  unsigned short %d\\n\", bits);\n      CALC_BITS (bits, mp_size_t);      printf (\"  mp_size_t      %d\\n\", bits);\n    }\n\n  if (error)\n    abort ();\n\n  exit (0);\n}",
      "lines": 147,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/t-count_zeros.c": {
    "check_clz": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\ncheck_clz (int want, mp_limb_t n)\n{\n  int  got;\n  count_leading_zeros (got, n);\n  if (got != want)\n    {\n      printf        (\"count_leading_zeros wrong\\n\");\n      mp_limb_trace (\"  n    \", n);\n      printf        (\"  want %d\\n\", want);\n      printf        (\"  got  %d\\n\", got);\n      abort ();\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_ctz": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\ncheck_ctz (int want, mp_limb_t n)\n{\n  int  got;\n  count_trailing_zeros (got, n);\n  if (got != want)\n    {\n      printf (\"count_trailing_zeros wrong\\n\");\n      mpn_trace (\"  n    \", &n, (mp_size_t) 1);\n      printf    (\"  want %d\\n\", want);\n      printf    (\"  got  %d\\n\", got);\n      abort ();\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  int        i;\n\n#ifdef COUNT_LEADING_ZEROS_0\n  check_clz (COUNT_LEADING_ZEROS_0, CNST_LIMB(0));\n#endif\n\n  for (i=0; i < GMP_LIMB_BITS; i++)\n    {\n      check_clz (i, CNST_LIMB(1) << (GMP_LIMB_BITS-1-i));\n      check_ctz (i, CNST_LIMB(1) << i);\n\n      check_ctz (i, MP_LIMB_T_MAX << i);\n      check_clz (i, MP_LIMB_T_MAX >> i);\n    }\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n  mp_trace_base = 16;\n\n  check_various ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/t-hightomask.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nmain (void)\n{\n  ASSERT_ALWAYS (LIMB_HIGHBIT_TO_MASK (0) == 0);\n  ASSERT_ALWAYS (LIMB_HIGHBIT_TO_MASK (GMP_LIMB_HIGHBIT) == MP_LIMB_T_MAX);\n  ASSERT_ALWAYS (LIMB_HIGHBIT_TO_MASK (MP_LIMB_T_MAX) == MP_LIMB_T_MAX);\n  ASSERT_ALWAYS (LIMB_HIGHBIT_TO_MASK (GMP_LIMB_HIGHBIT >> 1) == 0);\n  ASSERT_ALWAYS (LIMB_HIGHBIT_TO_MASK (MP_LIMB_T_MAX >> 1) == 0);\n\n  exit (0);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/t-modlinv.c": {
    "one": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\none (mp_limb_t n)\n{\n  mp_limb_t  inv, prod;\n\n  binvert_limb (inv, n);\n  prod = (inv * n) & GMP_NUMB_MASK;\n  if (prod != 1)\n    {\n      printf (\"binvert_limb wrong\\n\");\n      mp_limb_trace (\"  n       \", n);\n      mp_limb_trace (\"  got     \", inv);\n      mp_limb_trace (\"  product \", prod);\n      abort ();\n    }\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "some": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nsome (void)\n{\n  int  i;\n  for (i = 0; i < 10000; i++)\n    one (refmpn_random_limb () | 1);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "all": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "void\nall (void)\n{\n  mp_limb_t  n;\n\n  n = 1;\n  do {\n    one (n);\n    n += 2;\n  } while (n != 1);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  if (argc >= 2 && strcmp (argv[1], \"-a\") == 0)\n    {\n      /* it's feasible to run all values on a 32-bit limb, but not a 64-bit */\n      all ();\n    }\n  else\n    {\n      some ();\n    }\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/t-parity.c": {
    "check_one": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\ncheck_one (int want, unsigned long n)\n{\n  int  got;\n  ULONG_PARITY (got, n);\n  if (got != want)\n    {\n      printf (\"ULONG_PARITY wrong\\n\");\n      printf (\"  n    %lX\\n\", n);\n      printf (\"  want %d\\n\", want);\n      printf (\"  got  %d\\n\", got);\n      abort ();\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  int  i;\n\n  check_one (0, 0L);\n  check_one (BITS_PER_ULONG & 1, ULONG_MAX);\n  check_one (0, 0x11L);\n  check_one (1, 0x111L);\n  check_one (1, 0x3111L);\n\n  for (i = 0; i < BITS_PER_ULONG; i++)\n    check_one (1, 1UL << i);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n  mp_trace_base = 16;\n\n  check_various ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/t-popc.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nmain (void)\n{\n  mp_limb_t  src, want, got;\n  int        i;\n\n  tests_start ();\n  mp_trace_base = -16;\n\n  for (i = 0; i < GMP_LIMB_BITS; i++)\n    {\n      src = CNST_LIMB(1) << i;\n      want = 1;\n\n      popc_limb (got, src);\n      if (got != want)\n        {\n        error:\n          printf (\"popc_limb wrong result\\n\");\n          mpn_trace (\"  src \", &src,  (mp_size_t) 1);\n          mpn_trace (\"  want\", &want, (mp_size_t) 1);\n          mpn_trace (\"  got \", &got,  (mp_size_t) 1);\n          abort ();\n        }\n    }\n\n  src = 0;\n  want = 0;\n  for (i = 0; i < GMP_LIMB_BITS; i++)\n    {\n      src += CNST_LIMB(1) << i;\n      want += 1;\n\n      popc_limb (got, src);\n      if (got != want)\n        {\n\t  goto error;\n        }\n    }\n\n  for (i = 0; i < 100; i++)\n    {\n      mpn_random2 (&src, (mp_size_t) 1);\n      want = ref_popc_limb (src);\n\n      popc_limb (got, src);\n      if (got != want)\n        goto error;\n    }\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 53,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/t-sub.c": {
    "check_data": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n#define M  MP_LIMB_T_MAX\n\n  static const struct {\n    mp_limb_t  want_dh,want_dl, mh,ml, sh,sl;\n  } data[] = {\n    { 0,0,  0,0,  0,0 },\n    { 0,0,  0,1,  0,1 },\n    { 0,0,  1,2,  1,2 },\n\n    { 0,1,  0,2,  0,1 },\n    { 0,M,  1,0,  0,1 },\n    { M,M,  0,0,  0,1 },\n\n    { M,M,  0,M-1,  0,M },\n    { 0,0,  0,M-1,  0,M-1 },\n    { 0,1,  0,M-1,  0,M-2 },\n  };\n  int  i;\n  mp_limb_t  got_dh, got_dl;\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      sub_ddmmss (got_dh,got_dl, data[i].mh,data[i].ml, data[i].sh,data[i].sl);\n      if (got_dh != data[i].want_dh || got_dl != data[i].want_dl)\n        {\n          printf (\"check_data wrong at data[%d]\\n\", i);\n          mp_limb_trace (\"  mh\", data[i].mh);\n          mp_limb_trace (\"  ml\", data[i].ml);\n          mp_limb_trace (\"  sh\", data[i].sh);\n          mp_limb_trace (\"  sl\", data[i].sl);\n          mp_limb_trace (\"  want dh\", data[i].want_dh);\n          mp_limb_trace (\"  want dl\", data[i].want_dl);\n          mp_limb_trace (\"  got dh \", got_dh);\n          mp_limb_trace (\"  got dl \", got_dl);\n          abort ();\n        }\n    }\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\ncheck_random (void)\n{\n  mp_limb_t  want_dh,want_dl, got_dh,got_dl, mh,ml, sh,sl;\n  int  i;\n\n  for (i = 0; i < 20; i++)\n    {\n      mh = urandom ();\n      ml = urandom ();\n      sh = urandom ();\n      sl = urandom ();\n\n      refmpn_sub_ddmmss (&want_dh,&want_dl, mh,ml, sh,sl);\n\n      sub_ddmmss (got_dh,got_dl, mh,ml, sh,sl);\n\n      if (got_dh != want_dh || got_dl != want_dl)\n        {\n          printf (\"check_data wrong at data[%d]\\n\", i);\n          mp_limb_trace (\"  mh\", mh);\n          mp_limb_trace (\"  ml\", ml);\n          mp_limb_trace (\"  sh\", sh);\n          mp_limb_trace (\"  sl\", sl);\n          mp_limb_trace (\"  want dh\", want_dh);\n          mp_limb_trace (\"  want dl\", want_dl);\n          mp_limb_trace (\"  got dh \", got_dh);\n          mp_limb_trace (\"  got dl \", got_dl);\n          abort ();\n        }\n    }\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_data ();\n  check_random ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/tests.h": {
    "ostringstream": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "class\nostringstream : public std::ostrstream {\n public:\n  string str() {\n    int  pcount = ostrstream::pcount ();\n    char *s = (char *) (*__gmp_allocate_func) (pcount + 1);\n    memcpy (s, ostrstream::str(), pcount);\n    s[pcount] = '\\0';\n    string ret = string(s);\n    (*__gmp_free_func) (s, pcount + 1);\n    return ret; }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": null
    },
    "istringstream": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "class\nistringstream : public std::istrstream {\n public:\n  istringstream (const char *s) : istrstream (s) { };\n}",
      "lines": 5,
      "depth": 10,
      "decorators": null
    }
  },
  "gmp/gmp-6.1.2/tests/trace.c": {
    "mp_trace_start": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\nmp_trace_start (const char *name)\n{\n  if (name != NULL && name[0] != '\\0')\n    printf (\"%s=\", name);\n\n  switch (ABS (mp_trace_base)) {\n  case  2: printf (\"bin:\");                         break;\n  case  8: printf (\"oct:\");                         break;\n  case 10:                                          break;\n  case 16: printf (\"0x\");                           break;\n  default: printf (\"base%d:\", ABS (mp_trace_base)); break;\n  }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "mpq_trace": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\nmpq_trace (const char *name, mpq_srcptr q)\n{\n  mp_trace_start (name);\n  if (q == NULL)\n    {\n      printf (\"NULL\\n\");\n      return;\n    }\n\n  mpq_out_str (stdout, mp_trace_base, q);\n  printf (\"\\n\");\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_trace": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\nmpz_trace (const char *name, mpz_srcptr z)\n{\n  mpq_t      q;\n  mp_limb_t  one;\n\n  if (z == NULL)\n    {\n      mpq_trace (name, NULL);\n      return;\n    }\n\n  q->_mp_num._mp_alloc = ALLOC(z);\n  q->_mp_num._mp_size = SIZ(z);\n  q->_mp_num._mp_d = PTR(z);\n\n  one = 1;\n  q->_mp_den._mp_alloc = 1;\n  q->_mp_den._mp_size = 1;\n  q->_mp_den._mp_d = &one;\n\n  mpq_trace(name, q);\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpf_trace": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nmpf_trace (const char *name, mpf_srcptr f)\n{\n  mp_trace_start (name);\n  if (f == NULL)\n    {\n      printf (\"NULL\\n\");\n      return;\n    }\n\n  mpf_out_str (stdout, ABS (mp_trace_base), 0, f);\n  printf (\"\\n\");\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_tracen": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\nmpz_tracen (const char *name, int num, mpz_srcptr z)\n{\n  if (name != NULL && name[0] != '\\0')\n    {\n      printf (name, num);\n      putchar ('=');\n    }\n  mpz_trace (NULL, z);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_trace": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\nmpn_trace (const char *name, mp_srcptr ptr, mp_size_t size)\n{\n  mpz_t  z;\n  if (ptr == NULL)\n    {\n      mpz_trace (name, NULL);\n      return;\n    }\n  MPN_NORMALIZE (ptr, size);\n  PTR(z) = (mp_ptr) ptr;\n  SIZ(z) = size;\n  ALLOC(z) = size;\n  mpz_trace (name, z);\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mp_limb_trace": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void\nmp_limb_trace (const char *name, mp_limb_t n)\n{\n#if GMP_NAIL_BITS != 0\n  mp_limb_t  a[2];\n  a[0] = n & GMP_NUMB_MASK;\n  a[1] = n >> GMP_NUMB_BITS;\n  mpn_trace (name, a, (mp_size_t) 2);\n#else\n  mpn_trace (name, &n, (mp_size_t) 1);\n#endif\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpn_tracen": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "void\nmpn_tracen (const char *name, int num, mp_srcptr ptr, mp_size_t size)\n{\n  if (name != NULL && name[0] != '\\0')\n    {\n      printf (name, num);\n      putchar ('=');\n    }\n  mpn_trace (NULL, ptr, size);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_tracea": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\nmpn_tracea (const char *name, const mp_ptr *a, int count, mp_size_t size)\n{\n  int i;\n  for (i = 0; i < count; i++)\n    mpn_tracen (name, i, a[i], size);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpn_trace_file": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "void\nmpn_trace_file (const char *filename, mp_srcptr ptr, mp_size_t size)\n{\n  FILE   *fp;\n  mpz_t  z;\n\n  fp = fopen (filename, \"w\");\n  if (fp == NULL)\n    {\n      perror (\"fopen\");\n      abort();\n    }\n\n  MPN_NORMALIZE (ptr, size);\n  PTR(z) = (mp_ptr) ptr;\n  SIZ(z) = (int) size;\n\n  mpz_out_str (fp, mp_trace_base, z);\n  fprintf (fp, \"\\n\");\n\n  if (ferror (fp) || fclose (fp) != 0)\n    {\n      printf (\"error writing %s\\n\", filename);\n      abort();\n    }\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_tracea_file": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "void\nmpn_tracea_file (const char *filename,\n                 const mp_ptr *a, int count, mp_size_t size)\n{\n  char  *s;\n  int   i;\n  TMP_DECL;\n\n  TMP_MARK;\n  s = (char *) TMP_ALLOC (strlen (filename) + 50);\n\n  for (i = 0; i < count; i++)\n    {\n      sprintf (s, \"%s%d\", filename, i);\n      mpn_trace_file (s, a[i], size);\n    }\n\n  TMP_FREE;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "byte_trace": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void\nbyte_trace (const char *name, const void *ptr, mp_size_t size)\n{\n  const char *fmt;\n  mp_size_t  i;\n\n  mp_trace_start (name);\n\n  switch (mp_trace_base) {\n  case   8: fmt = \" %o\"; break;\n  case  10: fmt = \" %d\"; break;\n  case  16: fmt = \" %x\"; break;\n  case -16: fmt = \" %X\"; break;\n  default: printf (\"Oops, unsupported base in byte_trace\\n\"); abort (); break;\n  }\n\n  for (i = 0; i < size; i++)\n    printf (fmt, (int) ((unsigned char *) ptr)[i]);\n  printf (\"\\n\");\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "byte_tracen": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "void\nbyte_tracen (const char *name, int num, const void *ptr, mp_size_t size)\n{\n  if (name != NULL && name[0] != '\\0')\n    {\n      printf (name, num);\n      putchar ('=');\n    }\n  byte_trace (NULL, ptr, size);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "d_trace": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\nd_trace (const char *name, double d)\n{\n  union {\n    double         d;\n    unsigned char  b[sizeof(double)];\n  } u;\n  int  i;\n\n  if (name != NULL && name[0] != '\\0')\n    printf (\"%s=\", name);\n\n  u.d = d;\n  printf (\"[\");\n  for (i = 0; i < sizeof (u.b); i++)\n    {\n      if (i != 0)\n        printf (\" \");\n      printf (\"%02X\", (int) u.b[i]);\n    }\n  printf (\"] %.20g\\n\", d);\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/x86check.c": {
    "calling_conventions_check": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\ncalling_conventions_check (void)\n{\n  const char  *header = \"Violated calling conventions:\\n\";\n  int  ret = 1;\n  int i;\n\n#define CHECK(callreg, regstr, value)                   \\\n  if (callreg != value)                                 \\\n    {                                                   \\\n      printf (\"%s   %s  got 0x%08X want 0x%08X\\n\",      \\\n              header, regstr, callreg, value);          \\\n      header = \"\";                                      \\\n      ret = 0;                                          \\\n    }\n\n  for (i = 0; i < 4; i++)\n    {\n      CHECK (calling_conventions_values[VAL+i], regname[i], calling_conventions_values[WANT+i]);\n    }\n\n  if (DIR_BIT (calling_conventions_values[EFLAGS]) != 0)\n    {\n      printf (\"%s   eflags dir bit  got %d want 0\\n\",\n              header, DIR_BIT (calling_conventions_values[EFLAGS]));\n      header = \"\";\n      ret = 0;\n    }\n\n  if ((calling_conventions_fenv.tag & 0xFFFF) != 0xFFFF)\n    {\n      printf (\"%s   fpu tags  got 0x%X want 0xFFFF\\n\",\n              header, calling_conventions_fenv.tag & 0xFFFF);\n      header = \"\";\n      ret = 0;\n    }\n\n  return ret;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/cxx/clocale.c": {},
  "gmp/gmp-6.1.2/tests/devel/anymul_1.c": {
    "cputime": [
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          53,
          1
        ],
        "content": "int\ncputime ()\n{\n  if (CLOCKS_PER_SEC < 100000)\n    return clock () * 1000 / CLOCKS_PER_SEC;\n  return clock () / (CLOCKS_PER_SEC / 1000);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          59,
          0
        ],
        "end_point": [
          66,
          1
        ],
        "content": "int\ncputime ()\n{\n  struct rusage rus;\n\n  getrusage (0, &rus);\n  return rus.ru_utime.tv_sec * 1000 + rus.ru_utime.tv_usec / 1000;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "main": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr s1, ref, rp;\n  mp_limb_t cy_ref, cy_try;\n  int i;\n  long t0, t;\n  unsigned int test;\n  mp_limb_t xlimb;\n  mp_size_t size;\n  double cyc;\n  unsigned int ntests;\n\n  s1 = malloc (SIZE * sizeof (mp_limb_t));\n  ref = malloc (SIZE * sizeof (mp_limb_t));\n  rp = malloc ((SIZE + 2) * sizeof (mp_limb_t));\n  rp++;\n\n  ntests = ~(unsigned) 0;\n  if (argc == 2)\n    ntests = strtol (argv[1], 0, 0);\n\n  for (test = 1; test <= ntests; test++)\n    {\n#if TIMES == 1 && ! defined (PRINT)\n      if (test % (1 + 0x80000 / (SIZE + 20)) == 0)\n\t{\n\t  printf (\"\\r%u\", test);\n\t  fflush (stdout);\n\t}\n#endif\n\n#ifdef PLAIN_RANDOM\n#define MPN_RANDOM mpn_random\n#else\n#define MPN_RANDOM mpn_random2\n#endif\n\n#ifdef RANDOM\n      size = random () % SIZE + 1;\n#else\n      size = SIZE;\n#endif\n\n      rp[-1] = 0x87654321;\n      rp[size] = 0x12345678;\n\n#ifdef FIXED_XLIMB\n      xlimb = FIXED_XLIMB;\n#else\n      MPN_RANDOM (&xlimb, 1);\n#endif\n\n#if TIMES != 1\n      mpn_random (s1, size);\n      mpn_random (rp, size);\n\n      MPN_COPY (ref, rp, size);\n      t0 = cputime();\n      for (i = 0; i < TIMES; i++)\n\tfunc (ref, s1, size, xlimb);\n      t = cputime() - t0;\n      cyc = ((double) t * CLOCK) / (TIMES * size * 1000.0);\n      printf (funcname \":    %5ldms (%.3f cycles/limb) [%.2f Gb/s]\\n\",\n\t      t, cyc,\n\t      CLOCK/cyc*GMP_LIMB_BITS*GMP_LIMB_BITS/1e9);\n#endif\n\n#ifndef NOCHECK\n      MPN_RANDOM (s1, size);\n#ifdef ZERO\n      memset (rp, 0, size * sizeof *rp);\n#else\n      MPN_RANDOM (rp, size);\n#endif\n#if defined (PRINT) || defined (XPRINT)\n      printf (\"xlimb=\");\n      mpn_print (&xlimb, 1);\n#endif\n#ifdef PRINT\n#ifndef OPERATION_mul_1\n      printf (\"%*s \", (int) (2 * sizeof(mp_limb_t)), \"\");\n      mpn_print (rp, size);\n#endif\n      printf (\"%*s \", (int) (2 * sizeof(mp_limb_t)), \"\");\n      mpn_print (s1, size);\n#endif\n\n      MPN_COPY (ref, rp, size);\n      cy_ref = reffunc (ref, s1, size, xlimb);\n      cy_try = func (rp, s1, size, xlimb);\n\n#ifdef PRINT\n      mpn_print (&cy_ref, 1);\n      mpn_print (ref, size);\n      mpn_print (&cy_try, 1);\n      mpn_print (rp, size);\n#endif\n\n      if (cy_ref != cy_try || mpn_cmp (ref, rp, size) != 0\n\t  || rp[-1] != 0x87654321 || rp[size] != 0x12345678)\n\t{\n\t  printf (\"\\n        ref%*s try%*s diff\\n\", LXW - 3, \"\", 2 * LXW - 6, \"\");\n\t  for (i = 0; i < size; i++)\n\t    {\n\t      printf (\"%6d: \", i);\n\t      printf (\"%0*llX \", LXW, (unsigned long long) ref[i]);\n\t      printf (\"%0*llX \", LXW, (unsigned long long) rp[i]);\n\t      print_posneg (rp[i] - ref[i]);\n\t      printf (\"\\n\");\n\t    }\n\t  printf (\"retval: \");\n\t  printf (\"%0*llX \", LXW, (unsigned long long) cy_ref);\n\t  printf (\"%0*llX \", LXW, (unsigned long long) cy_try);\n\t  print_posneg (cy_try - cy_ref);\n\t  printf (\"\\n\");\n\t  if (rp[-1] != 0x87654321)\n\t    printf (\"clobbered at low end\\n\");\n\t  if (rp[size] != 0x12345678)\n\t    printf (\"clobbered at high end\\n\");\n\t  printf (\"TEST NUMBER %u\\n\", test);\n\t  abort();\n\t}\n#endif\n    }\n  exit (0);\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "print_posneg": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "static void\nprint_posneg (mp_limb_t d)\n{\n  char buf[LXW + 2];\n  if (d == 0)\n    printf (\" %*X\", LXW, 0);\n  else if (-d < d)\n    {\n      sprintf (buf, \"%llX\", (unsigned long long) -d);\n      printf (\"%*s-%s\", LXW - (int) strlen (buf), \"\", buf);\n    }\n  else\n    {\n      sprintf (buf, \"%llX\", (unsigned long long) d);\n      printf (\"%*s+%s\", LXW - (int) strlen (buf), \"\", buf);\n    }\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_print": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static void\nmpn_print (mp_ptr p, mp_size_t size)\n{\n  mp_size_t i;\n\n  for (i = size - 1; i >= 0; i--)\n    {\n#ifdef _LONG_LONG_LIMB\n      printf (\"%0*lX%0*lX\", (int) (sizeof(mp_limb_t)),\n\t      (unsigned long) (p[i] >> (GMP_LIMB_BITS/2)),\n              (int) (sizeof(mp_limb_t)), (unsigned long) (p[i]));\n#else\n      printf (\"%0*lX\", (int) (2 * sizeof(mp_limb_t)), p[i]);\n#endif\n#ifdef SPACE\n      if (i != 0)\n\tprintf (\" \");\n#endif\n    }\n  puts (\"\");\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/devel/aors_n.c": {
    "cputime": [
      {
        "start_point": [
          64,
          0
        ],
        "end_point": [
          70,
          1
        ],
        "content": "int\ncputime ()\n{\n  if (CLOCKS_PER_SEC < 100000)\n    return clock () * 1000 / CLOCKS_PER_SEC;\n  return clock () / (CLOCKS_PER_SEC / 1000);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          76,
          0
        ],
        "end_point": [
          83,
          1
        ],
        "content": "int\ncputime ()\n{\n  struct rusage rus;\n\n  getrusage (0, &rus);\n  return rus.ru_utime.tv_sec * 1000 + rus.ru_utime.tv_usec / 1000;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "main": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr s1, s2, dx, dy;\n  mp_limb_t cyx, cyy;\n  int i;\n#if TIMES != 1\n  long t0, t;\n#endif\n  unsigned int test;\n  mp_size_t size;\n  unsigned int ntests;\n\n  s1 = malloc (SIZE * sizeof (mp_limb_t));\n  s2 = malloc (SIZE * sizeof (mp_limb_t));\n  dx = malloc ((SIZE + 2) * sizeof (mp_limb_t));\n  dy = malloc ((SIZE + 2) * sizeof (mp_limb_t));\n\n  ntests = ~(unsigned) 0;\n  if (argc == 2)\n    ntests = strtol (argv[1], 0, 0);\n\n  for (test = 1; test <= ntests; test++)\n    {\n#if TIMES == 1 && ! defined (PRINT)\n      if (test % (SIZE > 100000 ? 1 : 100000 / SIZE) == 0)\n\t{\n\t  printf (\"\\r%u\", test);\n\t  fflush (stdout);\n\t}\n#endif\n\n#ifdef RANDOM\n      size = random () % SIZE + 1;\n#else\n      size = SIZE;\n#endif\n\n      dx[0] = 0x87654321;\n      dy[0] = 0x87654321;\n      dx[size+1] = 0x12345678;\n      dy[size+1] = 0x12345678;\n\n#if TIMES != 1\n      mpn_random (s1, size);\n      mpn_random (s2, size);\n\n      t0 = cputime();\n      for (i = 0; i < TIMES; i++)\n\tfunc (dx+1, s1, s2, size);\n      t = cputime() - t0;\n      printf (funcname \":    %5ldms (%.3f cycles/limb)\\n\",\n\t      t, ((double) t * CLOCK) / (TIMES * size * 1000.0));\n#endif\n\n#ifndef NOCHECK\n      mpn_random2 (s1, size);\n      mpn_random2 (s2, size);\n\n#ifdef PRINT\n      mpn_print (s1, size);\n      mpn_print (s2, size);\n#endif\n\n      /* Put garbage in the destination.  */\n      for (i = 0; i < size; i++)\n\t{\n\t  dx[i+1] = 0xdead;\n\t  dy[i+1] = 0xbeef;\n\t}\n\n      cyx = reffunc (dx+1, s1, s2, size);\n      cyy = func (dy+1, s1, s2, size);\n\n#ifdef PRINT\n      mpn_print (&cyx, 1);\n      mpn_print (dx+1, size);\n      mpn_print (&cyy, 1);\n      mpn_print (dy+1, size);\n#endif\n\n      if (cyx != cyy || mpn_cmp (dx, dy, size+2) != 0\n\t  || dx[0] != 0x87654321 || dx[size+1] != 0x12345678)\n\t{\n\t  mp_size_t s, e;\n\t  for (s = 0;; s++)\n\t    if ((unsigned long long) (dx+1)[s] != (unsigned long long) (dy+1)[s])\n\t      break;\n\t  for (e = size - 1;; e--)\n\t    if ((unsigned long long) (dx+1)[e] != (unsigned long long) (dy+1)[e])\n\t      break;\n#ifndef PRINT\n\t  for (i = s; i <= e; i++)\n\t    {\n\t      printf (\"%6d: \", i);\n\t      printf (\"%0*llX \", LXW, (unsigned long long) (dx+1)[i]);\n\t      printf (\"%0*llX \", LXW, (unsigned long long) (dy+1)[i]);\n\t      print_posneg ((dy+1)[i] - (dx+1)[i]);\n\t      printf (\"\\n\");\n\t    }\n\t  printf (\"%6s: \", \"retval\");\n\t  printf (\"%0*llX \", LXW, (unsigned long long) cyx);\n\t  printf (\"%0*llX \", LXW, (unsigned long long) cyy);\n\t  print_posneg (cyx - cyy);\n#endif\n\t  printf (\"\\n\");\n\t  if (dy[0] != 0x87654321)\n\t    printf (\"clobbered at low end\\n\");\n\t  if (dy[size+1] != 0x12345678)\n\t    printf (\"clobbered at high end\\n\");\n\t  printf (\"TEST NUMBER %u\\n\", test);\n\t  abort();\n\t}\n#endif\n    }\n  exit (0);\n}",
      "lines": 117,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "print_posneg": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static void\nprint_posneg (mp_limb_t d)\n{\n  char buf[LXW + 2];\n  if (d == 0)\n    printf (\" %*X\", LXW, 0);\n  else if (-d < d)\n    {\n      sprintf (buf, \"%llX\", (unsigned long long) -d);\n      printf (\"%*s-%s\", LXW - (int) strlen (buf), \"\", buf);\n    }\n  else\n    {\n      sprintf (buf, \"%llX\", (unsigned long long) d);\n      printf (\"%*s+%s\", LXW - (int) strlen (buf), \"\", buf);\n    }\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_print": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static void\nmpn_print (mp_ptr p, mp_size_t size)\n{\n  mp_size_t i;\n\n  for (i = size - 1; i >= 0; i--)\n    {\n#ifdef _LONG_LONG_LIMB\n      printf (\"%0*lX%0*lX\", (int) (sizeof(mp_limb_t)),\n\t      (unsigned long) (p[i] >> (GMP_LIMB_BITS/2)),\n\t      (int) (sizeof(mp_limb_t)), (unsigned long) (p[i]));\n#else\n      printf (\"%0*lX\", (int) (2 * sizeof(mp_limb_t)), p[i]);\n#endif\n#ifdef SPACE\n      if (i != 0)\n\tprintf (\" \");\n#endif\n    }\n  puts (\"\");\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/devel/copy.c": {
    "cputime": [
      {
        "start_point": [
          40,
          0
        ],
        "end_point": [
          46,
          1
        ],
        "content": "int\ncputime ()\n{\n  if (CLOCKS_PER_SEC < 100000)\n    return clock () * 1000 / CLOCKS_PER_SEC;\n  return clock () / (CLOCKS_PER_SEC / 1000);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          59,
          1
        ],
        "content": "int\ncputime ()\n{\n  struct rusage rus;\n\n  getrusage (0, &rus);\n  return rus.ru_utime.tv_sec * 1000 + rus.ru_utime.tv_usec / 1000;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "main": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr s1, dx, dy;\n  int i;\n  long t0, t;\n  unsigned int test;\n  mp_size_t size;\n  unsigned int ntests;\n\n  s1 = malloc (SIZE * sizeof (mp_limb_t));\n  dx = malloc ((SIZE + 2) * sizeof (mp_limb_t));\n  dy = malloc ((SIZE + 2) * sizeof (mp_limb_t));\n\n  ntests = ~(unsigned) 0;\n  if (argc == 2)\n    ntests = strtol (argv[1], 0, 0);\n\n  for (test = 1; test <= ntests; test++)\n    {\n#if TIMES == 1 && ! defined (PRINT)\n      if (test % (SIZE > 100000 ? 1 : 100000 / SIZE) == 0)\n\t{\n\t  printf (\"\\r%u\", test);\n\t  fflush (stdout);\n\t}\n#endif\n\n#ifdef RANDOM\n      size = random () % SIZE + 1;\n#else\n      size = SIZE;\n#endif\n\n      dx[0] = 0x87654321;\n      dy[0] = 0x87654321;\n      dx[size+1] = 0x12345678;\n      dy[size+1] = 0x12345678;\n\n#if TIMES != 1\n      mpn_random (s1, size);\n\n      t0 = cputime();\n      for (i = 0; i < TIMES; i++)\n\tfunc (dx+1, s1, size);\n      t = cputime() - t0;\n      printf (funcname \":    %5ldms (%.3f cycles/limb)\\n\",\n\t      t, ((double) t * CLOCK) / (TIMES * size * 1000.0));\n#endif\n\n#ifndef NOCHECK\n      mpn_random2 (s1, size);\n\n#ifdef PRINT\n      mpn_print (s1, size);\n#endif\n\n      /* Put garbage in the destination.  */\n      for (i = 0; i < size; i++)\n\t{\n\t  dx[i+1] = 0xdead;\n\t  dy[i+1] = 0xbeef;\n\t}\n\n      reffunc (dx+1, s1, size);\n      func (dy+1, s1, size);\n\n#ifdef PRINT\n      mpn_print (dx+1, size);\n      mpn_print (dy+1, size);\n#endif\n\n      if (mpn_cmp (dx, dy, size+2) != 0\n\t  || dx[0] != 0x87654321 || dx[size+1] != 0x12345678)\n\t{\n\t  mp_size_t s, e;\n\t  for (s = 0;; s++)\n\t    if ((unsigned long long) (dx+1)[s] != (unsigned long long) (dy+1)[s])\n\t      break;\n\t  for (e = size - 1;; e--)\n\t    if ((unsigned long long) (dx+1)[e] != (unsigned long long) (dy+1)[e])\n\t      break;\n#ifndef PRINT\n\t  for (i = s; i <= e; i++)\n\t    {\n\t      printf (\"%6d: \", i);\n\t      printf (\"%0*llX \", LXW, (unsigned long long) (dx+1)[i]);\n\t      printf (\"%0*llX \", LXW, (unsigned long long) (dy+1)[i]);\n\t      print_posneg ((dy+1)[i] - (dx+1)[i]);\n\t      printf (\"\\n\");\n\t    }\n#endif\n\t  printf (\"\\n\");\n\t  if (dy[0] != 0x87654321)\n\t    printf (\"clobbered at low end\\n\");\n\t  if (dy[size+1] != 0x12345678)\n\t    printf (\"clobbered at high end\\n\");\n\t  printf (\"TEST NUMBER %u\\n\", test);\n\t  abort();\n\t}\n#endif\n    }\n  exit (0);\n}",
      "lines": 104,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "print_posneg": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "static void\nprint_posneg (mp_limb_t d)\n{\n  char buf[LXW + 2];\n  if (d == 0)\n    printf (\" %*X\", LXW, 0);\n  else if (-d < d)\n    {\n      sprintf (buf, \"%llX\", (unsigned long long) -d);\n      printf (\"%*s-%s\", LXW - (int) strlen (buf), \"\", buf);\n    }\n  else\n    {\n      sprintf (buf, \"%llX\", (unsigned long long) d);\n      printf (\"%*s+%s\", LXW - (int) strlen (buf), \"\", buf);\n    }\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_print": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static void\nmpn_print (mp_ptr p, mp_size_t size)\n{\n  mp_size_t i;\n\n  for (i = size - 1; i >= 0; i--)\n    {\n#ifdef _LONG_LONG_LIMB\n      printf (\"%0*lX%0*lX\", (int) (sizeof(mp_limb_t)),\n\t      (unsigned long) (p[i] >> (GMP_LIMB_BITS/2)),\n\t      (int) (sizeof(mp_limb_t)), (unsigned long) (p[i]));\n#else\n      printf (\"%0*lX\", (int) (2 * sizeof(mp_limb_t)), p[i]);\n#endif\n#ifdef SPACE\n      if (i != 0)\n\tprintf (\" \");\n#endif\n    }\n  puts (\"\");\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/devel/divmod_1.c": {
    "cputime": [
      {
        "start_point": [
          27,
          0
        ],
        "end_point": [
          33,
          1
        ],
        "content": "int\ncputime ()\n{\n  if (CLOCKS_PER_SEC < 100000)\n    return clock () * 1000 / CLOCKS_PER_SEC;\n  return clock () / (CLOCKS_PER_SEC / 1000);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          39,
          0
        ],
        "end_point": [
          46,
          1
        ],
        "content": "int\ncputime ()\n{\n  struct rusage rus;\n\n  getrusage (0, &rus);\n  return rus.ru_utime.tv_sec * 1000 + rus.ru_utime.tv_usec / 1000;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "main": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "int\nmain ()\n{\n  mp_limb_t np[SIZE];\n  mp_limb_t dx[SIZE + FSIZE + 2];\n  mp_limb_t dy[SIZE + FSIZE + 2];\n  mp_limb_t dlimb;\n  mp_size_t nn, fn;\n  mp_limb_t retx, rety;\n  int test;\n#if TIMES != 1\n  int i;\n  long t0, t;\n  double cyc;\n#endif\n\n  for (test = 0; ; test++)\n    {\n#if TIMES == 1 && ! defined (PRINT)\n      if (test % (SIZE > 100000 ? 1 : 100000 / SIZE) == 0)\n\t{\n\t  printf (\"\\r%u\", test);\n\t  fflush (stdout);\n\t}\n#endif\n\n#ifdef RANDOM\n      nn = random () % (SIZE + 1);\n      fn = random () % (FSIZE + 1);\n#else\n      nn = SIZE;\n      fn = FSIZE;\n#endif\n\n      dx[0] = 0x87654321;\n      dx[nn + fn + 1] = 0x12345678;\n      dy[0] = 0x87654321;\n      dy[nn + fn + 1] = 0x12345678;\n      mpn_random2 (np, nn);\n\n#ifdef FIXED_DLIMB\n      dlimb = FIXED_DLIMB;\n#else\n      do\n\t{\n\t  mpn_random2 (&dlimb, 1);\n#ifdef FORCE_NORM\n\t  dlimb |= GMP_NUMB_HIGHBIT;\n#endif\n#ifdef FORCE_UNNORM\n\t  dlimb &= GMP_NUMB_MAX >> 1;\n#endif\n\t}\n      while (dlimb == 0);\n#endif\n\n#if defined (PRINT) || defined (XPRINT)\n      printf (\"N=\");\n      mpn_print (np, nn);\n      printf (\"D=\");\n      mpn_print (&dlimb, 1);\n      printf (\"nn=%ld\\n\", (long) nn);\n#endif\n\n#if TIMES != 1\n      t0 = cputime();\n      for (i = 0; i < TIMES; i++)\n\tmpn_divrem_1 (dx + 1, 0L, np, nn, dlimb);\n      t = cputime() - t0;\n      cyc = ((double) t * CLOCK) / (TIMES * nn * 1000.0);\n      printf (\"mpn_divrem_1 int:    %5ldms (%.3f cycles/limb) [%.2f Gb/s]\\n\",\n\t      t, cyc,\n\t      CLOCK/cyc*GMP_LIMB_BITS*GMP_LIMB_BITS/1e9);\n      t0 = cputime();\n      for (i = 0; i < TIMES; i++)\n\tmpn_divrem_1 (dx + 1, fn, np, 0, dlimb);\n      t = cputime() - t0;\n      cyc = ((double) t * CLOCK) / (TIMES * fn * 1000.0);\n      printf (\"mpn_divrem_1 frac:   %5ldms (%.3f cycles/limb) [%.2f Gb/s]\\n\",\n\t      t, cyc,\n\t      CLOCK/cyc*GMP_LIMB_BITS*GMP_LIMB_BITS/1e9);\n#endif\n\n      retx = refmpn_divrem_1 (dx + 1, fn, np, nn, dlimb);\n      rety = mpn_divrem_1 (dy + 1, fn, np, nn, dlimb);\n\n#ifndef NOCHECK\n      if (retx != rety || mpn_cmp (dx, dy, fn + nn + 2) != 0)\n\t{\n\t  printf (\"ERROR in test %d, nn=%ld, fn=%ld\\n\", test, nn, fn);\n\t  mpn_print (np, nn);\n\t  mpn_print (&dlimb, 1);\n\t  printf (\"rq: \");\n\t  mpn_print (dx + 1, nn + fn);\n\t  printf (\"rr: %*lX\\n\", (int) (2 * sizeof(mp_limb_t)), retx);\n\t  printf (\" q: \");\n\t  mpn_print (dy + 1, nn + fn);\n\t  printf (\" r: %*lX\\n\", (int) (2 * sizeof(mp_limb_t)), rety);\n\t  if (dy[0] != 0x87654321)\n\t    printf (\"clobbered at low end %*lX\\n\", (int) (2 * sizeof(mp_limb_t)), dy[0]);\n\t  if (dy[nn + fn + 1] != 0x12345678)\n\t    printf (\"clobbered at high end\\n\");\n\t  abort ();\n\t}\n#endif\n    }\n}",
      "lines": 107,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "mpn_print": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static void\nmpn_print (mp_ptr p, mp_size_t size)\n{\n  mp_size_t i;\n\n  for (i = size - 1; i >= 0; i--)\n    {\n#ifdef _LONG_LONG_LIMB\n      printf (\"%0*lX%0*lX\", (int) (sizeof(mp_limb_t)),\n\t      (unsigned long) (p[i] >> (GMP_LIMB_BITS/2)),\n              (int) (sizeof(mp_limb_t)), (unsigned long) (p[i]));\n#else\n      printf (\"%0*lX\", (int) (2 * sizeof(mp_limb_t)), p[i]);\n#endif\n#ifdef SPACE\n      if (i != 0)\n\tprintf (\" \");\n#endif\n    }\n  puts (\"\");\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/devel/divrem.c": {
    "cputime": [
      {
        "start_point": [
          26,
          0
        ],
        "end_point": [
          32,
          1
        ],
        "content": "int\ncputime ()\n{\n  if (CLOCKS_PER_SEC < 100000)\n    return clock () * 1000 / CLOCKS_PER_SEC;\n  return clock () / (CLOCKS_PER_SEC / 1000);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          45,
          1
        ],
        "content": "int\ncputime ()\n{\n  struct rusage rus;\n\n  getrusage (0, &rus);\n  return rus.ru_utime.tv_sec * 1000 + rus.ru_utime.tv_usec / 1000;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain ()\n{\n  mp_limb_t nptr[2 * SIZE];\n  mp_limb_t dptr[2 * SIZE];\n  mp_limb_t qptr[2 * SIZE];\n  mp_limb_t pptr[2 * SIZE + 1];\n  mp_limb_t rptr[2 * SIZE];\n  mp_size_t nsize, dsize, qsize, rsize, psize;\n  int test;\n  mp_limb_t qlimb;\n\n  for (test = 0; ; test++)\n    {\n      printf (\"%d\\n\", test);\n#ifdef RANDOM\n      nsize = random () % (2 * SIZE) + 1;\n      dsize = random () % nsize + 1;\n#else\n      nsize = 2 * SIZE;\n      dsize = SIZE;\n#endif\n\n      mpn_random2 (nptr, nsize);\n      mpn_random2 (dptr, dsize);\n      dptr[dsize - 1] |= (mp_limb_t) 1 << (GMP_LIMB_BITS - 1);\n\n      MPN_COPY (rptr, nptr, nsize);\n      qlimb = mpn_divrem (qptr, (mp_size_t) 0, rptr, nsize, dptr, dsize);\n      rsize = dsize;\n      qsize = nsize - dsize;\n      qptr[qsize] = qlimb;\n      qsize += qlimb;\n      if (qsize == 0 || qsize > 2 * SIZE)\n\t{\n\t  continue;\t\t/* bogus */\n\t}\n      else\n\t{\n\t  mp_limb_t cy;\n\t  if (qsize > dsize)\n\t    mpn_mul (pptr, qptr, qsize, dptr, dsize);\n\t  else\n\t    mpn_mul (pptr, dptr, dsize, qptr, qsize);\n\t  psize = qsize + dsize;\n\t  psize -= pptr[psize - 1] == 0;\n\t  cy = mpn_add (pptr, pptr, psize, rptr, rsize);\n\t  pptr[psize] = cy;\n\t  psize += cy;\n\t}\n\n      if (nsize != psize || mpn_cmp (nptr, pptr, nsize) != 0)\n\tabort ();\n    }\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/devel/logops_n.c": {
    "cputime": [
      {
        "start_point": [
          75,
          0
        ],
        "end_point": [
          81,
          1
        ],
        "content": "int\ncputime ()\n{\n  if (CLOCKS_PER_SEC < 100000)\n    return clock () * 1000 / CLOCKS_PER_SEC;\n  return clock () / (CLOCKS_PER_SEC / 1000);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          87,
          0
        ],
        "end_point": [
          94,
          1
        ],
        "content": "int\ncputime ()\n{\n  struct rusage rus;\n\n  getrusage (0, &rus);\n  return rus.ru_utime.tv_sec * 1000 + rus.ru_utime.tv_usec / 1000;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "main": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr s1, s2, dx, dy;\n  int i;\n  long t0, t;\n  unsigned int test;\n  mp_size_t size;\n  unsigned int ntests;\n\n  s1 = malloc (SIZE * sizeof (mp_limb_t));\n  s2 = malloc (SIZE * sizeof (mp_limb_t));\n  dx = malloc ((SIZE + 2) * sizeof (mp_limb_t));\n  dy = malloc ((SIZE + 2) * sizeof (mp_limb_t));\n\n  ntests = ~(unsigned) 0;\n  if (argc == 2)\n    ntests = strtol (argv[1], 0, 0);\n\n  for (test = 1; test <= ntests; test++)\n    {\n#if TIMES == 1 && ! defined (PRINT)\n      if (test % (SIZE > 100000 ? 1 : 100000 / SIZE) == 0)\n\t{\n\t  printf (\"\\r%d\", test);\n\t  fflush (stdout);\n\t}\n#endif\n\n#ifdef RANDOM\n      size = random () % SIZE + 1;\n#else\n      size = SIZE;\n#endif\n\n      dx[0] = 0x87654321;\n      dy[0] = 0x87654321;\n      dx[size+1] = 0x12345678;\n      dy[size+1] = 0x12345678;\n\n#if TIMES != 1\n      mpn_random (s1, size);\n      mpn_random (s2, size);\n\n      t0 = cputime();\n      for (i = 0; i < TIMES; i++)\n\tfunc (dx+1, s1, s2, size);\n      t = cputime() - t0;\n      printf (funcname \":    %5ldms (%.3f cycles/limb)\\n\",\n\t      t, ((double) t * CLOCK) / (TIMES * size * 1000.0));\n#endif\n\n#ifndef NOCHECK\n      mpn_random2 (s1, size);\n      mpn_random2 (s2, size);\n\n#ifdef PRINT\n      mpn_print (s1, size);\n      mpn_print (s2, size);\n#endif\n\n      /* Put garbage in the destination.  */\n      for (i = 0; i < size; i++)\n\t{\n\t  dx[i+1] = 0xdead;\n\t  dy[i+1] = 0xbeef;\n\t}\n\n      reffunc (dx+1, s1, s2, size);\n      func (dy+1, s1, s2, size);\n#ifdef PRINT\n      mpn_print (dx+1, size);\n      mpn_print (dy+1, size);\n#endif\n      if (mpn_cmp (dx, dy, size+2) != 0\n\t  || dx[0] != 0x87654321 || dx[size+1] != 0x12345678)\n\t{\n#ifndef PRINT\n\t  mpn_print (dx+1, size);\n\t  mpn_print (dy+1, size);\n#endif\n\t  printf (\"\\n\");\n\t  if (dy[0] != 0x87654321)\n\t    printf (\"clobbered at low end\\n\");\n\t  if (dy[size+1] != 0x12345678)\n\t    printf (\"clobbered at high end\\n\");\n\t  printf (\"TEST NUMBER %u\\n\", test);\n\t  abort();\n\t}\n#endif\n    }\n  exit (0);\n}",
      "lines": 93,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "mpn_print": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static void\nmpn_print (mp_ptr p, mp_size_t size)\n{\n  mp_size_t i;\n\n  for (i = size - 1; i >= 0; i--)\n    {\n#ifdef _LONG_LONG_LIMB\n      printf (\"%0*lX%0*lX\", (int) (sizeof(mp_limb_t)),\n\t      (unsigned long) (p[i] >> (GMP_LIMB_BITS/2)),\n              (int) (sizeof(mp_limb_t)), (unsigned long) (p[i]));\n#else\n      printf (\"%0*lX\", (int) (2 * sizeof(mp_limb_t)), p[i]);\n#endif\n#ifdef SPACE\n      if (i != 0)\n\tprintf (\" \");\n#endif\n    }\n  puts (\"\");\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/devel/shift.c": {
    "cputime": [
      {
        "start_point": [
          41,
          0
        ],
        "end_point": [
          47,
          1
        ],
        "content": "int\ncputime ()\n{\n  if (CLOCKS_PER_SEC < 100000)\n    return clock () * 1000 / CLOCKS_PER_SEC;\n  return clock () / (CLOCKS_PER_SEC / 1000);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "int\ncputime ()\n{\n  struct rusage rus;\n\n  getrusage (0, &rus);\n  return rus.ru_utime.tv_sec * 1000 + rus.ru_utime.tv_usec / 1000;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr s1, dx, dy;\n  mp_limb_t cyx, cyy;\n  int i;\n  long t0, t;\n  unsigned int test;\n  int cnt = CNT;\n  mp_size_t size;\n  unsigned int ntests;\n\n  s1 = malloc (SIZE * sizeof (mp_limb_t));\n  dx = malloc ((SIZE + 2) * sizeof (mp_limb_t));\n  dy = malloc ((SIZE + 2) * sizeof (mp_limb_t));\n\n  ntests = ~(unsigned) 0;\n  if (argc == 2)\n    ntests = strtol (argv[1], 0, 0);\n\n  for (test = 1; test <= ntests; test++)\n    {\n#if TIMES == 1 && ! defined (PRINT)\n      if (test % (SIZE > 100000 ? 1 : 100000 / SIZE) == 0)\n\t{\n\t  printf (\"\\r%u\", test);\n\t  fflush (stdout);\n\t}\n#endif\n\n#if TIMES == 1\n      cnt = random () % (GMP_NUMB_BITS - 1) + 1;\n#endif\n\n#ifdef RANDOM\n      size = random () % SIZE + 1;\n#else\n      size = SIZE;\n#endif\n\n      dx[0] = 0x87654321;\n      dy[0] = 0x87654321;\n      dx[size+1] = 0x12345678;\n      dy[size+1] = 0x12345678;\n\n#if TIMES != 1\n      mpn_random (s1, size);\n\n      t0 = cputime();\n      for (i = 0; i < TIMES; i++)\n\tfunc (dx+1, s1, size, cnt);\n      t = cputime() - t0;\n      printf (funcname \":    %5ldms (%.3f cycles/limb)\\n\",\n\t      t, ((double) t * CLOCK) / (TIMES * size * 1000.0));\n#endif\n\n#ifndef NOCHECK\n      mpn_random (s1, size);\n\n#ifdef PRINT\n      printf (\"cnt=%-*d \", (int) (2 * sizeof(mp_limb_t)) - 4, cnt);\n      mpn_print (s1, size);\n#endif\n\n      /* Put garbage in the destination.  */\n      for (i = 0; i < size; i++)\n\t{\n\t  dx[i+1] = 0xdead;\n\t  dy[i+1] = 0xbeef;\n\t}\n\n      cyx = reffunc (dx+1, s1, size, cnt);\n      cyy = func (dy+1, s1, size, cnt);\n\n#ifdef PRINT\n      mpn_print (&cyx, 1);\n      mpn_print (dx+1, size);\n      mpn_print (&cyy, 1);\n      mpn_print (dy+1, size);\n#endif\n\n      if (cyx != cyy || mpn_cmp (dx, dy, size+2) != 0\n\t  || dx[0] != 0x87654321 || dx[size+1] != 0x12345678)\n\t{\n\t  mp_size_t s, e;\n\t  for (s = 0;; s++)\n\t    if ((unsigned long long) (dx+1)[s] != (unsigned long long) (dy+1)[s])\n\t      break;\n\t  for (e = size - 1;; e--)\n\t    if ((unsigned long long) (dx+1)[e] != (unsigned long long) (dy+1)[e])\n\t      break;\n#ifndef PRINT\n\t  printf (\"cnt=%-*d\\n\", (int) (2 * sizeof(mp_limb_t)) - 4, cnt);\n\t  for (i = s; i <= e; i++)\n\t    {\n\t      printf (\"%6d: \", i);\n\t      printf (\"%0*llX \", LXW, (unsigned long long) (dx+1)[i]);\n\t      printf (\"%0*llX \", LXW, (unsigned long long) (dy+1)[i]);\n\t      print_posneg ((dy+1)[i] - (dx+1)[i]);\n\t      printf (\"\\n\");\n\t    }\n\t  printf (\"%6s: \", \"retval\");\n\t  printf (\"%0*llX \", LXW, (unsigned long long) cyx);\n\t  printf (\"%0*llX \", LXW, (unsigned long long) cyy);\n\t  print_posneg (cyx - cyy);\n#endif\n\t  printf (\"\\n\");\n\t  if (dy[0] != 0x87654321)\n\t    printf (\"clobbered at low end\\n\");\n\t  if (dy[size+1] != 0x12345678)\n\t    printf (\"clobbered at high end\\n\");\n\t  printf (\"TEST NUMBER %u\\n\", test);\n\t  abort();\n\t}\n#endif\n    }\n  exit (0);\n}",
      "lines": 118,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "print_posneg": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "static void\nprint_posneg (mp_limb_t d)\n{\n  char buf[LXW + 2];\n  if (d == 0)\n    printf (\" %*X\", LXW, 0);\n  else if (-d < d)\n    {\n      sprintf (buf, \"%llX\", (unsigned long long) -d);\n      printf (\"%*s-%s\", LXW - (int) strlen (buf), \"\", buf);\n    }\n  else\n    {\n      sprintf (buf, \"%llX\", (unsigned long long) d);\n      printf (\"%*s+%s\", LXW - (int) strlen (buf), \"\", buf);\n    }\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_print": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static void\nmpn_print (mp_ptr p, mp_size_t size)\n{\n  mp_size_t i;\n\n  for (i = size - 1; i >= 0; i--)\n    {\n#ifdef _LONG_LONG_LIMB\n      printf (\"%0*lX%0*lX\", (int) (sizeof(mp_limb_t)),\n\t      (unsigned long) (p[i] >> (GMP_LIMB_BITS/2)),\n\t      (int) (sizeof(mp_limb_t)), (unsigned long) (p[i]));\n#else\n      printf (\"%0*lX\", (int) (2 * sizeof(mp_limb_t)), p[i]);\n#endif\n#ifdef SPACE\n      if (i != 0)\n\tprintf (\" \");\n#endif\n    }\n  puts (\"\");\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/devel/try.c": {
    "strerror": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "char *\nstrerror (int n)\n{\n  if (n < 0 || n >= sys_nerr)\n    return \"errno out of range\";\n  else\n    return sys_errlist[n];\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nstrerror (int n)",
        "*"
      ]
    },
    "validate_mod_34lsub1": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "void\nvalidate_mod_34lsub1 (void)\n{\n#define CNST_34LSUB1   ((CNST_LIMB(1) << (3 * (GMP_NUMB_BITS / 4))) - 1)\n\n  mp_srcptr  ptr = s[0].p;\n  int        error = 0;\n  mp_limb_t  got, got_mod, want, want_mod;\n\n  ASSERT (size >= 1);\n\n  got = fun.retval;\n  got_mod = got % CNST_34LSUB1;\n\n  want = refmpn_mod_34lsub1 (ptr, size);\n  want_mod = want % CNST_34LSUB1;\n\n  if (got_mod != want_mod)\n    {\n      gmp_printf (\"got   0x%MX reduced from 0x%MX\\n\", got_mod, got);\n      gmp_printf (\"want  0x%MX reduced from 0x%MX\\n\", want_mod, want);\n      error = 1;\n    }\n\n  if (error)\n    validate_fail ();\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "validate_divexact_1": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "void\nvalidate_divexact_1 (void)\n{\n  mp_srcptr  src = s[0].p;\n  mp_srcptr  dst = fun.d[0].p;\n  int  error = 0;\n\n  ASSERT (size >= 1);\n\n  {\n    mp_ptr     tp = refmpn_malloc_limbs (size);\n    mp_limb_t  rem;\n\n    rem = refmpn_divrem_1 (tp, 0, src, size, divisor);\n    if (rem != 0)\n      {\n\tgmp_printf (\"Remainder a%%d == 0x%MX, mpn_divexact_1 undefined\\n\", rem);\n\terror = 1;\n      }\n    if (! refmpn_equal_anynail (tp, dst, size))\n      {\n\tprintf (\"Quotient a/d wrong\\n\");\n\tmpn_trace (\"fun \", dst, size);\n\tmpn_trace (\"want\", tp, size);\n\terror = 1;\n      }\n    free (tp);\n  }\n\n  if (error)\n    validate_fail ();\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "validate_bdiv_q_1": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        474,
        1
      ],
      "content": "void\nvalidate_bdiv_q_1\n (void)\n{\n  mp_srcptr  src = s[0].p;\n  mp_srcptr  dst = fun.d[0].p;\n  int  error = 0;\n\n  ASSERT (size >= 1);\n\n  {\n    mp_ptr     tp = refmpn_malloc_limbs (size + 1);\n\n    refmpn_mul_1 (tp, dst, size, divisor);\n    /* Set ignored low bits */\n    tp[0] |= (src[0] & LOW_ZEROS_MASK (divisor));\n    if (! refmpn_equal_anynail (tp, src, size))\n      {\n\tprintf (\"Bdiv wrong: res * divisor != src (mod B^size)\\n\");\n\tmpn_trace (\"res \", dst, size);\n\tmpn_trace (\"src \", src, size);\n\terror = 1;\n      }\n    free (tp);\n  }\n\n  if (error)\n    validate_fail ();\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "validate_modexact_1c_odd": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        533,
        1
      ],
      "content": "void\nvalidate_modexact_1c_odd (void)\n{\n  mp_srcptr  ptr = s[0].p;\n  mp_limb_t  r = fun.retval;\n  int  error = 0;\n\n  ASSERT (size >= 1);\n  ASSERT (divisor & 1);\n\n  if ((r & GMP_NAIL_MASK) != 0)\n    printf (\"r has non-zero nail\\n\");\n\n  if (carry < divisor)\n    {\n      if (! (r < divisor))\n\t{\n\t  printf (\"Don't have r < divisor\\n\");\n\t  error = 1;\n\t}\n    }\n  else /* carry >= divisor */\n    {\n      if (! (r <= divisor))\n\t{\n\t  printf (\"Don't have r <= divisor\\n\");\n\t  error = 1;\n\t}\n    }\n\n  {\n    mp_limb_t  c = carry % divisor;\n    mp_ptr     tp = refmpn_malloc_limbs (size+1);\n    mp_size_t  k;\n\n    for (k = size-1; k <= size; k++)\n      {\n\t/* set {tp,size+1} to r*b^k + a - c */\n\trefmpn_copyi (tp, ptr, size);\n\ttp[size] = 0;\n\tASSERT_NOCARRY (refmpn_add_1 (tp+k, tp+k, size+1-k, r));\n\tif (refmpn_sub_1 (tp, tp, size+1, c))\n\t  ASSERT_CARRY (mpn_add_1 (tp, tp, size+1, divisor));\n\n\tif (refmpn_mod_1 (tp, size+1, divisor) == 0)\n\t  goto good_remainder;\n      }\n    printf (\"Remainder matches neither r*b^(size-1) nor r*b^size\\n\");\n    error = 1;\n\n  good_remainder:\n    free (tp);\n  }\n\n  if (error)\n    validate_fail ();\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "validate_modexact_1_odd": {
      "start_point": [
        535,
        0
      ],
      "end_point": [
        540,
        1
      ],
      "content": "void\nvalidate_modexact_1_odd (void)\n{\n  carry = 0;\n  validate_modexact_1c_odd ();\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "validate_div_qr_1_pi1": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        574,
        1
      ],
      "content": "void\nvalidate_div_qr_1_pi1 (void)\n{\n  mp_srcptr up = ref.s[0].p;\n  mp_size_t un = size;\n  mp_size_t uh = ref.s[1].p[0];\n  mp_srcptr qp = fun.d[0].p;\n  mp_limb_t r = fun.retval;\n  mp_limb_t cy;\n  int cmp;\n  mp_ptr tp;\n  if (r >= divisor)\n    {\n      gmp_printf (\"Bad remainder %Md, d = %Md\\n\", r, divisor);\n      validate_fail ();\n    }\n  tp = refmpn_malloc_limbs (un);\n  cy = refmpn_mul_1 (tp, qp, un, divisor);\n  cy += refmpn_add_1 (tp, tp, un, r);\n  if (cy != uh || refmpn_cmp (tp, up, un) != 0)\n    {\n      gmp_printf (\"Incorrect result, size %ld.\\n\"\n\t\t  \"d = %Mx, u = %Mx, %Nx\\n\"\n\t\t  \"got: r = %Mx, q = %Nx\\n\"\n\t\t  \"q d + r = %Mx, %Nx\",\n\t\t  (long) un,\n\t\t  divisor, uh, up, un,\n\t\t  r, qp, un,\n\t\t  cy, tp, un);\n      validate_fail ();\n    }\n  free (tp);\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "validate_sqrtrem": {
      "start_point": [
        577,
        0
      ],
      "end_point": [
        618,
        1
      ],
      "content": "void\nvalidate_sqrtrem (void)\n{\n  mp_srcptr  orig_ptr = s[0].p;\n  mp_size_t  orig_size = size;\n  mp_size_t  root_size = (size+1)/2;\n  mp_srcptr  root_ptr = fun.d[0].p;\n  mp_size_t  rem_size = fun.retval;\n  mp_srcptr  rem_ptr = fun.d[1].p;\n  mp_size_t  prod_size = 2*root_size;\n  mp_ptr     p;\n  int  error = 0;\n\n  if (rem_size < 0 || rem_size > size)\n    {\n      printf (\"Bad remainder size retval %ld\\n\", (long) rem_size);\n      validate_fail ();\n    }\n\n  p = refmpn_malloc_limbs (prod_size);\n\n  p[root_size] = refmpn_lshift (p, root_ptr, root_size, 1);\n  if (refmpn_cmp_twosizes (p,root_size+1, rem_ptr,rem_size) < 0)\n    {\n      printf (\"Remainder bigger than 2*root\\n\");\n      error = 1;\n    }\n\n  refmpn_sqr (p, root_ptr, root_size);\n  if (rem_size != 0)\n    refmpn_add (p, p, prod_size, rem_ptr, rem_size);\n  if (refmpn_cmp_twosizes (p,prod_size, orig_ptr,orig_size) != 0)\n    {\n      printf (\"root^2+rem != original\\n\");\n      mpn_trace (\"prod\", p, prod_size);\n      error = 1;\n    }\n  free (p);\n\n  if (error)\n    validate_fail ();\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "validate_sqrt": {
      "start_point": [
        620,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "void\nvalidate_sqrt (void)\n{\n  mp_srcptr  orig_ptr = s[0].p;\n  mp_size_t  orig_size = size;\n  mp_size_t  root_size = (size+1)/2;\n  mp_srcptr  root_ptr = fun.d[0].p;\n  int        perf_pow = (fun.retval == 0);\n  mp_size_t  prod_size = 2*root_size;\n  mp_ptr     p;\n  int  error = 0;\n\n  p = refmpn_malloc_limbs (prod_size);\n\n  refmpn_sqr (p, root_ptr, root_size);\n  MPN_NORMALIZE (p, prod_size);\n  if (refmpn_cmp_twosizes (p,prod_size, orig_ptr,orig_size) != - !perf_pow)\n    {\n      printf (\"root^2 bigger than original, or wrong return value.\\n\");\n      mpn_trace (\"prod...\", p, prod_size);\n      error = 1;\n    }\n\n  refmpn_sub (p, orig_ptr,orig_size, p,prod_size);\n  MPN_NORMALIZE (p, prod_size);\n  if (prod_size >= root_size &&\n      refmpn_sub (p, p,prod_size, root_ptr, root_size) == 0 &&\n      refmpn_cmp_twosizes (p, prod_size, root_ptr, root_size) > 0)\n    {\n      printf (\"(root+1)^2 smaller than original.\\n\");\n      mpn_trace (\"prod\", p, prod_size);\n      error = 1;\n    }\n  free (p);\n\n  if (error)\n    validate_fail ();\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "param_init": {
      "start_point": [
        729,
        0
      ],
      "end_point": [
        1481,
        1
      ],
      "content": "void\nparam_init (void)\n{\n  struct try_t  *p;\n\n#define COPY(index)  memcpy (p, &param[index], sizeof (*p))\n\n#define REFERENCE(fun)                  \\\n  p->reference = (tryfun_t) fun;        \\\n  p->reference_name = #fun\n#define VALIDATE(fun)           \\\n  p->validate = fun;            \\\n  p->validate_name = #fun\n\n\n  p = &param[TYPE_ADD_N];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->src[1] = 1;\n  REFERENCE (refmpn_add_n);\n\n  p = &param[TYPE_ADD_NC];\n  COPY (TYPE_ADD_N);\n  p->carry = CARRY_BIT;\n  REFERENCE (refmpn_add_nc);\n\n  p = &param[TYPE_SUB_N];\n  COPY (TYPE_ADD_N);\n  REFERENCE (refmpn_sub_n);\n\n  p = &param[TYPE_SUB_NC];\n  COPY (TYPE_ADD_NC);\n  REFERENCE (refmpn_sub_nc);\n\n  p = &param[TYPE_ADD];\n  COPY (TYPE_ADD_N);\n  p->size = SIZE_ALLOW_ZERO;\n  p->size2 = 1;\n  REFERENCE (refmpn_add);\n\n  p = &param[TYPE_SUB];\n  COPY (TYPE_ADD);\n  REFERENCE (refmpn_sub);\n\n\n  p = &param[TYPE_ADD_ERR1_N];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->dst[1] = 1;\n  p->src[0] = 1;\n  p->src[1] = 1;\n  p->src[2] = 1;\n  p->dst_size[1] = SIZE_2;\n  p->carry = CARRY_BIT;\n  p->overlap = OVERLAP_NOT_DST2;\n  REFERENCE (refmpn_add_err1_n);\n\n  p = &param[TYPE_SUB_ERR1_N];\n  COPY (TYPE_ADD_ERR1_N);\n  REFERENCE (refmpn_sub_err1_n);\n\n  p = &param[TYPE_ADD_ERR2_N];\n  COPY (TYPE_ADD_ERR1_N);\n  p->src[3] = 1;\n  p->dst_size[1] = SIZE_4;\n  REFERENCE (refmpn_add_err2_n);\n\n  p = &param[TYPE_SUB_ERR2_N];\n  COPY (TYPE_ADD_ERR2_N);\n  REFERENCE (refmpn_sub_err2_n);\n\n  p = &param[TYPE_ADD_ERR3_N];\n  COPY (TYPE_ADD_ERR2_N);\n  p->src[4] = 1;\n  p->dst_size[1] = SIZE_6;\n  REFERENCE (refmpn_add_err3_n);\n\n  p = &param[TYPE_SUB_ERR3_N];\n  COPY (TYPE_ADD_ERR3_N);\n  REFERENCE (refmpn_sub_err3_n);\n\n  p = &param[TYPE_ADDCND_N];\n  COPY (TYPE_ADD_N);\n  p->carry = CARRY_BIT;\n  REFERENCE (refmpn_cnd_add_n);\n\n  p = &param[TYPE_SUBCND_N];\n  COPY (TYPE_ADD_N);\n  p->carry = CARRY_BIT;\n  REFERENCE (refmpn_cnd_sub_n);\n\n\n  p = &param[TYPE_MUL_1];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->multiplier = 1;\n  p->overlap = OVERLAP_LOW_TO_HIGH;\n  REFERENCE (refmpn_mul_1);\n\n  p = &param[TYPE_MUL_1C];\n  COPY (TYPE_MUL_1);\n  p->carry = CARRY_LIMB;\n  REFERENCE (refmpn_mul_1c);\n\n\n  p = &param[TYPE_MUL_2];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->dst_size[0] = SIZE_PLUS_MSIZE_SUB_1;\n  p->src[0] = 1;\n  p->src[1] = 1;\n  p->msize = 2;\n  p->overlap = OVERLAP_NOT_SRC2;\n  REFERENCE (refmpn_mul_2);\n\n  p = &param[TYPE_MUL_3];\n  COPY (TYPE_MUL_2);\n  p->msize = 3;\n  REFERENCE (refmpn_mul_3);\n\n  p = &param[TYPE_MUL_4];\n  COPY (TYPE_MUL_2);\n  p->msize = 4;\n  REFERENCE (refmpn_mul_4);\n\n  p = &param[TYPE_MUL_5];\n  COPY (TYPE_MUL_2);\n  p->msize = 5;\n  REFERENCE (refmpn_mul_5);\n\n  p = &param[TYPE_MUL_6];\n  COPY (TYPE_MUL_2);\n  p->msize = 6;\n  REFERENCE (refmpn_mul_6);\n\n\n  p = &param[TYPE_ADDMUL_1];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->multiplier = 1;\n  p->dst0_from_src1 = 1;\n  REFERENCE (refmpn_addmul_1);\n\n  p = &param[TYPE_ADDMUL_1C];\n  COPY (TYPE_ADDMUL_1);\n  p->carry = CARRY_LIMB;\n  REFERENCE (refmpn_addmul_1c);\n\n  p = &param[TYPE_SUBMUL_1];\n  COPY (TYPE_ADDMUL_1);\n  REFERENCE (refmpn_submul_1);\n\n  p = &param[TYPE_SUBMUL_1C];\n  COPY (TYPE_ADDMUL_1C);\n  REFERENCE (refmpn_submul_1c);\n\n\n  p = &param[TYPE_ADDMUL_2];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->dst_size[0] = SIZE_PLUS_MSIZE_SUB_1;\n  p->src[0] = 1;\n  p->src[1] = 1;\n  p->msize = 2;\n  p->dst0_from_src1 = 1;\n  p->overlap = OVERLAP_NONE;\n  REFERENCE (refmpn_addmul_2);\n\n  p = &param[TYPE_ADDMUL_3];\n  COPY (TYPE_ADDMUL_2);\n  p->msize = 3;\n  REFERENCE (refmpn_addmul_3);\n\n  p = &param[TYPE_ADDMUL_4];\n  COPY (TYPE_ADDMUL_2);\n  p->msize = 4;\n  REFERENCE (refmpn_addmul_4);\n\n  p = &param[TYPE_ADDMUL_5];\n  COPY (TYPE_ADDMUL_2);\n  p->msize = 5;\n  REFERENCE (refmpn_addmul_5);\n\n  p = &param[TYPE_ADDMUL_6];\n  COPY (TYPE_ADDMUL_2);\n  p->msize = 6;\n  REFERENCE (refmpn_addmul_6);\n\n  p = &param[TYPE_ADDMUL_7];\n  COPY (TYPE_ADDMUL_2);\n  p->msize = 7;\n  REFERENCE (refmpn_addmul_7);\n\n  p = &param[TYPE_ADDMUL_8];\n  COPY (TYPE_ADDMUL_2);\n  p->msize = 8;\n  REFERENCE (refmpn_addmul_8);\n\n\n  p = &param[TYPE_AND_N];\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->src[1] = 1;\n  REFERENCE (refmpn_and_n);\n\n  p = &param[TYPE_ANDN_N];\n  COPY (TYPE_AND_N);\n  REFERENCE (refmpn_andn_n);\n\n  p = &param[TYPE_NAND_N];\n  COPY (TYPE_AND_N);\n  REFERENCE (refmpn_nand_n);\n\n  p = &param[TYPE_IOR_N];\n  COPY (TYPE_AND_N);\n  REFERENCE (refmpn_ior_n);\n\n  p = &param[TYPE_IORN_N];\n  COPY (TYPE_AND_N);\n  REFERENCE (refmpn_iorn_n);\n\n  p = &param[TYPE_NIOR_N];\n  COPY (TYPE_AND_N);\n  REFERENCE (refmpn_nior_n);\n\n  p = &param[TYPE_XOR_N];\n  COPY (TYPE_AND_N);\n  REFERENCE (refmpn_xor_n);\n\n  p = &param[TYPE_XNOR_N];\n  COPY (TYPE_AND_N);\n  REFERENCE (refmpn_xnor_n);\n\n\n  p = &param[TYPE_ADDSUB_N];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->dst[1] = 1;\n  p->src[0] = 1;\n  p->src[1] = 1;\n  REFERENCE (refmpn_add_n_sub_n);\n\n  p = &param[TYPE_ADDSUB_NC];\n  COPY (TYPE_ADDSUB_N);\n  p->carry = CARRY_4;\n  REFERENCE (refmpn_add_n_sub_nc);\n\n\n  p = &param[TYPE_COPY];\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->overlap = OVERLAP_NONE;\n  p->size = SIZE_ALLOW_ZERO;\n  REFERENCE (refmpn_copy);\n\n  p = &param[TYPE_COPYI];\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->overlap = OVERLAP_LOW_TO_HIGH;\n  p->size = SIZE_ALLOW_ZERO;\n  REFERENCE (refmpn_copyi);\n\n  p = &param[TYPE_COPYD];\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->overlap = OVERLAP_HIGH_TO_LOW;\n  p->size = SIZE_ALLOW_ZERO;\n  REFERENCE (refmpn_copyd);\n\n  p = &param[TYPE_COM];\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  REFERENCE (refmpn_com);\n\n\n  p = &param[TYPE_ADDLSH1_N];\n  COPY (TYPE_ADD_N);\n  REFERENCE (refmpn_addlsh1_n);\n\n  p = &param[TYPE_ADDLSH2_N];\n  COPY (TYPE_ADD_N);\n  REFERENCE (refmpn_addlsh2_n);\n\n  p = &param[TYPE_ADDLSH_N];\n  COPY (TYPE_ADD_N);\n  p->shift = 1;\n  REFERENCE (refmpn_addlsh_n);\n\n  p = &param[TYPE_ADDLSH1_N_IP1];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->dst0_from_src1 = 1;\n  REFERENCE (refmpn_addlsh1_n_ip1);\n\n  p = &param[TYPE_ADDLSH2_N_IP1];\n  COPY (TYPE_ADDLSH1_N_IP1);\n  REFERENCE (refmpn_addlsh2_n_ip1);\n\n  p = &param[TYPE_ADDLSH_N_IP1];\n  COPY (TYPE_ADDLSH1_N_IP1);\n  p->shift = 1;\n  REFERENCE (refmpn_addlsh_n_ip1);\n\n  p = &param[TYPE_ADDLSH1_N_IP2];\n  COPY (TYPE_ADDLSH1_N_IP1);\n  REFERENCE (refmpn_addlsh1_n_ip2);\n\n  p = &param[TYPE_ADDLSH2_N_IP2];\n  COPY (TYPE_ADDLSH1_N_IP1);\n  REFERENCE (refmpn_addlsh2_n_ip2);\n\n  p = &param[TYPE_ADDLSH_N_IP2];\n  COPY (TYPE_ADDLSH_N_IP1);\n  REFERENCE (refmpn_addlsh_n_ip2);\n\n  p = &param[TYPE_SUBLSH1_N];\n  COPY (TYPE_ADD_N);\n  REFERENCE (refmpn_sublsh1_n);\n\n  p = &param[TYPE_SUBLSH2_N];\n  COPY (TYPE_ADD_N);\n  REFERENCE (refmpn_sublsh2_n);\n\n  p = &param[TYPE_SUBLSH_N];\n  COPY (TYPE_ADDLSH_N);\n  REFERENCE (refmpn_sublsh_n);\n\n  p = &param[TYPE_SUBLSH1_N_IP1];\n  COPY (TYPE_ADDLSH1_N_IP1);\n  REFERENCE (refmpn_sublsh1_n_ip1);\n\n  p = &param[TYPE_SUBLSH2_N_IP1];\n  COPY (TYPE_ADDLSH1_N_IP1);\n  REFERENCE (refmpn_sublsh2_n_ip1);\n\n  p = &param[TYPE_SUBLSH_N_IP1];\n  COPY (TYPE_ADDLSH_N_IP1);\n  REFERENCE (refmpn_sublsh_n_ip1);\n\n  p = &param[TYPE_RSBLSH1_N];\n  COPY (TYPE_ADD_N);\n  REFERENCE (refmpn_rsblsh1_n);\n\n  p = &param[TYPE_RSBLSH2_N];\n  COPY (TYPE_ADD_N);\n  REFERENCE (refmpn_rsblsh2_n);\n\n  p = &param[TYPE_RSBLSH_N];\n  COPY (TYPE_ADDLSH_N);\n  REFERENCE (refmpn_rsblsh_n);\n\n  p = &param[TYPE_RSH1ADD_N];\n  COPY (TYPE_ADD_N);\n  REFERENCE (refmpn_rsh1add_n);\n\n  p = &param[TYPE_RSH1SUB_N];\n  COPY (TYPE_ADD_N);\n  REFERENCE (refmpn_rsh1sub_n);\n\n\n  p = &param[TYPE_ADDLSH1_NC];\n  COPY (TYPE_ADDLSH1_N);\n  p->carry = CARRY_3;\n  REFERENCE (refmpn_addlsh1_nc);\n\n  p = &param[TYPE_ADDLSH2_NC];\n  COPY (TYPE_ADDLSH2_N);\n  p->carry = CARRY_4; /* FIXME */\n  REFERENCE (refmpn_addlsh2_nc);\n\n  p = &param[TYPE_ADDLSH_NC];\n  COPY (TYPE_ADDLSH_N);\n  p->carry = CARRY_BIT; /* FIXME */\n  REFERENCE (refmpn_addlsh_nc);\n\n  p = &param[TYPE_SUBLSH1_NC];\n  COPY (TYPE_ADDLSH1_NC);\n  REFERENCE (refmpn_sublsh1_nc);\n\n  p = &param[TYPE_SUBLSH2_NC];\n  COPY (TYPE_ADDLSH2_NC);\n  REFERENCE (refmpn_sublsh2_nc);\n\n  p = &param[TYPE_SUBLSH_NC];\n  COPY (TYPE_ADDLSH_NC);\n  REFERENCE (refmpn_sublsh_nc);\n\n  p = &param[TYPE_RSBLSH1_NC];\n  COPY (TYPE_RSBLSH1_N);\n  p->carry = CARRY_BIT; /* FIXME */\n  REFERENCE (refmpn_rsblsh1_nc);\n\n  p = &param[TYPE_RSBLSH2_NC];\n  COPY (TYPE_RSBLSH2_N);\n  p->carry = CARRY_4; /* FIXME */\n  REFERENCE (refmpn_rsblsh2_nc);\n\n  p = &param[TYPE_RSBLSH_NC];\n  COPY (TYPE_RSBLSH_N);\n  p->carry = CARRY_BIT; /* FIXME */\n  REFERENCE (refmpn_rsblsh_nc);\n\n\n  p = &param[TYPE_MOD_1];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->size = SIZE_ALLOW_ZERO;\n  p->divisor = DIVISOR_LIMB;\n  REFERENCE (refmpn_mod_1);\n\n  p = &param[TYPE_MOD_1C];\n  COPY (TYPE_MOD_1);\n  p->carry = CARRY_DIVISOR;\n  REFERENCE (refmpn_mod_1c);\n\n  p = &param[TYPE_DIVMOD_1];\n  COPY (TYPE_MOD_1);\n  p->dst[0] = 1;\n  REFERENCE (refmpn_divmod_1);\n\n  p = &param[TYPE_DIVMOD_1C];\n  COPY (TYPE_DIVMOD_1);\n  p->carry = CARRY_DIVISOR;\n  REFERENCE (refmpn_divmod_1c);\n\n  p = &param[TYPE_DIVREM_1];\n  COPY (TYPE_DIVMOD_1);\n  p->size2 = SIZE_FRACTION;\n  p->dst_size[0] = SIZE_SUM;\n  REFERENCE (refmpn_divrem_1);\n\n  p = &param[TYPE_DIVREM_1C];\n  COPY (TYPE_DIVREM_1);\n  p->carry = CARRY_DIVISOR;\n  REFERENCE (refmpn_divrem_1c);\n\n  p = &param[TYPE_PREINV_DIVREM_1];\n  COPY (TYPE_DIVREM_1);\n  p->size = SIZE_YES; /* ie. no size==0 */\n  REFERENCE (refmpn_preinv_divrem_1);\n\n  p = &param[TYPE_DIV_QR_1N_PI1];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->src[1] = 1;\n  /* SIZE_1 not supported. Always uses low limb only. */\n  p->size2 = 1;\n  p->dst[0] = 1;\n  p->divisor = DIVISOR_NORM;\n  p->data = DATA_DIV_QR_1;\n  VALIDATE (validate_div_qr_1_pi1);\n\n  p = &param[TYPE_PREINV_MOD_1];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->divisor = DIVISOR_NORM;\n  REFERENCE (refmpn_preinv_mod_1);\n\n  p = &param[TYPE_MOD_34LSUB1];\n  p->retval = 1;\n  p->src[0] = 1;\n  VALIDATE (validate_mod_34lsub1);\n\n  p = &param[TYPE_UDIV_QRNND];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->dst[0] = 1;\n  p->dst_size[0] = SIZE_1;\n  p->divisor = UDIV_NEEDS_NORMALIZATION ? DIVISOR_NORM : DIVISOR_LIMB;\n  p->data = DATA_UDIV_QRNND;\n  p->overlap = OVERLAP_NONE;\n  REFERENCE (refmpn_udiv_qrnnd);\n\n  p = &param[TYPE_UDIV_QRNND_R];\n  COPY (TYPE_UDIV_QRNND);\n  REFERENCE (refmpn_udiv_qrnnd_r);\n\n\n  p = &param[TYPE_DIVEXACT_1];\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->divisor = DIVISOR_LIMB;\n  p->data = DATA_MULTIPLE_DIVISOR;\n  VALIDATE (validate_divexact_1);\n  REFERENCE (refmpn_divmod_1);\n\n  p = &param[TYPE_BDIV_Q_1];\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->divisor = DIVISOR_LIMB;\n  VALIDATE (validate_bdiv_q_1);\n\n  p = &param[TYPE_DIVEXACT_BY3];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  REFERENCE (refmpn_divexact_by3);\n\n  p = &param[TYPE_DIVEXACT_BY3C];\n  COPY (TYPE_DIVEXACT_BY3);\n  p->carry = CARRY_3;\n  REFERENCE (refmpn_divexact_by3c);\n\n\n  p = &param[TYPE_MODEXACT_1_ODD];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->divisor = DIVISOR_ODD;\n  VALIDATE (validate_modexact_1_odd);\n\n  p = &param[TYPE_MODEXACT_1C_ODD];\n  COPY (TYPE_MODEXACT_1_ODD);\n  p->carry = CARRY_LIMB;\n  VALIDATE (validate_modexact_1c_odd);\n\n\n  p = &param[TYPE_GCD_1];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->data = DATA_NON_ZERO;\n  p->divisor = DIVISOR_LIMB;\n  REFERENCE (refmpn_gcd_1);\n\n  p = &param[TYPE_GCD];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->src[1] = 1;\n  p->size2 = 1;\n  p->dst_size[0] = SIZE_RETVAL;\n  p->overlap = OVERLAP_NOT_SRCS;\n  p->data = DATA_GCD;\n  REFERENCE (refmpn_gcd);\n\n\n  p = &param[TYPE_MPZ_LEGENDRE];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->size = SIZE_ALLOW_ZERO;\n  p->src[1] = 1;\n  p->data = DATA_SRC1_ODD_PRIME;\n  p->size2 = 1;\n  p->carry = CARRY_BIT;\n  p->carry_sign = 1;\n  REFERENCE (refmpz_legendre);\n\n  p = &param[TYPE_MPZ_JACOBI];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->size = SIZE_ALLOW_ZERO;\n  p->src[1] = 1;\n  p->data = DATA_SRC1_ODD;\n  p->size2 = 1;\n  p->carry = CARRY_BIT;\n  p->carry_sign = 1;\n  REFERENCE (refmpz_jacobi);\n\n  p = &param[TYPE_MPZ_KRONECKER];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->size = SIZE_ALLOW_ZERO;\n  p->src[1] = 1;\n  p->data = 0;\n  p->size2 = 1;\n  p->carry = CARRY_4;\n  p->carry_sign = 1;\n  REFERENCE (refmpz_kronecker);\n\n\n  p = &param[TYPE_MPZ_KRONECKER_UI];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->size = SIZE_ALLOW_ZERO;\n  p->multiplier = 1;\n  p->carry = CARRY_BIT;\n  REFERENCE (refmpz_kronecker_ui);\n\n  p = &param[TYPE_MPZ_KRONECKER_SI];\n  COPY (TYPE_MPZ_KRONECKER_UI);\n  REFERENCE (refmpz_kronecker_si);\n\n  p = &param[TYPE_MPZ_UI_KRONECKER];\n  COPY (TYPE_MPZ_KRONECKER_UI);\n  REFERENCE (refmpz_ui_kronecker);\n\n  p = &param[TYPE_MPZ_SI_KRONECKER];\n  COPY (TYPE_MPZ_KRONECKER_UI);\n  REFERENCE (refmpz_si_kronecker);\n\n\n  p = &param[TYPE_SQR];\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->dst_size[0] = SIZE_SUM;\n  p->overlap = OVERLAP_NONE;\n  REFERENCE (refmpn_sqr);\n\n  p = &param[TYPE_MUL_N];\n  COPY (TYPE_SQR);\n  p->src[1] = 1;\n  REFERENCE (refmpn_mul_n);\n\n  p = &param[TYPE_MULLO_N];\n  COPY (TYPE_MUL_N);\n  p->dst_size[0] = 0;\n  REFERENCE (refmpn_mullo_n);\n\n  p = &param[TYPE_SQRLO];\n  COPY (TYPE_SQR);\n  p->dst_size[0] = 0;\n  REFERENCE (refmpn_sqrlo);\n\n  p = &param[TYPE_MUL_MN];\n  COPY (TYPE_MUL_N);\n  p->size2 = 1;\n  REFERENCE (refmpn_mul_basecase);\n\n  p = &param[TYPE_MULMID_MN];\n  COPY (TYPE_MUL_MN);\n  p->dst_size[0] = SIZE_DIFF_PLUS_3;\n  REFERENCE (refmpn_mulmid_basecase);\n\n  p = &param[TYPE_MULMID_N];\n  COPY (TYPE_MUL_N);\n  p->size = SIZE_ODD;\n  p->size2 = SIZE_CEIL_HALF;\n  p->dst_size[0] = SIZE_DIFF_PLUS_3;\n  REFERENCE (refmpn_mulmid_n);\n\n  p = &param[TYPE_UMUL_PPMM];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->dst[0] = 1;\n  p->dst_size[0] = SIZE_1;\n  p->overlap = OVERLAP_NONE;\n  REFERENCE (refmpn_umul_ppmm);\n\n  p = &param[TYPE_UMUL_PPMM_R];\n  COPY (TYPE_UMUL_PPMM);\n  REFERENCE (refmpn_umul_ppmm_r);\n\n\n  p = &param[TYPE_RSHIFT];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->shift = 1;\n  p->overlap = OVERLAP_LOW_TO_HIGH;\n  REFERENCE (refmpn_rshift);\n\n  p = &param[TYPE_LSHIFT];\n  COPY (TYPE_RSHIFT);\n  p->overlap = OVERLAP_HIGH_TO_LOW;\n  REFERENCE (refmpn_lshift);\n\n  p = &param[TYPE_LSHIFTC];\n  COPY (TYPE_RSHIFT);\n  p->overlap = OVERLAP_HIGH_TO_LOW;\n  REFERENCE (refmpn_lshiftc);\n\n\n  p = &param[TYPE_POPCOUNT];\n  p->retval = 1;\n  p->src[0] = 1;\n  REFERENCE (refmpn_popcount);\n\n  p = &param[TYPE_HAMDIST];\n  COPY (TYPE_POPCOUNT);\n  p->src[1] = 1;\n  REFERENCE (refmpn_hamdist);\n\n\n  p = &param[TYPE_SBPI1_DIV_QR];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->dst[1] = 1;\n  p->src[0] = 1;\n  p->src[1] = 1;\n  p->data = DATA_SRC1_HIGHBIT;\n  p->size2 = 1;\n  p->dst_size[0] = SIZE_DIFF;\n  p->overlap = OVERLAP_NONE;\n  REFERENCE (refmpn_sb_div_qr);\n\n  p = &param[TYPE_TDIV_QR];\n  p->dst[0] = 1;\n  p->dst[1] = 1;\n  p->src[0] = 1;\n  p->src[1] = 1;\n  p->size2 = 1;\n  p->dst_size[0] = SIZE_DIFF_PLUS_1;\n  p->dst_size[1] = SIZE_SIZE2;\n  p->overlap = OVERLAP_NONE;\n  REFERENCE (refmpn_tdiv_qr);\n\n  p = &param[TYPE_SQRTREM];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->dst[1] = 1;\n  p->src[0] = 1;\n  p->dst_size[0] = SIZE_CEIL_HALF;\n  p->dst_size[1] = SIZE_RETVAL;\n  p->overlap = OVERLAP_NONE;\n  VALIDATE (validate_sqrtrem);\n  REFERENCE (refmpn_sqrtrem);\n\n  p = &param[TYPE_SQRT];\n  p->retval = 1;\n  p->dst[0] = 1;\n  p->dst[1] = 0;\n  p->src[0] = 1;\n  p->dst_size[0] = SIZE_CEIL_HALF;\n  p->overlap = OVERLAP_NONE;\n  VALIDATE (validate_sqrt);\n\n  p = &param[TYPE_ZERO];\n  p->dst[0] = 1;\n  p->size = SIZE_ALLOW_ZERO;\n  REFERENCE (refmpn_zero);\n\n  p = &param[TYPE_GET_STR];\n  p->retval = 1;\n  p->src[0] = 1;\n  p->size = SIZE_ALLOW_ZERO;\n  p->dst[0] = 1;\n  p->dst[1] = 1;\n  p->dst_size[0] = SIZE_GET_STR;\n  p->dst_bytes[0] = 1;\n  p->overlap = OVERLAP_NONE;\n  REFERENCE (refmpn_get_str);\n\n  p = &param[TYPE_BINVERT];\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->data = DATA_SRC0_ODD;\n  p->overlap = OVERLAP_NONE;\n  REFERENCE (refmpn_binvert);\n\n  p = &param[TYPE_INVERT];\n  p->dst[0] = 1;\n  p->src[0] = 1;\n  p->data = DATA_SRC0_HIGHBIT;\n  p->overlap = OVERLAP_NONE;\n  REFERENCE (refmpn_invert);\n\n#ifdef EXTRA_PARAM_INIT\n  EXTRA_PARAM_INIT\n#endif\n}",
      "lines": 753,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "MPN_COPY_fun": {
      "start_point": [
        1487,
        0
      ],
      "end_point": [
        1489,
        28
      ],
      "content": "void\nMPN_COPY_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{ MPN_COPY (rp, sp, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "MPN_COPY_INCR_fun": {
      "start_point": [
        1491,
        0
      ],
      "end_point": [
        1493,
        33
      ],
      "content": "void\nMPN_COPY_INCR_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{ MPN_COPY_INCR (rp, sp, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "MPN_COPY_DECR_fun": {
      "start_point": [
        1495,
        0
      ],
      "end_point": [
        1497,
        33
      ],
      "content": "void\nMPN_COPY_DECR_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{ MPN_COPY_DECR (rp, sp, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "__GMPN_COPY_fun": {
      "start_point": [
        1499,
        0
      ],
      "end_point": [
        1501,
        31
      ],
      "content": "void\n__GMPN_COPY_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{ __GMPN_COPY (rp, sp, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "__GMPN_COPY_INCR_fun": {
      "start_point": [
        1504,
        0
      ],
      "end_point": [
        1506,
        36
      ],
      "content": "void\n__GMPN_COPY_INCR_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{ __GMPN_COPY_INCR (rp, sp, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_com_fun": {
      "start_point": [
        1509,
        0
      ],
      "end_point": [
        1511,
        27
      ],
      "content": "void\nmpn_com_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{ mpn_com (rp, sp, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_and_n_fun": {
      "start_point": [
        1513,
        0
      ],
      "end_point": [
        1515,
        33
      ],
      "content": "void\nmpn_and_n_fun (mp_ptr rp, mp_srcptr s1, mp_srcptr s2, mp_size_t size)\n{ mpn_and_n (rp, s1, s2, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_andn_n_fun": {
      "start_point": [
        1517,
        0
      ],
      "end_point": [
        1519,
        34
      ],
      "content": "void\nmpn_andn_n_fun (mp_ptr rp, mp_srcptr s1, mp_srcptr s2, mp_size_t size)\n{ mpn_andn_n (rp, s1, s2, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_nand_n_fun": {
      "start_point": [
        1521,
        0
      ],
      "end_point": [
        1523,
        34
      ],
      "content": "void\nmpn_nand_n_fun (mp_ptr rp, mp_srcptr s1, mp_srcptr s2, mp_size_t size)\n{ mpn_nand_n (rp, s1, s2, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_ior_n_fun": {
      "start_point": [
        1525,
        0
      ],
      "end_point": [
        1527,
        33
      ],
      "content": "void\nmpn_ior_n_fun (mp_ptr rp, mp_srcptr s1, mp_srcptr s2, mp_size_t size)\n{ mpn_ior_n (rp, s1, s2, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_iorn_n_fun": {
      "start_point": [
        1529,
        0
      ],
      "end_point": [
        1531,
        34
      ],
      "content": "void\nmpn_iorn_n_fun (mp_ptr rp, mp_srcptr s1, mp_srcptr s2, mp_size_t size)\n{ mpn_iorn_n (rp, s1, s2, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_nior_n_fun": {
      "start_point": [
        1533,
        0
      ],
      "end_point": [
        1535,
        34
      ],
      "content": "void\nmpn_nior_n_fun (mp_ptr rp, mp_srcptr s1, mp_srcptr s2, mp_size_t size)\n{ mpn_nior_n (rp, s1, s2, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_xor_n_fun": {
      "start_point": [
        1537,
        0
      ],
      "end_point": [
        1539,
        33
      ],
      "content": "void\nmpn_xor_n_fun (mp_ptr rp, mp_srcptr s1, mp_srcptr s2, mp_size_t size)\n{ mpn_xor_n (rp, s1, s2, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_xnor_n_fun": {
      "start_point": [
        1541,
        0
      ],
      "end_point": [
        1543,
        34
      ],
      "content": "void\nmpn_xnor_n_fun (mp_ptr rp, mp_srcptr s1, mp_srcptr s2, mp_size_t size)\n{ mpn_xnor_n (rp, s1, s2, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "udiv_qrnnd_fun": {
      "start_point": [
        1545,
        0
      ],
      "end_point": [
        1551,
        1
      ],
      "content": "mp_limb_t\nudiv_qrnnd_fun (mp_limb_t *remptr, mp_limb_t n1, mp_limb_t n0, mp_limb_t d)\n{\n  mp_limb_t  q;\n  udiv_qrnnd (q, *remptr, n1, n0, d);\n  return q;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_divexact_by3_fun": {
      "start_point": [
        1553,
        0
      ],
      "end_point": [
        1557,
        1
      ],
      "content": "mp_limb_t\nmpn_divexact_by3_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  return mpn_divexact_by3 (rp, sp, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_addlsh1_n_ip1_fun": {
      "start_point": [
        1560,
        0
      ],
      "end_point": [
        1564,
        1
      ],
      "content": "mp_limb_t\nmpn_addlsh1_n_ip1_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  return mpn_addlsh1_n_ip1 (rp, sp, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_addlsh2_n_ip1_fun": {
      "start_point": [
        1567,
        0
      ],
      "end_point": [
        1571,
        1
      ],
      "content": "mp_limb_t\nmpn_addlsh2_n_ip1_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  return mpn_addlsh2_n_ip1 (rp, sp, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_addlsh_n_ip1_fun": {
      "start_point": [
        1574,
        0
      ],
      "end_point": [
        1578,
        1
      ],
      "content": "mp_limb_t\nmpn_addlsh_n_ip1_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size, unsigned int sh)\n{\n  return mpn_addlsh_n_ip1 (rp, sp, size, sh);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_addlsh1_n_ip2_fun": {
      "start_point": [
        1581,
        0
      ],
      "end_point": [
        1585,
        1
      ],
      "content": "mp_limb_t\nmpn_addlsh1_n_ip2_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  return mpn_addlsh1_n_ip2 (rp, sp, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_addlsh2_n_ip2_fun": {
      "start_point": [
        1588,
        0
      ],
      "end_point": [
        1592,
        1
      ],
      "content": "mp_limb_t\nmpn_addlsh2_n_ip2_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  return mpn_addlsh2_n_ip2 (rp, sp, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_addlsh_n_ip2_fun": {
      "start_point": [
        1595,
        0
      ],
      "end_point": [
        1599,
        1
      ],
      "content": "mp_limb_t\nmpn_addlsh_n_ip2_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size, unsigned int sh)\n{\n  return mpn_addlsh_n_ip2 (rp, sp, size, sh);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_sublsh1_n_ip1_fun": {
      "start_point": [
        1602,
        0
      ],
      "end_point": [
        1606,
        1
      ],
      "content": "mp_limb_t\nmpn_sublsh1_n_ip1_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  return mpn_sublsh1_n_ip1 (rp, sp, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_sublsh2_n_ip1_fun": {
      "start_point": [
        1609,
        0
      ],
      "end_point": [
        1613,
        1
      ],
      "content": "mp_limb_t\nmpn_sublsh2_n_ip1_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size)\n{\n  return mpn_sublsh2_n_ip1 (rp, sp, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_sublsh_n_ip1_fun": {
      "start_point": [
        1616,
        0
      ],
      "end_point": [
        1620,
        1
      ],
      "content": "mp_limb_t\nmpn_sublsh_n_ip1_fun (mp_ptr rp, mp_srcptr sp, mp_size_t size, unsigned int sh)\n{\n  return mpn_sublsh_n_ip1 (rp, sp, size, sh);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_modexact_1_odd_fun": {
      "start_point": [
        1623,
        0
      ],
      "end_point": [
        1627,
        1
      ],
      "content": "mp_limb_t\nmpn_modexact_1_odd_fun (mp_srcptr ptr, mp_size_t size, mp_limb_t divisor)\n{\n  return mpn_modexact_1_odd (ptr, size, divisor);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_toom22_mul_fun": {
      "start_point": [
        1629,
        0
      ],
      "end_point": [
        1638,
        1
      ],
      "content": "void\nmpn_toom22_mul_fun (mp_ptr dst, mp_srcptr src1, mp_srcptr src2, mp_size_t size)\n{\n  mp_ptr  tspace;\n  TMP_DECL;\n  TMP_MARK;\n  tspace = TMP_ALLOC_LIMBS (mpn_toom22_mul_itch (size, size));\n  mpn_toom22_mul (dst, src1, size, src2, size, tspace);\n  TMP_FREE;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_toom2_sqr_fun": {
      "start_point": [
        1639,
        0
      ],
      "end_point": [
        1648,
        1
      ],
      "content": "void\nmpn_toom2_sqr_fun (mp_ptr dst, mp_srcptr src, mp_size_t size)\n{\n  mp_ptr tspace;\n  TMP_DECL;\n  TMP_MARK;\n  tspace = TMP_ALLOC_LIMBS (mpn_toom2_sqr_itch (size));\n  mpn_toom2_sqr (dst, src, size, tspace);\n  TMP_FREE;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_toom33_mul_fun": {
      "start_point": [
        1649,
        0
      ],
      "end_point": [
        1658,
        1
      ],
      "content": "void\nmpn_toom33_mul_fun (mp_ptr dst, mp_srcptr src1, mp_srcptr src2, mp_size_t size)\n{\n  mp_ptr  tspace;\n  TMP_DECL;\n  TMP_MARK;\n  tspace = TMP_ALLOC_LIMBS (mpn_toom33_mul_itch (size, size));\n  mpn_toom33_mul (dst, src1, size, src2, size, tspace);\n  TMP_FREE;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_toom3_sqr_fun": {
      "start_point": [
        1659,
        0
      ],
      "end_point": [
        1668,
        1
      ],
      "content": "void\nmpn_toom3_sqr_fun (mp_ptr dst, mp_srcptr src, mp_size_t size)\n{\n  mp_ptr tspace;\n  TMP_DECL;\n  TMP_MARK;\n  tspace = TMP_ALLOC_LIMBS (mpn_toom3_sqr_itch (size));\n  mpn_toom3_sqr (dst, src, size, tspace);\n  TMP_FREE;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_toom44_mul_fun": {
      "start_point": [
        1669,
        0
      ],
      "end_point": [
        1678,
        1
      ],
      "content": "void\nmpn_toom44_mul_fun (mp_ptr dst, mp_srcptr src1, mp_srcptr src2, mp_size_t size)\n{\n  mp_ptr  tspace;\n  TMP_DECL;\n  TMP_MARK;\n  tspace = TMP_ALLOC_LIMBS (mpn_toom44_mul_itch (size, size));\n  mpn_toom44_mul (dst, src1, size, src2, size, tspace);\n  TMP_FREE;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_toom4_sqr_fun": {
      "start_point": [
        1679,
        0
      ],
      "end_point": [
        1688,
        1
      ],
      "content": "void\nmpn_toom4_sqr_fun (mp_ptr dst, mp_srcptr src, mp_size_t size)\n{\n  mp_ptr tspace;\n  TMP_DECL;\n  TMP_MARK;\n  tspace = TMP_ALLOC_LIMBS (mpn_toom4_sqr_itch (size));\n  mpn_toom4_sqr (dst, src, size, tspace);\n  TMP_FREE;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_toom42_mulmid_fun": {
      "start_point": [
        1690,
        0
      ],
      "end_point": [
        1701,
        1
      ],
      "content": "void\nmpn_toom42_mulmid_fun (mp_ptr dst, mp_srcptr src1, mp_srcptr src2,\n\t\t       mp_size_t size)\n{\n  mp_ptr  tspace;\n  mp_size_t n;\n  TMP_DECL;\n  TMP_MARK;\n  tspace = TMP_ALLOC_LIMBS (mpn_toom42_mulmid_itch (size));\n  mpn_toom42_mulmid (dst, src1, src2, size, tspace);\n  TMP_FREE;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "umul_ppmm_fun": {
      "start_point": [
        1703,
        0
      ],
      "end_point": [
        1709,
        1
      ],
      "content": "mp_limb_t\numul_ppmm_fun (mp_limb_t *lowptr, mp_limb_t m1, mp_limb_t m2)\n{\n  mp_limb_t  high;\n  umul_ppmm (high, *lowptr, m1, m2);\n  return high;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "MPN_ZERO_fun": {
      "start_point": [
        1711,
        0
      ],
      "end_point": [
        1713,
        25
      ],
      "content": "void\nMPN_ZERO_fun (mp_ptr ptr, mp_size_t size)\n{ MPN_ZERO (ptr, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_sqrt_fun": {
      "start_point": [
        1715,
        0
      ],
      "end_point": [
        1717,
        46
      ],
      "content": "mp_size_t\nmpn_sqrt_fun (mp_ptr dst, mp_srcptr src, mp_size_t size)\n{ return mpn_sqrtrem (dst, NULL, src, size); }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mprotect_maybe": {
      "start_point": [
        2034,
        0
      ],
      "end_point": [
        2058,
        1
      ],
      "content": "void\nmprotect_maybe (void *addr, size_t len, int prot)\n{\n  if (!option_redzones)\n    return;\n\n#if HAVE_MPROTECT\n  if (mprotect (addr, len, prot) != 0)\n    {\n      fprintf (stderr, \"Cannot mprotect %p 0x%X 0x%X: %s\\n\",\n\t       addr, (unsigned) len, prot, strerror (errno));\n      exit (1);\n    }\n#else\n  {\n    static int  warned = 0;\n    if (!warned)\n      {\n\tfprintf (stderr,\n\t\t \"mprotect not available, bounds testing not performed\\n\");\n\twarned = 1;\n      }\n  }\n#endif\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "round_up_multiple": {
      "start_point": [
        2061,
        0
      ],
      "end_point": [
        2071,
        1
      ],
      "content": "size_t\nround_up_multiple (size_t a, size_t m)\n{\n  unsigned long  r;\n\n  r = a % m;\n  if (r == 0)\n    return a;\n  else\n    return a + (m - r);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "malloc_region": {
      "start_point": [
        2081,
        0
      ],
      "end_point": [
        2119,
        1
      ],
      "content": "void\nmalloc_region (struct region_t *r, mp_size_t n)\n{\n  mp_ptr  p;\n  size_t  nbytes;\n\n  ASSERT ((pagesize % GMP_LIMB_BYTES) == 0);\n\n  n = round_up_multiple (n, PAGESIZE_LIMBS);\n  r->size = n;\n\n  nbytes = n*GMP_LIMB_BYTES + 2*REDZONE_BYTES + pagesize;\n\n#if defined (MAP_ANONYMOUS) && ! defined (MAP_ANON)\n#define MAP_ANON  MAP_ANONYMOUS\n#endif\n\n#if HAVE_MMAP && defined (MAP_ANON)\n  /* note must pass fd=-1 for MAP_ANON on BSD */\n  p = (mp_ptr) mmap (NULL, nbytes, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);\n  if (p == (void *) -1)\n    {\n      fprintf (stderr, \"Cannot mmap %#x anon bytes: %s\\n\",\n\t       (unsigned) nbytes, strerror (errno));\n      exit (1);\n    }\n#else\n  p = (mp_ptr) malloc (nbytes);\n  ASSERT_ALWAYS (p != NULL);\n#endif\n\n  p = (mp_ptr) align_pointer (p, pagesize);\n\n  mprotect_maybe (p, REDZONE_BYTES, PROT_NONE);\n  p += REDZONE_LIMBS;\n  r->ptr = p;\n\n  mprotect_maybe (p + n, REDZONE_BYTES, PROT_NONE);\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mprotect_region": {
      "start_point": [
        2121,
        0
      ],
      "end_point": [
        2125,
        1
      ],
      "content": "void\nmprotect_region (const struct region_t *r, int prot)\n{\n  mprotect_maybe (r->ptr, r->size, prot);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "t_random": {
      "start_point": [
        2258,
        0
      ],
      "end_point": [
        2298,
        1
      ],
      "content": "void\nt_random (mp_ptr ptr, mp_size_t n)\n{\n  if (n == 0)\n    return;\n\n  switch (option_data) {\n  case DATA_TRAND:\n    switch (t_rand) {\n    case 0: refmpn_random (ptr, n); break;\n    case 1: refmpn_random2 (ptr, n); break;\n    default: abort();\n    }\n    break;\n  case DATA_SEQ:\n    {\n      static mp_limb_t  counter = 0;\n      mp_size_t  i;\n      for (i = 0; i < n; i++)\n\tptr[i] = ++counter;\n    }\n    break;\n  case DATA_ZEROS:\n    refmpn_zero (ptr, n);\n    break;\n  case DATA_FFS:\n    refmpn_fill (ptr, n, GMP_NUMB_MAX);\n    break;\n  case DATA_2FD:\n    /* Special value 0x2FFF...FFFD, which divided by 3 gives 0xFFF...FFF,\n       inducing the q1_ff special case in the mul-by-inverse part of some\n       versions of divrem_1 and mod_1. */\n    refmpn_fill (ptr, n, (mp_limb_t) -1);\n    ptr[n-1] = 2;\n    ptr[0] -= 2;\n    break;\n\n  default:\n    abort();\n  }\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "print_each": {
      "start_point": [
        2303,
        0
      ],
      "end_point": [
        2327,
        1
      ],
      "content": "void\nprint_each (const struct each_t *e)\n{\n  int  i;\n\n  printf (\"%s %s\\n\", e->name, e == &ref ? tr->reference_name : choice->name);\n  if (tr->retval)\n    mpn_trace (\"   retval\", &e->retval, 1);\n\n  for (i = 0; i < NUM_DESTS; i++)\n    {\n      if (tr->dst[i])\n\t{\n\t  if (tr->dst_bytes[i])\n\t    byte_tracen (\"   d[%d]\", i, e->d[i].p, d[i].size);\n\t  else\n\t    mpn_tracen (\"   d[%d]\", i, e->d[i].p, d[i].size);\n\t  printf (\"        located %p\\n\", (void *) (e->d[i].p));\n\t}\n    }\n\n  for (i = 0; i < NUM_SOURCES; i++)\n    if (tr->src[i])\n      printf (\"   s[%d] located %p\\n\", i, (void *)  (e->s[i].p));\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "print_all": {
      "start_point": [
        2330,
        0
      ],
      "end_point": [
        2392,
        1
      ],
      "content": "void\nprint_all (void)\n{\n  int  i;\n\n  printf (\"\\n\");\n  printf (\"size  %ld\\n\", (long) size);\n  if (tr->size2)\n    printf (\"size2 %ld\\n\", (long) size2);\n\n  for (i = 0; i < NUM_DESTS; i++)\n    if (d[i].size != size)\n      printf (\"d[%d].size %ld\\n\", i, (long) d[i].size);\n\n  if (tr->multiplier)\n    mpn_trace (\"   multiplier\", &multiplier, 1);\n  if (tr->divisor)\n    mpn_trace (\"   divisor\", &divisor, 1);\n  if (tr->shift)\n    printf (\"   shift %lu\\n\", shift);\n  if (tr->carry)\n    mpn_trace (\"   carry\", &carry, 1);\n  if (tr->msize)\n    mpn_trace (\"   multiplier_N\", multiplier_N, tr->msize);\n\n  for (i = 0; i < NUM_DESTS; i++)\n    if (tr->dst[i])\n      printf (\"   d[%d] %s, align %ld, size %ld\\n\",\n\t      i, d[i].high ? \"high\" : \"low\",\n\t      (long) d[i].align, (long) d[i].size);\n\n  for (i = 0; i < NUM_SOURCES; i++)\n    {\n      if (tr->src[i])\n\t{\n\t  printf (\"   s[%d] %s, align %ld, \",\n\t\t  i, s[i].high ? \"high\" : \"low\", (long) s[i].align);\n\t  switch (overlap->s[i]) {\n\t  case -1:\n\t    printf (\"no overlap\\n\");\n\t    break;\n\t  default:\n\t    printf (\"==d[%d]%s\\n\",\n\t\t    overlap->s[i],\n\t\t    tr->overlap == OVERLAP_LOW_TO_HIGH ? \"+a\"\n\t\t    : tr->overlap == OVERLAP_HIGH_TO_LOW ? \"-a\"\n\t\t    : \"\");\n\t    break;\n\t  }\n\t  printf (\"   s[%d]=\", i);\n\t  if (tr->carry_sign && (carry & (1 << i)))\n\t    printf (\"-\");\n\t  mpn_trace (NULL, s[i].p, SRC_SIZE(i));\n\t}\n    }\n\n  if (tr->dst0_from_src1)\n    mpn_trace (\"   d[0]\", s[1].region.ptr, size);\n\n  if (tr->reference)\n    print_each (&ref);\n  print_each (&fun);\n}",
      "lines": 63,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "compare": {
      "start_point": [
        2394,
        0
      ],
      "end_point": [
        2452,
        1
      ],
      "content": "void\ncompare (void)\n{\n  int  error = 0;\n  int  i;\n\n  if (tr->retval && ref.retval != fun.retval)\n    {\n      gmp_printf (\"Different return values (%Mu, %Mu)\\n\",\n\t\t  ref.retval, fun.retval);\n      error = 1;\n    }\n\n  for (i = 0; i < NUM_DESTS; i++)\n    {\n      switch (tr->dst_size[i]) {\n      case SIZE_RETVAL:\n      case SIZE_GET_STR:\n\td[i].size = ref.retval;\n\tbreak;\n      }\n    }\n\n  for (i = 0; i < NUM_DESTS; i++)\n    {\n      if (! tr->dst[i])\n\tcontinue;\n\n      if (tr->dst_bytes[i])\n\t{\n\t  if (memcmp (ref.d[i].p, fun.d[i].p, d[i].size) != 0)\n\t    {\n\t      printf (\"Different d[%d] data results, low diff at %ld, high diff at %ld\\n\",\n\t\t      i,\n\t\t      (long) byte_diff_lowest (ref.d[i].p, fun.d[i].p, d[i].size),\n\t\t      (long) byte_diff_highest (ref.d[i].p, fun.d[i].p, d[i].size));\n\t      error = 1;\n\t    }\n\t}\n      else\n\t{\n\t  if (d[i].size != 0\n\t      && ! refmpn_equal_anynail (ref.d[i].p, fun.d[i].p, d[i].size))\n\t    {\n\t      printf (\"Different d[%d] data results, low diff at %ld, high diff at %ld\\n\",\n\t\t      i,\n\t\t      (long) mpn_diff_lowest (ref.d[i].p, fun.d[i].p, d[i].size),\n\t\t      (long) mpn_diff_highest (ref.d[i].p, fun.d[i].p, d[i].size));\n\t      error = 1;\n\t    }\n\t}\n    }\n\n  if (error)\n    {\n      print_all();\n      abort();\n    }\n}",
      "lines": 59,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "call": {
      "start_point": [
        2460,
        0
      ],
      "end_point": [
        2897,
        1
      ],
      "content": "void\ncall (struct each_t *e, tryfun_t function)\n{\n  switch (choice->type) {\n  case TYPE_ADD:\n  case TYPE_SUB:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, size, e->s[1].p, size2);\n    break;\n\n  case TYPE_ADD_N:\n  case TYPE_SUB_N:\n  case TYPE_ADDLSH1_N:\n  case TYPE_ADDLSH2_N:\n  case TYPE_SUBLSH1_N:\n  case TYPE_SUBLSH2_N:\n  case TYPE_RSBLSH1_N:\n  case TYPE_RSBLSH2_N:\n  case TYPE_RSH1ADD_N:\n  case TYPE_RSH1SUB_N:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, e->s[1].p, size);\n    break;\n  case TYPE_ADDLSH_N:\n  case TYPE_SUBLSH_N:\n  case TYPE_RSBLSH_N:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, e->s[1].p, size, shift);\n    break;\n  case TYPE_ADDLSH_NC:\n  case TYPE_SUBLSH_NC:\n  case TYPE_RSBLSH_NC:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, e->s[1].p, size, shift, carry);\n    break;\n  case TYPE_ADDLSH1_NC:\n  case TYPE_ADDLSH2_NC:\n  case TYPE_SUBLSH1_NC:\n  case TYPE_SUBLSH2_NC:\n  case TYPE_RSBLSH1_NC:\n  case TYPE_RSBLSH2_NC:\n  case TYPE_ADD_NC:\n  case TYPE_SUB_NC:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, e->s[1].p, size, carry);\n    break;\n  case TYPE_ADDCND_N:\n  case TYPE_SUBCND_N:\n    e->retval = CALLING_CONVENTIONS (function)\n      (carry, e->d[0].p, e->s[0].p, e->s[1].p, size);\n    break;\n  case TYPE_ADD_ERR1_N:\n  case TYPE_SUB_ERR1_N:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, e->s[1].p, e->d[1].p, e->s[2].p, size, carry);\n    break;\n  case TYPE_ADD_ERR2_N:\n  case TYPE_SUB_ERR2_N:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, e->s[1].p, e->d[1].p, e->s[2].p, e->s[3].p, size, carry);\n    break;\n  case TYPE_ADD_ERR3_N:\n  case TYPE_SUB_ERR3_N:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, e->s[1].p, e->d[1].p, e->s[2].p, e->s[3].p, e->s[4].p, size, carry);\n    break;\n\n  case TYPE_MUL_1:\n  case TYPE_ADDMUL_1:\n  case TYPE_SUBMUL_1:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, size, multiplier);\n    break;\n  case TYPE_MUL_1C:\n  case TYPE_ADDMUL_1C:\n  case TYPE_SUBMUL_1C:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, size, multiplier, carry);\n    break;\n\n  case TYPE_MUL_2:\n  case TYPE_MUL_3:\n  case TYPE_MUL_4:\n  case TYPE_MUL_5:\n  case TYPE_MUL_6:\n    if (size == 1)\n      abort ();\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, size, multiplier_N);\n    break;\n\n  case TYPE_ADDMUL_2:\n  case TYPE_ADDMUL_3:\n  case TYPE_ADDMUL_4:\n  case TYPE_ADDMUL_5:\n  case TYPE_ADDMUL_6:\n  case TYPE_ADDMUL_7:\n  case TYPE_ADDMUL_8:\n    if (size == 1)\n      abort ();\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, size, multiplier_N);\n    break;\n\n  case TYPE_AND_N:\n  case TYPE_ANDN_N:\n  case TYPE_NAND_N:\n  case TYPE_IOR_N:\n  case TYPE_IORN_N:\n  case TYPE_NIOR_N:\n  case TYPE_XOR_N:\n  case TYPE_XNOR_N:\n    CALLING_CONVENTIONS (function) (e->d[0].p, e->s[0].p, e->s[1].p, size);\n    break;\n\n  case TYPE_ADDSUB_N:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->d[1].p, e->s[0].p, e->s[1].p, size);\n    break;\n  case TYPE_ADDSUB_NC:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->d[1].p, e->s[0].p, e->s[1].p, size, carry);\n    break;\n\n  case TYPE_COPY:\n  case TYPE_COPYI:\n  case TYPE_COPYD:\n  case TYPE_COM:\n    CALLING_CONVENTIONS (function) (e->d[0].p, e->s[0].p, size);\n    break;\n\n  case TYPE_ADDLSH1_N_IP1:\n  case TYPE_ADDLSH2_N_IP1:\n  case TYPE_ADDLSH1_N_IP2:\n  case TYPE_ADDLSH2_N_IP2:\n  case TYPE_SUBLSH1_N_IP1:\n  case TYPE_SUBLSH2_N_IP1:\n  case TYPE_DIVEXACT_BY3:\n    e->retval = CALLING_CONVENTIONS (function) (e->d[0].p, e->s[0].p, size);\n    break;\n  case TYPE_DIVEXACT_BY3C:\n    e->retval = CALLING_CONVENTIONS (function) (e->d[0].p, e->s[0].p, size,\n\t\t\t\t\t\tcarry);\n    break;\n\n\n  case TYPE_DIVMOD_1:\n  case TYPE_DIVEXACT_1:\n  case TYPE_BDIV_Q_1:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, size, divisor);\n    break;\n  case TYPE_DIVMOD_1C:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, size, divisor, carry);\n    break;\n  case TYPE_DIVREM_1:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, size2, e->s[0].p, size, divisor);\n    break;\n  case TYPE_DIVREM_1C:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, size2, e->s[0].p, size, divisor, carry);\n    break;\n  case TYPE_PREINV_DIVREM_1:\n    {\n      mp_limb_t  dinv;\n      unsigned   shift;\n      shift = refmpn_count_leading_zeros (divisor);\n      dinv = refmpn_invert_limb (divisor << shift);\n      e->retval = CALLING_CONVENTIONS (function)\n\t(e->d[0].p, size2, e->s[0].p, size, divisor, dinv, shift);\n    }\n    break;\n  case TYPE_MOD_1:\n  case TYPE_MODEXACT_1_ODD:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->s[0].p, size, divisor);\n    break;\n  case TYPE_MOD_1C:\n  case TYPE_MODEXACT_1C_ODD:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->s[0].p, size, divisor, carry);\n    break;\n  case TYPE_PREINV_MOD_1:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->s[0].p, size, divisor, refmpn_invert_limb (divisor));\n    break;\n  case TYPE_DIV_QR_1N_PI1:\n    {\n      mp_limb_t dinv = refmpn_invert_limb (divisor);\n      e->retval = CALLING_CONVENTIONS (function)\n\t(e->d[0].p, e->s[0].p, size, e->s[1].p[0], divisor, dinv);\n      break;\n    }\n\n  case TYPE_MOD_34LSUB1:\n    e->retval = CALLING_CONVENTIONS (function) (e->s[0].p, size);\n    break;\n\n  case TYPE_UDIV_QRNND:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p[1], e->s[0].p[0], divisor);\n    break;\n  case TYPE_UDIV_QRNND_R:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->s[0].p[1], e->s[0].p[0], divisor, e->d[0].p);\n    break;\n\n  case TYPE_SBPI1_DIV_QR:\n    {\n      gmp_pi1_t dinv;\n      invert_pi1 (dinv, e->s[1].p[size2-1], e->s[1].p[size2-2]); /* FIXME: use refinvert_pi1 */\n      refmpn_copyi (e->d[1].p, e->s[0].p, size);        /* dividend */\n      refmpn_fill (e->d[0].p, size-size2, 0x98765432);  /* quotient */\n      e->retval = CALLING_CONVENTIONS (function)\n\t(e->d[0].p, e->d[1].p, size, e->s[1].p, size2, dinv.inv32);\n      refmpn_zero (e->d[1].p+size2, size-size2);    /* excess over remainder */\n    }\n    break;\n\n  case TYPE_TDIV_QR:\n    CALLING_CONVENTIONS (function) (e->d[0].p, e->d[1].p, 0,\n\t\t\t\t    e->s[0].p, size, e->s[1].p, size2);\n    break;\n\n  case TYPE_GCD_1:\n    /* Must have a non-zero src, but this probably isn't the best way to do\n       it. */\n    if (refmpn_zero_p (e->s[0].p, size))\n      e->retval = 0;\n    else\n      e->retval = CALLING_CONVENTIONS (function) (e->s[0].p, size, divisor);\n    break;\n\n  case TYPE_GCD:\n    /* Sources are destroyed, so they're saved and replaced, but a general\n       approach to this might be better.  Note that it's still e->s[0].p and\n       e->s[1].p that are passed, to get the desired alignments. */\n    {\n      mp_ptr  s0 = refmpn_malloc_limbs (size);\n      mp_ptr  s1 = refmpn_malloc_limbs (size2);\n      refmpn_copyi (s0, e->s[0].p, size);\n      refmpn_copyi (s1, e->s[1].p, size2);\n\n      mprotect_region (&s[0].region, PROT_READ|PROT_WRITE);\n      mprotect_region (&s[1].region, PROT_READ|PROT_WRITE);\n      e->retval = CALLING_CONVENTIONS (function) (e->d[0].p,\n\t\t\t\t\t\t  e->s[0].p, size,\n\t\t\t\t\t\t  e->s[1].p, size2);\n      refmpn_copyi (e->s[0].p, s0, size);\n      refmpn_copyi (e->s[1].p, s1, size2);\n      free (s0);\n      free (s1);\n    }\n    break;\n\n  case TYPE_GCD_FINDA:\n    {\n      /* FIXME: do this with a flag */\n      mp_limb_t  c[2];\n      c[0] = e->s[0].p[0];\n      c[0] += (c[0] == 0);\n      c[1] = e->s[0].p[0];\n      c[1] += (c[1] == 0);\n      e->retval = CALLING_CONVENTIONS (function) (c);\n    }\n    break;\n\n  case TYPE_MPZ_LEGENDRE:\n  case TYPE_MPZ_JACOBI:\n    {\n      mpz_t  a, b;\n      PTR(a) = e->s[0].p; SIZ(a) = (carry==0 ? size : -size);\n      PTR(b) = e->s[1].p; SIZ(b) = size2;\n      e->retval = CALLING_CONVENTIONS (function) (a, b);\n    }\n    break;\n  case TYPE_MPZ_KRONECKER:\n    {\n      mpz_t  a, b;\n      PTR(a) = e->s[0].p; SIZ(a) = ((carry&1)==0 ? size : -size);\n      PTR(b) = e->s[1].p; SIZ(b) = ((carry&2)==0 ? size2 : -size2);\n      e->retval = CALLING_CONVENTIONS (function) (a, b);\n    }\n    break;\n  case TYPE_MPZ_KRONECKER_UI:\n    {\n      mpz_t  a;\n      PTR(a) = e->s[0].p; SIZ(a) = (carry==0 ? size : -size);\n      e->retval = CALLING_CONVENTIONS(function) (a, (unsigned long)multiplier);\n    }\n    break;\n  case TYPE_MPZ_KRONECKER_SI:\n    {\n      mpz_t  a;\n      PTR(a) = e->s[0].p; SIZ(a) = (carry==0 ? size : -size);\n      e->retval = CALLING_CONVENTIONS (function) (a, (long) multiplier);\n    }\n    break;\n  case TYPE_MPZ_UI_KRONECKER:\n    {\n      mpz_t  b;\n      PTR(b) = e->s[0].p; SIZ(b) = (carry==0 ? size : -size);\n      e->retval = CALLING_CONVENTIONS(function) ((unsigned long)multiplier, b);\n    }\n    break;\n  case TYPE_MPZ_SI_KRONECKER:\n    {\n      mpz_t  b;\n      PTR(b) = e->s[0].p; SIZ(b) = (carry==0 ? size : -size);\n      e->retval = CALLING_CONVENTIONS (function) ((long) multiplier, b);\n    }\n    break;\n\n  case TYPE_MUL_MN:\n  case TYPE_MULMID_MN:\n    CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, size, e->s[1].p, size2);\n    break;\n  case TYPE_MUL_N:\n  case TYPE_MULLO_N:\n    CALLING_CONVENTIONS (function) (e->d[0].p, e->s[0].p, e->s[1].p, size);\n    break;\n  case TYPE_MULMID_N:\n    CALLING_CONVENTIONS (function) (e->d[0].p, e->s[0].p, e->s[1].p,\n\t\t\t\t    (size + 1) / 2);\n    break;\n  case TYPE_SQR:\n  case TYPE_SQRLO:\n    CALLING_CONVENTIONS (function) (e->d[0].p, e->s[0].p, size);\n    break;\n\n  case TYPE_UMUL_PPMM:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p[0], e->s[0].p[1]);\n    break;\n  case TYPE_UMUL_PPMM_R:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->s[0].p[0], e->s[0].p[1], e->d[0].p);\n    break;\n\n  case TYPE_ADDLSH_N_IP1:\n  case TYPE_ADDLSH_N_IP2:\n  case TYPE_SUBLSH_N_IP1:\n  case TYPE_LSHIFT:\n  case TYPE_LSHIFTC:\n  case TYPE_RSHIFT:\n    e->retval = CALLING_CONVENTIONS (function)\n      (e->d[0].p, e->s[0].p, size, shift);\n    break;\n\n  case TYPE_POPCOUNT:\n    e->retval = (* (unsigned long (*)(ANYARGS))\n\t\t CALLING_CONVENTIONS (function)) (e->s[0].p, size);\n    break;\n  case TYPE_HAMDIST:\n    e->retval = (* (unsigned long (*)(ANYARGS))\n\t\t CALLING_CONVENTIONS (function)) (e->s[0].p, e->s[1].p, size);\n    break;\n\n  case TYPE_SQRTREM:\n    e->retval = (* (long (*)(ANYARGS)) CALLING_CONVENTIONS (function))\n      (e->d[0].p, e->d[1].p, e->s[0].p, size);\n    break;\n\n  case TYPE_SQRT:\n    e->retval = (* (long (*)(ANYARGS)) CALLING_CONVENTIONS (function))\n      (e->d[0].p, e->s[0].p, size);\n    break;\n\n  case TYPE_ZERO:\n    CALLING_CONVENTIONS (function) (e->d[0].p, size);\n    break;\n\n  case TYPE_GET_STR:\n    {\n      size_t  sizeinbase, fill;\n      char    *dst;\n      MPN_SIZEINBASE (sizeinbase, e->s[0].p, size, base);\n      ASSERT_ALWAYS (sizeinbase <= d[0].size);\n      fill = d[0].size - sizeinbase;\n      if (d[0].high)\n\t{\n\t  memset (e->d[0].p, 0xBA, fill);\n\t  dst = (char *) e->d[0].p + fill;\n\t}\n      else\n\t{\n\t  dst = (char *) e->d[0].p;\n\t  memset (dst + sizeinbase, 0xBA, fill);\n\t}\n      if (POW2_P (base))\n\t{\n\t  e->retval = CALLING_CONVENTIONS (function) (dst, base,\n\t\t\t\t\t\t      e->s[0].p, size);\n\t}\n      else\n\t{\n\t  refmpn_copy (e->d[1].p, e->s[0].p, size);\n\t  e->retval = CALLING_CONVENTIONS (function) (dst, base,\n\t\t\t\t\t\t      e->d[1].p, size);\n\t}\n      refmpn_zero (e->d[1].p, size);  /* clobbered or unused */\n    }\n    break;\n\n case TYPE_INVERT:\n    {\n      mp_ptr scratch;\n      TMP_DECL;\n      TMP_MARK;\n      scratch = TMP_ALLOC_LIMBS (mpn_invert_itch (size));\n      CALLING_CONVENTIONS (function) (e->d[0].p, e->s[0].p, size, scratch);\n      TMP_FREE;\n    }\n    break;\n  case TYPE_BINVERT:\n    {\n      mp_ptr scratch;\n      TMP_DECL;\n      TMP_MARK;\n      scratch = TMP_ALLOC_LIMBS (mpn_binvert_itch (size));\n      CALLING_CONVENTIONS (function) (e->d[0].p, e->s[0].p, size, scratch);\n      TMP_FREE;\n    }\n    break;\n\n#ifdef EXTRA_CALL\n    EXTRA_CALL\n#endif\n\n  default:\n    printf (\"Unknown routine type %d\\n\", choice->type);\n    abort ();\n    break;\n  }\n}",
      "lines": 438,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "pointer_setup": {
      "start_point": [
        2900,
        0
      ],
      "end_point": [
        3043,
        1
      ],
      "content": "void\npointer_setup (struct each_t *e)\n{\n  int  i, j;\n\n  for (i = 0; i < NUM_DESTS; i++)\n    {\n      switch (tr->dst_size[i]) {\n      case 0:\n      case SIZE_RETVAL: /* will be adjusted later */\n\td[i].size = size;\n\tbreak;\n\n      case SIZE_1:\n\td[i].size = 1;\n\tbreak;\n      case SIZE_2:\n\td[i].size = 2;\n\tbreak;\n      case SIZE_3:\n\td[i].size = 3;\n\tbreak;\n      case SIZE_4:\n\td[i].size = 4;\n\tbreak;\n      case SIZE_6:\n\td[i].size = 6;\n\tbreak;\n\n      case SIZE_PLUS_1:\n\td[i].size = size+1;\n\tbreak;\n      case SIZE_PLUS_MSIZE_SUB_1:\n\td[i].size = size + tr->msize - 1;\n\tbreak;\n\n      case SIZE_SUM:\n\tif (tr->size2)\n\t  d[i].size = size + size2;\n\telse\n\t  d[i].size = 2*size;\n\tbreak;\n\n      case SIZE_SIZE2:\n\td[i].size = size2;\n\tbreak;\n\n      case SIZE_DIFF:\n\td[i].size = size - size2;\n\tbreak;\n\n      case SIZE_DIFF_PLUS_1:\n\td[i].size = size - size2 + 1;\n\tbreak;\n\n      case SIZE_DIFF_PLUS_3:\n\td[i].size = size - size2 + 3;\n\tbreak;\n\n      case SIZE_CEIL_HALF:\n\td[i].size = (size+1)/2;\n\tbreak;\n\n      case SIZE_GET_STR:\n\t{\n\t  mp_limb_t ff = GMP_NUMB_MAX;\n\t  MPN_SIZEINBASE (d[i].size, &ff - (size-1), size, base);\n\t}\n\tbreak;\n\n      default:\n\tprintf (\"Unrecognised dst_size type %d\\n\", tr->dst_size[i]);\n\tabort ();\n      }\n    }\n\n  /* establish e->d[].p destinations */\n  for (i = 0; i < NUM_DESTS; i++)\n    {\n      mp_size_t  offset = 0;\n\n      /* possible room for overlapping sources */\n      for (j = 0; j < numberof (overlap->s); j++)\n\tif (overlap->s[j] == i)\n\t  offset = MAX (offset, s[j].align);\n\n      if (d[i].high)\n\t{\n\t  if (tr->dst_bytes[i])\n\t    {\n\t      e->d[i].p = (mp_ptr)\n\t\t((char *) (e->d[i].region.ptr + e->d[i].region.size)\n\t\t - d[i].size - d[i].align);\n\t    }\n\t  else\n\t    {\n\t      e->d[i].p = e->d[i].region.ptr + e->d[i].region.size\n\t\t- d[i].size - d[i].align;\n\t      if (tr->overlap == OVERLAP_LOW_TO_HIGH)\n\t\te->d[i].p -= offset;\n\t    }\n\t}\n      else\n\t{\n\t  if (tr->dst_bytes[i])\n\t    {\n\t      e->d[i].p = (mp_ptr) ((char *) e->d[i].region.ptr + d[i].align);\n\t    }\n\t  else\n\t    {\n\t      e->d[i].p = e->d[i].region.ptr + d[i].align;\n\t      if (tr->overlap == OVERLAP_HIGH_TO_LOW)\n\t\te->d[i].p += offset;\n\t    }\n\t}\n    }\n\n  /* establish e->s[].p sources */\n  for (i = 0; i < NUM_SOURCES; i++)\n    {\n      int  o = overlap->s[i];\n      switch (o) {\n      case -1:\n\t/* no overlap */\n\te->s[i].p = s[i].p;\n\tbreak;\n      case 0:\n      case 1:\n\t/* overlap with d[o] */\n\tif (tr->overlap == OVERLAP_HIGH_TO_LOW)\n\t  e->s[i].p = e->d[o].p - s[i].align;\n\telse if (tr->overlap == OVERLAP_LOW_TO_HIGH)\n\t  e->s[i].p = e->d[o].p + s[i].align;\n\telse if (tr->size2 == SIZE_FRACTION)\n\t  e->s[i].p = e->d[o].p + size2;\n\telse\n\t  e->s[i].p = e->d[o].p;\n\tbreak;\n      default:\n\tabort();\n\tbreak;\n      }\n    }\n}",
      "lines": 144,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "validate_fail": {
      "start_point": [
        3046,
        0
      ],
      "end_point": [
        3058,
        1
      ],
      "content": "void\nvalidate_fail (void)\n{\n  if (tr->reference)\n    {\n      trap_location = TRAP_REF;\n      call (&ref, tr->reference);\n      trap_location = TRAP_NOWHERE;\n    }\n\n  print_all();\n  abort();\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "try_one": {
      "start_point": [
        3061,
        0
      ],
      "end_point": [
        3266,
        1
      ],
      "content": "void\ntry_one (void)\n{\n  int  i;\n\n  if (option_spinner)\n    spinner();\n  spinner_count++;\n\n  trap_location = TRAP_SETUPS;\n\n  if (tr->divisor == DIVISOR_NORM)\n    divisor |= GMP_NUMB_HIGHBIT;\n  if (tr->divisor == DIVISOR_ODD)\n    divisor |= 1;\n\n  for (i = 0; i < NUM_SOURCES; i++)\n    {\n      if (s[i].high)\n\ts[i].p = s[i].region.ptr + s[i].region.size - SRC_SIZE(i) - s[i].align;\n      else\n\ts[i].p = s[i].region.ptr + s[i].align;\n    }\n\n  pointer_setup (&ref);\n  pointer_setup (&fun);\n\n  ref.retval = 0x04152637;\n  fun.retval = 0x8C9DAEBF;\n\n  t_random (multiplier_N, tr->msize);\n\n  for (i = 0; i < NUM_SOURCES; i++)\n    {\n      if (! tr->src[i])\n\tcontinue;\n\n      mprotect_region (&s[i].region, PROT_READ|PROT_WRITE);\n      t_random (s[i].p, SRC_SIZE(i));\n\n      switch (tr->data) {\n      case DATA_NON_ZERO:\n\tif (refmpn_zero_p (s[i].p, SRC_SIZE(i)))\n\t  s[i].p[0] = 1;\n\tbreak;\n\n      case DATA_MULTIPLE_DIVISOR:\n\t/* same number of low zero bits as divisor */\n\ts[i].p[0] &= ~ LOW_ZEROS_MASK (divisor);\n\trefmpn_sub_1 (s[i].p, s[i].p, size,\n\t\t      refmpn_mod_1 (s[i].p, size, divisor));\n\tbreak;\n\n      case DATA_GCD:\n\t/* s[1] no more bits than s[0] */\n\tif (i == 1 && size2 == size)\n\t  s[1].p[size-1] &= refmpn_msbone_mask (s[0].p[size-1]);\n\n\t/* high limb non-zero */\n\ts[i].p[SRC_SIZE(i)-1] += (s[i].p[SRC_SIZE(i)-1] == 0);\n\n\t/* odd */\n\ts[i].p[0] |= 1;\n\tbreak;\n\n      case DATA_SRC0_ODD:\n\tif (i == 0)\n\t  s[i].p[0] |= 1;\n\tbreak;\n\n      case DATA_SRC1_ODD:\n\tif (i == 1)\n\t  s[i].p[0] |= 1;\n\tbreak;\n\n      case DATA_SRC1_ODD_PRIME:\n\tif (i == 1)\n\t  {\n\t    if (refmpn_zero_p (s[i].p+1, SRC_SIZE(i)-1)\n\t\t&& s[i].p[0] <=3)\n\t      s[i].p[0] = 3;\n\t    else\n\t      {\n\t\tmpz_t p;\n\t\tmpz_init (p);\n\t\tfor (;;)\n\t\t  {\n\t\t    _mpz_realloc (p, SRC_SIZE(i));\n\t\t    MPN_COPY (PTR(p), s[i].p, SRC_SIZE(i));\n\t\t    SIZ(p) = SRC_SIZE(i);\n\t\t    MPN_NORMALIZE (PTR(p), SIZ(p));\n\t\t    mpz_nextprime (p, p);\n\t\t    if (mpz_size (p) <= SRC_SIZE(i))\n\t\t      break;\n\n\t\t    t_random (s[i].p, SRC_SIZE(i));\n\t\t  }\n\t\tMPN_COPY (s[i].p, PTR(p), SIZ(p));\n\t\tif (SIZ(p) < SRC_SIZE(i))\n\t\t  MPN_ZERO (s[i].p + SIZ(p), SRC_SIZE(i) - SIZ(p));\n\t\tmpz_clear (p);\n\t      }\n\t  }\n\tbreak;\n\n      case DATA_SRC1_HIGHBIT:\n\tif (i == 1)\n\t  {\n\t    if (tr->size2)\n\t      s[i].p[size2-1] |= GMP_NUMB_HIGHBIT;\n\t    else\n\t      s[i].p[size-1] |= GMP_NUMB_HIGHBIT;\n\t  }\n\tbreak;\n\n      case DATA_SRC0_HIGHBIT:\n       if (i == 0)\n\t {\n\t   s[i].p[size-1] |= GMP_NUMB_HIGHBIT;\n\t }\n       break;\n\n      case DATA_UDIV_QRNND:\n\ts[i].p[1] %= divisor;\n\tbreak;\n      case DATA_DIV_QR_1:\n\tif (i == 1)\n\t  s[i].p[0] %= divisor;\n\tbreak;\n      }\n\n      mprotect_region (&s[i].region, PROT_READ);\n    }\n\n  for (i = 0; i < NUM_DESTS; i++)\n    {\n      if (! tr->dst[i])\n\tcontinue;\n\n      if (tr->dst0_from_src1 && i==0)\n\t{\n\t  mp_size_t  copy = MIN (d[0].size, SRC_SIZE(1));\n\t  mp_size_t  fill = MAX (0, d[0].size - copy);\n\t  MPN_COPY (fun.d[0].p, s[1].region.ptr, copy);\n\t  MPN_COPY (ref.d[0].p, s[1].region.ptr, copy);\n\t  refmpn_fill (fun.d[0].p + copy, fill, DEADVAL);\n\t  refmpn_fill (ref.d[0].p + copy, fill, DEADVAL);\n\t}\n      else if (tr->dst_bytes[i])\n\t{\n\t  memset (ref.d[i].p, 0xBA, d[i].size);\n\t  memset (fun.d[i].p, 0xBA, d[i].size);\n\t}\n      else\n\t{\n\t  refmpn_fill (ref.d[i].p, d[i].size, DEADVAL);\n\t  refmpn_fill (fun.d[i].p, d[i].size, DEADVAL);\n\t}\n    }\n\n  for (i = 0; i < NUM_SOURCES; i++)\n    {\n      if (! tr->src[i])\n\tcontinue;\n\n      if (ref.s[i].p != s[i].p)\n\t{\n\t  refmpn_copyi (ref.s[i].p, s[i].p, SRC_SIZE(i));\n\t  refmpn_copyi (fun.s[i].p, s[i].p, SRC_SIZE(i));\n\t}\n    }\n\n  if (option_print)\n    print_all();\n\n  if (tr->validate != NULL)\n    {\n      trap_location = TRAP_FUN;\n      call (&fun, choice->function);\n      trap_location = TRAP_NOWHERE;\n\n      if (! CALLING_CONVENTIONS_CHECK ())\n\t{\n\t  print_all();\n\t  abort();\n\t}\n\n      (*tr->validate) ();\n    }\n  else\n    {\n      trap_location = TRAP_REF;\n      call (&ref, tr->reference);\n      trap_location = TRAP_FUN;\n      call (&fun, choice->function);\n      trap_location = TRAP_NOWHERE;\n\n      if (! CALLING_CONVENTIONS_CHECK ())\n\t{\n\t  print_all();\n\t  abort();\n\t}\n\n      compare ();\n    }\n}",
      "lines": 206,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "try_many": {
      "start_point": [
        3312,
        0
      ],
      "end_point": [
        3372,
        1
      ],
      "content": "void\ntry_many (void)\n{\n  int   i;\n\n  {\n    unsigned long  total = 1;\n\n    total *= option_repetitions;\n    total *= option_lastsize;\n    if (tr->size2 == SIZE_FRACTION) total *= FRACTION_COUNT;\n    else if (tr->size2)             total *= (option_lastsize+1)/2;\n\n    total *= SHIFT_LIMIT;\n    total *= MULTIPLIER_COUNT;\n    total *= DIVISOR_COUNT;\n    total *= CARRY_COUNT;\n    total *= T_RAND_COUNT;\n\n    total *= HIGH_COUNT (tr->dst[0]);\n    total *= HIGH_COUNT (tr->dst[1]);\n    total *= HIGH_COUNT (tr->src[0]);\n    total *= HIGH_COUNT (tr->src[1]);\n\n    total *= ALIGN_COUNT (tr->dst[0]);\n    total *= ALIGN_COUNT (tr->dst[1]);\n    total *= ALIGN_COUNT (tr->src[0]);\n    total *= ALIGN_COUNT (tr->src[1]);\n\n    total *= OVERLAP_COUNT;\n\n    printf (\"%s %lu\\n\", choice->name, total);\n  }\n\n  spinner_count = 0;\n\n  for (i = 0; i < option_repetitions; i++)\n    SIZE_ITERATION\n      SIZE2_ITERATION\n\n      SHIFT_ITERATION\n      MULTIPLIER_ITERATION\n      DIVISOR_ITERATION\n      CARRY_ITERATION /* must be after divisor */\n      T_RAND_ITERATION\n\n      HIGH_ITERATION(d,0, tr->dst[0])\n      HIGH_ITERATION(d,1, tr->dst[1])\n      HIGH_ITERATION(s,0, tr->src[0])\n      HIGH_ITERATION(s,1, tr->src[1])\n\n      ALIGN_ITERATION(d,0, tr->dst[0])\n      ALIGN_ITERATION(d,1, tr->dst[1])\n      ALIGN_ITERATION(s,0, tr->src[0])\n      ALIGN_ITERATION(s,1, tr->src[1])\n\n      OVERLAP_ITERATION\n      try_one();\n\n  printf(\"\\n\");\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "trap": {
      "start_point": [
        3377,
        0
      ],
      "end_point": [
        3410,
        1
      ],
      "content": "void\ntrap (int sig)\n{\n  const char *name = \"noname\";\n\n  switch (sig) {\n  case SIGILL:  name = \"SIGILL\";  break;\n#ifdef SIGBUS\n  case SIGBUS:  name = \"SIGBUS\";  break;\n#endif\n  case SIGSEGV: name = \"SIGSEGV\"; break;\n  case SIGFPE:  name = \"SIGFPE\";  break;\n  }\n\n  printf (\"\\n\\nSIGNAL TRAP: %s\\n\", name);\n\n  switch (trap_location) {\n  case TRAP_REF:\n    printf (\"  in reference function: %s\\n\", tr->reference_name);\n    break;\n  case TRAP_FUN:\n    printf (\"  in test function: %s\\n\", choice->name);\n    print_all ();\n    break;\n  case TRAP_SETUPS:\n    printf (\"  in parameter setups\\n\");\n    print_all ();\n    break;\n  default:\n    printf (\"  somewhere unknown\\n\");\n    break;\n  }\n  exit (1);\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "try_init": {
      "start_point": [
        3413,
        0
      ],
      "end_point": [
        3467,
        1
      ],
      "content": "void\ntry_init (void)\n{\n#if HAVE_GETPAGESIZE\n  /* Prefer getpagesize() over sysconf(), since on SunOS 4 sysconf() doesn't\n     know _SC_PAGESIZE. */\n  pagesize = getpagesize ();\n#else\n#if HAVE_SYSCONF\n  if ((pagesize = sysconf (_SC_PAGESIZE)) == -1)\n    {\n      /* According to the linux man page, sysconf doesn't set errno */\n      fprintf (stderr, \"Cannot get sysconf _SC_PAGESIZE\\n\");\n      exit (1);\n    }\n#else\nError, error, cannot get page size\n#endif\n#endif\n\n  printf (\"pagesize is 0x%lX bytes\\n\", pagesize);\n\n  signal (SIGILL,  trap);\n#ifdef SIGBUS\n  signal (SIGBUS,  trap);\n#endif\n  signal (SIGSEGV, trap);\n  signal (SIGFPE,  trap);\n\n  {\n    int  i;\n\n    for (i = 0; i < NUM_SOURCES; i++)\n      {\n\tmalloc_region (&s[i].region, 2*option_lastsize+ALIGNMENTS-1);\n\tprintf (\"s[%d] %p to %p (0x%lX bytes)\\n\",\n\t\ti, (void *) (s[i].region.ptr),\n\t\t(void *) (s[i].region.ptr + s[i].region.size),\n\t\t(long) s[i].region.size * GMP_LIMB_BYTES);\n      }\n\n#define INIT_EACH(e,es)                                                 \\\n    for (i = 0; i < NUM_DESTS; i++)                                     \\\n      {                                                                 \\\n\tmalloc_region (&e.d[i].region, 2*option_lastsize+ALIGNMENTS-1); \\\n\tprintf (\"%s d[%d] %p to %p (0x%lX bytes)\\n\",                    \\\n\t\tes, i, (void *) (e.d[i].region.ptr),\t\t\t\\\n\t\t(void *)  (e.d[i].region.ptr + e.d[i].region.size),\t\\\n\t\t(long) e.d[i].region.size * GMP_LIMB_BYTES);         \\\n      }\n\n    INIT_EACH(ref, \"ref\");\n    INIT_EACH(fun, \"fun\");\n  }\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "strmatch_wild": {
      "start_point": [
        3469,
        0
      ],
      "end_point": [
        3491,
        1
      ],
      "content": "int\nstrmatch_wild (const char *pattern, const char *str)\n{\n  size_t  plen, slen;\n\n  /* wildcard at start */\n  if (pattern[0] == '*')\n    {\n      pattern++;\n      plen = strlen (pattern);\n      slen = strlen (str);\n      return (plen == 0\n\t      || (slen >= plen && memcmp (pattern, str+slen-plen, plen) == 0));\n    }\n\n  /* wildcard at end */\n  plen = strlen (pattern);\n  if (plen >= 1 && pattern[plen-1] == '*')\n    return (memcmp (pattern, str, plen-1) == 0);\n\n  /* no wildcards */\n  return (strcmp (pattern, str) == 0);\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "try_name": {
      "start_point": [
        3493,
        0
      ],
      "end_point": [
        3515,
        1
      ],
      "content": "void\ntry_name (const char *name)\n{\n  int  found = 0;\n  int  i;\n\n  for (i = 0; i < numberof (choice_array); i++)\n    {\n      if (strmatch_wild (name, choice_array[i].name))\n\t{\n\t  choice = &choice_array[i];\n\t  tr = &param[choice->type];\n\t  try_many ();\n\t  found = 1;\n\t}\n    }\n\n  if (!found)\n    {\n      printf (\"%s unknown\\n\", name);\n      /* exit (1); */\n    }\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "usage": {
      "start_point": [
        3518,
        0
      ],
      "end_point": [
        3555,
        1
      ],
      "content": "void\nusage (const char *prog)\n{\n  int  col = 0;\n  int  i;\n\n  printf (\"Usage: %s [options] function...\\n\", prog);\n  printf (\"    -1        use limb data 1,2,3,etc\\n\");\n  printf (\"    -9        use limb data all 0xFF..FFs\\n\");\n  printf (\"    -a zeros  use limb data all zeros\\n\");\n  printf (\"    -a ffs    use limb data all 0xFF..FFs (same as -9)\\n\");\n  printf (\"    -a 2fd    use data 0x2FFF...FFFD\\n\");\n  printf (\"    -p        print each case tried (try this if seg faulting)\\n\");\n  printf (\"    -R        seed random numbers from time()\\n\");\n  printf (\"    -r reps   set repetitions (default %d)\\n\", DEFAULT_REPETITIONS);\n  printf (\"    -s size   starting size to test\\n\");\n  printf (\"    -S size2  starting size2 to test\\n\");\n  printf (\"    -s s1-s2  range of sizes to test\\n\");\n  printf (\"    -W        don't show the spinner (use this in gdb)\\n\");\n  printf (\"    -z        disable mprotect() redzones\\n\");\n  printf (\"Default data is refmpn_random() and refmpn_random2().\\n\");\n  printf (\"\\n\");\n  printf (\"Functions that can be tested:\\n\");\n\n  for (i = 0; i < numberof (choice_array); i++)\n    {\n      if (col + 1 + strlen (choice_array[i].name) > 79)\n\t{\n\t  printf (\"\\n\");\n\t  col = 0;\n\t}\n      printf (\" %s\", choice_array[i].name);\n      col += 1 + strlen (choice_array[i].name);\n    }\n  printf (\"\\n\");\n\n  exit(1);\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        3558,
        0
      ],
      "end_point": [
        3658,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int  i;\n\n  /* unbuffered output */\n  setbuf (stdout, NULL);\n  setbuf (stderr, NULL);\n\n  /* default trace in hex, and in upper-case so can paste into bc */\n  mp_trace_base = -16;\n\n  param_init ();\n\n  {\n    unsigned long  seed = 123;\n    int   opt;\n\n    while ((opt = getopt(argc, argv, \"19a:b:E:pRr:S:s:Wz\")) != EOF)\n      {\n\tswitch (opt) {\n\tcase '1':\n\t  /* use limb data values 1, 2, 3, ... etc */\n\t  option_data = DATA_SEQ;\n\t  break;\n\tcase '9':\n\t  /* use limb data values 0xFFF...FFF always */\n\t  option_data = DATA_FFS;\n\t  break;\n\tcase 'a':\n\t  if (strcmp (optarg, \"zeros\") == 0)     option_data = DATA_ZEROS;\n\t  else if (strcmp (optarg, \"seq\") == 0)  option_data = DATA_SEQ;\n\t  else if (strcmp (optarg, \"ffs\") == 0)  option_data = DATA_FFS;\n\t  else if (strcmp (optarg, \"2fd\") == 0)  option_data = DATA_2FD;\n\t  else\n\t    {\n\t      fprintf (stderr, \"unrecognised data option: %s\\n\", optarg);\n\t      exit (1);\n\t    }\n\t  break;\n\tcase 'b':\n\t  mp_trace_base = atoi (optarg);\n\t  break;\n\tcase 'E':\n\t  /* re-seed */\n\t  sscanf (optarg, \"%lu\", &seed);\n\t  printf (\"Re-seeding with %lu\\n\", seed);\n\t  break;\n\tcase 'p':\n\t  option_print = 1;\n\t  break;\n\tcase 'R':\n\t  /* randomize */\n\t  seed = time (NULL);\n\t  printf (\"Seeding with %lu, re-run using \\\"-E %lu\\\"\\n\", seed, seed);\n\t  break;\n\tcase 'r':\n\t  option_repetitions = atoi (optarg);\n\t  break;\n\tcase 's':\n\t  {\n\t    char  *p;\n\t    option_firstsize = strtol (optarg, 0, 0);\n\t    if ((p = strchr (optarg, '-')) != NULL)\n\t      option_lastsize = strtol (p+1, 0, 0);\n\t  }\n\t  break;\n\tcase 'S':\n\t  /* -S <size> sets the starting size for the second of a two size\n\t     routine (like mpn_mul_basecase) */\n\t  option_firstsize2 = strtol (optarg, 0, 0);\n\t  break;\n\tcase 'W':\n\t  /* use this when running in the debugger */\n\t  option_spinner = 0;\n\t  break;\n\tcase 'z':\n\t  /* disable redzones */\n\t  option_redzones = 0;\n\t  break;\n\tcase '?':\n\t  usage (argv[0]);\n\t  break;\n\t}\n      }\n\n    gmp_randinit_default (__gmp_rands);\n    __gmp_rands_initialized = 1;\n    gmp_randseed_ui (__gmp_rands, seed);\n  }\n\n  try_init();\n\n  if (argc <= optind)\n    usage (argv[0]);\n\n  for (i = optind; i < argc; i++)\n    try_name (argv[i]);\n\n  return 0;\n}",
      "lines": 101,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/devel/tst-addsub.c": {
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_size_t alloc_size, max_size, size, i, cumul_size;\n  mp_ptr s1, s2, dx, dy;\n  int s1_align, s2_align, d_align;\n  long pass, n_passes;\n  mp_limb_t cx, cy;\n\n  max_size = SIZE;\n  n_passes = 1000000;\n\n  argc--; argv++;\n  if (argc)\n    {\n      max_size = atol (*argv);\n      argc--; argv++;\n    }\n\n  alloc_size = max_size + 32;\n  s1 = malloc (alloc_size * GMP_LIMB_BYTES);\n  s2 = malloc (alloc_size * GMP_LIMB_BYTES);\n  dx = malloc (alloc_size * GMP_LIMB_BYTES);\n  dy = malloc (alloc_size * GMP_LIMB_BYTES);\n\n  cumul_size = 0;\n  for (pass = 0; pass < n_passes; pass++)\n    {\n      size = random () % max_size + 1;\n\n      cumul_size += size;\n      if (cumul_size >= 1000000)\n\t{\n\t  cumul_size -= 1000000;\n\t  printf (\"\\r%ld\", pass); fflush (stdout);\n\t}\n      s1_align = random () % 32;\n      s2_align = random () % 32;\n      d_align = random () % 32;\n\n      mpn_random2 (s1 + s1_align, size);\n      mpn_random2 (s2 + s2_align, size);\n\n      for (i = 0; i < alloc_size; i++)\n\tdx[i] = dy[i] = i + 0x9876500;\n\n      cx = TESTCALL (dx + d_align, s1 + s1_align, s2 + s2_align, size);\n      cy = REFCALL (dy + d_align, s1 + s1_align, s2 + s2_align, size);\n\n      if (cx != cy || mpn_cmp (dx, dy, alloc_size) != 0)\n\tabort ();\n    }\n\n  printf (\"%ld passes OK\\n\", n_passes);\n  exit (0);\n}",
      "lines": 56,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/misc/t-locale.c": {
    "check_input": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "void\ncheck_input (void)\n{\n  static const char *point[] = {\n    \".\", \",\", \"WU\", \"STR\", \"ZTV***\"\n  };\n\n  static const struct {\n    const char  *str;\n    double      d;\n  } data[] = {\n\n    { \"1%s\",   1.0 },\n    { \"1%s0\",  1.0 },\n    { \"1%s00\", 1.0 },\n\n    { \"%s5\",    0.5 },\n    { \"0%s5\",   0.5 },\n    { \"00%s5\",  0.5 },\n    { \"00%s50\", 0.5 },\n\n    { \"1%s5\",    1.5 },\n    { \"1%s5e1\", 15.0 },\n  };\n\n  int     i, j, neg, ret;\n  char    str[128];\n  mpf_t   f;\n  double  d;\n\n  mpf_init (f);\n\n  for (i = 0; i < numberof (point); i++)\n    {\n      decimal_point = (const char *) point[i];\n\n      for (neg = 0; neg <= 1; neg++)\n        {\n          for (j = 0; j < numberof (data); j++)\n            {\n              strcpy (str, neg ? \"-\" : \"\");\n              sprintf (str+strlen(str), data[j].str, decimal_point);\n\n              d = data[j].d;\n              if (neg)\n                d = -d;\n\n              mpf_set_d (f, 123.0);\n              if (mpf_set_str (f, str, 10) != 0)\n                {\n                  printf (\"mpf_set_str error\\n\");\n                  printf (\"  point  %s\\n\", decimal_point);\n                  printf (\"  str    %s\\n\", str);\n                  abort ();\n                }\n              if (mpf_cmp_d (f, d) != 0)\n                {\n                  printf    (\"mpf_set_str wrong result\\n\");\n                  printf    (\"  point  %s\\n\", decimal_point);\n                  printf    (\"  str    %s\\n\", str);\n                  mpf_trace (\"  f\", f);\n                  printf    (\"  d=%g\\n\", d);\n                  abort ();\n                }\n\n              mpf_set_d (f, 123.0);\n              ret = gmp_sscanf (str, \"%Ff\", f);\n              if (ret != 1)\n                {\n                  printf (\"gmp_sscanf wrong return value\\n\");\n                  printf (\"  point  %s\\n\", decimal_point);\n                  printf (\"  str    %s\\n\", str);\n                  printf (\"  ret    %d\\n\", ret);\n                  abort ();\n                }\n              if (mpf_cmp_d (f, d) != 0)\n                {\n                  printf    (\"gmp_sscanf wrong result\\n\");\n                  printf    (\"  point  %s\\n\", decimal_point);\n                  printf    (\"  str    %s\\n\", str);\n                  mpf_trace (\"  f\", f);\n                  printf    (\"  d=%g\\n\", d);\n                  abort ();\n                }\n            }\n        }\n    }\n  mpf_clear (f);\n}",
      "lines": 89,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* The localeconv replacement breaks printf \"%lu\" on SunOS 4, so we can't\n     print the seed in tests_rand_start().  Nothing random is used in this\n     program though, so just use the memory tests alone.  */\n  tests_memory_start ();\n\n  {\n    mpf_t  f;\n    char   buf[128];\n    mpf_init (f);\n    decimal_point = \",\";\n    mpf_set_d (f, 1.5);\n    gmp_snprintf (buf, sizeof(buf), \"%.1Ff\", f);\n    mpf_clear (f);\n    if (strcmp (buf, \"1,5\") != 0)\n      {\n        printf (\"Test skipped, replacing localeconv/nl_langinfo doesn't work\\n\");\n        goto done;\n      }\n  }\n\n  check_input ();\n\n done:\n  tests_memory_end ();\n  exit (0);\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/misc/t-printf.c": {
    "check_plain": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\ncheck_plain (const char *want, const char *fmt_orig, ...)\n{\n  char        got[MAX_OUTPUT];\n  int         got_len, want_len;\n  size_t      fmtsize;\n  char        *fmt, *q;\n  const char  *p;\n  va_list     ap;\n  va_start (ap, fmt_orig);\n\n  if (! option_check_printf)\n    return;\n\n  fmtsize = strlen (fmt_orig) + 1;\n  fmt = (char *) (*__gmp_allocate_func) (fmtsize);\n\n  for (p = fmt_orig, q = fmt; *p != '\\0'; p++)\n    {\n      switch (*p) {\n      case 'a':\n      case 'A':\n\t/* The exact value of the exponent isn't guaranteed in glibc, and it\n\t   and gmp_printf do slightly different things, so don't compare\n\t   directly. */\n\tgoto done;\n      case 'F':\n\tif (p > fmt_orig && *(p-1) == '.')\n\t  goto done;  /* don't test the \"all digits\" cases */\n\t/* discard 'F' type */\n\tbreak;\n      case 'Z':\n\t/* transmute */\n\t*q++ = 'l';\n\tbreak;\n      default:\n\t*q++ = *p;\n\tbreak;\n      }\n    }\n  *q = '\\0';\n\n  want_len = strlen (want);\n  ASSERT_ALWAYS (want_len < sizeof(got));\n\n  got_len = vsprintf (got, fmt, ap);\n\n  if (got_len != want_len || strcmp (got, want) != 0)\n    {\n      printf (\"wanted data doesn't match plain vsprintf\\n\");\n      printf (\"  fmt      |%s|\\n\", fmt);\n      printf (\"  got      |%s|\\n\", got);\n      printf (\"  want     |%s|\\n\", want);\n      printf (\"  got_len  %d\\n\", got_len);\n      printf (\"  want_len %d\\n\", want_len);\n      abort ();\n    }\n\n done:\n  (*__gmp_free_func) (fmt, fmtsize);\n}",
      "lines": 61,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "check_vsprintf": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "void\ncheck_vsprintf (const char *want, const char *fmt, va_list ap)\n{\n  char  got[MAX_OUTPUT];\n  int   got_len, want_len;\n\n  want_len = strlen (want);\n  got_len = gmp_vsprintf (got, fmt, ap);\n\n  if (got_len != want_len || strcmp (got, want) != 0)\n    {\n      printf (\"gmp_vsprintf wrong\\n\");\n      printf (\"  fmt      |%s|\\n\", fmt);\n      printf (\"  got      |%s|\\n\", got);\n      printf (\"  want     |%s|\\n\", want);\n      printf (\"  got_len  %d\\n\", got_len);\n      printf (\"  want_len %d\\n\", want_len);\n      abort ();\n    }\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_vfprintf": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\ncheck_vfprintf (const char *want, const char *fmt, va_list ap)\n{\n  char  got[MAX_OUTPUT];\n  int   got_len, want_len, fread_len;\n  long  ftell_len;\n\n  want_len = strlen (want);\n\n  rewind (check_vfprintf_fp);\n  got_len = gmp_vfprintf (check_vfprintf_fp, fmt, ap);\n  ASSERT_ALWAYS (got_len != -1);\n  ASSERT_ALWAYS (fflush (check_vfprintf_fp) == 0);\n\n  ftell_len = ftell (check_vfprintf_fp);\n  ASSERT_ALWAYS (ftell_len != -1);\n\n  rewind (check_vfprintf_fp);\n  ASSERT_ALWAYS (ftell_len <= sizeof(got));\n  fread_len = fread (got, 1, ftell_len, check_vfprintf_fp);\n\n  if (got_len != want_len\n      || ftell_len != want_len\n      || fread_len != want_len\n      || memcmp (got, want, want_len) != 0)\n    {\n      printf (\"gmp_vfprintf wrong\\n\");\n      printf (\"  fmt       |%s|\\n\", fmt);\n      printf (\"  got       |%.*s|\\n\", fread_len, got);\n      printf (\"  want      |%s|\\n\", want);\n      printf (\"  got_len   %d\\n\", got_len);\n      printf (\"  ftell_len %ld\\n\", ftell_len);\n      printf (\"  fread_len %d\\n\", fread_len);\n      printf (\"  want_len  %d\\n\", want_len);\n      abort ();\n    }\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_vsnprintf": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "void\ncheck_vsnprintf (const char *want, const char *fmt, va_list ap)\n{\n  char    got[MAX_OUTPUT+1];\n  int     ret, got_len, want_len;\n  size_t  bufsize;\n\n  want_len = strlen (want);\n\n  bufsize = -1;\n  for (;;)\n    {\n      /* do 0 to 5, then want-5 to want+5 */\n      bufsize++;\n      if (bufsize > 5 && bufsize < want_len-5)\n\tbufsize = want_len-5;\n      if (bufsize > want_len + 5)\n\tbreak;\n      ASSERT_ALWAYS (bufsize+1 <= sizeof (got));\n\n      got[bufsize] = '!';\n      ret = gmp_vsnprintf (got, bufsize, fmt, ap);\n\n      got_len = MIN (MAX(1,bufsize)-1, want_len);\n\n      if (got[bufsize] != '!')\n\t{\n\t  printf (\"gmp_vsnprintf overwrote bufsize sentinel\\n\");\n\t  goto error;\n\t}\n\n      if (ret != want_len)\n\t{\n\t  printf (\"gmp_vsnprintf return value wrong\\n\");\n\t  goto error;\n\t}\n\n      if (bufsize > 0)\n\t{\n\t  if (memcmp (got, want, got_len) != 0 || got[got_len] != '\\0')\n\t    {\n\t      printf (\"gmp_vsnprintf wrong result string\\n\");\n\t    error:\n\t      printf (\"  fmt       |%s|\\n\", fmt);\n\t      printf (\"  bufsize   %lu\\n\", (unsigned long) bufsize);\n\t      printf (\"  got       |%s|\\n\", got);\n\t      printf (\"  want      |%.*s|\\n\", got_len, want);\n\t      printf (\"  want full |%s|\\n\", want);\n\t      printf (\"  ret       %d\\n\", ret);\n\t      printf (\"  want_len  %d\\n\", want_len);\n\t      abort ();\n\t    }\n\t}\n    }\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "check_vasprintf": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "void\ncheck_vasprintf (const char *want, const char *fmt, va_list ap)\n{\n  char  *got;\n  int   got_len, want_len;\n\n  want_len = strlen (want);\n  got_len = gmp_vasprintf (&got, fmt, ap);\n\n  if (got_len != want_len || strcmp (got, want) != 0)\n    {\n      printf (\"gmp_vasprintf wrong\\n\");\n      printf (\"  fmt      |%s|\\n\", fmt);\n      printf (\"  got      |%s|\\n\", got);\n      printf (\"  want     |%s|\\n\", want);\n      printf (\"  got_len  %d\\n\", got_len);\n      printf (\"  want_len %d\\n\", want_len);\n      abort ();\n    }\n  (*__gmp_free_func) (got, strlen(got)+1);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_obstack_vprintf": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "void\ncheck_obstack_vprintf (const char *want, const char *fmt, va_list ap)\n{\n#if HAVE_OBSTACK_VPRINTF\n  struct obstack  ob;\n  int   got_len, want_len, ob_len;\n  char  *got;\n\n  want_len = strlen (want);\n\n  obstack_init (&ob);\n  got_len = gmp_obstack_vprintf (&ob, fmt, ap);\n  got = (char *) obstack_base (&ob);\n  ob_len = obstack_object_size (&ob);\n\n  if (got_len != want_len\n      || ob_len != want_len\n      || memcmp (got, want, want_len) != 0)\n    {\n      printf (\"gmp_obstack_vprintf wrong\\n\");\n      printf (\"  fmt      |%s|\\n\", fmt);\n      printf (\"  got      |%s|\\n\", got);\n      printf (\"  want     |%s|\\n\", want);\n      printf (\"  got_len  %d\\n\", got_len);\n      printf (\"  ob_len   %d\\n\", ob_len);\n      printf (\"  want_len %d\\n\", want_len);\n      abort ();\n    }\n  obstack_free (&ob, NULL);\n#endif\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_one": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "void\ncheck_one (const char *want, const char *fmt, ...)\n{\n  va_list ap;\n  va_start (ap, fmt);\n\n  /* simplest first */\n  check_vsprintf (want, fmt, ap);\n  check_vfprintf (want, fmt, ap);\n  check_vsnprintf (want, fmt, ap);\n  check_vasprintf (want, fmt, ap);\n  check_obstack_vprintf (want, fmt, ap);\n}",
      "lines": 13,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_z": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "void\ncheck_z (void)\n{\n  static const struct {\n    const char  *fmt;\n    const char  *z;\n    const char  *want;\n  } data[] = {\n    { \"%Zd\", \"0\",    \"0\" },\n    { \"%Zd\", \"1\",    \"1\" },\n    { \"%Zd\", \"123\",  \"123\" },\n    { \"%Zd\", \"-1\",   \"-1\" },\n    { \"%Zd\", \"-123\", \"-123\" },\n\n    { \"%+Zd\", \"0\",      \"+0\" },\n    { \"%+Zd\", \"123\",  \"+123\" },\n    { \"%+Zd\", \"-123\", \"-123\" },\n\n    { \"%Zx\",  \"123\",   \"7b\" },\n    { \"%ZX\",  \"123\",   \"7B\" },\n    { \"%Zx\", \"-123\",  \"-7b\" },\n    { \"%ZX\", \"-123\",  \"-7B\" },\n    { \"%Zo\",  \"123\",  \"173\" },\n    { \"%Zo\", \"-123\", \"-173\" },\n\n    { \"%#Zx\",    \"0\",     \"0\" },\n    { \"%#ZX\",    \"0\",     \"0\" },\n    { \"%#Zx\",  \"123\",  \"0x7b\" },\n    { \"%#ZX\",  \"123\",  \"0X7B\" },\n    { \"%#Zx\", \"-123\", \"-0x7b\" },\n    { \"%#ZX\", \"-123\", \"-0X7B\" },\n\n    { \"%#Zo\",    \"0\",     \"0\" },\n    { \"%#Zo\",  \"123\",  \"0173\" },\n    { \"%#Zo\", \"-123\", \"-0173\" },\n\n    { \"%10Zd\",      \"0\", \"         0\" },\n    { \"%10Zd\",    \"123\", \"       123\" },\n    { \"%10Zd\",   \"-123\", \"      -123\" },\n\n    { \"%-10Zd\",     \"0\", \"0         \" },\n    { \"%-10Zd\",   \"123\", \"123       \" },\n    { \"%-10Zd\",  \"-123\", \"-123      \" },\n\n    { \"%+10Zd\",   \"123\", \"      +123\" },\n    { \"%+-10Zd\",  \"123\", \"+123      \" },\n    { \"%+10Zd\",  \"-123\", \"      -123\" },\n    { \"%+-10Zd\", \"-123\", \"-123      \" },\n\n    { \"%08Zd\",    \"0\", \"00000000\" },\n    { \"%08Zd\",  \"123\", \"00000123\" },\n    { \"%08Zd\", \"-123\", \"-0000123\" },\n\n    { \"%+08Zd\",    \"0\", \"+0000000\" },\n    { \"%+08Zd\",  \"123\", \"+0000123\" },\n    { \"%+08Zd\", \"-123\", \"-0000123\" },\n\n    { \"%#08Zx\",    \"0\", \"00000000\" },\n    { \"%#08Zx\",  \"123\", \"0x00007b\" },\n    { \"%#08Zx\", \"-123\", \"-0x0007b\" },\n\n    { \"%+#08Zx\",    \"0\", \"+0000000\" },\n    { \"%+#08Zx\",  \"123\", \"+0x0007b\" },\n    { \"%+#08Zx\", \"-123\", \"-0x0007b\" },\n\n    { \"%.0Zd\", \"0\", \"\" },\n    { \"%.1Zd\", \"0\", \"0\" },\n    { \"%.2Zd\", \"0\", \"00\" },\n    { \"%.3Zd\", \"0\", \"000\" },\n  };\n\n  int        i, j;\n  mpz_t      z;\n  char       *nfmt;\n  mp_size_t  nsize, zeros;\n\n  mpz_init (z);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (z, data[i].z, 0);\n\n      /* don't try negatives or forced sign in hex or octal */\n      if (mpz_fits_slong_p (z)\n\t  && ! (hex_or_octal_p (data[i].fmt)\n\t\t&& (strchr (data[i].fmt, '+') != NULL || mpz_sgn(z) < 0)))\n\t{\n\t  check_plain (data[i].want, data[i].fmt, mpz_get_si (z));\n\t}\n\n      check_one (data[i].want, data[i].fmt, z);\n\n      /* Same again, with %N and possibly some high zero limbs */\n      nfmt = __gmp_allocate_strdup (data[i].fmt);\n      for (j = 0; nfmt[j] != '\\0'; j++)\n\tif (nfmt[j] == 'Z')\n\t  nfmt[j] = 'N';\n      for (zeros = 0; zeros <= 3; zeros++)\n\t{\n\t  nsize = ABSIZ(z)+zeros;\n\t  MPZ_REALLOC (z, nsize);\n\t  nsize = (SIZ(z) >= 0 ? nsize : -nsize);\n\t  refmpn_zero (PTR(z)+ABSIZ(z), zeros);\n\t  check_one (data[i].want, nfmt, PTR(z), nsize);\n\t}\n      __gmp_free_func (nfmt, strlen(nfmt)+1);\n    }\n\n  mpz_clear (z);\n}",
      "lines": 110,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "check_q": {
      "start_point": [
        432,
        0
      ],
      "end_point": [
        537,
        1
      ],
      "content": "void\ncheck_q (void)\n{\n  static const struct {\n    const char  *fmt;\n    const char  *q;\n    const char  *want;\n  } data[] = {\n    { \"%Qd\",    \"0\",    \"0\" },\n    { \"%Qd\",    \"1\",    \"1\" },\n    { \"%Qd\",  \"123\",  \"123\" },\n    { \"%Qd\",   \"-1\",   \"-1\" },\n    { \"%Qd\", \"-123\", \"-123\" },\n    { \"%Qd\",  \"3/2\",  \"3/2\" },\n    { \"%Qd\", \"-3/2\", \"-3/2\" },\n\n    { \"%+Qd\", \"0\",      \"+0\" },\n    { \"%+Qd\", \"123\",  \"+123\" },\n    { \"%+Qd\", \"-123\", \"-123\" },\n    { \"%+Qd\", \"5/8\",  \"+5/8\" },\n    { \"%+Qd\", \"-5/8\", \"-5/8\" },\n\n    { \"%Qx\",  \"123\",   \"7b\" },\n    { \"%QX\",  \"123\",   \"7B\" },\n    { \"%Qx\",  \"15/16\", \"f/10\" },\n    { \"%QX\",  \"15/16\", \"F/10\" },\n    { \"%Qx\", \"-123\",  \"-7b\" },\n    { \"%QX\", \"-123\",  \"-7B\" },\n    { \"%Qx\", \"-15/16\", \"-f/10\" },\n    { \"%QX\", \"-15/16\", \"-F/10\" },\n    { \"%Qo\",  \"123\",  \"173\" },\n    { \"%Qo\", \"-123\", \"-173\" },\n    { \"%Qo\",  \"16/17\",  \"20/21\" },\n    { \"%Qo\", \"-16/17\", \"-20/21\" },\n\n    { \"%#Qx\",    \"0\",     \"0\" },\n    { \"%#QX\",    \"0\",     \"0\" },\n    { \"%#Qx\",  \"123\",  \"0x7b\" },\n    { \"%#QX\",  \"123\",  \"0X7B\" },\n    { \"%#Qx\",  \"5/8\",  \"0x5/0x8\" },\n    { \"%#QX\",  \"5/8\",  \"0X5/0X8\" },\n    { \"%#Qx\", \"-123\", \"-0x7b\" },\n    { \"%#QX\", \"-123\", \"-0X7B\" },\n    { \"%#Qx\", \"-5/8\", \"-0x5/0x8\" },\n    { \"%#QX\", \"-5/8\", \"-0X5/0X8\" },\n    { \"%#Qo\",    \"0\",     \"0\" },\n    { \"%#Qo\",  \"123\",  \"0173\" },\n    { \"%#Qo\", \"-123\", \"-0173\" },\n    { \"%#Qo\",  \"5/7\",  \"05/07\" },\n    { \"%#Qo\", \"-5/7\", \"-05/07\" },\n\n    /* zero denominator and showbase */\n    { \"%#10Qo\", \"0/0\",     \"       0/0\" },\n    { \"%#10Qd\", \"0/0\",     \"       0/0\" },\n    { \"%#10Qx\", \"0/0\",     \"       0/0\" },\n    { \"%#10Qo\", \"123/0\",   \"    0173/0\" },\n    { \"%#10Qd\", \"123/0\",   \"     123/0\" },\n    { \"%#10Qx\", \"123/0\",   \"    0x7b/0\" },\n    { \"%#10QX\", \"123/0\",   \"    0X7B/0\" },\n    { \"%#10Qo\", \"-123/0\",  \"   -0173/0\" },\n    { \"%#10Qd\", \"-123/0\",  \"    -123/0\" },\n    { \"%#10Qx\", \"-123/0\",  \"   -0x7b/0\" },\n    { \"%#10QX\", \"-123/0\",  \"   -0X7B/0\" },\n\n    { \"%10Qd\",      \"0\", \"         0\" },\n    { \"%-10Qd\",     \"0\", \"0         \" },\n    { \"%10Qd\",    \"123\", \"       123\" },\n    { \"%-10Qd\",   \"123\", \"123       \" },\n    { \"%10Qd\",   \"-123\", \"      -123\" },\n    { \"%-10Qd\",  \"-123\", \"-123      \" },\n\n    { \"%+10Qd\",   \"123\", \"      +123\" },\n    { \"%+-10Qd\",  \"123\", \"+123      \" },\n    { \"%+10Qd\",  \"-123\", \"      -123\" },\n    { \"%+-10Qd\", \"-123\", \"-123      \" },\n\n    { \"%08Qd\",    \"0\", \"00000000\" },\n    { \"%08Qd\",  \"123\", \"00000123\" },\n    { \"%08Qd\", \"-123\", \"-0000123\" },\n\n    { \"%+08Qd\",    \"0\", \"+0000000\" },\n    { \"%+08Qd\",  \"123\", \"+0000123\" },\n    { \"%+08Qd\", \"-123\", \"-0000123\" },\n\n    { \"%#08Qx\",    \"0\", \"00000000\" },\n    { \"%#08Qx\",  \"123\", \"0x00007b\" },\n    { \"%#08Qx\", \"-123\", \"-0x0007b\" },\n\n    { \"%+#08Qx\",    \"0\", \"+0000000\" },\n    { \"%+#08Qx\",  \"123\", \"+0x0007b\" },\n    { \"%+#08Qx\", \"-123\", \"-0x0007b\" },\n  };\n\n  int    i;\n  mpq_t  q;\n\n  mpq_init (q);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpq_set_str_or_abort (q, data[i].q, 0);\n      check_one (data[i].want, data[i].fmt, q);\n    }\n\n  mpq_clear (q);\n}",
      "lines": 106,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_f": {
      "start_point": [
        539,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "void\ncheck_f (void)\n{\n  static const struct {\n    const char  *fmt;\n    const char  *f;\n    const char  *want;\n\n  } data[] = {\n\n    { \"%Ff\",    \"0\",    \"0.000000\" },\n    { \"%Ff\",  \"123\",  \"123.000000\" },\n    { \"%Ff\", \"-123\", \"-123.000000\" },\n\n    { \"%+Ff\",    \"0\",   \"+0.000000\" },\n    { \"%+Ff\",  \"123\", \"+123.000000\" },\n    { \"%+Ff\", \"-123\", \"-123.000000\" },\n\n    { \"%.0Ff\",    \"0\",    \"0\" },\n    { \"%.0Ff\",  \"123\",  \"123\" },\n    { \"%.0Ff\", \"-123\", \"-123\" },\n\n    { \"%8.0Ff\",    \"0\", \"       0\" },\n    { \"%8.0Ff\",  \"123\", \"     123\" },\n    { \"%8.0Ff\", \"-123\", \"    -123\" },\n\n    { \"%08.0Ff\",    \"0\", \"00000000\" },\n    { \"%08.0Ff\",  \"123\", \"00000123\" },\n    { \"%08.0Ff\", \"-123\", \"-0000123\" },\n\n    { \"%10.2Ff\",       \"0\", \"      0.00\" },\n    { \"%10.2Ff\",    \"0.25\", \"      0.25\" },\n    { \"%10.2Ff\",  \"123.25\", \"    123.25\" },\n    { \"%10.2Ff\", \"-123.25\", \"   -123.25\" },\n\n    { \"%-10.2Ff\",       \"0\", \"0.00      \" },\n    { \"%-10.2Ff\",    \"0.25\", \"0.25      \" },\n    { \"%-10.2Ff\",  \"123.25\", \"123.25    \" },\n    { \"%-10.2Ff\", \"-123.25\", \"-123.25   \" },\n\n    { \"%.2Ff\", \"0.00000000000001\", \"0.00\" },\n    { \"%.2Ff\", \"0.002\",            \"0.00\" },\n    { \"%.2Ff\", \"0.008\",            \"0.01\" },\n\n    { \"%.0Ff\", \"123.00000000000001\", \"123\" },\n    { \"%.0Ff\", \"123.2\",              \"123\" },\n    { \"%.0Ff\", \"123.8\",              \"124\" },\n\n    { \"%.0Ff\",  \"999999.9\", \"1000000\" },\n    { \"%.0Ff\", \"3999999.9\", \"4000000\" },\n\n    { \"%Fe\",    \"0\",  \"0.000000e+00\" },\n    { \"%Fe\",    \"1\",  \"1.000000e+00\" },\n    { \"%Fe\",  \"123\",  \"1.230000e+02\" },\n\n    { \"%FE\",    \"0\",  \"0.000000E+00\" },\n    { \"%FE\",    \"1\",  \"1.000000E+00\" },\n    { \"%FE\",  \"123\",  \"1.230000E+02\" },\n\n    { \"%Fe\",    \"0\",  \"0.000000e+00\" },\n    { \"%Fe\",    \"1\",  \"1.000000e+00\" },\n\n    { \"%.0Fe\",     \"10000000000\",    \"1e+10\" },\n    { \"%.0Fe\",    \"-10000000000\",   \"-1e+10\" },\n\n    { \"%.2Fe\",     \"10000000000\",  \"1.00e+10\" },\n    { \"%.2Fe\",    \"-10000000000\", \"-1.00e+10\" },\n\n    { \"%8.0Fe\",    \"10000000000\", \"   1e+10\" },\n    { \"%8.0Fe\",   \"-10000000000\", \"  -1e+10\" },\n\n    { \"%-8.0Fe\",   \"10000000000\", \"1e+10   \" },\n    { \"%-8.0Fe\",  \"-10000000000\", \"-1e+10  \" },\n\n    { \"%12.2Fe\",   \"10000000000\", \"    1.00e+10\" },\n    { \"%12.2Fe\",  \"-10000000000\", \"   -1.00e+10\" },\n\n    { \"%012.2Fe\",  \"10000000000\", \"00001.00e+10\" },\n    { \"%012.2Fe\", \"-10000000000\", \"-0001.00e+10\" },\n\n    { \"%Fg\",   \"0\", \"0\" },\n    { \"%Fg\",   \"1\", \"1\" },\n    { \"%Fg\",   \"-1\", \"-1\" },\n\n    { \"%.0Fg\", \"0\", \"0\" },\n    { \"%.0Fg\", \"1\", \"1\" },\n    { \"%.0Fg\", \"-1\", \"-1\" },\n\n    { \"%.1Fg\", \"100\", \"1e+02\" },\n    { \"%.2Fg\", \"100\", \"1e+02\" },\n    { \"%.3Fg\", \"100\", \"100\" },\n    { \"%.4Fg\", \"100\", \"100\" },\n\n    { \"%Fg\", \"0.001\",    \"0.001\" },\n    { \"%Fg\", \"0.0001\",   \"0.0001\" },\n    { \"%Fg\", \"0.00001\",  \"1e-05\" },\n    { \"%Fg\", \"0.000001\", \"1e-06\" },\n\n    { \"%.4Fg\", \"1.00000000000001\", \"1\" },\n    { \"%.4Fg\", \"100000000000001\",  \"1e+14\" },\n\n    { \"%.4Fg\", \"12345678\", \"1.235e+07\" },\n\n    { \"%Fa\", \"0\",\"0x0p+0\" },\n    { \"%FA\", \"0\",\"0X0P+0\" },\n\n    { \"%Fa\", \"1\",\"0x1p+0\" },\n    { \"%Fa\", \"65535\",\"0xf.fffp+12\" },\n    { \"%Fa\", \"65536\",\"0x1p+16\" },\n    { \"%F.10a\", \"65536\",\"0x1.0000000000p+16\" },\n    { \"%F.1a\", \"65535\",\"0x1.0p+16\" },\n    { \"%F.0a\", \"65535\",\"0x1p+16\" },\n\n    { \"%.2Ff\", \"0.99609375\", \"1.00\" },\n    { \"%.Ff\",  \"0.99609375\", \"0.99609375\" },\n    { \"%.Fe\",  \"0.99609375\", \"9.9609375e-01\" },\n    { \"%.Fg\",  \"0.99609375\", \"0.99609375\" },\n    { \"%.20Fg\",  \"1000000\", \"1000000\" },\n    { \"%.Fg\",  \"1000000\", \"1000000\" },\n\n    { \"%#.0Ff\", \"1\", \"1.\" },\n    { \"%#.0Fe\", \"1\", \"1.e+00\" },\n    { \"%#.0Fg\", \"1\", \"1.\" },\n\n    { \"%#.1Ff\", \"1\", \"1.0\" },\n    { \"%#.1Fe\", \"1\", \"1.0e+00\" },\n    { \"%#.1Fg\", \"1\", \"1.\" },\n\n    { \"%#.4Ff\", \"1234\", \"1234.0000\" },\n    { \"%#.4Fe\", \"1234\", \"1.2340e+03\" },\n    { \"%#.4Fg\", \"1234\", \"1234.\" },\n\n    { \"%#.8Ff\", \"1234\", \"1234.00000000\" },\n    { \"%#.8Fe\", \"1234\", \"1.23400000e+03\" },\n    { \"%#.8Fg\", \"1234\", \"1234.0000\" },\n\n  };\n\n  int     i;\n  mpf_t   f;\n  double  d;\n\n  mpf_init2 (f, 256L);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      if (data[i].f[0] == '0' && data[i].f[1] == 'x')\n\tmpf_set_str_or_abort (f, data[i].f, 16);\n      else\n\tmpf_set_str_or_abort (f, data[i].f, 10);\n\n      /* if mpf->double doesn't truncate, then expect same result */\n      d = mpf_get_d (f);\n      if (mpf_cmp_d (f, d) == 0)\n\tcheck_plain (data[i].want, data[i].fmt, d);\n\n      check_one (data[i].want, data[i].fmt, f);\n    }\n\n  mpf_clear (f);\n}",
      "lines": 161,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_limb": {
      "start_point": [
        702,
        0
      ],
      "end_point": [
        736,
        1
      ],
      "content": "void\ncheck_limb (void)\n{\n  int        i;\n  mp_limb_t  limb;\n  mpz_t      z;\n  char       *s;\n\n  check_one (\"0\", \"%Md\", CNST_LIMB(0));\n  check_one (\"1\", \"%Md\", CNST_LIMB(1));\n\n  /* \"i\" many 1 bits, tested against mpz_get_str in decimal and hex */\n  limb = 1;\n  mpz_init_set_ui (z, 1L);\n  for (i = 1; i <= GMP_LIMB_BITS; i++)\n    {\n      s = mpz_get_str (NULL, 10, z);\n      check_one (s, \"%Mu\", limb);\n      (*__gmp_free_func) (s, strlen (s) + 1);\n\n      s = mpz_get_str (NULL, 16, z);\n      check_one (s, \"%Mx\", limb);\n      (*__gmp_free_func) (s, strlen (s) + 1);\n\n      s = mpz_get_str (NULL, -16, z);\n      check_one (s, \"%MX\", limb);\n      (*__gmp_free_func) (s, strlen (s) + 1);\n\n      limb = 2*limb + 1;\n      mpz_mul_2exp (z, z, 1L);\n      mpz_add_ui (z, z, 1L);\n    }\n\n  mpz_clear (z);\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_n": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        851,
        1
      ],
      "content": "void\ncheck_n (void)\n{\n  {\n    int  n = -1;\n    check_one (\"blah\", \"%nblah\", &n);\n    ASSERT_ALWAYS (n == 0);\n  }\n\n  {\n    int  n = -1;\n    check_one (\"hello \", \"hello %n\", &n);\n    ASSERT_ALWAYS (n == 6);\n  }\n\n  {\n    int  n = -1;\n    check_one (\"hello  world\", \"hello %n world\", &n);\n    ASSERT_ALWAYS (n == 6);\n  }\n\n#define CHECK_N(type, string)                           \\\n  do {                                                  \\\n    type  x[2];                                         \\\n    char  fmt[128];                                     \\\n\t\t\t\t\t\t\t\\\n    x[0] = ~ (type) 0;                                  \\\n    x[1] = ~ (type) 0;                                  \\\n    sprintf (fmt, \"%%d%%%sn%%d\", string);               \\\n    check_one (\"123456\", fmt, 123, &x[0], 456);         \\\n\t\t\t\t\t\t\t\\\n    /* should write whole of x[0] and none of x[1] */   \\\n    ASSERT_ALWAYS (x[0] == 3);                          \\\n    ASSERT_ALWAYS (x[1] == (type) ~ (type) 0);\t\t\\\n\t\t\t\t\t\t\t\\\n  } while (0)\n\n  CHECK_N (mp_limb_t, \"M\");\n  CHECK_N (char,      \"hh\");\n  CHECK_N (long,      \"l\");\n#if HAVE_LONG_LONG\n  CHECK_N (long long, \"L\");\n#endif\n#if HAVE_INTMAX_T\n  CHECK_N (intmax_t,  \"j\");\n#endif\n#if HAVE_PTRDIFF_T\n  CHECK_N (ptrdiff_t, \"t\");\n#endif\n  CHECK_N (short,     \"h\");\n  CHECK_N (size_t,    \"z\");\n\n  {\n    mpz_t  x[2];\n    mpz_init_set_si (x[0], -987L);\n    mpz_init_set_si (x[1],  654L);\n    check_one (\"123456\", \"%d%Zn%d\", 123, x[0], 456);\n    MPZ_CHECK_FORMAT (x[0]);\n    MPZ_CHECK_FORMAT (x[1]);\n    ASSERT_ALWAYS (mpz_cmp_ui (x[0], 3L) == 0);\n    ASSERT_ALWAYS (mpz_cmp_ui (x[1], 654L) == 0);\n    mpz_clear (x[0]);\n    mpz_clear (x[1]);\n  }\n\n  {\n    mpq_t  x[2];\n    mpq_init (x[0]);\n    mpq_init (x[1]);\n    mpq_set_ui (x[0], 987L, 654L);\n    mpq_set_ui (x[1], 4115L, 226L);\n    check_one (\"123456\", \"%d%Qn%d\", 123, x[0], 456);\n    MPQ_CHECK_FORMAT (x[0]);\n    MPQ_CHECK_FORMAT (x[1]);\n    ASSERT_ALWAYS (mpq_cmp_ui (x[0], 3L, 1L) == 0);\n    ASSERT_ALWAYS (mpq_cmp_ui (x[1], 4115L, 226L) == 0);\n    mpq_clear (x[0]);\n    mpq_clear (x[1]);\n  }\n\n  {\n    mpf_t  x[2];\n    mpf_init (x[0]);\n    mpf_init (x[1]);\n    mpf_set_ui (x[0], 987L);\n    mpf_set_ui (x[1], 654L);\n    check_one (\"123456\", \"%d%Fn%d\", 123, x[0], 456);\n    MPF_CHECK_FORMAT (x[0]);\n    MPF_CHECK_FORMAT (x[1]);\n    ASSERT_ALWAYS (mpf_cmp_ui (x[0], 3L) == 0);\n    ASSERT_ALWAYS (mpf_cmp_ui (x[1], 654L) == 0);\n    mpf_clear (x[0]);\n    mpf_clear (x[1]);\n  }\n\n  {\n    mp_limb_t  a[5];\n    mp_limb_t  a_want[numberof(a)];\n    mp_size_t  i;\n\n    a[0] = 123;\n    check_one (\"blah\", \"bl%Nnah\", a, (mp_size_t) 0);\n    ASSERT_ALWAYS (a[0] == 123);\n\n    MPN_ZERO (a_want, numberof (a_want));\n    for (i = 1; i < numberof (a); i++)\n      {\n\tcheck_one (\"blah\", \"bl%Nnah\", a, i);\n\ta_want[0] = 2;\n\tASSERT_ALWAYS (mpn_cmp (a, a_want, i) == 0);\n      }\n  }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_misc": {
      "start_point": [
        854,
        0
      ],
      "end_point": [
        923,
        1
      ],
      "content": "void\ncheck_misc (void)\n{\n  mpz_t  z;\n  mpf_t  f;\n\n  mpz_init (z);\n  mpf_init2 (f, 128L);\n\n  check_one (\"!\", \"%c\", '!');\n\n  check_one (\"hello world\", \"hello %s\", \"world\");\n  check_one (\"hello:\", \"%s:\", \"hello\");\n  mpz_set_ui (z, 0L);\n  check_one (\"hello0\", \"%s%Zd\", \"hello\", z, z);\n\n  {\n    static char  xs[801];\n    memset (xs, 'x', sizeof(xs)-1);\n    check_one (xs, \"%s\", xs);\n  }\n\n  mpz_set_ui (z, 12345L);\n  check_one (\"     12345\", \"%*Zd\", 10, z);\n  check_one (\"0000012345\", \"%0*Zd\", 10, z);\n  check_one (\"12345     \", \"%*Zd\", -10, z);\n  check_one (\"12345 and 678\", \"%Zd and %d\", z, 678);\n  check_one (\"12345,1,12345,2,12345\", \"%Zd,%d,%Zd,%d,%Zd\", z, 1, z, 2, z);\n\n  /* from the glibc info docs */\n  mpz_set_si (z, 0L);\n  check_one (\"|    0|0    |   +0|+0   |    0|00000|     |   00|0|\",\n\t     \"|%5Zd|%-5Zd|%+5Zd|%+-5Zd|% 5Zd|%05Zd|%5.0Zd|%5.2Zd|%Zd|\",\n\t     /**/ z,    z,    z,     z,    z,    z,     z,     z,  z);\n  mpz_set_si (z, 1L);\n  check_one (\"|    1|1    |   +1|+1   |    1|00001|    1|   01|1|\",\n\t     \"|%5Zd|%-5Zd|%+5Zd|%+-5Zd|% 5Zd|%05Zd|%5.0Zd|%5.2Zd|%Zd|\",\n\t     /**/ z,    z,    z,     z,    z,    z,     z,     z,  z);\n  mpz_set_si (z, -1L);\n  check_one (\"|   -1|-1   |   -1|-1   |   -1|-0001|   -1|  -01|-1|\",\n\t     \"|%5Zd|%-5Zd|%+5Zd|%+-5Zd|% 5Zd|%05Zd|%5.0Zd|%5.2Zd|%Zd|\",\n\t     /**/ z,    z,    z,     z,    z,    z,     z,     z,  z);\n  mpz_set_si (z, 100000L);\n  check_one (\"|100000|100000|+100000|+100000| 100000|100000|100000|100000|100000|\",\n\t     \"|%5Zd|%-5Zd|%+5Zd|%+-5Zd|% 5Zd|%05Zd|%5.0Zd|%5.2Zd|%Zd|\",\n\t     /**/ z,    z,    z,     z,    z,    z,     z,     z,  z);\n  mpz_set_si (z, 0L);\n  check_one (\"|    0|    0|    0|    0|    0|    0|  00000000|\",\n\t     \"|%5Zo|%5Zx|%5ZX|%#5Zo|%#5Zx|%#5ZX|%#10.8Zx|\",\n\t     /**/ z,   z,   z,    z,    z,    z,       z);\n  mpz_set_si (z, 1L);\n  check_one (\"|    1|    1|    1|   01|  0x1|  0X1|0x00000001|\",\n\t     \"|%5Zo|%5Zx|%5ZX|%#5Zo|%#5Zx|%#5ZX|%#10.8Zx|\",\n\t     /**/ z,   z,   z,    z,    z,    z,       z);\n  mpz_set_si (z, 100000L);\n  check_one (\"|303240|186a0|186A0|0303240|0x186a0|0X186A0|0x000186a0|\",\n\t     \"|%5Zo|%5Zx|%5ZX|%#5Zo|%#5Zx|%#5ZX|%#10.8Zx|\",\n\t     /**/ z,   z,   z,    z,    z,    z,       z);\n\n  /* %zd for size_t won't be available on old systems, and running something\n     to see if it works might be bad, so only try it on glibc, and only on a\n     new enough version (glibc 2.0 doesn't have %zd) */\n#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 0)\n  mpz_set_ui (z, 789L);\n  check_one (\"456 789 blah\", \"%zd %Zd blah\", (size_t) 456, z);\n#endif\n\n  mpz_clear (z);\n  mpf_clear (f);\n}",
      "lines": 70,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        926,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc > 1 && strcmp (argv[1], \"-s\") == 0)\n    option_check_printf = 1;\n\n  tests_start ();\n  check_vfprintf_fp = fopen (CHECK_VFPRINTF_FILENAME, \"w+\");\n  ASSERT_ALWAYS (check_vfprintf_fp != NULL);\n\n  check_z ();\n  check_q ();\n  check_f ();\n  check_limb ();\n  check_n ();\n  check_misc ();\n\n  ASSERT_ALWAYS (fclose (check_vfprintf_fp) == 0);\n  unlink (CHECK_VFPRINTF_FILENAME);\n  tests_end ();\n  exit (0);\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/misc/t-scanf.c": {
    "test_sscanf_eof_ok": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\ntest_sscanf_eof_ok (void)\n{\n  static int  result = -1;\n\n  if (result == -1)\n    {\n      int  x;\n      if (sscanf (\"\", \"%d\", &x) == EOF)\n        {\n          result = 1;\n        }\n      else\n        {\n          printf (\"Warning, sscanf(\\\"\\\",\\\"%%d\\\",&x) doesn't return EOF.\\n\");\n          printf (\"This affects gmp_sscanf, tests involving it will be suppressed.\\n\");\n          printf (\"You should try to get a fix for your libc.\\n\");\n          result = 0;\n        }\n    }\n  return result;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "libc_scanf_convert": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nlibc_scanf_convert (char *fmt)\n{\n  char  *p = fmt;\n\n  if (! option_libc_scanf)\n    return 0;\n\n  for ( ; *fmt != '\\0'; fmt++)\n    {\n      switch (*fmt) {\n      case 'F':\n      case 'Q':\n      case 'Z':\n        /* transmute */\n        *p++ = 'l';\n        break;\n      default:\n        *p++ = *fmt;\n        break;\n      }\n    }\n  *p = '\\0';\n  return 1;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "fromstring_gmp_fscanf": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\nfromstring_gmp_fscanf (const char *input, const char *fmt, ...)\n{\n  va_list  ap;\n  FILE     *fp;\n  int      ret;\n  va_start (ap, fmt);\n\n  fp = fopen (TEMPFILE, \"w+\");\n  ASSERT_ALWAYS (fp != NULL);\n  ASSERT_ALWAYS (fputs (input, fp) != EOF);\n  ASSERT_ALWAYS (fflush (fp) == 0);\n  rewind (fp);\n\n  ret = gmp_vfscanf (fp, fmt, ap);\n  got_ftell = ftell (fp);\n  ASSERT_ALWAYS (got_ftell != -1L);\n\n  fromstring_next_c = getc (fp);\n\n  ASSERT_ALWAYS (fclose (fp) == 0);\n  va_end (ap);\n  return ret;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "fun_gmp_sscanf": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\nfun_gmp_sscanf (const char *input, const char *fmt, void *a1, void *a2)\n{\n  if (a2 == NULL)\n    return gmp_sscanf (input, fmt, a1);\n  else\n    return gmp_sscanf (input, fmt, a1, a2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "fun_gmp_fscanf": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nfun_gmp_fscanf (const char *input, const char *fmt, void *a1, void *a2)\n{\n  if (a2 == NULL)\n    return fromstring_gmp_fscanf (input, fmt, a1);\n  else\n    return fromstring_gmp_fscanf (input, fmt, a1, a2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "fun_fscanf": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "int\nfun_fscanf (const char *input, const char *fmt, void *a1, void *a2)\n{\n  FILE  *fp;\n  int   ret;\n\n  fp = fopen (TEMPFILE, \"w+\");\n  ASSERT_ALWAYS (fp != NULL);\n  ASSERT_ALWAYS (fputs (input, fp) != EOF);\n  ASSERT_ALWAYS (fflush (fp) == 0);\n  rewind (fp);\n\n  if (a2 == NULL)\n    ret = fscanf (fp, fmt, a1);\n  else\n    ret = fscanf (fp, fmt, a1, a2);\n\n  got_ftell = ftell (fp);\n  ASSERT_ALWAYS (got_ftell != -1L);\n\n  fromstring_next_c = getc (fp);\n\n  ASSERT_ALWAYS (fclose (fp) == 0);\n  return ret;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "fun_sscanf": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "int\nfun_sscanf (const char *input, const char *fmt, void *a1, void *a2)\n{\n  char    *input_writable;\n  size_t  size;\n  int     ret;\n\n  size = strlen (input) + 1;\n  input_writable = (char *) (*__gmp_allocate_func) (size);\n  memcpy (input_writable, input, size);\n\n  if (a2 == NULL)\n    ret = sscanf (input_writable, fmt, a1);\n  else\n    ret = sscanf (input_writable, fmt, a1, a2);\n\n  (*__gmp_free_func) (input_writable, size);\n  return ret;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "fmt_allignore": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "int\nfmt_allignore (const char *fmt)\n{\n  int  saw_star = 1;\n  for ( ; *fmt != '\\0'; fmt++)\n    {\n      switch (*fmt) {\n      case '%':\n        if (! saw_star)\n          return 0;\n        saw_star = 0;\n        break;\n      case '*':\n        saw_star = 1;\n        break;\n      }\n    }\n  return 1;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "check_z": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        602,
        1
      ],
      "content": "void\ncheck_z (void)\n{\n  static const struct {\n    const char  *fmt;\n    const char  *input;\n    const char  *want;\n    int         want_ret;\n    long        want_ftell;\n    int         want_upto;\n    int         not_glibc;\n\n  } data[] = {\n\n    { \"%Zd\",    \"0\",    \"0\", 1, -1, -1 },\n    { \"%Zd\",    \"1\",    \"1\", 1, -1, -1 },\n    { \"%Zd\",  \"123\",  \"123\", 1, -1, -1 },\n    { \"%Zd\",   \"+0\",    \"0\", 1, -1, -1 },\n    { \"%Zd\",   \"+1\",    \"1\", 1, -1, -1 },\n    { \"%Zd\", \"+123\",  \"123\", 1, -1, -1 },\n    { \"%Zd\",   \"-0\",    \"0\", 1, -1, -1 },\n    { \"%Zd\",   \"-1\",   \"-1\", 1, -1, -1 },\n    { \"%Zd\", \"-123\", \"-123\", 1, -1, -1 },\n\n    { \"%Zo\",    \"0\",    \"0\", 1, -1, -1 },\n    { \"%Zo\",  \"173\",  \"123\", 1, -1, -1 },\n    { \"%Zo\",   \"+0\",    \"0\", 1, -1, -1 },\n    { \"%Zo\", \"+173\",  \"123\", 1, -1, -1 },\n    { \"%Zo\",   \"-0\",    \"0\", 1, -1, -1 },\n    { \"%Zo\", \"-173\", \"-123\", 1, -1, -1 },\n\n    { \"%Zx\",    \"0\",    \"0\", 1, -1, -1 },\n    { \"%Zx\",   \"7b\",  \"123\", 1, -1, -1 },\n    { \"%Zx\",   \"7b\",  \"123\", 1, -1, -1 },\n    { \"%Zx\",   \"+0\",    \"0\", 1, -1, -1 },\n    { \"%Zx\",  \"+7b\",  \"123\", 1, -1, -1 },\n    { \"%Zx\",  \"+7b\",  \"123\", 1, -1, -1 },\n    { \"%Zx\",   \"-0\",   \"-0\", 1, -1, -1 },\n    { \"%Zx\",  \"-7b\", \"-123\", 1, -1, -1 },\n    { \"%Zx\",  \"-7b\", \"-123\", 1, -1, -1 },\n    { \"%ZX\",    \"0\",    \"0\", 1, -1, -1 },\n    { \"%ZX\",   \"7b\",  \"123\", 1, -1, -1 },\n    { \"%ZX\",   \"7b\",  \"123\", 1, -1, -1 },\n    { \"%ZX\",   \"+0\",    \"0\", 1, -1, -1 },\n    { \"%ZX\",  \"+7b\",  \"123\", 1, -1, -1 },\n    { \"%ZX\",  \"+7b\",  \"123\", 1, -1, -1 },\n    { \"%ZX\",   \"-0\",   \"-0\", 1, -1, -1 },\n    { \"%ZX\",  \"-7b\", \"-123\", 1, -1, -1 },\n    { \"%ZX\",  \"-7b\", \"-123\", 1, -1, -1 },\n    { \"%Zx\",    \"0\",    \"0\", 1, -1, -1 },\n    { \"%Zx\",   \"7B\",  \"123\", 1, -1, -1 },\n    { \"%Zx\",   \"7B\",  \"123\", 1, -1, -1 },\n    { \"%Zx\",   \"+0\",    \"0\", 1, -1, -1 },\n    { \"%Zx\",  \"+7B\",  \"123\", 1, -1, -1 },\n    { \"%Zx\",  \"+7B\",  \"123\", 1, -1, -1 },\n    { \"%Zx\",   \"-0\",   \"-0\", 1, -1, -1 },\n    { \"%Zx\",  \"-7B\", \"-123\", 1, -1, -1 },\n    { \"%Zx\",  \"-7B\", \"-123\", 1, -1, -1 },\n    { \"%ZX\",    \"0\",    \"0\", 1, -1, -1 },\n    { \"%ZX\",   \"7B\",  \"123\", 1, -1, -1 },\n    { \"%ZX\",   \"7B\",  \"123\", 1, -1, -1 },\n    { \"%ZX\",   \"+0\",    \"0\", 1, -1, -1 },\n    { \"%ZX\",  \"+7B\",  \"123\", 1, -1, -1 },\n    { \"%ZX\",  \"+7B\",  \"123\", 1, -1, -1 },\n    { \"%ZX\",   \"-0\",   \"-0\", 1, -1, -1 },\n    { \"%ZX\",  \"-7B\", \"-123\", 1, -1, -1 },\n    { \"%ZX\",  \"-7B\", \"-123\", 1, -1, -1 },\n\n    { \"%Zi\",    \"0\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",    \"1\",    \"1\", 1, -1, -1 },\n    { \"%Zi\",  \"123\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"+0\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",   \"+1\",    \"1\", 1, -1, -1 },\n    { \"%Zi\", \"+123\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"-0\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",   \"-1\",   \"-1\", 1, -1, -1 },\n    { \"%Zi\", \"-123\", \"-123\", 1, -1, -1 },\n\n    { \"%Zi\",    \"00\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",  \"0173\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"+00\",    \"0\", 1, -1, -1 },\n    { \"%Zi\", \"+0173\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"-00\",    \"0\", 1, -1, -1 },\n    { \"%Zi\", \"-0173\", \"-123\", 1, -1, -1 },\n\n    { \"%Zi\",    \"0x0\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",   \"0x7b\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"0x7b\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"+0x0\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",  \"+0x7b\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",  \"+0x7b\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"-0x0\",   \"-0\", 1, -1, -1 },\n    { \"%Zi\",  \"-0x7b\", \"-123\", 1, -1, -1 },\n    { \"%Zi\",  \"-0x7b\", \"-123\", 1, -1, -1 },\n    { \"%Zi\",    \"0X0\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",   \"0X7b\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"0X7b\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"+0X0\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",  \"+0X7b\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",  \"+0X7b\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"-0X0\",   \"-0\", 1, -1, -1 },\n    { \"%Zi\",  \"-0X7b\", \"-123\", 1, -1, -1 },\n    { \"%Zi\",  \"-0X7b\", \"-123\", 1, -1, -1 },\n    { \"%Zi\",    \"0x0\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",   \"0x7B\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"0x7B\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"+0x0\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",  \"+0x7B\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",  \"+0x7B\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"-0x0\",   \"-0\", 1, -1, -1 },\n    { \"%Zi\",  \"-0x7B\", \"-123\", 1, -1, -1 },\n    { \"%Zi\",  \"-0x7B\", \"-123\", 1, -1, -1 },\n    { \"%Zi\",    \"0X0\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",   \"0X7B\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"0X7B\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"+0X0\",    \"0\", 1, -1, -1 },\n    { \"%Zi\",  \"+0X7B\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",  \"+0X7B\",  \"123\", 1, -1, -1 },\n    { \"%Zi\",   \"-0X0\",   \"-0\", 1, -1, -1 },\n    { \"%Zi\",  \"-0X7B\", \"-123\", 1, -1, -1 },\n    { \"%Zi\",  \"-0X7B\", \"-123\", 1, -1, -1 },\n\n    { \"%Zd\",    \" 0\",    \"0\", 1, -1, -1 },\n    { \"%Zd\",   \"  0\",    \"0\", 1, -1, -1 },\n    { \"%Zd\",  \"   0\",    \"0\", 1, -1, -1 },\n    { \"%Zd\",   \"\\t0\",    \"0\", 1, -1, -1 },\n    { \"%Zd\", \"\\t\\t0\",    \"0\", 1, -1, -1 },\n\n    { \"hello%Zd\",      \"hello0\",       \"0\", 1, -1, -1 },\n    { \"hello%Zd\",      \"hello 0\",      \"0\", 1, -1, -1 },\n    { \"hello%Zd\",      \"hello \\t0\",    \"0\", 1, -1, -1 },\n    { \"hello%Zdworld\", \"hello 0world\", \"0\", 1, -1, -1 },\n\n    { \"hello%*Zd\",      \"hello0\",       \"-999\", 0, -1, -1 },\n    { \"hello%*Zd\",      \"hello 0\",      \"-999\", 0, -1, -1 },\n    { \"hello%*Zd\",      \"hello \\t0\",    \"-999\", 0, -1, -1 },\n    { \"hello%*Zdworld\", \"hello 0world\", \"-999\", 0, -1, -1 },\n\n    { \"%Zd\",    \"\",     \"-999\", -1, -1, -555 },\n    { \"%Zd\",    \" \",    \"-999\", -1, -1, -555 },\n    { \" %Zd\",   \"\",     \"-999\", -1, -1, -555 },\n    { \"xyz%Zd\", \"\",     \"-999\", -1, -1, -555 },\n\n    { \"%*Zd\",    \"\",     \"-999\", -1, -1, -555 },\n    { \" %*Zd\",   \"\",     \"-999\", -1, -1, -555 },\n    { \"xyz%*Zd\", \"\",     \"-999\", -1, -1, -555 },\n\n    { \"%Zd\",    \"xyz\",  \"0\",     0, 0, -555 },\n\n    /* match something, but invalid */\n    { \"%Zd\",    \"-\",    \"-999\",  0, 1, -555 },\n    { \"%Zd\",    \"+\",    \"-999\",  0, 1, -555 },\n    { \"xyz%Zd\", \"xyz-\", \"-999\",  0, 4, -555 },\n    { \"xyz%Zd\", \"xyz+\", \"-999\",  0, 4, -555 },\n    { \"%Zi\",    \"0x\",   \"-999\",  0, 2, -555 },\n    { \"%Zi\",    \"0X\",   \"-999\",  0, 2, -555 },\n    { \"%Zi\",    \"0x-\",  \"-999\",  0, 2, -555 },\n    { \"%Zi\",    \"0X+\",  \"-999\",  0, 2, -555 },\n    { \"%Zi\",    \"-0x\",  \"-999\",  0, 3, -555 },\n    { \"%Zi\",    \"-0X\",  \"-999\",  0, 3, -555 },\n    { \"%Zi\",    \"+0x\",  \"-999\",  0, 3, -555 },\n    { \"%Zi\",    \"+0X\",  \"-999\",  0, 3, -555 },\n\n    { \"%1Zi\",  \"1234\", \"1\",    1, 1, 1 },\n    { \"%2Zi\",  \"1234\", \"12\",   1, 2, 2 },\n    { \"%3Zi\",  \"1234\", \"123\",  1, 3, 3 },\n    { \"%4Zi\",  \"1234\", \"1234\", 1, 4, 4 },\n    { \"%5Zi\",  \"1234\", \"1234\", 1, 4, 4 },\n    { \"%6Zi\",  \"1234\", \"1234\", 1, 4, 4 },\n\n    { \"%1Zi\",  \"01234\", \"0\",     1, 1, 1 },\n    { \"%2Zi\",  \"01234\", \"01\",    1, 2, 2 },\n    { \"%3Zi\",  \"01234\", \"012\",   1, 3, 3 },\n    { \"%4Zi\",  \"01234\", \"0123\",  1, 4, 4 },\n    { \"%5Zi\",  \"01234\", \"01234\", 1, 5, 5 },\n    { \"%6Zi\",  \"01234\", \"01234\", 1, 5, 5 },\n    { \"%7Zi\",  \"01234\", \"01234\", 1, 5, 5 },\n\n    { \"%1Zi\",  \"0x1234\", \"0\",      1, 1, 1 },\n    { \"%2Zi\",  \"0x1234\", \"-999\",   0, 2, -555 },\n    { \"%3Zi\",  \"0x1234\", \"0x1\",    1, 3, 3 },\n    { \"%4Zi\",  \"0x1234\", \"0x12\",   1, 4, 4 },\n    { \"%5Zi\",  \"0x1234\", \"0x123\",  1, 5, 5 },\n    { \"%6Zi\",  \"0x1234\", \"0x1234\", 1, 6, 6 },\n    { \"%7Zi\",  \"0x1234\", \"0x1234\", 1, 6, 6 },\n    { \"%8Zi\",  \"0x1234\", \"0x1234\", 1, 6, 6 },\n\n    { \"%%xyz%Zd\",  \"%xyz123\",  \"123\", 1, -1, -1 },\n    { \"12%%34%Zd\", \"12%34567\", \"567\", 1, -1, -1 },\n    { \"%%%%%Zd\",   \"%%123\",    \"123\", 1, -1, -1 },\n\n    /* various subtle EOF cases */\n    { \"x\",       \"\",    \"-999\", EOF, 0, -555 },\n    { \" x\",      \"\",    \"-999\", EOF, 0, -555 },\n    { \"xyz\",     \"\",    \"-999\", EOF, 0, -555 },\n    { \" \",       \"\",    \"-999\",   0, 0,    0 },\n    { \" \",       \" \",   \"-999\",   0, 1,    1 },\n    { \"%*Zd%Zd\", \"\",    \"-999\", EOF, 0, -555 },\n    { \"%*Zd%Zd\", \"123\", \"-999\", EOF, 3, -555 },\n    { \"x\",       \"x\",   \"-999\",   0, 1,    1 },\n    { \"xyz\",     \"x\",   \"-999\", EOF, 1, -555 },\n    { \"xyz\",     \"xy\",  \"-999\", EOF, 2, -555 },\n    { \"xyz\",     \"xyz\", \"-999\",   0, 3,    3 },\n    { \"%Zn\",     \"\",    \"0\",      0, 0,    0 },\n    { \" %Zn\",    \"\",    \"0\",      0, 0,    0 },\n    { \" x%Zn\",   \"\",    \"-999\", EOF, 0, -555 },\n    { \"xyz%Zn\",  \"\",    \"-999\", EOF, 0, -555 },\n    { \" x%Zn\",   \"\",    \"-999\", EOF, 0, -555 },\n    { \" %Zn x\",  \" \",   \"-999\", EOF, 1, -555 },\n\n    /* these seem to tickle a bug in glibc 2.2.4 */\n    { \" x\",      \" \",   \"-999\", EOF, 1, -555, 1 },\n    { \" xyz\",    \" \",   \"-999\", EOF, 1, -555, 1 },\n    { \" x%Zn\",   \" \",   \"-999\", EOF, 1, -555, 1 },\n  };\n\n  int         i, j, ignore;\n  int         got_ret, want_ret, got_upto, want_upto;\n  mpz_t       got, want;\n  long        got_l, want_ftell;\n  int         error = 0;\n  fun_t       fun;\n  const char  *name;\n  char        fmt[128];\n\n  mpz_init (got);\n  mpz_init (want);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (want, data[i].want, 0);\n\n      ASSERT_ALWAYS (strlen (data[i].fmt) + 2 < sizeof (fmt));\n      strcpy (fmt, data[i].fmt);\n      strcat (fmt, \"%n\");\n\n      ignore = fmt_allignore (fmt);\n\n      for (j = 0; j <= 3; j++)\n        {\n          want_ret = data[i].want_ret;\n\n          want_ftell = data[i].want_ftell;\n          if (want_ftell == -1)\n            want_ftell = strlen (data[i].input);\n\n          want_upto = data[i].want_upto;\n          if (want_upto == -1)\n            want_upto = strlen (data[i].input);\n\n          switch (j) {\n          case 0:\n            name = \"gmp_sscanf\";\n            fun = fun_gmp_sscanf;\n            break;\n          case 1:\n            name = \"gmp_fscanf\";\n            fun = fun_gmp_fscanf;\n            break;\n          case 2:\n#ifdef __GLIBC__\n            if (data[i].not_glibc)\n              continue;\n#endif\n            if (! libc_scanf_convert (fmt))\n              continue;\n            name = \"standard sscanf\";\n            fun = fun_sscanf;\n            break;\n          case 3:\n#ifdef __GLIBC__\n            if (data[i].not_glibc)\n              continue;\n#endif\n            if (! libc_scanf_convert (fmt))\n              continue;\n            name = \"standard fscanf\";\n            fun = fun_fscanf;\n            break;\n          default:\n            ASSERT_ALWAYS (0);\n            break;\n          }\n\n          got_upto = -555;\n          got_ftell = -1L;\n\n          switch (j) {\n          case 0:\n          case 1:\n            mpz_set_si (got, -999L);\n            if (ignore)\n              got_ret = (*fun) (data[i].input, fmt, &got_upto, NULL);\n            else\n              got_ret = (*fun) (data[i].input, fmt, got, &got_upto);\n            break;\n          case 2:\n          case 3:\n            got_l = -999L;\n            if (ignore)\n              got_ret = (*fun) (data[i].input, fmt, &got_upto, NULL);\n            else\n              got_ret = (*fun) (data[i].input, fmt, &got_l, &got_upto);\n            mpz_set_si (got, got_l);\n            break;\n          default:\n            ASSERT_ALWAYS (0);\n            break;\n          }\n\n          MPZ_CHECK_FORMAT (got);\n\n          if (got_ret != want_ret)\n            {\n              printf (\"%s wrong return value\\n\", name);\n              error = 1;\n            }\n          if (want_ret == 1 && mpz_cmp (want, got) != 0)\n            {\n              printf (\"%s wrong result\\n\", name);\n              error = 1;\n            }\n          if (got_upto != want_upto)\n            {\n              printf (\"%s wrong upto\\n\", name);\n              error = 1;\n            }\n          if (got_ftell != -1 && want_ftell != -1 && got_ftell != want_ftell)\n            {\n              printf (\"%s wrong ftell\\n\", name);\n              error = 1;\n            }\n          if (error)\n            {\n              printf    (\"  fmt   \\\"%s\\\"\\n\", data[i].fmt);\n              printf    (\"  input \\\"%s\\\"\\n\", data[i].input);\n              printf    (\"  ignore %d\\n\", ignore);\n              printf    (\"  ret   want=%d\\n\", want_ret);\n              printf    (\"        got =%d\\n\", got_ret);\n              mpz_trace (\"  value want\", want);\n              mpz_trace (\"        got \", got);\n              printf    (\"  upto  want =%d\\n\", want_upto);\n              printf    (\"        got  =%d\\n\", got_upto);\n              if (got_ftell != -1)\n                {\n                  printf    (\"  ftell want =%ld\\n\", want_ftell);\n                  printf    (\"        got  =%ld\\n\", got_ftell);\n                }\n              abort ();\n            }\n        }\n    }\n\n  mpz_clear (got);\n  mpz_clear (want);\n}",
      "lines": 356,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "check_q": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        986,
        1
      ],
      "content": "void\ncheck_q (void)\n{\n  static const struct {\n    const char  *fmt;\n    const char  *input;\n    const char  *want;\n    int         ret;\n    long        ftell;\n\n  } data[] = {\n\n    { \"%Qd\",    \"0\",    \"0\", 1, -1 },\n    { \"%Qd\",    \"1\",    \"1\", 1, -1 },\n    { \"%Qd\",  \"123\",  \"123\", 1, -1 },\n    { \"%Qd\",   \"+0\",    \"0\", 1, -1 },\n    { \"%Qd\",   \"+1\",    \"1\", 1, -1 },\n    { \"%Qd\", \"+123\",  \"123\", 1, -1 },\n    { \"%Qd\",   \"-0\",    \"0\", 1, -1 },\n    { \"%Qd\",   \"-1\",   \"-1\", 1, -1 },\n    { \"%Qd\", \"-123\", \"-123\", 1, -1 },\n\n    { \"%Qo\",    \"0\",    \"0\", 1, -1 },\n    { \"%Qo\",  \"173\",  \"123\", 1, -1 },\n    { \"%Qo\",   \"+0\",    \"0\", 1, -1 },\n    { \"%Qo\", \"+173\",  \"123\", 1, -1 },\n    { \"%Qo\",   \"-0\",    \"0\", 1, -1 },\n    { \"%Qo\", \"-173\", \"-123\", 1, -1 },\n\n    { \"%Qx\",    \"0\",    \"0\", 1, -1 },\n    { \"%Qx\",   \"7b\",  \"123\", 1, -1 },\n    { \"%Qx\",   \"7b\",  \"123\", 1, -1 },\n    { \"%Qx\",   \"+0\",    \"0\", 1, -1 },\n    { \"%Qx\",  \"+7b\",  \"123\", 1, -1 },\n    { \"%Qx\",  \"+7b\",  \"123\", 1, -1 },\n    { \"%Qx\",   \"-0\",   \"-0\", 1, -1 },\n    { \"%Qx\",  \"-7b\", \"-123\", 1, -1 },\n    { \"%Qx\",  \"-7b\", \"-123\", 1, -1 },\n    { \"%QX\",    \"0\",    \"0\", 1, -1 },\n    { \"%QX\",   \"7b\",  \"123\", 1, -1 },\n    { \"%QX\",   \"7b\",  \"123\", 1, -1 },\n    { \"%QX\",   \"+0\",    \"0\", 1, -1 },\n    { \"%QX\",  \"+7b\",  \"123\", 1, -1 },\n    { \"%QX\",  \"+7b\",  \"123\", 1, -1 },\n    { \"%QX\",   \"-0\",   \"-0\", 1, -1 },\n    { \"%QX\",  \"-7b\", \"-123\", 1, -1 },\n    { \"%QX\",  \"-7b\", \"-123\", 1, -1 },\n    { \"%Qx\",    \"0\",    \"0\", 1, -1 },\n    { \"%Qx\",   \"7B\",  \"123\", 1, -1 },\n    { \"%Qx\",   \"7B\",  \"123\", 1, -1 },\n    { \"%Qx\",   \"+0\",    \"0\", 1, -1 },\n    { \"%Qx\",  \"+7B\",  \"123\", 1, -1 },\n    { \"%Qx\",  \"+7B\",  \"123\", 1, -1 },\n    { \"%Qx\",   \"-0\",   \"-0\", 1, -1 },\n    { \"%Qx\",  \"-7B\", \"-123\", 1, -1 },\n    { \"%Qx\",  \"-7B\", \"-123\", 1, -1 },\n    { \"%QX\",    \"0\",    \"0\", 1, -1 },\n    { \"%QX\",   \"7B\",  \"123\", 1, -1 },\n    { \"%QX\",   \"7B\",  \"123\", 1, -1 },\n    { \"%QX\",   \"+0\",    \"0\", 1, -1 },\n    { \"%QX\",  \"+7B\",  \"123\", 1, -1 },\n    { \"%QX\",  \"+7B\",  \"123\", 1, -1 },\n    { \"%QX\",   \"-0\",   \"-0\", 1, -1 },\n    { \"%QX\",  \"-7B\", \"-123\", 1, -1 },\n    { \"%QX\",  \"-7B\", \"-123\", 1, -1 },\n\n    { \"%Qi\",    \"0\",    \"0\", 1, -1 },\n    { \"%Qi\",    \"1\",    \"1\", 1, -1 },\n    { \"%Qi\",  \"123\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"+0\",    \"0\", 1, -1 },\n    { \"%Qi\",   \"+1\",    \"1\", 1, -1 },\n    { \"%Qi\", \"+123\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"-0\",    \"0\", 1, -1 },\n    { \"%Qi\",   \"-1\",   \"-1\", 1, -1 },\n    { \"%Qi\", \"-123\", \"-123\", 1, -1 },\n\n    { \"%Qi\",    \"00\",    \"0\", 1, -1 },\n    { \"%Qi\",  \"0173\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"+00\",    \"0\", 1, -1 },\n    { \"%Qi\", \"+0173\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"-00\",    \"0\", 1, -1 },\n    { \"%Qi\", \"-0173\", \"-123\", 1, -1 },\n\n    { \"%Qi\",    \"0x0\",    \"0\", 1, -1 },\n    { \"%Qi\",   \"0x7b\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"0x7b\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"+0x0\",    \"0\", 1, -1 },\n    { \"%Qi\",  \"+0x7b\",  \"123\", 1, -1 },\n    { \"%Qi\",  \"+0x7b\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"-0x0\",   \"-0\", 1, -1 },\n    { \"%Qi\",  \"-0x7b\", \"-123\", 1, -1 },\n    { \"%Qi\",  \"-0x7b\", \"-123\", 1, -1 },\n    { \"%Qi\",    \"0X0\",    \"0\", 1, -1 },\n    { \"%Qi\",   \"0X7b\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"0X7b\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"+0X0\",    \"0\", 1, -1 },\n    { \"%Qi\",  \"+0X7b\",  \"123\", 1, -1 },\n    { \"%Qi\",  \"+0X7b\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"-0X0\",   \"-0\", 1, -1 },\n    { \"%Qi\",  \"-0X7b\", \"-123\", 1, -1 },\n    { \"%Qi\",  \"-0X7b\", \"-123\", 1, -1 },\n    { \"%Qi\",    \"0x0\",    \"0\", 1, -1 },\n    { \"%Qi\",   \"0x7B\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"0x7B\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"+0x0\",    \"0\", 1, -1 },\n    { \"%Qi\",  \"+0x7B\",  \"123\", 1, -1 },\n    { \"%Qi\",  \"+0x7B\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"-0x0\",   \"-0\", 1, -1 },\n    { \"%Qi\",  \"-0x7B\", \"-123\", 1, -1 },\n    { \"%Qi\",  \"-0x7B\", \"-123\", 1, -1 },\n    { \"%Qi\",    \"0X0\",    \"0\", 1, -1 },\n    { \"%Qi\",   \"0X7B\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"0X7B\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"+0X0\",    \"0\", 1, -1 },\n    { \"%Qi\",  \"+0X7B\",  \"123\", 1, -1 },\n    { \"%Qi\",  \"+0X7B\",  \"123\", 1, -1 },\n    { \"%Qi\",   \"-0X0\",   \"-0\", 1, -1 },\n    { \"%Qi\",  \"-0X7B\", \"-123\", 1, -1 },\n    { \"%Qi\",  \"-0X7B\", \"-123\", 1, -1 },\n\n    { \"%Qd\",    \" 0\",    \"0\", 1, -1 },\n    { \"%Qd\",   \"  0\",    \"0\", 1, -1 },\n    { \"%Qd\",  \"   0\",    \"0\", 1, -1 },\n    { \"%Qd\",   \"\\t0\",    \"0\", 1, -1 },\n    { \"%Qd\", \"\\t\\t0\",    \"0\", 1, -1 },\n\n    { \"%Qd\",  \"3/2\",   \"3/2\", 1, -1 },\n    { \"%Qd\", \"+3/2\",   \"3/2\", 1, -1 },\n    { \"%Qd\", \"-3/2\",  \"-3/2\", 1, -1 },\n\n    { \"%Qx\",  \"f/10\", \"15/16\", 1, -1 },\n    { \"%Qx\",  \"F/10\", \"15/16\", 1, -1 },\n    { \"%QX\",  \"f/10\", \"15/16\", 1, -1 },\n    { \"%QX\",  \"F/10\", \"15/16\", 1, -1 },\n\n    { \"%Qo\",  \"20/21\",  \"16/17\", 1, -1 },\n    { \"%Qo\", \"-20/21\", \"-16/17\", 1, -1 },\n\n    { \"%Qi\",    \"10/11\",  \"10/11\", 1, -1 },\n    { \"%Qi\",   \"+10/11\",  \"10/11\", 1, -1 },\n    { \"%Qi\",   \"-10/11\", \"-10/11\", 1, -1 },\n    { \"%Qi\",   \"010/11\",   \"8/11\", 1, -1 },\n    { \"%Qi\",  \"+010/11\",   \"8/11\", 1, -1 },\n    { \"%Qi\",  \"-010/11\",  \"-8/11\", 1, -1 },\n    { \"%Qi\",  \"0x10/11\",  \"16/11\", 1, -1 },\n    { \"%Qi\", \"+0x10/11\",  \"16/11\", 1, -1 },\n    { \"%Qi\", \"-0x10/11\", \"-16/11\", 1, -1 },\n\n    { \"%Qi\",    \"10/011\",  \"10/9\", 1, -1 },\n    { \"%Qi\",   \"+10/011\",  \"10/9\", 1, -1 },\n    { \"%Qi\",   \"-10/011\", \"-10/9\", 1, -1 },\n    { \"%Qi\",   \"010/011\",   \"8/9\", 1, -1 },\n    { \"%Qi\",  \"+010/011\",   \"8/9\", 1, -1 },\n    { \"%Qi\",  \"-010/011\",  \"-8/9\", 1, -1 },\n    { \"%Qi\",  \"0x10/011\",  \"16/9\", 1, -1 },\n    { \"%Qi\", \"+0x10/011\",  \"16/9\", 1, -1 },\n    { \"%Qi\", \"-0x10/011\", \"-16/9\", 1, -1 },\n\n    { \"%Qi\",    \"10/0x11\",  \"10/17\", 1, -1 },\n    { \"%Qi\",   \"+10/0x11\",  \"10/17\", 1, -1 },\n    { \"%Qi\",   \"-10/0x11\", \"-10/17\", 1, -1 },\n    { \"%Qi\",   \"010/0x11\",   \"8/17\", 1, -1 },\n    { \"%Qi\",  \"+010/0x11\",   \"8/17\", 1, -1 },\n    { \"%Qi\",  \"-010/0x11\",  \"-8/17\", 1, -1 },\n    { \"%Qi\",  \"0x10/0x11\",  \"16/17\", 1, -1 },\n    { \"%Qi\", \"+0x10/0x11\",  \"16/17\", 1, -1 },\n    { \"%Qi\", \"-0x10/0x11\", \"-16/17\", 1, -1 },\n\n    { \"hello%Qd\",      \"hello0\",         \"0\", 1, -1 },\n    { \"hello%Qd\",      \"hello 0\",        \"0\", 1, -1 },\n    { \"hello%Qd\",      \"hello \\t0\",      \"0\", 1, -1 },\n    { \"hello%Qdworld\", \"hello 0world\",   \"0\", 1, -1 },\n    { \"hello%Qd\",      \"hello3/2\",     \"3/2\", 1, -1 },\n\n    { \"hello%*Qd\",      \"hello0\",        \"-999/121\", 0, -1 },\n    { \"hello%*Qd\",      \"hello 0\",       \"-999/121\", 0, -1 },\n    { \"hello%*Qd\",      \"hello \\t0\",     \"-999/121\", 0, -1 },\n    { \"hello%*Qdworld\", \"hello 0world\",  \"-999/121\", 0, -1 },\n    { \"hello%*Qdworld\", \"hello3/2world\", \"-999/121\", 0, -1 },\n\n    { \"%Qd\",    \"\",     \"-999/121\", -1, -1 },\n    { \"%Qd\",   \" \",     \"-999/121\", -1, -1 },\n    { \" %Qd\",   \"\",     \"-999/121\", -1, -1 },\n    { \"xyz%Qd\", \"\",     \"-999/121\", -1, -1 },\n\n    { \"%*Qd\",    \"\",     \"-999/121\", -1, -1 },\n    { \" %*Qd\",   \"\",     \"-999/121\", -1, -1 },\n    { \"xyz%*Qd\", \"\",     \"-999/121\", -1, -1 },\n\n    /* match something, but invalid */\n    { \"%Qd\",    \"-\",     \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"+\",     \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"/-\",    \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"/+\",    \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"-/\",    \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"+/\",    \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"-/-\",   \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"-/+\",   \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"+/+\",   \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"/123\",  \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"-/123\", \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"+/123\", \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"123/\",  \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"123/-\", \"-999/121\",  0, 1 },\n    { \"%Qd\",    \"123/+\", \"-999/121\",  0, 1 },\n    { \"xyz%Qd\", \"xyz-\",  \"-999/121\",  0, 4 },\n    { \"xyz%Qd\", \"xyz+\",  \"-999/121\",  0, 4 },\n\n    { \"%1Qi\",  \"12/57\", \"1\",        1, 1 },\n    { \"%2Qi\",  \"12/57\", \"12\",       1, 2 },\n    { \"%3Qi\",  \"12/57\", \"-999/121\", 0, -1 },\n    { \"%4Qi\",  \"12/57\", \"12/5\",     1, 4 },\n    { \"%5Qi\",  \"12/57\", \"12/57\",    1, 5 },\n    { \"%6Qi\",  \"12/57\", \"12/57\",    1, 5 },\n    { \"%7Qi\",  \"12/57\", \"12/57\",    1, 5 },\n\n    { \"%1Qi\",  \"012/057\", \"0\",        1, 1 },\n    { \"%2Qi\",  \"012/057\", \"01\",       1, 2 },\n    { \"%3Qi\",  \"012/057\", \"012\",      1, 3 },\n    { \"%4Qi\",  \"012/057\", \"-999/121\", 0, -1 },\n    { \"%5Qi\",  \"012/057\", \"012/0\",    1, 5 },\n    { \"%6Qi\",  \"012/057\", \"012/5\",    1, 6 },\n    { \"%7Qi\",  \"012/057\", \"012/057\",  1, 7 },\n    { \"%8Qi\",  \"012/057\", \"012/057\",  1, 7 },\n    { \"%9Qi\",  \"012/057\", \"012/057\",  1, 7 },\n\n    { \"%1Qi\",  \"0x12/0x57\", \"0\",         1, 1 },\n    { \"%2Qi\",  \"0x12/0x57\", \"-999\",      0, 2 },\n    { \"%3Qi\",  \"0x12/0x57\", \"0x1\",       1, 3 },\n    { \"%4Qi\",  \"0x12/0x57\", \"0x12\",      1, 4 },\n    { \"%5Qi\",  \"0x12/0x57\", \"-999/121\",  0, 5 },\n    { \"%6Qi\",  \"0x12/0x57\", \"0x12/0\",    1, 6 },\n    { \"%7Qi\",  \"0x12/0x57\", \"-999/121\",  0, 7 },\n    { \"%8Qi\",  \"0x12/0x57\", \"0x12/0x5\",  1, 8 },\n    { \"%9Qi\",  \"0x12/0x57\", \"0x12/0x57\", 1, 9 },\n    { \"%10Qi\", \"0x12/0x57\", \"0x12/0x57\", 1, 9 },\n    { \"%11Qi\", \"0x12/0x57\", \"0x12/0x57\", 1, 9 },\n\n    { \"%Qd\",  \"xyz\", \"0\", 0, 0 },\n  };\n\n  int         i, j, ignore, got_ret, want_ret, got_upto, want_upto;\n  mpq_t       got, want;\n  long        got_l, want_ftell;\n  int         error = 0;\n  fun_t       fun;\n  const char  *name;\n  char        fmt[128];\n\n  mpq_init (got);\n  mpq_init (want);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpq_set_str_or_abort (want, data[i].want, 0);\n\n      ASSERT_ALWAYS (strlen (data[i].fmt) + 2 < sizeof (fmt));\n      strcpy (fmt, data[i].fmt);\n      strcat (fmt, \"%n\");\n\n      ignore = (strchr (fmt, '*') != NULL);\n\n      for (j = 0; j <= 3; j++)\n        {\n          want_ret = data[i].ret;\n\n          want_ftell = data[i].ftell;\n          if (want_ftell == -1)\n            want_ftell = strlen (data[i].input);\n          want_upto = want_ftell;\n\n          if (want_ret == -1 || (want_ret == 0 && ! ignore))\n            {\n              want_ftell = -1;\n              want_upto = -555;\n            }\n\n          switch (j) {\n          case 0:\n            name = \"gmp_sscanf\";\n            fun = fun_gmp_sscanf;\n            break;\n          case 1:\n            name = \"gmp_fscanf\";\n            fun = fun_gmp_fscanf;\n            break;\n          case 2:\n            if (strchr (data[i].input, '/') != NULL)\n              continue;\n            if (! libc_scanf_convert (fmt))\n              continue;\n            name = \"standard sscanf\";\n            fun = fun_sscanf;\n            break;\n          case 3:\n            if (strchr (data[i].input, '/') != NULL)\n              continue;\n            if (! libc_scanf_convert (fmt))\n              continue;\n            name = \"standard fscanf\";\n            fun = fun_fscanf;\n            break;\n          default:\n            ASSERT_ALWAYS (0);\n            break;\n          }\n\n          got_upto = -555;\n          got_ftell = -1;\n\n          switch (j) {\n          case 0:\n          case 1:\n            mpq_set_si (got, -999L, 121L);\n            if (ignore)\n              got_ret = (*fun) (data[i].input, fmt, &got_upto, NULL);\n            else\n              got_ret = (*fun) (data[i].input, fmt, got, &got_upto);\n            break;\n          case 2:\n          case 3:\n            got_l = -999L;\n            if (ignore)\n              got_ret = (*fun) (data[i].input, fmt, &got_upto, NULL);\n            else\n              got_ret = (*fun) (data[i].input, fmt, &got_l, &got_upto);\n            mpq_set_si (got, got_l, (got_l == -999L ? 121L : 1L));\n            break;\n          default:\n            ASSERT_ALWAYS (0);\n            break;\n          }\n\n          MPZ_CHECK_FORMAT (mpq_numref (got));\n          MPZ_CHECK_FORMAT (mpq_denref (got));\n\n          if (got_ret != want_ret)\n            {\n              printf (\"%s wrong return value\\n\", name);\n              error = 1;\n            }\n          /* use direct mpz compares, since some of the test data is\n             non-canonical and can trip ASSERTs in mpq_equal */\n          if (want_ret == 1\n              && ! (mpz_cmp (mpq_numref(want), mpq_numref(got)) == 0\n                    && mpz_cmp (mpq_denref(want), mpq_denref(got)) == 0))\n            {\n              printf (\"%s wrong result\\n\", name);\n              error = 1;\n            }\n          if (got_upto != want_upto)\n            {\n              printf (\"%s wrong upto\\n\", name);\n              error = 1;\n            }\n          if (got_ftell != -1 && want_ftell != -1 && got_ftell != want_ftell)\n            {\n              printf (\"%s wrong ftell\\n\", name);\n              error = 1;\n            }\n          if (error)\n            {\n              printf    (\"  fmt   \\\"%s\\\"\\n\", data[i].fmt);\n              printf    (\"  input \\\"%s\\\"\\n\", data[i].input);\n              printf    (\"  ret   want=%d\\n\", want_ret);\n              printf    (\"        got =%d\\n\", got_ret);\n              mpq_trace (\"  value want\", want);\n              mpq_trace (\"        got \", got);\n              printf    (\"  upto  want=%d\\n\", want_upto);\n              printf    (\"        got =%d\\n\", got_upto);\n              if (got_ftell != -1)\n                {\n                  printf    (\"  ftell want =%ld\\n\", want_ftell);\n                  printf    (\"        got  =%ld\\n\", got_ftell);\n                }\n              abort ();\n            }\n        }\n    }\n\n  mpq_clear (got);\n  mpq_clear (want);\n}",
      "lines": 383,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "check_f": {
      "start_point": [
        988,
        0
      ],
      "end_point": [
        1284,
        1
      ],
      "content": "void\ncheck_f (void)\n{\n  static const struct {\n    const char  *fmt;\n    const char  *input;\n    const char  *want;\n    int         ret;\n    long        ftell;    /* or -1 for length of input string */\n\n  } data[] = {\n\n    { \"%Ff\",    \"0\",    \"0\", 1, -1 },\n    { \"%Fe\",    \"0\",    \"0\", 1, -1 },\n    { \"%FE\",    \"0\",    \"0\", 1, -1 },\n    { \"%Fg\",    \"0\",    \"0\", 1, -1 },\n    { \"%FG\",    \"0\",    \"0\", 1, -1 },\n\n    { \"%Ff\",  \"123\",    \"123\", 1, -1 },\n    { \"%Ff\", \"+123\",    \"123\", 1, -1 },\n    { \"%Ff\", \"-123\",   \"-123\", 1, -1 },\n    { \"%Ff\",  \"123.\",   \"123\", 1, -1 },\n    { \"%Ff\", \"+123.\",   \"123\", 1, -1 },\n    { \"%Ff\", \"-123.\",  \"-123\", 1, -1 },\n    { \"%Ff\",  \"123.0\",  \"123\", 1, -1 },\n    { \"%Ff\", \"+123.0\",  \"123\", 1, -1 },\n    { \"%Ff\", \"-123.0\", \"-123\", 1, -1 },\n    { \"%Ff\",  \"0123\",   \"123\", 1, -1 },\n    { \"%Ff\", \"-0123\",  \"-123\", 1, -1 },\n\n    { \"%Ff\",  \"123.456e3\",   \"123456\", 1, -1 },\n    { \"%Ff\", \"-123.456e3\",  \"-123456\", 1, -1 },\n    { \"%Ff\",  \"123.456e+3\",  \"123456\", 1, -1 },\n    { \"%Ff\", \"-123.456e+3\", \"-123456\", 1, -1 },\n    { \"%Ff\",  \"123000e-3\",      \"123\", 1, -1 },\n    { \"%Ff\", \"-123000e-3\",     \"-123\", 1, -1 },\n    { \"%Ff\",  \"123000.e-3\",     \"123\", 1, -1 },\n    { \"%Ff\", \"-123000.e-3\",    \"-123\", 1, -1 },\n\n    { \"%Ff\",  \"123.456E3\",   \"123456\", 1, -1 },\n    { \"%Ff\", \"-123.456E3\",  \"-123456\", 1, -1 },\n    { \"%Ff\",  \"123.456E+3\",  \"123456\", 1, -1 },\n    { \"%Ff\", \"-123.456E+3\", \"-123456\", 1, -1 },\n    { \"%Ff\",  \"123000E-3\",      \"123\", 1, -1 },\n    { \"%Ff\", \"-123000E-3\",     \"-123\", 1, -1 },\n    { \"%Ff\",  \"123000.E-3\",     \"123\", 1, -1 },\n    { \"%Ff\", \"-123000.E-3\",    \"-123\", 1, -1 },\n\n    { \"%Ff\",  \".456e3\",   \"456\", 1, -1 },\n    { \"%Ff\", \"-.456e3\",  \"-456\", 1, -1 },\n    { \"%Ff\",  \".456e+3\",  \"456\", 1, -1 },\n    { \"%Ff\", \"-.456e+3\", \"-456\", 1, -1 },\n\n    { \"%Ff\",    \" 0\",    \"0\", 1, -1 },\n    { \"%Ff\",   \"  0\",    \"0\", 1, -1 },\n    { \"%Ff\",  \"   0\",    \"0\", 1, -1 },\n    { \"%Ff\",   \"\\t0\",    \"0\", 1, -1 },\n    { \"%Ff\", \"\\t\\t0\",    \"0\", 1, -1 },\n\n    { \"hello%Fg\",      \"hello0\",       \"0\",   1, -1 },\n    { \"hello%Fg\",      \"hello 0\",      \"0\",   1, -1 },\n    { \"hello%Fg\",      \"hello \\t0\",    \"0\",   1, -1 },\n    { \"hello%Fgworld\", \"hello 0world\", \"0\",   1, -1 },\n    { \"hello%Fg\",      \"hello3.0\",     \"3.0\", 1, -1 },\n\n    { \"hello%*Fg\",      \"hello0\",        \"-999\", 0, -1 },\n    { \"hello%*Fg\",      \"hello 0\",       \"-999\", 0, -1 },\n    { \"hello%*Fg\",      \"hello \\t0\",     \"-999\", 0, -1 },\n    { \"hello%*Fgworld\", \"hello 0world\",  \"-999\", 0, -1 },\n    { \"hello%*Fgworld\", \"hello3.0world\", \"-999\", 0, -1 },\n\n    { \"%Ff\",     \"\",   \"-999\", -1, -1 },\n    { \"%Ff\",    \" \",   \"-999\", -1, -1 },\n    { \"%Ff\",   \"\\t\",   \"-999\", -1, -1 },\n    { \"%Ff\",  \" \\t\",   \"-999\", -1, -1 },\n    { \" %Ff\",    \"\",   \"-999\", -1, -1 },\n    { \"xyz%Ff\",  \"\",   \"-999\", -1, -1 },\n\n    { \"%*Ff\",    \"\",   \"-999\", -1, -1 },\n    { \" %*Ff\",   \"\",   \"-999\", -1, -1 },\n    { \"xyz%*Ff\", \"\",   \"-999\", -1, -1 },\n\n    { \"%Ff\",    \"xyz\", \"0\", 0 },\n\n    /* various non-empty but invalid */\n    { \"%Ff\",    \"-\",      \"-999\",  0, 1 },\n    { \"%Ff\",    \"+\",      \"-999\",  0, 1 },\n    { \"xyz%Ff\", \"xyz-\",   \"-999\",  0, 4 },\n    { \"xyz%Ff\", \"xyz+\",   \"-999\",  0, 4 },\n    { \"%Ff\",    \"-.\",     \"-999\",  0, 2 },\n    { \"%Ff\",    \"+.\",     \"-999\",  0, 2 },\n    { \"%Ff\",    \".e\",     \"-999\",  0, 1 },\n    { \"%Ff\",   \"-.e\",     \"-999\",  0, 2 },\n    { \"%Ff\",   \"+.e\",     \"-999\",  0, 2 },\n    { \"%Ff\",    \".E\",     \"-999\",  0, 1 },\n    { \"%Ff\",   \"-.E\",     \"-999\",  0, 2 },\n    { \"%Ff\",   \"+.E\",     \"-999\",  0, 2 },\n    { \"%Ff\",    \".e123\",  \"-999\",  0, 1 },\n    { \"%Ff\",   \"-.e123\",  \"-999\",  0, 2 },\n    { \"%Ff\",   \"+.e123\",  \"-999\",  0, 2 },\n    { \"%Ff\",    \"123e\",   \"-999\",  0, 4 },\n    { \"%Ff\",   \"-123e\",   \"-999\",  0, 5 },\n    { \"%Ff\",    \"123e-\",  \"-999\",  0, 5 },\n    { \"%Ff\",   \"-123e-\",  \"-999\",  0, 6 },\n    { \"%Ff\",    \"123e+\",  \"-999\",  0, 5 },\n    { \"%Ff\",   \"-123e+\",  \"-999\",  0, 6 },\n    { \"%Ff\",   \"123e-Z\",  \"-999\",  0, 5 },\n\n    /* hex floats */\n    { \"%Ff\", \"0x123p0\",       \"291\",  1, -1 },\n    { \"%Ff\", \"0x123P0\",       \"291\",  1, -1 },\n    { \"%Ff\", \"0X123p0\",       \"291\",  1, -1 },\n    { \"%Ff\", \"0X123P0\",       \"291\",  1, -1 },\n    { \"%Ff\", \"-0x123p0\",     \"-291\",  1, -1 },\n    { \"%Ff\", \"+0x123p0\",      \"291\",  1, -1 },\n    { \"%Ff\", \"0x123.p0\",      \"291\",  1, -1 },\n    { \"%Ff\", \"0x12.3p4\",      \"291\",  1, -1 },\n    { \"%Ff\", \"-0x12.3p4\",    \"-291\",  1, -1 },\n    { \"%Ff\", \"+0x12.3p4\",     \"291\",  1, -1 },\n    { \"%Ff\", \"0x1230p-4\",     \"291\",  1, -1 },\n    { \"%Ff\", \"-0x1230p-4\",   \"-291\",  1, -1 },\n    { \"%Ff\", \"+0x1230p-4\",    \"291\",  1, -1 },\n    { \"%Ff\", \"+0x.1230p12\",   \"291\",  1, -1 },\n    { \"%Ff\", \"+0x123000p-12\", \"291\",  1, -1 },\n    { \"%Ff\", \"0x123 p12\",     \"291\",  1, 5 },\n    { \"%Ff\", \"0x9 9\",           \"9\",  1, 3 },\n    { \"%Ff\", \"0x01\",            \"1\",  1, 4 },\n    { \"%Ff\", \"0x23\",           \"35\",  1, 4 },\n    { \"%Ff\", \"0x45\",           \"69\",  1, 4 },\n    { \"%Ff\", \"0x67\",          \"103\",  1, 4 },\n    { \"%Ff\", \"0x89\",          \"137\",  1, 4 },\n    { \"%Ff\", \"0xAB\",          \"171\",  1, 4 },\n    { \"%Ff\", \"0xCD\",          \"205\",  1, 4 },\n    { \"%Ff\", \"0xEF\",          \"239\",  1, 4 },\n    { \"%Ff\", \"0xab\",          \"171\",  1, 4 },\n    { \"%Ff\", \"0xcd\",          \"205\",  1, 4 },\n    { \"%Ff\", \"0xef\",          \"239\",  1, 4 },\n    { \"%Ff\", \"0x100p0A\",      \"256\",  1, 7 },\n    { \"%Ff\", \"0x1p9\",         \"512\",  1, -1 },\n\n    /* invalid hex floats */\n    { \"%Ff\", \"0x\",     \"-999\",  0, 2 },\n    { \"%Ff\", \"-0x\",    \"-999\",  0, 3 },\n    { \"%Ff\", \"+0x\",    \"-999\",  0, 3 },\n    { \"%Ff\", \"0x-\",    \"-999\",  0, 2 },\n    { \"%Ff\", \"0x+\",    \"-999\",  0, 2 },\n    { \"%Ff\", \"0x.\",    \"-999\",  0, 3 },\n    { \"%Ff\", \"-0x.\",   \"-999\",  0, 4 },\n    { \"%Ff\", \"+0x.\",   \"-999\",  0, 4 },\n    { \"%Ff\", \"0x.p\",   \"-999\",  0, 3 },\n    { \"%Ff\", \"-0x.p\",  \"-999\",  0, 4 },\n    { \"%Ff\", \"+0x.p\",  \"-999\",  0, 4 },\n    { \"%Ff\", \"0x.P\",   \"-999\",  0, 3 },\n    { \"%Ff\", \"-0x.P\",  \"-999\",  0, 4 },\n    { \"%Ff\", \"+0x.P\",  \"-999\",  0, 4 },\n    { \"%Ff\", \".p123\",  \"-999\",  0, 1 },\n    { \"%Ff\", \"-.p123\", \"-999\",  0, 2 },\n    { \"%Ff\", \"+.p123\", \"-999\",  0, 2 },\n    { \"%Ff\", \"0x1p\",   \"-999\",  0, 4 },\n    { \"%Ff\", \"0x1p-\",  \"-999\",  0, 5 },\n    { \"%Ff\", \"0x1p+\",  \"-999\",  0, 5 },\n    { \"%Ff\", \"0x123p 12\", \"291\",  0, 6 },\n    { \"%Ff\", \"0x 123p12\", \"291\",  0, 2 },\n\n  };\n\n  int         i, j, ignore, got_ret, want_ret, got_upto, want_upto;\n  mpf_t       got, want;\n  double      got_d;\n  long        want_ftell;\n  int         error = 0;\n  fun_t       fun;\n  const char  *name;\n  char        fmt[128];\n\n  mpf_init (got);\n  mpf_init (want);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpf_set_str_or_abort (want, data[i].want, 10);\n\n      ASSERT_ALWAYS (strlen (data[i].fmt) + 2 < sizeof (fmt));\n      strcpy (fmt, data[i].fmt);\n      strcat (fmt, \"%n\");\n\n      ignore = (strchr (fmt, '*') != NULL);\n\n      for (j = 0; j <= 3; j++)\n        {\n          want_ret = data[i].ret;\n\n          want_ftell = data[i].ftell;\n          if (want_ftell == -1)\n            want_ftell = strlen (data[i].input);\n          want_upto = want_ftell;\n\n          if (want_ret == -1 || (want_ret == 0 && ! ignore))\n            want_upto = -555;\n\n          switch (j) {\n          case 0:\n            name = \"gmp_sscanf\";\n            fun = fun_gmp_sscanf;\n            break;\n          case 1:\n            name = \"gmp_fscanf\";\n            fun = fun_gmp_fscanf;\n            break;\n          case 2:\n            if (! libc_scanf_convert (fmt))\n              continue;\n            name = \"standard sscanf\";\n            fun = fun_sscanf;\n            break;\n          case 3:\n            if (! libc_scanf_convert (fmt))\n              continue;\n            name = \"standard fscanf\";\n            fun = fun_fscanf;\n            break;\n          default:\n            ASSERT_ALWAYS (0);\n            break;\n          }\n\n          got_upto = -555;\n          got_ftell = -1;\n\n          switch (j) {\n          case 0:\n          case 1:\n            mpf_set_si (got, -999L);\n            if (ignore)\n              got_ret = (*fun) (data[i].input, fmt, &got_upto, NULL);\n            else\n              got_ret = (*fun) (data[i].input, fmt, got, &got_upto);\n            break;\n          case 2:\n          case 3:\n            got_d = -999L;\n            if (ignore)\n              got_ret = (*fun) (data[i].input, fmt, &got_upto, NULL);\n            else\n              got_ret = (*fun) (data[i].input, fmt, &got_d, &got_upto);\n            mpf_set_d (got, got_d);\n            break;\n          default:\n            ASSERT_ALWAYS (0);\n            break;\n          }\n\n          MPF_CHECK_FORMAT (got);\n\n          if (got_ret != want_ret)\n            {\n              printf (\"%s wrong return value\\n\", name);\n              error = 1;\n            }\n          if (want_ret == 1 && mpf_cmp (want, got) != 0)\n            {\n              printf (\"%s wrong result\\n\", name);\n              error = 1;\n            }\n          if (got_upto != want_upto)\n            {\n              printf (\"%s wrong upto\\n\", name);\n              error = 1;\n            }\n          if (got_ftell != -1 && want_ftell != -1 && got_ftell != want_ftell)\n            {\n              printf (\"%s wrong ftell\\n\", name);\n              error = 1;\n            }\n          if (error)\n            {\n              printf    (\"  fmt   \\\"%s\\\"\\n\", data[i].fmt);\n              printf    (\"  input \\\"%s\\\"\\n\", data[i].input);\n              printf    (\"  ret   want=%d\\n\", want_ret);\n              printf    (\"        got =%d\\n\", got_ret);\n              mpf_trace (\"  value want\", want);\n              mpf_trace (\"        got \", got);\n              printf    (\"  upto  want=%d\\n\", want_upto);\n              printf    (\"        got =%d\\n\", got_upto);\n              if (got_ftell != -1)\n                {\n                  printf    (\"  ftell want =%ld\\n\", want_ftell);\n                  printf    (\"        got  =%ld\\n\", got_ftell);\n                }\n              abort ();\n            }\n        }\n    }\n\n  mpf_clear (got);\n  mpf_clear (want);\n}",
      "lines": 297,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "check_n": {
      "start_point": [
        1287,
        0
      ],
      "end_point": [
        1410,
        1
      ],
      "content": "void\ncheck_n (void)\n{\n  int    ret;\n\n  /* %n suppressed */\n  {\n    int n = 123;\n    gmp_sscanf (\"   \", \" %*n\", &n);\n    ASSERT_ALWAYS (n == 123);\n  }\n  {\n    int n = 123;\n    fromstring_gmp_fscanf (\"   \", \" %*n\", &n);\n    ASSERT_ALWAYS (n == 123);\n  }\n\n\n#define CHECK_N(type, string)                           \\\n  do {                                                  \\\n    type  x[2];                                         \\\n    char  fmt[128];                                     \\\n    int   ret;                                          \\\n                                                        \\\n    x[0] = ~ (type) 0;                                  \\\n    x[1] = ~ (type) 0;                                  \\\n    sprintf (fmt, \"abc%%%sn\", string);                  \\\n    ret = gmp_sscanf (\"abc\", fmt, &x[0]);               \\\n                                                        \\\n    ASSERT_ALWAYS (ret == 0);                           \\\n                                                        \\\n    /* should write whole of x[0] and none of x[1] */   \\\n    ASSERT_ALWAYS (x[0] == 3);                          \\\n    ASSERT_ALWAYS (x[1] == (type) ~ (type) 0);\t\t\\\n                                                        \\\n  } while (0)\n\n  CHECK_N (char,      \"hh\");\n  CHECK_N (long,      \"l\");\n#if HAVE_LONG_LONG\n  CHECK_N (long long, \"L\");\n#endif\n#if HAVE_INTMAX_T\n  CHECK_N (intmax_t,  \"j\");\n#endif\n#if HAVE_PTRDIFF_T\n  CHECK_N (ptrdiff_t, \"t\");\n#endif\n  CHECK_N (short,     \"h\");\n  CHECK_N (size_t,    \"z\");\n\n  /* %Zn */\n  {\n    mpz_t  x[2];\n    mpz_init_set_si (x[0], -987L);\n    mpz_init_set_si (x[1],  654L);\n    ret = gmp_sscanf (\"xyz   \", \"xyz%Zn\", x[0]);\n    MPZ_CHECK_FORMAT (x[0]);\n    MPZ_CHECK_FORMAT (x[1]);\n    ASSERT_ALWAYS (ret == 0);\n    ASSERT_ALWAYS (mpz_cmp_ui (x[0], 3L) == 0);\n    ASSERT_ALWAYS (mpz_cmp_ui (x[1], 654L) == 0);\n    mpz_clear (x[0]);\n    mpz_clear (x[1]);\n  }\n  {\n    mpz_t  x;\n    mpz_init (x);\n    ret = fromstring_gmp_fscanf (\"xyz   \", \"xyz%Zn\", x);\n    ASSERT_ALWAYS (ret == 0);\n    ASSERT_ALWAYS (mpz_cmp_ui (x, 3L) == 0);\n    mpz_clear (x);\n  }\n\n  /* %Qn */\n  {\n    mpq_t  x[2];\n    mpq_init (x[0]);\n    mpq_init (x[1]);\n    mpq_set_ui (x[0], 987L, 654L);\n    mpq_set_ui (x[1], 4115L, 226L);\n    ret = gmp_sscanf (\"xyz   \", \"xyz%Qn\", x[0]);\n    MPQ_CHECK_FORMAT (x[0]);\n    MPQ_CHECK_FORMAT (x[1]);\n    ASSERT_ALWAYS (ret == 0);\n    ASSERT_ALWAYS (mpq_cmp_ui (x[0], 3L, 1L) == 0);\n    ASSERT_ALWAYS (mpq_cmp_ui (x[1], 4115L, 226L) == 0);\n    mpq_clear (x[0]);\n    mpq_clear (x[1]);\n  }\n  {\n    mpq_t  x;\n    mpq_init (x);\n    ret = fromstring_gmp_fscanf (\"xyz   \", \"xyz%Qn\", x);\n    ASSERT_ALWAYS (ret == 0);\n    ASSERT_ALWAYS (mpq_cmp_ui (x, 3L, 1L) == 0);\n    mpq_clear (x);\n  }\n\n  /* %Fn */\n  {\n    mpf_t  x[2];\n    mpf_init (x[0]);\n    mpf_init (x[1]);\n    mpf_set_ui (x[0], 987L);\n    mpf_set_ui (x[1], 654L);\n    ret = gmp_sscanf (\"xyz   \", \"xyz%Fn\", x[0]);\n    MPF_CHECK_FORMAT (x[0]);\n    MPF_CHECK_FORMAT (x[1]);\n    ASSERT_ALWAYS (ret == 0);\n    ASSERT_ALWAYS (mpf_cmp_ui (x[0], 3L) == 0);\n    ASSERT_ALWAYS (mpf_cmp_ui (x[1], 654L) == 0);\n    mpf_clear (x[0]);\n    mpf_clear (x[1]);\n  }\n  {\n    mpf_t  x;\n    mpf_init (x);\n    ret = fromstring_gmp_fscanf (\"xyz   \", \"xyz%Fn\", x);\n    ASSERT_ALWAYS (ret == 0);\n    ASSERT_ALWAYS (mpf_cmp_ui (x, 3L) == 0);\n    mpf_clear (x);\n  }\n}",
      "lines": 124,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_misc": {
      "start_point": [
        1413,
        0
      ],
      "end_point": [
        1595,
        1
      ],
      "content": "void\ncheck_misc (void)\n{\n  int  ret, cmp;\n  {\n    int  a=9, b=8, c=7, n=66;\n    mpz_t  z;\n    mpz_init (z);\n    ret = gmp_sscanf (\"1 2 3 4\", \"%d %d %d %Zd%n\",\n                      &a, &b, &c, z, &n);\n    ASSERT_ALWAYS (ret == 4);\n    ASSERT_ALWAYS (a == 1);\n    ASSERT_ALWAYS (b == 2);\n    ASSERT_ALWAYS (c == 3);\n    ASSERT_ALWAYS (n == 7);\n    ASSERT_ALWAYS (mpz_cmp_ui (z, 4L) == 0);\n    mpz_clear (z);\n  }\n  {\n    int  a=9, b=8, c=7, n=66;\n    mpz_t  z;\n    mpz_init (z);\n    ret = fromstring_gmp_fscanf (\"1 2 3 4\", \"%d %d %d %Zd%n\",\n                                 &a, &b, &c, z, &n);\n    ASSERT_ALWAYS (ret == 4);\n    ASSERT_ALWAYS (a == 1);\n    ASSERT_ALWAYS (b == 2);\n    ASSERT_ALWAYS (c == 3);\n    ASSERT_ALWAYS (mpz_cmp_ui (z, 4L) == 0);\n    ASSERT_ALWAYS (n == 7);\n    ASSERT_ALWAYS (got_ftell == 7);\n    mpz_clear (z);\n  }\n\n  {\n    int  a=9, n=8;\n    mpz_t  z;\n    mpz_init (z);\n    ret = gmp_sscanf (\"1 2 3 4\", \"%d %*d %*d %Zd%n\", &a, z, &n);\n    ASSERT_ALWAYS (ret == 2);\n    ASSERT_ALWAYS (a == 1);\n    ASSERT_ALWAYS (mpz_cmp_ui (z, 4L) == 0);\n    ASSERT_ALWAYS (n == 7);\n    mpz_clear (z);\n  }\n  {\n    int  a=9, n=8;\n    mpz_t  z;\n    mpz_init (z);\n    ret = fromstring_gmp_fscanf (\"1 2 3 4\", \"%d %*d %*d %Zd%n\",\n                                 &a, z, &n);\n    ASSERT_ALWAYS (ret == 2);\n    ASSERT_ALWAYS (a == 1);\n    ASSERT_ALWAYS (mpz_cmp_ui (z, 4L) == 0);\n    ASSERT_ALWAYS (n == 7);\n    ASSERT_ALWAYS (got_ftell == 7);\n    mpz_clear (z);\n  }\n\n  /* EOF for no matching */\n  {\n    char buf[128];\n    ret = gmp_sscanf (\"   \", \"%s\", buf);\n    ASSERT_ALWAYS (ret == EOF);\n    ret = fromstring_gmp_fscanf (\"   \", \"%s\", buf);\n    ASSERT_ALWAYS (ret == EOF);\n    if (option_libc_scanf)\n      {\n        ret = sscanf (\"   \", \"%s\", buf);\n        ASSERT_ALWAYS (ret == EOF);\n        ret = fun_fscanf (\"   \", \"%s\", buf, NULL);\n        ASSERT_ALWAYS (ret == EOF);\n      }\n  }\n\n  /* suppressed field, then eof */\n  {\n    int  x;\n    if (test_sscanf_eof_ok ())\n      {\n        ret = gmp_sscanf (\"123\", \"%*d%d\", &x);\n        ASSERT_ALWAYS (ret == EOF);\n      }\n    ret = fromstring_gmp_fscanf (\"123\", \"%*d%d\", &x);\n    ASSERT_ALWAYS (ret == EOF);\n    if (option_libc_scanf)\n      {\n        ret = sscanf (\"123\", \"%*d%d\", &x);\n        ASSERT_ALWAYS (ret == EOF);\n        ret = fun_fscanf (\"123\", \"%*d%d\", &x, NULL);\n        ASSERT_ALWAYS (ret == EOF);\n      }\n  }\n  {\n    mpz_t  x;\n    mpz_init (x);\n    ret = gmp_sscanf (\"123\", \"%*Zd%Zd\", x);\n    ASSERT_ALWAYS (ret == EOF);\n    ret = fromstring_gmp_fscanf (\"123\", \"%*Zd%Zd\", x);\n    ASSERT_ALWAYS (ret == EOF);\n    mpz_clear (x);\n  }\n\n  /* %[...], glibc only */\n#ifdef __GLIBC__\n  {\n    char  buf[128];\n    int   n = -1;\n    buf[0] = '\\0';\n    ret = gmp_sscanf (\"abcdefgh\", \"%[a-d]ef%n\", buf, &n);\n    ASSERT_ALWAYS (ret == 1);\n    cmp = strcmp (buf, \"abcd\");\n    ASSERT_ALWAYS (cmp == 0);\n    ASSERT_ALWAYS (n == 6);\n  }\n  {\n    char  buf[128];\n    int   n = -1;\n    buf[0] = '\\0';\n    ret = gmp_sscanf (\"xyza\", \"%[^a]a%n\", buf, &n);\n    ASSERT_ALWAYS (ret == 1);\n    cmp = strcmp (buf, \"xyz\");\n    ASSERT_ALWAYS (cmp == 0);\n    ASSERT_ALWAYS (n == 4);\n  }\n  {\n    char  buf[128];\n    int   n = -1;\n    buf[0] = '\\0';\n    ret = gmp_sscanf (\"ab]ab]\", \"%[]ab]%n\", buf, &n);\n    ASSERT_ALWAYS (ret == 1);\n    cmp = strcmp (buf, \"ab]ab]\");\n    ASSERT_ALWAYS (cmp == 0);\n    ASSERT_ALWAYS (n == 6);\n  }\n  {\n    char  buf[128];\n    int   n = -1;\n    buf[0] = '\\0';\n    ret = gmp_sscanf (\"xyzb\", \"%[^]ab]b%n\", buf, &n);\n    ASSERT_ALWAYS (ret == 1);\n    cmp = strcmp (buf, \"xyz\");\n    ASSERT_ALWAYS (cmp == 0);\n    ASSERT_ALWAYS (n == 4);\n  }\n#endif\n\n  /* %zd etc won't be accepted by sscanf on old systems, and running\n     something to see if they work might be bad, so only try it on glibc,\n     and only on a new enough version (glibc 2.0 doesn't have %zd) */\n#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 0)\n  {\n    mpz_t   z;\n    size_t  s = -1;\n    mpz_init (z);\n    ret = gmp_sscanf (\"456 789\", \"%zd %Zd\", &s, z);\n    ASSERT_ALWAYS (ret == 2);\n    ASSERT_ALWAYS (s == 456);\n    ASSERT_ALWAYS (mpz_cmp_ui (z, 789L) == 0);\n    mpz_clear (z);\n  }\n  {\n    mpz_t      z;\n    ptrdiff_t  d = -1;\n    mpz_init (z);\n    ret = gmp_sscanf (\"456 789\", \"%td %Zd\", &d, z);\n    ASSERT_ALWAYS (ret == 2);\n    ASSERT_ALWAYS (d == 456);\n    ASSERT_ALWAYS (mpz_cmp_ui (z, 789L) == 0);\n    mpz_clear (z);\n  }\n  {\n    mpz_t      z;\n    long long  ll = -1;\n    mpz_init (z);\n    ret = gmp_sscanf (\"456 789\", \"%Ld %Zd\", &ll, z);\n    ASSERT_ALWAYS (ret == 2);\n    ASSERT_ALWAYS (ll == 456);\n    ASSERT_ALWAYS (mpz_cmp_ui (z, 789L) == 0);\n    mpz_clear (z);\n  }\n#endif\n}",
      "lines": 183,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        1597,
        0
      ],
      "end_point": [
        1616,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc > 1 && strcmp (argv[1], \"-s\") == 0)\n    option_libc_scanf = 1;\n\n  tests_start ();\n\n  mp_trace_base = 16;\n\n  check_z ();\n  check_q ();\n  check_f ();\n  check_n ();\n  check_misc ();\n\n  unlink (TEMPFILE);\n  tests_end ();\n  exit (0);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/reuse.c": {
    "main": [
      {
        "start_point": [
          34,
          0
        ],
        "end_point": [
          39,
          1
        ],
        "content": "int\nmain (void)\n{\n  printf (\"Test suppressed for windows DLL\\n\");\n  exit (0);\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          92,
          0
        ],
        "end_point": [
          201,
          1
        ],
        "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int pass, reps = 10000;\n  mpf_t in1, in2, out1;\n  unsigned long int in1i, in2i;\n  mpf_t res1, res2, res3;\n  mp_size_t bprec = 100;\n\n  tests_start ();\n\n  if (argc > 1)\n    {\n      reps = strtol (argv[1], 0, 0);\n      if (argc > 2)\n\tbprec = strtol (argv[2], 0, 0);\n    }\n\n  mpf_set_default_prec (bprec);\n\n  mpf_init (in1);\n  mpf_init (in2);\n  mpf_init (out1);\n  mpf_init (res1);\n  mpf_init (res2);\n  mpf_init (res3);\n\n  for (pass = 1; pass <= reps; pass++)\n    {\n      mpf_random2 (in1, urandom () % SIZE - SIZE/2, urandom () % EXPO);\n      mpf_random2 (in2, urandom () % SIZE - SIZE/2, urandom () % EXPO);\n\n      for (i = 0; i < sizeof (dss_funcs) / sizeof (dss_func); i++)\n\t{\n\t  /* Don't divide by 0.  */\n\t  if (i == 0 && mpf_cmp_ui (in2, 0) == 0)\n\t    continue;\n\n\t  (dss_funcs[i]) (res1, in1, in2);\n\n\t  mpf_set (out1, in1);\n\t  (dss_funcs[i]) (out1, out1, in2);\n\t  mpf_set (res2, out1);\n\n\t  mpf_set (out1, in2);\n\t  (dss_funcs[i]) (out1, in1, out1);\n\t  mpf_set (res3, out1);\n\n\t  if (mpf_cmp (res1, res2) != 0)\n\t    dump_abort (dss_func_names[i], res1, res2);\n\t  if (mpf_cmp (res1, res3) != 0)\n\t    dump_abort (dss_func_names[i], res1, res3);\n\t}\n\n      in2i = urandom ();\n      for (i = 0; i < sizeof (dsi_funcs) / sizeof (dsi_func); i++)\n\t{\n\t  unsigned long this_in2i = in2i;\n\n\t  /* Don't divide by 0.  */\n\t  if (dsi_funcs[i] == mpf_div_ui && this_in2i == 0)\n\t    continue;\n\n\t  /* Avoid overflow/underflow in the exponent.  */\n\t  if (dsi_funcs[i] == mpf_mul_2exp || dsi_funcs[i] == mpf_div_2exp)\n\t    this_in2i %= 0x100000;\n\t  else if (dsi_funcs[i] == mpf_pow_ui)\n\t    this_in2i %= 0x1000;\n\n\t  (dsi_funcs[i]) (res1, in1, this_in2i);\n\n\t  mpf_set (out1, in1);\n\t  (dsi_funcs[i]) (out1, out1, this_in2i);\n\t  mpf_set (res2, out1);\n\n\t  if (mpf_cmp (res1, res2) != 0)\n\t    dump_abort (dsi_func_names[i], res1, res2);\n\t}\n\n      in1i = urandom ();\n      for (i = 0; i < sizeof (dis_funcs) / sizeof (dis_func); i++)\n\t{\n\t  /* Don't divide by 0.  */\n\t  if (dis_funcs[i] == mpf_ui_div\n\t      && mpf_cmp_ui (in2, 0) == 0)\n\t    continue;\n\n\t  (dis_funcs[i]) (res1, in1i, in2);\n\n\t  mpf_set (out1, in2);\n\t  (dis_funcs[i]) (out1, in1i, out1);\n\t  mpf_set (res2, out1);\n\n\t  if (mpf_cmp (res1, res2) != 0)\n\t    dump_abort (dis_func_names[i], res1, res2);\n\t}\n\n    }\n\n  mpf_clear (in1);\n  mpf_clear (in2);\n  mpf_clear (out1);\n  mpf_clear (res1);\n  mpf_clear (res2);\n  mpf_clear (res3);\n\n  tests_end ();\n  exit (0);\n}",
        "lines": 110,
        "depth": 13,
        "decorators": [
          "int"
        ]
      }
    ],
    "dump_abort": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "void\ndump_abort (const char *name, mpf_t res1, mpf_t res2)\n{\n  printf (\"failure in %s:\\n\", name);\n  mpf_dump (res1);\n  mpf_dump (res2);\n  abort ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-add.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_size_t size;\n  mp_exp_t exp;\n  int reps = 20000;\n  int i;\n  mpf_t u, v, w, wref;\n  mp_size_t bprec = 100;\n  mpf_t rerr, max_rerr, limit_rerr;\n\n  tests_start ();\n\n  if (argc > 1)\n    {\n      reps = strtol (argv[1], 0, 0);\n      if (argc > 2)\n\tbprec = strtol (argv[2], 0, 0);\n    }\n\n  mpf_set_default_prec (bprec);\n\n  mpf_init_set_ui (limit_rerr, 1);\n  mpf_div_2exp (limit_rerr, limit_rerr, bprec);\n#if VERBOSE\n  mpf_dump (limit_rerr);\n#endif\n  mpf_init (rerr);\n  mpf_init_set_ui (max_rerr, 0);\n\n  mpf_init (u);\n  mpf_init (v);\n  mpf_init (w);\n  mpf_init (wref);\n  for (i = 0; i < reps; i++)\n    {\n      size = urandom () % (2 * SIZE) - SIZE;\n      exp = urandom () % SIZE;\n      mpf_random2 (u, size, exp);\n\n      size = urandom () % (2 * SIZE) - SIZE;\n      exp = urandom () % SIZE;\n      mpf_random2 (v, size, exp);\n\n      mpf_add (w, u, v);\n      refmpf_add (wref, u, v);\n\n      mpf_reldiff (rerr, w, wref);\n      if (mpf_cmp (rerr, max_rerr) > 0)\n\t{\n\t  mpf_set (max_rerr, rerr);\n#if VERBOSE\n\t  mpf_dump (max_rerr);\n#endif\n\t  if (mpf_cmp (rerr, limit_rerr) > 0)\n\t    {\n\t      printf (\"ERROR after %d tests\\n\", i);\n\t      printf (\"   u = \"); mpf_dump (u);\n\t      printf (\"   v = \"); mpf_dump (v);\n\t      printf (\"wref = \"); mpf_dump (wref);\n\t      printf (\"   w = \"); mpf_dump (w);\n\t      abort ();\n\t    }\n\t}\n    }\n\n  mpf_clear (limit_rerr);\n  mpf_clear (rerr);\n  mpf_clear (max_rerr);\n\n  mpf_clear (u);\n  mpf_clear (v);\n  mpf_clear (w);\n  mpf_clear (wref);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 78,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-cmp_d.c": {
    "check_one": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\ncheck_one (const char *name, mpf_srcptr x, double y, int cmp)\n{\n  int   got;\n\n  got = mpf_cmp_d (x, y);\n  if (SGN(got) != cmp)\n    {\n      int i;\n      printf    (\"mpf_cmp_d wrong (from %s)\\n\", name);\n      printf    (\"  got  %d\\n\", got);\n      printf    (\"  want %d\\n\", cmp);\n      mpf_trace (\"  x\", x);\n      printf    (\"  y %g\\n\", y);\n      mp_trace_base=-16;\n      mpf_trace (\"  x\", x);\n      printf    (\"  y %g\\n\", y);\n      printf    (\"  y\");\n      for (i = 0; i < sizeof(y); i++)\n        printf (\" %02X\", (unsigned) ((unsigned char *) &y)[i]);\n      printf (\"\\n\");\n      abort ();\n    }\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "check_infinity": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\ncheck_infinity (void)\n{\n  mpf_t   x;\n  double  y = tests_infinity_d ();\n  if (y == 0.0)\n    return;\n\n  mpf_init (x);\n\n  /* 0 cmp inf */\n  mpf_set_ui (x, 0L);\n  check_one (\"check_infinity\", x,  y, -1);\n  check_one (\"check_infinity\", x, -y,  1);\n\n  /* 123 cmp inf */\n  mpf_set_ui (x, 123L);\n  check_one (\"check_infinity\", x,  y, -1);\n  check_one (\"check_infinity\", x, -y,  1);\n\n  /* -123 cmp inf */\n  mpf_set_si (x, -123L);\n  check_one (\"check_infinity\", x,  y, -1);\n  check_one (\"check_infinity\", x, -y,  1);\n\n  /* 2^5000 cmp inf */\n  mpf_set_ui (x, 1L);\n  mpf_mul_2exp (x, x, 5000L);\n  check_one (\"check_infinity\", x,  y, -1);\n  check_one (\"check_infinity\", x, -y,  1);\n\n  /* -2^5000 cmp inf */\n  mpf_neg (x, x);\n  check_one (\"check_infinity\", x,  y, -1);\n  check_one (\"check_infinity\", x, -y,  1);\n\n  mpf_clear (x);\n}",
      "lines": 38,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  check_infinity ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-cmp_si.c": {
    "check_data": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    int         a_base;\n    const char  *a;\n    const char  *b;\n    int         want;\n  } data[] = {\n    { 10, \"0\",  \"1\", -1 },\n    { 10, \"0\",  \"0\",  0 },\n    { 10, \"0\", \"-1\",  1 },\n\n    { 10, \"1\",  \"1\", 0 },\n    { 10, \"1\",  \"0\", 1 },\n    { 10, \"1\", \"-1\", 1 },\n\n    { 10, \"-1\",  \"1\", -1 },\n    { 10, \"-1\",  \"0\", -1 },\n    { 10, \"-1\", \"-1\", 0 },\n\n    { 10, \"1.5\", \"2\", -1 },\n    { 10, \"1.5\", \"1\",  1 },\n    { 10, \"0.5\", \"1\", -1 },\n\n    { 10, \"-1.5\", \"-2\",  1 },\n    { 10, \"-1.5\", \"-1\", -1 },\n    { 10, \"-0.5\", \"-1\",  1 },\n\n    { 16,         \"0\", \"-0x80000000\",  1 },\n    { 16,  \"80000000\", \"-0x80000000\",  1 },\n    { 16,  \"80000001\", \"-0x80000000\",  1 },\n    { 16, \"-80000000\", \"-0x80000000\",  0 },\n    { 16, \"-80000001\", \"-0x80000000\", -1 },\n    { 16, \"-FF0080000001\", \"-0x80000000\", -1 },\n\n    { 16,                 \"0\", \"-0x8000000000000000\",  1 },\n    { 16,  \"8000000000000000\", \"-0x8000000000000000\",  1 },\n    { 16,  \"8000000000000001\", \"-0x8000000000000000\",  1 },\n    { 16, \"-8000000000000000\", \"-0x8000000000000000\",  0 },\n    { 16, \"-8000000000000000.1\", \"-0x8000000000000000\", -1 },\n    { 16, \"-FF008000000000000001\", \"-0x8000000000000000\", -1 },\n\n    { 16,                 \"0\", \"-0x876543210FEDCBA9876543210000000\",  1 },\n    { 16,  \"876543210FEDCBA9876543210000000\", \"-0x876543210FEDCBA9876543210000000\",  1 },\n    { 16,  \"876543210FEDCBA9876543210000001\", \"-0x876543210FEDCBA9876543210000000\",  1 },\n    { 16, \"-876543210FEDCBA9876543210000000\", \"-0x876543210FEDCBA9876543210000000\",  0 },\n    { 16, \"-876543210FEDCBA9876543210000000.1\", \"-0x876543210FEDCBA9876543210000000\", -1 },\n    { 16, \"-FF00876543210FEDCBA9876543210000000\", \"-0x876543210FEDCBA9876543210000000\", -1 },\n  };\n\n  mpf_t  a;\n  mpz_t  bz;\n  long   b;\n  int    got;\n  int    i;\n\n  mpf_init2 (a, 128);\n  mpz_init (bz);\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpf_set_str_or_abort (a, data[i].a, data[i].a_base);\n      mpz_set_str_or_abort (bz, data[i].b, 0);\n\n      if (mpz_fits_slong_p (bz))\n        {\n          b = mpz_get_si (bz);\n          got = mpf_cmp_si (a, b);\n          if (SGN (got) != data[i].want)\n            {\n              printf (\"mpf_cmp_si wrong on data[%d]\\n\", i);\n              printf (\"  a=\"); mpf_out_str (stdout, 10, 0, a);\n              printf (\" (%s)\\n\", data[i].a);\n              printf (\"  b=%ld (%s)\\n\", b, data[i].b);\n              printf (\"  got=%d\\n\", got);\n              printf (\"  want=%d\\n\", data[i].want);\n              abort();\n            }\n        }\n\n      got = mpf_cmp_z (a, bz);\n      if (SGN (got) != data[i].want)\n      \t{\n\t  b = mpz_get_si (bz);\n      \t  printf (\"mpf_cmp_z wrong on data[%d]\\n\", i);\n      \t  printf (\"  a=\"); mpf_out_str (stdout, 10, 0, a);\n      \t  printf (\" (%s)\\n\", data[i].a);\n      \t  printf (\"  b=%ld (%s)\\n\", b, data[i].b);\n      \t  printf (\"  got=%d\\n\", got);\n      \t  printf (\"  want=%d\\n\", data[i].want);\n      \t  abort();\n      \t}\n    }\n\n  mpf_clear (a);\n  mpz_clear (bz);\n}",
      "lines": 97,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-conv.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpf_t x, y;\n  int reps = 20000;\n  int i;\n  mp_size_t bprec = 100;\n  mpf_t d, rerr, max_rerr, limit_rerr;\n  char *str;\n  mp_exp_t bexp;\n  long size, exp;\n  int base;\n  char buf[SIZE * GMP_LIMB_BITS + 5];\n\n  tests_start ();\n\n  if (argc > 1)\n    {\n      reps = strtol (argv[1], 0, 0);\n      if (argc > 2)\n\tbprec = strtol (argv[2], 0, 0);\n    }\n\n  mpf_set_default_prec (bprec);\n\n  mpf_init_set_ui (limit_rerr, 1);\n  mpf_div_2exp (limit_rerr, limit_rerr, bprec);\n#if VERBOSE\n  mpf_dump (limit_rerr);\n#endif\n  mpf_init (rerr);\n  mpf_init_set_ui (max_rerr, 0);\n\n  mpf_init (x);\n  mpf_init (y);\n  mpf_init (d);\n\n  /* First test some specific values.  */\n\n  mpf_set_str (y, \"1.23456e1000\", 0);\n\n  mpf_set_str (x, \"1.23456e1000\", 10);\n  if (mpf_cmp (x, y) != 0)\n    abort ();\n  mpf_set_str (x, \"1.23456e+1000\", 0);\n  if (mpf_cmp (x, y) != 0)\n    abort ();\n  mpf_set_str (x, \"1.23456e+1000\", 10);\n  if (mpf_cmp (x, y) != 0)\n    abort ();\n\n  /* Now test random values.  */\n\n  for (i = 0; i < reps; i++)\n    {\n      if (i == 0)\n        {\n          /* exercise the special case in get_str for for x==0 */\n          mpf_set_ui (x, 0L);\n          base = 10;\n        }\n      else\n        {\n          size = urandom () % (2 * SIZE) - SIZE;\n          exp = urandom () % EXPO;\n          mpf_random2 (x, size, exp);\n          base = urandom () % 61 + 2;\n        }\n\n      str = mpf_get_str (0, &bexp, base, 0, x);\n\n      if (str[0] == '-')\n\tsprintf (buf, \"-0.%s@%ld\", str + 1, bexp);\n      else\n\tsprintf (buf, \"0.%s@%ld\", str, bexp);\n\n      mpf_set_str_or_abort (y, buf, -base);\n      (*__gmp_free_func) (str, strlen (str) + 1);\n\n      mpf_reldiff (rerr, x, y);\n      if (mpf_cmp (rerr, max_rerr) > 0)\n\t{\n\t  mpf_set (max_rerr, rerr);\n#if VERBOSE\n\t  mpf_dump (max_rerr);\n#endif\n\t  if (mpf_cmp (rerr, limit_rerr) > 0)\n\t    {\n\t      printf (\"ERROR after %d tests\\n\", i);\n\t      printf (\"base = %d\\n\", base);\n\t      printf (\"   x = \"); mpf_dump (x);\n\t      printf (\"   y = \"); mpf_dump (y);\n\t      abort ();\n\t    }\n\t}\n    }\n\n  mpf_clear (limit_rerr);\n  mpf_clear (rerr);\n  mpf_clear (max_rerr);\n\n  mpf_clear (x);\n  mpf_clear (y);\n  mpf_clear (d);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 108,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-div.c": {
    "check_one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\ncheck_one (const char *desc, mpf_ptr got, mpf_srcptr u, mpf_srcptr v)\n{\n  if (! refmpf_validate_division (\"mpf_div\", got, u, v))\n    {\n      mp_trace_base = -16;\n      mpf_trace (\"  u\", u);\n      mpf_trace (\"  v\", v);\n      printf    (\"  %s\\n\", desc);\n      abort ();\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_rand": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "void\ncheck_rand (void)\n{\n  unsigned long  min_prec = __GMPF_BITS_TO_PREC (1);\n  gmp_randstate_ptr  rands = RANDS;\n  unsigned long  prec;\n  mpf_t  got, u, v;\n  int    i;\n\n  mpf_init (got);\n  mpf_init (u);\n  mpf_init (v);\n\n  /* separate */\n  for (i = 0; i < 100; i++)\n    {\n      /* got precision */\n      prec = min_prec + gmp_urandomm_ui (rands, 15L);\n      refmpf_set_prec_limbs (got, prec);\n\n      /* u */\n      prec = min_prec + gmp_urandomm_ui (rands, 15L);\n      refmpf_set_prec_limbs (u, prec);\n      do {\n        mpf_random2 (u, PREC(u), (mp_exp_t) 20);\n      } while (SIZ(u) == 0);\n      if (gmp_urandomb_ui (rands, 1L))\n        mpf_neg (u, u);\n\n      /* v */\n      prec = min_prec + gmp_urandomm_ui (rands, 15L);\n      refmpf_set_prec_limbs (v, prec);\n      do {\n        mpf_random2 (v, PREC(v), (mp_exp_t) 20);\n      } while (SIZ(v) == 0);\n      if (gmp_urandomb_ui (rands, 1L))\n        mpf_neg (v, v);\n\n      switch (i % 3) {\n      case 0:\n        mpf_div (got, u, v);\n        check_one (\"separate\", got, u, v);\n        break;\n      case 1:\n        prec = refmpf_set_overlap (got, u);\n        mpf_div (got, got, v);\n        check_one (\"dst == u\", got, u, v);\n        mpf_set_prec_raw (got, prec);\n        break;\n      case 2:\n        prec = refmpf_set_overlap (got, v);\n        mpf_div (got, u, got);\n        check_one (\"dst == v\", got, u, v);\n        mpf_set_prec_raw (got, prec);\n        break;\n      }\n    }\n\n  mpf_clear (got);\n  mpf_clear (u);\n  mpf_clear (v);\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_reuse_three": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "void\ncheck_reuse_three (void)\n{\n  unsigned long  min_prec = __GMPF_BITS_TO_PREC (1);\n  gmp_randstate_ptr  rands = RANDS;\n  unsigned long  result_prec, input_prec, set_prec;\n  mpf_t  got;\n  int    i;\n\n  mpf_init (got);\n\n  for (i = 0; i < 8; i++)\n    {\n      result_prec = min_prec + gmp_urandomm_ui (rands, 15L);\n      input_prec = min_prec + gmp_urandomm_ui (rands, 15L);\n\n      set_prec = MAX (result_prec, input_prec);\n      refmpf_set_prec_limbs (got, set_prec);\n\n      /* input, non-zero, possibly negative */\n      PREC(got) = input_prec;\n      do {\n        mpf_random2 (got, input_prec, (mp_exp_t) 20);\n      } while (SIZ(got) == 0);\n      if (gmp_urandomb_ui (rands, 1L))\n        mpf_neg (got, got);\n\n      PREC(got) = result_prec;\n\n      mpf_div (got, got, got);\n\n      /* expect exactly 1.0 always */\n      ASSERT_ALWAYS (mpf_cmp_ui (got, 1L) == 0);\n\n      PREC(got) = set_prec;\n    }\n\n  mpf_clear (got);\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  mpf_t got, u, v;\n\n  mpf_init (got);\n  mpf_init (u);\n  mpf_init (v);\n\n  /* 100/4 == 25 */\n  mpf_set_prec (got, 20L);\n  mpf_set_ui (u, 100L);\n  mpf_set_ui (v, 4L);\n  mpf_div (got, u, v);\n  MPF_CHECK_FORMAT (got);\n  ASSERT_ALWAYS (mpf_cmp_ui (got, 25L) == 0);\n\n  /* 1/(2^n+1), a case where truncating the divisor would be wrong */\n  mpf_set_prec (got, 500L);\n  mpf_set_prec (v, 900L);\n  mpf_set_ui (v, 1L);\n  mpf_mul_2exp (v, v, 800L);\n  mpf_add_ui (v, v, 1L);\n  mpf_div (got, u, v);\n  check_one (\"1/2^n+1, separate\", got, u, v);\n\n  mpf_clear (got);\n  mpf_clear (u);\n  mpf_clear (v);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_various ();\n  check_rand ();\n  check_reuse_three ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-dm2exp.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int reps = 100000;\n  int i;\n  mpf_t u, v, w1, w2, w3;\n  mp_size_t bprec = 100;\n  mpf_t rerr, limit_rerr;\n  mp_size_t un;\n  mp_exp_t ue;\n\n  tests_start ();\n\n  if (argc > 1)\n    {\n      reps = strtol (argv[1], 0, 0);\n      if (argc > 2)\n\tbprec = strtol (argv[2], 0, 0);\n    }\n\n  mpf_set_default_prec (bprec);\n\n  mpf_init (rerr);\n  mpf_init (limit_rerr);\n\n  mpf_init (u);\n  mpf_init (v);\n  mpf_init (w1);\n  mpf_init (w2);\n  mpf_init (w3);\n\n  for (i = 0; i < reps; i++)\n    {\n      unsigned long int res_prec;\n      unsigned long int pow2;\n\n      res_prec = urandom () % (bprec + 100);\n      mpf_set_prec (w1, res_prec);\n      mpf_set_prec (w2, res_prec);\n      mpf_set_prec (w3, res_prec);\n\n      mpf_set_ui (limit_rerr, 1);\n      mpf_div_2exp (limit_rerr, limit_rerr, res_prec);\n\n      pow2 = urandom () % 0x10000;\n      mpf_set_ui (v, 1);\n      mpf_mul_2exp (v, v, pow2);\n\n      un = urandom () % (2 * SIZE) - SIZE;\n      ue = urandom () % SIZE;\n      mpf_random2 (u, un, ue);\n\n      mpf_div_2exp (w1, u, pow2);\n      mpf_div (w2, u, v);\n      mpf_reldiff (rerr, w1, w2);\n      if (mpf_cmp (rerr, limit_rerr) > 0)\n\t{\n\t  printf (\"ERROR in mpf_div or mpf_div_2exp after %d tests\\n\", i);\n\t  printf (\"   u = \"); mpf_dump (u);\n\t  printf (\"   v = \"); mpf_dump (v);\n\t  printf (\"  w1 = \"); mpf_dump (w1);\n\t  printf (\"  w2 = \"); mpf_dump (w2);\n\t  abort ();\n\t}\n      mpf_mul_2exp (w3, w1, pow2);\n      mpf_reldiff (rerr, u, w3);\n      if (mpf_cmp (rerr, limit_rerr) > 0)\n\t{\n\t  printf (\"ERROR in mpf_mul_2exp after %d tests\\n\", i);\n\t  printf (\"   u = \"); mpf_dump (u);\n\t  printf (\"   v = \"); mpf_dump (v);\n\t  printf (\"  w1 = \"); mpf_dump (w1);\n\t  printf (\"  w3 = \"); mpf_dump (w3);\n\t  abort ();\n\t}\n    }\n\n  mpf_clear (rerr);\n  mpf_clear (limit_rerr);\n\n  mpf_clear (u);\n  mpf_clear (v);\n  mpf_clear (w1);\n  mpf_clear (w2);\n  mpf_clear (w3);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 89,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-eq.c": {
    "check_data": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct\n  {\n    struct {\n      int        exp, size;\n      mp_limb_t  d[10];\n    } x, y;\n    mp_bitcnt_t bits;\n    int want;\n\n  } data[] = {\n    { { 0, 0, { 0 } },             { 0, 0, { 0 } },    0, 1 },\n\n    { { 0, 1, { 7 } },             { 0, 1, { 7 } },    0, 1 },\n    { { 0, 1, { 7 } },             { 0, 1, { 7 } },   17, 1 },\n    { { 0, 1, { 7 } },             { 0, 1, { 7 } }, 4711, 1 },\n\n    { { 0, 1, { 7 } },             { 0, 1, { 6 } },    0, 1 },\n    { { 0, 1, { 7 } },             { 0, 1, { 6 } },    2, 1 },\n    { { 0, 1, { 7 } },             { 0, 1, { 6 } },    3, 0 },\n\n    { { 0, 0, { 0 } },             { 0, 1, { 1 } },    0, 0 },\n    { { 0, 1, { 1 } },             { 0,-1 ,{ 1 } },    0, 0 },\n    { { 1, 1, { 1 } },             { 0, 1, { 1 } },    0, 0 },\n\n    { { 0, 1, { 8 } },             { 0, 1, { 4 } },    0, 0 },\n\n    { { 0, 2, { 0, 3 } },          { 0, 1, { 3 } }, 1000, 1 },\n  };\n\n  mpf_t  x, y;\n  int got, got_swapped;\n  int i;\n  mp_trace_base = 16;\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      PTR(x) = (mp_ptr) data[i].x.d;\n      SIZ(x) = data[i].x.size;\n      EXP(x) = data[i].x.exp;\n      PREC(x) = numberof (data[i].x.d);\n      MPF_CHECK_FORMAT (x);\n\n      PTR(y) = (mp_ptr) data[i].y.d;\n      SIZ(y) = data[i].y.size;\n      EXP(y) = data[i].y.exp;\n      PREC(y) = numberof (data[i].y.d);\n      MPF_CHECK_FORMAT (y);\n\n      got         = mpf_eq (x, y, data[i].bits);\n      got_swapped = mpf_eq (y, x, data[i].bits);\n\n      if (got != got_swapped || got != data[i].want)\n\t{\n\t  printf (\"check_data() wrong result at data[%d]\\n\", i);\n\t  mpf_trace (\"x   \", x);\n\t  mpf_trace (\"y   \", y);\n\t  printf (\"got         %d\\n\", got);\n\t  printf (\"got_swapped %d\\n\", got_swapped);\n\t  printf (\"want        %d\\n\", data[i].want);\n\t  abort ();\n        }\n    }\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "void\ncheck_random (long reps)\n{\n  unsigned long test;\n  gmp_randstate_ptr rands = RANDS;\n  mpf_t a, b, x;\n  mpz_t ds;\n  int hibits, lshift1, lshift2;\n  int xtra;\n\n#define HIBITS 10\n#define LSHIFT1 10\n#define LSHIFT2 10\n\n  mpf_set_default_prec ((1 << HIBITS) + (1 << LSHIFT1) + (1 << LSHIFT2));\n\n  mpz_init (ds);\n  mpf_inits (a, b, x, NULL);\n\n  for (test = 0; test < reps; test++)\n    {\n      mpz_urandomb (ds, rands, HIBITS);\n      hibits = mpz_get_ui (ds) + 1;\n      mpz_urandomb (ds, rands, hibits);\n      mpz_setbit (ds, hibits  - 1);\t/* make sure msb is set */\n      mpf_set_z (a, ds);\n      mpf_set_z (b, ds);\n\n      mpz_urandomb (ds, rands, LSHIFT1);\n      lshift1 = mpz_get_ui (ds);\n      mpf_mul_2exp (a, a, lshift1 + 1);\n      mpf_mul_2exp (b, b, lshift1 + 1);\n      mpf_add_ui (a, a, 1);\t/* make a one-bit difference */\n\n      mpz_urandomb (ds, rands, LSHIFT2);\n      lshift2 = mpz_get_ui (ds);\n      mpf_mul_2exp (a, a, lshift2);\n      mpf_mul_2exp (b, b, lshift2);\n      mpz_urandomb (ds, rands, lshift2);\n      mpf_set_z (x, ds);\n      mpf_add (a, a, x);\n      mpf_add (b, b, x);\n\n      insert_random_low_zero_limbs (a, rands);\n      insert_random_low_zero_limbs (b, rands);\n\n      if (mpf_eq (a, b, lshift1 + hibits) == 0 ||\n\t  mpf_eq (b, a, lshift1 + hibits) == 0)\n\t{\n\t  dump_abort (a, b, lshift1 + hibits, lshift1, lshift2, hibits, 1, test);\n\t}\n      for (xtra = 1; xtra < 100; xtra++)\n\tif (mpf_eq (a, b, lshift1 + hibits + xtra) != 0 ||\n\t    mpf_eq (b, a, lshift1 + hibits + xtra) != 0)\n\t  {\n\t    dump_abort (a, b, lshift1 + hibits + xtra, lshift1, lshift2, hibits, 0, test);\n\t  }\n    }\n\n  mpf_clears (a, b, x, NULL);\n  mpz_clear (ds);\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "insert_random_low_zero_limbs": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\ninsert_random_low_zero_limbs (mpf_t x, gmp_randstate_ptr rands)\n{\n  mp_size_t max = PREC(x) - SIZ(x);\n  mp_size_t s;\n  mpz_t ds; mpz_init (ds);\n  mpz_urandomb (ds, rands, 32);\n  s = mpz_get_ui (ds) % (max + 1);\n  MPN_COPY_DECR (PTR(x) + s, PTR(x), SIZ(x));\n  MPN_ZERO (PTR(x), s);\n  SIZ(x) += s;\n  mpz_clear (ds);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "dump_abort": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\ndump_abort (mpf_t a, mpf_t b, int cmp_prec, int lshift1, int lshift2, int hibits, int want, long test)\n{\n  printf (\"ERROR in test %ld\\n\", test);\n  printf (\"want %d got %d from mpf_eq\\n\", want, 1-want);\n  printf (\"cmp_prec = %d\\n\", cmp_prec);\n  printf (\"lshift1 = %d\\n\", lshift1);\n  printf (\"lshift2 = %d\\n\", lshift2);\n  printf (\"hibits = %d\\n\", hibits);\n  hexdump (a); puts (\"\");\n  hexdump (b); puts (\"\");\n  abort ();\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hexdump": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "void\nhexdump (mpf_t x)\n{\n  mp_size_t i;\n  for (i = ABSIZ(x) - 1; i >= 0; i--)\n    {\n      gmp_printf (\"%0*MX\", SZ, PTR(x)[i]);\n      if (i != 0)\n\tprintf (\" \");\n    }\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  long reps = 10000;\n\n  if (argc == 2)\n    reps = strtol (argv[1], 0, 0);\n\n  tests_start ();\n\n  check_data ();\n  check_random (reps);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-fits.c": {
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "int\nmain (void)\n{\n  mpf_t       f, f0p5;\n  int         got;\n  const char  *expr;\n  int         error = 0;\n\n  tests_start ();\n  mpf_init2 (f, 200L);\n  mpf_init2 (f0p5, 200L);\n\n  /* 0.5 */\n  mpf_set_ui (f0p5, 1L);\n  mpf_div_2exp (f0p5, f0p5, 1L);\n\n  mpf_set_ui (f, 0L);\n  expr = \"0\";\n  EXPECT (mpf_fits_ulong_p, 1);\n  EXPECT (mpf_fits_uint_p, 1);\n  EXPECT (mpf_fits_ushort_p, 1);\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n  EXPECT (mpf_fits_sshort_p, 1);\n\n  mpf_set_ui (f, 1L);\n  expr = \"1\";\n  EXPECT (mpf_fits_ulong_p, 1);\n  EXPECT (mpf_fits_uint_p, 1);\n  EXPECT (mpf_fits_ushort_p, 1);\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n  EXPECT (mpf_fits_sshort_p, 1);\n\n  mpf_set_si (f, -1L);\n  expr = \"-1\";\n  EXPECT (mpf_fits_ulong_p, 0);\n  EXPECT (mpf_fits_uint_p, 0);\n  EXPECT (mpf_fits_ushort_p, 0);\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n  EXPECT (mpf_fits_sshort_p, 1);\n\n\n  mpf_set_ui (f, (unsigned long) USHRT_MAX);\n  expr = \"USHRT_MAX\";\n  EXPECT (mpf_fits_ulong_p, 1);\n  EXPECT (mpf_fits_uint_p, 1);\n  EXPECT (mpf_fits_ushort_p, 1);\n\n  mpf_set_ui (f, (unsigned long) USHRT_MAX);\n  mpf_add (f, f, f0p5);\n  expr = \"USHRT_MAX + 0.5\";\n  EXPECT (mpf_fits_ulong_p, 1);\n  EXPECT (mpf_fits_uint_p, 1);\n  EXPECT (mpf_fits_ushort_p, 1);\n\n  mpf_set_ui (f, (unsigned long) USHRT_MAX);\n  mpf_add_ui (f, f, 1L);\n  expr = \"USHRT_MAX + 1\";\n  EXPECT (mpf_fits_ushort_p, 0);\n\n\n  mpf_set_ui (f, (unsigned long) UINT_MAX);\n  expr = \"UINT_MAX\";\n  EXPECT (mpf_fits_ulong_p, 1);\n  EXPECT (mpf_fits_uint_p, 1);\n\n  mpf_set_ui (f, (unsigned long) UINT_MAX);\n  mpf_add (f, f, f0p5);\n  expr = \"UINT_MAX + 0.5\";\n  EXPECT (mpf_fits_ulong_p, 1);\n  EXPECT (mpf_fits_uint_p, 1);\n\n  mpf_set_ui (f, (unsigned long) UINT_MAX);\n  mpf_add_ui (f, f, 1L);\n  expr = \"UINT_MAX + 1\";\n  EXPECT (mpf_fits_uint_p, 0);\n\n\n  mpf_set_ui (f, ULONG_MAX);\n  expr = \"ULONG_MAX\";\n  EXPECT (mpf_fits_ulong_p, 1);\n\n  mpf_set_ui (f, ULONG_MAX);\n  mpf_add (f, f, f0p5);\n  expr = \"ULONG_MAX + 0.5\";\n  EXPECT (mpf_fits_ulong_p, 1);\n\n  mpf_set_ui (f, ULONG_MAX);\n  mpf_add_ui (f, f, 1L);\n  expr = \"ULONG_MAX + 1\";\n  EXPECT (mpf_fits_ulong_p, 0);\n\n\n  mpf_set_si (f, (long) SHRT_MAX);\n  expr = \"SHRT_MAX\";\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n  EXPECT (mpf_fits_sshort_p, 1);\n\n  mpf_set_si (f, (long) SHRT_MAX);\n  expr = \"SHRT_MAX + 0.5\";\n  mpf_add (f, f, f0p5);\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n  EXPECT (mpf_fits_sshort_p, 1);\n\n  mpf_set_si (f, (long) SHRT_MAX);\n  mpf_add_ui (f, f, 1L);\n  expr = \"SHRT_MAX + 1\";\n  EXPECT (mpf_fits_sshort_p, 0);\n\n\n  mpf_set_si (f, (long) INT_MAX);\n  expr = \"INT_MAX\";\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n\n  mpf_set_si (f, (long) INT_MAX);\n  mpf_add (f, f, f0p5);\n  expr = \"INT_MAX + 0.5\";\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n\n  mpf_set_si (f, (long) INT_MAX);\n  mpf_add_ui (f, f, 1L);\n  expr = \"INT_MAX + 1\";\n  EXPECT (mpf_fits_sint_p, 0);\n\n\n  mpf_set_si (f, LONG_MAX);\n  expr = \"LONG_MAX\";\n  EXPECT (mpf_fits_slong_p, 1);\n\n  mpf_set_si (f, LONG_MAX);\n  mpf_add (f, f, f0p5);\n  expr = \"LONG_MAX + 0.5\";\n  EXPECT (mpf_fits_slong_p, 1);\n\n  mpf_set_si (f, LONG_MAX);\n  mpf_add_ui (f, f, 1L);\n  expr = \"LONG_MAX + 1\";\n  EXPECT (mpf_fits_slong_p, 0);\n\n\n  mpf_set_si (f, (long) SHRT_MIN);\n  expr = \"SHRT_MIN\";\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n  EXPECT (mpf_fits_sshort_p, 1);\n\n  mpf_set_si (f, (long) SHRT_MIN);\n  mpf_sub (f, f, f0p5);\n  expr = \"SHRT_MIN - 0.5\";\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n  EXPECT (mpf_fits_sshort_p, 1);\n\n  mpf_set_si (f, (long) SHRT_MIN);\n  mpf_sub_ui (f, f, 1L);\n  expr = \"SHRT_MIN - 1\";\n  EXPECT (mpf_fits_sshort_p, 0);\n\n\n  mpf_set_si (f, (long) INT_MIN);\n  expr = \"INT_MIN\";\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n\n  mpf_set_si (f, (long) INT_MIN);\n  mpf_sub (f, f, f0p5);\n  expr = \"INT_MIN - 0.5\";\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n\n  mpf_set_si (f, (long) INT_MIN);\n  mpf_sub_ui (f, f, 1L);\n  expr = \"INT_MIN - 1\";\n  EXPECT (mpf_fits_sint_p, 0);\n\n\n  mpf_set_si (f, LONG_MIN);\n  expr = \"LONG_MIN\";\n  EXPECT (mpf_fits_slong_p, 1);\n\n  mpf_set_si (f, LONG_MIN);\n  mpf_sub (f, f, f0p5);\n  expr = \"LONG_MIN - 0.5\";\n  EXPECT (mpf_fits_slong_p, 1);\n\n  mpf_set_si (f, LONG_MIN);\n  mpf_sub_ui (f, f, 1L);\n  expr = \"LONG_MIN - 1\";\n  EXPECT (mpf_fits_slong_p, 0);\n\n\n  mpf_set_str_or_abort (f, \"0.5\", 10);\n  expr = \"0.5\";\n  EXPECT (mpf_fits_ulong_p, 1);\n  EXPECT (mpf_fits_uint_p, 1);\n  EXPECT (mpf_fits_ushort_p, 1);\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n  EXPECT (mpf_fits_sshort_p, 1);\n\n  mpf_set_str_or_abort (f, \"-0.5\", 10);\n  expr = \"-0.5\";\n  EXPECT (mpf_fits_ulong_p, 1);\n  EXPECT (mpf_fits_uint_p, 1);\n  EXPECT (mpf_fits_ushort_p, 1);\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n  EXPECT (mpf_fits_sshort_p, 1);\n\n  mpf_set_str_or_abort (f, \"-1.5\", 10);\n  expr = \"-1.5\";\n  EXPECT (mpf_fits_ulong_p, 0);\n  EXPECT (mpf_fits_uint_p, 0);\n  EXPECT (mpf_fits_ushort_p, 0);\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n  EXPECT (mpf_fits_sshort_p, 1);\n\n\n  mpf_set_str_or_abort (f, \"1.000000000000000000000000000000000001\", 16);\n  expr = \"1.000000000000000000000000000000000001 base 16\";\n  EXPECT (mpf_fits_ulong_p, 1);\n  EXPECT (mpf_fits_uint_p, 1);\n  EXPECT (mpf_fits_ushort_p, 1);\n  EXPECT (mpf_fits_slong_p, 1);\n  EXPECT (mpf_fits_sint_p, 1);\n  EXPECT (mpf_fits_sshort_p, 1);\n\n  mpf_set_str_or_abort (f, \"1@1000\", 16);\n  expr = \"1@1000 base 16\";\n  EXPECT (mpf_fits_ulong_p, 0);\n  EXPECT (mpf_fits_uint_p, 0);\n  EXPECT (mpf_fits_ushort_p, 0);\n  EXPECT (mpf_fits_slong_p, 0);\n  EXPECT (mpf_fits_sint_p, 0);\n  EXPECT (mpf_fits_sshort_p, 0);\n\n\n  mpf_set_ui (f, 1L);\n  mpf_mul_2exp (f, f, BITS_PER_ULONG + 1);\n  mpf_sub_ui (f, f, 1L);\n  expr = \"2^(BITS_PER_ULONG+1) - 1\";\n  EXPECT (mpf_fits_ulong_p, 0);\n  EXPECT (mpf_fits_uint_p, 0);\n  EXPECT (mpf_fits_ushort_p, 0);\n  EXPECT (mpf_fits_slong_p, 0);\n  EXPECT (mpf_fits_sint_p, 0);\n  EXPECT (mpf_fits_sshort_p, 0);\n\n  mpf_set_ui (f, 1L);\n  mpf_mul_2exp (f, f, BITS_PER_ULONG + 1);\n  mpf_ui_sub (f, 1L, f);\n  expr = \"- (2^(BITS_PER_ULONG+1) - 1)\";\n  EXPECT (mpf_fits_ulong_p, 0);\n  EXPECT (mpf_fits_uint_p, 0);\n  EXPECT (mpf_fits_ushort_p, 0);\n  EXPECT (mpf_fits_slong_p, 0);\n  EXPECT (mpf_fits_sint_p, 0);\n  EXPECT (mpf_fits_sshort_p, 0);\n\n  mpf_set_ui (f, 1L);\n  mpf_mul_2exp (f, f, BITS_PER_ULONG + 5);\n  mpf_sub_ui (f, f, 1L);\n  expr = \"2^(BITS_PER_ULONG+5) - 1\";\n  EXPECT (mpf_fits_ulong_p, 0);\n  EXPECT (mpf_fits_uint_p, 0);\n  EXPECT (mpf_fits_ushort_p, 0);\n  EXPECT (mpf_fits_slong_p, 0);\n  EXPECT (mpf_fits_sint_p, 0);\n  EXPECT (mpf_fits_sshort_p, 0);\n\n\n  if (error)\n    abort ();\n\n  mpf_clear (f);\n  mpf_clear (f0p5);\n  tests_end ();\n  exit (0);\n}",
      "lines": 286,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-get_d.c": {
    "test_denorms": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\ntest_denorms (int prc)\n{\n#ifdef _GMP_IEEE_FLOATS\n  double d1, d2;\n  mpf_t f;\n  int i;\n\n  mpf_set_default_prec (prc);\n\n  mpf_init (f);\n\n  d1 = 1.9;\n  for (i = 0; i < 820; i++)\n    {\n      mpf_set_d (f, d1);\n      d2 = mpf_get_d (f);\n      if (d1 != d2)\n        abort ();\n      d1 *= 0.4;\n    }\n\n  mpf_clear (f);\n#endif\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  double d, e, r;\n  mpf_t u, v;\n\n  tests_start ();\n  mpf_init (u);\n  mpf_init (v);\n\n  mpf_set_d (u, LOW_BOUND);\n  for (d = 2.0 * LOW_BOUND; d < HIGH_BOUND; d *= 1.01)\n    {\n      mpf_set_d (v, d);\n      if (mpf_cmp (u, v) >= 0)\n\tabort ();\n      e = mpf_get_d (v);\n      r = e/d;\n      if (r < 0.99999999999999 || r > 1.00000000000001)\n\t{\n\t  fprintf (stderr, \"should be one ulp from 1: %.16f\\n\", r);\n\t  abort ();\n\t}\n      mpf_set (u, v);\n    }\n\n  mpf_clear (u);\n  mpf_clear (v);\n\n  test_denorms (10);\n  test_denorms (32);\n  test_denorms (64);\n  test_denorms (100);\n  test_denorms (200);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-get_d_2exp.c": {
    "check_onebit": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static void\ncheck_onebit (void)\n{\n  static const long data[] = {\n    -513, -512, -511, -65, -64, -63, -32, -1,\n    0, 1, 32, 53, 54, 64, 128, 256, 511, 512, 513\n  };\n  mpf_t   f;\n  double  got, want;\n  long    got_exp, want_exp;\n  int     i;\n\n  mpf_init2 (f, 1024L);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpf_set_ui (f, 1L);\n      if (data[i] >= 0)\n        mpf_mul_2exp (f, f, data[i]);\n      else\n        mpf_div_2exp (f, f, -data[i]);\n      want = 0.5;\n      want_exp = data[i] + 1;\n\n      got = mpf_get_d_2exp (&got_exp, f);\n      if (got != want || got_exp != want_exp)\n        {\n          printf    (\"mpf_get_d_2exp wrong on 2**%ld\\n\", data[i]);\n          mpf_trace (\"   f    \", f);\n          d_trace   (\"   want \", want);\n          d_trace   (\"   got  \", got);\n          printf    (\"   want exp %ld\\n\", want_exp);\n          printf    (\"   got exp  %ld\\n\", got_exp);\n          abort();\n        }\n    }\n  mpf_clear (f);\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_round": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static void\ncheck_round (void)\n{\n  static const unsigned long data[] = { 1, 32, 53, 54, 64, 128, 256, 512 };\n  mpf_t   f;\n  double  got;\n  long    got_exp;\n  int     i, rnd_mode, old_rnd_mode;\n\n  mpf_init2 (f, 1024L);\n  old_rnd_mode = tests_hardware_getround ();\n\n  for (rnd_mode = 0; rnd_mode < 4; rnd_mode++)\n    {\n      tests_hardware_setround (rnd_mode);\n\n      for (i = 0; i < numberof (data); i++)\n        {\n          mpf_set_ui (f, 1L);\n          mpf_mul_2exp (f, f, data[i]);\n          mpf_sub_ui (f, f, 1L);\n\n          got = mpf_get_d_2exp (&got_exp, f);\n          if (got < 0.5 || got >= 1.0)\n            {\n              printf    (\"mpf_get_d_2exp bad on 2**%lu-1\\n\", data[i]);\n              printf    (\"result out of range, expect 0.5 <= got < 1.0\\n\");\n              printf    (\"   rnd_mode = %d\\n\", rnd_mode);\n              printf    (\"   data[i]  = %lu\\n\", data[i]);\n              mpf_trace (\"   f    \", f);\n              d_trace   (\"   got  \", got);\n              printf    (\"   got exp  %ld\\n\", got_exp);\n              abort();\n            }\n        }\n    }\n\n  mpf_clear (f);\n  tests_hardware_setround (old_rnd_mode);\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = 16;\n\n  check_onebit ();\n  check_round ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-get_si.c": {
    "check_data": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    int         base;\n    const char  *f;\n    long        want;\n  } data[] = {\n    { 10, \"0\",      0L },\n    { 10, \"1\",      1L },\n    { 10, \"-1\",     -1L },\n    { 10, \"2\",      2L },\n    { 10, \"-2\",     -2L },\n    { 10, \"12345\",  12345L },\n    { 10, \"-12345\", -12345L },\n\n    /* fraction bits ignored */\n    { 10, \"0.5\",    0L },\n    { 10, \"-0.5\",   0L },\n    { 10, \"1.1\",    1L },\n    { 10, \"-1.1\",   -1L },\n    { 10, \"1.9\",    1L },\n    { 10, \"-1.9\",   -1L },\n    { 16, \"1.000000000000000000000000000000000000000000000000001\", 1L },\n    { 16, \"-1.000000000000000000000000000000000000000000000000001\", -1L },\n\n    /* low bits extracted (this is undocumented) */\n    { 16, \"1000000000000000000000000000000000000000000000000001\", 1L },\n    { 16, \"-1000000000000000000000000000000000000000000000000001\", -1L },\n  };\n\n  int    i;\n  mpf_t  f;\n  long   got;\n\n  mpf_init2 (f, 2000L);\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpf_set_str_or_abort (f, data[i].f, data[i].base);\n\n      got = mpf_get_si (f);\n      if (got != data[i].want)\n\t{\n\t  printf (\"mpf_get_si wrong at data[%d]\\n\", i);\n\t  printf (\"   f     \\\"%s\\\"\\n\", data[i].f);\n\t  printf (\"     dec \"); mpf_out_str (stdout, 10, 0, f); printf (\"\\n\");\n\t  printf (\"     hex \"); mpf_out_str (stdout, 16, 0, f); printf (\"\\n\");\n\t  printf (\"     size %ld\\n\", (long) SIZ(f));\n\t  printf (\"     exp  %ld\\n\", (long) EXP(f));\n\t  printf (\"   got   %ld (0x%lX)\\n\", got, got);\n\t  printf (\"   want  %ld (0x%lX)\\n\", data[i].want, data[i].want);\n\t  abort();\n\t}\n    }\n  mpf_clear (f);\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_max": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\ncheck_max (void)\n{\n  mpf_t  f;\n  long   want;\n  long   got;\n\n  mpf_init2 (f, 200L);\n\n#define CHECK_MAX(name)                                         \\\n  if (got != want)                                              \\\n    {                                                           \\\n      printf (\"mpf_get_si wrong on %s\\n\", name);                \\\n      printf (\"   f    \");                                      \\\n      mpf_out_str (stdout, 10, 0, f); printf (\", hex \");        \\\n      mpf_out_str (stdout, 16, 0, f); printf (\"\\n\");            \\\n      printf (\"   got  %ld, hex %lX\\n\", got, got);              \\\n      printf (\"   want %ld, hex %lX\\n\", want, want);            \\\n      abort();                                                  \\\n    }\n\n  want = LONG_MAX;\n  mpf_set_si (f, want);\n  got = mpf_get_si (f);\n  CHECK_MAX (\"LONG_MAX\");\n\n  want = LONG_MIN;\n  mpf_set_si (f, want);\n  got = mpf_get_si (f);\n  CHECK_MAX (\"LONG_MIN\");\n\n  mpf_clear (f);\n}",
      "lines": 33,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "check_limbdata": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "void\ncheck_limbdata (void)\n{\n#define M  GMP_NUMB_MAX\n\n  static const struct {\n    mp_exp_t       exp;\n    mp_size_t      size;\n    mp_limb_t      d[10];\n    unsigned long  want;\n\n  } data[] = {\n\n    /* in the comments here, a \"_\" indicates a digit (ie. limb) position not\n       included in the d data, and therefore zero */\n\n    { 0, 0, { 0 }, 0L },    /* 0 */\n\n    { 1,  1, { 1 }, 1L },   /* 1 */\n    { 1, -1, { 1 }, -1UL },  /* -1 */\n\n    { 0,  1, { 1 }, 0L },   /* .1 */\n    { 0, -1, { 1 }, 0L },   /* -.1 */\n\n    { -1,  1, { 1 }, 0L },  /* ._1 */\n    { -1, -1, { 1 }, 0L },  /* -._1 */\n\n    { -999,          1, { 1 }, 0L },   /* .___1 small */\n    { MP_EXP_T_MIN,  1, { 1 }, 0L },   /* .____1 very small */\n\n    { 999,          1, { 1 }, 0L },    /* 1____. big */\n    { MP_EXP_T_MAX, 1, { 1 }, 0L },    /* 1_____. very big */\n\n    { 1, 2, { 999, 2 }, 2L },                  /* 2.9 */\n    { 5, 8, { 7, 8, 9, 3, 0, 0, 0, 1 }, 3L },  /* 10003.987 */\n\n    { 2, 2, { M, M },    LONG_MAX }, /* FF. */\n    { 2, 2, { M, M, M }, LONG_MAX }, /* FF.F */\n    { 3, 3, { M, M, M }, LONG_MAX }, /* FFF. */\n\n#if GMP_NUMB_BITS >= BITS_PER_ULONG\n    /* normal case, numb bigger than long */\n    { 2,  1, { 1 },    0L },      /* 1_. */\n    { 2,  2, { 0, 1 }, 0L },      /* 10. */\n    { 2,  2, { 999, 1 }, 999L },  /* 19. */\n    { 3,  2, { 999, 1 }, 0L },    /* 19_. */\n\n#else\n    /* nails case, numb smaller than long */\n    { 2,  1, { 1 }, 1L << GMP_NUMB_BITS },  /* 1_. */\n    { 3,  1, { 1 }, 0L },                   /* 1__. */\n\n    { 2,  2, { 99, 1 },    99L + (1L << GMP_NUMB_BITS) },  /* 19. */\n    { 3,  2, { 1, 99 },    1L << GMP_NUMB_BITS },          /* 91_. */\n    { 3,  3, { 0, 1, 99 }, 1L << GMP_NUMB_BITS },          /* 910. */\n\n#endif\n  };\n\n  mpf_t          f;\n  unsigned long  got;\n  int            i;\n  mp_limb_t      buf[20 + numberof(data[i].d)];\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      refmpn_fill (buf, 10, CNST_LIMB(0xDEADBEEF));\n      refmpn_copy (buf+10, data[i].d, ABS(data[i].size));\n      refmpn_fill (buf+10+ABS(data[i].size), 10, CNST_LIMB(0xDEADBEEF));\n\n      PTR(f) = buf+10;\n      EXP(f) = data[i].exp;\n      SIZ(f) = data[i].size;\n      PREC(f) = numberof (data[i].d);\n      MPF_CHECK_FORMAT (f);\n\n      got = mpf_get_si (f);\n      if (got != data[i].want)\n\t{\n\t  printf    (\"mpf_get_si wrong at limb data[%d]\\n\", i);\n\t  mpf_trace (\"  f\", f);\n\t  mpn_trace (\"  d\", data[i].d, data[i].size);\n\t  printf    (\"  size %ld\\n\", (long) data[i].size);\n\t  printf    (\"  exp %ld\\n\", (long) data[i].exp);\n\t  printf    (\"  got   %lu (0x%lX)\\n\", got, got);\n\t  printf    (\"  want  %lu (0x%lX)\\n\", data[i].want, data[i].want);\n\t  abort();\n\t}\n    }\n}",
      "lines": 90,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n  check_max ();\n  check_limbdata ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-get_ui.c": {
    "check_limbdata": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\ncheck_limbdata (void)\n{\n#define M  GMP_NUMB_MAX\n\n  static const struct {\n    mp_exp_t       exp;\n    mp_size_t      size;\n    mp_limb_t      d[10];\n    unsigned long  want;\n\n  } data[] = {\n\n    /* in the comments here, a \"_\" indicates a digit (ie. limb) position not\n       included in the d data, and therefore zero */\n\n    { 0, 0, { 0 }, 0L },    /* 0 */\n\n    { 1,  1, { 1 }, 1L },   /* 1 */\n    { 1, -1, { 1 }, 1L },   /* -1 */\n\n    { 0,  1, { 1 }, 0L },   /* .1 */\n    { 0, -1, { 1 }, 0L },   /* -.1 */\n\n    { -1,  1, { 1 }, 0L },  /* ._1 */\n    { -1, -1, { 1 }, 0L },  /* -._1 */\n\n    { -999,          1, { 1 }, 0L },   /* .___1 small */\n    { MP_EXP_T_MIN,  1, { 1 }, 0L },   /* .____1 very small */\n\n    { 999,          1, { 1 }, 0L },    /* 1____. big */\n    { MP_EXP_T_MAX, 1, { 1 }, 0L },    /* 1_____. very big */\n\n    { 1, 2, { 999, 2 }, 2L },                  /* 2.9 */\n    { 5, 8, { 7, 8, 9, 3, 0, 0, 0, 1 }, 3L },  /* 10003.987 */\n\n    { 2, 2, { M, M },    ULONG_MAX }, /* FF. */\n    { 2, 2, { M, M, M }, ULONG_MAX }, /* FF.F */\n    { 3, 3, { M, M, M }, ULONG_MAX }, /* FFF. */\n\n#if GMP_NUMB_BITS >= BITS_PER_ULONG\n    /* normal case, numb bigger than long */\n    { 2,  1, { 1 },    0L },      /* 1_. */\n    { 2,  2, { 0, 1 }, 0L },      /* 10. */\n    { 2,  2, { 999, 1 }, 999L },  /* 19. */\n    { 3,  2, { 999, 1 }, 0L },    /* 19_. */\n\n#else\n    /* nails case, numb smaller than long */\n    { 2,  1, { 1 }, 1L << GMP_NUMB_BITS },  /* 1_. */\n    { 3,  1, { 1 }, 0L },                   /* 1__. */\n\n    { 2,  2, { 99, 1 },    99L + (1L << GMP_NUMB_BITS) },  /* 19. */\n    { 3,  2, { 1, 99 },    1L << GMP_NUMB_BITS },          /* 91_. */\n    { 3,  3, { 0, 1, 99 }, 1L << GMP_NUMB_BITS },          /* 910. */\n\n#endif\n  };\n\n  mpf_t          f;\n  unsigned long  got;\n  int            i;\n  mp_limb_t      buf[20 + numberof(data[i].d)];\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      refmpn_fill (buf, 10, CNST_LIMB(0xDEADBEEF));\n      refmpn_copy (buf+10, data[i].d, ABS(data[i].size));\n      refmpn_fill (buf+10+ABS(data[i].size), 10, CNST_LIMB(0xDEADBEEF));\n\n      PTR(f) = buf+10;\n      EXP(f) = data[i].exp;\n      SIZ(f) = data[i].size;\n      PREC(f) = numberof (data[i].d);\n      MPF_CHECK_FORMAT (f);\n\n      got = mpf_get_ui (f);\n      if (got != data[i].want)\n\t{\n\t  printf    (\"mpf_get_ui wrong at limb data[%d]\\n\", i);\n\t  mpf_trace (\"  f\", f);\n\t  mpn_trace (\"  d\", data[i].d, data[i].size);\n\t  printf    (\"  size %ld\\n\", (long) data[i].size);\n\t  printf    (\"  exp %ld\\n\", (long) data[i].exp);\n\t  printf    (\"  got   %lu (0x%lX)\\n\", got, got);\n\t  printf    (\"  want  %lu (0x%lX)\\n\", data[i].want, data[i].want);\n\t  abort();\n\t}\n    }\n}",
      "lines": 90,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = 16;\n\n  check_limbdata ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-gsprec.c": {
    "check_consistency": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\ncheck_consistency (void)\n{\n  mpf_t  x;\n  unsigned long  i, a, b;\n\n  mpf_init (x);\n\n  for (i = 1; i < 2000; i++)\n    {\n      mpf_set_prec (x, i);\n      a = mpf_get_prec (x);\n      mpf_set_prec (x, a);\n      b = mpf_get_prec (x);\n      if (a != b)\n        {\n          printf (\"mpf_get_prec / mpf_set_prec inconsistent\\n\");\n          printf (\"   set %lu gives %lu, but then set %lu gives %lu\\n\",\n                  i, a,\n                  a, b);\n          abort ();\n        }\n    }\n\n  mpf_clear (x);\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_consistency ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-inp_str.c": {
    "check_data": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *inp;\n    int         base;\n    const char  *want;\n    int         want_nread;\n\n  } data[] = {\n\n    { \"0\",   10, \"0\", 1 },\n\n    { \"abc\", 10, \"0\", 0 },\n    { \"ghi\", 16, \"0\", 0 },\n\n    { \"125\",    10, \"125\",  3 },\n    { \"125e1\",  10, \"1250\", 5 },\n    { \"12e+2\",  10, \"1200\", 5 },\n    { \"125e-1\", 10, \"12.5\", 6 },\n\n    {  \"ff\", 16,  \"255\", 2 },\n    { \"-ff\", 16, \"-255\", 3 },\n    {  \"FF\", 16,  \"255\", 2 },\n    { \"-FF\", 16, \"-255\", 3 },\n\n    { \"100\",     16, \"256\",  3 },\n    { \"100@1\",   16, \"4096\", 5 },\n    { \"100@10\",  16, \"4722366482869645213696\", 6 },\n    { \"100@10\", -16, \"281474976710656\",        6 },\n    { \"100@-1\",  16, \"16\",   6 },\n    { \"10000000000000000@-10\",  16, \"1\", 21 },\n    { \"10000000000@-10\",       -16, \"1\", 15 },\n\n    { \"z\", 36, \"35\", 1 },\n    { \"Z\", 36, \"35\", 1 },\n    { \"z@1\", 36, \"1260\", 3 },\n    { \"Z@1\", 36, \"1260\", 3 },\n\n    {  \"0\",      0,   \"0\", 1 },\n  };\n\n  mpf_t  got, want;\n  long   ftell_nread;\n  int    i, pre, post, j, got_nread, want_nread;\n  FILE   *fp;\n\n  mpf_init (got);\n  mpf_init (want);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      for (pre = 0; pre <= 3; pre++)\n        {\n          for (post = 0; post <= 2; post++)\n            {\n              mpf_set_str_or_abort (want, data[i].want, 10);\n              MPF_CHECK_FORMAT (want);\n\n              /* create the file new each time to ensure its length is what\n                 we want */\n              fp = fopen (FILENAME, \"w+\");\n              ASSERT_ALWAYS (fp != NULL);\n              for (j = 0; j < pre; j++)\n                putc (' ', fp);\n              fputs (data[i].inp, fp);\n              for (j = 0; j < post; j++)\n                putc (' ', fp);\n              fflush (fp);\n              ASSERT_ALWAYS (! ferror(fp));\n\n              rewind (fp);\n              got_nread = mpf_inp_str (got, fp, data[i].base);\n\n              if (got_nread != 0)\n                {\n                  ftell_nread = ftell (fp);\n                  if (got_nread != ftell_nread)\n                    {\n                      printf (\"mpf_inp_str nread wrong\\n\");\n                      printf (\"  inp          \\\"%s\\\"\\n\", data[i].inp);\n                      printf (\"  base         %d\\n\", data[i].base);\n                      printf (\"  pre          %d\\n\", pre);\n                      printf (\"  post         %d\\n\", post);\n                      printf (\"  got_nread    %d\\n\", got_nread);\n                      printf (\"  ftell_nread  %ld\\n\", ftell_nread);\n                      abort ();\n                    }\n                }\n\n              /* if data[i].inp is a whole string to read and there's no post\n                 whitespace then expect to have EOF */\n              if (post == 0 && data[i].want_nread == strlen(data[i].inp))\n                {\n                  int  c = getc(fp);\n                  if (c != EOF)\n                    {\n                      printf (\"mpf_inp_str didn't read to EOF\\n\");\n                      printf (\"  inp   \\\"%s\\\"\\n\", data[i].inp);\n                      printf (\"  base  %d\\n\", data[i].base);\n                      printf (\"  pre   %d\\n\", pre);\n                      printf (\"  post  %d\\n\", post);\n                      printf (\"  c     '%c' %#x\\n\", c, c);\n                      abort ();\n                    }\n                }\n\n              /* only expect \"pre\" included in the count when non-zero */\n              want_nread = data[i].want_nread;\n              if (want_nread != 0)\n                want_nread += pre;\n\n              if (got_nread != want_nread)\n                {\n                  printf (\"mpf_inp_str nread wrong\\n\");\n                  printf (\"  inp         \\\"%s\\\"\\n\", data[i].inp);\n                  printf (\"  base        %d\\n\", data[i].base);\n                  printf (\"  pre         %d\\n\", pre);\n                  printf (\"  post        %d\\n\", post);\n                  printf (\"  got_nread   %d\\n\", got_nread);\n                  printf (\"  want_nread  %d\\n\", want_nread);\n                  abort ();\n                }\n\n              MPF_CHECK_FORMAT (got);\n\n              if (mpf_cmp (got, want) != 0)\n                {\n                  printf (\"mpf_inp_str wrong result\\n\");\n                  printf (\"  inp   \\\"%s\\\"\\n\", data[i].inp);\n                  printf (\"  base  %d\\n\", data[i].base);\n                  mpf_trace (\"  got \",  got);\n                  mpf_trace (\"  want\", want);\n                  abort ();\n                }\n\n              ASSERT_ALWAYS (fclose (fp) == 0);\n            }\n        }\n    }\n\n  mpf_clear (got);\n  mpf_clear (want);\n}",
      "lines": 144,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n\n  unlink (FILENAME);\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-int_p.c": {
    "one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\none (mpf_srcptr f, int want)\n{\n  int  got;\n  got = mpf_integer_p (f);\n  if (got != want)\n    {\n      printf (\"mpf_integer_p got %d want %d\\n\", got, want);\n      mpf_trace (\" f\", f);\n      abort ();\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "all": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\nall (mpf_ptr f, int want)\n{\n  one (f, want);\n  mpf_neg (f, f);\n  one (f, want);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nmain (void)\n{\n  mpf_t  f;\n\n  tests_start ();\n  mpf_init2 (f, 200L);\n\n  mpf_set_ui (f, 0L);\n  one (f, 1);\n\n  mpf_set_ui (f, 1L);\n  all (f, 1);\n\n  mpf_set_ui (f, 1L);\n  mpf_div_2exp (f, f, 1L);\n  all (f, 0);\n\n  mpf_set_ui (f, 1L);\n  mpf_div_2exp (f, f, 5000L);\n  all (f, 0);\n\n  mpf_set_ui (f, 1L);\n  mpf_mul_2exp (f, f, 5000L);\n  all (f, 1);\n\n  mpf_set_str (f, \"0.5\", 10);\n  all (f, 0);\n\n  mpf_set_str (f, \"2.5\", 10);\n  all (f, 0);\n\n  mpf_set_ui (f, 1L);\n  mpf_div_ui (f, f, 3L);\n  all (f, 0);\n\n  mpf_set_ui (f, 7L);\n  mpf_div_ui (f, f, 3L);\n  all (f, 0);\n\n  mpf_clear (f);\n  tests_end ();\n  exit (0);\n}",
      "lines": 44,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-muldiv.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_size_t size;\n  mp_exp_t exp;\n  int reps = 10000;\n  int i;\n  mpf_t u, v, w, x;\n  mp_size_t bprec = SIZE * GMP_LIMB_BITS;\n  mpf_t rerr, limit_rerr;\n  unsigned long ulimb, vlimb;\n  int single_flag;\n\n  tests_start ();\n\n  if (argc > 1)\n    {\n      reps = strtol (argv[1], 0, 0);\n      if (argc > 2)\n\tbprec = strtol (argv[2], 0, 0);\n    }\n\n  mpf_set_default_prec (bprec);\n\n  mpf_init (rerr);\n  mpf_init (limit_rerr);\n\n  mpf_init (u);\n  mpf_init (v);\n  mpf_init (w);\n  mpf_init (x);\n\n  for (i = 0; i < reps; i++)\n    {\n      mp_size_t res_prec;\n\n      res_prec = urandom () % bprec + 1;\n      mpf_set_prec (w, res_prec);\n      mpf_set_prec (x, res_prec);\n\n      mpf_set_ui (limit_rerr, 1);\n      mpf_div_2exp (limit_rerr, limit_rerr, res_prec - 1);\n\n      single_flag = 0;\n\n      if ((urandom () & 1) != 0)\n\t{\n\t  size = urandom () % (2 * SIZE) - SIZE;\n\t  exp = urandom () % SIZE;\n\t  mpf_random2 (u, size, exp);\n\t}\n      else\n\t{\n\t  ulimb = urandom ();\n\t  mpf_set_ui (u, ulimb);\n\t  single_flag = 1;\n\t}\n\n      if ((urandom () & 1) != 0)\n\t{\n\t  size = urandom () % (2 * SIZE) - SIZE;\n\t  exp = urandom () % SIZE;\n\t  mpf_random2 (v, size, exp);\n\t}\n      else\n\t{\n\t  vlimb = urandom ();\n\t  mpf_set_ui (v, vlimb);\n\t  single_flag = 2;\n\t}\n\n      if (mpf_sgn (v) == 0)\n\tcontinue;\n\n      mpf_div (w, u, v);\n      mpf_mul (x, w, v);\n      mpf_reldiff (rerr, u, x);\n      if (mpf_cmp (rerr, limit_rerr) > 0)\n\t{\n\t  printf (\"ERROR in mpf_mul or mpf_div after %d tests\\n\", i);\n\t  printf (\"   u = \"); mpf_dump (u);\n\t  printf (\"   v = \"); mpf_dump (v);\n\t  printf (\"   x = \"); mpf_dump (x);\n\t  printf (\"   w = \"); mpf_dump (w);\n\t  abort ();\n\t}\n\n      if (single_flag == 2)\n\t{\n\t  mpf_div_ui (x, u, vlimb);\n\t  mpf_reldiff (rerr, w, x);\n\t  if (mpf_cmp (rerr, limit_rerr) > 0)\n\t    {\n\t      printf (\"ERROR in mpf_div or mpf_div_ui after %d tests\\n\", i);\n\t      printf (\"   u = \"); mpf_dump (u);\n\t      printf (\"   v = \"); mpf_dump (v);\n\t      printf (\"   x = \"); mpf_dump (x);\n\t      printf (\"   w = \"); mpf_dump (w);\n\t      abort ();\n\t    }\n\t}\n\n      if (single_flag == 1)\n\t{\n\t  mpf_ui_div (x, ulimb, v);\n\t  mpf_reldiff (rerr, w, x);\n\t  if (mpf_cmp (rerr, limit_rerr) > 0)\n\t    {\n\t      printf (\"ERROR in mpf_div or mpf_ui_div after %d tests\\n\", i);\n\t      printf (\"   u = \"); mpf_dump (u);\n\t      printf (\"   v = \"); mpf_dump (v);\n\t      printf (\"   x = \"); mpf_dump (x);\n\t      printf (\"   w = \"); mpf_dump (w);\n\t      abort ();\n\t    }\n\t}\n    }\n\n  mpf_clear (rerr);\n  mpf_clear (limit_rerr);\n\n  mpf_clear (u);\n  mpf_clear (v);\n  mpf_clear (w);\n  mpf_clear (x);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 129,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-mul_ui.c": {
    "check_one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\ncheck_one (const char *desc, mpf_ptr got, mpf_srcptr u, unsigned long v)\n{\n  mp_size_t  usize, usign;\n  mp_ptr     wp;\n  mpf_t      want;\n\n  MPF_CHECK_FORMAT (got);\n\n  /* this code not nailified yet */\n  ASSERT_ALWAYS (BITS_PER_ULONG <= GMP_NUMB_BITS);\n  usign = SIZ (u);\n  usize = ABS (usign);\n  wp = refmpn_malloc_limbs (usize + 1);\n  wp[usize] = mpn_mul_1 (wp, PTR(u), usize, (mp_limb_t) v);\n\n  PTR(want) = wp;\n  SIZ(want) = (usign >= 0 ? usize+1 : -(usize+1));\n  EXP(want) = EXP(u) + 1;\n  refmpf_normalize (want);\n\n  if (! refmpf_validate (\"mpf_mul_ui\", got, want))\n    {\n      mp_trace_base = -16;\n      printf    (\"  %s\\n\", desc);\n      mpf_trace (\"  u\", u);\n      printf    (\"  v %ld  0x%lX\\n\", v, v);\n      abort ();\n    }\n\n  free (wp);\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_rand": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void\ncheck_rand (void)\n{\n  unsigned long  min_prec = __GMPF_BITS_TO_PREC (1);\n  gmp_randstate_ptr  rands = RANDS;\n  mpf_t              got, u;\n  unsigned long      prec, v;\n  int                i;\n\n  /* The nails code in mpf_mul_ui currently isn't exact, so suppress these\n     tests for now.  */\n  if (BITS_PER_ULONG > GMP_NUMB_BITS)\n    return;\n\n  mpf_init (got);\n  mpf_init (u);\n\n  for (i = 0; i < 200; i++)\n    {\n      /* got precision */\n      prec = min_prec + gmp_urandomm_ui (rands, 15L);\n      refmpf_set_prec_limbs (got, prec);\n\n      /* u precision */\n      prec = min_prec + gmp_urandomm_ui (rands, 15L);\n      refmpf_set_prec_limbs (u, prec);\n\n      /* u, possibly negative */\n      mpf_random2 (u, PREC(u), (mp_exp_t) 20);\n      if (gmp_urandomb_ui (rands, 1L))\n        mpf_neg (u, u);\n\n      /* v, 0 to BITS_PER_ULONG bits (inclusive) */\n      prec = gmp_urandomm_ui (rands, BITS_PER_ULONG+1);\n      v = gmp_urandomb_ui (rands, prec);\n\n      if ((i % 2) == 0)\n        {\n          /* separate */\n          mpf_mul_ui (got, u, v);\n          check_one (\"separate\", got, u, v);\n        }\n      else\n        {\n          /* overlap */\n          prec = refmpf_set_overlap (got, u);\n          mpf_mul_ui (got, got, v);\n          check_one (\"overlap src==dst\", got, u, v);\n\n          mpf_set_prec_raw (got, prec);\n        }\n    }\n\n  mpf_clear (got);\n  mpf_clear (u);\n}",
      "lines": 56,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  mpf_t  u, got, want;\n  const char   *s;\n\n  mpf_init2 (u,    2*8*sizeof(long));\n  mpf_init2 (got,  2*8*sizeof(long));\n  mpf_init2 (want, 2*8*sizeof(long));\n\n  s = \"0 * ULONG_MAX\";\n  mpf_set_ui (u, 0L);\n  mpf_mul_ui (got, u, ULONG_MAX);\n  MPF_CHECK_FORMAT (got);\n  mpf_set_ui (want, 0L);\n  if (mpf_cmp (got, want) != 0)\n    {\n    error:\n      printf (\"Wrong result from %s\\n\", s);\n      mpf_trace (\"u   \", u);\n      mpf_trace (\"got \", got);\n      mpf_trace (\"want\", want);\n      abort ();\n    }\n\n  s = \"1 * ULONG_MAX\";\n  mpf_set_ui (u, 1L);\n  mpf_mul_ui (got, u, ULONG_MAX);\n  MPF_CHECK_FORMAT (got);\n  mpf_set_ui (want, ULONG_MAX);\n  if (mpf_cmp (got, want) != 0)\n    goto error;\n\n  mpf_clear (u);\n  mpf_clear (got);\n  mpf_clear (want);\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_various ();\n  check_rand ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-pow_ui.c": {
    "check_data": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  unsigned int b, e;\n  mpf_t b1, r, r2, limit;\n\n  mpf_inits (b1, r, r2, NULL);\n  mpf_init_set_ui (limit, 1);\n  mpf_mul_2exp (limit, limit, MAX (GMP_NUMB_BITS, 53)); \n\n  /* This test just test integers with results that fit in a single\n     limb or 53 bits.  This avoids any rounding.  */\n\n  for (b = 0; b <= 400; b++)\n    {\n      mpf_set_ui (b1, b);\n      mpf_set_ui (r2, 1);\n      for (e = 0; e <= GMP_LIMB_BITS; e++)\n\t{\n\t  mpf_pow_ui (r, b1, e);\n\n\t  if (mpf_cmp (r, r2))\n\t    abort ();\n\n\t  mpf_mul_ui (r2, r2, b);\n\n\t  if (mpf_cmp (r2, limit) >= 0)\n\t    break;\n\t}\n    }\n\n  mpf_clears (b1, r, r2, limit, NULL);\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  tests_start ();\n\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-set.c": {
    "check_reuse": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\ncheck_reuse (void)\n{\n  /* Try mpf_set(f,f) when f is bigger than prec.  In the past this had\n     resulted in an MPN_COPY with invalid operand overlap. */\n  mpf_t  f;\n  mp_size_t      limbs = 20;\n  unsigned long  bits = limbs * GMP_NUMB_BITS;\n  mpf_init2 (f, bits);\n  refmpf_fill (f, limbs, GMP_NUMB_MAX);\n  mpf_set_prec_raw (f, bits / 2);\n  mpf_set (f, f);\n  MPF_CHECK_FORMAT (f);\n  mpf_set_prec_raw (f, bits);\n  mpf_clear (f);\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\ncheck_random (long reps)\n{\n  unsigned long test;\n  gmp_randstate_ptr rands;\n  mpf_t a, b;\n  mpz_t z;\n  int precbits;\n\n#define PRECBITS 10\n\n  rands = RANDS;\n\n  mpz_init (z);\n  mpf_init2 (a, 1 << PRECBITS);\n\n  for (test = 0; test < reps; test++)\n    {\n      mpz_urandomb (z, rands, PRECBITS + 1);\n      precbits = mpz_get_ui (z) + 1;\n      mpz_urandomb (z, rands, precbits);\n      mpz_setbit (z, precbits  - 1);\t/* make sure msb is set */\n      mpf_set_z (a, z);\n      if (precbits & 1)\n\tmpf_neg (a, a);\n      mpz_urandomb (z, rands, PRECBITS);\n      mpf_div_2exp (a, a, mpz_get_ui (z) + 1);\n      mpz_urandomb (z, rands, PRECBITS);\n      precbits -= mpz_get_ui (z);\n      if (precbits <= 0)\n\tprecbits = 1 - precbits;\n      mpf_set_default_prec (precbits);\n\n      mpf_init_set (b, a);\n      MPF_CHECK_FORMAT (b);\n      if (!mpf_eq (a, b, precbits))\n\t{\n\t  printf (\"mpf_init_set wrong.\\n\");\n\t  abort();\n\t}\n\n      mpf_set_ui (b, 0);\n      mpf_set (b, a);\n      MPF_CHECK_FORMAT (b);\n      if (!mpf_eq (a, b, precbits))\n\t{\n\t  printf (\"mpf_set wrong.\\n\");\n\t  abort();\n\t}\n\n      mpf_clear (b);\n    }\n\n  mpf_clear (a);\n  mpz_clear (z);\n}",
      "lines": 56,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  long reps = 10000;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  check_reuse ();\n  check_random (reps);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-set_q.c": {
    "check_one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\ncheck_one (mpf_ptr got, mpq_srcptr q)\n{\n  mpf_t  n, d;\n\n  mpf_set_q (got, q);\n\n  PTR(n) = PTR(&q->_mp_num);\n  SIZ(n) = SIZ(&q->_mp_num);\n  EXP(n) = ABSIZ(&q->_mp_num);\n\n  PTR(d) = PTR(&q->_mp_den);\n  SIZ(d) = SIZ(&q->_mp_den);\n  EXP(d) = ABSIZ(&q->_mp_den);\n\n  if (! refmpf_validate_division (\"mpf_set_q\", got, n, d))\n    {\n      mp_trace_base = -16;\n      mpq_trace (\"   q\", q);\n      abort ();\n    }\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_rand": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "void\ncheck_rand (void)\n{\n  unsigned long  min_prec = __GMPF_BITS_TO_PREC (1);\n  gmp_randstate_ptr  rands = RANDS;\n  unsigned long  prec;\n  mpf_t  got;\n  mpq_t  q;\n  int    i;\n\n  mpf_init (got);\n  mpq_init (q);\n\n  for (i = 0; i < 400; i++)\n    {\n      /* result precision */\n      prec = min_prec + gmp_urandomm_ui (rands, 20L);\n      refmpf_set_prec_limbs (got, prec);\n\n      /* num */\n      prec = gmp_urandomm_ui (rands, 20L * GMP_NUMB_BITS);\n      mpz_rrandomb (mpq_numref(q), rands, prec);\n\n      /* possibly negative num */\n      if (gmp_urandomb_ui (rands, 1L))\n        mpz_neg (mpq_numref(q), mpq_numref(q));\n\n      /* den, non-zero */\n      do {\n        prec = gmp_urandomm_ui (rands, 20L * GMP_NUMB_BITS);\n        mpz_rrandomb (mpq_denref(q), rands, prec);\n      } while (mpz_sgn (mpq_denref(q)) <= 0);\n\n      check_one (got, q);\n    }\n\n  mpf_clear (got);\n  mpq_clear (q);\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  mpf_t got;\n  mpq_t q;\n\n  mpf_init (got);\n  mpq_init (q);\n\n  /* 1/1 == 1 */\n  mpf_set_prec (got, 20L);\n  mpq_set_ui (q, 1L, 1L);\n  mpf_set_q (got, q);\n  MPF_CHECK_FORMAT (got);\n  ASSERT_ALWAYS (mpf_cmp_ui (got, 1L) == 0);\n\n  /* 1/(2^n+1), a case where truncating the divisor would be wrong */\n  mpf_set_prec (got, 500L);\n  mpq_set_ui (q, 1L, 1L);\n  mpz_mul_2exp (mpq_denref(q), mpq_denref(q), 800L);\n  mpz_add_ui (mpq_denref(q), mpq_denref(q), 1L);\n  check_one (got, q);\n\n  mpf_clear (got);\n  mpq_clear (q);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_various ();\n  check_rand ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-set_si.c": {
    "check_data": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    long       x;\n    mp_size_t  want_size;\n    mp_limb_t  want_data[2];\n  } data[] = {\n\n    {  0L,  0 },\n    {  1L,  1, { 1 } },\n    { -1L, -1, { 1 } },\n\n#if GMP_NUMB_BITS >= BITS_PER_ULONG\n    { LONG_MAX,  1, { LONG_MAX, 0 } },\n    { -LONG_MAX,  -1, { LONG_MAX, 0 } },\n    { LONG_HIGHBIT,  -1, { ULONG_HIGHBIT, 0 } },\n#else\n    { LONG_MAX,  2, { LONG_MAX & GMP_NUMB_MASK, LONG_MAX >> GMP_NUMB_BITS } },\n    { -LONG_MAX,  -2, { LONG_MAX & GMP_NUMB_MASK, LONG_MAX >> GMP_NUMB_BITS }},\n    { LONG_HIGHBIT,  -2, { 0, ULONG_HIGHBIT >> GMP_NUMB_BITS } },\n#endif\n  };\n\n  mpf_t  x;\n  int    i;\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpf_init (x);\n      mpf_set_si (x, data[i].x);\n      MPF_CHECK_FORMAT (x);\n      if (x->_mp_size != data[i].want_size\n          || refmpn_cmp_allowzero (x->_mp_d, data[i].want_data,\n                                   ABS (data[i].want_size)) != 0\n          || x->_mp_exp != ABS (data[i].want_size))\n        {\n          printf (\"mpf_set_si wrong on data[%d]\\n\", i);\n          abort();\n        }\n      mpf_clear (x);\n\n      mpf_init_set_si (x, data[i].x);\n      MPF_CHECK_FORMAT (x);\n      if (x->_mp_size != data[i].want_size\n          || refmpn_cmp_allowzero (x->_mp_d, data[i].want_data,\n                                   ABS (data[i].want_size)) != 0\n          || x->_mp_exp != ABS (data[i].want_size))\n        {\n          printf (\"mpf_init_set_si wrong on data[%d]\\n\", i);\n          abort();\n        }\n      mpf_clear (x);\n    }\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-set_ui.c": {
    "check_data": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    unsigned long  x;\n    mp_size_t      want_size;\n    mp_limb_t      want_data[2];\n  } data[] = {\n\n    {  0L,  0 },\n    {  1L,  1, { 1 } },\n\n#if GMP_NUMB_BITS >= BITS_PER_ULONG\n    { ULONG_MAX,     1, { ULONG_MAX, 0 } },\n    { ULONG_HIGHBIT, 1, { ULONG_HIGHBIT, 0 } },\n#else\n    { ULONG_MAX,     2, { ULONG_MAX & GMP_NUMB_MASK,\n                          ULONG_MAX >> GMP_NUMB_BITS } },\n    { ULONG_HIGHBIT, 2, { 0,\n                          ULONG_HIGHBIT >> GMP_NUMB_BITS } },\n#endif\n  };\n\n  mpf_t  x;\n  int    i;\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpf_init (x);\n      mpf_set_ui (x, data[i].x);\n      MPF_CHECK_FORMAT (x);\n      if (x->_mp_size != data[i].want_size\n          || refmpn_cmp_allowzero (x->_mp_d, data[i].want_data,\n                                   ABS (data[i].want_size)) != 0\n          || x->_mp_exp != ABS (data[i].want_size))\n        {\n          printf (\"mpf_set_ui wrong on data[%d]\\n\", i);\n          abort();\n        }\n      mpf_clear (x);\n\n      mpf_init_set_ui (x, data[i].x);\n      MPF_CHECK_FORMAT (x);\n      if (x->_mp_size != data[i].want_size\n          || refmpn_cmp_allowzero (x->_mp_d, data[i].want_data,\n                                   ABS (data[i].want_size)) != 0\n          || x->_mp_exp != ABS (data[i].want_size))\n        {\n          printf (\"mpf_init_set_ui wrong on data[%d]\\n\", i);\n          abort();\n        }\n      mpf_clear (x);\n    }\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-sqrt.c": {
    "check_rand1": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void\ncheck_rand1 (int argc, char **argv)\n{\n  mp_size_t size;\n  mp_exp_t exp;\n  int reps = 20000;\n  int i;\n  mpf_t x, y, y2;\n  mp_size_t bprec = 100;\n  mpf_t rerr, max_rerr, limit_rerr;\n\n  if (argc > 1)\n    {\n      reps = strtol (argv[1], 0, 0);\n      if (argc > 2)\n\tbprec = strtol (argv[2], 0, 0);\n    }\n\n  mpf_set_default_prec (bprec);\n\n  mpf_init_set_ui (limit_rerr, 1);\n  mpf_div_2exp (limit_rerr, limit_rerr, bprec);\n#if VERBOSE\n  mpf_dump (limit_rerr);\n#endif\n  mpf_init (rerr);\n  mpf_init_set_ui (max_rerr, 0);\n\n  mpf_init (x);\n  mpf_init (y);\n  mpf_init (y2);\n  for (i = 0; i < reps; i++)\n    {\n      size = urandom () % SIZE;\n      exp = urandom () % SIZE;\n      mpf_random2 (x, size, exp);\n\n      mpf_sqrt (y, x);\n      MPF_CHECK_FORMAT (y);\n      mpf_mul (y2, y, y);\n\n      mpf_reldiff (rerr, x, y2);\n      if (mpf_cmp (rerr, max_rerr) > 0)\n\t{\n\t  mpf_set (max_rerr, rerr);\n#if VERBOSE\n\t  mpf_dump (max_rerr);\n#endif\n\t  if (mpf_cmp (rerr, limit_rerr) > 0)\n\t    {\n\t      printf (\"ERROR after %d tests\\n\", i);\n\t      printf (\"   x = \"); mpf_dump (x);\n\t      printf (\"   y = \"); mpf_dump (y);\n\t      printf (\"  y2 = \"); mpf_dump (y2);\n\t      printf (\"   rerr       = \"); mpf_dump (rerr);\n\t      printf (\"   limit_rerr = \"); mpf_dump (limit_rerr);\n              printf (\"in hex:\\n\");\n              mp_trace_base = 16;\n\t      mpf_trace (\"   x  \", x);\n\t      mpf_trace (\"   y  \", y);\n\t      mpf_trace (\"   y2 \", y2);\n\t      mpf_trace (\"   rerr      \", rerr);\n\t      mpf_trace (\"   limit_rerr\", limit_rerr);\n\t      abort ();\n\t    }\n\t}\n    }\n\n  mpf_clear (limit_rerr);\n  mpf_clear (rerr);\n  mpf_clear (max_rerr);\n\n  mpf_clear (x);\n  mpf_clear (y);\n  mpf_clear (y2);\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_rand2": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "void\ncheck_rand2 (void)\n{\n  unsigned long      max_prec = 20;\n  unsigned long      min_prec = __GMPF_BITS_TO_PREC (1);\n  gmp_randstate_ptr  rands = RANDS;\n  unsigned long      x_prec, r_prec;\n  mpf_t              x, r, s;\n  int                i;\n\n  mpf_init (x);\n  mpf_init (r);\n  mpf_init (s);\n  refmpf_set_prec_limbs (s, 2*max_prec+10);\n\n  for (i = 0; i < 500; i++)\n    {\n      /* input precision */\n      x_prec = gmp_urandomm_ui (rands, max_prec-min_prec) + min_prec;\n      refmpf_set_prec_limbs (x, x_prec);\n\n      /* result precision */\n      r_prec = gmp_urandomm_ui (rands, max_prec-min_prec) + min_prec;\n      refmpf_set_prec_limbs (r, r_prec);\n\n      mpf_random2 (x, x_prec, 1000);\n\n      mpf_sqrt (r, x);\n      MPF_CHECK_FORMAT (r);\n\n      /* Expect to prec limbs of result.\n         In the current implementation there's no stripping of low zero\n         limbs in mpf_sqrt, so size should be exactly prec.  */\n      if (SIZ(r) != r_prec)\n        {\n          printf (\"mpf_sqrt wrong number of result limbs\\n\");\n          mpf_trace (\"  x\", x);\n          mpf_trace (\"  r\", r);\n          printf    (\"  r_prec=%lu\\n\", r_prec);\n          printf    (\"  SIZ(r)  %ld\\n\", (long) SIZ(r));\n          printf    (\"  PREC(r) %ld\\n\", (long) PREC(r));\n          abort ();\n        }\n\n      /* Must have r^2 <= x, since r has been truncated. */\n      mpf_mul (s, r, r);\n      if (! (mpf_cmp (s, x) <= 0))\n        {\n          printf    (\"mpf_sqrt result too big\\n\");\n          mpf_trace (\"  x\", x);\n          printf    (\"  r_prec=%lu\\n\", r_prec);\n          mpf_trace (\"  r\", r);\n          mpf_trace (\"  s\", s);\n          abort ();\n        }\n\n      /* Must have (r+ulp)^2 > x, or else r is too small. */\n      refmpf_add_ulp (r);\n      mpf_mul (s, r, r);\n      if (! (mpf_cmp (s, x) > 0))\n        {\n          printf    (\"mpf_sqrt result too small\\n\");\n          mpf_trace (\"  x\", x);\n          printf    (\"  r_prec=%lu\\n\", r_prec);\n          mpf_trace (\"  r+ulp\", r);\n          mpf_trace (\"  s\", s);\n          abort ();\n        }\n    }\n\n  mpf_clear (x);\n  mpf_clear (r);\n  mpf_clear (s);\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_rand1 (argc, argv);\n  check_rand2 ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-sqrt_ui.c": {
    "check_rand": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\ncheck_rand (void)\n{\n  unsigned long      max_prec = 15;\n  unsigned long      min_prec = __GMPF_BITS_TO_PREC (1);\n  gmp_randstate_ptr  rands = RANDS;\n  unsigned long      x, prec;\n  mpf_t              r, s;\n  int                i;\n\n  mpf_init (r);\n  mpf_init (s);\n  refmpf_set_prec_limbs (s, 2*max_prec+10);\n\n  for (x = 0; x < 2; x++)\n    {\n      mpf_sqrt_ui (r, x);\n      MPF_CHECK_FORMAT (r);\n      if (mpf_cmp_ui (r, x) != 0)\n\t{\n\t  printf    (\"mpf_sqrt_ui wrong for special case:\\n\");\n          printf    (\"  x=%lu\\n\", x);\n          mpf_trace (\"  r\", r);\n\t  abort ();\n\t}\n    }\n\n  for (i = 0; i < 50; i++)\n    {\n      /* input, a random non-zero ulong, exponentially distributed */\n      do {\n        x = gmp_urandomb_ui (rands,\n                             gmp_urandomm_ui (rands, BITS_PER_ULONG) + 1);\n      } while (x <= 1);\n\n      /* result precision */\n      prec = gmp_urandomm_ui (rands, max_prec-min_prec) + min_prec;\n      refmpf_set_prec_limbs (r, prec);\n\n      mpf_sqrt_ui (r, x);\n      MPF_CHECK_FORMAT (r);\n\n      /* Expect to prec limbs of result.\n         In the current implementation there's no stripping of low zero\n         limbs in mpf_sqrt_ui, not even on perfect squares, so size should\n         be exactly prec.  */\n      if (SIZ(r) != prec)\n        {\n          printf (\"mpf_sqrt_ui result not enough result limbs\\n\");\n          printf    (\"  x=%lu\\n\", x);\n          printf    (\"  want prec=%lu\\n\", prec);\n          mpf_trace (\"  r\", r);\n          printf    (\"  r size %ld\\n\", (long) SIZ(r));\n          printf    (\"  r prec %ld\\n\", (long) PREC(r));\n          abort ();\n        }\n\n      /* Must have r^2 <= x, since r has been truncated. */\n      mpf_mul (s, r, r);\n      if (! (mpf_cmp_ui (s, x) <= 0))\n        {\n          printf    (\"mpf_sqrt_ui result too big\\n\");\n          printf    (\"  x=%lu\\n\", x);\n          printf    (\"  want prec=%lu\\n\", prec);\n          mpf_trace (\"  r\", r);\n          mpf_trace (\"  s\", s);\n          abort ();\n        }\n\n      /* Must have (r+ulp)^2 > x.\n         No overflow from refmpf_add_ulp since r is only prec limbs. */\n      refmpf_add_ulp (r);\n      mpf_mul (s, r, r);\n      if (! (mpf_cmp_ui (s, x) > 0))\n        {\n          printf    (\"mpf_sqrt_ui result too small\\n\");\n          printf    (\"  x=%lu\\n\", x);\n          printf    (\"  want prec=%lu\\n\", prec);\n          mpf_trace (\"  r+ulp\", r);\n          mpf_trace (\"  s\", s);\n          abort ();\n        }\n    }\n\n  mpf_clear (r);\n  mpf_clear (s);\n}",
      "lines": 87,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_rand ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-sub.c": {
    "check_rand": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void\ncheck_rand (int argc, char **argv)\n{\n  mp_size_t size;\n  mp_exp_t exp;\n  int reps = 20000;\n  int i;\n  mpf_t u, v, w, wref;\n  mp_size_t bprec = 100;\n  mpf_t rerr, max_rerr, limit_rerr;\n\n  if (argc > 1)\n    {\n      reps = strtol (argv[1], 0, 0);\n      if (argc > 2)\n\tbprec = strtol (argv[2], 0, 0);\n    }\n\n  mpf_set_default_prec (bprec);\n\n  mpf_init_set_ui (limit_rerr, 1);\n  mpf_div_2exp (limit_rerr, limit_rerr, bprec);\n#if VERBOSE\n  mpf_dump (limit_rerr);\n#endif\n  mpf_init (rerr);\n  mpf_init_set_ui (max_rerr, 0);\n\n  mpf_init (u);\n  mpf_init (v);\n  mpf_init (w);\n  mpf_init (wref);\n  for (i = 0; i < reps; i++)\n    {\n      size = urandom () % (2 * SIZE) - SIZE;\n      exp = urandom () % SIZE;\n      mpf_random2 (u, size, exp);\n\n      size = urandom () % (2 * SIZE) - SIZE;\n      exp = urandom () % SIZE;\n      mpf_random2 (v, size, exp);\n\n      if ((urandom () & 1) != 0)\n\tmpf_add_ui (u, v, 1);\n      else if ((urandom () & 1) != 0)\n\tmpf_sub_ui (u, v, 1);\n\n      mpf_sub (w, u, v);\n      refmpf_sub (wref, u, v);\n\n      mpf_reldiff (rerr, w, wref);\n      if (mpf_cmp (rerr, max_rerr) > 0)\n\t{\n\t  mpf_set (max_rerr, rerr);\n#if VERBOSE\n\t  mpf_dump (max_rerr);\n#endif\n\t  if (mpf_cmp (rerr, limit_rerr) > 0)\n\t    {\n\t      printf (\"ERROR after %d tests\\n\", i);\n\t      printf (\"   u = \"); mpf_dump (u);\n\t      printf (\"   v = \"); mpf_dump (v);\n\t      printf (\"wref = \"); mpf_dump (wref);\n\t      printf (\"   w = \"); mpf_dump (w);\n\t      abort ();\n\t    }\n\t}\n    }\n\n  mpf_clear (limit_rerr);\n  mpf_clear (rerr);\n  mpf_clear (max_rerr);\n\n  mpf_clear (u);\n  mpf_clear (v);\n  mpf_clear (w);\n  mpf_clear (wref);\n}",
      "lines": 78,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    struct {\n      int        exp, size;\n      mp_limb_t  d[10];\n    } x, y, want;\n\n  } data[] = {\n    { { 123, 2, { 8, 9 } },             { 123, 1, { 9 } }, { 122, 1, { 8 } } },\n    { { 1, 1, { 9 } },                  { 1, 1, { 8 } },   { 1, 1, { 1 } } },\n    { { 1, 1, { 9 } },                 { 1, -1, { 6 } },   { 1, 1, { 15 } } },\n    { { 1, 2, { 8, 9 } },               { 1, 1, { 8 } },   { 1, 2, { 8, 1 } } },\n    { { 2, 2, { 8, 1 } },               { 1, 1, { 9 } },   { 1, 1, { W } } },\n    { { 2, 2, { 9, 8 } },               { 1, 1, { 9 } },   { 2, 1, { 8 } } },\n    { { 2, 1, { 1 } },                  { 1, 1, { 1 } },   { 1, 1, { W } } },\n    { { 2, 1, { 9 } },                  { 1, 1, { W } },   { 2, 2, { 1, 8 } } },\n\n    { { 1, 2, { W, 8 } },             { 1, 1, { 9 } },   { 0, -1, { 1 } } },\n    { { 1, 2, { W, 7 } },             { 1, 1, { 9 } },   { 1, -2, { 1, 1 } } },\n    { { 1, 2, { 1, 8 } },             { 1, 1, { 9 } },   { 0, -1, { W } } },\n    { { 1, 2, { 1, 7 } },             { 1, 1, { 9 } },   { 1, -2, { W, 1 } } },\n    { { 1, 2, { 0, 8 } },             { 1, 1, { 9 } },   { 1, -1, { 1 } } },\n    { { 2, 3, { 5, 8, 1 } },          { 1, 1, { 9 } },   { 1, 2, { 5, W } } },\n    { { 3, 1, { 1 } },                { 1, 1, { 1 } },   { 2, 2, { W, W } } },\n    { { 1, 6, { W, W, W, W, W, 8 } }, { 1, 1, { 9 } },   { -4, -1, { 1 } } },\n    { { 5, 5, { W-6, W, W, W, W } },  { 6, 1, { 1 } },   { 1, -1, { 7 } } },\n\n    /* f - f == 0, various sizes.\n       These exercise a past problem (gmp 4.1.3 and earlier) where the\n       result exponent was not zeroed on a zero result like this.  */\n    { { 0, 0 }, { 0, 0 }, { 0, 0 } },\n    { { 99, 3, { 0, 0, 1 } },       { 99, 1, { 1 } },             { 0, 0 } },\n    { { 99, 3, { 0, 123, 456 } },   { 99, 2, { 123, 456 } },      { 0, 0 } },\n    { { 99, 3, { 123, 456, 789 } }, { 99, 3, { 123, 456, 789 } }, { 0, 0 } },\n\n    /* High limbs cancel, leaving just the low limbs of the longer operand.\n       This exercises a past problem (gmp 4.1.3 and earlier) where high zero\n       limbs on the remainder were not stripped before truncating to the\n       destination, causing loss of precision.  */\n    { { 123, 2, { 8, 9 } },             { 123, 1, { 9 } }, { 122, 1, { 8 } } },\n    { { 123, 3, { 8, 0, 9 } },          { 123, 1, { 9 } }, { 121, 1, { 8 } } },\n    { { 123, 4, { 8, 0, 0, 9 } },       { 123, 1, { 9 } }, { 120, 1, { 8 } } },\n    { { 123, 5, { 8, 0, 0, 0, 9 } },    { 123, 1, { 9 } }, { 119, 1, { 8 } } },\n    { { 123, 6, { 8, 0, 0, 0, 0, 9 } }, { 123, 1, { 9 } }, { 118, 1, { 8 } } },\n    /* { { 123, 6, { 8, 0, 0, 0, 0, 9 } }, { 123, 6, { 9, 0, 0, 0, 0, 8 } }, { 122, 5, { W, W, W, W, W } } }, */\n\n  };\n\n  mpf_t  x, y, got, want;\n  int  i, swap, fail;\n\n  fail = 0;\n  mp_trace_base = 16;\n  mpf_init (got);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      for (swap = 0; swap <= 7; swap++)\n        {\n          PTR(x) = (mp_ptr) data[i].x.d;\n          SIZ(x) = data[i].x.size;\n          EXP(x) = data[i].x.exp;\n          PREC(x) = numberof (data[i].x.d);\n          MPF_CHECK_FORMAT (x);\n\n          PTR(y) = (mp_ptr) data[i].y.d;\n          SIZ(y) = data[i].y.size;\n          EXP(y) = data[i].y.exp;\n          PREC(y) = numberof (data[i].y.d);\n          MPF_CHECK_FORMAT (y);\n\n          PTR(want) = (mp_ptr) data[i].want.d;\n          SIZ(want) = data[i].want.size;\n          EXP(want) = data[i].want.exp;\n          PREC(want) = numberof (data[i].want.d);\n          MPF_CHECK_FORMAT (want);\n\n          if (swap & 4)\n            {\n              mpf_swap (want, y);\n            }\n\n\t  if ((SIZ (x) ^ SIZ (y)) < 0)\n\t    continue; /* It's an addition, not a subtraction (TO BE REMOVED) */\n\n          if (swap & 1)\n            {\n              mpf_swap (x, y);\n              SIZ(want) = - SIZ(want);\n            }\n\n          if (swap & 2)\n            {\n              SIZ(want) = - SIZ(want);\n              SIZ(x) = - SIZ(x);\n              SIZ(y) = - SIZ(y);\n            }\n\n          mpf_sub (got, x, y);\n/*           MPF_CHECK_FORMAT (got); */\n\n          if (! refmpf_validate (\"mpf_sub\", got, want))\n            {\n              printf (\"check_data() wrong result at data[%d] (operands%s swapped)\\n\", i, swap ? \"\" : \" not\");\n              mpf_trace (\"x   \", x);\n              mpf_trace (\"y   \", y);\n              mpf_trace (\"got \", got);\n              mpf_trace (\"want\", want);\n\t      fail = 1;\n            }\n\n\t  if (SIZ (x) == 1 || SIZ (x) == 0 )\n\t    {\n\t      if (SIZ (y)) EXP (y) -= EXP (x) - (mp_exp_t) SIZ (x);\n\t      if (SIZ (want)) EXP (want) -= EXP (x) - (mp_exp_t) SIZ (x);\n\t      EXP (x) = (mp_exp_t) SIZ (x);\n\n\t      if (mpf_fits_uint_p (x))\n\t\t{\n\t\t  mpf_ui_sub (got, mpf_get_ui (x), y);\n\n\t\t  if (! refmpf_validate (\"mpf_ui_sub\", got, want))\n\t\t    {\n\t\t      printf (\"check_data() wrong result at data[%d] (operands%s swapped)\\n\", i, swap ? \"\" : \" not\");\n\t\t      mpf_trace (\"x   \", x);\n\t\t      mpf_trace (\"y   \", y);\n\t\t      mpf_trace (\"got \", got);\n\t\t      mpf_trace (\"want\", want);\n\t\t      fail = 1;\n\t\t    }\n\t\t}\n\t    }\n\n\t  if (SIZ (y) == 1 || SIZ (y) == 0)\n\t    {\n\t      if (SIZ (x)) EXP (x) -= EXP (y) - (mp_exp_t) SIZ (y);\n\t      if (SIZ (want)) EXP (want) -= EXP (y) - (mp_exp_t) SIZ (y);\n\t      EXP (y) = (mp_exp_t) SIZ (y);\n\n\t      if (mpf_fits_uint_p (x))\n\t\t{\n\t\t  mpf_sub_ui (got, x, mpf_get_ui (y));\n\n\t\t  if (! refmpf_validate (\"mpf_sub_ui\", got, want))\n\t\t    {\n\t\t      printf (\"check_data() wrong result at data[%d] (operands%s swapped)\\n\", i, swap ? \"\" : \" not\");\n\t\t      mpf_trace (\"x   \", x);\n\t\t      mpf_trace (\"y   \", y);\n\t\t      mpf_trace (\"got \", got);\n\t\t      mpf_trace (\"want\", want);\n\t\t      fail = 1;\n\t\t    }\n\t\t}\n\t    }\n\n        }\n    }\n\n  mpf_clear (got);\n  if (fail)\n    abort ();\n}",
      "lines": 164,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  tests_start ();\n\n  check_data ();\n  check_rand (argc, argv);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-trunc.c": {
    "check_print": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\ncheck_print (mpf_srcptr src, mpf_srcptr got, mpf_srcptr want)\n{\n  mp_trace_base = 16;\n  mpf_trace (\"src \", src);\n  mpf_trace (\"got \", got);\n  mpf_trace (\"want\", want);\n\n  printf (\"got  size=%d exp=%ld\\n\", SIZ(got), EXP(got));\n  mpn_trace (\"     limbs=\", PTR(got), (mp_size_t) ABSIZ(got));\n\n  printf (\"want size=%d exp=%ld\\n\", SIZ(want), EXP(want));\n  mpn_trace (\"     limbs=\", PTR(want), (mp_size_t) ABSIZ(want));\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_one": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\ncheck_one (mpf_srcptr src, mpf_srcptr trunc, mpf_srcptr ceil, mpf_srcptr floor)\n{\n  mpf_t  got;\n\n  mpf_init2 (got, mpf_get_prec (trunc));\n  ASSERT_ALWAYS (PREC(got) == PREC(trunc));\n  ASSERT_ALWAYS (PREC(got) == PREC(ceil));\n  ASSERT_ALWAYS (PREC(got) == PREC(floor));\n\n#define CHECK_SEP(name, fun, want)              \\\n  mpf_set_ui (got, 54321L); /* initial junk */  \\\n  fun (got, src);                               \\\n  MPF_CHECK_FORMAT (got);                       \\\n  if (mpf_cmp (got, want) != 0)                 \\\n    {                                           \\\n\tprintf (\"%s wrong\\n\", name);            \\\n\tcheck_print (src, got, want);           \\\n\tabort ();                               \\\n    }\n\n  CHECK_SEP (\"mpf_trunc\", mpf_trunc, trunc);\n  CHECK_SEP (\"mpf_ceil\",  mpf_ceil,  ceil);\n  CHECK_SEP (\"mpf_floor\", mpf_floor, floor);\n\n#define CHECK_INPLACE(name, fun, want)  \\\n  mpf_set (got, src);                   \\\n  fun (got, got);                       \\\n  MPF_CHECK_FORMAT (got);               \\\n  if (mpf_cmp (got, want) != 0)         \\\n    {                                   \\\n\tprintf (\"%s wrong\\n\", name);    \\\n\tcheck_print (src, got, want);   \\\n\tabort ();                       \\\n    }\n\n  CHECK_INPLACE (\"mpf_trunc\", mpf_trunc, trunc);\n\n  /* Can't do these unconditionally in case truncation by mpf_set strips\n     some low non-zero limbs which would have rounded the result.  */\n  if (ABSIZ(src) <= PREC(trunc)+1)\n    {\n      CHECK_INPLACE (\"mpf_ceil\",  mpf_ceil,  ceil);\n      CHECK_INPLACE (\"mpf_floor\", mpf_floor, floor);\n    }\n\n  mpf_clear (got);\n}",
      "lines": 48,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_all": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\ncheck_all (mpf_ptr src, mpf_ptr trunc, mpf_ptr ceil, mpf_ptr floor)\n{\n  /* some of these values are generated with direct field assignments */\n  MPF_CHECK_FORMAT (src);\n  MPF_CHECK_FORMAT (trunc);\n  MPF_CHECK_FORMAT (ceil);\n  MPF_CHECK_FORMAT (floor);\n\n  check_one (src, trunc, ceil, floor);\n\n  mpf_neg (src,   src);\n  mpf_neg (trunc, trunc);\n  mpf_neg (ceil,  ceil);\n  mpf_neg (floor, floor);\n  check_one (src, trunc, floor, ceil);\n}",
      "lines": 17,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  mpf_t  src, trunc, ceil, floor;\n  int    n, i;\n\n  mpf_init2 (src, 512L);\n  mpf_init2 (trunc, 256L);\n  mpf_init2 (ceil,  256L);\n  mpf_init2 (floor, 256L);\n\n  /* 0 */\n  mpf_set_ui (src, 0L);\n  mpf_set_ui (trunc, 0L);\n  mpf_set_ui (ceil, 0L);\n  mpf_set_ui (floor, 0L);\n  check_all (src, trunc, ceil, floor);\n\n  /* 1 */\n  mpf_set_ui (src, 1L);\n  mpf_set_ui (trunc, 1L);\n  mpf_set_ui (ceil, 1L);\n  mpf_set_ui (floor, 1L);\n  check_all (src, trunc, ceil, floor);\n\n  /* 2^1024 */\n  mpf_set_ui (src, 1L);\n  mpf_mul_2exp (src,   src,   1024L);\n  mpf_set (trunc, src);\n  mpf_set (ceil,  src);\n  mpf_set (floor, src);\n  check_all (src, trunc, ceil, floor);\n\n  /* 1/2^1024, fraction only */\n  mpf_set_ui (src, 1L);\n  mpf_div_2exp (src,  src, 1024L);\n  mpf_set_si (trunc, 0L);\n  mpf_set_si (ceil, 1L);\n  mpf_set_si (floor, 0L);\n  check_all (src, trunc, ceil, floor);\n\n  /* 1/2 */\n  mpf_set_ui (src, 1L);\n  mpf_div_2exp (src,  src, 1L);\n  mpf_set_si (trunc, 0L);\n  mpf_set_si (ceil, 1L);\n  mpf_set_si (floor, 0L);\n  check_all (src, trunc, ceil, floor);\n\n  /* 123+1/2^64 */\n  mpf_set_ui (src, 1L);\n  mpf_div_2exp (src,  src, 64L);\n  mpf_add_ui (src,  src, 123L);\n  mpf_set_si (trunc, 123L);\n  mpf_set_si (ceil, 124L);\n  mpf_set_si (floor, 123L);\n  check_all (src, trunc, ceil, floor);\n\n  /* integer of full prec+1 limbs, unchanged */\n  n = PREC(trunc)+1;\n  ASSERT_ALWAYS (n <= PREC(src)+1);\n  EXP(src) = n;\n  SIZ(src) = n;\n  for (i = 0; i < SIZ(src); i++)\n    PTR(src)[i] = i+100;\n  mpf_set (trunc, src);\n  mpf_set (ceil, src);\n  mpf_set (floor, src);\n  check_all (src, trunc, ceil, floor);\n\n  /* full prec+1 limbs, 1 trimmed for integer */\n  n = PREC(trunc)+1;\n  ASSERT_ALWAYS (n <= PREC(src)+1);\n  EXP(src) = n-1;\n  SIZ(src) = n;\n  for (i = 0; i < SIZ(src); i++)\n    PTR(src)[i] = i+200;\n  EXP(trunc) = n-1;\n  SIZ(trunc) = n-1;\n  for (i = 0; i < SIZ(trunc); i++)\n    PTR(trunc)[i] = i+201;\n  mpf_set (floor, trunc);\n  mpf_add_ui (ceil, trunc, 1L);\n  check_all (src, trunc, ceil, floor);\n\n  /* prec+3 limbs, 2 trimmed for size */\n  n = PREC(trunc)+3;\n  ASSERT_ALWAYS (n <= PREC(src)+1);\n  EXP(src) = n;\n  SIZ(src) = n;\n  for (i = 0; i < SIZ(src); i++)\n    PTR(src)[i] = i+300;\n  EXP(trunc) = n;\n  SIZ(trunc) = n-2;\n  for (i = 0; i < SIZ(trunc); i++)\n    PTR(trunc)[i] = i+302;\n  mpf_set (floor, trunc);\n  mpf_set (ceil, trunc);\n  PTR(ceil)[0]++;\n  check_all (src, trunc, ceil, floor);\n\n  /* prec+4 limbs, 2 trimmed for size, 1 trimmed for integer */\n  n = PREC(trunc)+4;\n  ASSERT_ALWAYS (n <= PREC(src)+1);\n  EXP(src) = n-1;\n  SIZ(src) = n;\n  for (i = 0; i < SIZ(src); i++)\n    PTR(src)[i] = i+400;\n  EXP(trunc) = n-1;\n  SIZ(trunc) = n-3;\n  for (i = 0; i < SIZ(trunc); i++)\n    PTR(trunc)[i] = i+403;\n  mpf_set (floor, trunc);\n  mpf_set (ceil, trunc);\n  PTR(ceil)[0]++;\n  check_all (src, trunc, ceil, floor);\n\n  /* F.F, carry out of ceil */\n  EXP(src) = 1;\n  SIZ(src) = 2;\n  PTR(src)[0] = GMP_NUMB_MAX;\n  PTR(src)[1] = GMP_NUMB_MAX;\n  EXP(trunc) = 1;\n  SIZ(trunc) = 1;\n  PTR(trunc)[0] = GMP_NUMB_MAX;\n  mpf_set (floor, trunc);\n  EXP(ceil) = 2;\n  SIZ(ceil) = 1;\n  PTR(ceil)[0] = 1;\n  check_all (src, trunc, ceil, floor);\n\n  /* FF.F, carry out of ceil */\n  EXP(src) = 2;\n  SIZ(src) = 3;\n  PTR(src)[0] = GMP_NUMB_MAX;\n  PTR(src)[1] = GMP_NUMB_MAX;\n  PTR(src)[2] = GMP_NUMB_MAX;\n  EXP(trunc) = 2;\n  SIZ(trunc) = 2;\n  PTR(trunc)[0] = GMP_NUMB_MAX;\n  PTR(trunc)[1] = GMP_NUMB_MAX;\n  mpf_set (floor, trunc);\n  EXP(ceil) = 3;\n  SIZ(ceil) = 1;\n  PTR(ceil)[0] = 1;\n  check_all (src, trunc, ceil, floor);\n\n  mpf_clear (src);\n  mpf_clear (trunc);\n  mpf_clear (ceil);\n  mpf_clear (floor);\n}",
      "lines": 152,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_various ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpf/t-ui_div.c": {
    "check_one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\ncheck_one (const char *desc, mpf_ptr got, unsigned long u, mpf_srcptr v)\n{\n  mpf_t      uf;\n  mp_limb_t  ulimbs[2];\n  mp_size_t  usize;\n\n  ulimbs[0] = u & GMP_NUMB_MASK;\n  usize = (u != 0);\n#if BITS_PER_ULONG > GMP_NUMB_BITS\n  u >>= GMP_NUMB_BITS;\n  ulimbs[1] = u;\n  usize += (u != 0);\n#endif\n  PTR(uf) = ulimbs;\n  SIZ(uf) = usize;\n  EXP(uf) = usize;\n\n  if (! refmpf_validate_division (\"mpf_ui_div\", got, uf, v))\n    {\n      mp_trace_base = -16;\n      printf    (\"  u 0x%lX  (%lu)\\n\", u, u);\n      mpf_trace (\"  v\", v);\n      printf    (\"  %s\\n\", desc);\n      abort ();\n    }\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_rand": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "void\ncheck_rand (void)\n{\n  unsigned long  min_prec = __GMPF_BITS_TO_PREC (1);\n  gmp_randstate_ptr  rands = RANDS;\n  unsigned long  prec, u;\n  mpf_t  got, v;\n  int    i;\n\n  mpf_init (got);\n  mpf_init (v);\n\n  for (i = 0; i < 200; i++)\n    {\n      /* got precision */\n      prec = min_prec + gmp_urandomm_ui (rands, 15L);\n      refmpf_set_prec_limbs (got, prec);\n\n      /* u */\n      prec = gmp_urandomm_ui (rands, BITS_PER_ULONG+1);\n      u = gmp_urandomb_ui (rands, prec);\n\n      /* v precision */\n      prec = min_prec + gmp_urandomm_ui (rands, 15L);\n      refmpf_set_prec_limbs (v, prec);\n\n      /* v, non-zero */\n      do {\n        mpf_random2 (v, PREC(v), (mp_exp_t) 20);\n      } while (SIZ(v) == 0);\n\n      /* v possibly negative */\n      if (gmp_urandomb_ui (rands, 1L))\n        mpf_neg (v, v);\n\n      if ((i % 2) == 0)\n        {\n          /* src != dst */\n          mpf_ui_div (got, u, v);\n          check_one (\"separate\", got, u, v);\n        }\n      else\n        {\n          /* src == dst */\n          prec = refmpf_set_overlap (got, v);\n          mpf_ui_div (got, u, got);\n          check_one (\"overlap src==dst\", got, u, v);\n\n          mpf_set_prec_raw (got, prec);\n        }\n    }\n\n  mpf_clear (got);\n  mpf_clear (v);\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  mpf_t got, v;\n\n  mpf_init (got);\n  mpf_init (v);\n\n  /* 100/4 == 25 */\n  mpf_set_prec (got, 20L);\n  mpf_set_ui (v, 4L);\n  mpf_ui_div (got, 100L, v);\n  MPF_CHECK_FORMAT (got);\n  ASSERT_ALWAYS (mpf_cmp_ui (got, 25L) == 0);\n\n  {\n    /* 1/(2^n+1), a case where truncating the divisor would be wrong */\n    unsigned long  u = 1L;\n    mpf_set_prec (got, 500L);\n    mpf_set_prec (v, 900L);\n    mpf_set_ui (v, 1L);\n    mpf_mul_2exp (v, v, 800L);\n    mpf_add_ui (v, v, 1L);\n    mpf_ui_div (got, u, v);\n    check_one (\"1/2^n+1, separate\", got, u, v);\n  }\n\n  mpf_clear (got);\n  mpf_clear (v);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_various ();\n  check_rand ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/logic.c": {
    "check_one": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\ncheck_one (mp_srcptr refp, mp_srcptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n, const char *funcname)\n{\n  if (mpn_cmp (refp, rp, n))\n    {\n      printf (\"ERROR in mpn_%s\\n\", funcname);\n      printf (\"a: \"); mpn_dump (ap, n);\n      printf (\"b: \"); mpn_dump (bp, n);\n      printf (\"r:   \"); mpn_dump (rp, n);\n      printf (\"ref: \"); mpn_dump (refp, n);\n      abort();\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t a, b;\n  mp_ptr ap, bp, rp, refp;\n  mp_size_t max_n, n, i;\n  gmp_randstate_ptr rands;\n  long test, reps = 1000;\n  TMP_DECL;\n  TMP_MARK;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  mpz_inits (a, b, NULL);\n\n  rands = RANDS;\t\t/* FIXME: not used */\n\n  max_n = 100;\n\n  rp = TMP_ALLOC_LIMBS (1 + max_n * 8 / GMP_LIMB_BITS);\n  refp = TMP_ALLOC_LIMBS (1 + max_n * 8 / GMP_LIMB_BITS);\n\n  for (test = 0; test < reps; test++)\n    {\n      for (i = 1; i <= max_n; i++)\n\t{\n\t  mpz_rrandomb (a, rands, i * 8);\n\t  mpz_rrandomb (b, rands, i * 8);\n\t  mpz_setbit (a, i * 8 - 1);\n\t  mpz_setbit (b, i * 8 - 1);\n\t  ap = PTR(a);\n\t  bp = PTR(b);\n\t  n = SIZ(a);\n\n\t  refmpn_and_n (refp, ap, bp, n);\n\t  mpn_and_n (rp, ap, bp, n);\n\t  check_one (refp, rp, ap, bp, n, \"and_n\");\n\n\t  refmpn_ior_n (refp, ap, bp, n);\n\t  mpn_ior_n (rp, ap, bp, n);\n\t  check_one (refp, rp, ap, bp, n, \"ior_n\");\n\n\t  refmpn_xor_n (refp, ap, bp, n);\n\t  mpn_xor_n (rp, ap, bp, n);\n\t  check_one (refp, rp, ap, bp, n, \"xor_n\");\n\n\t  refmpn_andn_n (refp, ap, bp, n);\n\t  mpn_andn_n (rp, ap, bp, n);\n\t  check_one (refp, rp, ap, bp, n, \"andn_n\");\n\n\t  refmpn_iorn_n (refp, ap, bp, n);\n\t  mpn_iorn_n (rp, ap, bp, n);\n\t  check_one (refp, rp, ap, bp, n, \"iorn_n\");\n\n\t  refmpn_nand_n (refp, ap, bp, n);\n\t  mpn_nand_n (rp, ap, bp, n);\n\t  check_one (refp, rp, ap, bp, n, \"nand_n\");\n\n\t  refmpn_nior_n (refp, ap, bp, n);\n\t  mpn_nior_n (rp, ap, bp, n);\n\t  check_one (refp, rp, ap, bp, n, \"nior_n\");\n\n\t  refmpn_xnor_n (refp, ap, bp, n);\n\t  mpn_xnor_n (rp, ap, bp, n);\n\t  check_one (refp, rp, ap, bp, n, \"xnor_n\");\n\n\t  refmpn_com (refp, ap, n);\n\t  mpn_com (rp, ap, n);\n\t  check_one (refp, rp, ap, bp, n, \"com\");\n\t}\n    }\n\n  TMP_FREE;\n  mpz_clears (a, b, NULL);\n  tests_end ();\n  return 0;\n}",
      "lines": 78,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-aors_1.c": {
    "verify": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\nverify (const char *name, int i,\n        mp_srcptr src, mp_limb_t n,\n        mp_limb_t got_c, mp_limb_t want_c,\n        mp_srcptr got, mp_srcptr want, mp_size_t size)\n{\n  if (got[size] != MAGIC)\n    {\n      printf (\"Overwrite at %s i=%d\\n\", name, i);\n      abort ();\n    }\n\n  if (got_c != want_c || ! refmpn_equal_anynail (got, want, size))\n    {\n      printf (\"Wrong at %s i=%d size=%ld\\n\", name, i, size);\n      mpn_trace (\"   src\", src,  size);\n      mpn_trace (\"     n\", &n,   (mp_size_t) 1);\n      mpn_trace (\"   got\", got,  size);\n      mpn_trace (\"  want\", want, size);\n      mpn_trace (\" got c\", &got_c,  (mp_size_t) 1);\n      mpn_trace (\"want c\", &want_c, (mp_size_t) 1);\n      abort ();\n    }\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_add_1": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "void\ncheck_add_1 (void)\n{\n  static const struct {\n    mp_size_t        size;\n    mp_limb_t        n;\n    const mp_limb_t  src[ASIZE];\n    mp_limb_t        want_c;\n    const mp_limb_t  want[ASIZE];\n  } data[] = {\n    { 1, 0, { 0 },  0, { 0 } },\n    { 1, 0, { 1 },  0, { 1 } },\n    { 1, 1, { 0 },  0, { 1 } },\n    { 1, 0, { M },  0, { M } },\n    { 1, M, { 0 },  0, { M } },\n    { 1, 1, { 123 }, 0, { 124 } },\n\n    { 1, 1, { M },  1, { 0 } },\n    { 1, M, { 1 },  1, { 0 } },\n    { 1, M, { M },  1, { M-1 } },\n\n    { 2, 0, { 0, 0 },  0, { 0, 0 } },\n    { 2, 0, { 1, 0 },  0, { 1, 0 } },\n    { 2, 1, { 0, 0 },  0, { 1, 0 } },\n    { 2, 0, { M, 0 },  0, { M, 0 } },\n    { 2, M, { 0, 0 },  0, { M, 0 } },\n    { 2, 1, { M, 0 },  0, { 0, 1 } },\n    { 2, M, { 1, 0 },  0, { 0, 1 } },\n    { 2, M, { M, 0 },  0, { M-1, 1 } },\n    { 2, M, { M, 0 },  0, { M-1, 1 } },\n\n    { 2, 1, { M, M },  1, { 0, 0 } },\n    { 2, M, { 1, M },  1, { 0, 0 } },\n    { 2, M, { M, M },  1, { M-1, 0 } },\n    { 2, M, { M, M },  1, { M-1, 0 } },\n\n    { 3, 1, { M, M, M },  1, { 0, 0, 0 } },\n    { 3, M, { 1, M, M },  1, { 0, 0, 0 } },\n    { 3, M, { M, M, M },  1, { M-1, 0, 0 } },\n    { 3, M, { M, M, M },  1, { M-1, 0, 0 } },\n\n    { 4, 1, { M, M, M, M },  1, { 0, 0, 0, 0 } },\n    { 4, M, { 1, M, M, M },  1, { 0, 0, 0, 0 } },\n    { 4, M, { M, M, M, M },  1, { M-1, 0, 0, 0 } },\n    { 4, M, { M, M, M, M },  1, { M-1, 0, 0, 0 } },\n\n    { 4, M, { M, 0,   M, M },  0, { M-1, 1, M, M } },\n    { 4, M, { M, M-1, M, M },  0, { M-1, M, M, M } },\n\n    { 4, M, { M, M, 0,   M },  0, { M-1, 0, 1, M } },\n    { 4, M, { M, M, M-1, M },  0, { M-1, 0, M, M } },\n  };\n\n  mp_limb_t  got[ASIZE];\n  mp_limb_t  got_c;\n  /* mpn_sec_add_a_itch(n) <= n */\n  mp_limb_t  scratch[ASIZE];\n  int        i;\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      SETUP ();\n      got_c = mpn_add_1 (got, data[i].src, data[i].size, data[i].n);\n      VERIFY (\"check_add_1 (separate)\");\n\n      SETUP_INPLACE ();\n      got_c = mpn_add_1 (got, got, data[i].size, data[i].n);\n      VERIFY (\"check_add_1 (in-place)\");\n\n      SETUP ();\n      scratch [mpn_sec_add_1_itch(data[i].size)] = MAGIC;\n      got_c = mpn_sec_add_1 (got, data[i].src, data[i].size, data[i].n, scratch);\n      got_c ^= scratch [mpn_sec_add_1_itch(data[i].size)] ^ MAGIC;\n      VERIFY (\"check_sec_add_1 (separate)\");\n\n      SETUP_INPLACE ();\n      got_c = mpn_sec_add_1 (got, got, data[i].size, data[i].n, scratch);\n      VERIFY (\"check_sec_add_1 (in-place)\");\n\n      if (data[i].n == 1)\n        {\n          SETUP ();\n          got_c = mpn_add_1 (got, data[i].src, data[i].size, CNST_LIMB(1));\n          VERIFY (\"check_add_1 (separate, const 1)\");\n\n          SETUP_INPLACE ();\n          got_c = mpn_add_1 (got, got, data[i].size, CNST_LIMB(1));\n          VERIFY (\"check_add_1 (in-place, const 1)\");\n\n          SETUP ();\n          got_c = mpn_sec_add_1 (got, data[i].src, data[i].size,\n\t\t\t\t CNST_LIMB(1), scratch);\n          VERIFY (\"check_sec_add_1 (separate, const 1)\");\n\n          SETUP_INPLACE ();\n          got_c = mpn_sec_add_1 (got, got, data[i].size,\n\t\t\t\t CNST_LIMB(1), scratch);\n          VERIFY (\"check_sec_add_1 (in-place, const 1)\");\n        }\n\n      /* Same again on functions, not inlines. */\n      SETUP ();\n      got_c = (*fudge(mpn_add_1)) (got, data[i].src, data[i].size, data[i].n);\n      VERIFY (\"check_add_1 (function, separate)\");\n\n      SETUP_INPLACE ();\n      got_c = (*fudge(mpn_add_1)) (got, got, data[i].size, data[i].n);\n      VERIFY (\"check_add_1 (function, in-place)\");\n    }\n}",
      "lines": 110,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_sub_1": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "void\ncheck_sub_1 (void)\n{\n  static const struct {\n    mp_size_t        size;\n    mp_limb_t        n;\n    const mp_limb_t  src[ASIZE];\n    mp_limb_t        want_c;\n    const mp_limb_t  want[ASIZE];\n  } data[] = {\n    { 1, 0, { 0 },  0, { 0 } },\n    { 1, 0, { 1 },  0, { 1 } },\n    { 1, 1, { 1 },  0, { 0 } },\n    { 1, 0, { M },  0, { M } },\n    { 1, 1, { M },  0, { M-1 } },\n    { 1, 1, { 123 }, 0, { 122 } },\n\n    { 1, 1, { 0 },  1, { M } },\n    { 1, M, { 0 },  1, { 1 } },\n\n    { 2, 0, { 0, 0 },  0, { 0, 0 } },\n    { 2, 0, { 1, 0 },  0, { 1, 0 } },\n    { 2, 1, { 1, 0 },  0, { 0, 0 } },\n    { 2, 0, { M, 0 },  0, { M, 0 } },\n    { 2, 1, { M, 0 },  0, { M-1, 0 } },\n    { 2, 1, { 123, 0 }, 0, { 122, 0 } },\n\n    { 2, 1, { 0, 0 },  1, { M, M } },\n    { 2, M, { 0, 0 },  1, { 1, M } },\n\n    { 3, 0, { 0,   0, 0 },  0, { 0,   0, 0 } },\n    { 3, 0, { 123, 0, 0 },  0, { 123, 0, 0 } },\n\n    { 3, 1, { 0, 0, 0 },  1, { M, M, M } },\n    { 3, M, { 0, 0, 0 },  1, { 1, M, M } },\n\n    { 4, 1, { 0, 0, 0, 0 },  1, { M, M, M, M } },\n    { 4, M, { 0, 0, 0, 0 },  1, { 1, M, M, M } },\n\n    { 4, 1, { 0, 0, 1,   42 },  0, { M, M, 0,   42 } },\n    { 4, M, { 0, 0, 123, 24 },  0, { 1, M, 122, 24 } },\n  };\n\n  mp_limb_t  got[ASIZE];\n  mp_limb_t  got_c;\n  /* mpn_sec_sub_1_itch(n) <= n */\n  mp_limb_t  scratch[ASIZE];\n  int        i;\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      SETUP ();\n      got_c = mpn_sub_1 (got, data[i].src, data[i].size, data[i].n);\n      VERIFY (\"check_sub_1 (separate)\");\n\n      SETUP_INPLACE ();\n      got_c = mpn_sub_1 (got, got, data[i].size, data[i].n);\n      VERIFY (\"check_sub_1 (in-place)\");\n\n      SETUP ();\n      scratch [mpn_sec_sub_1_itch(data[i].size)] = MAGIC;\n      got_c = mpn_sec_sub_1 (got, data[i].src, data[i].size, data[i].n, scratch);\n      got_c ^= scratch [mpn_sec_sub_1_itch(data[i].size)] ^ MAGIC;\n      VERIFY (\"check_sec_sub_1 (separate)\");\n\n      SETUP_INPLACE ();\n      got_c = mpn_sec_sub_1 (got, got, data[i].size, data[i].n, scratch);\n      VERIFY (\"check_sec_sub_1 (in-place)\");\n\n      if (data[i].n == 1)\n        {\n          SETUP ();\n          got_c = mpn_sub_1 (got, data[i].src, data[i].size, CNST_LIMB(1));\n          VERIFY (\"check_sub_1 (separate, const 1)\");\n\n          SETUP_INPLACE ();\n          got_c = mpn_sub_1 (got, got, data[i].size, CNST_LIMB(1));\n          VERIFY (\"check_sub_1 (in-place, const 1)\");\n\n          SETUP ();\n          got_c = mpn_sec_sub_1 (got, data[i].src, data[i].size,\n\t\t\t\t CNST_LIMB(1), scratch);\n          VERIFY (\"check_sec_sub_1 (separate, const 1)\");\n\n          SETUP_INPLACE ();\n          got_c = mpn_sec_sub_1 (got, got, data[i].size,\n\t\t\t\t CNST_LIMB(1), scratch);\n          VERIFY (\"check_sec_sub_1 (in-place, const 1)\");\n        }\n\n      /* Same again on functions, not inlines. */\n      SETUP ();\n      got_c = (*fudge(mpn_sub_1)) (got, data[i].src, data[i].size, data[i].n);\n      VERIFY (\"check_sub_1 (function, separate)\");\n\n      SETUP_INPLACE ();\n      got_c = (*fudge(mpn_sub_1)) (got, got, data[i].size, data[i].n);\n      VERIFY (\"check_sub_1 (function, in-place)\");\n    }\n}",
      "lines": 100,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "fudge": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "mpn_aors_1_t\nfudge (mpn_aors_1_t f)\n{\n  return f;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "mpn_aors_1_t"
      ]
    },
    "main": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_add_1 ();\n  check_sub_1 ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-asmtype.c": {
    "main": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\nmain (void)\n{\n  static const mp_limb_t x[3]    = { 1, 2, 3 };\n  static const mp_limb_t y[3]    = { 4, 5, 6 };\n  static const mp_limb_t want[3] = { 5, 7, 9 };\n  mp_limb_t  got[3];\n\n  mpn_add_n (got, x, y, (mp_size_t) 3);\n\n  if (refmpn_cmp (got, want, (mp_size_t) 3) != 0)\n    {\n      printf (\"Wrong result from mpn_add_n\\n\");\n      abort ();\n    }\n\n  exit (0);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-bdiv.c": {
    "dumpy": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ndumpy (mp_srcptr p, mp_size_t n)\n{\n  mp_size_t i;\n  if (n > 20)\n    {\n      for (i = n - 1; i >= n - 4; i--)\n\t{\n\t  printf (\"%0*lx\", (int) (2 * sizeof (mp_limb_t)), p[i]);\n\t  printf (\" \");\n\t}\n      printf (\"... \");\n      for (i = 3; i >= 0; i--)\n\t{\n\t  printf (\"%0*lx\", (int) (2 * sizeof (mp_limb_t)), p[i]);\n\t  printf (i == 0 ? \"\" : \" \");\n\t}\n    }\n  else\n    {\n      for (i = n - 1; i >= 0; i--)\n\t{\n\t  printf (\"%0*lx\", (int) (2 * sizeof (mp_limb_t)), p[i]);\n\t  printf (i == 0 ? \"\" : \" \");\n\t}\n    }\n  puts (\"\");\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_one": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\ncheck_one (mp_ptr qp, mp_srcptr rp, mp_limb_t rh,\n\t   mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, const char *fname)\n{\n  mp_size_t qn;\n  int cmp;\n  mp_ptr tp;\n  mp_limb_t cy = 4711;\t\t/* silence warnings */\n  TMP_DECL;\n\n  qn = nn - dn;\n\n  if (qn == 0)\n    return;\n\n  TMP_MARK;\n\n  tp = TMP_ALLOC_LIMBS (nn + 1);\n\n  if (dn >= qn)\n    mpn_mul (tp, dp, dn, qp, qn);\n  else\n    mpn_mul (tp, qp, qn, dp, dn);\n\n  if (rp != NULL)\n    {\n      cy = mpn_add_n (tp + qn, tp + qn, rp, dn);\n      cmp = cy != rh || mpn_cmp (tp, np, nn) != 0;\n    }\n  else\n    cmp = mpn_cmp (tp, np, nn - dn) != 0;\n\n  if (cmp != 0)\n    {\n      printf (\"\\r*******************************************************************************\\n\");\n      printf (\"%s inconsistent in test %lu\\n\", fname, test);\n      printf (\"N=   \"); dumpy (np, nn);\n      printf (\"D=   \"); dumpy (dp, dn);\n      printf (\"Q=   \"); dumpy (qp, qn);\n      if (rp != NULL)\n\t{\n\t  printf (\"R=   \"); dumpy (rp, dn);\n\t  printf (\"Rb=  %d, Cy=%d\\n\", (int) cy, (int) rh);\n\t}\n      printf (\"T=   \"); dumpy (tp, nn);\n      printf (\"nn = %ld, dn = %ld, qn = %ld\", nn, dn, qn);\n      printf (\"\\n*******************************************************************************\\n\");\n      abort ();\n    }\n\n  TMP_FREE;\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "random_word": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "mp_limb_t\nrandom_word (gmp_randstate_ptr rs)\n{\n  mpz_t x;\n  mp_limb_t r;\n  TMP_DECL;\n  TMP_MARK;\n\n  MPZ_TMP_INIT (x, 2);\n  mpz_urandomb (x, rs, 32);\n  r = mpz_get_ui (x);\n  TMP_FREE;\n  return r;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "main": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  gmp_randstate_ptr rands;\n  unsigned long maxnbits, maxdbits, nbits, dbits;\n  mpz_t n, d, tz;\n  mp_size_t maxnn, maxdn, nn, dn, clearn, i;\n  mp_ptr np, dp, qp, rp;\n  mp_limb_t rh;\n  mp_limb_t t;\n  mp_limb_t dinv;\n  int count = COUNT;\n  mp_ptr scratch;\n  mp_limb_t ran;\n  mp_size_t alloc, itch;\n  mp_limb_t rran0, rran1, qran0, qran1;\n  TMP_DECL;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n\n  maxdbits = MAX_DN;\n  maxnbits = MAX_NN;\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (n);\n  mpz_init (d);\n  mpz_init (tz);\n\n  maxnn = maxnbits / GMP_NUMB_BITS + 1;\n  maxdn = maxdbits / GMP_NUMB_BITS + 1;\n\n  TMP_MARK;\n\n  qp = TMP_ALLOC_LIMBS (maxnn + 2) + 1;\n  rp = TMP_ALLOC_LIMBS (maxnn + 2) + 1;\n\n  alloc = 1;\n  scratch = __GMP_ALLOCATE_FUNC_LIMBS (alloc);\n\n  for (test = 0; test < count;)\n    {\n      nbits = random_word (rands) % (maxnbits - GMP_NUMB_BITS) + 2 * GMP_NUMB_BITS;\n      if (maxdbits > nbits)\n\tdbits = random_word (rands) % nbits + 1;\n      else\n\tdbits = random_word (rands) % maxdbits + 1;\n\n#if RAND_UNIFORM\n#define RANDFUNC mpz_urandomb\n#else\n#define RANDFUNC mpz_rrandomb\n#endif\n\n      do\n\t{\n\t  RANDFUNC (n, rands, nbits);\n\t  do\n\t    {\n\t      RANDFUNC (d, rands, dbits);\n\t    }\n\t  while (mpz_sgn (d) == 0);\n\n\t  np = PTR (n);\n\t  dp = PTR (d);\n\t  nn = SIZ (n);\n\t  dn = SIZ (d);\n\t}\n      while (nn < dn);\n\n      dp[0] |= 1;\n\n      mpz_urandomb (tz, rands, 32);\n      t = mpz_get_ui (tz);\n\n      if (t % 17 == 0)\n\tdp[0] = GMP_NUMB_MAX;\n\n      switch ((int) t % 16)\n\t{\n\tcase 0:\n\t  clearn = random_word (rands) % nn;\n\t  for (i = 0; i <= clearn; i++)\n\t    np[i] = 0;\n\t  break;\n\tcase 1:\n\t  mpn_sub_1 (np + nn - dn, dp, dn, random_word (rands));\n\t  break;\n\tcase 2:\n\t  mpn_add_1 (np + nn - dn, dp, dn, random_word (rands));\n\t  break;\n\t}\n\n      test++;\n\n      binvert_limb (dinv, dp[0]);\n\n      rran0 = random_word (rands);\n      rran1 = random_word (rands);\n      qran0 = random_word (rands);\n      qran1 = random_word (rands);\n\n      qp[-1] = qran0;\n      qp[nn - dn + 1] = qran1;\n      rp[-1] = rran0;\n\n      ran = random_word (rands);\n\n      if ((double) (nn - dn) * dn < 1e5)\n\t{\n\t  if (nn > dn)\n\t    {\n\t      /* Test mpn_sbpi1_bdiv_qr */\n\t      MPN_ZERO (qp, nn - dn);\n\t      MPN_ZERO (rp, dn);\n\t      MPN_COPY (rp, np, nn);\n\t      rh = mpn_sbpi1_bdiv_qr (qp, rp, nn, dp, dn, -dinv);\n\t      ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t      ASSERT_ALWAYS (rp[-1] == rran0);\n\t      check_one (qp, rp + nn - dn, rh, np, nn, dp, dn, \"mpn_sbpi1_bdiv_qr\");\n\t    }\n\n\t  if (nn > dn)\n\t    {\n\t      /* Test mpn_sbpi1_bdiv_q */\n\t      MPN_COPY (rp, np, nn);\n\t      MPN_ZERO (qp, nn - dn);\n\t      mpn_sbpi1_bdiv_q (qp, rp, nn - dn, dp, MIN(dn,nn-dn), -dinv);\n\t      ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t      ASSERT_ALWAYS (rp[-1] == rran0);\n\t      check_one (qp, NULL, 0, np, nn, dp, dn, \"mpn_sbpi1_bdiv_q\");\n\t    }\n\t}\n\n      if (dn >= 4 && nn - dn >= 2)\n\t{\n\t  /* Test mpn_dcpi1_bdiv_qr */\n\t  MPN_COPY (rp, np, nn);\n\t  MPN_ZERO (qp, nn - dn);\n\t  rh = mpn_dcpi1_bdiv_qr (qp, rp, nn, dp, dn, -dinv);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t  ASSERT_ALWAYS (rp[-1] == rran0);\n\t  check_one (qp, rp + nn - dn, rh, np, nn, dp, dn, \"mpn_dcpi1_bdiv_qr\");\n\t}\n\n      if (dn >= 4 && nn - dn >= 2)\n\t{\n\t  /* Test mpn_dcpi1_bdiv_q */\n\t  MPN_COPY (rp, np, nn);\n\t  MPN_ZERO (qp, nn - dn);\n\t  mpn_dcpi1_bdiv_q (qp, rp, nn - dn, dp, MIN(dn,nn-dn), -dinv);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t  ASSERT_ALWAYS (rp[-1] == rran0);\n\t  check_one (qp, NULL, 0, np, nn, dp, dn, \"mpn_dcpi1_bdiv_q\");\n\t}\n\n      if (nn > dn)\n\t{\n\t  /* Test mpn_bdiv_qr */\n\t  itch = mpn_bdiv_qr_itch (nn, dn);\n\t  if (itch + 1 > alloc)\n\t    {\n\t      scratch = __GMP_REALLOCATE_FUNC_LIMBS (scratch, alloc, itch + 1);\n\t      alloc = itch + 1;\n\t    }\n\t  scratch[itch] = ran;\n\t  MPN_ZERO (qp, nn - dn);\n\t  MPN_ZERO (rp, dn);\n\t  rp[dn] = rran1;\n\t  rh = mpn_bdiv_qr (qp, rp, np, nn, dp, dn, scratch);\n\t  ASSERT_ALWAYS (ran == scratch[itch]);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t  ASSERT_ALWAYS (rp[-1] == rran0);  ASSERT_ALWAYS (rp[dn] == rran1);\n\n\t  check_one (qp, rp, rh, np, nn, dp, dn, \"mpn_bdiv_qr\");\n\t}\n\n      if (nn - dn < 2 || dn < 2)\n\tcontinue;\n\n      /* Test mpn_mu_bdiv_qr */\n      itch = mpn_mu_bdiv_qr_itch (nn, dn);\n      if (itch + 1 > alloc)\n\t{\n\t  scratch = __GMP_REALLOCATE_FUNC_LIMBS (scratch, alloc, itch + 1);\n\t  alloc = itch + 1;\n\t}\n      scratch[itch] = ran;\n      MPN_ZERO (qp, nn - dn);\n      MPN_ZERO (rp, dn);\n      rp[dn] = rran1;\n      rh = mpn_mu_bdiv_qr (qp, rp, np, nn, dp, dn, scratch);\n      ASSERT_ALWAYS (ran == scratch[itch]);\n      ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n      ASSERT_ALWAYS (rp[-1] == rran0);  ASSERT_ALWAYS (rp[dn] == rran1);\n      check_one (qp, rp, rh, np, nn, dp, dn, \"mpn_mu_bdiv_qr\");\n\n      /* Test mpn_mu_bdiv_q */\n      itch = mpn_mu_bdiv_q_itch (nn, dn);\n      if (itch + 1 > alloc)\n\t{\n\t  scratch = __GMP_REALLOCATE_FUNC_LIMBS (scratch, alloc, itch + 1);\n\t  alloc = itch + 1;\n\t}\n      scratch[itch] = ran;\n      MPN_ZERO (qp, nn - dn + 1);\n      mpn_mu_bdiv_q (qp, np, nn - dn, dp, dn, scratch);\n      ASSERT_ALWAYS (ran == scratch[itch]);\n      ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n      check_one (qp, NULL, 0, np, nn, dp, dn, \"mpn_mu_bdiv_q\");\n    }\n\n  __GMP_FREE_FUNC_LIMBS (scratch, alloc);\n\n  TMP_FREE;\n\n  mpz_clear (n);\n  mpz_clear (d);\n  mpz_clear (tz);\n\n  tests_end ();\n  return 0;\n}",
      "lines": 234,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-broot.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  gmp_randstate_ptr rands;\n\n  mp_ptr ap, rp, pp, scratch;\n  int count = COUNT;\n  unsigned i;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  tests_start ();\n  rands = RANDS;\n\n  ap = TMP_ALLOC_LIMBS (MAX_LIMBS);\n  rp = TMP_ALLOC_LIMBS (MAX_LIMBS);\n  pp = TMP_ALLOC_LIMBS (MAX_LIMBS);\n  scratch = TMP_ALLOC_LIMBS (3*MAX_LIMBS); /* For mpn_powlo */\n\n  for (i = 0; i < count; i++)\n    {\n      mp_size_t n;\n      mp_limb_t k;\n      int c;\n\n      n = 1 + gmp_urandomm_ui (rands, MAX_LIMBS);\n\n      if (i & 1)\n\tmpn_random2 (ap, n);\n      else\n\tmpn_random (ap, n);\n\n      ap[0] |= 1;\n\n      if (i < 100)\n\tk = 3 + 2*i;\n      else\n\t{\n\t  mpn_random (&k, 1);\n\t  if (k < 3)\n\t    k = 3;\n\t  else\n\t    k |= 1;\n\t}\n      mpn_broot (rp, ap, n, k);\n      mpn_powlo (pp, rp, &k, 1, n, scratch);\n\n      MPN_CMP (c, ap, pp, n);\n      if (c != 0)\n\t{\n\t  gmp_fprintf (stderr,\n\t\t       \"mpn_broot returned bad result: %u limbs\\n\",\n\t\t       (unsigned) n);\n\t  gmp_fprintf (stderr, \"k   = %Mx\\n\", k);\n\t  gmp_fprintf (stderr, \"a   = %Nx\\n\", ap, n);\n\t  gmp_fprintf (stderr, \"r   = %Nx\\n\", rp, n);\n\t  gmp_fprintf (stderr, \"r^k = %Nx\\n\", pp, n);\n\t  abort ();\n\t}\n    }\n\n  mpn_broot (rp, ap, MAX_LIMBS, 1);\n  if (mpn_cmp (ap, rp, MAX_LIMBS) != 0)\n    {\n      gmp_fprintf (stderr,\n\t\t   \"mpn_broot returned bad result: %u limbs\\n\",\n\t\t   (unsigned) MAX_LIMBS);\n      gmp_fprintf (stderr, \"k   = %Mx\\n\", 1);\n      gmp_fprintf (stderr, \"a   = %Nx\\n\", ap, MAX_LIMBS);\n      gmp_fprintf (stderr, \"r   = %Nx\\n\", rp, MAX_LIMBS);\n      abort ();\n    }\n\n  TMP_FREE;\n  tests_end ();\n  return 0;\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-brootinv.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  gmp_randstate_ptr rands;\n\n  mp_ptr ap, rp, pp, app, scratch;\n  int count = COUNT;\n  unsigned i;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  tests_start ();\n  rands = RANDS;\n\n  ap = TMP_ALLOC_LIMBS (MAX_LIMBS);\n  rp = TMP_ALLOC_LIMBS (MAX_LIMBS);\n  pp = TMP_ALLOC_LIMBS (MAX_LIMBS);\n  app = TMP_ALLOC_LIMBS (MAX_LIMBS);\n  scratch = TMP_ALLOC_LIMBS (5*MAX_LIMBS);\n\n  for (i = 0; i < count; i++)\n    {\n      mp_size_t n;\n      mp_limb_t k;\n\n      n = 1 + gmp_urandomm_ui (rands, MAX_LIMBS);\n\n      if (i & 1)\n\tmpn_random2 (ap, n);\n      else\n\tmpn_random (ap, n);\n\n      ap[0] |= 1;\n\n      if (i < 100)\n\tk = 3 + 2*i;\n      else\n\t{\n\t  mpn_random (&k, 1);\n\t  if (k < 3)\n\t    k = 3;\n\t  else\n\t    k |= 1;\n\t}\n      mpn_brootinv (rp, ap, n, k, scratch);\n      mpn_powlo (pp, rp, &k, 1, n, scratch);\n      mpn_mullo_n (app, ap, pp, n);\n\n      if (app[0] != 1 || !(n == 1 || mpn_zero_p (app+1, n-1)))\n\t{\n\t  gmp_fprintf (stderr,\n\t\t       \"mpn_brootinv returned bad result: %u limbs\\n\",\n\t\t       (unsigned) n);\n\t  gmp_fprintf (stderr, \"k     = %Mx\\n\", k);\n\t  gmp_fprintf (stderr, \"a     = %Nx\\n\", ap, n);\n\t  gmp_fprintf (stderr, \"r     = %Nx\\n\", rp, n);\n\t  gmp_fprintf (stderr, \"r^n   = %Nx\\n\", pp, n);\n\t  gmp_fprintf (stderr, \"a r^n = %Nx\\n\", app, n);\n\t  abort ();\n\t}\n    }\n  TMP_FREE;\n  tests_end ();\n  return 0;\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-div.c": {
    "dumpy": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ndumpy (mp_srcptr p, mp_size_t n)\n{\n  mp_size_t i;\n  if (n > 20)\n    {\n      for (i = n - 1; i >= n - 4; i--)\n\t{\n\t  printf (\"%0*lx\", (int) (2 * sizeof (mp_limb_t)), p[i]);\n\t  printf (\" \");\n\t}\n      printf (\"... \");\n      for (i = 3; i >= 0; i--)\n\t{\n\t  printf (\"%0*lx\", (int) (2 * sizeof (mp_limb_t)), p[i]);\n\t  printf (i == 0 ? \"\" : \" \");\n\t}\n    }\n  else\n    {\n      for (i = n - 1; i >= 0; i--)\n\t{\n\t  printf (\"%0*lx\", (int) (2 * sizeof (mp_limb_t)), p[i]);\n\t  printf (i == 0 ? \"\" : \" \");\n\t}\n    }\n  puts (\"\");\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_one": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static void\ncheck_one (mp_ptr qp, mp_srcptr rp,\n\t   mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn,\n\t   const char *fname, mp_limb_t q_allowed_err)\n{\n  mp_size_t qn = nn - dn + 1;\n  mp_ptr tp;\n  const char *msg;\n  const char *tvalue;\n  mp_limb_t i;\n  TMP_DECL;\n  TMP_MARK;\n\n  tp = TMP_ALLOC_LIMBS (nn + 1);\n  if (dn >= qn)\n    refmpn_mul (tp, dp, dn, qp, qn);\n  else\n    refmpn_mul (tp, qp, qn, dp, dn);\n\n  for (i = 0; i < q_allowed_err && (tp[nn] > 0 || mpn_cmp (tp, np, nn) > 0); i++)\n    ASSERT_NOCARRY (refmpn_sub (tp, tp, nn+1, dp, dn));\n\n  if (tp[nn] > 0 || mpn_cmp (tp, np, nn) > 0)\n    {\n      msg = \"q too large\";\n      tvalue = \"Q*D\";\n    error:\n      printf (\"\\r*******************************************************************************\\n\");\n      printf (\"%s failed test %ld: %s\\n\", fname, test, msg);\n      printf (\"N=    \"); dumpy (np, nn);\n      printf (\"D=    \"); dumpy (dp, dn);\n      printf (\"Q=    \"); dumpy (qp, qn);\n      if (rp)\n\t{ printf (\"R=    \"); dumpy (rp, dn); }\n      printf (\"%5s=\", tvalue); dumpy (tp, nn+1);\n      printf (\"nn = %ld, dn = %ld, qn = %ld\\n\", nn, dn, qn);\n      abort ();\n    }\n\n  ASSERT_NOCARRY (refmpn_sub_n (tp, np, tp, nn));\n  tvalue = \"N-Q*D\";\n  if (!(nn == dn || mpn_zero_p (tp + dn, nn - dn)) || mpn_cmp (tp, dp, dn) >= 0)\n    {\n      msg = \"q too small\";\n      goto error;\n    }\n\n  if (rp && mpn_cmp (rp, tp, dn) != 0)\n    {\n      msg = \"r incorrect\";\n      goto error;\n    }\n\n  TMP_FREE;\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        504,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  gmp_randstate_ptr rands;\n  unsigned long maxnbits, maxdbits, nbits, dbits;\n  mpz_t n, d, q, r, tz, junk;\n  mp_size_t maxnn, maxdn, nn, dn, clearn, i;\n  mp_ptr np, dup, dnp, qp, rp, junkp;\n  mp_limb_t t;\n  gmp_pi1_t dinv;\n  long count = COUNT;\n  mp_ptr scratch;\n  mp_limb_t ran;\n  mp_size_t alloc, itch;\n  mp_limb_t rran0, rran1, qran0, qran1;\n  TMP_DECL;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  maxdbits = MAX_DN;\n  maxnbits = MAX_NN;\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (n);\n  mpz_init (d);\n  mpz_init (q);\n  mpz_init (r);\n  mpz_init (tz);\n  mpz_init (junk);\n\n  maxnn = maxnbits / GMP_NUMB_BITS + 1;\n  maxdn = maxdbits / GMP_NUMB_BITS + 1;\n\n  TMP_MARK;\n\n  qp = TMP_ALLOC_LIMBS (maxnn + 2) + 1;\n  rp = TMP_ALLOC_LIMBS (maxnn + 2) + 1;\n  dnp = TMP_ALLOC_LIMBS (maxdn);\n\n  alloc = 1;\n  scratch = __GMP_ALLOCATE_FUNC_LIMBS (alloc);\n\n  for (test = -300; test < count; test++)\n    {\n      nbits = urandom () % (maxnbits - GMP_NUMB_BITS) + 2 * GMP_NUMB_BITS;\n\n      if (test < 0)\n\tdbits = (test + 300) % (nbits - 1) + 1;\n      else\n\tdbits = urandom () % (nbits - 1) % maxdbits + 1;\n\n#if RAND_UNIFORM\n#define RANDFUNC mpz_urandomb\n#else\n#define RANDFUNC mpz_rrandomb\n#endif\n\n      do\n\tRANDFUNC (d, rands, dbits);\n      while (mpz_sgn (d) == 0);\n      dn = SIZ (d);\n      dup = PTR (d);\n      MPN_COPY (dnp, dup, dn);\n      dnp[dn - 1] |= GMP_NUMB_HIGHBIT;\n\n      if (test % 2 == 0)\n\t{\n\t  RANDFUNC (n, rands, nbits);\n\t  nn = SIZ (n);\n\t  ASSERT_ALWAYS (nn >= dn);\n\t}\n      else\n\t{\n\t  do\n\t    {\n\t      RANDFUNC (q, rands, urandom () % (nbits - dbits + 1));\n\t      RANDFUNC (r, rands, urandom () % mpz_sizeinbase (d, 2));\n\t      mpz_mul (n, q, d);\n\t      mpz_add (n, n, r);\n\t      nn = SIZ (n);\n\t    }\n\t  while (nn > maxnn || nn < dn);\n\t}\n\n      ASSERT_ALWAYS (nn <= maxnn);\n      ASSERT_ALWAYS (dn <= maxdn);\n\n      mpz_urandomb (junk, rands, nbits);\n      junkp = PTR (junk);\n\n      np = PTR (n);\n\n      mpz_urandomb (tz, rands, 32);\n      t = mpz_get_ui (tz);\n\n      if (t % 17 == 0)\n\t{\n\t  dnp[dn - 1] = GMP_NUMB_MAX;\n\t  dup[dn - 1] = GMP_NUMB_MAX;\n\t}\n\n      switch ((int) t % 16)\n\t{\n\tcase 0:\n\t  clearn = urandom () % nn;\n\t  for (i = clearn; i < nn; i++)\n\t    np[i] = 0;\n\t  break;\n\tcase 1:\n\t  mpn_sub_1 (np + nn - dn, dnp, dn, urandom ());\n\t  break;\n\tcase 2:\n\t  mpn_add_1 (np + nn - dn, dnp, dn, urandom ());\n\t  break;\n\t}\n\n      if (dn >= 2)\n\tinvert_pi1 (dinv, dnp[dn - 1], dnp[dn - 2]);\n\n      rran0 = urandom ();\n      rran1 = urandom ();\n      qran0 = urandom ();\n      qran1 = urandom ();\n\n      qp[-1] = qran0;\n      qp[nn - dn + 1] = qran1;\n      rp[-1] = rran0;\n\n      ran = urandom ();\n\n      if ((double) (nn - dn) * dn < 1e5)\n\t{\n\t  /* Test mpn_sbpi1_div_qr */\n\t  if (dn > 2)\n\t    {\n\t      MPN_COPY (rp, np, nn);\n\t      if (nn > dn)\n\t\tMPN_COPY (qp, junkp, nn - dn);\n\t      qp[nn - dn] = mpn_sbpi1_div_qr (qp, rp, nn, dnp, dn, dinv.inv32);\n\t      check_one (qp, rp, np, nn, dnp, dn, \"mpn_sbpi1_div_qr\", 0);\n\t    }\n\n\t  /* Test mpn_sbpi1_divappr_q */\n\t  if (dn > 2)\n\t    {\n\t      MPN_COPY (rp, np, nn);\n\t      if (nn > dn)\n\t\tMPN_COPY (qp, junkp, nn - dn);\n\t      qp[nn - dn] = mpn_sbpi1_divappr_q (qp, rp, nn, dnp, dn, dinv.inv32);\n\t      check_one (qp, NULL, np, nn, dnp, dn, \"mpn_sbpi1_divappr_q\", 1);\n\t    }\n\n\t  /* Test mpn_sbpi1_div_q */\n\t  if (dn > 2)\n\t    {\n\t      MPN_COPY (rp, np, nn);\n\t      if (nn > dn)\n\t\tMPN_COPY (qp, junkp, nn - dn);\n\t      qp[nn - dn] = mpn_sbpi1_div_q (qp, rp, nn, dnp, dn, dinv.inv32);\n\t      check_one (qp, NULL, np, nn, dnp, dn, \"mpn_sbpi1_div_q\", 0);\n\t    }\n\n\t  /* Test mpn_sec_div_qr */\n\t  itch = mpn_sec_div_qr_itch (nn, dn);\n\t  if (itch + 1 > alloc)\n\t    {\n\t      scratch = __GMP_REALLOCATE_FUNC_LIMBS (scratch, alloc, itch + 1);\n\t      alloc = itch + 1;\n\t    }\n\t  scratch[itch] = ran;\n\t  MPN_COPY (rp, np, nn);\n\t  if (nn >= dn)\n\t    MPN_COPY (qp, junkp, nn - dn + 1);\n\t  qp[nn - dn] = mpn_sec_div_qr (qp, rp, nn, dup, dn, scratch);\n\t  ASSERT_ALWAYS (ran == scratch[itch]);\n\t  check_one (qp, rp, np, nn, dup, dn, \"mpn_sec_div_qr (unnorm)\", 0);\n\n\t  /* Test mpn_sec_div_r */\n\t  itch = mpn_sec_div_r_itch (nn, dn);\n\t  if (itch + 1 > alloc)\n\t    {\n\t      scratch = __GMP_REALLOCATE_FUNC_LIMBS (scratch, alloc, itch + 1);\n\t      alloc = itch + 1;\n\t    }\n\t  scratch[itch] = ran;\n\t  MPN_COPY (rp, np, nn);\n\t  mpn_sec_div_r (rp, nn, dup, dn, scratch);\n\t  ASSERT_ALWAYS (ran == scratch[itch]);\n\t  /* Note: Since check_one cannot cope with remainder-only functions, we\n\t     pass qp[] from the previous function, mpn_sec_div_qr.  */\n\t  check_one (qp, rp, np, nn, dup, dn, \"mpn_sec_div_r (unnorm)\", 0);\n\n\t  /* Normalised case, mpn_sec_div_qr */\n\t  itch = mpn_sec_div_qr_itch (nn, dn);\n\t  scratch[itch] = ran;\n\n\t  MPN_COPY (rp, np, nn);\n\t  if (nn >= dn)\n\t    MPN_COPY (qp, junkp, nn - dn + 1);\n\t  qp[nn - dn] = mpn_sec_div_qr (qp, rp, nn, dnp, dn, scratch);\n\t  ASSERT_ALWAYS (ran == scratch[itch]);\n\t  check_one (qp, rp, np, nn, dnp, dn, \"mpn_sec_div_qr (norm)\", 0);\n\n\t  /* Normalised case, mpn_sec_div_r */\n\t  itch = mpn_sec_div_r_itch (nn, dn);\n\t  scratch[itch] = ran;\n\t  MPN_COPY (rp, np, nn);\n\t  mpn_sec_div_r (rp, nn, dnp, dn, scratch);\n\t  ASSERT_ALWAYS (ran == scratch[itch]);\n\t  /* Note: Since check_one cannot cope with remainder-only functions, we\n\t     pass qp[] from the previous function, mpn_sec_div_qr.  */\n\t  check_one (qp, rp, np, nn, dnp, dn, \"mpn_sec_div_r (norm)\", 0);\n\t}\n\n      /* Test mpn_dcpi1_div_qr */\n      if (dn >= 6 && nn - dn >= 3)\n\t{\n\t  MPN_COPY (rp, np, nn);\n\t  if (nn > dn)\n\t    MPN_COPY (qp, junkp, nn - dn);\n\t  qp[nn - dn] = mpn_dcpi1_div_qr (qp, rp, nn, dnp, dn, &dinv);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t  ASSERT_ALWAYS (rp[-1] == rran0);\n\t  check_one (qp, rp, np, nn, dnp, dn, \"mpn_dcpi1_div_qr\", 0);\n\t}\n\n      /* Test mpn_dcpi1_divappr_q */\n      if (dn >= 6 && nn - dn >= 3)\n\t{\n\t  MPN_COPY (rp, np, nn);\n\t  if (nn > dn)\n\t    MPN_COPY (qp, junkp, nn - dn);\n\t  qp[nn - dn] = mpn_dcpi1_divappr_q (qp, rp, nn, dnp, dn, &dinv);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t  ASSERT_ALWAYS (rp[-1] == rran0);\n\t  check_one (qp, NULL, np, nn, dnp, dn, \"mpn_dcpi1_divappr_q\", 1);\n\t}\n\n      /* Test mpn_dcpi1_div_q */\n      if (dn >= 6 && nn - dn >= 3)\n\t{\n\t  MPN_COPY (rp, np, nn);\n\t  if (nn > dn)\n\t    MPN_COPY (qp, junkp, nn - dn);\n\t  qp[nn - dn] = mpn_dcpi1_div_q (qp, rp, nn, dnp, dn, &dinv);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t  ASSERT_ALWAYS (rp[-1] == rran0);\n\t  check_one (qp, NULL, np, nn, dnp, dn, \"mpn_dcpi1_div_q\", 0);\n\t}\n\n     /* Test mpn_mu_div_qr */\n      if (nn - dn > 2 && dn >= 2)\n\t{\n\t  itch = mpn_mu_div_qr_itch (nn, dn, 0);\n\t  if (itch + 1 > alloc)\n\t    {\n\t      scratch = __GMP_REALLOCATE_FUNC_LIMBS (scratch, alloc, itch + 1);\n\t      alloc = itch + 1;\n\t    }\n\t  scratch[itch] = ran;\n\t  MPN_COPY (qp, junkp, nn - dn);\n\t  MPN_ZERO (rp, dn);\n\t  rp[dn] = rran1;\n\t  qp[nn - dn] = mpn_mu_div_qr (qp, rp, np, nn, dnp, dn, scratch);\n\t  ASSERT_ALWAYS (ran == scratch[itch]);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t  ASSERT_ALWAYS (rp[-1] == rran0);  ASSERT_ALWAYS (rp[dn] == rran1);\n\t  check_one (qp, rp, np, nn, dnp, dn, \"mpn_mu_div_qr\", 0);\n\t}\n\n      /* Test mpn_mu_divappr_q */\n      if (nn - dn > 2 && dn >= 2)\n\t{\n\t  itch = mpn_mu_divappr_q_itch (nn, dn, 0);\n\t  if (itch + 1 > alloc)\n\t    {\n\t      scratch = __GMP_REALLOCATE_FUNC_LIMBS (scratch, alloc, itch + 1);\n\t      alloc = itch + 1;\n\t    }\n\t  scratch[itch] = ran;\n\t  MPN_COPY (qp, junkp, nn - dn);\n\t  qp[nn - dn] = mpn_mu_divappr_q (qp, np, nn, dnp, dn, scratch);\n\t  ASSERT_ALWAYS (ran == scratch[itch]);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t  check_one (qp, NULL, np, nn, dnp, dn, \"mpn_mu_divappr_q\", 4);\n\t}\n\n      /* Test mpn_mu_div_q */\n      if (nn - dn > 2 && dn >= 2)\n\t{\n\t  itch = mpn_mu_div_q_itch (nn, dn, 0);\n\t  if (itch + 1> alloc)\n\t    {\n\t      scratch = __GMP_REALLOCATE_FUNC_LIMBS (scratch, alloc, itch + 1);\n\t      alloc = itch + 1;\n\t    }\n\t  scratch[itch] = ran;\n\t  MPN_COPY (qp, junkp, nn - dn);\n\t  qp[nn - dn] = mpn_mu_div_q (qp, np, nn, dnp, dn, scratch);\n\t  ASSERT_ALWAYS (ran == scratch[itch]);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t  check_one (qp, NULL, np, nn, dnp, dn, \"mpn_mu_div_q\", 0);\n\t}\n\n      if (1)\n\t{\n\t  itch = nn + 1;\n\t  if (itch + 1> alloc)\n\t    {\n\t      scratch = __GMP_REALLOCATE_FUNC_LIMBS (scratch, alloc, itch + 1);\n\t      alloc = itch + 1;\n\t    }\n\t  scratch[itch] = ran;\n\t  mpn_div_q (qp, np, nn, dup, dn, scratch);\n\t  ASSERT_ALWAYS (ran == scratch[itch]);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - dn + 1] == qran1);\n\t  check_one (qp, NULL, np, nn, dup, dn, \"mpn_div_q\", 0);\n\t}\n\n      if (dn >= 2 && nn >= 2)\n\t{\n\t  mp_limb_t qh;\n\n\t  /* mpn_divrem_2 */\n\t  MPN_COPY (rp, np, nn);\n\t  qp[nn - 2] = qp[nn-1] = qran1;\n\n\t  qh = mpn_divrem_2 (qp, 0, rp, nn, dnp + dn - 2);\n\t  ASSERT_ALWAYS (qp[nn - 2] == qran1);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - 1] == qran1);\n\t  qp[nn - 2] = qh;\n\t  check_one (qp, rp, np, nn, dnp + dn - 2, 2, \"mpn_divrem_2\", 0);\n\n\t  /* Missing: divrem_2 with fraction limbs. */\n\n\t  /* mpn_div_qr_2 */\n\t  qp[nn - 2] = qran1;\n\n\t  qh = mpn_div_qr_2 (qp, rp, np, nn, dup + dn - 2);\n\t  ASSERT_ALWAYS (qp[nn - 2] == qran1);\n\t  ASSERT_ALWAYS (qp[-1] == qran0);  ASSERT_ALWAYS (qp[nn - 1] == qran1);\n\t  qp[nn - 2] = qh;\n\t  check_one (qp, rp, np, nn, dup + dn - 2, 2, \"mpn_div_qr_2\", 0);\n\t}\n      if (dn >= 1 && nn >= 1)\n\t{\n\t  /* mpn_div_qr_1 */\n\t  mp_limb_t qh;\n\t  qp[nn-1] = qran1;\n\t  rp[0] = mpn_div_qr_1 (qp, &qh, np, nn, dnp[dn - 1]);\n\t  ASSERT_ALWAYS (qp[-1] == qran0); ASSERT_ALWAYS (qp[nn - 1] == qran1);\n\t  qp[nn - 1] = qh;\n\t  check_one (qp, rp, np, nn,  dnp + dn - 1, 1, \"mpn_div_qr_1\", 0);\n\t}\n    }\n\n  __GMP_FREE_FUNC_LIMBS (scratch, alloc);\n\n  TMP_FREE;\n\n  mpz_clear (n);\n  mpz_clear (d);\n  mpz_clear (q);\n  mpz_clear (r);\n  mpz_clear (tz);\n  mpz_clear (junk);\n\n  tests_end ();\n  return 0;\n}",
      "lines": 381,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-divrem_1.c": {
    "check_data": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    mp_limb_t  n[1];\n    mp_size_t  nsize;\n    mp_limb_t  d;\n    mp_size_t  qxn;\n    mp_limb_t  want_q[5];\n    mp_limb_t  want_r;\n  } data[] = {\n    { { 0 }, 1, 1, 0,\n      { 0 }, 0},\n\n    { { 5 }, 1, 2, 0,\n      { 2 }, 1},\n\n    /* Exercises the q update in the nl == constant 0 case of\n       udiv_qrnnd_preinv3. Test case copied from t-fat.c. */\n    { { 287 }, 1, 7, 1,\n      { 0, 41 }, 0 },\n\n#if GMP_NUMB_BITS == 32\n    { { 0x3C }, 1, 0xF2, 1,\n      { 0x3F789854, 0 }, 0x98 },\n#endif\n\n#if GMP_NUMB_BITS == 64\n    { { 0x3C }, 1, 0xF2, 1,\n      { CNST_LIMB(0x3F789854A0CB1B81), 0 }, 0x0E },\n\n    /* This case exposed some wrong code generated by SGI cc on mips64 irix\n       6.5 with -n32 -O2, in the fractional loop for normalized divisor\n       using udiv_qrnnd_preinv.  A test \"x>al\" in one of the sub_ddmmss\n       expansions came out wrong, leading to an incorrect quotient.  */\n    { { CNST_LIMB(0x3C00000000000000) }, 1, CNST_LIMB(0xF200000000000000), 1,\n      { CNST_LIMB(0x3F789854A0CB1B81), 0 }, CNST_LIMB(0x0E00000000000000) },\n#endif\n  };\n\n  mp_limb_t  dinv, got_r, got_q[numberof(data[0].want_q)];\n  mp_size_t  qsize;\n  int        i, shift;\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      qsize = data[i].nsize + data[i].qxn;\n      ASSERT_ALWAYS (qsize <= numberof (got_q));\n\n      got_r = mpn_divrem_1 (got_q, data[i].qxn, data[i].n, data[i].nsize,\n                            data[i].d);\n      if (got_r != data[i].want_r\n          || refmpn_cmp (got_q, data[i].want_q, qsize) != 0)\n        {\n          printf        (\"mpn_divrem_1 wrong at data[%d]\\n\", i);\n        bad:\n          mpn_trace     (\"  n\", data[i].n, data[i].nsize);\n          printf        (\"  nsize=%ld\\n\", (long) data[i].nsize);\n          mp_limb_trace (\"  d\", data[i].d);\n          printf        (\"  qxn=%ld\\n\", (long) data[i].qxn);\n          mpn_trace     (\"  want q\", data[i].want_q, qsize);\n          mpn_trace     (\"  got  q\", got_q, qsize);\n          mp_limb_trace (\"  want r\", data[i].want_r);\n          mp_limb_trace (\"  got  r\", got_r);\n          abort ();\n        }\n\n      /* test if available */\n#if USE_PREINV_DIVREM_1 || HAVE_NATIVE_mpn_preinv_divrem_1\n      shift = refmpn_count_leading_zeros (data[i].d);\n      dinv = refmpn_invert_limb (data[i].d << shift);\n      got_r = mpn_preinv_divrem_1 (got_q, data[i].qxn,\n                                   data[i].n, data[i].nsize,\n                                   data[i].d, dinv, shift);\n      if (got_r != data[i].want_r\n          || refmpn_cmp (got_q, data[i].want_q, qsize) != 0)\n        {\n          printf        (\"mpn_preinv divrem_1 wrong at data[%d]\\n\", i);\n          printf        (\"  shift=%d\\n\", shift);\n          mp_limb_trace (\"  dinv\", dinv);\n          goto bad;\n        }\n#endif\n    }\n}",
      "lines": 85,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-fat.c": {
    "check_functions": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "void\ncheck_functions (void)\n{\n  mp_limb_t  wp[2], xp[2], yp[2], r;\n  int  i;\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 123;\n      yp[0] = 456;\n      mpn_add_n (wp, xp, yp, (mp_size_t) 1);\n      ASSERT_ALWAYS (wp[0] == 579);\n    }\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 123;\n      wp[0] = 456;\n      r = mpn_addmul_1 (wp, xp, (mp_size_t) 1, CNST_LIMB(2));\n      ASSERT_ALWAYS (wp[0] == 702);\n      ASSERT_ALWAYS (r == 0);\n    }\n\n#if HAVE_NATIVE_mpn_copyd\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 123;\n      xp[1] = 456;\n      mpn_copyd (xp+1, xp, (mp_size_t) 1);\n      ASSERT_ALWAYS (xp[1] == 123);\n    }\n#endif\n\n#if HAVE_NATIVE_mpn_copyi\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 123;\n      xp[1] = 456;\n      mpn_copyi (xp, xp+1, (mp_size_t) 1);\n      ASSERT_ALWAYS (xp[0] == 456);\n    }\n#endif\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 1605;\n      mpn_divexact_1 (wp, xp, (mp_size_t) 1, CNST_LIMB(5));\n      ASSERT_ALWAYS (wp[0] == 321);\n    }\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 1296;\n      r = mpn_divexact_by3c (wp, xp, (mp_size_t) 1, CNST_LIMB(0));\n      ASSERT_ALWAYS (wp[0] == 432);\n      ASSERT_ALWAYS (r == 0);\n    }\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 287;\n      r = mpn_divrem_1 (wp, (mp_size_t) 1, xp, (mp_size_t) 1, CNST_LIMB(7));\n      ASSERT_ALWAYS (wp[1] == 41);\n      ASSERT_ALWAYS (wp[0] == 0);\n      ASSERT_ALWAYS (r == 0);\n    }\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 12;\n      r = mpn_gcd_1 (xp, (mp_size_t) 1, CNST_LIMB(9));\n      ASSERT_ALWAYS (r == 3);\n    }\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 0x1001;\n      mpn_lshift (wp, xp, (mp_size_t) 1, 1);\n      ASSERT_ALWAYS (wp[0] == 0x2002);\n    }\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 14;\n      r = mpn_mod_1 (xp, (mp_size_t) 1, CNST_LIMB(4));\n      ASSERT_ALWAYS (r == 2);\n    }\n\n#if (GMP_NUMB_BITS % 4) == 0\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      int  bits = (GMP_NUMB_BITS / 4) * 3;\n      mp_limb_t  mod = (CNST_LIMB(1) << bits) - 1;\n      mp_limb_t  want = GMP_NUMB_MAX % mod;\n      xp[0] = GMP_NUMB_MAX;\n      r = mpn_mod_34lsub1 (xp, (mp_size_t) 1);\n      ASSERT_ALWAYS (r % mod == want);\n    }\n#endif\n\n  /*   DECL_modexact_1c_odd ((*modexact_1c_odd)); */\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 14;\n      r = mpn_mul_1 (wp, xp, (mp_size_t) 1, CNST_LIMB(4));\n      ASSERT_ALWAYS (wp[0] == 56);\n      ASSERT_ALWAYS (r == 0);\n    }\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 5;\n      yp[0] = 7;\n      mpn_mul_basecase (wp, xp, (mp_size_t) 1, yp, (mp_size_t) 1);\n      ASSERT_ALWAYS (wp[0] == 35);\n      ASSERT_ALWAYS (wp[1] == 0);\n    }\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 5;\n      yp[0] = 7;\n      mpn_mullo_basecase (wp, xp, yp, (mp_size_t) 1);\n      ASSERT_ALWAYS (wp[0] == 35);\n    }\n\n#if HAVE_NATIVE_mpn_preinv_divrem_1 && GMP_NAIL_BITS == 0\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 0x101;\n      r = mpn_preinv_divrem_1 (wp, (mp_size_t) 1, xp, (mp_size_t) 1,\n                               GMP_LIMB_HIGHBIT,\n                               refmpn_invert_limb (GMP_LIMB_HIGHBIT), 0);\n      ASSERT_ALWAYS (wp[0] == 0x202);\n      ASSERT_ALWAYS (wp[1] == 0);\n      ASSERT_ALWAYS (r == 0);\n    }\n#endif\n\n#if GMP_NAIL_BITS == 0\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = GMP_LIMB_HIGHBIT+123;\n      r = mpn_preinv_mod_1 (xp, (mp_size_t) 1, GMP_LIMB_HIGHBIT,\n                            refmpn_invert_limb (GMP_LIMB_HIGHBIT));\n      ASSERT_ALWAYS (r == 123);\n    }\n#endif\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 0x8008;\n      mpn_rshift (wp, xp, (mp_size_t) 1, 1);\n      ASSERT_ALWAYS (wp[0] == 0x4004);\n    }\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 5;\n      mpn_sqr_basecase (wp, xp, (mp_size_t) 1);\n      ASSERT_ALWAYS (wp[0] == 25);\n      ASSERT_ALWAYS (wp[1] == 0);\n    }\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 999;\n      yp[0] = 666;\n      mpn_sub_n (wp, xp, yp, (mp_size_t) 1);\n      ASSERT_ALWAYS (wp[0] == 333);\n    }\n\n  memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));\n  for (i = 0; i < 2; i++)\n    {\n      xp[0] = 123;\n      wp[0] = 456;\n      r = mpn_submul_1 (wp, xp, (mp_size_t) 1, CNST_LIMB(2));\n      ASSERT_ALWAYS (wp[0] == 210);\n      ASSERT_ALWAYS (r == 0);\n    }\n}",
      "lines": 202,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_thresholds": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "void\ncheck_thresholds (void)\n{\n#define ITERATE(name,field)                                             \\\n  do {                                                                  \\\n    __gmpn_cpuvec_initialized = 0;\t\t\t\t\t\\\n    memcpy (&__gmpn_cpuvec, &initial_cpuvec, sizeof (__gmpn_cpuvec));   \\\n    ASSERT_ALWAYS (name != 0);                                          \\\n    ASSERT_ALWAYS (name == __gmpn_cpuvec.field);                        \\\n    ASSERT_ALWAYS (__gmpn_cpuvec_initialized);                          \\\n  } while (0)\n\n  ITERATE_FAT_THRESHOLDS ();\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "int\nmain (void)\n{\n  memcpy (&initial_cpuvec, &__gmpn_cpuvec, sizeof (__gmpn_cpuvec));\n\n  tests_start ();\n\n  check_functions ();\n  check_thresholds ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-get_d.c": {
    "check_onebit": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "void\ncheck_onebit (void)\n{\n  static const int bit_table[] = {\n    0, 1, 2, 3,\n    GMP_NUMB_BITS - 2, GMP_NUMB_BITS - 1,\n    GMP_NUMB_BITS,\n    GMP_NUMB_BITS + 1, GMP_NUMB_BITS + 2,\n    2 * GMP_NUMB_BITS - 2, 2 * GMP_NUMB_BITS - 1,\n    2 * GMP_NUMB_BITS,\n    2 * GMP_NUMB_BITS + 1, 2 * GMP_NUMB_BITS + 2,\n    3 * GMP_NUMB_BITS - 2, 3 * GMP_NUMB_BITS - 1,\n    3 * GMP_NUMB_BITS,\n    3 * GMP_NUMB_BITS + 1, 3 * GMP_NUMB_BITS + 2,\n    4 * GMP_NUMB_BITS - 2, 4 * GMP_NUMB_BITS - 1,\n    4 * GMP_NUMB_BITS,\n    4 * GMP_NUMB_BITS + 1, 4 * GMP_NUMB_BITS + 2,\n    5 * GMP_NUMB_BITS - 2, 5 * GMP_NUMB_BITS - 1,\n    5 * GMP_NUMB_BITS,\n    5 * GMP_NUMB_BITS + 1, 5 * GMP_NUMB_BITS + 2,\n    6 * GMP_NUMB_BITS - 2, 6 * GMP_NUMB_BITS - 1,\n    6 * GMP_NUMB_BITS,\n    6 * GMP_NUMB_BITS + 1, 6 * GMP_NUMB_BITS + 2,\n  };\n  static const int exp_table[] = {\n    0, -100, -10, -1, 1, 10, 100,\n  };\n\n  /* FIXME: It'd be better to base this on the float format. */\n#if defined (__vax) || defined (__vax__)\n  int     limit = 127;  /* vax fp numbers have limited range */\n#else\n  int     limit = 511;\n#endif\n\n  int        bit_i, exp_i, i;\n  double     got, want;\n  mp_size_t  nsize, sign;\n  long       bit, exp, want_bit;\n  mp_limb_t  np[20];\n\n  for (bit_i = 0; bit_i < numberof (bit_table); bit_i++)\n    {\n      bit = bit_table[bit_i];\n\n      nsize = BITS_TO_LIMBS (bit+1);\n      refmpn_zero (np, nsize);\n      np[bit/GMP_NUMB_BITS] = CNST_LIMB(1) << (bit % GMP_NUMB_BITS);\n\n      for (exp_i = 0; exp_i < numberof (exp_table); exp_i++)\n        {\n          exp = exp_table[exp_i];\n\n          want_bit = bit + exp;\n          if (want_bit >= limit || want_bit <= -limit)\n            continue;\n\n          want = 1.0;\n          for (i = 0; i < want_bit; i++)\n            want *= 2.0;\n          for (i = 0; i > want_bit; i--)\n            want *= 0.5;\n\n          for (sign = 0; sign >= -1; sign--, want = -want)\n            {\n              got = mpn_get_d (np, nsize, sign, exp);\n              if (got != want)\n                {\n                  printf    (\"mpn_get_d wrong on 2^n\\n\");\n                  printf    (\"   bit      %ld\\n\", bit);\n                  printf    (\"   exp      %ld\\n\", exp);\n                  printf    (\"   want_bit %ld\\n\", want_bit);\n                  printf    (\"   sign     %ld\\n\", (long) sign);\n                  mpn_trace (\"   n        \", np, nsize);\n                  printf    (\"   nsize    %ld\\n\", (long) nsize);\n                  d_trace   (\"   want     \", want);\n                  d_trace   (\"   got      \", got);\n                  abort();\n                }\n            }\n        }\n    }\n}",
      "lines": 83,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "check_twobit": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\ncheck_twobit (void)\n{\n  int        i, mant_bits;\n  double     got, want;\n  mp_size_t  nsize, sign;\n  mp_ptr     np;\n\n  mant_bits = tests_dbl_mant_bits ();\n  if (mant_bits == 0)\n    return;\n\n  np = refmpn_malloc_limbs (BITS_TO_LIMBS (mant_bits));\n  want = 3.0;\n  for (i = 1; i < mant_bits; i++)\n    {\n      nsize = BITS_TO_LIMBS (i+1);\n      refmpn_zero (np, nsize);\n      np[i/GMP_NUMB_BITS] = CNST_LIMB(1) << (i % GMP_NUMB_BITS);\n      np[0] |= 1;\n\n      for (sign = 0; sign >= -1; sign--)\n        {\n          got = mpn_get_d (np, nsize, sign, 0);\n          if (got != want)\n            {\n              printf    (\"mpn_get_d wrong on 2^%d + 1\\n\", i);\n              printf    (\"   sign     %ld\\n\", (long) sign);\n              mpn_trace (\"   n        \", np, nsize);\n              printf    (\"   nsize    %ld\\n\", (long) nsize);\n              d_trace   (\"   want     \", want);\n              d_trace   (\"   got      \", got);\n              abort();\n            }\n          want = -want;\n        }\n\n      want = 2.0 * want - 1.0;\n    }\n\n  free (np);\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "check_underflow": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "void\ncheck_underflow (void)\n{\n  static const long exp_table[] = {\n    -999999L, LONG_MIN,\n  };\n  static const mp_limb_t  np[1] = { 1 };\n\n  static long exp;\n  mp_size_t  nsize, sign;\n  double     got;\n  int        exp_i;\n\n  nsize = numberof (np);\n\n  if (tests_setjmp_sigfpe() == 0)\n    {\n      for (exp_i = 0; exp_i < numberof (exp_table); exp_i++)\n        {\n          exp = exp_table[exp_i];\n\n          for (sign = 0; sign >= -1; sign--)\n            {\n              got = mpn_get_d (np, nsize, sign, exp);\n              if (got != 0.0)\n                {\n                  printf  (\"mpn_get_d wrong, didn't get 0.0 on underflow\\n\");\n                  printf  (\"  nsize    %ld\\n\", (long) nsize);\n                  printf  (\"  exp      %ld\\n\", exp);\n                  printf  (\"  sign     %ld\\n\", (long) sign);\n                  d_trace (\"  got      \", got);\n                  abort ();\n                }\n            }\n        }\n    }\n  else\n    {\n      printf (\"Warning, underflow to zero tests skipped due to SIGFPE (exp=%ld)\\n\", exp);\n    }\n  tests_sigfpe_done ();\n}",
      "lines": 42,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "check_inf": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "void\ncheck_inf (void)\n{\n  static const long exp_table[] = {\n    999999L, LONG_MAX,\n  };\n  static const mp_limb_t  np[4] = { 1, 1, 1, 1 };\n  long       exp;\n  mp_size_t  nsize, sign, got_sign;\n  double     got;\n  int        exp_i;\n\n  if (! _GMP_IEEE_FLOATS)\n    return;\n\n  for (nsize = 1; nsize <= numberof (np); nsize++)\n    {\n      for (exp_i = 0; exp_i < numberof (exp_table); exp_i++)\n        {\n          exp = exp_table[exp_i];\n\n          for (sign = 0; sign >= -1; sign--)\n            {\n              got = mpn_get_d (np, nsize, sign, exp);\n              got_sign = (got >= 0 ? 0 : -1);\n              if (! tests_isinf (got))\n                {\n                  printf  (\"mpn_get_d wrong, didn't get infinity\\n\");\n                bad:\n                  printf  (\"  nsize    %ld\\n\", (long) nsize);\n                  printf  (\"  exp      %ld\\n\", exp);\n                  printf  (\"  sign     %ld\\n\", (long) sign);\n                  d_trace (\"  got      \", got);\n                  printf  (\"  got sign %ld\\n\", (long) got_sign);\n                  abort ();\n                }\n              if (got_sign != sign)\n                {\n                  printf  (\"mpn_get_d wrong sign on infinity\\n\");\n                  goto bad;\n                }\n            }\n        }\n    }\n}",
      "lines": 45,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "check_ieee_denorm": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "void\ncheck_ieee_denorm (void)\n{\n  static long exp;\n  mp_limb_t  n = 1;\n  long       i;\n  mp_size_t  sign;\n  double     want, got;\n\n  if (! _GMP_IEEE_FLOATS)\n    return;\n\n  if (tests_setjmp_sigfpe() == 0)\n    {\n      exp = -1020;\n      want = 1.0;\n      for (i = 0; i > exp; i--)\n        want *= 0.5;\n\n      for ( ; exp > -1500 && want != 0.0; exp--)\n        {\n          for (sign = 0; sign >= -1; sign--)\n            {\n              got = mpn_get_d (&n, (mp_size_t) 1, sign, exp);\n              if (got != want)\n                {\n                  printf  (\"mpn_get_d wrong on denorm\\n\");\n                  printf  (\"  n=1\\n\");\n                  printf  (\"  exp   %ld\\n\", exp);\n                  printf  (\"  sign  %ld\\n\", (long) sign);\n                  d_trace (\"  got   \", got);\n                  d_trace (\"  want  \", want);\n                  abort ();\n                }\n              want = -want;\n            }\n          want *= 0.5;\n          FORCE_DOUBLE (want);\n        }\n    }\n  else\n    {\n      printf (\"Warning, IEEE denorm tests skipped due to SIGFPE (exp=%ld)\\n\", exp);\n    }\n  tests_sigfpe_done ();\n}",
      "lines": 46,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "check_ieee_overflow": {
      "start_point": [
        315,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "void\ncheck_ieee_overflow (void)\n{\n  static long exp;\n  mp_limb_t  n = 1;\n  long       i;\n  mp_size_t  sign;\n  double     want, got;\n\n  if (! _GMP_IEEE_FLOATS)\n    return;\n\n  if (tests_setjmp_sigfpe() == 0)\n    {\n      exp = 1010;\n      want = 1.0;\n      for (i = 0; i < exp; i++)\n        want *= 2.0;\n\n      for ( ; exp < 1050; exp++)\n        {\n          for (sign = 0; sign >= -1; sign--)\n            {\n              got = mpn_get_d (&n, (mp_size_t) 1, sign, exp);\n              if (got != want)\n                {\n                  printf  (\"mpn_get_d wrong on overflow\\n\");\n                  printf  (\"  n=1\\n\");\n                  printf  (\"  exp   %ld\\n\", exp);\n                  printf  (\"  sign  %ld\\n\", (long) sign);\n                  d_trace (\"  got   \", got);\n                  d_trace (\"  want  \", want);\n                  abort ();\n                }\n              want = -want;\n            }\n          want *= 2.0;\n          FORCE_DOUBLE (want);\n        }\n    }\n  else\n    {\n      printf (\"Warning, IEEE overflow tests skipped due to SIGFPE (exp=%ld)\\n\", exp);\n    }\n  tests_sigfpe_done ();\n}",
      "lines": 46,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "check_0x81c25113": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\ncheck_0x81c25113 (void)\n{\n#if GMP_NUMB_BITS >= 32\n  double     want = 2176995603.0;\n  double     got;\n  mp_limb_t  np[4];\n  mp_size_t  nsize;\n  long       exp;\n\n  if (tests_dbl_mant_bits() < 32)\n    return;\n\n  for (nsize = 1; nsize <= numberof (np); nsize++)\n    {\n      refmpn_zero (np, nsize-1);\n      np[nsize-1] = CNST_LIMB(0x81c25113);\n      exp = - (nsize-1) * GMP_NUMB_BITS;\n      got = mpn_get_d (np, nsize, (mp_size_t) 0, exp);\n      if (got != want)\n        {\n          printf  (\"mpn_get_d wrong on 2176995603 (0x81c25113)\\n\");\n          printf  (\"  nsize  %ld\\n\", (long) nsize);\n          printf  (\"  exp    %ld\\n\", exp);\n          d_trace (\"  got    \", got);\n          d_trace (\"  want   \", want);\n          abort ();\n        }\n    }\n#endif\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "check_rand": {
      "start_point": [
        400,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "void\ncheck_rand (void)\n{\n  gmp_randstate_ptr rands = RANDS;\n  int            rep, i;\n  unsigned long  mant_bits;\n  long           exp, exp_min, exp_max;\n  double         got, want, d;\n  mp_size_t      nalloc, nsize, sign;\n  mp_limb_t      nhigh_mask;\n  mp_ptr         np;\n\n  mant_bits = tests_dbl_mant_bits ();\n  if (mant_bits == 0)\n    return;\n\n  /* Allow for vax D format with exponent 127 to -128 only.\n     FIXME: Do something to probe for a valid exponent range.  */\n  exp_min = -100 - mant_bits;\n  exp_max =  100 - mant_bits;\n\n  /* space for mant_bits */\n  nalloc = BITS_TO_LIMBS (mant_bits);\n  np = refmpn_malloc_limbs (nalloc);\n  nhigh_mask = MP_LIMB_T_MAX\n    >> (GMP_NAIL_BITS + nalloc * GMP_NUMB_BITS - mant_bits);\n\n  for (rep = 0; rep < 200; rep++)\n    {\n      /* random exp_min to exp_max, inclusive */\n      exp = exp_min + (long) gmp_urandomm_ui (rands, exp_max - exp_min + 1);\n\n      /* mant_bits worth of random at np */\n      if (rep & 1)\n        mpn_random (np, nalloc);\n      else\n        mpn_random2 (np, nalloc);\n      nsize = nalloc;\n      np[nsize-1] &= nhigh_mask;\n      MPN_NORMALIZE (np, nsize);\n      if (nsize == 0)\n        continue;\n\n      sign = (mp_size_t) gmp_urandomb_ui (rands, 1L) - 1;\n\n      /* want = {np,nsize}, converting one bit at a time */\n      want = 0.0;\n      for (i = 0, d = 1.0; i < mant_bits; i++, d *= 2.0)\n        if (np[i/GMP_NUMB_BITS] & (CNST_LIMB(1) << (i%GMP_NUMB_BITS)))\n          want += d;\n      if (sign < 0)\n        want = -want;\n\n      /* want = want * 2^exp */\n      for (i = 0; i < exp; i++)\n        want *= 2.0;\n      for (i = 0; i > exp; i--)\n        want *= 0.5;\n\n      got = mpn_get_d (np, nsize, sign, exp);\n\n      if (got != want)\n        {\n          printf    (\"mpn_get_d wrong on random data\\n\");\n          printf    (\"   sign     %ld\\n\", (long) sign);\n          mpn_trace (\"   n        \", np, nsize);\n          printf    (\"   nsize    %ld\\n\", (long) nsize);\n          printf    (\"   exp      %ld\\n\", exp);\n          d_trace   (\"   want     \", want);\n          d_trace   (\"   got      \", got);\n          abort();\n        }\n    }\n\n  free (np);\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        478,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_onebit ();\n  check_twobit ();\n  check_inf ();\n  check_underflow ();\n  check_ieee_denorm ();\n  check_ieee_overflow ();\n  check_0x81c25113 ();\n#if ! (defined (__vax) || defined (__vax__))\n  check_rand ();\n#endif\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-hgcd.c": {
    "main": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t op1, op2, temp1, temp2;\n  int i, j, chain_len;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long size_range;\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (bs);\n  mpz_init (op1);\n  mpz_init (op2);\n  mpz_init (temp1);\n  mpz_init (temp2);\n\n  for (i = 0; hgcd_values[i].res >= 0; i++)\n    {\n      mp_size_t res;\n\n      mpz_set_str (op1, hgcd_values[i].a, 0);\n      mpz_set_str (op2, hgcd_values[i].b, 0);\n\n      res = one_test (op1, op2, -1-i);\n      if (res != hgcd_values[i].res)\n\t{\n\t  fprintf (stderr, \"ERROR in test %d\\n\", -1-i);\n\t  fprintf (stderr, \"Bad return code from hgcd\\n\");\n\t  fprintf (stderr, \"op1=\");                 debug_mp (op1, -16);\n\t  fprintf (stderr, \"op2=\");                 debug_mp (op2, -16);\n\t  fprintf (stderr, \"expected: %d\\n\", hgcd_values[i].res);\n\t  fprintf (stderr, \"hgcd:     %d\\n\", (int) res);\n\t  abort ();\n\t}\n    }\n\n  for (i = 0; i < 15; i++)\n    {\n      /* Generate plain operands with unknown gcd.  These types of operands\n\t have proven to trigger certain bugs in development versions of the\n\t gcd code. */\n\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 13 + 2;\n\n      mpz_urandomb (bs, rands, size_range);\n      mpz_rrandomb (op1, rands, mpz_get_ui (bs) + MIN_OPERAND_SIZE);\n      mpz_urandomb (bs, rands, size_range);\n      mpz_rrandomb (op2, rands, mpz_get_ui (bs) + MIN_OPERAND_SIZE);\n\n      if (mpz_cmp (op1, op2) < 0)\n\tmpz_swap (op1, op2);\n\n      if (mpz_size (op1) > 0)\n\tone_test (op1, op2, i);\n\n      /* Generate a division chain backwards, allowing otherwise\n\t unlikely huge quotients.  */\n\n      mpz_set_ui (op1, 0);\n      mpz_urandomb (bs, rands, 32);\n      mpz_urandomb (bs, rands, mpz_get_ui (bs) % 16 + 1);\n      mpz_rrandomb (op2, rands, mpz_get_ui (bs));\n      mpz_add_ui (op2, op2, 1);\n\n#if 0\n      chain_len = 1000000;\n#else\n      mpz_urandomb (bs, rands, 32);\n      chain_len = mpz_get_ui (bs) % (GMP_NUMB_BITS * GCD_DC_THRESHOLD / 256);\n#endif\n\n      for (j = 0; j < chain_len; j++)\n\t{\n\t  mpz_urandomb (bs, rands, 32);\n\t  mpz_urandomb (bs, rands, mpz_get_ui (bs) % 12 + 1);\n\t  mpz_rrandomb (temp2, rands, mpz_get_ui (bs) + 1);\n\t  mpz_add_ui (temp2, temp2, 1);\n\t  mpz_mul (temp1, op2, temp2);\n\t  mpz_add (op1, op1, temp1);\n\n\t  /* Don't generate overly huge operands.  */\n\t  if (SIZ (op1) > 3 * GCD_DC_THRESHOLD)\n\t    break;\n\n\t  mpz_urandomb (bs, rands, 32);\n\t  mpz_urandomb (bs, rands, mpz_get_ui (bs) % 12 + 1);\n\t  mpz_rrandomb (temp2, rands, mpz_get_ui (bs) + 1);\n\t  mpz_add_ui (temp2, temp2, 1);\n\t  mpz_mul (temp1, op1, temp2);\n\t  mpz_add (op2, op2, temp1);\n\n\t  /* Don't generate overly huge operands.  */\n\t  if (SIZ (op2) > 3 * GCD_DC_THRESHOLD)\n\t    break;\n\t}\n      if (mpz_cmp (op1, op2) < 0)\n\tmpz_swap (op1, op2);\n\n      if (mpz_size (op1) > 0)\n\tone_test (op1, op2, i);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (op1);\n  mpz_clear (op2);\n  mpz_clear (temp1);\n  mpz_clear (temp2);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "debug_mp": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "one_test": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "static mp_size_t\none_test (mpz_t a, mpz_t b, int i)\n{\n  struct hgcd_matrix hgcd;\n  struct hgcd_ref ref;\n\n  mpz_t ref_r0;\n  mpz_t ref_r1;\n  mpz_t hgcd_r0;\n  mpz_t hgcd_r1;\n\n  mp_size_t res[2];\n  mp_size_t asize;\n  mp_size_t bsize;\n\n  mp_size_t hgcd_init_scratch;\n  mp_size_t hgcd_scratch;\n\n  mp_ptr hgcd_init_tp;\n  mp_ptr hgcd_tp;\n\n  asize = a->_mp_size;\n  bsize = b->_mp_size;\n\n  ASSERT (asize >= bsize);\n\n  hgcd_init_scratch = MPN_HGCD_MATRIX_INIT_ITCH (asize);\n  hgcd_init_tp = refmpn_malloc_limbs (hgcd_init_scratch);\n  mpn_hgcd_matrix_init (&hgcd, asize, hgcd_init_tp);\n\n  hgcd_scratch = mpn_hgcd_itch (asize);\n  hgcd_tp = refmpn_malloc_limbs (hgcd_scratch);\n\n#if 0\n  fprintf (stderr,\n\t   \"one_test: i = %d asize = %d, bsize = %d\\n\",\n\t   i, a->_mp_size, b->_mp_size);\n\n  gmp_fprintf (stderr,\n\t       \"one_test: i = %d\\n\"\n\t       \"  a = %Zx\\n\"\n\t       \"  b = %Zx\\n\",\n\t       i, a, b);\n#endif\n  hgcd_ref_init (&ref);\n\n  mpz_init_set (ref_r0, a);\n  mpz_init_set (ref_r1, b);\n  res[0] = hgcd_ref (&ref, ref_r0, ref_r1);\n\n  mpz_init_set (hgcd_r0, a);\n  mpz_init_set (hgcd_r1, b);\n  if (bsize < asize)\n    {\n      _mpz_realloc (hgcd_r1, asize);\n      MPN_ZERO (hgcd_r1->_mp_d + bsize, asize - bsize);\n    }\n  res[1] = mpn_hgcd (hgcd_r0->_mp_d,\n\t\t     hgcd_r1->_mp_d,\n\t\t     asize,\n\t\t     &hgcd, hgcd_tp);\n\n  if (res[0] != res[1])\n    {\n      fprintf (stderr, \"ERROR in test %d\\n\", i);\n      fprintf (stderr, \"Different return value from hgcd and hgcd_ref\\n\");\n      fprintf (stderr, \"op1=\");                 debug_mp (a, -16);\n      fprintf (stderr, \"op2=\");                 debug_mp (b, -16);\n      fprintf (stderr, \"hgcd_ref: %ld\\n\", (long) res[0]);\n      fprintf (stderr, \"mpn_hgcd: %ld\\n\", (long) res[1]);\n      abort ();\n    }\n  if (res[0] > 0)\n    {\n      if (!hgcd_ref_equal (&hgcd, &ref)\n\t  || !mpz_mpn_equal (ref_r0, hgcd_r0->_mp_d, res[1])\n\t  || !mpz_mpn_equal (ref_r1, hgcd_r1->_mp_d, res[1]))\n\t{\n\t  fprintf (stderr, \"ERROR in test %d\\n\", i);\n\t  fprintf (stderr, \"mpn_hgcd and hgcd_ref returned different values\\n\");\n\t  fprintf (stderr, \"op1=\");                 debug_mp (a, -16);\n\t  fprintf (stderr, \"op2=\");                 debug_mp (b, -16);\n\t  abort ();\n\t}\n    }\n\n  refmpn_free_limbs (hgcd_init_tp);\n  refmpn_free_limbs (hgcd_tp);\n  hgcd_ref_clear (&ref);\n  mpz_clear (ref_r0);\n  mpz_clear (ref_r1);\n  mpz_clear (hgcd_r0);\n  mpz_clear (hgcd_r1);\n\n  return res[0];\n}",
      "lines": 96,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "hgcd_ref_init": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "static void\nhgcd_ref_init (struct hgcd_ref *hgcd)\n{\n  unsigned i;\n  for (i = 0; i<2; i++)\n    {\n      unsigned j;\n      for (j = 0; j<2; j++)\n\tmpz_init (hgcd->m[i][j]);\n    }\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hgcd_ref_clear": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static void\nhgcd_ref_clear (struct hgcd_ref *hgcd)\n{\n  unsigned i;\n  for (i = 0; i<2; i++)\n    {\n      unsigned j;\n      for (j = 0; j<2; j++)\n\tmpz_clear (hgcd->m[i][j]);\n    }\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sdiv_qr": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "static int\nsdiv_qr (mpz_t q, mpz_t r, mp_size_t s, const mpz_t a, const mpz_t b)\n{\n  mpz_fdiv_qr (q, r, a, b);\n  if (mpz_size (r) <= s)\n    {\n      mpz_add (r, r, b);\n      mpz_sub_ui (q, q, 1);\n    }\n\n  return (mpz_sgn (q) > 0);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hgcd_ref": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "static int\nhgcd_ref (struct hgcd_ref *hgcd, mpz_t a, mpz_t b)\n{\n  mp_size_t n = MAX (mpz_size (a), mpz_size (b));\n  mp_size_t s = n/2 + 1;\n  mp_size_t asize;\n  mp_size_t bsize;\n  mpz_t q;\n  int res;\n\n  if (mpz_size (a) <= s || mpz_size (b) <= s)\n    return 0;\n\n  res = mpz_cmp (a, b);\n  if (res < 0)\n    {\n      mpz_sub (b, b, a);\n      if (mpz_size (b) <= s)\n\treturn 0;\n\n      mpz_set_ui (hgcd->m[0][0], 1); mpz_set_ui (hgcd->m[0][1], 0);\n      mpz_set_ui (hgcd->m[1][0], 1); mpz_set_ui (hgcd->m[1][1], 1);\n    }\n  else if (res > 0)\n    {\n      mpz_sub (a, a, b);\n      if (mpz_size (a) <= s)\n\treturn 0;\n\n      mpz_set_ui (hgcd->m[0][0], 1); mpz_set_ui (hgcd->m[0][1], 1);\n      mpz_set_ui (hgcd->m[1][0], 0); mpz_set_ui (hgcd->m[1][1], 1);\n    }\n  else\n    return 0;\n\n  mpz_init (q);\n\n  for (;;)\n    {\n      ASSERT (mpz_size (a) > s);\n      ASSERT (mpz_size (b) > s);\n\n      if (mpz_cmp (a, b) > 0)\n\t{\n\t  if (!sdiv_qr (q, a, s, a, b))\n\t    break;\n\t  mpz_addmul (hgcd->m[0][1], q, hgcd->m[0][0]);\n\t  mpz_addmul (hgcd->m[1][1], q, hgcd->m[1][0]);\n\t}\n      else\n\t{\n\t  if (!sdiv_qr (q, b, s, b, a))\n\t    break;\n\t  mpz_addmul (hgcd->m[0][0], q, hgcd->m[0][1]);\n\t  mpz_addmul (hgcd->m[1][0], q, hgcd->m[1][1]);\n\t}\n    }\n\n  mpz_clear (q);\n\n  asize = mpz_size (a);\n  bsize = mpz_size (b);\n  return MAX (asize, bsize);\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpz_mpn_equal": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "static int\nmpz_mpn_equal (const mpz_t a, mp_srcptr bp, mp_size_t bsize)\n{\n  mp_srcptr ap = a->_mp_d;\n  mp_size_t asize = a->_mp_size;\n\n  MPN_NORMALIZE (bp, bsize);\n  return asize == bsize && mpn_cmp (ap, bp, asize) == 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hgcd_ref_equal": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        406,
        1
      ],
      "content": "static int\nhgcd_ref_equal (const struct hgcd_matrix *hgcd, const struct hgcd_ref *ref)\n{\n  unsigned i;\n\n  for (i = 0; i<2; i++)\n    {\n      unsigned j;\n\n      for (j = 0; j<2; j++)\n\tif (!mpz_mpn_equal (ref->m[i][j], hgcd->p[i][j], hgcd->n))\n\t  return 0;\n    }\n\n  return 1;\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-hgcd_appr.c": {
    "main": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t op1, op2, temp1, temp2;\n  int i, j, chain_len;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long size_range;\n\n  if (argc > 1)\n    {\n      if (strcmp (argv[1], \"-v\") == 0)\n\tverbose_flag = 1;\n      else\n\t{\n\t  fprintf (stderr, \"Invalid argument.\\n\");\n\t  return 1;\n\t}\n    }\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (bs);\n  mpz_init (op1);\n  mpz_init (op2);\n  mpz_init (temp1);\n  mpz_init (temp2);\n\n  for (i = 0; i < 15; i++)\n    {\n      /* Generate plain operands with unknown gcd.  These types of operands\n\t have proven to trigger certain bugs in development versions of the\n\t gcd code. */\n\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 13 + 2;\n\n      mpz_urandomb (bs, rands, size_range);\n      mpz_urandomb (op1, rands, mpz_get_ui (bs) + MIN_OPERAND_SIZE);\n      mpz_urandomb (bs, rands, size_range);\n      mpz_urandomb (op2, rands, mpz_get_ui (bs) + MIN_OPERAND_SIZE);\n\n      if (mpz_cmp (op1, op2) < 0)\n\tmpz_swap (op1, op2);\n\n      if (mpz_size (op1) > 0)\n\tone_test (op1, op2, i);\n\n      /* Generate a division chain backwards, allowing otherwise\n\t unlikely huge quotients.  */\n\n      mpz_set_ui (op1, 0);\n      mpz_urandomb (bs, rands, 32);\n      mpz_urandomb (bs, rands, mpz_get_ui (bs) % 16 + 1);\n      mpz_rrandomb (op2, rands, mpz_get_ui (bs));\n      mpz_add_ui (op2, op2, 1);\n\n#if 0\n      chain_len = 1000000;\n#else\n      mpz_urandomb (bs, rands, 32);\n      chain_len = mpz_get_ui (bs) % (GMP_NUMB_BITS * GCD_DC_THRESHOLD / 256);\n#endif\n\n      for (j = 0; j < chain_len; j++)\n\t{\n\t  mpz_urandomb (bs, rands, 32);\n\t  mpz_urandomb (bs, rands, mpz_get_ui (bs) % 12 + 1);\n\t  mpz_rrandomb (temp2, rands, mpz_get_ui (bs) + 1);\n\t  mpz_add_ui (temp2, temp2, 1);\n\t  mpz_mul (temp1, op2, temp2);\n\t  mpz_add (op1, op1, temp1);\n\n\t  /* Don't generate overly huge operands.  */\n\t  if (SIZ (op1) > 3 * GCD_DC_THRESHOLD)\n\t    break;\n\n\t  mpz_urandomb (bs, rands, 32);\n\t  mpz_urandomb (bs, rands, mpz_get_ui (bs) % 12 + 1);\n\t  mpz_rrandomb (temp2, rands, mpz_get_ui (bs) + 1);\n\t  mpz_add_ui (temp2, temp2, 1);\n\t  mpz_mul (temp1, op1, temp2);\n\t  mpz_add (op2, op2, temp1);\n\n\t  /* Don't generate overly huge operands.  */\n\t  if (SIZ (op2) > 3 * GCD_DC_THRESHOLD)\n\t    break;\n\t}\n      if (mpz_cmp (op1, op2) < 0)\n\tmpz_swap (op1, op2);\n\n      if (mpz_size (op1) > 0)\n\tone_test (op1, op2, i);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (op1);\n  mpz_clear (op2);\n  mpz_clear (temp1);\n  mpz_clear (temp2);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 105,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "debug_mp": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "one_test": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static mp_size_t\none_test (mpz_t a, mpz_t b, int i)\n{\n  struct hgcd_matrix hgcd;\n  struct hgcd_ref ref;\n\n  mpz_t ref_r0;\n  mpz_t ref_r1;\n  mpz_t hgcd_r0;\n  mpz_t hgcd_r1;\n\n  int res[2];\n  mp_size_t asize;\n  mp_size_t bsize;\n\n  mp_size_t hgcd_init_scratch;\n  mp_size_t hgcd_scratch;\n\n  mp_ptr hgcd_init_tp;\n  mp_ptr hgcd_tp;\n  mp_limb_t marker[4];\n\n  asize = a->_mp_size;\n  bsize = b->_mp_size;\n\n  ASSERT (asize >= bsize);\n\n  hgcd_init_scratch = MPN_HGCD_MATRIX_INIT_ITCH (asize);\n  hgcd_init_tp = refmpn_malloc_limbs (hgcd_init_scratch + 2) + 1;\n  mpn_hgcd_matrix_init (&hgcd, asize, hgcd_init_tp);\n\n  hgcd_scratch = mpn_hgcd_appr_itch (asize);\n  hgcd_tp = refmpn_malloc_limbs (hgcd_scratch + 2) + 1;\n\n  mpn_random (marker, 4);\n\n  hgcd_init_tp[-1] = marker[0];\n  hgcd_init_tp[hgcd_init_scratch] = marker[1];\n  hgcd_tp[-1] = marker[2];\n  hgcd_tp[hgcd_scratch] = marker[3];\n\n#if 0\n  fprintf (stderr,\n\t   \"one_test: i = %d asize = %d, bsize = %d\\n\",\n\t   i, a->_mp_size, b->_mp_size);\n\n  gmp_fprintf (stderr,\n\t       \"one_test: i = %d\\n\"\n\t       \"  a = %Zx\\n\"\n\t       \"  b = %Zx\\n\",\n\t       i, a, b);\n#endif\n  hgcd_ref_init (&ref);\n\n  mpz_init_set (ref_r0, a);\n  mpz_init_set (ref_r1, b);\n  res[0] = hgcd_ref (&ref, ref_r0, ref_r1);\n\n  mpz_init_set (hgcd_r0, a);\n  mpz_init_set (hgcd_r1, b);\n  if (bsize < asize)\n    {\n      _mpz_realloc (hgcd_r1, asize);\n      MPN_ZERO (hgcd_r1->_mp_d + bsize, asize - bsize);\n    }\n  res[1] = mpn_hgcd_appr (hgcd_r0->_mp_d,\n\t\t\t  hgcd_r1->_mp_d,\n\t\t\t  asize,\n\t\t\t  &hgcd, hgcd_tp);\n\n  if (hgcd_init_tp[-1] != marker[0]\n      || hgcd_init_tp[hgcd_init_scratch] != marker[1]\n      || hgcd_tp[-1] != marker[2]\n      || hgcd_tp[hgcd_scratch] != marker[3])\n    {\n      fprintf (stderr, \"ERROR in test %d\\n\", i);\n      fprintf (stderr, \"scratch space overwritten!\\n\");\n\n      if (hgcd_init_tp[-1] != marker[0])\n\tgmp_fprintf (stderr,\n\t\t     \"before init_tp: %Mx\\n\"\n\t\t     \"expected: %Mx\\n\",\n\t\t     hgcd_init_tp[-1], marker[0]);\n      if (hgcd_init_tp[hgcd_init_scratch] != marker[1])\n\tgmp_fprintf (stderr,\n\t\t     \"after init_tp: %Mx\\n\"\n\t\t     \"expected: %Mx\\n\",\n\t\t     hgcd_init_tp[hgcd_init_scratch], marker[1]);\n      if (hgcd_tp[-1] != marker[2])\n\tgmp_fprintf (stderr,\n\t\t     \"before tp: %Mx\\n\"\n\t\t     \"expected: %Mx\\n\",\n\t\t     hgcd_tp[-1], marker[2]);\n      if (hgcd_tp[hgcd_scratch] != marker[3])\n\tgmp_fprintf (stderr,\n\t\t     \"after tp: %Mx\\n\"\n\t\t     \"expected: %Mx\\n\",\n\t\t     hgcd_tp[hgcd_scratch], marker[3]);\n\n      abort ();\n    }\n\n  if (!hgcd_appr_valid_p (a, b, res[0], &ref, ref_r0, ref_r1,\n\t\t\t  res[1], &hgcd))\n    {\n      fprintf (stderr, \"ERROR in test %d\\n\", i);\n      fprintf (stderr, \"Invalid results for hgcd and hgcd_ref\\n\");\n      fprintf (stderr, \"op1=\");                 debug_mp (a, -16);\n      fprintf (stderr, \"op2=\");                 debug_mp (b, -16);\n      fprintf (stderr, \"hgcd_ref: %ld\\n\", (long) res[0]);\n      fprintf (stderr, \"mpn_hgcd_appr: %ld\\n\", (long) res[1]);\n      abort ();\n    }\n\n  refmpn_free_limbs (hgcd_init_tp - 1);\n  refmpn_free_limbs (hgcd_tp - 1);\n  hgcd_ref_clear (&ref);\n  mpz_clear (ref_r0);\n  mpz_clear (ref_r1);\n  mpz_clear (hgcd_r0);\n  mpz_clear (hgcd_r1);\n\n  return res[0];\n}",
      "lines": 124,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "hgcd_ref_init": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static void\nhgcd_ref_init (struct hgcd_ref *hgcd)\n{\n  unsigned i;\n  for (i = 0; i<2; i++)\n    {\n      unsigned j;\n      for (j = 0; j<2; j++)\n\tmpz_init (hgcd->m[i][j]);\n    }\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hgcd_ref_clear": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "static void\nhgcd_ref_clear (struct hgcd_ref *hgcd)\n{\n  unsigned i;\n  for (i = 0; i<2; i++)\n    {\n      unsigned j;\n      for (j = 0; j<2; j++)\n\tmpz_clear (hgcd->m[i][j]);\n    }\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sdiv_qr": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "static int\nsdiv_qr (mpz_t q, mpz_t r, mp_size_t s, const mpz_t a, const mpz_t b)\n{\n  mpz_fdiv_qr (q, r, a, b);\n  if (mpz_size (r) <= s)\n    {\n      mpz_add (r, r, b);\n      mpz_sub_ui (q, q, 1);\n    }\n\n  return (mpz_sgn (q) > 0);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hgcd_ref": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static int\nhgcd_ref (struct hgcd_ref *hgcd, mpz_t a, mpz_t b)\n{\n  mp_size_t n = MAX (mpz_size (a), mpz_size (b));\n  mp_size_t s = n/2 + 1;\n  mpz_t q;\n  int res;\n\n  if (mpz_size (a) <= s || mpz_size (b) <= s)\n    return 0;\n\n  res = mpz_cmp (a, b);\n  if (res < 0)\n    {\n      mpz_sub (b, b, a);\n      if (mpz_size (b) <= s)\n\treturn 0;\n\n      mpz_set_ui (hgcd->m[0][0], 1); mpz_set_ui (hgcd->m[0][1], 0);\n      mpz_set_ui (hgcd->m[1][0], 1); mpz_set_ui (hgcd->m[1][1], 1);\n    }\n  else if (res > 0)\n    {\n      mpz_sub (a, a, b);\n      if (mpz_size (a) <= s)\n\treturn 0;\n\n      mpz_set_ui (hgcd->m[0][0], 1); mpz_set_ui (hgcd->m[0][1], 1);\n      mpz_set_ui (hgcd->m[1][0], 0); mpz_set_ui (hgcd->m[1][1], 1);\n    }\n  else\n    return 0;\n\n  mpz_init (q);\n\n  for (;;)\n    {\n      ASSERT (mpz_size (a) > s);\n      ASSERT (mpz_size (b) > s);\n\n      if (mpz_cmp (a, b) > 0)\n\t{\n\t  if (!sdiv_qr (q, a, s, a, b))\n\t    break;\n\t  mpz_addmul (hgcd->m[0][1], q, hgcd->m[0][0]);\n\t  mpz_addmul (hgcd->m[1][1], q, hgcd->m[1][0]);\n\t}\n      else\n\t{\n\t  if (!sdiv_qr (q, b, s, b, a))\n\t    break;\n\t  mpz_addmul (hgcd->m[0][0], q, hgcd->m[0][1]);\n\t  mpz_addmul (hgcd->m[1][0], q, hgcd->m[1][1]);\n\t}\n    }\n\n  mpz_clear (q);\n\n  return 1;\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hgcd_ref_equal": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "static int\nhgcd_ref_equal (const struct hgcd_ref *A, const struct hgcd_ref *B)\n{\n  unsigned i;\n\n  for (i = 0; i<2; i++)\n    {\n      unsigned j;\n\n      for (j = 0; j<2; j++)\n\tif (mpz_cmp (A->m[i][j], B->m[i][j]) != 0)\n\t  return 0;\n    }\n\n  return 1;\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hgcd_appr_valid_p": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "static int\nhgcd_appr_valid_p (mpz_t a, mpz_t b, mp_size_t res0,\n\t\t   struct hgcd_ref *ref, mpz_t ref_r0, mpz_t ref_r1,\n\t\t   mp_size_t res1, struct hgcd_matrix *hgcd)\n{\n  mp_size_t n = MAX (mpz_size (a), mpz_size (b));\n  mp_size_t s = n/2 + 1;\n\n  mp_bitcnt_t dbits, abits, margin;\n  mpz_t appr_r0, appr_r1, t, q;\n  struct hgcd_ref appr;\n\n  if (!res0)\n    {\n      if (!res1)\n\treturn 1;\n\n      fprintf (stderr, \"mpn_hgcd_appr returned 1 when no reduction possible.\\n\");\n      return 0;\n    }\n\n  /* NOTE: No *_clear calls on error return, since we're going to\n     abort anyway. */\n  mpz_init (t);\n  mpz_init (q);\n  hgcd_ref_init (&appr);\n  mpz_init (appr_r0);\n  mpz_init (appr_r1);\n\n  if (mpz_size (ref_r0) <= s)\n    {\n      fprintf (stderr, \"ref_r0 too small!!!: \"); debug_mp (ref_r0, 16);\n      return 0;\n    }\n  if (mpz_size (ref_r1) <= s)\n    {\n      fprintf (stderr, \"ref_r1 too small!!!: \"); debug_mp (ref_r1, 16);\n      return 0;\n    }\n\n  mpz_sub (t, ref_r0, ref_r1);\n  dbits = mpz_sizeinbase (t, 2);\n  if (dbits > s*GMP_NUMB_BITS)\n    {\n      fprintf (stderr, \"ref |r0 - r1| too large!!!: \"); debug_mp (t, 16);\n      return 0;\n    }\n\n  if (!res1)\n    {\n      mpz_set (appr_r0, a);\n      mpz_set (appr_r1, b);\n    }\n  else\n    {\n      unsigned i;\n\n      for (i = 0; i<2; i++)\n\t{\n\t  unsigned j;\n\n\t  for (j = 0; j<2; j++)\n\t    {\n\t      mp_size_t mn = hgcd->n;\n\t      MPN_NORMALIZE (hgcd->p[i][j], mn);\n\t      mpz_realloc (appr.m[i][j], mn);\n\t      MPN_COPY (PTR (appr.m[i][j]), hgcd->p[i][j], mn);\n\t      SIZ (appr.m[i][j]) = mn;\n\t    }\n\t}\n      mpz_mul (appr_r0, appr.m[1][1], a);\n      mpz_mul (t, appr.m[0][1], b);\n      mpz_sub (appr_r0, appr_r0, t);\n      if (mpz_sgn (appr_r0) <= 0\n\t  || mpz_size (appr_r0) <= s)\n\t{\n\t  fprintf (stderr, \"appr_r0 too small: \"); debug_mp (appr_r0, 16);\n\t  return 0;\n\t}\n\n      mpz_mul (appr_r1, appr.m[1][0], a);\n      mpz_mul (t, appr.m[0][0], b);\n      mpz_sub (appr_r1, t, appr_r1);\n      if (mpz_sgn (appr_r1) <= 0\n\t  || mpz_size (appr_r1) <= s)\n\t{\n\t  fprintf (stderr, \"appr_r1 too small: \"); debug_mp (appr_r1, 16);\n\t  return 0;\n\t}\n    }\n\n  mpz_sub (t, appr_r0, appr_r1);\n  abits = mpz_sizeinbase (t, 2);\n  if (abits < dbits)\n    {\n      fprintf (stderr, \"|r0 - r1| too small: \"); debug_mp (t, 16);\n      return 0;\n    }\n\n  /* We lose one bit each time we discard the least significant limbs.\n     For the lehmer code, that can happen at most s * (GMP_NUMB_BITS)\n     / (GMP_NUMB_BITS - 1) times. For the dc code, we lose an entire\n     limb (or more?) for each level of recursion. */\n\n  margin = (n/2+1) * GMP_NUMB_BITS / (GMP_NUMB_BITS - 1);\n  {\n    mp_size_t rn;\n    for (rn = n; ABOVE_THRESHOLD (rn, HGCD_APPR_THRESHOLD); rn = (rn + 1)/2)\n      margin += GMP_NUMB_BITS;\n  }\n\n  if (verbose_flag && abits > dbits)\n    fprintf (stderr, \"n = %u: sbits = %u: ref #(r0-r1): %u, appr #(r0-r1): %u excess: %d, margin: %u\\n\",\n\t     (unsigned) n, (unsigned) s*GMP_NUMB_BITS,\n\t     (unsigned) dbits, (unsigned) abits,\n\t     (int) (abits - s * GMP_NUMB_BITS), (unsigned) margin);\n\n  if (abits > s*GMP_NUMB_BITS + margin)\n    {\n      fprintf (stderr, \"appr |r0 - r1| much larger than minimal (by %u bits, margin = %u bits)\\n\",\n\t       (unsigned) (abits - s*GMP_NUMB_BITS), (unsigned) margin);\n      return 0;\n    }\n\n  while (mpz_cmp (appr_r0, ref_r0) > 0 || mpz_cmp (appr_r1, ref_r1) > 0)\n    {\n      ASSERT (mpz_size (appr_r0) > s);\n      ASSERT (mpz_size (appr_r1) > s);\n\n      if (mpz_cmp (appr_r0, appr_r1) > 0)\n\t{\n\t  if (!sdiv_qr (q, appr_r0, s, appr_r0, appr_r1))\n\t    break;\n\t  mpz_addmul (appr.m[0][1], q, appr.m[0][0]);\n\t  mpz_addmul (appr.m[1][1], q, appr.m[1][0]);\n\t}\n      else\n\t{\n\t  if (!sdiv_qr (q, appr_r1, s, appr_r1, appr_r0))\n\t    break;\n\t  mpz_addmul (appr.m[0][0], q, appr.m[0][1]);\n\t  mpz_addmul (appr.m[1][0], q, appr.m[1][1]);\n\t}\n    }\n\n  if (mpz_cmp (appr_r0, ref_r0) != 0\n      || mpz_cmp (appr_r1, ref_r1) != 0\n      || !hgcd_ref_equal (ref, &appr))\n    {\n      fprintf (stderr, \"appr_r0: \"); debug_mp (appr_r0, 16);\n      fprintf (stderr, \"ref_r0: \"); debug_mp (ref_r0, 16);\n\n      fprintf (stderr, \"appr_r1: \"); debug_mp (appr_r1, 16);\n      fprintf (stderr, \"ref_r1: \"); debug_mp (ref_r1, 16);\n\n      return 0;\n    }\n  mpz_clear (t);\n  mpz_clear (q);\n  hgcd_ref_clear (&appr);\n  mpz_clear (appr_r0);\n  mpz_clear (appr_r1);\n\n  return 1;\n}",
      "lines": 165,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-instrument.c": {
    "__cyg_profile_func_enter": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\n__cyg_profile_func_enter (void *this_fn, void *call_site)\n{\n#if 0\n  printf (\"%24s %p %p\\n\", name, this_fn, call_site);\n#endif\n  ASSERT_ALWAYS (ncall >= 0);\n  ASSERT_ALWAYS (ncall <= numberof (call));\n\n  if (ncall >= numberof (call))\n    {\n      printf (\"__cyg_profile_func_enter: oops, call stack full, from %s\\n\", name);\n      abort ();\n    }\n\n  enter_seen = 1;\n  call[ncall].this_fn = this_fn;\n  call[ncall].call_site = call_site;\n  ncall++;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "__cyg_profile_func_exit": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\n__cyg_profile_func_exit  (void *this_fn, void *call_site)\n{\n  ASSERT_ALWAYS (ncall >= 0);\n  ASSERT_ALWAYS (ncall <= numberof (call));\n\n  if (ncall == 0)\n    {\n      printf (\"__cyg_profile_func_exit: call stack empty, from %s\\n\", name);\n      abort ();\n    }\n\n  ncall--;\n  if (this_fn != call[ncall].this_fn || call_site != call[ncall].call_site)\n    {\n      printf (\"__cyg_profile_func_exit: unbalanced this_fn/call_site from %s\\n\", name);\n      printf (\"  this_fn got  %p\\n\", this_fn);\n      printf (\"          want %p\\n\", call[ncall].this_fn);\n      printf (\"  call_site got  %p\\n\", call_site);\n      printf (\"            want %p\\n\", call[ncall].call_site);\n      abort ();\n    }\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "pre": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\npre (const char *str)\n{\n  name = str;\n  enter_seen = 0;\n  old_ncall = ncall;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "post": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "void\npost (void)\n{\n  if (! enter_seen)\n    {\n      printf (\"did not reach __cyg_profile_func_enter from %s\\n\", name);\n      abort ();\n    }\n\n  if (ncall != old_ncall)\n    {\n      printf (\"unbalance enter/exit calls from %s\\n\", name);\n      printf (\"  ncall     %d\\n\", ncall);\n      printf (\"  old_ncall %d\\n\", old_ncall);\n      abort ();\n    }\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "void\ncheck (void)\n{\n  mp_limb_t  wp[100], xp[100], yp[100];\n  mp_size_t  size = 100;\n\n  refmpn_zero (xp, size);\n  refmpn_zero (yp, size);\n  refmpn_zero (wp, size);\n\n  pre (\"mpn_add_n\");\n  mpn_add_n (wp, xp, yp, size);\n  post ();\n\n#if HAVE_NATIVE_mpn_add_nc\n  pre (\"mpn_add_nc\");\n  mpn_add_nc (wp, xp, yp, size, CNST_LIMB(0));\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_addlsh1_n\n  pre (\"mpn_addlsh1_n\");\n  mpn_addlsh1_n (wp, xp, yp, size);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_and_n\n  pre (\"mpn_and_n\");\n  mpn_and_n (wp, xp, yp, size);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_andn_n\n  pre (\"mpn_andn_n\");\n  mpn_andn_n (wp, xp, yp, size);\n  post ();\n#endif\n\n  pre (\"mpn_addmul_1\");\n  mpn_addmul_1 (wp, xp, size, yp[0]);\n  post ();\n\n#if HAVE_NATIVE_mpn_addmul_1c\n  pre (\"mpn_addmul_1c\");\n  mpn_addmul_1c (wp, xp, size, yp[0], CNST_LIMB(0));\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_com\n  pre (\"mpn_com\");\n  mpn_com (wp, xp, size);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_copyd\n  pre (\"mpn_copyd\");\n  mpn_copyd (wp, xp, size);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_copyi\n  pre (\"mpn_copyi\");\n  mpn_copyi (wp, xp, size);\n  post ();\n#endif\n\n  pre (\"mpn_divexact_1\");\n  mpn_divexact_1 (wp, xp, size, CNST_LIMB(123));\n  post ();\n\n  pre (\"mpn_divexact_by3c\");\n  mpn_divexact_by3c (wp, xp, size, CNST_LIMB(0));\n  post ();\n\n  pre (\"mpn_divrem_1\");\n  mpn_divrem_1 (wp, (mp_size_t) 0, xp, size, CNST_LIMB(123));\n  post ();\n\n#if HAVE_NATIVE_mpn_divrem_1c\n  pre (\"mpn_divrem_1c\");\n  mpn_divrem_1c (wp, (mp_size_t) 0, xp, size, CNST_LIMB(123), CNST_LIMB(122));\n  post ();\n#endif\n\n  pre (\"mpn_gcd_1\");\n  xp[0] |= 1;\n  notdead += (unsigned long) mpn_gcd_1 (xp, size, CNST_LIMB(123));\n  post ();\n\n  pre (\"mpn_hamdist\");\n  notdead += mpn_hamdist (xp, yp, size);\n  post ();\n\n#if HAVE_NATIVE_mpn_ior_n\n  pre (\"mpn_ior_n\");\n  mpn_ior_n (wp, xp, yp, size);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_iorn_n\n  pre (\"mpn_iorn_n\");\n  mpn_iorn_n (wp, xp, yp, size);\n  post ();\n#endif\n\n  pre (\"mpn_lshift\");\n  mpn_lshift (wp, xp, size, 1);\n  post ();\n\n  pre (\"mpn_mod_1\");\n  notdead += mpn_mod_1 (xp, size, CNST_LIMB(123));\n  post ();\n\n#if HAVE_NATIVE_mpn_mod_1c\n  pre (\"mpn_mod_1c\");\n  notdead += mpn_mod_1c (xp, size, CNST_LIMB(123), CNST_LIMB(122));\n  post ();\n#endif\n\n#if GMP_NUMB_BITS % 4 == 0\n  pre (\"mpn_mod_34lsub1\");\n  notdead += mpn_mod_34lsub1 (xp, size);\n  post ();\n#endif\n\n  pre (\"mpn_modexact_1_odd\");\n  notdead += mpn_modexact_1_odd (xp, size, CNST_LIMB(123));\n  post ();\n\n  pre (\"mpn_modexact_1c_odd\");\n  notdead += mpn_modexact_1c_odd (xp, size, CNST_LIMB(123), CNST_LIMB(456));\n  post ();\n\n  pre (\"mpn_mul_1\");\n  mpn_mul_1 (wp, xp, size, yp[0]);\n  post ();\n\n#if HAVE_NATIVE_mpn_mul_1c\n  pre (\"mpn_mul_1c\");\n  mpn_mul_1c (wp, xp, size, yp[0], CNST_LIMB(0));\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_mul_2\n  pre (\"mpn_mul_2\");\n  mpn_mul_2 (wp, xp, size-1, yp);\n  post ();\n#endif\n\n  pre (\"mpn_mul_basecase\");\n  mpn_mul_basecase (wp, xp, (mp_size_t) 3, yp, (mp_size_t) 3);\n  post ();\n\n#if HAVE_NATIVE_mpn_nand_n\n  pre (\"mpn_nand_n\");\n  mpn_nand_n (wp, xp, yp, size);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_nior_n\n  pre (\"mpn_nior_n\");\n  mpn_nior_n (wp, xp, yp, size);\n  post ();\n#endif\n\n  pre (\"mpn_popcount\");\n  notdead += mpn_popcount (xp, size);\n  post ();\n\n  pre (\"mpn_preinv_mod_1\");\n  notdead += mpn_preinv_mod_1 (xp, size, GMP_NUMB_MAX,\n                               refmpn_invert_limb (GMP_NUMB_MAX));\n  post ();\n\n#if USE_PREINV_DIVREM_1 || HAVE_NATIVE_mpn_preinv_divrem_1\n  pre (\"mpn_preinv_divrem_1\");\n  mpn_preinv_divrem_1 (wp, (mp_size_t) 0, xp, size, GMP_NUMB_MAX,\n                       refmpn_invert_limb (GMP_NUMB_MAX), 0);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_rsh1add_n\n  pre (\"mpn_rsh1add_n\");\n  mpn_rsh1add_n (wp, xp, yp, size);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_rsh1sub_n\n  pre (\"mpn_rsh1sub_n\");\n  mpn_rsh1sub_n (wp, xp, yp, size);\n  post ();\n#endif\n\n  pre (\"mpn_rshift\");\n  mpn_rshift (wp, xp, size, 1);\n  post ();\n\n  pre (\"mpn_sqr_basecase\");\n  mpn_sqr_basecase (wp, xp, (mp_size_t) 3);\n  post ();\n\n  pre (\"mpn_submul_1\");\n  mpn_submul_1 (wp, xp, size, yp[0]);\n  post ();\n\n#if HAVE_NATIVE_mpn_submul_1c\n  pre (\"mpn_submul_1c\");\n  mpn_submul_1c (wp, xp, size, yp[0], CNST_LIMB(0));\n  post ();\n#endif\n\n  pre (\"mpn_sub_n\");\n  mpn_sub_n (wp, xp, yp, size);\n  post ();\n\n#if HAVE_NATIVE_mpn_sub_nc\n  pre (\"mpn_sub_nc\");\n  mpn_sub_nc (wp, xp, yp, size, CNST_LIMB(0));\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_sublsh1_n\n  pre (\"mpn_sublsh1_n\");\n  mpn_sublsh1_n (wp, xp, yp, size);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_udiv_qrnnd\n  pre (\"mpn_udiv_qrnnd\");\n  mpn_udiv_qrnnd (&wp[0], CNST_LIMB(122), xp[0], CNST_LIMB(123));\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_udiv_qrnnd_r\n  pre (\"mpn_udiv_qrnnd_r\");\n  mpn_udiv_qrnnd (CNST_LIMB(122), xp[0], CNST_LIMB(123), &wp[0]);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_umul_ppmm\n  pre (\"mpn_umul_ppmm\");\n  mpn_umul_ppmm (&wp[0], xp[0], yp[0]);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_umul_ppmm_r\n  pre (\"mpn_umul_ppmm_r\");\n  mpn_umul_ppmm_r (&wp[0], xp[0], yp[0]);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_xor_n\n  pre (\"mpn_xor_n\");\n  mpn_xor_n (wp, xp, yp, size);\n  post ();\n#endif\n\n#if HAVE_NATIVE_mpn_xnor_n\n  pre (\"mpn_xnor_n\");\n  mpn_xnor_n (wp, xp, yp, size);\n  post ();\n#endif\n}",
      "lines": 263,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          395,
          0
        ],
        "end_point": [
          404,
          1
        ],
        "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check ();\n\n  tests_end ();\n  exit (0);\n}",
        "lines": 10,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          409,
          0
        ],
        "end_point": [
          413,
          1
        ],
        "content": "int\nmain (void)\n{\n  exit (0);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gmp/gmp-6.1.2/tests/mpn/t-invert.c": {
    "invert_valid": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\ninvert_valid (mp_srcptr ip, mp_srcptr dp, mp_size_t n)\n{\n  mp_ptr tp;\n  int cy;\n  TMP_DECL;\n\n  TMP_MARK;\n  tp = TMP_ALLOC_LIMBS (2*n);\n\n  refmpn_mul (tp, ip, n, dp, n);\n  cy  = refmpn_add_n (tp + n, tp + n, dp, n); /* This must not give a carry. */\n  cy -= refmpn_add (tp, tp, 2*n, dp, n); /* This must give a carry. */\n  TMP_FREE;\n\n  return (cy == -1);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr ip, dp, scratch;\n  int count = COUNT;\n  int test;\n  gmp_randstate_ptr rands;\n  TMP_DECL;\n  TMP_MARK;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  tests_start ();\n  rands = RANDS;\n\n  dp = TMP_ALLOC_LIMBS (MAX_N);\n  ip = 1+TMP_ALLOC_LIMBS (MAX_N + 2);\n  scratch\n    = 1+TMP_ALLOC_LIMBS (mpn_invert_itch (MAX_N) + 2);\n\n  for (test = 0; test < count; test++)\n    {\n      unsigned size_min;\n      unsigned size_range;\n      mp_size_t n;\n      mp_size_t itch;\n      mp_limb_t i_before, i_after, s_before, s_after;\n\n      for (size_min = 1; (1L << size_min) < MIN_N; size_min++)\n\t;\n\n      /* We generate an in the MIN_N <= n <= (1 << size_range). */\n      size_range = size_min\n\t+ gmp_urandomm_ui (rands, SIZE_LOG + 1 - size_min);\n\n      n = MIN_N\n\t+ gmp_urandomm_ui (rands, (1L << size_range) + 1 - MIN_N);\n\n      mpn_random2 (dp, n);\n\n      mpn_random2 (ip-1, n + 2);\n      i_before = ip[-1];\n      i_after = ip[n];\n\n      itch = mpn_invert_itch (n);\n      ASSERT_ALWAYS (itch <= mpn_invert_itch (MAX_N));\n      mpn_random2 (scratch-1, itch+2);\n      s_before = scratch[-1];\n      s_after = scratch[itch];\n\n      dp[n-1] |= GMP_NUMB_HIGHBIT;\n      mpn_invert (ip, dp, n, scratch);\n      if (ip[-1] != i_before || ip[n] != i_after\n\t  || scratch[-1] != s_before || scratch[itch] != s_after\n\t  || ! invert_valid(ip, dp, n))\n\t{\n\t  printf (\"ERROR in test %d, n = %d\\n\",\n\t\t  test, (int) n);\n\t  if (ip[-1] != i_before)\n\t    {\n\t      printf (\"before ip:\"); mpn_dump (ip -1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&i_before, 1);\n\t    }\n\t  if (ip[n] != i_after)\n\t    {\n\t      printf (\"after ip:\"); mpn_dump (ip + n, 1);\n\t      printf (\"keep:   \"); mpn_dump (&i_after, 1);\n\t    }\n\t  if (scratch[-1] != s_before)\n\t    {\n\t      printf (\"before scratch:\"); mpn_dump (scratch-1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_before, 1);\n\t    }\n\t  if (scratch[itch] != s_after)\n\t    {\n\t      printf (\"after scratch:\"); mpn_dump (scratch + itch, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_after, 1);\n\t    }\n\t  mpn_dump (dp, n);\n\t  mpn_dump (ip, n);\n\n\t  abort();\n\t}\n    }\n  TMP_FREE;\n  tests_end ();\n  return 0;\n}",
      "lines": 97,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-iord_u.c": {
    "check_one": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "void\ncheck_one (const char *name, int i,\n           mp_srcptr src, mp_limb_t n,\n           mp_srcptr got, mp_srcptr want, mp_size_t size)\n{\n  if (! refmpn_equal_anynail (got, want, size))\n    {\n      printf (\"Wrong at %s i=%d\\n\", name, i);\n      mpn_trace (\"  src\", src,  size);\n      mpn_trace (\"    n\", &n,   (mp_size_t) 1);\n      mpn_trace (\"  got\", got,  size);\n      mpn_trace (\" want\", want, size);\n      abort ();\n    }\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_incr_data": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\ncheck_incr_data (void)\n{\n  static const struct {\n    mp_limb_t        n;\n    const mp_limb_t  src[SIZE];\n    const mp_limb_t  want[SIZE];\n  } data[] = {\n    { 1, { 0 },   { 1 } },\n    { 1, { 123 }, { 124 } },\n    { 2, { 0 },   { 2 } },\n    { 2, { 123 }, { 125 } },\n    { M, { 0 },   { M } },\n\n    { 1, { M, 0 },   { 0,   1 } },\n    { 1, { M, 123 }, { 0,   124 } },\n    { 2, { M, 0 },   { 1,   1 } },\n    { 2, { M, 123 }, { 1,   124 } },\n    { M, { M, 0 },   { M-1, 1 } },\n    { M, { M, 123 }, { M-1, 124 } },\n\n    { 1, { M, M, 0 },   { 0,   0, 1 } },\n    { 1, { M, M, 123 }, { 0,   0, 124 } },\n    { 2, { M, M, 0 },   { 1,   0, 1 } },\n    { 2, { M, M, 123 }, { 1,   0, 124 } },\n    { M, { M, M, 0 },   { M-1, 0, 1 } },\n    { M, { M, M, 123 }, { M-1, 0, 124 } },\n\n    { 1, { M, M, M, 0 },   { 0,   0, 0, 1 } },\n    { 1, { M, M, M, 123 }, { 0,   0, 0, 124 } },\n    { 2, { M, M, M, 0 },   { 1,   0, 0, 1 } },\n    { 2, { M, M, M, 123 }, { 1,   0, 0, 124 } },\n    { M, { M, M, M, 0 },   { M-1, 0, 0, 1 } },\n    { M, { M, M, M, 123 }, { M-1, 0, 0, 124 } },\n\n    { 1, { M, M, M, M, 0 },   { 0,   0, 0, 0, 1 } },\n    { 1, { M, M, M, M, 123 }, { 0,   0, 0, 0, 124 } },\n    { 2, { M, M, M, M, 0 },   { 1,   0, 0, 0, 1 } },\n    { 2, { M, M, M, M, 123 }, { 1,   0, 0, 0, 124 } },\n    { M, { M, M, M, M, 0 },   { M-1, 0, 0, 0, 1 } },\n    { M, { M, M, M, M, 123 }, { M-1, 0, 0, 0, 124\n#if defined (__hpux) && ! defined (__GNUC__)\n    /* Some versions (at least HP92453-01 B.11.11.23709.GP) of the\n       HP C compilers fail to zero-fill aggregates as the ISO C standard\n       requires (cf 6.5.7 Initialization).  Compensate here:  */\n\t\t\t\t, 0, 0, 0, 0, 0\n#endif\n    } }\n  };\n\n  mp_limb_t  got[SIZE];\n  int   i;\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      refmpn_copyi (got, data[i].src, SIZE);\n      MPN_INCR_U (got, SIZE, data[i].n);\n      check_one (\"check_incr (general)\", i,\n                 data[i].src, data[i].n,\n                 got, data[i].want, SIZE);\n\n      if (data[i].n == 1)\n        {\n          refmpn_copyi (got, data[i].src, SIZE);\n          MPN_INCR_U (got, SIZE, CNST_LIMB(1));\n          check_one (\"check_incr (const 1)\", i,\n                     data[i].src, data[i].n,\n                     got, data[i].want, SIZE);\n        }\n    }\n}",
      "lines": 71,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_decr_data": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void\ncheck_decr_data (void)\n{\n  static const struct {\n    mp_limb_t        n;\n    const mp_limb_t  src[SIZE];\n    const mp_limb_t  want[SIZE];\n  } data[] = {\n    { 1,   { 1 },   { 0   } },\n    { 1,   { 123 }, { 122 } },\n    { 1,   { M },   { M-1 } },\n    { 2,   { 2 },   { 0   } },\n    { 2,   { 123 }, { 121 } },\n    { M,   { M },   { 0   } },\n    { M-1, { M },   { 1   } },\n\n    { 1,   { 0,   1   }, { M,   0   } },\n    { 1,   { 0,   123 }, { M,   122 } },\n    { 1,   { 0,   M   }, { M,   M-1 } },\n    { 2,   { 0,   123 }, { M-1, 122 } },\n    { 2,   { 1,   123 }, { M,   122 } },\n    { M,   { 0,   123 }, { 1,   122 } },\n    { M,   { M-1, M   }, { M,   M-1 } },\n\n    { 1,   { 0,   0, 1   }, { M,   M, 0   } },\n    { 1,   { 0,   0, 123 }, { M,   M, 122 } },\n    { 1,   { 0,   0, M   }, { M,   M, M-1 } },\n    { 2,   { 0,   0, 123 }, { M-1, M, 122 } },\n    { 2,   { 1,   0, 123 }, { M,   M, 122 } },\n    { M,   { 0,   0, 123 }, { 1,   M, 122 } },\n    { M,   { M-1, 0, M   }, { M,   M, M-1 } },\n\n    { 1,   { 0,   0, 0, 1   }, { M,   M, M, 0   } },\n    { 1,   { 0,   0, 0, 123 }, { M,   M, M, 122 } },\n    { 1,   { 0,   0, 0, M   }, { M,   M, M, M-1 } },\n    { 2,   { 0,   0, 0, 123 }, { M-1, M, M, 122 } },\n    { 2,   { 1,   0, 0, 123 }, { M,   M, M, 122 } },\n    { M,   { 0,   0, 0, 123 }, { 1,   M, M, 122 } },\n    { M,   { M-1, 0, 0, M   }, { M,   M, M, M-1 } },\n\n    { 1,   { 0,   0, 0, 0, 1   }, { M,   M, M, M, 0   } },\n    { 1,   { 0,   0, 0, 0, 123 }, { M,   M, M, M, 122 } },\n    { 1,   { 0,   0, 0, 0, M   }, { M,   M, M, M, M-1 } },\n    { 2,   { 0,   0, 0, 0, 123 }, { M-1, M, M, M, 122 } },\n    { 2,   { 1,   0, 0, 0, 123 }, { M,   M, M, M, 122 } },\n    { M,   { 0,   0, 0, 0, 123 }, { 1,   M, M, M, 122 } },\n    { M,   { M-1, 0, 0, 0, M   }, { M,   M, M, M, M-1 } },\n\n    { 1,   { 0,   0, 0, 0, 0, 1   }, { M,   M, M, M, M, 0   } },\n    { 1,   { 0,   0, 0, 0, 0, 123 }, { M,   M, M, M, M, 122 } },\n    { 1,   { 0,   0, 0, 0, 0, M   }, { M,   M, M, M, M, M-1 } },\n    { 2,   { 0,   0, 0, 0, 0, 123 }, { M-1, M, M, M, M, 122 } },\n    { 2,   { 1,   0, 0, 0, 0, 123 }, { M,   M, M, M, M, 122 } },\n    { M,   { 0,   0, 0, 0, 0, 123 }, { 1,   M, M, M, M, 122 } },\n    { M,   { M-1, 0, 0, 0, 0, M   }, { M,   M, M, M, M, M-1\n#if defined (__hpux) && ! defined (__GNUC__)\n    /* For explanation of this garbage, see previous function.  */\n\t\t\t\t       , 0, 0, 0, 0\n#endif\n    } }\n  };\n\n  mp_limb_t  got[SIZE];\n  int   i;\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      refmpn_copyi (got, data[i].src, SIZE);\n      MPN_DECR_U (got, SIZE, data[i].n);\n      check_one (\"check_decr_data\", i,\n                 data[i].src, data[i].n,\n                 got, data[i].want, SIZE);\n\n      if (data[i].n == 1)\n        {\n          refmpn_copyi (got, data[i].src, SIZE);\n          MPN_DECR_U (got, SIZE, CNST_LIMB(1));\n          check_one (\"check_decr (const 1)\", i,\n                     data[i].src, data[i].n,\n                     got, data[i].want, SIZE);\n        }\n    }\n}",
      "lines": 83,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_incr_data ();\n  check_decr_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-matrix22.c": {
    "matrix_init": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static void\nmatrix_init (struct matrix *M, mp_size_t n)\n{\n  mp_ptr p = refmpn_malloc_limbs (4*(n+1));\n  M->e00 = p; p += n+1;\n  M->e01 = p; p += n+1;\n  M->e10 = p; p += n+1;\n  M->e11 = p;\n  M->alloc = n + 1;\n  M->n = 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "matrix_clear": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static void\nmatrix_clear (struct matrix *M)\n{\n  refmpn_free_limbs (M->e00);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "matrix_copy": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static void\nmatrix_copy (struct matrix *R, const struct matrix *M)\n{\n  R->n = M->n;\n  MPN_COPY (R->e00, M->e00, M->n);\n  MPN_COPY (R->e01, M->e01, M->n);\n  MPN_COPY (R->e10, M->e10, M->n);\n  MPN_COPY (R->e11, M->e11, M->n);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "matrix_equal_p": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static int\nmatrix_equal_p (const struct matrix *A, const struct matrix *B)\n{\n  return (A->n == B->n\n\t  && mpn_cmp (A->e00, B->e00, A->n) == 0\n\t  && mpn_cmp (A->e01, B->e01, A->n) == 0\n\t  && mpn_cmp (A->e10, B->e10, A->n) == 0\n\t  && mpn_cmp (A->e11, B->e11, A->n) == 0);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "matrix_random": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\nmatrix_random(struct matrix *M, mp_size_t n, gmp_randstate_ptr rands)\n{\n  M->n = n;\n  mpn_random (M->e00, n);\n  mpn_random (M->e01, n);\n  mpn_random (M->e10, n);\n  mpn_random (M->e11, n);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ref_matrix22_mul": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static void\nref_matrix22_mul (struct matrix *R,\n\t\t  const struct matrix *A,\n\t\t  const struct matrix *B, mp_ptr tp)\n{\n  mp_size_t an, bn, n;\n  mp_ptr r00, r01, r10, r11, a00, a01, a10, a11, b00, b01, b10, b11;\n\n  if (A->n >= B->n)\n    {\n      r00 = R->e00; a00 = A->e00; b00 = B->e00;\n      r01 = R->e01; a01 = A->e01; b01 = B->e01;\n      r10 = R->e10; a10 = A->e10; b10 = B->e10;\n      r11 = R->e11; a11 = A->e11; b11 = B->e11;\n      an = A->n, bn = B->n;\n    }\n  else\n    {\n      /* Transpose */\n      r00 = R->e00; a00 = B->e00; b00 = A->e00;\n      r01 = R->e10; a01 = B->e10; b01 = A->e10;\n      r10 = R->e01; a10 = B->e01; b10 = A->e01;\n      r11 = R->e11; a11 = B->e11; b11 = A->e11;\n      an = B->n, bn = A->n;\n    }\n  n = an + bn;\n  R->n = n + 1;\n\n  mpn_mul (r00, a00, an, b00, bn);\n  mpn_mul (tp, a01, an, b10, bn);\n  r00[n] = mpn_add_n (r00, r00, tp, n);\n\n  mpn_mul (r01, a00, an, b01, bn);\n  mpn_mul (tp, a01, an, b11, bn);\n  r01[n] = mpn_add_n (r01, r01, tp, n);\n\n  mpn_mul (r10, a10, an, b00, bn);\n  mpn_mul (tp, a11, an, b10, bn);\n  r10[n] = mpn_add_n (r10, r10, tp, n);\n\n  mpn_mul (r11, a10, an, b01, bn);\n  mpn_mul (tp, a11, an, b11, bn);\n  r11[n] = mpn_add_n (r11, r11, tp, n);\n}",
      "lines": 44,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "one_test": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static void\none_test (const struct matrix *A, const struct matrix *B, int i)\n{\n  struct matrix R;\n  struct matrix P;\n  mp_ptr tp;\n\n  matrix_init (&R, A->n + B->n + 1);\n  matrix_init (&P, A->n + B->n + 1);\n\n  tp = refmpn_malloc_limbs (mpn_matrix22_mul_itch (A->n, B->n));\n\n  ref_matrix22_mul (&R, A, B, tp);\n  matrix_copy (&P, A);\n  mpn_matrix22_mul (P.e00, P.e01, P.e10, P.e11, A->n,\n\t\t    B->e00, B->e01, B->e10, B->e11, B->n, tp);\n  P.n = A->n + B->n + 1;\n  if (!matrix_equal_p (&R, &P))\n    {\n      fprintf (stderr, \"ERROR in test %d\\n\", i);\n      gmp_fprintf (stderr, \"A = (%Nx, %Nx\\n      %Nx, %Nx)\\n\"\n\t\t   \"B = (%Nx, %Nx\\n      %Nx, %Nx)\\n\"\n\t\t   \"R = (%Nx, %Nx (expected)\\n      %Nx, %Nx)\\n\"\n\t\t   \"P = (%Nx, %Nx (incorrect)\\n      %Nx, %Nx)\\n\",\n\t\t   A->e00, A->n, A->e01, A->n, A->e10, A->n, A->e11, A->n,\n\t\t   B->e00, B->n, B->e01, B->n, B->e10, B->n, B->e11, B->n,\n\t\t   R.e00, R.n, R.e01, R.n, R.e10, R.n, R.e11, R.n,\n\t\t   P.e00, P.n, P.e01, P.n, P.e10, P.n, P.e11, P.n);\n      abort();\n    }\n  refmpn_free_limbs (tp);\n  matrix_clear (&R);\n  matrix_clear (&P);\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  struct matrix A;\n  struct matrix B;\n\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  int i;\n\n  tests_start ();\n  rands = RANDS;\n\n  matrix_init (&A, MAX_SIZE);\n  matrix_init (&B, MAX_SIZE);\n  mpz_init (bs);\n\n  for (i = 0; i < 1000; i++)\n    {\n      mp_size_t an, bn;\n      mpz_urandomb (bs, rands, 32);\n      an = 1 + mpz_get_ui (bs) % MAX_SIZE;\n      mpz_urandomb (bs, rands, 32);\n      bn = 1 + mpz_get_ui (bs) % MAX_SIZE;\n\n      matrix_random (&A, an, rands);\n      matrix_random (&B, bn, rands);\n\n      one_test (&A, &B, i);\n    }\n  mpz_clear (bs);\n  matrix_clear (&A);\n  matrix_clear (&B);\n\n  tests_end ();\n  return 0;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-minvert.c": {
    "mpz_to_mpn": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void\nmpz_to_mpn (mp_ptr ap, mp_size_t an, const mpz_t b)\n{\n  mp_size_t bn = mpz_size (b);\n  ASSERT_ALWAYS (bn <= an);\n  MPN_COPY_INCR (ap, mpz_limbs_read (b), bn);\n  MPN_ZERO (ap + bn, an - bn);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_eq_mpn": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmpz_eq_mpn (mp_ptr ap, mp_size_t an, const mpz_t b)\n{\n  mp_size_t bn = mpz_size (b);\n\n  return (bn >= 0 && bn <= an\n\t  && mpn_cmp (ap, mpz_limbs_read (b), bn) == 0\n\t  && (an == bn || mpn_zero_p (ap + bn, an - bn)));\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "bit_size": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static mp_bitcnt_t\nbit_size (mp_srcptr xp, mp_size_t n)\n{\n  MPN_NORMALIZE (xp, n);\n  return n > 0 ? mpn_sizeinbase (xp, n, 2) : 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "mp_bitcnt_t"
      ]
    },
    "main": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  gmp_randstate_ptr rands;\n  long count = COUNT;\n  mp_ptr mp;\n  mp_ptr ap;\n  mp_ptr tp;\n  mp_ptr scratch;\n  mpz_t m, a, r, g;\n  int test;\n  mp_limb_t ran;\n  mp_size_t itch;\n  TMP_DECL;\n\n  tests_start ();\n  rands = RANDS;\n\n\n  TMP_MARK;\n  mpz_init (m);\n  mpz_init (a);\n  mpz_init (r);\n  mpz_init (g);\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  mp = TMP_ALLOC_LIMBS (MAX_SIZE);\n  ap = TMP_ALLOC_LIMBS (MAX_SIZE);\n  tp = TMP_ALLOC_LIMBS (MAX_SIZE);\n  scratch = TMP_ALLOC_LIMBS (mpn_sec_invert_itch (MAX_SIZE) + 1);\n\n  for (test = 0; test < count; test++)\n    {\n      mp_bitcnt_t bits;\n      int rres, tres;\n      mp_size_t n;\n\n      bits = urandom () % (GMP_NUMB_BITS * MAX_SIZE) + 1;\n\n      if (test & 1)\n\tmpz_rrandomb (m, rands, bits);\n      else\n\tmpz_urandomb (m, rands, bits);\n      if (test & 2)\n\tmpz_rrandomb (a, rands, bits);\n      else\n\tmpz_urandomb (a, rands, bits);\n\n      mpz_setbit (m, 0);\n      if (test & 4)\n\t{\n\t  /* Ensure it really is invertible */\n\t  if (mpz_sgn (a) == 0)\n\t    mpz_set_ui (a, 1);\n\t  else\n\t    for (;;)\n\t      {\n\t\tmpz_gcd (g, a, m);\n\t\tif (mpz_cmp_ui (g, 1) == 0)\n\t\t  break;\n\t\tmpz_remove (a, a, g);\n\t      }\n\t}\n\n      rres = mpz_invert (r, a, m);\n      if ( (test & 4) && !rres)\n\t{\n\t  gmp_fprintf (stderr, \"test %d: Not invertible!\\n\"\n\t\t       \"m = %Zd\\n\"\n\t\t       \"a = %Zd\\n\", test, m, a);\n\t  abort ();\n\t}\n      ASSERT_ALWAYS (! (test & 4) || rres);\n\n      n = (bits + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;\n      ASSERT_ALWAYS (n <= MAX_SIZE);\n      itch = mpn_sec_invert_itch (n);\n      scratch[itch] = ran = urandom ();\n\n      mpz_to_mpn (ap, n, a);\n      mpz_to_mpn (mp, n, m);\n      tres = mpn_sec_invert (tp, ap, mp, n,\n\t\t\t     bit_size (ap, n) + bit_size (mp, n),\n\t\t\t     scratch);\n\n      if (rres != tres || (rres == 1 && !mpz_eq_mpn (tp, n, r)) || ran != scratch[itch])\n\t{\n\t  gmp_fprintf (stderr, \"Test %d failed.\\n\"\n\t\t       \"m = %Zd\\n\"\n\t\t       \"a = %Zd\\n\", test, m, a);\n\t  fprintf (stderr, \"ref ret: %d\\n\"\n\t\t  \"got ret: %d\\n\", rres, tres);\n\t  if (rres)\n\t    gmp_fprintf (stderr, \"ref: %Zd\\n\", r);\n\t  if (tres)\n\t    gmp_fprintf (stderr, \"got: %Nd\\n\", tp, n);\n\t  if (ran != scratch[itch])\n\t    fprintf (stderr, \"scratch[itch] changed.\\n\");\n\t  abort ();\n\t}\n    }\n\n  TMP_FREE;\n\n  mpz_clear (m);\n  mpz_clear (a);\n  mpz_clear (r);\n  mpz_clear (g);\n\n  tests_end ();\n  return 0;\n}",
      "lines": 122,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-mod_1.c": {
    "check_one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static void\ncheck_one (mp_srcptr ap, mp_size_t n, mp_limb_t b)\n{\n  mp_limb_t r_ref = refmpn_mod_1 (ap, n, b);\n  mp_limb_t r;\n\n  if (n >= 2)\n    {\n      mp_limb_t pre[4];\n      mpn_mod_1_1p_cps (pre, b);\n      r = mpn_mod_1_1p (ap, n, b << pre[1], pre);\n      if (r != r_ref)\n\t{\n\t  printf (\"mpn_mod_1_1p failed\\n\");\n\t  goto fail;\n\t}\n    }\n  if ((b & GMP_NUMB_HIGHBIT) == 0)\n    {\n      mp_limb_t pre[5];\n      mpn_mod_1s_2p_cps (pre, b);\n      r = mpn_mod_1s_2p (ap, n, b << pre[1], pre);\n      if (r != r_ref)\n\t{\n\t  printf (\"mpn_mod_1s_2p failed\\n\");\n\t  goto fail;\n\t}\n    }\n  if (b <= GMP_NUMB_MASK / 3)\n    {\n      mp_limb_t pre[6];\n      mpn_mod_1s_3p_cps (pre, b);\n      r = mpn_mod_1s_3p (ap, n, b << pre[1], pre);\n      if (r != r_ref)\n\t{\n\t  printf (\"mpn_mod_1s_3p failed\\n\");\n\t  goto fail;\n\t}\n    }\n  if (b <= GMP_NUMB_MASK / 4)\n    {\n      mp_limb_t pre[7];\n      mpn_mod_1s_4p_cps (pre, b);\n      r = mpn_mod_1s_4p (ap, n, b << pre[1], pre);\n      if (r != r_ref)\n\t{\n\t  printf (\"mpn_mod_1s_4p failed\\n\");\n\t  goto fail;\n\t}\n    }\n  r = mpn_mod_1 (ap, n, b);\n  if (r != r_ref)\n    {\n      printf (\"mpn_mod_1 failed\\n\");\n    fail:\n      printf (\"an = %d, a: \", (int) n); mpn_dump (ap, n);\n      printf (\"b           : \"); mpn_dump (&b, 1);\n      printf (\"r (expected): \"); mpn_dump (&r_ref, 1);\n      printf (\"r (bad)     : \"); mpn_dump (&r, 1);\n      abort();\n    }\n}",
      "lines": 62,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  gmp_randstate_ptr rands;\n  int i;\n  unsigned a_bits;\n  unsigned b_bits;\n  mpz_t a;\n  mpz_t b;\n\n  tests_start ();\n  rands = RANDS;\n  mpz_init (a);\n  mpz_init (b);\n\n  for (i = 0; i < 300; i++)\n    {\n      mp_size_t asize;\n      a_bits = 1 + gmp_urandomm_ui (rands, 1000);\n      b_bits = 1 + gmp_urandomm_ui (rands, GMP_NUMB_BITS);\n\n      mpz_rrandomb (a, rands, a_bits);\n      mpz_rrandomb (b, rands, b_bits);\n\n      asize = SIZ(a);\n      if (!asize)\n\tasize = 1;\n      if (mpz_sgn (b) == 0)\n\tmpz_set_ui (b, 1);\n\n      check_one (PTR(a), asize, PTR(b)[0]);\n    }\n\n  mpz_clear (a);\n  mpz_clear (b);\n\n  tests_end ();\n  return 0;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-mp_bases.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  mp_limb_t  want_bb, want_bb_inv;\n  int        base, want_chars_per_limb;\n\n  want_chars_per_limb = refmpn_chars_per_limb (10);\n  if (MP_BASES_CHARS_PER_LIMB_10 != want_chars_per_limb)\n    {\n      printf (\"MP_BASES_CHARS_PER_LIMB_10 wrong\\n\");\n      abort ();\n    }\n\n  want_bb = refmpn_big_base (10);\n  if (MP_BASES_BIG_BASE_10 != want_bb)\n    {\n      printf (\"MP_BASES_BIG_BASE_10 wrong\\n\");\n      abort ();\n    }\n\n  want_bb_inv = refmpn_invert_limb\n    (want_bb << refmpn_count_leading_zeros (want_bb));\n  if (MP_BASES_BIG_BASE_INVERTED_10 != want_bb_inv)\n    {\n      printf (\"MP_BASES_BIG_BASE_INVERTED_10 wrong\\n\");\n      abort ();\n    }\n\n  if (MP_BASES_NORMALIZATION_STEPS_10\n      != refmpn_count_leading_zeros (MP_BASES_BIG_BASE_10))\n    {\n      printf (\"MP_BASES_NORMALIZATION_STEPS_10 wrong\\n\");\n      abort ();\n    }\n\n  for (base = 2; base < numberof (mp_bases); base++)\n    {\n      want_chars_per_limb = refmpn_chars_per_limb (base);\n      if (mp_bases[base].chars_per_limb != want_chars_per_limb)\n        {\n          printf (\"mp_bases[%d].chars_per_limb wrong\\n\", base);\n          printf (\"  got  %d\\n\", mp_bases[base].chars_per_limb);\n          printf (\"  want %d\\n\", want_chars_per_limb);\n          abort ();\n        }\n\n      if (POW2_P (base))\n        {\n          want_bb = refmpn_count_trailing_zeros ((mp_limb_t) base);\n          if (mp_bases[base].big_base != want_bb)\n            {\n              printf (\"mp_bases[%d].big_base (log2 of base) wrong\\n\", base);\n              abort ();\n            }\n        }\n      else\n        {\n          want_bb = refmpn_big_base (base);\n          if (mp_bases[base].big_base != want_bb)\n            {\n              printf (\"mp_bases[%d].big_base wrong\\n\", base);\n              abort ();\n            }\n\n#if USE_PREINV_DIVREM_1\n          want_bb_inv = refmpn_invert_limb\n            (want_bb << refmpn_count_leading_zeros (want_bb));\n          if (mp_bases[base].big_base_inverted != want_bb_inv)\n            {\n              printf (\"mp_bases[%d].big_base_inverted wrong\\n\", base);\n              abort ();\n            }\n#endif\n        }\n    }\n\n  exit (0);\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-mul.c": {
    "isqrt": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static unsigned\nisqrt (unsigned t)\n{\n  unsigned s, b;\n\n  for (b = 0, s = t;  b++, s >>= 1; )\n    ;\n\n  s = 1 << (b >> 1);\n  if (b & 1)\n    s += s >> 1;\n\n  do\n    {\n      b = t / s;\n      s = (s + b) >> 1;\n    }\n  while (b < s);\n\n  return s;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "main": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr ap, bp, rp, refp;\n  mp_size_t max_n, an, bn, rn;\n  gmp_randstate_ptr rands;\n  int reps;\n  TMP_DECL;\n  TMP_MARK;\n\n  reps = 1;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  rands = RANDS;\n\n  /* Re-interpret reps argument as a size argument.  */\n  max_n = isqrt (reps * 25000);\n\n  ap = TMP_ALLOC_LIMBS (max_n + 1);\n  bp = TMP_ALLOC_LIMBS (max_n + 1);\n  rp = TMP_ALLOC_LIMBS (2 * max_n);\n  refp = TMP_ALLOC_LIMBS (2 * max_n);\n\n  for (an = 1; an <= max_n; an += 1)\n    {\n      for (bn = 1; bn <= an; bn += 1)\n\t{\n\t  mpn_random2 (ap, an + 1);\n\t  mpn_random2 (bp, bn + 1);\n\n\t  refmpn_mul (refp, ap, an, bp, bn);\n\t  mpn_mul (rp, ap, an, bp, bn);\n\n\t  rn = an + bn;\n\t  if (mpn_cmp (refp, rp, rn))\n\t    {\n\t      printf (\"ERROR, an = %d, bn = %d, rn = %d\\n\",\n\t\t      (int) an, (int) bn, (int) rn);\n\t      printf (\"a: \"); mpn_dump (ap, an);\n\t      printf (\"b: \"); mpn_dump (bp, bn);\n\t      printf (\"r:   \"); mpn_dump (rp, rn);\n\t      printf (\"ref: \"); mpn_dump (refp, rn);\n\t      abort();\n\t    }\n\t}\n    }\n  TMP_FREE;\n  tests_end ();\n  return 0;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-mullo.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr ap, bp, refp, pp, scratch;\n  int count = COUNT;\n  int test;\n  gmp_randstate_ptr rands;\n  TMP_DECL;\n  TMP_MARK;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  tests_start ();\n  rands = RANDS;\n\n#define mpn_mullo_itch(n) (0)\n\n  ap = TMP_ALLOC_LIMBS (MAX_N);\n  bp = TMP_ALLOC_LIMBS (MAX_N);\n  refp = TMP_ALLOC_LIMBS (MAX_N * 2);\n  pp = 1+TMP_ALLOC_LIMBS (MAX_N + 2);\n  scratch\n    = 1+TMP_ALLOC_LIMBS (mpn_mullo_itch (MAX_N) + 2);\n\n  for (test = 0; test < count; test++)\n    {\n      unsigned size_min;\n      unsigned size_range;\n      mp_size_t n;\n      mp_size_t itch;\n      mp_limb_t p_before, p_after, s_before, s_after;\n\n      for (size_min = 1; (1L << size_min) < MIN_N; size_min++)\n\t;\n\n      /* We generate an in the MIN_N <= n <= (1 << size_range). */\n      size_range = size_min\n\t+ gmp_urandomm_ui (rands, SIZE_LOG + 1 - size_min);\n\n      n = MIN_N\n\t+ gmp_urandomm_ui (rands, (1L << size_range) + 1 - MIN_N);\n\n      mpn_random2 (ap, n);\n      mpn_random2 (bp, n);\n      mpn_random2 (pp-1, n + 2);\n      p_before = pp[-1];\n      p_after = pp[n];\n\n      itch = mpn_mullo_itch (n);\n      ASSERT_ALWAYS (itch <= mpn_mullo_itch (MAX_N));\n      mpn_random2 (scratch-1, itch+2);\n      s_before = scratch[-1];\n      s_after = scratch[itch];\n\n      mpn_mullo_n (pp, ap, bp, n);\n      mpn_mul_n (refp, ap, bp, n);\n      if (pp[-1] != p_before || pp[n] != p_after\n\t  || scratch[-1] != s_before || scratch[itch] != s_after\n\t  || mpn_cmp (refp, pp, n) != 0)\n\t{\n\t  printf (\"ERROR in test %d, n = %d\",\n\t\t  test, (int) n);\n\t  if (pp[-1] != p_before)\n\t    {\n\t      printf (\"before pp:\"); mpn_dump (pp -1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&p_before, 1);\n\t    }\n\t  if (pp[n] != p_after)\n\t    {\n\t      printf (\"after pp:\"); mpn_dump (pp + n, 1);\n\t      printf (\"keep:   \"); mpn_dump (&p_after, 1);\n\t    }\n\t  if (scratch[-1] != s_before)\n\t    {\n\t      printf (\"before scratch:\"); mpn_dump (scratch-1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_before, 1);\n\t    }\n\t  if (scratch[itch] != s_after)\n\t    {\n\t      printf (\"after scratch:\"); mpn_dump (scratch + itch, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_after, 1);\n\t    }\n\t  mpn_dump (ap, n);\n\t  mpn_dump (bp, n);\n\t  mpn_dump (pp, n);\n\t  mpn_dump (refp, n);\n\n\t  abort();\n\t}\n    }\n  TMP_FREE;\n  tests_end ();\n  return 0;\n}",
      "lines": 103,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-mulmid.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr ap, bp, rp, refp;\n  gmp_randstate_ptr rands;\n  int test;\n  TMP_DECL;\n  TMP_MARK;\n\n  tests_start ();\n  rands = RANDS;\n\n  ap = TMP_ALLOC_LIMBS (MAX_N);\n  bp = TMP_ALLOC_LIMBS (MAX_N);\n  rp = TMP_ALLOC_LIMBS (MAX_N + 2);\n  refp = TMP_ALLOC_LIMBS (MAX_N + 2);\n\n  for (test = 0; test < COUNT; test++)\n    {\n      mp_size_t an, bn, rn;\n      unsigned size_log;\n\n      size_log = 1 + gmp_urandomm_ui (rands, SIZE_LOG);\n      an = 1 + gmp_urandomm_ui(rands, 1L << size_log);\n\n      size_log = 1 + gmp_urandomm_ui (rands, SIZE_LOG);\n      bn = 1 + gmp_urandomm_ui(rands, 1L << size_log);\n\n      /* Make sure an >= bn */\n      if (an < bn)\n\tMP_SIZE_T_SWAP (an, bn);\n\n      mpn_random2 (ap, an);\n      mpn_random2 (bp, bn);\n\n      refmpn_mulmid (refp, ap, an, bp, bn);\n      mpn_mulmid (rp, ap, an, bp, bn);\n\n      rn = an + 3 - bn;\n      if (mpn_cmp (refp, rp, rn))\n\t{\n\t  printf (\"ERROR in test %d, an = %d, bn = %d, rn = %d\\n\",\n\t\t  test, (int) an, (int) bn, (int) rn);\n\t  printf(\"a: \"); mpn_dump (ap, an);\n\t  printf(\"b: \"); mpn_dump (bp, bn);\n\t  printf(\"r:   \"); mpn_dump (rp, rn);\n\t  printf(\"ref: \"); mpn_dump (refp, rn);\n\n\t  abort();\n\t}\n    }\n  TMP_FREE;\n  tests_end ();\n  return 0;\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-mulmod_bnm1.c": {
    "ref_mulmod_bnm1": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\nref_mulmod_bnm1 (mp_ptr rp, mp_size_t rn, mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)\n{\n  mp_limb_t cy;\n\n  ASSERT (0 < an && an <= rn);\n  ASSERT (0 < bn && bn <= rn);\n\n  if (an >= bn)\n    refmpn_mul (rp, ap, an, bp, bn);\n  else\n    refmpn_mul (rp, bp, bn, ap, an);\n  an += bn;\n  if (an > rn) {\n    cy = mpn_add (rp, rp, rn, rp + rn, an - rn);\n    /* If cy == 1, then the value of rp is at most B^rn - 2, so there can\n     * be no overflow when adding in the carry. */\n    MPN_INCR_U (rp, rn, cy);\n  }\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr ap, bp, refp, pp, scratch;\n  int count = COUNT;\n  int test;\n  gmp_randstate_ptr rands;\n  TMP_DECL;\n  TMP_MARK;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  tests_start ();\n  rands = RANDS;\n\n  ASSERT_ALWAYS (mpn_mulmod_bnm1_next_size (MAX_N) == MAX_N);\n\n  ap = TMP_ALLOC_LIMBS (MAX_N);\n  bp = TMP_ALLOC_LIMBS (MAX_N);\n  refp = TMP_ALLOC_LIMBS (MAX_N * 4);\n  pp = 1+TMP_ALLOC_LIMBS (MAX_N + 2);\n  scratch\n    = 1+TMP_ALLOC_LIMBS (mpn_mulmod_bnm1_itch (MAX_N, MAX_N, MAX_N) + 2);\n\n  for (test = 0; test < count; test++)\n    {\n      unsigned size_min;\n      unsigned size_range;\n      mp_size_t an,bn,rn,n;\n      mp_size_t itch;\n      mp_limb_t p_before, p_after, s_before, s_after;\n\n      for (size_min = 1; (1L << size_min) < MIN_N; size_min++)\n\t;\n\n      /* We generate an in the MIN_N <= n <= (1 << size_range). */\n      size_range = size_min\n\t+ gmp_urandomm_ui (rands, SIZE_LOG + 1 - size_min);\n\n      n = MIN_N\n\t+ gmp_urandomm_ui (rands, (1L << size_range) + 1 - MIN_N);\n      n = mpn_mulmod_bnm1_next_size (n);\n\n      if ( (test & 1) || n == 1) {\n\t/* Half of the tests are done with the main scenario in mind:\n\t   both an and bn >= rn/2 */\n\tan = ((n+1) >> 1) + gmp_urandomm_ui (rands, (n+1) >> 1);\n\tbn = ((n+1) >> 1) + gmp_urandomm_ui (rands, (n+1) >> 1);\n      } else {\n\t/* Second half of the tests are done using mulmod to compute a\n\t   full product with n/2 < an+bn <= n. */\n\tan = 1 + gmp_urandomm_ui (rands, n - 1);\n\tif (an >= n/2)\n\t  bn = 1 + gmp_urandomm_ui (rands, n - an);\n\telse\n\t  bn = n/2 + 1 - an + gmp_urandomm_ui (rands, (n+1)/2);\n      }\n\n      /* Make sure an >= bn */\n      if (an < bn)\n\tMP_SIZE_T_SWAP (an, bn);\n\n      mpn_random2 (ap, an);\n      mpn_random2 (bp, bn);\n\n      /* Sometime trigger the borderline conditions\n\t A = -1,0,+1 or B = -1,0,+1 or A*B == -1,0,1 Mod(B^{n/2}+1).\n\t This only makes sense if there is at least a split, i.e. n is even. */\n      if ((test & 0x1f) == 1 && (n & 1) == 0) {\n\tmp_size_t x;\n\tMPN_COPY (ap, ap + (n >> 1), an - (n >> 1));\n\tMPN_ZERO (ap + an - (n >> 1) , n - an);\n\tMPN_COPY (bp, bp + (n >> 1), bn - (n >> 1));\n\tMPN_ZERO (bp + bn - (n >> 1) , n - bn);\n\tx = (n == an) ? 0 : gmp_urandomm_ui (rands, n - an);\n\tap[x] += gmp_urandomm_ui (rands, 3) - 1;\n\tx = (n >> 1) - x % (n >> 1);\n\tbp[x] += gmp_urandomm_ui (rands, 3) - 1;\n\t/* We don't propagate carry, this means that the desired condition\n\t   is not triggered all the times. A few times are enough anyway. */\n      }\n      rn = MIN(n, an + bn);\n      mpn_random2 (pp-1, rn + 2);\n      p_before = pp[-1];\n      p_after = pp[rn];\n\n      itch = mpn_mulmod_bnm1_itch (n, an, bn);\n      ASSERT_ALWAYS (itch <= mpn_mulmod_bnm1_itch (MAX_N, MAX_N, MAX_N));\n      mpn_random2 (scratch-1, itch+2);\n      s_before = scratch[-1];\n      s_after = scratch[itch];\n\n      mpn_mulmod_bnm1 (  pp, n, ap, an, bp, bn, scratch);\n      ref_mulmod_bnm1 (refp, n, ap, an, bp, bn);\n      if (pp[-1] != p_before || pp[rn] != p_after\n\t  || scratch[-1] != s_before || scratch[itch] != s_after\n\t  || mpn_cmp (refp, pp, rn) != 0)\n\t{\n\t  printf (\"ERROR in test %d, an = %d, bn = %d, n = %d\\n\",\n\t\t  test, (int) an, (int) bn, (int) n);\n\t  if (pp[-1] != p_before)\n\t    {\n\t      printf (\"before pp:\"); mpn_dump (pp -1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&p_before, 1);\n\t    }\n\t  if (pp[rn] != p_after)\n\t    {\n\t      printf (\"after pp:\"); mpn_dump (pp + rn, 1);\n\t      printf (\"keep:   \"); mpn_dump (&p_after, 1);\n\t    }\n\t  if (scratch[-1] != s_before)\n\t    {\n\t      printf (\"before scratch:\"); mpn_dump (scratch-1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_before, 1);\n\t    }\n\t  if (scratch[itch] != s_after)\n\t    {\n\t      printf (\"after scratch:\"); mpn_dump (scratch + itch, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_after, 1);\n\t    }\n\t  mpn_dump (ap, an);\n\t  mpn_dump (bp, bn);\n\t  mpn_dump (pp, rn);\n\t  mpn_dump (refp, rn);\n\n\t  abort();\n\t}\n    }\n  TMP_FREE;\n  tests_end ();\n  return 0;\n}",
      "lines": 141,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-perfsqr.c": {
    "check_mod_2": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\ncheck_mod_2 (mp_limb_t d, mp_limb_t inv, mp_limb_t got_hi, mp_limb_t got_lo)\n{\n  int        want[2*GMP_LIMB_BITS], got;\n  unsigned   r, idx;\n  mp_limb_t  q;\n\n  ASSERT_ALWAYS (d <= numberof (want));\n  ASSERT_ALWAYS (((inv * d) & PERFSQR_MOD_MASK) == 1);\n  ASSERT_ALWAYS (MP_LIMB_T_MAX / d >= PERFSQR_MOD_MASK);\n\n  /* the squares mod d */\n  for (r = 0; r < d; r++)\n    want[r] = 0;\n  for (r = 0; r < d; r++)\n    want[(r*r)%d] = 1;\n\n  /* for each remainder mod d, expect the table data to correctly identify\n     it as a residue or non-residue */\n  for (r = 0; r < d; r++)\n    {\n      /* as per PERFSQR_MOD_IDX */\n      q = ((r) * (inv)) & PERFSQR_MOD_MASK;\n      idx = (q * (d)) >> PERFSQR_MOD_BITS;\n\n      if (idx >= GMP_LIMB_BITS)\n        got = (got_hi >> (idx - GMP_LIMB_BITS)) & 1;\n      else\n        got = (got_lo >> idx) & 1;\n\n      if (got != want[r])\n        {\n          printf (\"Wrong generated data\\n\");\n          printf (\"  d=%u\\n\", (unsigned) d);\n          printf (\"  r=%u\\n\", r);\n          printf (\"  idx=%u\\n\", idx);\n          printf (\"  got  %d\\n\", got);\n          printf (\"  want %d\\n\", want[r]);\n          abort ();\n        }\n    }\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_mod": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\ncheck_mod (void)\n{\n#define PERFSQR_MOD_34(r, up, usize)       { r = 0; } /* so r isn't unused */\n#define PERFSQR_MOD_PP(r, up, usize)       { r = 0; }\n#define PERFSQR_MOD_1(r, d, inv, mask)     check_mod_2 (d, inv, CNST_LIMB(0), mask)\n#define PERFSQR_MOD_2(r, d, inv, mhi, mlo) check_mod_2 (d, inv, mhi, mlo)\n\n  PERFSQR_MOD_TEST (dummy, dummy);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_pp": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void\ncheck_pp (void)\n{\n#ifdef PERFSQR_PP\n  ASSERT_ALWAYS_LIMB (PERFSQR_PP);\n  ASSERT_ALWAYS_LIMB (PERFSQR_PP_NORM);\n  ASSERT_ALWAYS_LIMB (PERFSQR_PP_INVERTED);\n\n  /* preinv stuff only for nails==0 */\n  if (GMP_NAIL_BITS == 0)\n    {\n      ASSERT_ALWAYS (PERFSQR_PP_NORM\n                     == PERFSQR_PP << refmpn_count_leading_zeros (PERFSQR_PP));\n      ASSERT_ALWAYS (PERFSQR_PP_INVERTED\n                     == refmpn_invert_limb (PERFSQR_PP_NORM));\n    }\n#endif\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_mod ();\n  check_pp ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-scan.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\ncheck (void)\n{\n  unsigned long  i, got, want;\n\n  x[SIZE] = 1;\n  for (i = 0; i < SIZE*GMP_NUMB_BITS; i++)\n    {\n      got = refmpn_scan1 (x, i);\n      want = mpn_scan1 (x, i);\n      if (got != want)\n        {\n          printf (\"mpn_scan1\\n\");\n          printf (\"  i     %lu\\n\", i);\n          printf (\"  got   %lu\\n\", got);\n          printf (\"  want  %lu\\n\", want);\n          mpn_trace (\"  x    \", x, SIZE);\n          abort ();\n        }\n    }\n\n  x[SIZE] = 0;\n  for (i = 0; i < SIZE*GMP_NUMB_BITS; i++)\n    {\n      got = refmpn_scan0 (x, i);\n      want = mpn_scan0 (x, i);\n      if (got != want)\n        {\n          printf (\"mpn_scan0\\n\");\n          printf (\"  i     %lu\\n\", i);\n          printf (\"  got   %lu\\n\", got);\n          printf (\"  want  %lu\\n\", want);\n          mpn_trace (\"  x    \", x, SIZE);\n          abort ();\n        }\n    }\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_twobits": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\ncheck_twobits (void)\n{\n#define TWOBITS(a, b) \\\n  ((CNST_LIMB(1) << (a)) | (CNST_LIMB(1) << (b)))\n\n  refmpn_zero (x, SIZE);\n  x[0] = TWOBITS (1, 0);\n  check ();\n\n  refmpn_zero (x, SIZE);\n  x[0] = TWOBITS (GMP_NUMB_BITS-1, 1);\n  check ();\n\n  refmpn_zero (x, SIZE);\n  x[0] = CNST_LIMB(1);\n  x[1] = CNST_LIMB(1);\n  check ();\n\n  refmpn_zero (x, SIZE);\n  x[0] = CNST_LIMB(1) << (GMP_NUMB_BITS-1);\n  x[1] = CNST_LIMB(1);\n  check ();\n\n  refmpn_zero (x, SIZE);\n  x[1] = TWOBITS (1, 0);\n  check ();\n\n  refmpn_zero (x, SIZE);\n  x[1] = CNST_LIMB(1);\n  x[2] = CNST_LIMB(1);\n  check ();\n}",
      "lines": 33,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "check_twobits_exhaustive": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void\ncheck_twobits_exhaustive (void)\n{\n  unsigned long  i, j;\n\n  for (i = 0; i < GMP_NUMB_BITS * SIZE; i++)\n    {\n      for (j = 0; j < GMP_NUMB_BITS * SIZE; j++)\n        {\n          refmpn_zero (x, SIZE);\n          refmpn_setbit (x, i);\n          refmpn_setbit (x, j);\n          check ();\n        }\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_rand": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "void\ncheck_rand (void)\n{\n  int  i;\n\n  for (i = 0; i < 100; i++)\n    {\n      refmpn_random2 (x, SIZE);\n      check ();\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "int\nmain (void)\n{\n  mp_trace_base = -16;\n  tests_start ();\n\n  check_twobits ();\n  check_rand ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-sizeinbase.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_limb_t a;\n  mp_ptr pp, scratch;\n  mp_limb_t max_b;\n  int count = COUNT;\n  int test;\n  gmp_randstate_ptr rands;\n  TMP_DECL;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  tests_start ();\n  TMP_MARK;\n  rands = RANDS;\n\n  pp = TMP_ALLOC_LIMBS (MAX_N);\n  scratch = TMP_ALLOC_LIMBS (MAX_N);\n  max_b = numberof (mp_bases);\n\n  ASSERT_ALWAYS (max_b > 62);\n  ASSERT_ALWAYS (max_b < GMP_NUMB_MAX);\n\n  for (a = 2; a < max_b; ++a)\n    for (test = 0; test < count; ++test)\n      {\n\tmp_size_t pn;\n\tmp_limb_t exp;\n\tmp_bitcnt_t res;\n\n\texp = gmp_urandomm_ui (rands, MAX_N);\n\n\tpn = mpn_pow_1 (pp, &a, 1, exp, scratch);\n\n\tres = mpn_sizeinbase (pp, pn, a) - 1;\n\n\tif ((res < exp) || (res > exp + 1))\n\t  {\n\t    printf (\"ERROR in test %d, base = %d, exp = %d, res = %d\\n\",\n\t\t    test, (int) a, (int) exp, (int) res);\n\t    abort();\n\t  }\n\n\tmpn_sub_1 (pp, pp, pn, CNST_LIMB(1));\n\tpn -= pp[pn-1] == 0;\n\n\tres = mpn_sizeinbase (pp, pn, a);\n\n\tif ((res < exp) || (res - 1 > exp))\n\t  {\n\t    printf (\"ERROR in -1 test %d, base = %d, exp = %d, res = %d\\n\",\n\t\t    test, (int) a, (int) exp, (int) res);\n\t    abort();\n\t  }\n      }\n\n  TMP_FREE;\n  tests_end ();\n  return 0;\n}",
      "lines": 70,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-sqrlo.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr ap, refp, pp, scratch;\n  int count = COUNT;\n  int test;\n  gmp_randstate_ptr rands;\n  TMP_DECL;\n  TMP_MARK;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  tests_start ();\n  rands = RANDS;\n\n#define mpn_sqrlo_itch(n) (0)\n\n  ap = TMP_ALLOC_LIMBS (MAX_N);\n  refp = TMP_ALLOC_LIMBS (MAX_N * 2);\n  pp = 1+TMP_ALLOC_LIMBS (MAX_N + 2);\n  scratch\n    = 1+TMP_ALLOC_LIMBS (mpn_sqrlo_itch (MAX_N) + 2);\n\n  for (test = 0; test < count; test++)\n    {\n      unsigned size_min;\n      unsigned size_range;\n      mp_size_t n;\n      mp_size_t itch;\n      mp_limb_t p_before, p_after, s_before, s_after;\n\n      for (size_min = 1; (1L << size_min) < MIN_N; size_min++)\n\t;\n\n      /* We generate an in the MIN_N <= n <= (1 << size_range). */\n      size_range = size_min\n\t+ gmp_urandomm_ui (rands, SIZE_LOG + 1 - size_min);\n\n      n = MIN_N\n\t+ gmp_urandomm_ui (rands, (1L << size_range) + 1 - MIN_N);\n\n      mpn_random2 (ap, n);\n      mpn_random2 (pp-1, n + 2);\n      p_before = pp[-1];\n      p_after = pp[n];\n\n      itch = mpn_sqrlo_itch (n);\n#if 0\n      ASSERT_ALWAYS (itch <= mpn_sqrlo_itch (MAX_N));\n      mpn_random2 (scratch-1, itch+2);\n#endif\n      s_before = scratch[-1];\n      s_after = scratch[itch];\n\n      mpn_sqrlo (pp, ap, n);\n      mpn_sqr (refp, ap, n);\n      if (pp[-1] != p_before || pp[n] != p_after\n\t  || scratch[-1] != s_before || scratch[itch] != s_after\n\t  || mpn_cmp (refp, pp, n) != 0)\n\t{\n\t  printf (\"ERROR in test %d, n = %d\",\n\t\t  test, (int) n);\n\t  if (pp[-1] != p_before)\n\t    {\n\t      printf (\"before pp:\"); mpn_dump (pp -1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&p_before, 1);\n\t    }\n\t  if (pp[n] != p_after)\n\t    {\n\t      printf (\"after pp:\"); mpn_dump (pp + n, 1);\n\t      printf (\"keep:   \"); mpn_dump (&p_after, 1);\n\t    }\n\t  if (scratch[-1] != s_before)\n\t    {\n\t      printf (\"before scratch:\"); mpn_dump (scratch-1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_before, 1);\n\t    }\n\t  if (scratch[itch] != s_after)\n\t    {\n\t      printf (\"after scratch:\"); mpn_dump (scratch + itch, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_after, 1);\n\t    }\n\t  mpn_dump (ap, n);\n\t  mpn_dump (pp, n);\n\t  mpn_dump (refp, n);\n\n\t  abort();\n\t}\n    }\n  TMP_FREE;\n  tests_end ();\n  return 0;\n}",
      "lines": 102,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-sqrmod_bnm1.c": {
    "ref_sqrmod_bnm1": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\nref_sqrmod_bnm1 (mp_ptr rp, mp_size_t rn, mp_srcptr ap, mp_size_t an)\n{\n  mp_limb_t cy;\n\n  ASSERT (0 < an && an <= rn);\n\n  refmpn_mul (rp, ap, an, ap, an);\n  an *= 2;\n  if (an > rn) {\n    cy = mpn_add (rp, rp, rn, rp + rn, an - rn);\n    /* If cy == 1, then the value of rp is at most B^rn - 2, so there can\n     * be no overflow when adding in the carry. */\n    MPN_INCR_U (rp, rn, cy);\n  }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr ap, refp, pp, scratch;\n  int count = COUNT;\n  int test;\n  gmp_randstate_ptr rands;\n  TMP_DECL;\n  TMP_MARK;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  tests_start ();\n  rands = RANDS;\n\n  ASSERT_ALWAYS (mpn_sqrmod_bnm1_next_size (MAX_N) == MAX_N);\n\n  ap = TMP_ALLOC_LIMBS (MAX_N);\n  refp = TMP_ALLOC_LIMBS (MAX_N * 4);\n  pp = 1+TMP_ALLOC_LIMBS (MAX_N + 2);\n  scratch\n    = 1+TMP_ALLOC_LIMBS (mpn_sqrmod_bnm1_itch (MAX_N, MAX_N) + 2);\n\n  for (test = 0; test < count; test++)\n    {\n      unsigned size_min;\n      unsigned size_range;\n      mp_size_t an,rn,n;\n      mp_size_t itch;\n      mp_limb_t p_before, p_after, s_before, s_after;\n\n      for (size_min = 1; (1L << size_min) < MIN_N; size_min++)\n\t;\n\n      /* We generate an in the MIN_N <= n <= (1 << size_range). */\n      size_range = size_min\n\t+ gmp_urandomm_ui (rands, SIZE_LOG + 1 - size_min);\n\n      n = MIN_N\n\t+ gmp_urandomm_ui (rands, (1L << size_range) + 1 - MIN_N);\n      n = mpn_sqrmod_bnm1_next_size (n);\n\n      if (n == 1)\n\tan = 1;\n      else\n\tan = ((n+1) >> 1) + gmp_urandomm_ui (rands, (n+1) >> 1);\n\n      mpn_random2 (ap, an);\n\n      /* Sometime trigger the borderline conditions\n\t A = -1,0,+1 Mod(B^{n/2}+1).\n\t This only makes sense if there is at least a split, i.e. n is even. */\n      if ((test & 0x1f) == 1 && (n & 1) == 0) {\n\tmp_size_t x;\n\tMPN_COPY (ap, ap + (n >> 1), an - (n >> 1));\n\tMPN_ZERO (ap + an - (n >> 1) , n - an);\n\tx = (n == an) ? 0 : gmp_urandomm_ui (rands, n - an);\n\tap[x] += gmp_urandomm_ui (rands, 3) - 1;\n      }\n      rn = MIN(n, 2*an);\n      mpn_random2 (pp-1, rn + 2);\n      p_before = pp[-1];\n      p_after = pp[rn];\n\n      itch = mpn_sqrmod_bnm1_itch (n, an);\n      ASSERT_ALWAYS (itch <= mpn_sqrmod_bnm1_itch (MAX_N, MAX_N));\n      mpn_random2 (scratch-1, itch+2);\n      s_before = scratch[-1];\n      s_after = scratch[itch];\n\n      mpn_sqrmod_bnm1 (  pp, n, ap, an, scratch);\n      ref_sqrmod_bnm1 (refp, n, ap, an);\n      if (pp[-1] != p_before || pp[rn] != p_after\n\t  || scratch[-1] != s_before || scratch[itch] != s_after\n\t  || mpn_cmp (refp, pp, rn) != 0)\n\t{\n\t  printf (\"ERROR in test %d, an = %d, n = %d\\n\",\n\t\t  test, (int) an, (int) n);\n\t  if (pp[-1] != p_before)\n\t    {\n\t      printf (\"before pp:\"); mpn_dump (pp -1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&p_before, 1);\n\t    }\n\t  if (pp[rn] != p_after)\n\t    {\n\t      printf (\"after pp:\"); mpn_dump (pp + rn, 1);\n\t      printf (\"keep:   \"); mpn_dump (&p_after, 1);\n\t    }\n\t  if (scratch[-1] != s_before)\n\t    {\n\t      printf (\"before scratch:\"); mpn_dump (scratch-1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_before, 1);\n\t    }\n\t  if (scratch[itch] != s_after)\n\t    {\n\t      printf (\"after scratch:\"); mpn_dump (scratch + itch, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_after, 1);\n\t    }\n\t  mpn_dump (ap, an);\n\t  mpn_dump (pp, rn);\n\t  mpn_dump (refp, rn);\n\n\t  abort();\n\t}\n    }\n  TMP_FREE;\n  tests_end ();\n  return 0;\n}",
      "lines": 118,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/t-toom2-sqr.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom22.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom3-sqr.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom32.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom33.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom4-sqr.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom42.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom43.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom44.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom52.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom53.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom54.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom6-sqr.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom62.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom63.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom6h.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom8-sqr.c": {},
  "gmp/gmp-6.1.2/tests/mpn/t-toom8h.c": {},
  "gmp/gmp-6.1.2/tests/mpn/toom-shared.h": {
    "main": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr ap, bp, refp, pp, scratch;\n  int count = COUNT;\n  int test;\n  gmp_randstate_ptr rands;\n  TMP_DECL;\n  TMP_MARK;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  tests_start ();\n  rands = RANDS;\n\n  ap = TMP_ALLOC_LIMBS (MAX_AN);\n  bp = TMP_ALLOC_LIMBS (MAX_BN(MAX_AN));\n  refp = TMP_ALLOC_LIMBS (MAX_AN + MAX_BN(MAX_AN));\n  pp = 1+TMP_ALLOC_LIMBS (MAX_AN + MAX_BN(MAX_AN)+2);\n  scratch\n    = 1+TMP_ALLOC_LIMBS (mpn_toomMN_mul_itch (MAX_AN, MAX_BN(MAX_AN))\n\t\t\t + 2);\n\n  for (test = 0; test < count; test++)\n    {\n      unsigned size_min;\n      unsigned size_range;\n      mp_size_t an, bn;\n      mp_size_t itch;\n      mp_limb_t p_before, p_after, s_before, s_after;\n\n      for (size_min = 1; (1L << size_min) < MIN_AN; size_min++)\n\t;\n\n      /* We generate an in the MIN_AN <= an <= (1 << size_range). */\n      size_range = size_min\n\t+ gmp_urandomm_ui (rands, SIZE_LOG + 1 - size_min);\n\n      an = MIN_AN\n\t+ gmp_urandomm_ui (rands, (1L << size_range) + 1 - MIN_AN);\n      bn = MIN_BN(an)\n\t+ gmp_urandomm_ui (rands, MAX_BN(an) + 1 - MIN_BN(an));\n\n      mpn_random2 (ap, an);\n      mpn_random2 (bp, bn);\n      mpn_random2 (pp-1, an + bn + 2);\n      p_before = pp[-1];\n      p_after = pp[an + bn];\n\n      itch = mpn_toomMN_mul_itch (an, bn);\n      ASSERT_ALWAYS (itch <= mpn_toomMN_mul_itch (MAX_AN, MAX_BN(MAX_AN)));\n      mpn_random2 (scratch-1, itch+2);\n      s_before = scratch[-1];\n      s_after = scratch[itch];\n\n      mpn_toomMN_mul (pp, ap, an, bp, bn, scratch);\n      refmpn_mul (refp, ap, an, bp, bn);\n      if (pp[-1] != p_before || pp[an + bn] != p_after\n\t  || scratch[-1] != s_before || scratch[itch] != s_after\n\t  || mpn_cmp (refp, pp, an + bn) != 0)\n\t{\n\t  printf (\"ERROR in test %d, an = %d, bn = %d\\n\",\n\t\t  test, (int) an, (int) bn);\n\t  if (pp[-1] != p_before)\n\t    {\n\t      printf (\"before pp:\"); mpn_dump (pp -1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&p_before, 1);\n\t    }\n\t  if (pp[an + bn] != p_after)\n\t    {\n\t      printf (\"after pp:\"); mpn_dump (pp + an + bn, 1);\n\t      printf (\"keep:   \"); mpn_dump (&p_after, 1);\n\t    }\n\t  if (scratch[-1] != s_before)\n\t    {\n\t      printf (\"before scratch:\"); mpn_dump (scratch-1, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_before, 1);\n\t    }\n\t  if (scratch[itch] != s_after)\n\t    {\n\t      printf (\"after scratch:\"); mpn_dump (scratch + itch, 1);\n\t      printf (\"keep:   \"); mpn_dump (&s_after, 1);\n\t    }\n\t  mpn_dump (ap, an);\n\t  mpn_dump (bp, bn);\n\t  mpn_dump (pp, an + bn);\n\t  mpn_dump (refp, an + bn);\n\n\t  abort();\n\t}\n    }\n  TMP_FREE;\n\n  tests_end ();\n  return 0;\n}",
      "lines": 105,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpn/toom-sqr-shared.h": {
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mp_ptr ap, refp, pp, scratch;\n  int count = COUNT;\n  int test;\n  gmp_randstate_ptr rands;\n  TMP_DECL;\n  TMP_MARK;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n\n  tests_start ();\n\n  if (MAX_AN > MIN_AN) {\n    rands = RANDS;\n\n    ap = TMP_ALLOC_LIMBS (MAX_AN);\n    refp = TMP_ALLOC_LIMBS (MAX_AN * 2);\n    pp = 1 + TMP_ALLOC_LIMBS (MAX_AN * 2 + 2);\n    scratch\n      = 1+TMP_ALLOC_LIMBS (mpn_toomN_sqr_itch (MAX_AN) + 2);\n\n    for (test = 0; test < count; test++)\n      {\n\tmp_size_t an;\n\tmp_size_t itch;\n\tmp_limb_t p_before, p_after, s_before, s_after;\n\n\tan = MIN_AN\n\t  + gmp_urandomm_ui (rands, MAX_AN - MIN_AN);\n\n\tmpn_random2 (ap, an);\n\tmpn_random2 (pp-1, an * 2 + 2);\n\tp_before = pp[-1];\n\tp_after = pp[an * 2];\n\n\titch = mpn_toomN_sqr_itch (an);\n\tASSERT_ALWAYS (itch <= mpn_toomN_sqr_itch (MAX_AN));\n\tmpn_random2 (scratch-1, itch+2);\n\ts_before = scratch[-1];\n\ts_after = scratch[itch];\n\n\tmpn_toomN_sqr (pp, ap, an, scratch);\n\trefmpn_mul (refp, ap, an, ap, an);\n\tif (pp[-1] != p_before || pp[an * 2] != p_after\n\t    || scratch[-1] != s_before || scratch[itch] != s_after\n\t    || mpn_cmp (refp, pp, an * 2) != 0)\n\t  {\n\t    printf (\"ERROR in test %d, an = %d\\n\",\n\t\t    test, (int) an);\n\t    if (pp[-1] != p_before)\n\t      {\n\t\tprintf (\"before pp:\"); mpn_dump (pp -1, 1);\n\t\tprintf (\"keep:   \"); mpn_dump (&p_before, 1);\n\t      }\n\t    if (pp[an * 2] != p_after)\n\t      {\n\t\tprintf (\"after pp:\"); mpn_dump (pp + an * 2, 1);\n\t\tprintf (\"keep:   \"); mpn_dump (&p_after, 1);\n\t      }\n\t    if (scratch[-1] != s_before)\n\t      {\n\t\tprintf (\"before scratch:\"); mpn_dump (scratch-1, 1);\n\t\tprintf (\"keep:   \"); mpn_dump (&s_before, 1);\n\t      }\n\t    if (scratch[itch] != s_after)\n\t      {\n\t\tprintf (\"after scratch:\"); mpn_dump (scratch + itch, 1);\n\t\tprintf (\"keep:   \"); mpn_dump (&s_after, 1);\n\t      }\n\t    mpn_dump (ap, an);\n\t    mpn_dump (pp, an * 2);\n\t    mpn_dump (refp, an * 2);\n\n\t    abort();\n\t  }\n      }\n    TMP_FREE;\n  }\n\n  tests_end ();\n  return 0;\n}",
      "lines": 93,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/io.c": {
    "debug_mp": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\ndebug_mp (mpq_t x, int base)\n{\n  mpq_out_str (stdout, base, x); fputc ('\\n', stdout);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpq_t  op1, op2;\n  mp_size_t size;\n  int i;\n  int reps = 10000;\n  FILE *fp;\n  int base;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n  size_t nread;\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  if (argc == 2)\n    reps = atoi (argv[1]);\n\n  mpq_init (op1);\n  mpq_init (op2);\n\n  fp = fopen (FILENAME, \"w+\");\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 10 + 2;\n\n      mpz_urandomb (bs, rands, size_range);\n      size = mpz_get_ui (bs);\n      mpz_errandomb (mpq_numref(op1), rands, 512L);\n      mpz_errandomb_nonzero (mpq_denref(op1), rands, 512L);\n      mpq_canonicalize (op1);\n\n      mpz_urandomb (bs, rands, 1);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpq_neg (op1, op1);\n\n      mpz_urandomb (bs, rands, 16);\n      bsi = mpz_get_ui (bs);\n      base = bsi % 36 + 1;\n      if (base == 1)\n\tbase = 0;\n\n      rewind (fp);\n      if (mpq_out_str (fp, base, op1) == 0\n\t  || putc (' ', fp) == EOF\n\t  || fflush (fp) != 0)\n\t{\n\t  printf (\"mpq_out_str write error\\n\");\n\t  abort ();\n\t}\n\n      rewind (fp);\n      nread = mpq_inp_str (op2, fp, base);\n      if (nread == 0)\n\t{\n\t  if (ferror (fp))\n\t    printf (\"mpq_inp_str stream read error\\n\");\n\t  else\n\t    printf (\"mpq_inp_str data conversion error\\n\");\n\t  abort ();\n\t}\n\n      if (nread != ftell(fp))\n\t{\n\t  printf (\"mpq_inp_str nread doesn't match ftell\\n\");\n\t  printf (\"  nread  %lu\\n\", (unsigned long) nread);\n\t  printf (\"  ftell  %ld\\n\", ftell(fp));\n\t  abort ();\n\t}\n\n      if (mpq_cmp (op1, op2))\n\t{\n\t  printf (\"ERROR\\n\");\n\t  printf (\"op1  = \"); debug_mp (op1, -16);\n\t  printf (\"op2  = \"); debug_mp (op2, -16);\n\t  printf (\"base = %d\\n\", base);\n\t  abort ();\n\t}\n    }\n\n  fclose (fp);\n\n  unlink (FILENAME);\n\n  mpz_clear (bs);\n  mpq_clear (op1);\n  mpq_clear (op2);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 98,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/reuse.c": {
    "main": [
      {
        "start_point": [
          34,
          0
        ],
        "end_point": [
          39,
          1
        ],
        "content": "int\nmain (void)\n{\n  printf (\"Test suppressed for windows DLL\\n\");\n  exit (0);\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          86,
          0
        ],
        "end_point": [
          235,
          1
        ],
        "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int pass, reps = 100;\n  mpq_t in1, in2, out1;\n  unsigned long int randbits, in2i;\n  mpq_t res1, res2;\n  gmp_randstate_ptr  rands;\n\n  tests_start ();\n\n  if (argc > 1)\n    reps = strtol (argv[1], 0, 0);\n\n  rands = RANDS;\n\n  mpq_init (in1);\n  mpq_init (in2);\n  mpq_init (out1);\n  mpq_init (res1);\n  mpq_init (res2);\n\n  for (pass = 1; pass <= reps; pass++)\n    {\n      randbits = urandom ();\n\n      if (randbits & 1)\n\t{\n\t  mpq_clear (in1);\n\t  mpq_init (in1);\n\t}\n      randbits >>= 1;\n      mpz_errandomb (mpq_numref(in1), rands, 512L);\n      mpz_errandomb_nonzero (mpq_denref(in1), rands, 512L);\n      if (randbits & 1)\n\tmpz_neg (mpq_numref(in1),mpq_numref(in1));\n      randbits >>= 1;\n      mpq_canonicalize (in1);\n\n      if (randbits & 1)\n\t{\n\t  mpq_clear (in2);\n\t  mpq_init (in2);\n\t}\n      randbits >>= 1;\n      mpz_errandomb (mpq_numref(in2), rands, 512L);\n      mpz_errandomb_nonzero (mpq_denref(in2), rands, 512L);\n      if (randbits & 1)\n\tmpz_neg (mpq_numref(in2),mpq_numref(in2));\n      randbits >>= 1;\n      mpq_canonicalize (in2);\n\n      for (i = 0; i < sizeof (dss_funcs) / sizeof (dss_func); i++)\n\t{\n\t  /* Don't divide by 0.  */\n\t  if (i == 0 && mpq_cmp_ui (in2, 0, 1) == 0)\n\t    continue;\n\n\t  if (randbits & 1)\n\t    {\n\t      mpq_clear (res1);\n\t      mpq_init (res1);\n\t    }\n\t  randbits >>= 1;\n\n\t  (dss_funcs[i]) (res1, in1, in2);\n\t  MPQ_CHECK_FORMAT(res1);\n\n\t  mpq_set (out1, in1);\n\t  (dss_funcs[i]) (out1, out1, in2);\n\t  MPQ_CHECK_FORMAT(out1);\n\n\t  if (mpq_cmp (res1, out1) != 0)\n\t    dump_abort (dss_func_names[i], res1, out1);\n\n\t  mpq_set (out1, in2);\n\t  (dss_funcs[i]) (out1, in1, out1);\n\t  MPQ_CHECK_FORMAT(out1);\n\n\t  if (mpq_cmp (res1, out1) != 0)\n\t    dump_abort (dss_func_names[i], res1, out1);\n\n\t  mpq_set (out1, in2);\n\t  (dss_funcs[i]) (res1, out1, in2);\n\t  MPQ_CHECK_FORMAT(res1);\n\n\t  (dss_funcs[i]) (res2, in2, in2);\n\t  MPQ_CHECK_FORMAT(res2);\n\n\t  (dss_funcs[i]) (out1, out1, out1);\n\t  MPQ_CHECK_FORMAT(out1);\n\n\t  if (mpq_cmp (res1, res2) != 0)\n\t    dump_abort (dss_func_names[i], res1, res2);\n\t  if (mpq_cmp (res1, out1) != 0)\n\t    dump_abort (dss_func_names[i], res1, out1);\n\t}\n\n      for (i = 0; i < sizeof (ds_funcs) / sizeof (ds_func); i++)\n\t{\n\t  if (randbits & 1)\n\t    {\n\t      mpq_clear (res1);\n\t      mpq_init (res1);\n\t    }\n\t  randbits >>= 1;\n\t  (ds_funcs[i]) (res1, in1);\n\t  MPQ_CHECK_FORMAT(res1);\n\n\t  mpq_set (out1, in1);\n\t  (ds_funcs[i]) (out1, out1);\n\t  MPQ_CHECK_FORMAT(out1);\n\n\t  if (mpq_cmp (res1, out1) != 0)\n\t    dump_abort (ds_func_names[i], res1, out1);\n\t}\n\n      in2i = urandom () % 65536;\n      for (i = 0; i < sizeof (dsi_funcs) / sizeof (dsi_func); i++)\n\t{\n\t  if (randbits & 1)\n\t    {\n\t      mpq_clear (res1);\n\t      mpq_init (res1);\n\t    }\n\t  randbits >>= 1;\n\n\t  (dsi_funcs[i]) (res1, in1, in2i);\n\t  MPQ_CHECK_FORMAT(res1);\n\n\t  mpq_set (out1, in1);\n\t  (dsi_funcs[i]) (out1, out1, in2i);\n\t  MPQ_CHECK_FORMAT(out1);\n\n\t  if (mpq_cmp (res1, out1) != 0)\n\t    dump_abort (dsi_func_names[i], res1, out1);\n\t}\n\n    }\n\n  mpq_clear (in1);\n  mpq_clear (in2);\n  mpq_clear (out1);\n  mpq_clear (res1);\n  mpq_clear (res2);\n\n  tests_end ();\n  exit (0);\n}",
        "lines": 150,
        "depth": 13,
        "decorators": [
          "int"
        ]
      }
    ],
    "dump_abort": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "void\ndump_abort (const char *name, mpq_t res1, mpq_t res2)\n{\n  printf (\"failure in %s:\\n\", name);\n  mpq_trace (\"  res1  \", res1);\n  mpq_trace (\"  res2  \", res2);\n  abort ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-aors.c": {
    "check_all": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\ncheck_all (mpq_ptr x, mpq_ptr y, mpq_ptr want_add, mpq_ptr want_sub)\n{\n  mpq_t  got;\n  int    neg_x, neg_y, swap;\n\n  mpq_init (got);\n\n  MPQ_CHECK_FORMAT (want_add);\n  MPQ_CHECK_FORMAT (want_sub);\n  MPQ_CHECK_FORMAT (x);\n  MPQ_CHECK_FORMAT (y);\n\n  for (swap = 0; swap <= 1; swap++)\n    {\n      for (neg_x = 0; neg_x <= 1; neg_x++)\n        {\n          for (neg_y = 0; neg_y <= 1; neg_y++)\n            {\n              mpq_add (got, x, y);\n              MPQ_CHECK_FORMAT (got);\n              if (! mpq_equal (got, want_add))\n                {\n                  printf (\"mpq_add wrong\\n\");\n                  mpq_trace (\"  x   \", x);\n                  mpq_trace (\"  y   \", y);\n                  mpq_trace (\"  got \", got);\n                  mpq_trace (\"  want\", want_add);\n                  abort ();\n                }\n\n              mpq_sub (got, x, y);\n              MPQ_CHECK_FORMAT (got);\n              if (! mpq_equal (got, want_sub))\n                {\n                  printf (\"mpq_sub wrong\\n\");\n                  mpq_trace (\"  x   \", x);\n                  mpq_trace (\"  y   \", y);\n                  mpq_trace (\"  got \", got);\n                  mpq_trace (\"  want\", want_sub);\n                  abort ();\n                }\n\n\n              mpq_neg (y, y);\n              mpq_swap (want_add, want_sub);\n            }\n\n          mpq_neg (x, x);\n          mpq_swap (want_add, want_sub);\n          mpq_neg (want_add, want_add);\n          mpq_neg (want_sub, want_sub);\n        }\n\n      mpq_swap (x, y);\n      mpq_neg (want_sub, want_sub);\n    }\n\n  mpq_clear (got);\n}",
      "lines": 60,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *x;\n    const char  *y;\n    const char  *want_add;\n    const char  *want_sub;\n\n  } data[] = {\n\n    { \"0\", \"0\", \"0\", \"0\" },\n    { \"1\", \"0\", \"1\", \"1\" },\n    { \"1\", \"1\", \"2\", \"0\" },\n\n    { \"1/2\", \"1/2\", \"1\", \"0\" },\n    { \"5/6\", \"14/15\", \"53/30\", \"-1/10\" },\n  };\n\n  mpq_t  x, y, want_add, want_sub;\n  int i;\n\n  mpq_init (x);\n  mpq_init (y);\n  mpq_init (want_add);\n  mpq_init (want_sub);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpq_set_str_or_abort (x, data[i].x, 0);\n      mpq_set_str_or_abort (y, data[i].y, 0);\n      mpq_set_str_or_abort (want_add, data[i].want_add, 0);\n      mpq_set_str_or_abort (want_sub, data[i].want_sub, 0);\n\n      check_all (x, y, want_add, want_sub);\n    }\n\n  mpq_clear (x);\n  mpq_clear (y);\n  mpq_clear (want_add);\n  mpq_clear (want_sub);\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_rand": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void\ncheck_rand (void)\n{\n  mpq_t  x, y, want_add, want_sub;\n  int i;\n  gmp_randstate_ptr  rands = RANDS;\n\n  mpq_init (x);\n  mpq_init (y);\n  mpq_init (want_add);\n  mpq_init (want_sub);\n\n  for (i = 0; i < 500; i++)\n    {\n      mpz_errandomb (mpq_numref(x), rands, 512L);\n      mpz_errandomb_nonzero (mpq_denref(x), rands, 512L);\n      mpq_canonicalize (x);\n\n      mpz_errandomb (mpq_numref(y), rands, 512L);\n      mpz_errandomb_nonzero (mpq_denref(y), rands, 512L);\n      mpq_canonicalize (y);\n\n      refmpq_add (want_add, x, y);\n      refmpq_sub (want_sub, x, y);\n\n      check_all (x, y, want_add, want_sub);\n    }\n\n  mpq_clear (x);\n  mpq_clear (y);\n  mpq_clear (want_add);\n  mpq_clear (want_sub);\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n  check_rand ();\n\n  tests_end ();\n\n  exit (0);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-cmp.c": {
    "ref_mpq_cmp": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nref_mpq_cmp (mpq_t a, mpq_t b)\n{\n  mpz_t ai, bi;\n  int cc;\n\n  mpz_init (ai);\n  mpz_init (bi);\n\n  mpz_mul (ai, NUM (a), DEN (b));\n  mpz_mul (bi, NUM (b), DEN (a));\n  cc = mpz_cmp (ai, bi);\n  mpz_clear (ai);\n  mpz_clear (bi);\n  return cc;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpq_t a, b;\n  mp_size_t size;\n  int reps = 10000;\n  int i;\n  int cc, ccref;\n\n  tests_start ();\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  mpq_init (a);\n  mpq_init (b);\n\n  for (i = 0; i < reps; i++)\n    {\n      size = urandom () % SIZE - SIZE/2;\n      mpz_random2 (NUM (a), size);\n      do\n\t{\n\t  size = urandom () % SIZE - SIZE/2;\n\t  mpz_random2 (DEN (a), size);\n\t}\n      while (mpz_cmp_ui (DEN (a), 0) == 0);\n\n      size = urandom () % SIZE - SIZE/2;\n      mpz_random2 (NUM (b), size);\n      do\n\t{\n\t  size = urandom () % SIZE - SIZE/2;\n\t  mpz_random2 (DEN (b), size);\n\t}\n      while (mpz_cmp_ui (DEN (b), 0) == 0);\n\n      mpq_canonicalize (a);\n      mpq_canonicalize (b);\n\n      ccref = ref_mpq_cmp (a, b);\n      cc = mpq_cmp (a, b);\n\n      if (SGN (ccref) != SGN (cc))\n\tabort ();\n    }\n\n  mpq_clear (a);\n  mpq_clear (b);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-cmp_si.c": {
    "check_data": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char     *q;\n    long           n;\n    unsigned long  d;\n    int            want;\n  } data[] = {\n    { \"0\", 0, 1, 0 },\n    { \"0\", 0, 123, 0 },\n    { \"0\", 0, ULONG_MAX, 0 },\n    { \"1\", 0, 1, 1 },\n    { \"1\", 0, 123, 1 },\n    { \"1\", 0, ULONG_MAX, 1 },\n    { \"-1\", 0, 1, -1 },\n    { \"-1\", 0, 123, -1 },\n    { \"-1\", 0, ULONG_MAX, -1 },\n\n    { \"123\", 123, 1, 0 },\n    { \"124\", 123, 1, 1 },\n    { \"122\", 123, 1, -1 },\n\n    { \"-123\", 123, 1, -1 },\n    { \"-124\", 123, 1, -1 },\n    { \"-122\", 123, 1, -1 },\n\n    { \"123\", -123, 1, 1 },\n    { \"124\", -123, 1, 1 },\n    { \"122\", -123, 1, 1 },\n\n    { \"-123\", -123, 1, 0 },\n    { \"-124\", -123, 1, -1 },\n    { \"-122\", -123, 1, 1 },\n\n    { \"5/7\", 3,4, -1 },\n    { \"5/7\", -3,4, 1 },\n    { \"-5/7\", 3,4, -1 },\n    { \"-5/7\", -3,4, 1 },\n  };\n\n  mpq_t  q;\n  int    i, got;\n\n  mpq_init (q);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpq_set_str_or_abort (q, data[i].q, 0);\n      MPQ_CHECK_FORMAT (q);\n\n      got = mpq_cmp_si (q, data[i].n, data[i].d);\n      if (SGN(got) != data[i].want)\n        {\n          printf (\"mpq_cmp_si wrong\\n\");\n        error:\n          mpq_trace (\"  q\", q);\n          printf (\"  n=%ld\\n\", data[i].n);\n          printf (\"  d=%lu\\n\", data[i].d);\n          printf (\"  got=%d\\n\", got);\n          printf (\"  want=%d\\n\", data[i].want);\n          abort ();\n        }\n\n      if (data[i].n == 0)\n        {\n          got = mpq_cmp_si (q, 0L, data[i].d);\n          if (SGN(got) != data[i].want)\n            {\n              printf (\"mpq_cmp_si wrong\\n\");\n              goto error;\n            }\n        }\n    }\n\n  mpq_clear (q);\n}",
      "lines": 77,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  tests_start ();\n\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-cmp_ui.c": {
    "ref_mpq_cmp_ui": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nref_mpq_cmp_ui (mpq_t a, unsigned long int bn, unsigned long int bd)\n{\n  mpz_t ai, bi;\n  int cc;\n\n  mpz_init (ai);\n  mpz_init (bi);\n\n  mpz_mul_ui (ai, NUM (a), bd);\n  mpz_mul_ui (bi, DEN (a), bn);\n  cc = mpz_cmp (ai, bi);\n  mpz_clear (ai);\n  mpz_clear (bi);\n  return cc;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpq_t a, b;\n  mp_size_t size;\n  int reps = 10000;\n  int i;\n  int cc, ccref;\n  unsigned long int bn, bd;\n\n  tests_start ();\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  mpq_init (a);\n  mpq_init (b);\n\n  for (i = 0; i < reps; i++)\n    {\n      size = urandom () % SIZE - SIZE/2;\n      mpz_random2 (NUM (a), size);\n      do\n\t{\n\t  size = urandom () % SIZE - SIZE/2;\n\t  mpz_random2 (DEN (a), size);\n\t}\n      while (mpz_cmp_ui (DEN (a), 0) == 0);\n\n      mpz_random2 (NUM (b), (mp_size_t) 1);\n      mpz_mod_ui (NUM (b), NUM (b), ~(unsigned long int) 0);\n      mpz_add_ui (NUM (b), NUM (b), 1);\n\n      mpz_random2 (DEN (b), (mp_size_t) 1);\n      mpz_mod_ui (DEN (b), DEN (b), ~(unsigned long int) 0);\n      mpz_add_ui (DEN (b), DEN (b), 1);\n\n      mpq_canonicalize (a);\n      mpq_canonicalize (b);\n\n      ccref = ref_mpq_cmp_ui (a, 1, 1);\n      cc = mpq_cmp_ui (a, 1, 1);\n\n      if (SGN (ccref) != SGN (cc))\n\tabort ();\n\n      ccref = ref_mpq_cmp_ui (a, 0, 1);\n      cc = mpq_cmp_ui (a, 0, 1);\n\n      if (SGN (ccref) != SGN (cc))\n\tabort ();\n\n      bn = mpz_get_ui (NUM (b));\n      bd = mpz_get_ui (DEN (b));\n\n      ccref = ref_mpq_cmp_ui (a, bn, bd);\n      cc = mpq_cmp_ui (a, bn, bd);\n\n      if (SGN (ccref) != SGN (cc))\n\tabort ();\n    }\n\n  mpq_clear (a);\n  mpq_clear (b);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 68,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-cmp_z.c": {
    "ref_mpq_cmp_z": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nref_mpq_cmp_z (mpq_t a, mpz_t b)\n{\n  mpz_t bi;\n  int cc;\n\n  mpz_init (bi);\n\n  mpz_mul (bi, b, DEN (a));\n  cc = mpz_cmp (NUM (a), bi);\n  mpz_clear (bi);\n  return cc;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sizes_test": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nsizes_test (int m)\n{\n  mpq_t a;\n  mpz_t b;\n  int i, j, k, s;\n  int cc, ccref;\n\n  mpq_init (a);\n  mpz_init (b);\n\n  for (i = 0; i <= MAXN ; ++i)\n    {\n      mpz_setbit (DEN (a), i*m); /* \\sum_0^i 2^(i*m) */\n      for (j = 0; j <= MAXN; ++j)\n\t{\n\t  mpz_set_ui (NUM (a), 0);\n\t  mpz_setbit (NUM (a), j*m); /* 2^(j*m) */\n\t  for (k = 0; k <= MAXN; ++k)\n\t    {\n\t      mpz_set_ui (b, 0);\n\t      mpz_setbit (b, k*m); /* 2^(k*m) */\n\t      if (i == 0) /* Denominator is 1, compare the two exponents */\n\t\tccref = (j>k)-(j<k);\n\t      else\n\t\tccref = j-i > k ? 1 : -1;\n\t      for (s = 1; s >= -1; s -= 2)\n\t\t{\n\t\t  cc = mpq_cmp_z (a, b);\n\n\t\t  if (ccref != SGN (cc))\n\t\t    {\n\t\t      fprintf (stderr, \"i=%i, j=%i, k=%i, m=%i, s=%i\\n; ccref= %i, cc= %i\\n\", i, j, k, m, s, ccref, cc);\n\t\t      abort ();\n\t\t    }\n\n\t\t  mpq_neg (a, a);\n\t\t  mpz_neg (b, b);\n\t\t  ccref = - ccref;\n\t\t}\n\t    }\n\t}\n    }\n\n  mpq_clear (a);\n  mpz_clear (b);\n}",
      "lines": 47,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpq_t a;\n  mpz_t b;\n  mp_size_t size;\n  int reps = 10000;\n  int i;\n  int cc, ccref;\n\n  tests_start ();\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  mpq_init (a);\n  mpz_init (b);\n\n  for (i = 0; i < reps; i++)\n    {\n      if (i % 8192 == 0)\n\tsizes_test (urandom () % (i + 1) + 1);\t  \n      size = urandom () % SIZE - SIZE/2;\n      mpz_random2 (NUM (a), size);\n      do\n\t{\n\t  size = urandom () % (SIZE/2);\n\t  mpz_random2 (DEN (a), size);\n\t}\n      while (mpz_cmp_ui (DEN (a), 0) == 0);\n\n      size = urandom () % SIZE - SIZE/2;\n      mpz_random2 (b, size);\n\n      mpq_canonicalize (a);\n\n      ccref = ref_mpq_cmp_z (a, b);\n      cc = mpq_cmp_z (a, b);\n\n      if (SGN (ccref) != SGN (cc))\n\tabort ();\n    }\n\n  mpq_clear (a);\n  mpz_clear (b);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-equal.c": {
    "check_one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\ncheck_one (mpq_srcptr x, mpq_srcptr y, int want)\n{\n  int  got;\n\n  MPQ_CHECK_FORMAT (x);\n  MPQ_CHECK_FORMAT (y);\n\n  got = mpq_equal (x, y);\n  if ((got != 0) != (want != 0))\n    {\n      printf (\"mpq_equal got %d want %d\\n\", got, want);\n      mpq_trace (\"x\", x);\n      mpq_trace (\"y\", y);\n      abort ();\n    }\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_all": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\ncheck_all (mpq_ptr x, mpq_ptr y, int want)\n{\n  check_one (x, y, want);\n  check_one (y, x, want);\n\n  mpq_neg (x, x);\n  mpq_neg (y, y);\n\n  check_one (x, y, want);\n  check_one (y, x, want);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  mpq_t  x, y;\n\n  mpq_init (x);\n  mpq_init (y);\n\n  mpz_realloc (mpq_numref(x), (mp_size_t) 20);\n  mpz_realloc (mpq_denref(x), (mp_size_t) 20);\n  mpz_realloc (mpq_numref(y), (mp_size_t) 20);\n  mpz_realloc (mpq_denref(y), (mp_size_t) 20);\n\n  /* 0 == 0 */\n  SET4 (x, 0,13,12,11,10, 1,23,22,21,1);\n  SET4 (y, 0,33,32,31,30, 1,43,42,41,1);\n  check_all (x, y, 1);\n\n  /* 83/99 == 83/99 */\n  SET4 (x, 1,13,12,11,83, 1,23,22,21,99);\n  SET4 (y, 1,33,32,31,83, 1,43,42,41,99);\n  check_all (x, y, 1);\n\n  /* 1:2:3:4/5:6:7 == 1:2:3:4/5:6:7 */\n  SET4 (x, 4,1,2,3,4, 3,88,5,6,7);\n  SET4 (y, 4,1,2,3,4, 3,99,5,6,7);\n  check_all (x, y, 1);\n\n  /* various individual changes making != */\n  SET4 (x, 4,1,2,3,667, 3,88,5,6,7);\n  SET4 (y, 4,1,2,3,4, 3,99,5,6,7);\n  check_all (x, y, 0);\n  SET4 (x, 4,1,2,666,4, 3,88,5,6,7);\n  SET4 (y, 4,1,2,3,4, 3,99,5,6,7);\n  check_all (x, y, 0);\n  SET4 (x, 4,1,666,3,4, 3,88,5,6,7);\n  SET4 (y, 4,1,2,3,4, 3,99,5,6,7);\n  check_all (x, y, 0);\n#if GMP_NUMB_BITS != 62\n  SET4 (x, 4,667,2,3,4, 3,88,5,6,7);\n  SET4 (y, 4,1,2,3,4, 3,99,5,6,7);\n  check_all (x, y, 0);\n#endif\n  SET4 (x, 4,1,2,3,4, 3,88,5,6,667);\n  SET4 (y, 4,1,2,3,4, 3,99,5,6,7);\n  check_all (x, y, 0);\n  SET4 (x, 4,1,2,3,4, 3,88,5,667,7);\n  SET4 (y, 4,1,2,3,4, 3,99,5,6,7);\n  check_all (x, y, 0);\n  SET4 (x, 4,1,2,3,4, 3,88,666,6,7);\n  SET4 (y, 4,1,2,3,4, 3,99,5,6,7);\n  check_all (x, y, 0);\n  SET4 (x, -4,1,2,3,4, 3,88,5,6,7);\n  SET4 (y,  4,1,2,3,4, 3,99,5,6,7);\n  check_all (x, y, 0);\n  SET4 (x, 1,1,2,3,4, 3,88,5,6,7);\n  SET4 (y, 4,1,2,3,4, 3,99,5,6,7);\n  check_all (x, y, 0);\n  SET4 (x, 4,1,2,3,4, 3,88,5,6,7);\n  SET4 (y, 4,1,2,3,4, 2,99,5,6,7);\n  check_all (x, y, 0);\n\n  mpq_clear (x);\n  mpq_clear (y);\n}",
      "lines": 65,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_various ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-get_d.c": {
    "check_monotonic": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\ncheck_monotonic (int argc, char **argv)\n{\n  mpq_t a;\n  mp_size_t size;\n  int reps = 100;\n  int i, j;\n  double last_d, new_d;\n  mpq_t qlast_d, qnew_d;\n  mpq_t eps;\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  /* The idea here is to test the monotonousness of mpq_get_d by adding\n     numbers to the numerator and denominator.  */\n\n  mpq_init (a);\n  mpq_init (eps);\n  mpq_init (qlast_d);\n  mpq_init (qnew_d);\n\n  for (i = 0; i < reps; i++)\n    {\n      size = urandom () % SIZE - SIZE/2;\n      mpz_random2 (mpq_numref (a), size);\n      do\n\t{\n\t  size = urandom () % SIZE - SIZE/2;\n\t  mpz_random2 (mpq_denref (a), size);\n\t}\n      while (mpz_cmp_ui (mpq_denref (a), 0) == 0);\n\n      mpq_canonicalize (a);\n\n      last_d = mpq_get_d (a);\n      mpq_set_d (qlast_d, last_d);\n      for (j = 0; j < 10; j++)\n\t{\n\t  size = urandom () % EPSIZE + 1;\n\t  mpz_random2 (mpq_numref (eps), size);\n\t  size = urandom () % EPSIZE + 1;\n\t  mpz_random2 (mpq_denref (eps), size);\n\t  mpq_canonicalize (eps);\n\n\t  mpq_add (a, a, eps);\n\t  mpq_canonicalize (a);\n\t  new_d = mpq_get_d (a);\n\t  if (last_d > new_d)\n\t    {\n\t      printf (\"\\nERROR (test %d/%d): bad mpq_get_d results\\n\", i, j);\n\t      printf (\"last: %.16g\\n\", last_d);\n\t      printf (\" new: %.16g\\n\", new_d); dump (a);\n\t      abort ();\n\t    }\n\t  mpq_set_d (qnew_d, new_d);\n\t  MPQ_CHECK_FORMAT (qnew_d);\n\t  if (mpq_cmp (qlast_d, qnew_d) > 0)\n\t    {\n\t      printf (\"ERROR (test %d/%d): bad mpq_set_d results\\n\", i, j);\n\t      printf (\"last: %.16g\\n\", last_d); dump (qlast_d);\n\t      printf (\" new: %.16g\\n\", new_d); dump (qnew_d);\n\t      abort ();\n\t    }\n\t  last_d = new_d;\n\t  mpq_set (qlast_d, qnew_d);\n\t}\n    }\n\n  mpq_clear (a);\n  mpq_clear (eps);\n  mpq_clear (qlast_d);\n  mpq_clear (qnew_d);\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "my_ldexp": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "double\nmy_ldexp (double d, int e)\n{\n  for (;;)\n    {\n      if (e > 0)\n\t{\n\t  if (e >= 16)\n\t    {\n\t      d *= 65536.0;\n\t      e -= 16;\n\t    }\n\t  else\n\t    {\n\t      d *= 2.0;\n\t      e -= 1;\n\t    }\n\t}\n      else if (e < 0)\n\t{\n\n\t  if (e <= -16)\n\t    {\n\t      d /= 65536.0;\n\t      e += 16;\n\t    }\n\t  else\n\t    {\n\t      d /= 2.0;\n\t      e += 1;\n\t    }\n\t}\n      else\n\treturn d;\n    }\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "check_random": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "void\ncheck_random (int argc, char **argv)\n{\n  gmp_randstate_ptr rands = RANDS;\n\n  double d;\n  mpq_t q;\n  mpz_t a, t;\n  int exp;\n\n  int test, reps = 100000;\n\n  if (argc == 2)\n     reps = 100 * atoi (argv[1]);\n\n  mpq_init (q);\n  mpz_init (a);\n  mpz_init (t);\n\n  for (test = 0; test < reps; test++)\n    {\n      mpz_rrandomb (a, rands, 53);\n      mpz_urandomb (t, rands, 32);\n      exp = mpz_get_ui (t) % (2*MAXEXP) - MAXEXP;\n\n      d = my_ldexp (mpz_get_d (a), exp);\n      mpq_set_d (q, d);\n      /* Check that n/d = a * 2^exp, or\n\t d*a 2^{exp} = n */\n      mpz_mul (t, a, mpq_denref (q));\n      if (exp > 0)\n\tmpz_mul_2exp (t, t, exp);\n      else\n\t{\n\t  if (!mpz_divisible_2exp_p (t, -exp))\n\t    goto fail;\n\t  mpz_div_2exp (t, t, -exp);\n\t}\n      if (mpz_cmp (t, mpq_numref (q)) != 0)\n\t{\n\tfail:\n\t  printf (\"ERROR (check_random test %d): bad mpq_set_d results\\n\", test);\n\t  printf (\"%.16g\\n\", d);\n\t  gmp_printf (\"%Qd\\n\", q);\n\t  abort ();\n\t}\n    }\n  mpq_clear (q);\n  mpz_clear (t);\n  mpz_clear (a);\n}",
      "lines": 51,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "dump": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "void\ndump (mpq_t x)\n{\n  mpz_out_str (stdout, 10, mpq_numref (x));\n  printf (\"/\");\n  mpz_out_str (stdout, 10, mpq_denref (x));\n  printf (\"\\n\");\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "check_onebit": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "void\ncheck_onebit (void)\n{\n  static const long data[] = {\n    -3*GMP_NUMB_BITS-1, -3*GMP_NUMB_BITS, -3*GMP_NUMB_BITS+1,\n    -2*GMP_NUMB_BITS-1, -2*GMP_NUMB_BITS, -2*GMP_NUMB_BITS+1,\n    -GMP_NUMB_BITS-1, -GMP_NUMB_BITS, -GMP_NUMB_BITS+1,\n    -5, -2, -1, 0, 1, 2, 5,\n    GMP_NUMB_BITS-1, GMP_NUMB_BITS, GMP_NUMB_BITS+1,\n    2*GMP_NUMB_BITS-1, 2*GMP_NUMB_BITS, 2*GMP_NUMB_BITS+1,\n    3*GMP_NUMB_BITS-1, 3*GMP_NUMB_BITS, 3*GMP_NUMB_BITS+1,\n  };\n\n  int     i, neg;\n  long    exp, l;\n  mpq_t   q;\n  double  got, want;\n\n  mpq_init (q);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      exp = data[i];\n\n      mpq_set_ui (q, 1L, 1L);\n      if (exp >= 0)\n\tmpq_mul_2exp (q, q, exp);\n      else\n\tmpq_div_2exp (q, q, -exp);\n\n      want = 1.0;\n      for (l = 0; l < exp; l++)\n\twant *= 2.0;\n      for (l = 0; l > exp; l--)\n\twant /= 2.0;\n\n      for (neg = 0; neg <= 1; neg++)\n\t{\n\t  if (neg)\n\t    {\n\t      mpq_neg (q, q);\n\t      want = -want;\n\t    }\n\n\t  got = mpq_get_d (q);\n\n\t  if (got != want)\n\t    {\n\t      printf    (\"mpq_get_d wrong on %s2**%ld\\n\", neg ? \"-\" : \"\", exp);\n\t      mpq_trace (\"   q    \", q);\n\t      d_trace   (\"   want \", want);\n\t      d_trace   (\"   got  \", got);\n\t      abort();\n\t    }\n\t}\n    }\n  mpq_clear (q);\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  tests_start ();\n\n  check_onebit ();\n  check_monotonic (argc, argv);\n  check_random (argc, argv);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-get_str.c": {
    "check_one": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\ncheck_one (mpq_srcptr q, int base, const char *want)\n{\n  char    *str, *ret;\n  size_t  str_alloc;\n\n  MPQ_CHECK_FORMAT (q);\n  mp_trace_base = base;\n\n  str_alloc =\n    mpz_sizeinbase (mpq_numref(q), ABS(base)) +\n    mpz_sizeinbase (mpq_denref(q), ABS(base)) + 3;\n\n  str = mpq_get_str (NULL, base, q);\n  if (strlen(str)+1 > str_alloc)\n    {\n      printf (\"mpq_get_str size bigger than should be (passing NULL)\\n\");\n      printf (\"  base %d\\n\", base);\n      printf (\"  got  size %lu \\\"%s\\\"\\n\", (unsigned long)  strlen(str)+1, str);\n      printf (\"  want size %lu\\n\", (unsigned long) str_alloc);\n      abort ();\n    }\n  if (strcmp (str, want) != 0)\n    {\n      printf (\"mpq_get_str wrong (passing NULL)\\n\");\n      printf (\"  base %d\\n\", base);\n      printf (\"  got  \\\"%s\\\"\\n\", str);\n      printf (\"  want \\\"%s\\\"\\n\", want);\n      mpq_trace (\"  q\", q);\n      abort ();\n    }\n  (*__gmp_free_func) (str, strlen (str) + 1);\n\n  str = (char *) (*__gmp_allocate_func) (str_alloc);\n\n  ret = mpq_get_str (str, base, q);\n  if (str != ret)\n    {\n      printf (\"mpq_get_str wrong return value (passing non-NULL)\\n\");\n      printf (\"  base %d\\n\", base);\n      printf (\"  got  %p\\n\", ret);\n      printf (\"  want %p\\n\", want);\n      abort ();\n    }\n  if (strcmp (str, want) != 0)\n    {\n      printf (\"mpq_get_str wrong (passing non-NULL)\\n\");\n      printf (\"  base %d\\n\", base);\n      printf (\"  got  \\\"%s\\\"\\n\", str);\n      printf (\"  want \\\"%s\\\"\\n\", want);\n      abort ();\n    }\n  (*__gmp_free_func) (str, str_alloc);\n}",
      "lines": 54,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_all": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\ncheck_all (mpq_srcptr q, int base, const char *want)\n{\n  char  *s;\n\n  check_one (q, base, want);\n\n  s = __gmp_allocate_strdup (want);\n  strtoupper (s);\n  check_one (q, -base, s);\n  (*__gmp_free_func) (s, strlen(s)+1);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    int         base;\n    const char  *num;\n    const char  *den;\n    const char  *want;\n  } data[] = {\n    { 10, \"0\", \"1\", \"0\" },\n    { 10, \"1\", \"1\", \"1\" },\n\n    { 16, \"ffffffff\", \"1\", \"ffffffff\" },\n    { 16, \"ffffffffffffffff\", \"1\", \"ffffffffffffffff\" },\n\n    { 16, \"1\", \"ffffffff\", \"1/ffffffff\" },\n    { 16, \"1\", \"ffffffffffffffff\", \"1/ffffffffffffffff\" },\n    { 16, \"1\", \"10000000000000003\", \"1/10000000000000003\" },\n\n    { 10, \"12345678901234567890\", \"9876543210987654323\",\n      \"12345678901234567890/9876543210987654323\" },\n  };\n\n  mpq_t  q;\n  int    i;\n\n  mpq_init (q);\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (mpq_numref(q), data[i].num, data[i].base);\n      mpz_set_str_or_abort (mpq_denref(q), data[i].den, data[i].base);\n      check_all (q, data[i].base, data[i].want);\n    }\n  mpq_clear (q);\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-inp_str.c": {
    "check_data": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *inp;\n    int         base;\n    const char  *want;\n    int         want_nread;\n\n  } data[] = {\n\n    { \"0\",   10, \"0\", 1 },\n    { \"0/1\", 10, \"0\", 3 },\n\n    { \"0/\",   10, \"0\", 0 },\n    { \"/123\", 10, \"0\", 0 },\n    { \"blah\", 10, \"0\", 0 },\n    { \"123/blah\", 10, \"0\", 0 },\n    { \"5 /8\", 10, \"5\", 1 },\n    { \"5/ 8\", 10, \"0\", 0 },\n\n    {  \"ff\", 16,  \"255\", 2 },\n    { \"-ff\", 16, \"-255\", 3 },\n    {  \"FF\", 16,  \"255\", 2 },\n    { \"-FF\", 16, \"-255\", 3 },\n\n    { \"z\", 36, \"35\", 1 },\n    { \"Z\", 36, \"35\", 1 },\n\n    {  \"0x0\",    0,   \"0\", 3 },\n    {  \"0x10\",   0,  \"16\", 4 },\n    { \"-0x0\",    0,   \"0\", 4 },\n    { \"-0x10\",   0, \"-16\", 5 },\n    { \"-0x10/5\", 0, \"-16/5\", 7 },\n\n    {  \"00\",   0,  \"0\", 2 },\n    {  \"010\",  0,  \"8\", 3 },\n    { \"-00\",   0,  \"0\", 3 },\n    { \"-010\",  0, \"-8\", 4 },\n  };\n\n  mpq_t  got, want;\n  long   ftell_nread;\n  int    i, post, j, got_nread;\n  FILE   *fp;\n\n  mpq_init (got);\n  mpq_init (want);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      for (post = 0; post <= 2; post++)\n\t{\n\t  mpq_set_str_or_abort (want, data[i].want, 0);\n\t  MPQ_CHECK_FORMAT (want);\n\n\t  fp = fopen (FILENAME, \"w+\");\n\t  ASSERT_ALWAYS (fp != NULL);\n\t  fputs (data[i].inp, fp);\n\t  for (j = 0; j < post; j++)\n\t    putc (' ', fp);\n\t  fflush (fp);\n\t  ASSERT_ALWAYS (! ferror(fp));\n\n\t  rewind (fp);\n\t  got_nread = mpq_inp_str (got, fp, data[i].base);\n\n\t  if (got_nread != 0)\n\t    {\n\t      ftell_nread = ftell (fp);\n\t      if (got_nread != ftell_nread)\n\t\t{\n\t\t  printf (\"mpq_inp_str nread wrong\\n\");\n\t\t  printf (\"  inp          \\\"%s\\\"\\n\", data[i].inp);\n\t\t  printf (\"  base         %d\\n\", data[i].base);\n\t\t  printf (\"  got_nread    %d\\n\", got_nread);\n\t\t  printf (\"  ftell_nread  %ld\\n\", ftell_nread);\n\t\t  abort ();\n\t\t}\n\t    }\n\n\t  if (post == 0 && data[i].want_nread == strlen(data[i].inp))\n\t    {\n\t      int  c = getc(fp);\n\t      if (c != EOF)\n\t\t{\n\t\t  printf (\"mpq_inp_str didn't read to EOF\\n\");\n\t\t  printf (\"  inp         \\\"%s\\\"\\n\", data[i].inp);\n\t\t  printf (\"  base        %d\\n\", data[i].base);\n\t\t  printf (\"  c '%c' %#x\\n\", c, c);\n\t\t  abort ();\n\t\t}\n\t    }\n\n\t  if (got_nread != data[i].want_nread)\n\t    {\n\t      printf (\"mpq_inp_str nread wrong\\n\");\n\t      printf (\"  inp         \\\"%s\\\"\\n\", data[i].inp);\n\t      printf (\"  base        %d\\n\", data[i].base);\n\t      printf (\"  got_nread   %d\\n\", got_nread);\n\t      printf (\"  want_nread  %d\\n\", data[i].want_nread);\n\t      abort ();\n\t    }\n\n\t  MPQ_CHECK_FORMAT (got);\n\n\t  if (! mpq_equal (got, want))\n\t    {\n\t      printf (\"mpq_inp_str wrong result\\n\");\n\t      printf (\"  inp   \\\"%s\\\"\\n\", data[i].inp);\n\t      printf (\"  base  %d\\n\", data[i].base);\n\t      mpq_trace (\"  got \",  got);\n\t      mpq_trace (\"  want\", want);\n\t      abort ();\n\t    }\n\n\t  ASSERT_ALWAYS (fclose (fp) == 0);\n\t}\n    }\n\n  mpq_clear (got);\n  mpq_clear (want);\n}",
      "lines": 123,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n\n  unlink (FILENAME);\n  tests_end ();\n\n  exit (0);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-inv.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpq_t a, b;\n  mpz_t m, n;\n  const char* s = \"-420000000000000000000000\";\n\n  tests_start ();\n\n  mpq_inits (a, b, (mpq_ptr)0);\n  mpz_inits (m, n, (mpz_ptr)0);\n\n  mpz_set_ui (m, 13);\n  mpq_set_den (a, m);\n  mpz_set_str (m, s, 0);\n  mpq_set_num (a, m);\n  MPQ_CHECK_FORMAT (a);\n  mpq_inv (b, a);\n  MPQ_CHECK_FORMAT (b);\n  mpq_get_num (n, b);\n  ASSERT_ALWAYS (mpz_cmp_si (n, -13) == 0);\n  mpq_neg (b, b);\n  mpq_inv (a, b);\n  MPQ_CHECK_FORMAT (a);\n  mpq_inv (b, b);\n  MPQ_CHECK_FORMAT (b);\n  mpq_get_den (n, b);\n  ASSERT_ALWAYS (mpz_cmp_ui (n, 13) == 0);\n  mpq_get_num (n, a);\n  mpz_add (n, n, m);\n  ASSERT_ALWAYS (mpz_sgn (n) == 0);\n\n  mpq_clears (a, b, (mpq_ptr)0);\n  mpz_clears (m, n, (mpz_ptr)0);\n\n  tests_end ();\n  return 0;\n}",
      "lines": 38,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-md_2exp.c": {
    "check_random": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\ncheck_random ()\n{\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long arg_size, size_range;\n  mpq_t q, r;\n  int i;\n  mp_bitcnt_t shift;\n  int reps = 10000;\n\n  rands = RANDS;\n\n  mpz_init (bs);\n  mpq_init (q);\n  mpq_init (r);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 11 + 2; /* 0..4096 bit operands */\n\n      mpz_urandomb (bs, rands, size_range);\n      arg_size = mpz_get_ui (bs);\n      mpz_rrandomb (mpq_numref (q), rands, arg_size);\n      do\n\t{\n\t  mpz_urandomb (bs, rands, size_range);\n\t  arg_size = mpz_get_ui (bs);\n\t  mpz_rrandomb (mpq_denref (q), rands, arg_size);\n\t}\n      while (mpz_sgn (mpq_denref (q)) == 0);\n\n      /* We now have a random rational in q, albeit an unnormalised one.  The\n\t lack of normalisation should not matter here, so let's save the time a\n\t gcd would require.  */\n\n      mpz_urandomb (bs, rands, 32);\n      shift = mpz_get_ui (bs) % 4096;\n\n      mpq_mul_2exp (r, q, shift);\n\n      if (mpq_cmp (r, q) < 0)\n\t{\n\t  printf (\"mpq_mul_2exp wrong on random\\n\");\n\t  abort ();\n\t}\n\n      mpq_div_2exp (r, r, shift);\n\n      if (mpq_cmp (r, q) != 0)\n\t{\n\t  printf (\"mpq_mul_2exp or mpq_div_2exp wrong on random\\n\");\n\t  abort ();\n\t}\n    }\n  mpq_clear (q);\n  mpq_clear (r);\n  mpz_clear (bs);\n}",
      "lines": 60,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  static const struct {\n    struct pair_t  left;\n    unsigned long  n;\n    struct pair_t  right;\n\n  } data[] = {\n    { {\"0\",\"1\"}, 0, {\"0\",\"1\"} },\n    { {\"0\",\"1\"}, 1, {\"0\",\"1\"} },\n    { {\"0\",\"1\"}, 2, {\"0\",\"1\"} },\n\n    { {\"1\",\"1\"}, 0, {\"1\",\"1\"} },\n    { {\"1\",\"1\"}, 1, {\"2\",\"1\"} },\n    { {\"1\",\"1\"}, 2, {\"4\",\"1\"} },\n    { {\"1\",\"1\"}, 3, {\"8\",\"1\"} },\n\n    { {\"1\",\"1\"}, 31, {\"0x80000000\",\"1\"} },\n    { {\"1\",\"1\"}, 32, {\"0x100000000\",\"1\"} },\n    { {\"1\",\"1\"}, 33, {\"0x200000000\",\"1\"} },\n    { {\"1\",\"1\"}, 63, {\"0x8000000000000000\",\"1\"} },\n    { {\"1\",\"1\"}, 64, {\"0x10000000000000000\",\"1\"} },\n    { {\"1\",\"1\"}, 65, {\"0x20000000000000000\",\"1\"} },\n    { {\"1\",\"1\"}, 95, {\"0x800000000000000000000000\",\"1\"} },\n    { {\"1\",\"1\"}, 96, {\"0x1000000000000000000000000\",\"1\"} },\n    { {\"1\",\"1\"}, 97, {\"0x2000000000000000000000000\",\"1\"} },\n    { {\"1\",\"1\"}, 127, {\"0x80000000000000000000000000000000\",\"1\"} },\n    { {\"1\",\"1\"}, 128, {\"0x100000000000000000000000000000000\",\"1\"} },\n    { {\"1\",\"1\"}, 129, {\"0x200000000000000000000000000000000\",\"1\"} },\n\n    { {\"1\",\"2\"}, 31, {\"0x40000000\",\"1\"} },\n    { {\"1\",\"2\"}, 32, {\"0x80000000\",\"1\"} },\n    { {\"1\",\"2\"}, 33, {\"0x100000000\",\"1\"} },\n    { {\"1\",\"2\"}, 63, {\"0x4000000000000000\",\"1\"} },\n    { {\"1\",\"2\"}, 64, {\"0x8000000000000000\",\"1\"} },\n    { {\"1\",\"2\"}, 65, {\"0x10000000000000000\",\"1\"} },\n    { {\"1\",\"2\"}, 95, {\"0x400000000000000000000000\",\"1\"} },\n    { {\"1\",\"2\"}, 96, {\"0x800000000000000000000000\",\"1\"} },\n    { {\"1\",\"2\"}, 97, {\"0x1000000000000000000000000\",\"1\"} },\n    { {\"1\",\"2\"}, 127, {\"0x40000000000000000000000000000000\",\"1\"} },\n    { {\"1\",\"2\"}, 128, {\"0x80000000000000000000000000000000\",\"1\"} },\n    { {\"1\",\"2\"}, 129, {\"0x100000000000000000000000000000000\",\"1\"} },\n\n    { {\"1\",\"0x80000000\"}, 30, {\"1\",\"2\"} },\n    { {\"1\",\"0x80000000\"}, 31, {\"1\",\"1\"} },\n    { {\"1\",\"0x80000000\"}, 32, {\"2\",\"1\"} },\n    { {\"1\",\"0x80000000\"}, 33, {\"4\",\"1\"} },\n    { {\"1\",\"0x80000000\"}, 62, {\"0x80000000\",\"1\"} },\n    { {\"1\",\"0x80000000\"}, 63, {\"0x100000000\",\"1\"} },\n    { {\"1\",\"0x80000000\"}, 64, {\"0x200000000\",\"1\"} },\n    { {\"1\",\"0x80000000\"}, 94, {\"0x8000000000000000\",\"1\"} },\n    { {\"1\",\"0x80000000\"}, 95, {\"0x10000000000000000\",\"1\"} },\n    { {\"1\",\"0x80000000\"}, 96, {\"0x20000000000000000\",\"1\"} },\n    { {\"1\",\"0x80000000\"}, 126, {\"0x800000000000000000000000\",\"1\"} },\n    { {\"1\",\"0x80000000\"}, 127, {\"0x1000000000000000000000000\",\"1\"} },\n    { {\"1\",\"0x80000000\"}, 128, {\"0x2000000000000000000000000\",\"1\"} },\n\n    { {\"1\",\"0x100000000\"}, 1, {\"1\",\"0x80000000\"} },\n    { {\"1\",\"0x100000000\"}, 2, {\"1\",\"0x40000000\"} },\n    { {\"1\",\"0x100000000\"}, 3, {\"1\",\"0x20000000\"} },\n\n    { {\"1\",\"0x10000000000000000\"}, 1, {\"1\",\"0x8000000000000000\"} },\n    { {\"1\",\"0x10000000000000000\"}, 2, {\"1\",\"0x4000000000000000\"} },\n    { {\"1\",\"0x10000000000000000\"}, 3, {\"1\",\"0x2000000000000000\"} },\n  };\n\n  void (*fun) (mpq_ptr, mpq_srcptr, unsigned long);\n  const struct pair_t  *p_start, *p_want;\n  const char  *name;\n  mpq_t    sep, got, want;\n  mpq_ptr  q;\n  int      i, muldiv, sign, overlap;\n\n  tests_start ();\n\n  mpq_init (sep);\n  mpq_init (got);\n  mpq_init (want);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      for (muldiv = 0; muldiv < 2; muldiv++)\n        {\n          if (muldiv == 0)\n            {\n              fun = mpq_mul_2exp;\n              name = \"mpq_mul_2exp\";\n              p_start = &data[i].left;\n              p_want = &data[i].right;\n            }\n          else\n            {\n              fun = mpq_div_2exp;\n              name = \"mpq_div_2exp\";\n              p_start = &data[i].right;\n              p_want = &data[i].left;\n            }\n\n          for (sign = 0; sign <= 1; sign++)\n            {\n              mpz_set_str_or_abort (mpq_numref(want), p_want->num, 0);\n              mpz_set_str_or_abort (mpq_denref(want), p_want->den, 0);\n              if (sign)\n                mpq_neg (want, want);\n\n              for (overlap = 0; overlap <= 1; overlap++)\n                {\n                  q = overlap ? got : sep;\n\n                  /* initial garbage in \"got\" */\n                  mpq_set_ui (got, 123L, 456L);\n\n                  mpz_set_str_or_abort (mpq_numref(q), p_start->num, 0);\n                  mpz_set_str_or_abort (mpq_denref(q), p_start->den, 0);\n                  if (sign)\n                    mpq_neg (q, q);\n\n                  (*fun) (got, q, data[i].n);\n                  MPQ_CHECK_FORMAT (got);\n\n                  if (! mpq_equal (got, want))\n                    {\n                      printf (\"%s wrong at data[%d], sign %d, overlap %d\\n\",\n                              name, i, sign, overlap);\n                      printf (\"   num \\\"%s\\\"\\n\", p_start->num);\n                      printf (\"   den \\\"%s\\\"\\n\", p_start->den);\n                      printf (\"   n   %lu\\n\", data[i].n);\n\n                      printf (\"   got  \");\n                      mpq_out_str (stdout, 16, got);\n                      printf (\" (hex)\\n\");\n\n                      printf (\"   want \");\n                      mpq_out_str (stdout, 16, want);\n                      printf (\" (hex)\\n\");\n\n                      abort ();\n                    }\n                }\n            }\n        }\n    }\n\n  check_random ();\n\n  mpq_clear (sep);\n  mpq_clear (got);\n  mpq_clear (want);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 153,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-set_f.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n#if GMP_NAIL_BITS == 0\n  static const struct {\n    int         f_base;\n    const char  *f;\n    int         z_base;\n    const char  *want_num;\n    const char  *want_den;\n\n  } data[] = {\n\n    { -2, \"0\",    16, \"0\", \"1\" },\n    { -2, \"1\",    16, \"1\", \"1\" },\n    { -2, \"1@1\",  16, \"2\", \"1\" },\n    { -2, \"1@2\",  16, \"4\", \"1\" },\n    { -2, \"1@3\",  16, \"8\", \"1\" },\n\n    { -2, \"1@30\", 16,  \"40000000\", \"1\" },\n    { -2, \"1@31\", 16,  \"80000000\", \"1\" },\n    { -2, \"1@32\", 16, \"100000000\", \"1\" },\n    { -2, \"1@33\", 16, \"200000000\", \"1\" },\n    { -2, \"1@34\", 16, \"400000000\", \"1\" },\n\n    { -2, \"1@62\", 16,  \"4000000000000000\", \"1\" },\n    { -2, \"1@63\", 16,  \"8000000000000000\", \"1\" },\n    { -2, \"1@64\", 16, \"10000000000000000\", \"1\" },\n    { -2, \"1@65\", 16, \"20000000000000000\", \"1\" },\n    { -2, \"1@66\", 16, \"40000000000000000\", \"1\" },\n\n    { -2, \"1@126\", 16,  \"40000000000000000000000000000000\", \"1\" },\n    { -2, \"1@127\", 16,  \"80000000000000000000000000000000\", \"1\" },\n    { -2, \"1@128\", 16, \"100000000000000000000000000000000\", \"1\" },\n    { -2, \"1@129\", 16, \"200000000000000000000000000000000\", \"1\" },\n    { -2, \"1@130\", 16, \"400000000000000000000000000000000\", \"1\" },\n\n    { -2, \"1@-1\",  16, \"1\", \"2\" },\n    { -2, \"1@-2\",  16, \"1\", \"4\" },\n    { -2, \"1@-3\",  16, \"1\", \"8\" },\n\n    { -2, \"1@-30\", 16, \"1\",  \"40000000\" },\n    { -2, \"1@-31\", 16, \"1\",  \"80000000\" },\n    { -2, \"1@-32\", 16, \"1\", \"100000000\" },\n    { -2, \"1@-33\", 16, \"1\", \"200000000\" },\n    { -2, \"1@-34\", 16, \"1\", \"400000000\" },\n\n    { -2, \"1@-62\", 16, \"1\",  \"4000000000000000\" },\n    { -2, \"1@-63\", 16, \"1\",  \"8000000000000000\" },\n    { -2, \"1@-64\", 16, \"1\", \"10000000000000000\" },\n    { -2, \"1@-65\", 16, \"1\", \"20000000000000000\" },\n    { -2, \"1@-66\", 16, \"1\", \"40000000000000000\" },\n\n    { -2, \"1@-126\", 16, \"1\",  \"40000000000000000000000000000000\" },\n    { -2, \"1@-127\", 16, \"1\",  \"80000000000000000000000000000000\" },\n    { -2, \"1@-128\", 16, \"1\", \"100000000000000000000000000000000\" },\n    { -2, \"1@-129\", 16, \"1\", \"200000000000000000000000000000000\" },\n    { -2, \"1@-130\", 16, \"1\", \"400000000000000000000000000000000\" },\n\n    { -2, \"1@-30\", 16, \"1\",  \"40000000\" },\n    { -2, \"1@-31\", 16, \"1\",  \"80000000\" },\n    { -2, \"1@-32\", 16, \"1\", \"100000000\" },\n    { -2, \"1@-33\", 16, \"1\", \"200000000\" },\n    { -2, \"1@-34\", 16, \"1\", \"400000000\" },\n\n    { -2, \"11@-62\", 16, \"3\",  \"4000000000000000\" },\n    { -2, \"11@-63\", 16, \"3\",  \"8000000000000000\" },\n    { -2, \"11@-64\", 16, \"3\", \"10000000000000000\" },\n    { -2, \"11@-65\", 16, \"3\", \"20000000000000000\" },\n    { -2, \"11@-66\", 16, \"3\", \"40000000000000000\" },\n\n    { 16, \"80000000.00000001\", 16, \"8000000000000001\", \"100000000\" },\n    { 16, \"80000000.00000008\", 16, \"1000000000000001\",  \"20000000\" },\n    { 16, \"80000000.8\",        16, \"100000001\", \"2\" },\n\n  };\n\n  mpf_t  f;\n  mpq_t  got;\n  mpz_t  want_num, want_den;\n  int    i, neg;\n\n  tests_start ();\n\n  mpf_init2 (f, 1024L);\n  mpq_init (got);\n  mpz_init (want_num);\n  mpz_init (want_den);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      for (neg = 0; neg <= 1; neg++)\n        {\n          mpf_set_str_or_abort (f, data[i].f, data[i].f_base);\n          mpz_set_str_or_abort (want_num, data[i].want_num, data[i].z_base);\n          mpz_set_str_or_abort (want_den, data[i].want_den, data[i].z_base);\n\n          if (neg)\n            {\n              mpf_neg (f, f);\n              mpz_neg (want_num, want_num);\n            }\n\n          mpq_set_f (got, f);\n          MPQ_CHECK_FORMAT (got);\n\n          if (mpz_cmp (mpq_numref(got), want_num) != 0\n              || mpz_cmp (mpq_denref(got), want_den) != 0)\n            {\n              printf (\"wrong at data[%d]\\n\", i);\n              printf (\"   f_base %d, z_base %d\\n\",\n                      data[i].f_base, data[i].z_base);\n\n              printf (\"   f \\\"%s\\\" hex \", data[i].f);\n              mpf_out_str (stdout, 16, 0, f);\n              printf (\"\\n\");\n\n              printf (\"   want num 0x\");\n              mpz_out_str (stdout, 16, want_num);\n              printf (\"\\n\");\n              printf (\"   want den 0x\");\n              mpz_out_str (stdout, 16, want_den);\n              printf (\"\\n\");\n\n              printf (\"   got num 0x\");\n              mpz_out_str (stdout, 16, mpq_numref(got));\n              printf (\"\\n\");\n              printf (\"   got den 0x\");\n              mpz_out_str (stdout, 16, mpq_denref(got));\n              printf (\"\\n\");\n\n              abort ();\n            }\n        }\n    }\n\n  mpf_clear (f);\n  mpq_clear (got);\n  mpz_clear (want_num);\n  mpz_clear (want_den);\n\n  tests_end ();\n#endif\n  exit (0);\n}",
      "lines": 145,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpq/t-set_str.c": {
    "check_one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\ncheck_one (mpq_srcptr want, int base, const char *str)\n{\n  mpq_t   got;\n\n  MPQ_CHECK_FORMAT (want);\n  mp_trace_base = base;\n\n  mpq_init (got);\n\n  if (mpq_set_str (got, str, base) != 0)\n    {\n      printf (\"mpq_set_str unexpectedly failed\\n\");\n      printf (\"  base %d\\n\", base);\n      printf (\"  str  \\\"%s\\\"\\n\", str);\n      abort ();\n    }\n  MPQ_CHECK_FORMAT (got);\n\n  if (! mpq_equal (got, want))\n    {\n      printf (\"mpq_set_str wrong\\n\");\n      printf (\"  base %d\\n\", base);\n      printf (\"  str  \\\"%s\\\"\\n\", str);\n      mpq_trace (\"got \", got);\n      mpq_trace (\"want\", want);\n      abort ();\n    }\n\n  mpq_clear (got);\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_samples": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\ncheck_samples (void)\n{\n  mpq_t  q;\n\n  mpq_init (q);\n\n  mpq_set_ui (q, 0L, 1L);\n  check_one (q, 10, \"0\");\n  check_one (q, 10, \"0/1\");\n  check_one (q, 10, \"0  / 1\");\n  check_one (q, 0, \"0x0/ 1\");\n  check_one (q, 0, \"0x0/ 0x1\");\n  check_one (q, 0, \"0 / 0x1\");\n\n  check_one (q, 10, \"-0\");\n  check_one (q, 10, \"-0/1\");\n  check_one (q, 10, \"-0  / 1\");\n  check_one (q, 0, \"-0x0/ 1\");\n  check_one (q, 0, \"-0x0/ 0x1\");\n  check_one (q, 0, \"-0 / 0x1\");\n\n  mpq_set_ui (q, 255L, 256L);\n  check_one (q, 10, \"255/256\");\n  check_one (q, 0,  \"0xFF/0x100\");\n  check_one (q, 16, \"FF/100\");\n\n  mpq_neg (q, q);\n  check_one (q, 10, \"-255/256\");\n  check_one (q, 0,  \"-0xFF/0x100\");\n  check_one (q, 16, \"-FF/100\");\n\n  mpq_clear (q);\n}",
      "lines": 34,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_samples ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/bit.c": {
    "debug_mp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "void\ndebug_mp (mpz_srcptr x, int base)\n{\n  mpz_out_str (stdout, base, x); fputc ('\\n', stdout);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "check_clr_extend": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\ncheck_clr_extend (void)\n{\n  mpz_t          got, want;\n  unsigned long  i;\n  int            f;\n\n  mpz_init (got);\n  mpz_init (want);\n\n  for (i = 1; i < 5; i++)\n    {\n      for (f = 0; f <= 1; f++)\n\t{\n\t  /* lots of 1 bits in _mp_d */\n\t  mpz_set_si (got, 1L);\n\t  mpz_mul_2exp (got, got, 10*GMP_NUMB_BITS);\n\t  mpz_sub_ui (got, got, 1L);\n\n\t  /* value -2^(n-1) representing ..11100..00 */\n\t  mpz_set_si (got, -1L);\n\t  mpz_mul_2exp (got, got, i*GMP_NUMB_BITS-1);\n\n\t  /* complement bit n, giving ..11000..00 which is -2^n */\n\t  if (f == 0)\n\t    mpz_clrbit (got, i*GMP_NUMB_BITS-1);\n\t  else\n\t    mpz_combit (got, i*GMP_NUMB_BITS-1);\n\t  MPZ_CHECK_FORMAT (got);\n\n\t  mpz_set_si (want, -1L);\n\t  mpz_mul_2exp (want, want, i*GMP_NUMB_BITS);\n\n\t  if (mpz_cmp (got, want) != 0)\n\t    {\n\t      if (f == 0)\n\t\tprintf (\"mpz_clrbit: \");\n\t      else\n\t\tprintf (\"mpz_combit: \");\n\t      printf (\"wrong after extension\\n\");\n\t      mpz_trace (\"got \", got);\n\t      mpz_trace (\"want\", want);\n\t      abort ();\n\t    }\n\n\t  /* complement bit n, going back to ..11100..00 which is -2^(n-1) */\n\t  if (f == 0)\n\t    mpz_setbit (got, i*GMP_NUMB_BITS-1);\n\t  else\n\t    mpz_combit (got, i*GMP_NUMB_BITS-1);\n\t  MPZ_CHECK_FORMAT (got);\n\n\t  mpz_set_si (want, -1L);\n\t  mpz_mul_2exp (want, want, i*GMP_NUMB_BITS - 1);\n\n\t  if (mpz_cmp (got, want) != 0)\n\t    {\n\t      if (f == 0)\n\t\tprintf (\"mpz_setbit: \");\n\t      else\n\t\tprintf (\"mpz_combit: \");\n\t      printf (\"wrong after shrinking\\n\");\n\t      mpz_trace (\"got \", got);\n\t      mpz_trace (\"want\", want);\n\t      abort ();\n\t    }\n\t}\n    }\n\n  mpz_clear (got);\n  mpz_clear (want);\n}",
      "lines": 72,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "check_com_negs": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "void\ncheck_com_negs (void)\n{\n  static const struct {\n    unsigned long  bit;\n    mp_size_t      inp_size;\n    mp_limb_t      inp_n[5];\n    mp_size_t      want_size;\n    mp_limb_t      want_n[5];\n  } data[] = {\n    { GMP_NUMB_BITS,   2, { 1, 1 },  1, { 1 } },\n    { GMP_NUMB_BITS+1, 2, { 1, 1 },  2, { 1, 3 } },\n\n    { GMP_NUMB_BITS,   2, { 0, 1 },  2, { 0, 2 } },\n    { GMP_NUMB_BITS+1, 2, { 0, 1 },  2, { 0, 3 } },\n  };\n  mpz_t  inp, got, want;\n  int    i;\n\n  mpz_init (got);\n  mpz_init (want);\n  mpz_init (inp);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_n (inp, data[i].inp_n, data[i].inp_size);\n      mpz_neg (inp, inp);\n\n      mpz_set_n (want, data[i].want_n, data[i].want_size);\n      mpz_neg (want, want);\n\n      mpz_set (got, inp);\n      mpz_combit (got, data[i].bit);\n\n      if (mpz_cmp (got, want) != 0)\n\t{\n\t  printf (\"mpz_combit: wrong on neg data[%d]\\n\", i);\n\t  mpz_trace (\"inp \", inp);\n\t  printf    (\"bit %lu\\n\", data[i].bit);\n\t  mpz_trace (\"got \", got);\n\t  mpz_trace (\"want\", want);\n\t  abort ();\n\t}\n    }\n\n  mpz_clear (inp);\n  mpz_clear (got);\n  mpz_clear (want);\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_tstbit": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "void\ncheck_tstbit (void)\n{\n#define MAX_ZEROS  3\n#define NUM_LIMBS  3\n\n  mp_limb_t      pos[1+NUM_LIMBS+MAX_ZEROS];\n  mp_limb_t      neg[1+NUM_LIMBS+MAX_ZEROS];\n  mpz_t          z;\n  unsigned long  i;\n  int            zeros, low1;\n  int            got, want;\n\n  mpz_init (z);\n  for (zeros = 0; zeros <= MAX_ZEROS; zeros++)\n    {\n      MPN_ZERO (pos, numberof(pos));\n      mpn_random2 (pos+zeros, (mp_size_t) NUM_LIMBS);\n\n      for (low1 = 0; low1 <= 1; low1++)\n\t{\n\t  if (low1)\n\t    pos[0] |= 1;\n\n\t  refmpn_neg (neg, pos, (mp_size_t) numberof(neg));\n\t  mpz_set_n (z, neg, (mp_size_t) numberof(neg));\n\t  mpz_neg (z, z);\n\n\t  for (i = 0; i < numberof(pos)*GMP_NUMB_BITS; i++)\n\t    {\n\t      got = mpz_tstbit (z, i);\n\t      want = refmpn_tstbit (pos, i);\n\t      if (got != want)\n\t\t{\n\t\t  printf (\"wrong at bit %lu, with %d zeros\\n\", i, zeros);\n\t\t  printf (\"z neg \"); debug_mp (z, -16);\n\t\t  mpz_set_n (z, pos, (mp_size_t) numberof(pos));\n\t\t  printf (\"pos   \"); debug_mp (z, -16);\n\t\t  mpz_set_n (z, neg, (mp_size_t) numberof(neg));\n\t\t  printf (\"neg   \"); debug_mp (z, -16);\n\t\t  exit (1);\n\t\t}\n\t    }\n\t}\n    }\n  mpz_clear (z);\n}",
      "lines": 47,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "check_single": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "void\ncheck_single (void)\n{\n  mpz_t  x;\n  int    limb, offset, initial;\n  unsigned long  bit;\n\n  mpz_init (x);\n\n  for (limb = 0; limb < 4; limb++)\n    {\n      for (offset = (limb==0 ? 0 : -2); offset <= 2; offset++)\n\t{\n\t  for (initial = 1; initial >= -1; initial--)\n\t    {\n\t      mpz_set_si (x, (long) initial);\n\n\t      bit = (unsigned long) limb*GMP_LIMB_BITS + offset;\n\n\t      mpz_clrbit (x, bit);\n\t      MPZ_CHECK_FORMAT (x);\n\t      if (mpz_tstbit (x, bit) != 0)\n\t\t{\n\t\t  printf (\"check_single(): expected 0\\n\");\n\t\t  abort ();\n\t\t}\n\n\t      mpz_setbit (x, bit);\n\t      MPZ_CHECK_FORMAT (x);\n\t      if (mpz_tstbit (x, bit) != 1)\n\t\t{\n\t\t  printf (\"check_single(): expected 1\\n\");\n\t\t  abort ();\n\t\t}\n\n\t      mpz_clrbit (x, bit);\n\t      MPZ_CHECK_FORMAT (x);\n\t      if (mpz_tstbit (x, bit) != 0)\n\t\t{\n\t\t  printf (\"check_single(): expected 0\\n\");\n\t\t  abort ();\n\t\t}\n\n\t      mpz_combit (x, bit);\n\t      MPZ_CHECK_FORMAT (x);\n\t      if (mpz_tstbit (x, bit) != 1)\n\t\t{\n\t\t  printf (\"check_single(): expected 1\\n\");\n\t\t  abort ();\n\t\t}\n\n\t      mpz_combit (x, bit);\n\t      MPZ_CHECK_FORMAT (x);\n\t      if (mpz_tstbit (x, bit) != 0)\n\t\t{\n\t\t  printf (\"check_single(): expected 0\\n\");\n\t\t  abort ();\n\t\t}\n\t    }\n\t}\n    }\n\n  mpz_clear (x);\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "void\ncheck_random (int argc, char *argv[])\n{\n  mpz_t x, s0, s1, s2, s3, m;\n  mp_size_t xsize;\n  int i;\n  int reps = 100000;\n  int bit0, bit1, bit2, bit3;\n  unsigned long int bitindex;\n  const char  *s = \"\";\n\n  if (argc == 2)\n    reps = atoi (argv[1]);\n\n  mpz_init (x);\n  mpz_init (s0);\n  mpz_init (s1);\n  mpz_init (s2);\n  mpz_init (s3);\n  mpz_init (m);\n\n  for (i = 0; i < reps; i++)\n    {\n      xsize = urandom () % (2 * SIZE) - SIZE;\n      mpz_random2 (x, xsize);\n      bitindex = urandom () % SIZE;\n\n      mpz_set (s0, x);\n      bit0 = mpz_tstbit (x, bitindex);\n      mpz_setbit (x, bitindex);\n      MPZ_CHECK_FORMAT (x);\n\n      mpz_set (s1, x);\n      bit1 = mpz_tstbit (x, bitindex);\n      mpz_clrbit (x, bitindex);\n      MPZ_CHECK_FORMAT (x);\n\n      mpz_set (s2, x);\n      bit2 = mpz_tstbit (x, bitindex);\n      mpz_combit (x, bitindex);\n      MPZ_CHECK_FORMAT (x);\n\n      mpz_set (s3, x);\n      bit3 = mpz_tstbit (x, bitindex);\n\n#define FAIL(str) do { s = str; goto fail; } while (0)\n\n      if (bit1 != 1)  FAIL (\"bit1 != 1\");\n      if (bit2 != 0)  FAIL (\"bit2 != 0\");\n      if (bit3 != 1)  FAIL (\"bit3 != 1\");\n\n      if (bit0 == 0)\n\t{\n\t  if (mpz_cmp (s0, s1) == 0 || mpz_cmp (s0, s2) != 0 || mpz_cmp (s0, s3) == 0)\n\t    abort ();\n\t}\n      else\n\t{\n\t  if (mpz_cmp (s0, s1) != 0 || mpz_cmp (s0, s2) == 0 || mpz_cmp (s0, s3) != 0)\n\t    abort ();\n\t}\n\n      if (mpz_cmp (s1, s2) == 0 || mpz_cmp (s1, s3) != 0)\n\tabort ();\n      if (mpz_cmp (s2, s3) == 0)\n\tabort ();\n\n      mpz_combit (x, bitindex);\n      MPZ_CHECK_FORMAT (x);\n      if (mpz_cmp (s2, x) != 0)\n\tabort ();\n\n      mpz_clrbit (x, bitindex);\n      MPZ_CHECK_FORMAT (x);\n      if (mpz_cmp (s2, x) != 0)\n\tabort ();\n\n      mpz_ui_pow_ui (m, 2L, bitindex);\n      MPZ_CHECK_FORMAT (m);\n      mpz_ior (x, s0, m);\n      MPZ_CHECK_FORMAT (x);\n      if (mpz_cmp (x, s3) != 0)\n\tabort ();\n\n      mpz_com (m, m);\n      MPZ_CHECK_FORMAT (m);\n      mpz_and (x, s0, m);\n      MPZ_CHECK_FORMAT (x);\n      if (mpz_cmp (x, s2) != 0)\n\tabort ();\n    }\n\n  mpz_clear (x);\n  mpz_clear (s0);\n  mpz_clear (s1);\n  mpz_clear (s2);\n  mpz_clear (s3);\n  mpz_clear (m);\n  return;\n\n\n fail:\n  printf (\"%s\\n\", s);\n  printf (\"bitindex = %lu\\n\", bitindex);\n  printf (\"x = \"); mpz_out_str (stdout, -16, x); printf (\" hex\\n\");\n  exit (1);\n}",
      "lines": 107,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_clr_extend ();\n  check_com_negs ();\n  check_tstbit ();\n  check_random (argc, argv);\n  check_single ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/convert.c": {
    "string_urandomb": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "void\nstring_urandomb (char *bp, size_t len, int base, gmp_randstate_ptr rands)\n{\n  mpz_t bs;\n  unsigned long bsi;\n  int d, l;\n  const char *collseq = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n  mpz_init (bs);\n\n  mpz_urandomb (bs, rands, 32);\n  bsi = mpz_get_ui (bs);\n  d = bsi % base;\n  while (len != 0)\n    {\n      l = (bsi >> 16) % 20;\n      l = MIN (l, len);\n\n      memset (bp, collseq[d], l);\n\n      len -= l;\n      bp += l;\n\n      mpz_urandomb (bs, rands, 32);\n      bsi = mpz_get_ui (bs);\n      d = bsi & 0xfff;\n      if (d >= base)\n\td = 0;\n    }\n\n  bp[0] = '\\0';\n  mpz_clear (bs);\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t op1, op2;\n  mp_size_t size;\n  int i;\n  int reps = 2000;\n  char *str, *buf, *bp;\n  int base;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n  size_t len;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  mpz_init (op1);\n  mpz_init (op2);\n\n  for (i = 0; i < reps; i++)\n    {\n      /* 1. Generate random mpz_t and convert to a string and back to mpz_t\n\t again.  */\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 17 + 2;\t/* 2..18 */\n      mpz_urandomb (bs, rands, size_range);\t/* 3..262144 bits */\n      size = mpz_get_ui (bs);\n      mpz_rrandomb (op1, rands, size);\n\n      mpz_urandomb (bs, rands, 1);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (op1, op1);\n\n      mpz_urandomb (bs, rands, 32);\n      bsi = mpz_get_ui (bs);\n      base = bsi % 62 + 1;\n      if (base == 1)\n\tbase = 0;\n\n      str = mpz_get_str ((char *) 0, base, op1);\n      mpz_set_str_or_abort (op2, str, base);\n\n      if (mpz_cmp (op1, op2))\n\t{\n\t  fprintf (stderr, \"ERROR, op1 and op2 different in test %d\\n\", i);\n\t  fprintf (stderr, \"str  = %s\\n\", str);\n\t  fprintf (stderr, \"base = %d\\n\", base);\n\t  fprintf (stderr, \"op1  = \"); debug_mp (op1, -16);\n\t  fprintf (stderr, \"op2  = \"); debug_mp (op2, -16);\n\t  abort ();\n\t}\n\n      (*__gmp_free_func) (str, strlen (str) + 1);\n\n      /* 2. Generate random string and convert to mpz_t and back to a string\n\t again.  */\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 16 + 1;\t/* 1..16 */\n      mpz_urandomb (bs, rands, size_range);\t/* 1..65536 digits */\n      len = mpz_get_ui (bs) + 1;\n      buf = (char *) (*__gmp_allocate_func) (len + 1);\n      if (base == 0)\n\tbase = 10;\n      string_urandomb (buf, len, base, rands);\n\n      mpz_set_str_or_abort (op1, buf, base);\n      str = mpz_get_str ((char *) 0, base, op1);\n\n      /* Skip over leading zeros, but don't leave the string at zero length. */\n      for (bp = buf; bp[0] == '0' && bp[1] != '\\0'; bp++)\n\t;\n\n      if (strcasecmp (str, bp) != 0)\n\t{\n\t  fprintf (stderr, \"ERROR, str and buf different in test %d\\n\", i);\n\t  fprintf (stderr, \"str  = %s\\n\", str);\n\t  fprintf (stderr, \"buf  = %s\\n\", buf);\n\t  fprintf (stderr, \"base = %d\\n\", base);\n\t  fprintf (stderr, \"op1  = \"); debug_mp (op1, -16);\n\t  abort ();\n\t}\n\n      (*__gmp_free_func) (buf, len + 1);\n      (*__gmp_free_func) (str, strlen (str) + 1);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (op1);\n  mpz_clear (op2);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 99,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "debug_mp": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/dive.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t op1, op2;\n  mpz_t prod, quot;\n  mp_size_t size;\n  int i;\n  int reps = 5000;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  rands = RANDS;\n\n  mp_trace_base = -16;\n\n  mpz_init (bs);\n\n  mpz_init (op1);\n  mpz_init (op2);\n  mpz_init (prod);\n  mpz_init (quot);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 17 + 2; /* 0..2047 bit operands */\n\n      mpz_urandomb (bs, rands, size_range);\n      size = mpz_get_ui (bs);\n      mpz_rrandomb (op1, rands, size);\n\n      do\n\t{\n\t  mpz_urandomb (bs, rands, size_range);\n\t  size = mpz_get_ui (bs);\n\t  mpz_rrandomb (op2, rands, size);\n\t}\n      while (mpz_sgn (op2) == 0);\n\n      mpz_urandomb (bs, rands, 2);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (op1, op1);\n      if ((bsi & 2) != 0)\n\tmpz_neg (op2, op2);\n\n      mpz_mul (prod, op1, op2);\n\n      mpz_divexact (quot, prod, op2);\n      MPZ_CHECK_FORMAT (quot);\n\n      if (mpz_cmp (quot, op1) != 0)\n        {\n          printf (\"Wrong results:\\n\");\n          mpz_trace (\"  got     \", quot);\n          mpz_trace (\"  want    \", op1);\n          mpz_trace (\"  dividend\", prod);\n          mpz_trace (\"  divisor \", op2);\n          abort ();\n        }\n    }\n\n  mpz_clear (bs);\n  mpz_clear (op1);\n  mpz_clear (op2);\n  mpz_clear (prod);\n  mpz_clear (quot);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 75,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/dive_ui.c": {
    "check_random": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\ncheck_random (int argc, char *argv[])\n{\n  gmp_randstate_ptr rands = RANDS;\n  int    reps = 500000;\n  mpz_t  a, q, got;\n  int    i, qneg;\n  unsigned long  d;\n\n  if (argc == 2)\n    reps = atoi (argv[1]);\n\n  mpz_init (a);\n  mpz_init (q);\n  mpz_init (got);\n\n  for (i = 0; i < reps; i++)\n    {\n      do\n\td = (unsigned long) urandom();\n      while (d == 0);\n      mpz_erandomb (q, rands, 512);\n      mpz_mul_ui (a, q, d);\n\n      for (qneg = 0; qneg <= 1; qneg++)\n        {\n          mpz_divexact_ui (got, a, d);\n          MPZ_CHECK_FORMAT (got);\n          if (mpz_cmp (got, q) != 0)\n            {\n              printf    (\"mpz_divexact_ui wrong\\n\");\n              mpz_trace (\"    a\", a);\n              printf    (\"    d=%lu\\n\", d);\n              mpz_trace (\"    q\", q);\n              mpz_trace (\"  got\", got);\n              abort ();\n            }\n\n          mpz_neg (q, q);\n          mpz_neg (a, a);\n        }\n\n    }\n\n  mpz_clear (a);\n  mpz_clear (q);\n  mpz_clear (got);\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  tests_start ();\n\n  check_random (argc, argv);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/io.c": {
    "debug_mp": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stdout, base, x); fputc ('\\n', stdout);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t  op1, op2;\n  mp_size_t size;\n  int i;\n  int reps = 10000;\n  FILE *fp;\n  int base, base_out;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n  size_t nread;\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  if (argc == 2)\n    reps = atoi (argv[1]);\n\n  mpz_init (op1);\n  mpz_init (op2);\n\n  fp = fopen (FILENAME, \"w+\");\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 10 + 2;\n\n      mpz_urandomb (bs, rands, size_range);\n      size = mpz_get_ui (bs);\n      mpz_rrandomb (op1, rands, size);\n      mpz_urandomb (bs, rands, 1);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (op1, op1);\n\n      mpz_urandomb (bs, rands, 16);\n      bsi = mpz_get_ui (bs);\n      base = bsi % 62 + 1;\n      if (base == 1)\n\tbase = 0;\n\n      if (i % 2 == 0 && base <= 36)\n\tbase_out = -base;\n      else\n\tbase_out = base;\n\n      rewind (fp);\n      if (mpz_out_str (fp, base_out, op1) == 0\n\t  || putc (' ', fp) == EOF\n\t  || fflush (fp) != 0)\n\t{\n\t  printf (\"mpz_out_str write error\\n\");\n\t  abort ();\n\t}\n\n      rewind (fp);\n      nread = mpz_inp_str (op2, fp, base);\n      if (nread == 0)\n\t{\n\t  if (ferror (fp))\n\t    printf (\"mpz_inp_str stream read error\\n\");\n\t  else\n\t    printf (\"mpz_inp_str data conversion error\\n\");\n\t  abort ();\n\t}\n\n      if (nread != ftell(fp))\n\t{\n\t  printf (\"mpz_inp_str nread doesn't match ftell\\n\");\n\t  printf (\"  nread  %lu\\n\", (unsigned long) nread);\n\t  printf (\"  ftell  %ld\\n\", ftell(fp));\n\t  abort ();\n\t}\n\n      if (mpz_cmp (op1, op2))\n\t{\n\t  printf (\"ERROR\\n\");\n\t  printf (\"op1  = \"); debug_mp (op1, -16);\n\t  printf (\"op2  = \"); debug_mp (op2, -16);\n\t  printf (\"base = %d\\n\", base);\n\t  abort ();\n\t}\n    }\n\n  fclose (fp);\n\n  unlink (FILENAME);\n\n  mpz_clear (bs);\n  mpz_clear (op1);\n  mpz_clear (op2);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 100,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/logic.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t x, y, r1, r2;\n  mpz_t t1, t2, t3;\n  mp_size_t xsize, ysize;\n  int i;\n  int reps = 100000;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  mpz_init (x);\n  mpz_init (y);\n  mpz_init (r1);\n  mpz_init (r2);\n  mpz_init (t1);\n  mpz_init (t2);\n  mpz_init (t3);\n\n  mpz_set_si (x, -1);\n  mpz_set_ui (y, 0);\n  for (i = 0; i < 300; i++)\n    {\n      mpz_mul_2exp (x, x, 1);\n\n      mpz_and (r1, x, x);\n      MPZ_CHECK_FORMAT (r1);\n      if (mpz_cmp (r1, x) != 0)\n\tdump_abort ();\n\n      mpz_ior (r2, x, x);\n      MPZ_CHECK_FORMAT (r2);\n      if (mpz_cmp (r2, x) != 0)\n\tdump_abort ();\n\n      mpz_xor (t1, x, x);\n      MPZ_CHECK_FORMAT (t1);\n      if (mpz_cmp_si (t1, 0) != 0)\n\tdump_abort ();\n\n      mpz_ior (t1, x, y);\n      MPZ_CHECK_FORMAT (t1);\n      if (mpz_cmp (t1, x) != 0)\n\tdump_abort ();\n\n      mpz_xor (t2, x, y);\n      MPZ_CHECK_FORMAT (t2);\n      if (mpz_cmp (t2, x) != 0)\n\tdump_abort ();\n\n      mpz_com (t2, x);\n      MPZ_CHECK_FORMAT (t2);\n      mpz_xor (t3, t2, x);\n      MPZ_CHECK_FORMAT (t3);\n      if (mpz_cmp_si (t3, -1) != 0)\n\tdump_abort ();\n    }\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 8 + 2;\n\n      mpz_urandomb (bs, rands, size_range);\n      xsize = mpz_get_ui (bs);\n      mpz_rrandomb (x, rands, xsize);\n      mpz_urandomb (bs, rands, 1);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (x, x);\n\n      mpz_urandomb (bs, rands, size_range);\n      ysize = mpz_get_ui (bs);\n      mpz_rrandomb (y, rands, ysize);\n      mpz_urandomb (bs, rands, 1);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (y, y);\n\n      mpz_com (r1, x);\n      MPZ_CHECK_FORMAT (r1);\n      mpz_com (r1, r1);\n      MPZ_CHECK_FORMAT (r1);\n      if (mpz_cmp (r1, x) != 0)\n\tdump_abort ();\n\n      mpz_com (r1, y);\n      MPZ_CHECK_FORMAT (r1);\n      mpz_com (r2, r1);\n      MPZ_CHECK_FORMAT (r2);\n      if (mpz_cmp (r2, y) != 0)\n\tdump_abort ();\n\n      mpz_com (t1, x);\n      MPZ_CHECK_FORMAT (t1);\n      mpz_com (t2, y);\n      MPZ_CHECK_FORMAT (t2);\n      mpz_and (t3, t1, t2);\n      MPZ_CHECK_FORMAT (t3);\n      mpz_com (r1, t3);\n      MPZ_CHECK_FORMAT (r1);\n      mpz_ior (r2, x, y);\n      MPZ_CHECK_FORMAT (r2);\n      if (mpz_cmp (r1, r2) != 0)\n\tdump_abort ();\n\n      mpz_com (t1, x);\n      MPZ_CHECK_FORMAT (t1);\n      mpz_com (t2, y);\n      MPZ_CHECK_FORMAT (t2);\n      mpz_ior (t3, t1, t2);\n      MPZ_CHECK_FORMAT (t3);\n      mpz_com (r1, t3);\n      MPZ_CHECK_FORMAT (r1);\n      mpz_and (r2, x, y);\n      MPZ_CHECK_FORMAT (r2);\n      if (mpz_cmp (r1, r2) != 0)\n\tdump_abort ();\n\n      mpz_ior (t1, x, y);\n      MPZ_CHECK_FORMAT (t1);\n      mpz_and (t2, x, y);\n      MPZ_CHECK_FORMAT (t2);\n      mpz_com (t3, t2);\n      MPZ_CHECK_FORMAT (t3);\n      mpz_and (r1, t1, t3);\n      MPZ_CHECK_FORMAT (r1);\n      mpz_xor (r2, x, y);\n      MPZ_CHECK_FORMAT (r2);\n      if (mpz_cmp (r1, r2) != 0)\n\tdump_abort ();\n    }\n\n  mpz_clear (bs);\n  mpz_clear (x);\n  mpz_clear (y);\n  mpz_clear (r1);\n  mpz_clear (r2);\n  mpz_clear (t1);\n  mpz_clear (t2);\n  mpz_clear (t3);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 154,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "dump_abort": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\ndump_abort ()\n{\n  abort();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "debug_mp": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/reuse.c": {
    "main": [
      {
        "start_point": [
          41,
          0
        ],
        "end_point": [
          46,
          1
        ],
        "content": "int\nmain (void)\n{\n  printf (\"Test suppressed for windows DLL\\n\");\n  exit (0);\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          199,
          0
        ],
        "end_point": [
          701,
          1
        ],
        "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int pass, reps = 400;\n  mpz_t in1, in2, in3;\n  unsigned long int in2i;\n  mp_size_t size;\n  mpz_t res1, res2, res3;\n  mpz_t ref1, ref2, ref3;\n  mpz_t t;\n  unsigned long int r1, r2;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  mpz_init (in1);\n  mpz_init (in2);\n  mpz_init (in3);\n  mpz_init (ref1);\n  mpz_init (ref2);\n  mpz_init (ref3);\n  mpz_init (res1);\n  mpz_init (res2);\n  mpz_init (res3);\n  mpz_init (t);\n\n  for (pass = 1; pass <= reps; pass++)\n    {\n      if (isatty (fileno (stdout)))\n\t{\n\t  printf (\"\\r%d/%d passes\", pass, reps);\n\t  fflush (stdout);\n\t}\n\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 21 + 2;\n\n      if ((pass & 1) == 0)\n\t{\n\t  /* Make all input operands have quite different sizes */\n\t  mpz_urandomb (bs, rands, 32);\n\t  size = mpz_get_ui (bs) % size_range;\n\t  mpz_rrandomb (in1, rands, size);\n\n\t  mpz_urandomb (bs, rands, 32);\n\t  size = mpz_get_ui (bs) % size_range;\n\t  mpz_rrandomb (in2, rands, size);\n\n\t  mpz_urandomb (bs, rands, 32);\n\t  size = mpz_get_ui (bs) % size_range;\n\t  mpz_rrandomb (in3, rands, size);\n\t}\n      else\n\t{\n\t  /* Make all input operands have about the same size */\n\t  mpz_urandomb (bs, rands, size_range);\n\t  size = mpz_get_ui (bs);\n\t  mpz_rrandomb (in1, rands, size);\n\n\t  mpz_urandomb (bs, rands, size_range);\n\t  size = mpz_get_ui (bs);\n\t  mpz_rrandomb (in2, rands, size);\n\n\t  mpz_urandomb (bs, rands, size_range);\n\t  size = mpz_get_ui (bs);\n\t  mpz_rrandomb (in3, rands, size);\n\t}\n\n      mpz_urandomb (bs, rands, 3);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (in1, in1);\n      if ((bsi & 2) != 0)\n\tmpz_neg (in2, in2);\n      if ((bsi & 4) != 0)\n\tmpz_neg (in3, in3);\n\n      for (i = 0; i < numberof (dss); i++)\n\t{\n\t  if (dss[i].isdivision && mpz_sgn (in2) == 0)\n\t    continue;\n\t  if (dss[i].isslow && size_range > 19)\n\t    continue;\n\n\t  (dss[i].fptr) (ref1, in1, in2);\n\t  MPZ_CHECK_FORMAT (ref1);\n\n\t  mpz_set (res1, in1);\n\t  INVOKE_RSS (dss[i], res1, res1, in2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL (dss, i, in1, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  INVOKE_RSS (dss[i], res1, in1, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL (dss, i, in1, in2, NULL);\n\t}\n\n      for (i = 0; i < numberof (ddss_div); i++)\n\t{\n\t  if (mpz_sgn (in2) == 0)\n\t    continue;\n\n\t  (ddss_div[i].fptr) (ref1, ref2, in1, in2);\n\t  MPZ_CHECK_FORMAT (ref1);\n\t  MPZ_CHECK_FORMAT (ref2);\n\n\t  mpz_set (res1, in1);\n\t  INVOKE_RRSS (ddss_div[i], res1, res2, res1, in2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL (ddss_div, i, in1, in2, NULL);\n\n\t  mpz_set (res2, in1);\n\t  INVOKE_RRSS (ddss_div[i], res1, res2, res2, in2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL (ddss_div, i, in1, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  INVOKE_RRSS (ddss_div[i], res1, res2, in1, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL (ddss_div, i, in1, in2, NULL);\n\n\t  mpz_set (res2, in2);\n\t  INVOKE_RRSS (ddss_div[i], res1, res2, in1, res2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL (ddss_div, i, in1, in2, NULL);\n\t}\n\n      for (i = 0; i < numberof (ds); i++)\n\t{\n\t  if (ds[i].nonneg && mpz_sgn (in1) < 0)\n\t    continue;\n\n\t  (ds[i].fptr) (ref1, in1);\n\t  MPZ_CHECK_FORMAT (ref1);\n\n\t  mpz_set (res1, in1);\n\t  INVOKE_RS (ds[i], res1, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL (ds, i, in1, in2, NULL);\n\t}\n\n      in2i = mpz_get_ui (in2);\n\n      for (i = 0; i < numberof (dsi); i++)\n\t{\n\t  if (dsi[i].mod != 0)\n\t    in2i = mpz_get_ui (in2) % dsi[i].mod;\n\n\t  (dsi[i].fptr) (ref1, in1, in2i);\n\t  MPZ_CHECK_FORMAT (ref1);\n\n\t  mpz_set (res1, in1);\n\t  INVOKE_RRS (dsi[i], res1, res1, in2i);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL (dsi, i, in1, in2, NULL);\n\t}\n\n      if (in2i != 0)\t  /* Don't divide by 0.  */\n\t{\n\t  for (i = 0; i < numberof (dsi_div); i++)\n\t    {\n\t      r1 = (dsi_div[i].fptr) (ref1, in1, in2i);\n\t      MPZ_CHECK_FORMAT (ref1);\n\n\t      mpz_set (res1, in1);\n\t      r2 = (dsi_div[i].fptr) (res1, res1, in2i);\n\t      MPZ_CHECK_FORMAT (res1);\n\t      if (mpz_cmp (ref1, res1) != 0 || r1 != r2)\n\t\tFAIL (dsi_div, i, in1, in2, NULL);\n\t    }\n\n\t  for (i = 0; i < numberof (ddsi_div); i++)\n\t    {\n\t      r1 = (ddsi_div[i].fptr) (ref1, ref2, in1, in2i);\n\t      MPZ_CHECK_FORMAT (ref1);\n\n\t      mpz_set (res1, in1);\n\t      r2 = (ddsi_div[i].fptr) (res1, res2, res1, in2i);\n\t      MPZ_CHECK_FORMAT (res1);\n\t      if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0 || r1 != r2)\n\t\tFAIL (ddsi_div, i, in1, in2, NULL);\n\n\t      mpz_set (res2, in1);\n\t      (ddsi_div[i].fptr) (res1, res2, res2, in2i);\n\t      MPZ_CHECK_FORMAT (res1);\n\t      if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0 || r1 != r2)\n\t\tFAIL (ddsi_div, i, in1, in2, NULL);\n\t    }\n\t}\n\n      if (mpz_sgn (in1) >= 0)\n\t{\n\t  mpz_sqrtrem (ref1, ref2, in1);\n\t  MPZ_CHECK_FORMAT (ref1);\n\t  MPZ_CHECK_FORMAT (ref2);\n\n\t  mpz_set (res1, in1);\n\t  mpz_sqrtrem (res1, res2, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL2 (mpz_sqrtrem, in1, NULL, NULL);\n\n\t  mpz_set (res2, in1);\n\t  mpz_sqrtrem (res1, res2, res2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL2 (mpz_sqrtrem, in1, NULL, NULL);\n\n\t  mpz_set (res1, in1);\n\t  mpz_sqrtrem (res1, res1, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref2, res1) != 0)\n\t    FAIL2 (mpz_sqrtrem, in1, NULL, NULL);\n\t}\n\n      if (mpz_sgn (in1) >= 0)\n\t{\n\t  mpz_root (ref1, in1, in2i % 0x100 + 1);\n\t  MPZ_CHECK_FORMAT (ref1);\n\n\t  mpz_set (res1, in1);\n\t  mpz_root (res1, res1, in2i % 0x100 + 1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_root, in1, in2, NULL);\n\t}\n\n      if (mpz_sgn (in1) >= 0)\n\t{\n\t  mpz_rootrem (ref1, ref2, in1, in2i % 0x100 + 1);\n\t  MPZ_CHECK_FORMAT (ref1);\n\t  MPZ_CHECK_FORMAT (ref2);\n\n\t  mpz_set (res1, in1);\n\t  mpz_rootrem (res1, res2, res1, in2i % 0x100 + 1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL2 (mpz_rootrem, in1, in2, NULL);\n\n\t  mpz_set (res2, in1);\n\t  mpz_rootrem (res1, res2, res2, in2i % 0x100 + 1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0)\n\t    FAIL2 (mpz_rootrem, in1, in2, NULL);\n\t}\n\n      if (size_range < 18)\t/* run fewer tests since gcdext is slow */\n\t{\n\t  mpz_gcdext (ref1, ref2, ref3, in1, in2);\n\t  MPZ_CHECK_FORMAT (ref1);\n\t  MPZ_CHECK_FORMAT (ref2);\n\t  MPZ_CHECK_FORMAT (ref3);\n\n\t  mpz_set (res1, in1);\n\t  mpz_gcdext (res1, res2, res3, res1, in2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  MPZ_CHECK_FORMAT (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res2, in1);\n\t  mpz_gcdext (res1, res2, res3, res2, in2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  MPZ_CHECK_FORMAT (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res3, in1);\n\t  mpz_gcdext (res1, res2, res3, res3, in2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  MPZ_CHECK_FORMAT (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  mpz_gcdext (res1, res2, res3, in1, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  MPZ_CHECK_FORMAT (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res2, in2);\n\t  mpz_gcdext (res1, res2, res3, in1, res2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  MPZ_CHECK_FORMAT (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res3, in2);\n\t  mpz_gcdext (res1, res2, res3, in1, res3);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  MPZ_CHECK_FORMAT (res3);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res1, in1);\n\t  mpz_gcdext (res1, res2, NULL, res1, in2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res2, in1);\n\t  mpz_gcdext (res1, res2, NULL, res2, in2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  mpz_gcdext (res1, res2, NULL, in1, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\n\t  mpz_set (res2, in2);\n\t  mpz_gcdext (res1, res2, NULL, in1, res2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  MPZ_CHECK_FORMAT (res2);\n\t  if (mpz_cmp (ref1, res1) != 0 || mpz_cmp (ref2, res2) != 0\n\t      || mpz_cmp (ref3, res3) != 0)\n\t    FAIL2 (mpz_gcdext, in1, in2, NULL);\n\t}\n\n      /* Don't run mpz_powm for huge exponents or when undefined.  */\n      if (size_range < 17 && mpz_sizeinbase (in2, 2) < 250 && mpz_sgn (in3) != 0\n\t  && (mpz_sgn (in2) >= 0 || mpz_invert (t, in1, in3)))\n\t{\n\t  mpz_powm (ref1, in1, in2, in3);\n\t  MPZ_CHECK_FORMAT (ref1);\n\n\t  mpz_set (res1, in1);\n\t  mpz_powm (res1, res1, in2, in3);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_powm, in1, in2, in3);\n\n\t  mpz_set (res1, in2);\n\t  mpz_powm (res1, in1, res1, in3);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_powm, in1, in2, in3);\n\n\t  mpz_set (res1, in3);\n\t  mpz_powm (res1, in1, in2, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_powm, in1, in2, in3);\n\t}\n\n      /* Don't run mpz_powm_ui when undefined.  */\n      if (size_range < 17 && mpz_sgn (in3) != 0)\n\t{\n\t  mpz_powm_ui (ref1, in1, in2i, in3);\n\t  MPZ_CHECK_FORMAT (ref1);\n\n\t  mpz_set (res1, in1);\n\t  mpz_powm_ui (res1, res1, in2i, in3);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_powm_ui, in1, in2, in3);\n\n\t  mpz_set (res1, in3);\n\t  mpz_powm_ui (res1, in1, in2i, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_powm_ui, in1, in2, in3);\n\t}\n\n      {\n\tr1 = mpz_gcd_ui (ref1, in1, in2i);\n\tMPZ_CHECK_FORMAT (ref1);\n\n\tmpz_set (res1, in1);\n\tr2 = mpz_gcd_ui (res1, res1, in2i);\n\tMPZ_CHECK_FORMAT (res1);\n\tif (mpz_cmp (ref1, res1) != 0)\n\t  FAIL2 (mpz_gcd_ui, in1, in2, NULL);\n      }\n\n      if (mpz_sgn (in2) != 0)\n\t{\n\t  /* Test mpz_remove */\n\t  mp_bitcnt_t refretval, retval;\n\t  refretval = mpz_remove (ref1, in1, in2);\n\t  MPZ_CHECK_FORMAT (ref1);\n\n\t  mpz_set (res1, in1);\n\t  retval = mpz_remove (res1, res1, in2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0 || refretval != retval)\n\t    FAIL2 (mpz_remove, in1, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  retval = mpz_remove (res1, in1, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0 || refretval != retval)\n\t    FAIL2 (mpz_remove, in1, in2, NULL);\n\t}\n\n      if (mpz_sgn (in2) != 0)\n\t{\n\t  /* Test mpz_divexact */\n\t  mpz_mul (t, in1, in2);\n\t  mpz_divexact (ref1, t, in2);\n\t  MPZ_CHECK_FORMAT (ref1);\n\n\t  mpz_set (res1, t);\n\t  mpz_divexact (res1, res1, in2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_divexact, t, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  mpz_divexact (res1, t, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_divexact, t, in2, NULL);\n\t}\n\n      if (mpz_sgn (in2) > 0)\n\t{\n\t  /* Test mpz_divexact_gcd, same as mpz_divexact */\n\t  mpz_mul (t, in1, in2);\n\t  mpz_divexact_gcd (ref1, t, in2);\n\t  MPZ_CHECK_FORMAT (ref1);\n\n\t  mpz_set (res1, t);\n\t  mpz_divexact_gcd (res1, res1, in2);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_divexact_gcd, t, in2, NULL);\n\n\t  mpz_set (res1, in2);\n\t  mpz_divexact_gcd (res1, t, res1);\n\t  MPZ_CHECK_FORMAT (res1);\n\t  if (mpz_cmp (ref1, res1) != 0)\n\t    FAIL2 (mpz_divexact_gcd, t, in2, NULL);\n\t}\n    }\n\n  if (isatty (fileno (stdout)))\n    printf (\"\\r%20s\", \"\");\n\n  mpz_clear (bs);\n  mpz_clear (in1);\n  mpz_clear (in2);\n  mpz_clear (in3);\n  mpz_clear (ref1);\n  mpz_clear (ref2);\n  mpz_clear (ref3);\n  mpz_clear (res1);\n  mpz_clear (res2);\n  mpz_clear (res3);\n  mpz_clear (t);\n\n  if (isatty (fileno (stdout)))\n    printf (\"\\r\");\n\n  tests_end ();\n  exit (0);\n}",
        "lines": 503,
        "depth": 16,
        "decorators": [
          "int"
        ]
      }
    ],
    "mpz_xinvert": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\nmpz_xinvert (mpz_ptr r, mpz_srcptr a, mpz_srcptr b)\n{\n  int res;\n  res = mpz_invert (r, a, b);\n  if (res == 0)\n    mpz_set_ui (r, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dump": {
      "start_point": [
        703,
        0
      ],
      "end_point": [
        719,
        1
      ],
      "content": "void\ndump (const char *name, mpz_t in1, mpz_t in2, mpz_t in3)\n{\n  printf (\"failure in %s (\", name);\n  0 && mpz_out_str (stdout, -16, in1);\n  if (in2 != NULL)\n    {\n      printf (\" \");\n      0 && mpz_out_str (stdout, -16, in2);\n    }\n  if (in3 != NULL)\n    {\n      printf (\" \");\n      0 && mpz_out_str (stdout, -16, in3);\n    }\n  printf (\")\\n\");\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-addsub.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t op1, op2, r1, r2;\n  mp_size_t op1n, op2n;\n  unsigned long int op2long;\n  int i;\n  int reps = 100000;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  mpz_init (op1);\n  mpz_init (op2);\n  mpz_init (r1);\n  mpz_init (r2);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 10 + 2;\n\n      mpz_urandomb (bs, rands, size_range);\n      op1n = mpz_get_ui (bs);\n      mpz_rrandomb (op1, rands, op1n);\n\n      mpz_urandomb (bs, rands, size_range);\n      op2n = mpz_get_ui (bs);\n      mpz_rrandomb (op2, rands, op2n);\n\n      mpz_urandomb (bs, rands, 2);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (op1, op1);\n      if ((bsi & 2) != 0)\n\tmpz_neg (op2, op2);\n\n      /* printf (\"%ld %ld\\n\", SIZ (multiplier), SIZ (multiplicand)); */\n\n      mpz_add (r1, op1, op2);\n      mpz_sub (r2, r1, op2);\n      if (mpz_cmp (r2, op1) != 0)\n\tdump_abort (i, \"mpz_add or mpz_sub incorrect\", op1, op2);\n\n      if (mpz_fits_ulong_p (op2))\n\t{\n\t  op2long = mpz_get_ui (op2);\n\t  mpz_add_ui (r1, op1, op2long);\n\t  mpz_sub_ui (r2, r1, op2long);\n\t  if (mpz_cmp (r2, op1) != 0)\n\t    dump_abort (i, \"mpz_add_ui or mpz_sub_ui incorrect\", op1, op2);\n\n\t  mpz_ui_sub (r1, op2long, op1);\n\t  mpz_sub_ui (r2, op1, op2long);\n\t  mpz_neg (r2, r2);\n\t  if (mpz_cmp (r1, r2) != 0)\n\t    dump_abort (i, \"mpz_add_ui or mpz_ui_sub incorrect\", op1, op2);\n\t}\n    }\n\n  mpz_clear (bs);\n  mpz_clear (op1);\n  mpz_clear (op2);\n  mpz_clear (r1);\n  mpz_clear (r2);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 77,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "dump_abort": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\ndump_abort (int i, const char *s, mpz_t op1, mpz_t op2)\n{\n  fprintf (stderr, \"ERROR: %s in test %d\\n\", s, i);\n  fprintf (stderr, \"op1 = \"); debug_mp (op1, -16);\n  fprintf (stderr, \"op2 = \"); debug_mp (op2, -16);\n  abort();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "debug_mp": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-aorsmul.c": {
    "check_one_inplace": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "void\ncheck_one_inplace (mpz_srcptr w, mpz_srcptr y)\n{\n  mpz_t  want, got;\n\n  mpz_init (want);\n  mpz_init (got);\n\n  mpz_mul (want, w, y);\n  mpz_add (want, w, want);\n  mpz_set (got, w);\n  mpz_addmul (got, got, y);\n  MPZ_CHECK_FORMAT (got);\n  if (mpz_cmp (want, got) != 0)\n    {\n      printf (\"mpz_addmul inplace fail\\n\");\n    fail:\n      mpz_trace (\"w\", w);\n      mpz_trace (\"y\", y);\n      mpz_trace (\"want\", want);\n      mpz_trace (\"got \", got);\n      abort ();\n    }\n\n  mpz_mul (want, w, y);\n  mpz_sub (want, w, want);\n  mpz_set (got, w);\n  mpz_submul (got, got, y);\n  MPZ_CHECK_FORMAT (got);\n  if (mpz_cmp (want, got) != 0)\n    {\n      printf (\"mpz_submul inplace fail\\n\");\n      goto fail;\n    }\n\n  mpz_clear (want);\n  mpz_clear (got);\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_one_ui_inplace": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "void\ncheck_one_ui_inplace (mpz_ptr w, unsigned long y)\n{\n  mpz_t  want, got;\n\n  mpz_init (want);\n  mpz_init (got);\n\n  mpz_mul_ui (want, w, (unsigned long) y);\n  mpz_add (want, w, want);\n  mpz_set (got, w);\n  mpz_addmul_ui (got, got, (unsigned long) y);\n  MPZ_CHECK_FORMAT (got);\n  if (mpz_cmp (want, got) != 0)\n    {\n      printf (\"mpz_addmul_ui fail\\n\");\n    fail:\n      mpz_trace (\"w\", w);\n      printf    (\"y=0x%lX   %lu\\n\", y, y);\n      mpz_trace (\"want\", want);\n      mpz_trace (\"got \", got);\n      abort ();\n    }\n\n  mpz_mul_ui (want, w, y);\n  mpz_sub (want, w, want);\n  mpz_set (got, w);\n  mpz_submul_ui (got, got, y);\n  MPZ_CHECK_FORMAT (got);\n  if (mpz_cmp (want, got) != 0)\n    {\n      printf (\"mpz_submul_ui fail\\n\");\n      goto fail;\n    }\n\n  mpz_clear (want);\n  mpz_clear (got);\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_all_inplace": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "void\ncheck_all_inplace (mpz_ptr w, mpz_ptr y)\n{\n  int  wneg, yneg;\n\n  MPZ_CHECK_FORMAT (w);\n  MPZ_CHECK_FORMAT (y);\n\n  for (wneg = 0; wneg < 2; wneg++)\n    {\n      for (yneg = 0; yneg < 2; yneg++)\n        {\n          check_one_inplace (w, y);\n\n          if (mpz_fits_ulong_p (y))\n            check_one_ui_inplace (w, mpz_get_ui (y));\n\n          mpz_neg (y, y);\n        }\n      mpz_neg (w, w);\n    }\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_one": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\ncheck_one (mpz_srcptr w, mpz_srcptr x, mpz_srcptr y)\n{\n  mpz_t  want, got;\n\n  mpz_init (want);\n  mpz_init (got);\n\n  mpz_mul (want, x, y);\n  mpz_add (want, w, want);\n  mpz_set (got, w);\n  mpz_addmul (got, x, y);\n  MPZ_CHECK_FORMAT (got);\n  if (mpz_cmp (want, got) != 0)\n    {\n      printf (\"mpz_addmul fail\\n\");\n    fail:\n      mpz_trace (\"w\", w);\n      mpz_trace (\"x\", x);\n      mpz_trace (\"y\", y);\n      mpz_trace (\"want\", want);\n      mpz_trace (\"got \", got);\n      abort ();\n    }\n\n  mpz_mul (want, x, y);\n  mpz_sub (want, w, want);\n  mpz_set (got, w);\n  mpz_submul (got, x, y);\n  MPZ_CHECK_FORMAT (got);\n  if (mpz_cmp (want, got) != 0)\n    {\n      printf (\"mpz_submul fail\\n\");\n      goto fail;\n    }\n\n  mpz_clear (want);\n  mpz_clear (got);\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_one_ui": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "void\ncheck_one_ui (mpz_ptr w, mpz_ptr x, unsigned long y)\n{\n  mpz_t  want, got;\n\n  mpz_init (want);\n  mpz_init (got);\n\n  mpz_mul_ui (want, x, (unsigned long) y);\n  mpz_add (want, w, want);\n  mpz_set (got, w);\n  mpz_addmul_ui (got, x, (unsigned long) y);\n  MPZ_CHECK_FORMAT (got);\n  if (mpz_cmp (want, got) != 0)\n    {\n      printf (\"mpz_addmul_ui fail\\n\");\n    fail:\n      mpz_trace (\"w\", w);\n      mpz_trace (\"x\", x);\n      printf    (\"y=0x%lX   %lu\\n\", y, y);\n      mpz_trace (\"want\", want);\n      mpz_trace (\"got \", got);\n      abort ();\n    }\n\n  mpz_mul_ui (want, x, y);\n  mpz_sub (want, w, want);\n  mpz_set (got, w);\n  mpz_submul_ui (got, x, y);\n  MPZ_CHECK_FORMAT (got);\n  if (mpz_cmp (want, got) != 0)\n    {\n      printf (\"mpz_submul_ui fail\\n\");\n      goto fail;\n    }\n\n  mpz_clear (want);\n  mpz_clear (got);\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_all": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "void\ncheck_all (mpz_ptr w, mpz_ptr x, mpz_ptr y)\n{\n  int    swap, wneg, xneg, yneg;\n\n  MPZ_CHECK_FORMAT (w);\n  MPZ_CHECK_FORMAT (x);\n  MPZ_CHECK_FORMAT (y);\n\n  for (swap = 0; swap < 2; swap++)\n    {\n      for (wneg = 0; wneg < 2; wneg++)\n        {\n          for (xneg = 0; xneg < 2; xneg++)\n            {\n              for (yneg = 0; yneg < 2; yneg++)\n                {\n                  check_one (w, x, y);\n\n                  if (mpz_fits_ulong_p (y))\n                    check_one_ui (w, x, mpz_get_ui (y));\n\n                  mpz_neg (y, y);\n                }\n              mpz_neg (x, x);\n            }\n          mpz_neg (w, w);\n        }\n      mpz_swap (x, y);\n    }\n}",
      "lines": 31,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "check_data_inplace_ui": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "void\ncheck_data_inplace_ui (void)\n{\n  static const struct {\n    mp_limb_t      w[6];\n    unsigned long  y;\n\n  } data[] = {\n\n    { { 0 }, 0 },\n    { { 0 }, 1 },\n    { { 1 }, 1 },\n    { { 2 }, 1 },\n\n    { { 123 }, 1 },\n    { { 123 }, ULONG_MAX },\n    { { M }, 1 },\n    { { M }, ULONG_MAX },\n\n    { { 123, 456 }, 1 },\n    { { M, M }, 1 },\n    { { 123, 456 }, ULONG_MAX },\n    { { M, M }, ULONG_MAX },\n\n    { { 123, 456, 789 }, 1 },\n    { { M, M, M }, 1 },\n    { { 123, 456, 789 }, ULONG_MAX },\n    { { M, M, M }, ULONG_MAX },\n  };\n\n  mpz_t  w, y;\n  int    i;\n\n  mpz_init (w);\n  mpz_init (y);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_n (w, data[i].w, (mp_size_t) numberof(data[i].w));\n      mpz_set_ui (y, data[i].y);\n      check_all_inplace (w, y);\n    }\n\n  mpz_clear (w);\n  mpz_clear (y);\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    mp_limb_t  w[6];\n    mp_limb_t  x[6];\n    mp_limb_t  y[6];\n\n  } data[] = {\n\n    /* reducing to zero */\n    { { 1 }, { 1 }, { 1 } },\n    { { 2 }, { 1 }, { 2 } },\n    { { 0,1 }, { 0,1 }, { 1 } },\n\n    /* reducing to 1 */\n    { { 0,1 },       { M },       { 1 } },\n    { { 0,0,1 },     { M,M },     { 1 } },\n    { { 0,0,0,1 },   { M,M,M },   { 1 } },\n    { { 0,0,0,0,1 }, { M,M,M,M }, { 1 } },\n\n    /* reducing to -1 */\n    { { M },       { 0,1 },       { 1 } },\n    { { M,M },     { 0,0,1 },     { 1 } },\n    { { M,M,M },   { 0,0,0,1 },   { 1 } },\n    { { M,M,M,M }, { 0,0,0,0,1 }, { 1 } },\n\n    /* carry out of addmul */\n    { { M },     { 1 }, { 1 } },\n    { { M,M },   { 1 }, { 1 } },\n    { { M,M,M }, { 1 }, { 1 } },\n\n    /* borrow from submul */\n    { { 0,1 },     { 1 }, { 1 } },\n    { { 0,0,1 },   { 1 }, { 1 } },\n    { { 0,0,0,1 }, { 1 }, { 1 } },\n\n    /* borrow from submul */\n    { { 0,0,1 },     { 0,1 }, { 1 } },\n    { { 0,0,0,1 },   { 0,1 }, { 1 } },\n    { { 0,0,0,0,1 }, { 0,1 }, { 1 } },\n\n    /* more borrow from submul */\n    { { M }, { 0,1 },       { 1 } },\n    { { M }, { 0,0,1 },     { 1 } },\n    { { M }, { 0,0,0,1 },   { 1 } },\n    { { M }, { 0,0,0,0,1 }, { 1 } },\n\n    /* big borrow from submul */\n    { { 0,0,1 },     { M,M }, { M } },\n    { { 0,0,0,1 },   { M,M }, { M } },\n    { { 0,0,0,0,1 }, { M,M }, { M } },\n\n    /* small w */\n    { { 0,1 }, { M,M },       { M } },\n    { { 0,1 }, { M,M,M },     { M } },\n    { { 0,1 }, { M,M,M,M },   { M } },\n    { { 0,1 }, { M,M,M,M,M }, { M } },\n  };\n\n  mpz_t  w, x, y;\n  int    i;\n\n  mpz_init (w);\n  mpz_init (x);\n  mpz_init (y);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_n (w, data[i].w, (mp_size_t) numberof(data[i].w));\n      mpz_set_n (x, data[i].x, (mp_size_t) numberof(data[i].x));\n      mpz_set_n (y, data[i].y, (mp_size_t) numberof(data[i].y));\n      check_all (w, x, y);\n    }\n\n  mpz_clear (w);\n  mpz_clear (x);\n  mpz_clear (y);\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        406,
        1
      ],
      "content": "void\ncheck_random (int argc, char *argv[])\n{\n  gmp_randstate_ptr rands = RANDS;\n  mpz_t  w, x, y;\n  int    i, reps = 2000;\n\n  mpz_init (w);\n  mpz_init (x);\n  mpz_init (y);\n\n  if (argc == 2)\n    reps = atoi (argv[1]);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_errandomb (w, rands, 5*GMP_LIMB_BITS);\n      mpz_errandomb (x, rands, 5*GMP_LIMB_BITS);\n      mpz_errandomb (y, rands, 5*GMP_LIMB_BITS);\n      check_all (w, x, y);\n      check_all_inplace (w, y);\n\n      mpz_errandomb (w, rands, 5*GMP_LIMB_BITS);\n      mpz_errandomb (x, rands, 5*GMP_LIMB_BITS);\n      mpz_errandomb (y, rands, BITS_PER_ULONG);\n      check_all (w, x, y);\n      check_all_inplace (w, y);\n    }\n\n  mpz_clear (w);\n  mpz_clear (x);\n  mpz_clear (y);\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        409,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_data ();\n  check_data_inplace_ui ();\n  check_random (argc, argv);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-bin.c": {
    "try_mpz_bin_ui": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void\ntry_mpz_bin_ui (mpz_srcptr want, mpz_srcptr n, unsigned long k)\n{\n  mpz_t  got;\n\n  mpz_init (got);\n  mpz_bin_ui (got, n, k);\n  MPZ_CHECK_FORMAT (got);\n  if (mpz_cmp (got, want) != 0)\n    {\n      printf (\"mpz_bin_ui wrong\\n\");\n      printf (\"  n=\"); mpz_out_str (stdout, 10, n); printf (\"\\n\");\n      printf (\"  k=%lu\\n\", k);\n      printf (\"  got=\"); mpz_out_str (stdout, 10, got); printf (\"\\n\");\n      printf (\"  want=\"); mpz_out_str (stdout, 10, want); printf (\"\\n\");\n      abort();\n    }\n  mpz_clear (got);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "try_mpz_bin_uiui": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\ntry_mpz_bin_uiui (mpz_srcptr want, unsigned long n, unsigned long k)\n{\n  mpz_t  got;\n\n  mpz_init (got);\n  mpz_bin_uiui (got, n, k);\n  MPZ_CHECK_FORMAT (got);\n  if (mpz_cmp (got, want) != 0)\n    {\n      printf (\"mpz_bin_uiui wrong\\n\");\n      printf (\"  n=%lu\\n\", n);\n      printf (\"  k=%lu\\n\", k);\n      printf (\"  got=\"); mpz_out_str (stdout, 10, got); printf (\"\\n\");\n      printf (\"  want=\"); mpz_out_str (stdout, 10, want); printf (\"\\n\");\n      abort();\n    }\n  mpz_clear (got);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "samples": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "void\nsamples (void)\n{\n  static const struct {\n    const char     *n;\n    unsigned long  k;\n    const char     *want;\n  } data[] = {\n\n    {   \"0\", 123456, \"0\" },\n    {   \"1\", 543210, \"0\" },\n    {   \"2\", 123321, \"0\" },\n    {   \"3\", 234567, \"0\" },\n    {   \"10\", 23456, \"0\" },\n\n    /* negatives, using bin(-n,k)=bin(n+k-1,k) */\n    {   \"-1\",  0,  \"1\"  },\n    {   \"-1\",  1, \"-1\"  },\n    {   \"-1\",  2,  \"1\"  },\n    {   \"-1\",  3, \"-1\"  },\n    {   \"-1\",  4,  \"1\"  },\n\n    {   \"-2\",  0,  \"1\"  },\n    {   \"-2\",  1, \"-2\"  },\n    {   \"-2\",  2,  \"3\"  },\n    {   \"-2\",  3, \"-4\"  },\n    {   \"-2\",  4,  \"5\"  },\n    {   \"-2\",  5, \"-6\"  },\n    {   \"-2\",  6,  \"7\"  },\n\n    {   \"-3\",  0,   \"1\"  },\n    {   \"-3\",  1,  \"-3\"  },\n    {   \"-3\",  2,   \"6\"  },\n    {   \"-3\",  3, \"-10\"  },\n    {   \"-3\",  4,  \"15\"  },\n    {   \"-3\",  5, \"-21\"  },\n    {   \"-3\",  6,  \"28\"  },\n\n    /* A few random values */\n    {   \"41\", 20,  \"269128937220\" },\n    {   \"62\", 37,  \"147405545359541742\" },\n    {   \"50\", 18,  \"18053528883775\" },\n    {  \"149\", 21,  \"19332950844468483467894649\" },\n  };\n\n  mpz_t  n, want;\n  int    i;\n\n  mpz_init (n);\n  mpz_init (want);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (n, data[i].n, 0);\n      mpz_set_str_or_abort (want, data[i].want, 0);\n\n      try_mpz_bin_ui (want, n, data[i].k);\n\n      if (mpz_fits_ulong_p (n))\n\ttry_mpz_bin_uiui (want, mpz_get_ui (n), data[i].k);\n    }\n\n  mpz_clear (n);\n  mpz_clear (want);\n}",
      "lines": 65,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "twos": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "void\ntwos (int count)\n{\n  mpz_t          n, want;\n  unsigned long  k;\n\n  mpz_init (n);\n  mpz_init (want);\n\n  mpz_set_ui (want, (unsigned long) 2);\n  for (k = 1; k < count; k++)\n    {\n      mpz_set_ui (n, 2*k);\n      try_mpz_bin_ui (want, n, k);\n\n      try_mpz_bin_uiui (want, 2*k, k);\n\n      mpz_mul_ui (want, want, 2*(2*k+1));\n      mpz_fdiv_q_ui (want, want, k+1);\n    }\n\n  mpz_clear (n);\n  mpz_clear (want);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "randomwalk": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void\nrandomwalk (int count)\n{\n  mpz_t          n_z, want;\n  unsigned long  n, k, i, r;\n  int            tests;\n  gmp_randstate_ptr rands;\n\n  rands = RANDS;\n  mpz_init (n_z);\n  mpz_init (want);\n\n  k = 3;\n  n = 12;\n  mpz_set_ui (want, (unsigned long) 220); /* binomial(12,3) = 220 */\n\n  for (tests = 1; tests < count; tests++)\n    {\n      r = gmp_urandomm_ui (rands, 62) + 1;\n      for (i = r & 7; i > 0; i--)\n\t{\n\t  n++; k++;\n\t  mpz_mul_ui (want, want, n);\n\t  mpz_fdiv_q_ui (want, want, k);\n\t}\n      for (i = r >> 3; i > 0; i--)\n\t{\n\t  n++;\n\t  mpz_mul_ui (want, want, n);\n\t  mpz_fdiv_q_ui (want, want, n - k);\n\t}\n\n      mpz_set_ui (n_z, n);\n      try_mpz_bin_ui (want, n_z, k);\n\n      try_mpz_bin_uiui (want, n, k);\n    }\n\n  mpz_clear (n_z);\n  mpz_clear (want);\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "smallexaustive": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "void\nsmallexaustive (unsigned int count)\n{\n  mpz_t          n_z, want;\n  unsigned long  n, k;\n\n  mpz_init (n_z);\n  mpz_init (want);\n\n  for (n = 0; n < count; n++)\n    {\n      mpz_set_ui (want, (unsigned long) 1);\n      mpz_set_ui (n_z, n);\n      for (k = 0; k <= n; k++)\n\t{\n\t  try_mpz_bin_ui (want, n_z, k);\n\t  try_mpz_bin_uiui (want, n, k);\n\t  mpz_mul_ui (want, want, n - k);\n\t  mpz_fdiv_q_ui (want, want, k + 1);\n\t}\n      try_mpz_bin_ui (want, n_z, k);\n      try_mpz_bin_uiui (want, n, k);\n    }\n\n  mpz_clear (n_z);\n  mpz_clear (want);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int count;\n\n  if (argc > 1)\n    {\n      char *end;\n      count = strtol (argv[1], &end, 0);\n      if (*end || count <= 0)\n\t{\n\t  fprintf (stderr, \"Invalid test count: %s.\\n\", argv[1]);\n\t  return 1;\n\t}\n    }\n  else\n    count = COUNT;\n\n  tests_start ();\n\n  samples ();\n  smallexaustive (count >> 4);\n  twos (count >> 1);\n  randomwalk (count - (count >> 1));\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-cdiv_ui.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t dividend;\n  mpz_t quotient, remainder;\n  mpz_t quotient2, remainder2;\n  mpz_t temp;\n  mp_size_t dividend_size;\n  unsigned long divisor;\n  int i;\n  int reps = 10000;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n  unsigned long r_rq, r_q, r_r, r;\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  mpz_init (dividend);\n  mpz_init (quotient);\n  mpz_init (remainder);\n  mpz_init (quotient2);\n  mpz_init (remainder2);\n  mpz_init (temp);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 10 + 2; /* 0..2047 bit operands */\n\n      do\n\t{\n\t  mpz_rrandomb (bs, rands, 64);\n\t  divisor = mpz_get_ui (bs);\n\t}\n      while (divisor == 0);\n\n      mpz_urandomb (bs, rands, size_range);\n      dividend_size = mpz_get_ui (bs);\n      mpz_rrandomb (dividend, rands, dividend_size);\n\n      mpz_urandomb (bs, rands, 2);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (dividend, dividend);\n\n      /* printf (\"%ld\\n\", SIZ (dividend)); */\n\n      r_rq = mpz_cdiv_qr_ui (quotient, remainder, dividend, divisor);\n      r_q = mpz_cdiv_q_ui (quotient2, dividend, divisor);\n      r_r = mpz_cdiv_r_ui (remainder2, dividend, divisor);\n      r = mpz_cdiv_ui (dividend, divisor);\n\n      /* First determine that the quotients and remainders computed\n\t with different functions are equal.  */\n      if (mpz_cmp (quotient, quotient2) != 0)\n\tdump_abort (\"quotients from mpz_cdiv_qr_ui and mpz_cdiv_q_ui differ\",\n\t\t    dividend, divisor);\n      if (mpz_cmp (remainder, remainder2) != 0)\n\tdump_abort (\"remainders from mpz_cdiv_qr_ui and mpz_cdiv_r_ui differ\",\n\t\t    dividend, divisor);\n\n      /* Check if the sign of the quotient is correct.  */\n      if (mpz_cmp_ui (quotient, 0) != 0)\n\tif ((mpz_cmp_ui (quotient, 0) < 0)\n\t    != (mpz_cmp_ui (dividend, 0) < 0))\n\tdump_abort (\"quotient sign wrong\", dividend, divisor);\n\n      /* Check if the remainder has the opposite sign as the (positive) divisor\n\t (quotient rounded towards minus infinity).  */\n      if (mpz_cmp_ui (remainder, 0) != 0)\n\tif (mpz_cmp_ui (remainder, 0) > 0)\n\t  dump_abort (\"remainder sign wrong\", dividend, divisor);\n\n      mpz_mul_ui (temp, quotient, divisor);\n      mpz_add (temp, temp, remainder);\n      if (mpz_cmp (temp, dividend) != 0)\n\tdump_abort (\"n mod d != n - [n/d]*d\", dividend, divisor);\n\n      mpz_abs (remainder, remainder);\n      if (mpz_cmp_ui (remainder, divisor) >= 0)\n\tdump_abort (\"remainder greater than divisor\", dividend, divisor);\n\n      if (mpz_cmp_ui (remainder, r_rq) != 0)\n\tdump_abort (\"remainder returned from mpz_cdiv_qr_ui is wrong\",\n\t\t    dividend, divisor);\n      if (mpz_cmp_ui (remainder, r_q) != 0)\n\tdump_abort (\"remainder returned from mpz_cdiv_q_ui is wrong\",\n\t\t    dividend, divisor);\n      if (mpz_cmp_ui (remainder, r_r) != 0)\n\tdump_abort (\"remainder returned from mpz_cdiv_r_ui is wrong\",\n\t\t    dividend, divisor);\n      if (mpz_cmp_ui (remainder, r) != 0)\n\tdump_abort (\"remainder returned from mpz_cdiv_ui is wrong\",\n\t\t    dividend, divisor);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (dividend);\n  mpz_clear (quotient);\n  mpz_clear (remainder);\n  mpz_clear (quotient2);\n  mpz_clear (remainder2);\n  mpz_clear (temp);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 114,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "dump_abort": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\ndump_abort (const char *str, mpz_t dividend, unsigned long divisor)\n{\n  fprintf (stderr, \"ERROR: %s\\n\", str);\n  fprintf (stderr, \"dividend = \"); debug_mp (dividend, -16);\n  fprintf (stderr, \"divisor  = %lX\\n\", divisor);\n  abort();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "debug_mp": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-cmp.c": {
    "check_one": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\ncheck_one (mpz_ptr x, mpz_ptr y, int want_cmp, int want_cmpabs)\n{\n  int  got;\n\n  got = mpz_cmp (x, y);\n  if ((   got <  0) != (want_cmp <  0)\n      || (got == 0) != (want_cmp == 0)\n      || (got >  0) != (want_cmp >  0))\n    {\n      printf (\"mpz_cmp got %d want %d\\n\", got, want_cmp);\n      mpz_trace (\"x\", x);\n      mpz_trace (\"y\", y);\n      abort ();\n    }\n\n  got = mpz_cmpabs (x, y);\n  if ((   got <  0) != (want_cmpabs <  0)\n      || (got == 0) != (want_cmpabs == 0)\n      || (got >  0) != (want_cmpabs >  0))\n    {\n      printf (\"mpz_cmpabs got %d want %d\\n\", got, want_cmpabs);\n      mpz_trace (\"x\", x);\n      mpz_trace (\"y\", y);\n      abort ();\n    }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_all": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\ncheck_all (mpz_ptr x, mpz_ptr y, int want_cmp, int want_cmpabs)\n{\n  check_one (x, y,  want_cmp,  want_cmpabs);\n  check_one (y, x, -want_cmp, -want_cmpabs);\n\n  mpz_neg (x, x);\n  mpz_neg (y, y);\n  want_cmp = -want_cmp;\n\n  check_one (x, y,  want_cmp,  want_cmpabs);\n  check_one (y, x, -want_cmp, -want_cmpabs);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  mpz_t  x, y;\n\n  mpz_init (x);\n  mpz_init (y);\n\n  mpz_realloc (x, (mp_size_t) 20);\n  mpz_realloc (y, (mp_size_t) 20);\n\n  /* 0 cmp 0, junk in low limbs */\n  SET1 (x,0, 123);\n  SET1 (y,0, 456);\n  check_all (x, y, 0, 0);\n\n\n  /* 123 cmp 0 */\n  SET1 (x,1, 123);\n  SET1 (y,0, 456);\n  check_all (x, y, 1, 1);\n\n  /* 123:456 cmp 0 */\n  SET2 (x,2, 456,123);\n  SET1 (y,0, 9999);\n  check_all (x, y, 1, 1);\n\n\n  /* 123 cmp 123 */\n  SET1(x,1, 123);\n  SET1(y,1, 123);\n  check_all (x, y, 0, 0);\n\n  /* -123 cmp 123 */\n  SET1(x,-1, 123);\n  SET1(y,1,  123);\n  check_all (x, y, -1, 0);\n\n\n  /* 123 cmp 456 */\n  SET1(x,1, 123);\n  SET1(y,1, 456);\n  check_all (x, y, -1, -1);\n\n  /* -123 cmp 456 */\n  SET1(x,-1, 123);\n  SET1(y,1,  456);\n  check_all (x, y, -1, -1);\n\n  /* 123 cmp -456 */\n  SET1(x,1,  123);\n  SET1(y,-1, 456);\n  check_all (x, y, 1, -1);\n\n\n  /* 1:0 cmp 1:0 */\n  SET2 (x,2, 1,0);\n  SET2 (y,2, 1,0);\n  check_all (x, y, 0, 0);\n\n  /* -1:0 cmp 1:0 */\n  SET2 (x,-2, 1,0);\n  SET2 (y,2,  1,0);\n  check_all (x, y, -1, 0);\n\n\n  /* 2:0 cmp 1:0 */\n  SET2 (x,2, 2,0);\n  SET2 (y,2, 1,0);\n  check_all (x, y, 1, 1);\n\n\n  /* 4:3:2:1 cmp 2:1 */\n  SET4 (x,4, 4,3,2,1);\n  SET2 (y,2, 2,1);\n  check_all (x, y, 1, 1);\n\n  /* -4:3:2:1 cmp 2:1 */\n  SET4 (x,-4, 4,3,2,1);\n  SET2 (y,2,  2,1);\n  check_all (x, y, -1, 1);\n\n\n  mpz_clear (x);\n  mpz_clear (y);\n}",
      "lines": 86,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_various ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-cmp_d.c": {
    "check_one": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\ncheck_one (const char *name, mpz_srcptr x, double y, int cmp, int cmpabs)\n{\n  int   got;\n\n  got = mpz_cmp_d (x, y);\n  if (SGN(got) != cmp)\n    {\n      int i;\n      printf    (\"mpz_cmp_d wrong (from %s)\\n\", name);\n      printf    (\"  got  %d\\n\", got);\n      printf    (\"  want %d\\n\", cmp);\n    fail:\n      mpz_trace (\"  x\", x);\n      printf    (\"  y %g\\n\", y);\n      mp_trace_base=-16;\n      mpz_trace (\"  x\", x);\n      printf    (\"  y %g\\n\", y);\n      printf    (\"  y\");\n      for (i = 0; i < sizeof(y); i++)\n        printf (\" %02X\", (unsigned) ((unsigned char *) &y)[i]);\n      printf (\"\\n\");\n      abort ();\n    }\n\n  got = mpz_cmpabs_d (x, y);\n  if (SGN(got) != cmpabs)\n    {\n      printf    (\"mpz_cmpabs_d wrong\\n\");\n      printf    (\"  got  %d\\n\", got);\n      printf    (\"  want %d\\n\", cmpabs);\n      goto fail;\n    }\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *x;\n    double      y;\n    int         cmp, cmpabs;\n\n  } data[] = {\n\n    {  \"0\",  0.0,  0,  0 },\n\n    {  \"1\",  0.0,  1,  1 },\n    { \"-1\",  0.0, -1,  1 },\n\n    {  \"1\",  0.5,  1,  1 },\n    { \"-1\", -0.5, -1,  1 },\n\n    {  \"0\",  1.0, -1, -1 },\n    {  \"0\", -1.0,  1, -1 },\n\n    {  \"0x1000000000000000000000000000000000000000000000000\", 1.0,  1, 1 },\n    { \"-0x1000000000000000000000000000000000000000000000000\", 1.0, -1, 1 },\n\n    {  \"0\",  1e100, -1, -1 },\n    {  \"0\", -1e100,  1, -1 },\n\n    {  \"2\",  1.5,   1,  1 },\n    {  \"2\", -1.5,   1,  1 },\n    { \"-2\",  1.5,  -1,  1 },\n    { \"-2\", -1.5,  -1,  1 },\n  };\n\n  mpz_t  x;\n  int    i;\n\n  mpz_init (x);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (x, data[i].x, 0);\n      check_one (\"check_data\", x, data[i].y, data[i].cmp, data[i].cmpabs);\n    }\n\n  mpz_clear (x);\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_onebits": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\ncheck_onebits (void)\n{\n  mpz_t   x, x2;\n  double  y;\n  int     i;\n\n  mpz_init_set_ui (x, 0L);\n  mpz_init (x2);\n\n  for (i = 0; i < 512; i++)\n    {\n      mpz_mul_2exp (x, x, 1);\n      mpz_add_ui (x, x, 1L);\n\n      y = mpz_get_d (x);\n      mpz_set_d (x2, y);\n\n      /* stop if any truncation is occurring */\n      if (mpz_cmp (x, x2) != 0)\n        break;\n\n      check_one (\"check_onebits\", x, y, 0, 0);\n      check_one (\"check_onebits\", x, -y, 1, 0);\n      mpz_neg (x, x);\n      check_one (\"check_onebits\", x, y, -1, 0);\n      check_one (\"check_onebits\", x, -y, 0, 0);\n      mpz_neg (x, x);\n    }\n\n  mpz_clear (x);\n  mpz_clear (x2);\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_low_z_one": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void\ncheck_low_z_one (void)\n{\n  mpz_t          x;\n  double         y;\n  unsigned long  i;\n\n  mpz_init (x);\n\n  /* FIXME: It'd be better to base this on the float format. */\n#if defined (__vax) || defined (__vax__)\n#define LIM 127\t\t\t/* vax fp numbers have limited range */\n#else\n#define LIM 512\n#endif\n\n  for (i = 1; i < LIM; i++)\n    {\n      mpz_set_ui (x, 1L);\n      mpz_mul_2exp (x, x, i);\n      y = mpz_get_d (x);\n\n      check_one (\"check_low_z_one\", x, y,   0, 0);\n      check_one (\"check_low_z_one\", x, -y,  1, 0);\n      mpz_neg (x, x);\n      check_one (\"check_low_z_one\", x, y,  -1, 0);\n      check_one (\"check_low_z_one\", x, -y,  0, 0);\n      mpz_neg (x, x);\n\n      mpz_sub_ui (x, x, 1);\n\n      check_one (\"check_low_z_one\", x, y,  -1, -1);\n      check_one (\"check_low_z_one\", x, -y,  1, -1);\n      mpz_neg (x, x);\n      check_one (\"check_low_z_one\", x, y,  -1, -1);\n      check_one (\"check_low_z_one\", x, -y,  1, -1);\n      mpz_neg (x, x);\n\n      mpz_add_ui (x, x, 2);\n\n      check_one (\"check_low_z_one\", x, y,   1, 1);\n      check_one (\"check_low_z_one\", x, -y,  1, 1);\n      mpz_neg (x, x);\n      check_one (\"check_low_z_one\", x, y,  -1, 1);\n      check_one (\"check_low_z_one\", x, -y, -1, 1);\n      mpz_neg (x, x);\n    }\n\n  mpz_clear (x);\n}",
      "lines": 50,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_one_2exp": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\ncheck_one_2exp (void)\n{\n  double           e;\n  mpz_t            x;\n  volatile double  y;\n  int              i;\n\n  mpz_init (x);\n\n  e = 1.0;\n  for (i = 0; i < 128; i++)\n    {\n      e /= 2.0;\n      y = 1.0 + e;\n      if (y == 1.0)\n        break;\n\n      mpz_set_ui (x, 1L);\n      check_one (\"check_one_2exp\", x,  y, -1, -1);\n      check_one (\"check_one_2exp\", x, -y,  1, -1);\n\n      mpz_set_si (x, -1L);\n      check_one (\"check_one_2exp\", x,  y, -1, -1);\n      check_one (\"check_one_2exp\", x, -y,  1, -1);\n    }\n\n  mpz_clear (x);\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_infinity": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "void\ncheck_infinity (void)\n{\n  mpz_t   x;\n  double  y = tests_infinity_d ();\n  if (y == 0.0)\n    return;\n\n  mpz_init (x);\n\n  /* 0 cmp inf */\n  mpz_set_ui (x, 0L);\n  check_one (\"check_infinity\", x,  y, -1, -1);\n  check_one (\"check_infinity\", x, -y,  1, -1);\n\n  /* 123 cmp inf */\n  mpz_set_ui (x, 123L);\n  check_one (\"check_infinity\", x,  y, -1, -1);\n  check_one (\"check_infinity\", x, -y,  1, -1);\n\n  /* -123 cmp inf */\n  mpz_set_si (x, -123L);\n  check_one (\"check_infinity\", x,  y, -1, -1);\n  check_one (\"check_infinity\", x, -y,  1, -1);\n\n  /* 2^5000 cmp inf */\n  mpz_set_ui (x, 1L);\n  mpz_mul_2exp (x, x, 5000L);\n  check_one (\"check_infinity\", x,  y, -1, -1);\n  check_one (\"check_infinity\", x, -y,  1, -1);\n\n  /* -2^5000 cmp inf */\n  mpz_neg (x, x);\n  check_one (\"check_infinity\", x,  y, -1, -1);\n  check_one (\"check_infinity\", x, -y,  1, -1);\n\n  mpz_clear (x);\n}",
      "lines": 38,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  check_data ();\n  check_onebits ();\n  check_low_z_one ();\n  check_one_2exp ();\n  check_infinity ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-cmp_si.c": {
    "check_data": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *a, *b;\n    int         want;\n  } data[] = {\n    { \"0\",  \"1\", -1 },\n    { \"0\",  \"0\",  0 },\n    { \"0\", \"-1\",  1 },\n\n    { \"1\",  \"1\", 0 },\n    { \"1\",  \"0\", 1 },\n    { \"1\", \"-1\", 1 },\n\n    { \"-1\",  \"1\", -1 },\n    { \"-1\",  \"0\", -1 },\n    { \"-1\", \"-1\", 0 },\n\n    {           \"0\", \"-0x80000000\",  1 },\n    {  \"0x80000000\", \"-0x80000000\",  1 },\n    {  \"0x80000001\", \"-0x80000000\",  1 },\n    { \"-0x80000000\", \"-0x80000000\",  0 },\n    { \"-0x80000001\", \"-0x80000000\", -1 },\n\n    {                   \"0\", \"-0x8000000000000000\",  1 },\n    {  \"0x8000000000000000\", \"-0x8000000000000000\",  1 },\n    {  \"0x8000000000000001\", \"-0x8000000000000000\",  1 },\n    { \"-0x8000000000000000\", \"-0x8000000000000000\",  0 },\n    { \"-0x8000000000000001\", \"-0x8000000000000000\", -1 },\n  };\n\n  mpz_t  a, bz;\n  long   b;\n  int    got;\n  int    i;\n\n  mpz_init (a);\n  mpz_init (bz);\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (a, data[i].a, 0);\n      mpz_set_str_or_abort (bz, data[i].b, 0);\n\n      if (mpz_fits_slong_p (bz))\n\t{\n\t  b = mpz_get_si (bz);\n\t  got = mpz_cmp_si (a, b);\n\t  if (SGN (got) != data[i].want)\n\t    {\n\t      printf (\"mpz_cmp_si wrong on data[%d]\\n\", i);\n\t      printf (\"  a=\"); mpz_out_str (stdout, 10, a); printf (\"\\n\");\n\t      printf (\"  b=%ld\\n\", b);\n\t      printf (\"  got=%d\\n\", got);\n\t      printf (\"  want=%d\\n\", data[i].want);\n\t      abort();\n\t    }\n\t}\n    }\n\n  mpz_clear (a);\n  mpz_clear (bz);\n}",
      "lines": 63,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-cong.c": {
    "check_one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\ncheck_one (mpz_srcptr a, mpz_srcptr c, mpz_srcptr d, int want)\n{\n  int   got;\n  int   swap;\n\n  for (swap = 0; swap <= 1; swap++)\n    {\n      got = (mpz_congruent_p (a, c, d) != 0);\n      if (want != got)\n\t{\n\t  printf (\"mpz_congruent_p wrong\\n\");\n\t  printf (\"   expected %d got %d\\n\", want, got);\n\t  mpz_trace (\"\t a\", a);\n\t  mpz_trace (\"\t c\", c);\n\t  mpz_trace (\"\t d\", d);\n\t  mp_trace_base = -16;\n\t  mpz_trace (\"\t a\", a);\n\t  mpz_trace (\"\t c\", c);\n\t  mpz_trace (\"\t d\", d);\n\t  abort ();\n\t}\n\n      if (mpz_fits_ulong_p (c) && mpz_fits_ulong_p (d))\n\t{\n\t  unsigned long\t uc = mpz_get_ui (c);\n\t  unsigned long\t ud = mpz_get_ui (d);\n\t  got = (mpz_congruent_ui_p (a, uc, ud) != 0);\n\t  if (want != got)\n\t    {\n\t      printf\t(\"mpz_congruent_ui_p wrong\\n\");\n\t      printf\t(\"   expected %d got %d\\n\", want, got);\n\t      mpz_trace (\"   a\", a);\n\t      printf\t(\"   c=%lu\\n\", uc);\n\t      printf\t(\"   d=%lu\\n\", ud);\n\t      mp_trace_base = -16;\n\t      mpz_trace (\"   a\", a);\n\t      printf\t(\"   c=0x%lX\\n\", uc);\n\t      printf\t(\"   d=0x%lX\\n\", ud);\n\t      abort ();\n\t    }\n\t}\n\n      MPZ_SRCPTR_SWAP (a, c);\n    }\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char *a;\n    const char *c;\n    const char *d;\n    int        want;\n\n  } data[] = {\n\n    /* strict equality mod 0 */\n    { \"0\", \"0\", \"0\", 1 },\n    { \"11\", \"11\", \"0\", 1 },\n    { \"3\", \"11\", \"0\", 0 },\n\n    /* anything congruent mod 1 */\n    { \"0\", \"0\", \"1\", 1 },\n    { \"1\", \"0\", \"1\", 1 },\n    { \"0\", \"1\", \"1\", 1 },\n    { \"123\", \"456\", \"1\", 1 },\n    { \"0x123456789123456789\", \"0x987654321987654321\", \"1\", 1 },\n\n    /* csize==1, dsize==2 changing to 1 after stripping 2s */\n    { \"0x3333333333333333\",  \"0x33333333\",\n      \"0x180000000\", 1 },\n    { \"0x33333333333333333333333333333333\", \"0x3333333333333333\",\n      \"0x18000000000000000\", 1 },\n\n    /* another dsize==2 becoming 1, with opposite signs this time */\n    {  \"0x444444441\",\n      \"-0x22222221F\",\n       \"0x333333330\", 1 },\n    {  \"0x44444444444444441\",\n      \"-0x2222222222222221F\",\n       \"0x33333333333333330\", 1 },\n  };\n\n  mpz_t   a, c, d;\n  int     i;\n\n  mpz_init (a);\n  mpz_init (c);\n  mpz_init (d);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (a, data[i].a, 0);\n      mpz_set_str_or_abort (c, data[i].c, 0);\n      mpz_set_str_or_abort (d, data[i].d, 0);\n      check_one (a, c, d, data[i].want);\n    }\n\n  mpz_clear (a);\n  mpz_clear (c);\n  mpz_clear (d);\n}",
      "lines": 57,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "void\ncheck_random (int argc, char *argv[])\n{\n  gmp_randstate_ptr rands = RANDS;\n  mpz_t   a, c, d, ra, rc;\n  int     i;\n  int     want;\n  int     reps = 10000;\n  mpz_t bs;\n  unsigned long size_range, size;\n\n  if (argc >= 2)\n    reps = atoi (argv[1]);\n\n  mpz_init (bs);\n\n  mpz_init (a);\n  mpz_init (c);\n  mpz_init (d);\n  mpz_init (ra);\n  mpz_init (rc);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 16 + 1; /* 0..65536 bit operands */\n\n      mpz_urandomb (bs, rands, size_range);\n      size = mpz_get_ui (bs);\n      mpz_rrandomb (a, rands, size);\n\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 16 + 1; /* 0..65536 bit operands */\n\n      mpz_urandomb (bs, rands, size_range);\n      size = mpz_get_ui (bs);\n      mpz_rrandomb (c, rands, size);\n\n      do\n\t{\n\t  mpz_urandomb (bs, rands, 32);\n\t  size_range = mpz_get_ui (bs) % 16 + 1; /* 0..65536 bit operands */\n\n\t  mpz_urandomb (bs, rands, size_range);\n\t  size = mpz_get_ui (bs);\n\t  mpz_rrandomb (d, rands, size);\n\t}\n      while (SIZ(d) == 0);\n\n      mpz_negrandom (a, rands);\n      MPZ_CHECK_FORMAT (a);\n      mpz_negrandom (c, rands);\n      MPZ_CHECK_FORMAT (c);\n      mpz_negrandom (d, rands);\n\n      mpz_fdiv_r (ra, a, d);\n      mpz_fdiv_r (rc, c, d);\n\n      want = (mpz_cmp (ra, rc) == 0);\n      check_one (a, c, d, want);\n\n      mpz_sub (ra, ra, rc);\n      mpz_sub (a, a, ra);\n      MPZ_CHECK_FORMAT (a);\n      check_one (a, c, d, 1);\n\n      if (! mpz_pow2abs_p (d))\n        {\n\t  refmpz_combit (a, urandom() % (8*GMP_LIMB_BITS));\n\t  check_one (a, c, d, 0);\n        }\n    }\n\n  mpz_clear (bs);\n\n  mpz_clear (a);\n  mpz_clear (c);\n  mpz_clear (d);\n  mpz_clear (ra);\n  mpz_clear (rc);\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  check_data ();\n  check_random (argc, argv);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-cong_2exp.c": {
    "check_one": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void\ncheck_one (mpz_srcptr a, mpz_srcptr c, unsigned long d, int want)\n{\n  mpz_t  diff, d2exp;\n  int    got;\n  int    swap;\n\n  for (swap = 0; swap <= 1; swap++)\n    {\n      got = (mpz_congruent_2exp_p (a, c, d) != 0);\n      if (want != got)\n        {\n          mpz_init (diff);\n          mpz_init (d2exp);\n\n          mpz_sub (diff, a, c);\n          mpz_set_ui (d2exp, 1L);\n          mpz_mul_2exp (d2exp, d2exp, d);\n\n          printf (\"mpz_congruent_2exp_p wrong\\n\");\n          printf (\"   expected %d got %d\\n\", want, got);\n          mpz_trace (\"   a\", a);\n          mpz_trace (\"   c\", c);\n          mpz_trace (\" a-c\", diff);\n          mpz_trace (\" 2^d\", d2exp);\n          printf    (\"   d=%lu\\n\", d);\n\n          mp_trace_base = -16;\n          mpz_trace (\"   a\", a);\n          mpz_trace (\"   c\", c);\n          mpz_trace (\" a-c\", diff);\n          mpz_trace (\" 2^d\", d2exp);\n          printf    (\"   d=0x%lX\\n\", d);\n          abort ();\n        }\n\n      MPZ_SRCPTR_SWAP (a, c);\n    }\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char     *a;\n    const char     *c;\n    unsigned long  d;\n    int            want;\n\n  } data[] = {\n\n    /* anything is congruent mod 1 */\n    { \"0\", \"0\", 0, 1 },\n    { \"1\", \"0\", 0, 1 },\n    { \"0\", \"1\", 0, 1 },\n    { \"123\", \"-456\", 0, 1 },\n    { \"0x123456789123456789\", \"0x987654321987654321\", 0, 1 },\n    { \"0xfffffffffffffffffffffffffffffff7\", \"-0x9\", 129, 0 },\n    { \"0xfffffffffffffffffffffffffffffff6\", \"-0xa\", 128, 1 },\n\n  };\n\n  mpz_t   a, c;\n  int     i;\n\n  mpz_init (a);\n  mpz_init (c);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (a, data[i].a, 0);\n      mpz_set_str_or_abort (c, data[i].c, 0);\n      check_one (a, c, data[i].d, data[i].want);\n    }\n\n  mpz_clear (a);\n  mpz_clear (c);\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void\ncheck_random (int reps)\n{\n  gmp_randstate_ptr rands = RANDS;\n  unsigned long  d;\n  mpz_t  a, c, ra, rc;\n  int    i;\n\n  mpz_init (a);\n  mpz_init (c);\n  mpz_init (ra);\n  mpz_init (rc);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_errandomb (a, rands, 8*GMP_LIMB_BITS);\n      mpz_errandomb (c, rands, 8*GMP_LIMB_BITS);\n      d = urandom() % (8*GMP_LIMB_BITS);\n\n      mpz_mul_2exp (a, a, urandom() % (2*GMP_LIMB_BITS));\n      mpz_mul_2exp (c, c, urandom() % (2*GMP_LIMB_BITS));\n\n      mpz_negrandom (a, rands);\n      mpz_negrandom (c, rands);\n\n      mpz_fdiv_r_2exp (ra, a, d);\n      mpz_fdiv_r_2exp (rc, c, d);\n\n      mpz_sub (ra, ra, rc);\n      if (mpz_cmp_ui (ra, 0) != 0)\n\t{\n\t  check_one (a, c, d, 0);\n\t  mpz_sub (a, a, ra);\n\t}\n      check_one (a, c, d, 1);\n      if (d != 0)\n\t{\n\t  mpz_combit (a, urandom() % d);\n\t  check_one (a, c, d, 0);\n\t}\n    }\n\n  mpz_clear (a);\n  mpz_clear (c);\n  mpz_clear (ra);\n  mpz_clear (rc);\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_random_bits": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\ncheck_random_bits (int reps)\n{\n  mp_bitcnt_t ea, ec, en, d;\n  mp_bitcnt_t m = 10 * GMP_LIMB_BITS;\n  mpz_t  a, c;\n  int    i;\n\n  mpz_init2 (a, m + 1);\n  mpz_init2 (c, m);\n\n  for (i = 0; i < reps; i++)\n    {\n      d  = urandom() % m;\n      ea = urandom() % m;\n      ec = urandom() % m;\n      en = urandom() % m;\n\n      mpz_set_ui (c, 0);\n      mpz_setbit (c, en);\n\n      mpz_set_ui (a, 0);\n      mpz_setbit (a, ec);\n      mpz_sub (c , a, c);\n\n      mpz_set_ui (a, 0);\n      mpz_setbit (a, ea);\n      mpz_add (a , a, c);\n\n      check_one (a, c, d, ea >= d);\n    }\n\n  mpz_clear (a);\n  mpz_clear (c);\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int    reps = 5000;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  check_data ();\n  check_random (reps);\n  check_random_bits (reps);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-divis.c": {
    "check_one": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\ncheck_one (mpz_srcptr a, mpz_srcptr d, int want)\n{\n  int   got;\n\n  if (mpz_fits_ulong_p (d))\n    {\n      unsigned long  u = mpz_get_ui (d);\n      got = (mpz_divisible_ui_p (a, u) != 0);\n      if (want != got)\n        {\n          printf (\"mpz_divisible_ui_p wrong\\n\");\n          printf (\"   expected %d got %d\\n\", want, got);\n          mpz_trace (\"   a\", a);\n          printf (\"   d=%lu\\n\", u);\n          mp_trace_base = -16;\n          mpz_trace (\"   a\", a);\n          printf (\"   d=0x%lX\\n\", u);\n          abort ();\n        }\n    }\n\n  got = (mpz_divisible_p (a, d) != 0);\n  if (want != got)\n    {\n      printf (\"mpz_divisible_p wrong\\n\");\n      printf (\"   expected %d got %d\\n\", want, got);\n      mpz_trace (\"   a\", a);\n      mpz_trace (\"   d\", d);\n      mp_trace_base = -16;\n      mpz_trace (\"   a\", a);\n      mpz_trace (\"   d\", d);\n      abort ();\n    }\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char *a;\n    const char *d;\n    int        want;\n\n  } data[] = {\n\n    { \"0\",    \"0\", 1 },\n    { \"17\",   \"0\", 0 },\n    { \"0\",    \"1\", 1 },\n    { \"123\",  \"1\", 1 },\n    { \"-123\", \"1\", 1 },\n\n    { \"0\",  \"2\", 1 },\n    { \"1\",  \"2\", 0 },\n    { \"2\",  \"2\", 1 },\n    { \"-2\", \"2\", 1 },\n    { \"0x100000000000000000000000000000000\", \"2\", 1 },\n    { \"0x100000000000000000000000000000001\", \"2\", 0 },\n\n    { \"0x3333333333333333\", \"3\", 1 },\n    { \"0x3333333333333332\", \"3\", 0 },\n    { \"0x33333333333333333333333333333333\", \"3\", 1 },\n    { \"0x33333333333333333333333333333332\", \"3\", 0 },\n\n    /* divisor changes from 2 to 1 limb after stripping 2s */\n    {          \"0x3333333300000000\",         \"0x180000000\",         1 },\n    {  \"0x33333333333333330000000000000000\", \"0x18000000000000000\", 1 },\n    { \"0x133333333333333330000000000000000\", \"0x18000000000000000\", 0 },\n  };\n\n  mpz_t   a, d;\n  int     i;\n\n  mpz_init (a);\n  mpz_init (d);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (a, data[i].a, 0);\n      mpz_set_str_or_abort (d, data[i].d, 0);\n      check_one (a, d, data[i].want);\n    }\n\n  mpz_clear (a);\n  mpz_clear (d);\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "void\ncheck_random (int reps)\n{\n  gmp_randstate_ptr rands = RANDS;\n  mpz_t   a, d, r;\n  int     i;\n  int     want;\n\n  mpz_init (a);\n  mpz_init (d);\n  mpz_init (r);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_erandomb (a, rands, 1 << 19);\n      mpz_erandomb_nonzero (d, rands, 1 << 18);\n\n      mpz_fdiv_r (r, a, d);\n\n      want = (mpz_sgn (r) == 0);\n      check_one (a, d, want);\n\n      mpz_sub (a, a, r);\n      check_one (a, d, 1);\n\n      if (mpz_cmpabs_ui (d, 1L) == 0)\n        continue;\n\n      mpz_add_ui (a, a, 1L);\n      check_one (a, d, 0);\n    }\n\n  mpz_clear (a);\n  mpz_clear (d);\n  mpz_clear (r);\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int  reps = 100;\n\n  tests_start ();\n\n  if (argc == 2)\n    reps = atoi (argv[1]);\n\n  check_data ();\n  check_random (reps);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-divis_2exp.c": {
    "check_one": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\ncheck_one (mpz_srcptr a, unsigned long d, int want)\n{\n  int   got;\n\n  got = (mpz_divisible_2exp_p (a, d) != 0);\n  if (want != got)\n    {\n      printf (\"mpz_divisible_2exp_p wrong\\n\");\n      printf (\"   expected %d got %d\\n\", want, got);\n      mpz_trace (\"   a\", a);\n      printf    (\"   d=%lu\\n\", d);\n      mp_trace_base = -16;\n      mpz_trace (\"   a\", a);\n      printf    (\"   d=0x%lX\\n\", d);\n      abort ();\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char    *a;\n    unsigned long d;\n    int           want;\n\n  } data[] = {\n\n    { \"0\", 0, 1 },\n    { \"0\", 1, 1 },\n    { \"0\", 2, 1 },\n    { \"0\", 3, 1 },\n\n    { \"1\", 0, 1 },\n    { \"1\", 1, 0 },\n    { \"1\", 2, 0 },\n    { \"1\", 3, 0 },\n    { \"1\", 10000, 0 },\n\n    { \"4\", 0, 1 },\n    { \"4\", 1, 1 },\n    { \"4\", 2, 1 },\n    { \"4\", 3, 0 },\n    { \"4\", 4, 0 },\n    { \"4\", 10000, 0 },\n\n    { \"0x80000000\", 31, 1 },\n    { \"0x80000000\", 32, 0 },\n    { \"0x80000000\", 64, 0 },\n\n    { \"0x100000000\", 32, 1 },\n    { \"0x100000000\", 33, 0 },\n    { \"0x100000000\", 64, 0 },\n\n    { \"0x8000000000000000\", 63, 1 },\n    { \"0x8000000000000000\", 64, 0 },\n    { \"0x8000000000000000\", 128, 0 },\n\n    { \"0x10000000000000000\", 64, 1 },\n    { \"0x10000000000000000\", 65, 0 },\n    { \"0x10000000000000000\", 128, 0 },\n    { \"0x10000000000000000\", 256, 0 },\n\n    { \"0x10000000000000000100000000\", 32, 1 },\n    { \"0x10000000000000000100000000\", 33, 0 },\n    { \"0x10000000000000000100000000\", 64, 0 },\n\n    { \"0x1000000000000000010000000000000000\", 64, 1 },\n    { \"0x1000000000000000010000000000000000\", 65, 0 },\n    { \"0x1000000000000000010000000000000000\", 128, 0 },\n    { \"0x1000000000000000010000000000000000\", 256, 0 },\n    { \"0x1000000000000000010000000000000000\", 1024, 0 },\n\n  };\n\n  mpz_t   a, d;\n  int     i;\n\n  mpz_init (a);\n  mpz_init (d);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (a, data[i].a, 0);\n      check_one (a, data[i].d, data[i].want);\n\n      mpz_neg (a, a);\n      check_one (a, data[i].d, data[i].want);\n    }\n\n  mpz_clear (a);\n  mpz_clear (d);\n}",
      "lines": 75,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-div_2exp.c": {
    "check_one": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\ncheck_one (mpz_srcptr a, unsigned long d)\n{\n  mpz_t  q, r, p, d2exp;\n  int    inplace;\n\n  mpz_init (d2exp);\n  mpz_init (q);\n  mpz_init (r);\n  mpz_init (p);\n\n  mpz_set_ui (d2exp, 1L);\n  mpz_mul_2exp (d2exp, d2exp, d);\n\n#define INPLACE(fun,dst,src,d)  \\\n  if (inplace)                  \\\n    {                           \\\n      mpz_set (dst, src);       \\\n      fun (dst, dst, d);        \\\n    }                           \\\n  else                          \\\n    fun (dst, src, d);\n\n  for (inplace = 0; inplace <= 1; inplace++)\n    {\n      INPLACE (mpz_fdiv_q_2exp, q, a, d);\n      INPLACE (mpz_fdiv_r_2exp, r, a, d);\n\n      mpz_mul_2exp (p, q, d);\n      mpz_add (p, p, r);\n      if (mpz_sgn (r) < 0 || mpz_cmp (r, d2exp) >= 0)\n\t{\n\t  printf (\"mpz_fdiv_r_2exp result out of range\\n\");\n\t  goto error;\n\t}\n      if (mpz_cmp (p, a) != 0)\n\t{\n\t  printf (\"mpz_fdiv_[qr]_2exp doesn't multiply back\\n\");\n\t  goto error;\n\t}\n\n\n      INPLACE (mpz_cdiv_q_2exp, q, a, d);\n      INPLACE (mpz_cdiv_r_2exp, r, a, d);\n\n      mpz_mul_2exp (p, q, d);\n      mpz_add (p, p, r);\n      if (mpz_sgn (r) > 0 || mpz_cmpabs (r, d2exp) >= 0)\n\t{\n\t  printf (\"mpz_cdiv_r_2exp result out of range\\n\");\n\t  goto error;\n\t}\n      if (mpz_cmp (p, a) != 0)\n\t{\n\t  printf (\"mpz_cdiv_[qr]_2exp doesn't multiply back\\n\");\n\t  goto error;\n\t}\n\n\n      INPLACE (mpz_tdiv_q_2exp, q, a, d);\n      INPLACE (mpz_tdiv_r_2exp, r, a, d);\n\n      mpz_mul_2exp (p, q, d);\n      mpz_add (p, p, r);\n      if (mpz_sgn (r) != 0 && mpz_sgn (r) != mpz_sgn (a))\n\t{\n\t  printf (\"mpz_tdiv_r_2exp result wrong sign\\n\");\n\t  goto error;\n\t}\n      if (mpz_cmpabs (r, d2exp) >= 0)\n\t{\n\t  printf (\"mpz_tdiv_r_2exp result out of range\\n\");\n\t  goto error;\n\t}\n      if (mpz_cmp (p, a) != 0)\n\t{\n\t  printf (\"mpz_tdiv_[qr]_2exp doesn't multiply back\\n\");\n\t  goto error;\n\t}\n    }\n\n  mpz_clear (d2exp);\n  mpz_clear (q);\n  mpz_clear (r);\n  mpz_clear (p);\n  return;\n\n\n error:\n  mpz_trace (\"a\", a);\n  printf    (\"d=%lu\\n\", d);\n  mpz_trace (\"q\", q);\n  mpz_trace (\"r\", r);\n  mpz_trace (\"p\", p);\n\n  mp_trace_base = -16;\n  mpz_trace (\"a\", a);\n  printf    (\"d=0x%lX\\n\", d);\n  mpz_trace (\"q\", q);\n  mpz_trace (\"r\", r);\n  mpz_trace (\"p\", p);\n\n  abort ();\n}",
      "lines": 104,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_all": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "void\ncheck_all (mpz_ptr a, unsigned long d)\n{\n  check_one (a, d);\n  mpz_neg (a, a);\n  check_one (a, d);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  static const unsigned long  table[] = {\n    0, 1, 2, 3, 4, 5,\n    GMP_NUMB_BITS-1, GMP_NUMB_BITS, GMP_NUMB_BITS+1,\n    2*GMP_NUMB_BITS-1, 2*GMP_NUMB_BITS, 2*GMP_NUMB_BITS+1,\n    3*GMP_NUMB_BITS-1, 3*GMP_NUMB_BITS, 3*GMP_NUMB_BITS+1,\n    4*GMP_NUMB_BITS-1, 4*GMP_NUMB_BITS, 4*GMP_NUMB_BITS+1\n  };\n\n  int            i, j;\n  unsigned long  n, d;\n  mpz_t          a;\n\n  mpz_init (a);\n\n  /* a==0, and various d */\n  mpz_set_ui (a, 0L);\n  for (i = 0; i < numberof (table); i++)\n    check_one (a, table[i]);\n\n  /* a==2^n, and various d */\n  for (i = 0; i < numberof (table); i++)\n    {\n      n = table[i];\n      mpz_set_ui (a, 1L);\n      mpz_mul_2exp (a, a, n);\n\n      for (j = 0; j < numberof (table); j++)\n\t{\n\t  d = table[j];\n\t  check_all (a, d);\n\t}\n    }\n\n  mpz_clear (a);\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "void\ncheck_random (int argc, char *argv[])\n{\n  gmp_randstate_ptr  rands = RANDS;\n  int            reps = 100;\n  mpz_t          a;\n  unsigned long  d;\n  int            i;\n\n  if (argc == 2)\n    reps = atoi (argv[1]);\n\n  mpz_init (a);\n\n  for (i = 0; i < reps; i++)\n    {\n      /* exponentially within 2 to 257 bits */\n      mpz_erandomb (a, rands, urandom () % 8 + 2);\n\n      d = urandom () % 256;\n\n      check_all (a, d);\n    }\n\n  mpz_clear (a);\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  check_various ();\n  check_random (argc, argv);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-export.c": {
    "check_data": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *src;\n    size_t      want_count;\n    int         order;\n    size_t      size;\n    int         endian;\n    int         nail;\n    char        want_data[64];\n\n  } data[] = {\n\n    { \"0\", 0,1, 1,1, 0 },\n    { \"0\", 0,1, 2,1, 0 },\n    { \"0\", 0,1, 3,1, 0 },\n\n    { \"0x12345678\", 4,1,  1,1, 0, { '\\022', '\\064', '\\126', '\\170' } },\n    { \"0x12345678\", 1,1,  4,1, 0, { '\\022', '\\064', '\\126', '\\170' } },\n    { \"0x12345678\", 1,-1, 4,1, 0, { '\\022', '\\064', '\\126', '\\170' } },\n\n    { \"0x12345678\", 4,-1, 1,-1, 0, { '\\170', '\\126', '\\064', '\\022' } },\n    { \"0x12345678\", 1,1,  4,-1, 0, { '\\170', '\\126', '\\064', '\\022' } },\n    { \"0x12345678\", 1,-1, 4,-1, 0, { '\\170', '\\126', '\\064', '\\022' } },\n\n    { \"0x15\", 5,1,  1,1, 7, { '\\001', '\\000', '\\001', '\\000', '\\001' } },\n\n    { \"0x1FFFFFFFFFFF\", 3,1,  2,1,   1, {\n\t'\\177','\\377', '\\177','\\377', '\\177','\\377' } },\n    { \"0x1FFFFFFFFFFF\", 3,1,  2,-1,  1, {\n\t'\\377','\\177', '\\377','\\177', '\\377','\\177' } },\n    { \"0x7\",            3,1,  2,1,  15, {\n\t'\\000','\\001', '\\000','\\001', '\\000','\\001' } },\n    { \"0x7\",            3,1,  2,-1, 15, {\n\t'\\001','\\000', '\\001','\\000', '\\001','\\000' } },\n\n    { \"0x24\", 3,1,  2,1,  14, { '\\000','\\002', '\\000','\\001', '\\000','\\000' }},\n    { \"0x24\", 3,1,  2,-1, 14, { '\\002','\\000', '\\001','\\000', '\\000','\\000' }},\n    { \"0x24\", 3,-1, 2,-1, 14, { '\\000','\\000', '\\001','\\000', '\\002','\\000' }},\n    { \"0x24\", 3,-1, 2,1,  14, { '\\000','\\000', '\\000','\\001', '\\000','\\002' }},\n\n    { \"0x123456789ABC\", 3,1,  2,1,  0, {\n\t'\\022','\\064', '\\126','\\170', '\\232','\\274' } },\n    { \"0x123456789ABC\", 3,-1, 2,1,  0, {\n\t'\\232','\\274', '\\126','\\170', '\\022','\\064' } },\n    { \"0x123456789ABC\", 3,1,  2,-1, 0, {\n\t'\\064','\\022', '\\170','\\126', '\\274','\\232' } },\n    { \"0x123456789ABC\", 3,-1, 2,-1, 0, {\n\t'\\274','\\232', '\\170','\\126', '\\064','\\022' } },\n\n    { \"0x112233445566778899AABBCC\", 3,1,  4,1,  0,\n      { '\\021','\\042','\\063','\\104',\n\t'\\125','\\146','\\167','\\210',\n\t'\\231','\\252','\\273','\\314' } },\n    { \"0x112233445566778899AABBCC\", 3,-1, 4,1,  0,\n      { '\\231','\\252','\\273','\\314',\n\t'\\125','\\146','\\167','\\210',\n\t'\\021','\\042','\\063','\\104' } },\n    { \"0x112233445566778899AABBCC\", 3,1,  4,-1, 0,\n      { '\\104','\\063','\\042','\\021',\n\t'\\210','\\167','\\146','\\125',\n\t'\\314','\\273','\\252','\\231' } },\n    { \"0x112233445566778899AABBCC\", 3,-1, 4,-1, 0,\n      { '\\314','\\273','\\252','\\231',\n\t'\\210','\\167','\\146','\\125',\n\t'\\104','\\063','\\042','\\021' } },\n\n    { \"0x100120023003400450056006700780089009A00AB00BC00C\", 3,1,  8,1,  0,\n      { '\\020','\\001','\\040','\\002','\\060','\\003','\\100','\\004',\n\t'\\120','\\005','\\140','\\006','\\160','\\007','\\200','\\010',\n\t'\\220','\\011','\\240','\\012','\\260','\\013','\\300','\\014' } },\n    { \"0x100120023003400450056006700780089009A00AB00BC00C\", 3,-1, 8,1,  0,\n      { '\\220','\\011','\\240','\\012','\\260','\\013','\\300','\\014',\n\t'\\120','\\005','\\140','\\006','\\160','\\007','\\200','\\010',\n\t'\\020','\\001','\\040','\\002','\\060','\\003','\\100','\\004' } },\n    { \"0x100120023003400450056006700780089009A00AB00BC00C\", 3,1,  8,-1, 0,\n      { '\\004','\\100','\\003','\\060','\\002','\\040','\\001','\\020',\n\t'\\010','\\200','\\007','\\160','\\006','\\140','\\005','\\120',\n\t'\\014','\\300','\\013','\\260','\\012','\\240','\\011','\\220' } },\n    { \"0x100120023003400450056006700780089009A00AB00BC00C\", 3,-1, 8,-1, 0,\n      { '\\014','\\300','\\013','\\260','\\012','\\240','\\011','\\220',\n\t'\\010','\\200','\\007','\\160','\\006','\\140','\\005','\\120',\n\t'\\004','\\100','\\003','\\060','\\002','\\040','\\001','\\020' } },\n\n    { \"0x155555555555555555555555\", 3,1,  4,1,  1,\n      { '\\125','\\125','\\125','\\125',\n\t'\\052','\\252','\\252','\\252',\n\t'\\125','\\125','\\125','\\125' } },\n    { \"0x155555555555555555555555\", 3,-1,  4,1,  1,\n      { '\\125','\\125','\\125','\\125',\n\t'\\052','\\252','\\252','\\252',\n\t'\\125','\\125','\\125','\\125' } },\n    { \"0x155555555555555555555555\", 3,1,  4,-1,  1,\n      { '\\125','\\125','\\125','\\125',\n\t'\\252','\\252','\\252','\\052',\n\t'\\125','\\125','\\125','\\125' } },\n    { \"0x155555555555555555555555\", 3,-1,  4,-1,  1,\n      { '\\125','\\125','\\125','\\125',\n\t'\\252','\\252','\\252','\\052',\n\t'\\125','\\125','\\125','\\125' } },\n  };\n\n  char    buf[sizeof(data[0].src) + sizeof (mp_limb_t) + 128];\n  char    *got_data;\n  void    *ret;\n  size_t  align, got_count, j;\n  int     i, error = 0;\n  mpz_t   src;\n\n  mpz_init (src);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      for (align = 0; align < sizeof (mp_limb_t); align++)\n\t{\n\t  mpz_set_str_or_abort (src, data[i].src, 0);\n\t  MPZ_CHECK_FORMAT (src);\n\t  got_data = buf + align;\n\n\t  ASSERT_ALWAYS (data[i].want_count * data[i].size + align\n\t\t\t <= sizeof (buf));\n\n\t  memset (got_data, '\\0', data[i].want_count * data[i].size);\n\t  ret = mpz_export (got_data, &got_count, data[i].order,\n\t\t\t    data[i].size, data[i].endian, data[i].nail, src);\n\n\t  if (ret != got_data)\n\t    {\n\t      printf (\"return doesn't equal given pointer\\n\");\n\t      error = 1;\n\t    }\n\t  if (got_count != data[i].want_count)\n\t    {\n\t      printf (\"wrong count\\n\");\n\t      error = 1;\n\t    }\n\t  if (memcmp (got_data, data[i].want_data, got_count * data[i].size) != 0)\n\t    {\n\t      printf (\"wrong result data\\n\");\n\t      error = 1;\n\t    }\n\t  if (error)\n\t    {\n\t      printf (\"    at data[%d]  align=%d\\n\", i, (int) align);\n\t      printf (\"    src \\\"%s\\\"\\n\", data[i].src);\n\t      mpz_trace (\"    src\", src);\n\t      printf (\"    order=%d  size=%lu endian=%d nail=%u\\n\",\n\t\t      data[i].order,\n\t\t      (unsigned long) data[i].size, data[i].endian, data[i].nail);\n\t      printf (\"    want count %lu\\n\", (unsigned long) data[i].want_count);\n\t      printf (\"    got count  %lu\\n\", (unsigned long) got_count);\n\t      printf (\"    want\");\n\t      for (j = 0; j < data[i].want_count*data[i].size; j++)\n\t\tprintf (\" 0x%02X,\", (unsigned) (unsigned char) data[i].want_data[j]);\n\t      printf (\"\\n\");\n\t      printf (\"    got \");\n\t      for (j = 0; j < got_count*data[i].size; j++)\n\t\tprintf (\" 0x%02X,\", (unsigned) (unsigned char) got_data[j]);\n\t      printf (\"\\n\");\n\t      abort ();\n\t    }\n\t}\n    }\n  mpz_clear (src);\n}",
      "lines": 166,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  mp_trace_base = -16;\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-fac_ui.c": {
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  unsigned long  n, m;\n  unsigned long  limit = 2222;\n  mpz_t          df[2], f, r;\n\n  tests_start ();\n\n  if (argc > 1 && argv[1][0] == 'x')\n    limit = ULONG_MAX;\n  else if (argc > 1)\n    limit = atoi (argv[1]);\n\n  /* for small limb testing */\n  limit = MIN (limit, MP_LIMB_T_MAX);\n\n  mpz_init_set_ui (df[0], 1);  /* 0!! = 1 */\n  mpz_init_set_ui (df[1], 1);  /* -1!! = 1 */\n  mpz_init_set_ui (f, 1);  /* 0! = 1 */\n  mpz_init (r);\n\n  for (n = 0, m = 0; n < limit; n++)\n    {\n      mpz_fac_ui (r, n);\n      MPZ_CHECK_FORMAT (r);\n\n      if (mpz_cmp (f, r) != 0)\n        {\n          printf (\"mpz_fac_ui(%lu) wrong\\n\", n);\n          printf (\"  got  \"); mpz_out_str (stdout, 10, r); printf(\"\\n\");\n          printf (\"  want \"); mpz_out_str (stdout, 10, f); printf(\"\\n\");\n          abort ();\n        }\n\n      mpz_2fac_ui (r, n);\n      MPZ_CHECK_FORMAT (r);\n\n      if (mpz_cmp (df[m], r) != 0)\n        {\n          printf (\"mpz_2fac_ui(%lu) wrong\\n\", n);\n          printf (\"  got  \"); mpz_out_str (stdout, 10, r); printf(\"\\n\");\n          printf (\"  want \"); mpz_out_str (stdout, 10, df[m]); printf(\"\\n\");\n          abort ();\n        }\n\n      m ^= 1;\n      mpz_mul_ui (df[m], df[m], n+1);  /* (n+1)!! = (n-1)!! * (n+1) */\n      mpz_mul_ui (f, f, n+1);  /* (n+1)! = n! * (n+1) */\n    }\n\n  n = 2097169; /* a prime = 1 mod 4*/\n  if (n / 2 > MP_LIMB_T_MAX)\n    n = 131041; /* a smaller prime :-) */\n  mpz_fac_ui (f, n / 2); /* ((n-1)/2)! */\n  m = mpz_fdiv_ui (f, n); /* ((n-1)/2)! mod n*/\n  mpz_set_ui (f, m);\n  mpz_mul_ui (f, f, m); /* (((n-1)/2)!)^2 */\n  m = mpz_fdiv_ui (f, n); /* (((n-1)/2)!)^2 mod n*/\n  if ( m != n - 1)\n    {\n      printf (\"mpz_fac_ui(%lu) wrong\\n\", n / 2);\n      printf (\" al-Haytham's theorem not verified: got %lu, expected %lu.\\n\", m, n - 1);\n      abort ();\n    }\n\n  mpz_clear (df[0]);\n  mpz_clear (df[1]);\n  mpz_clear (f);\n  mpz_clear (r);\n\n  tests_end ();\n\n  exit (0);\n}",
      "lines": 75,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-fdiv.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t dividend, divisor;\n  mpz_t quotient, remainder;\n  mpz_t quotient2, remainder2;\n  mpz_t temp;\n  mp_size_t dividend_size, divisor_size;\n  int i;\n  int reps = 1000;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  mpz_init (dividend);\n  mpz_init (divisor);\n  mpz_init (quotient);\n  mpz_init (remainder);\n  mpz_init (quotient2);\n  mpz_init (remainder2);\n  mpz_init (temp);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 16 + 2; /* 0..131071 bit operands */\n\n      do\n\t{\n\t  mpz_urandomb (bs, rands, size_range);\n\t  divisor_size = mpz_get_ui (bs);\n\t  mpz_rrandomb (divisor, rands, divisor_size);\n\t}\n      while (mpz_sgn (divisor) == 0);\n\n      mpz_urandomb (bs, rands, size_range);\n      dividend_size = mpz_get_ui (bs) + divisor_size;\n      mpz_rrandomb (dividend, rands, dividend_size);\n\n      mpz_urandomb (bs, rands, 2);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (dividend, dividend);\n      if ((bsi & 2) != 0)\n\tmpz_neg (divisor, divisor);\n\n      /* printf (\"%ld %ld\\n\", SIZ (dividend), SIZ (divisor)); */\n\n      mpz_fdiv_qr (quotient, remainder, dividend, divisor);\n      mpz_fdiv_q (quotient2, dividend, divisor);\n      mpz_fdiv_r (remainder2, dividend, divisor);\n\n      /* First determine that the quotients and remainders computed\n\t with different functions are equal.  */\n      if (mpz_cmp (quotient, quotient2) != 0)\n\tdump_abort (dividend, divisor);\n      if (mpz_cmp (remainder, remainder2) != 0)\n\tdump_abort (dividend, divisor);\n\n      /* Check if the sign of the quotient is correct.  */\n      if (mpz_cmp_ui (quotient, 0) != 0)\n\tif ((mpz_cmp_ui (quotient, 0) < 0)\n\t    != ((mpz_cmp_ui (dividend, 0) ^ mpz_cmp_ui (divisor, 0)) < 0))\n\tdump_abort (dividend, divisor);\n\n      /* Check if the remainder has the same sign as the divisor\n\t (quotient rounded towards minus infinity).  */\n      if (mpz_cmp_ui (remainder, 0) != 0)\n\tif ((mpz_cmp_ui (remainder, 0) < 0) != (mpz_cmp_ui (divisor, 0) < 0))\n\t  dump_abort (dividend, divisor);\n\n      mpz_mul (temp, quotient, divisor);\n      mpz_add (temp, temp, remainder);\n      if (mpz_cmp (temp, dividend) != 0)\n\tdump_abort (dividend, divisor);\n\n      mpz_abs (temp, divisor);\n      mpz_abs (remainder, remainder);\n      if (mpz_cmp (remainder, temp) >= 0)\n\tdump_abort (dividend, divisor);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (dividend);\n  mpz_clear (divisor);\n  mpz_clear (quotient);\n  mpz_clear (remainder);\n  mpz_clear (quotient2);\n  mpz_clear (remainder2);\n  mpz_clear (temp);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 102,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "dump_abort": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "void\ndump_abort (mpz_t dividend, mpz_t divisor)\n{\n  fprintf (stderr, \"ERROR\\n\");\n  fprintf (stderr, \"dividend = \"); debug_mp (dividend, -16);\n  fprintf (stderr, \"divisor  = \"); debug_mp (divisor, -16);\n  abort();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "debug_mp": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-fdiv_ui.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t dividend;\n  mpz_t quotient, remainder;\n  mpz_t quotient2, remainder2;\n  mpz_t temp;\n  mp_size_t dividend_size;\n  unsigned long divisor;\n  int i;\n  int reps = 10000;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n  unsigned long r_rq, r_q, r_r, r;\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  mpz_init (dividend);\n  mpz_init (quotient);\n  mpz_init (remainder);\n  mpz_init (quotient2);\n  mpz_init (remainder2);\n  mpz_init (temp);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 10 + 2; /* 0..2047 bit operands */\n\n      do\n\t{\n\t  mpz_rrandomb (bs, rands, 64);\n\t  divisor = mpz_get_ui (bs);\n\t}\n      while (divisor == 0);\n\n      mpz_urandomb (bs, rands, size_range);\n      dividend_size = mpz_get_ui (bs);\n      mpz_rrandomb (dividend, rands, dividend_size);\n\n      mpz_urandomb (bs, rands, 2);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (dividend, dividend);\n\n      /* printf (\"%ld\\n\", SIZ (dividend)); */\n\n      r_rq = mpz_fdiv_qr_ui (quotient, remainder, dividend, divisor);\n      r_q = mpz_fdiv_q_ui (quotient2, dividend, divisor);\n      r_r = mpz_fdiv_r_ui (remainder2, dividend, divisor);\n      r = mpz_fdiv_ui (dividend, divisor);\n\n      /* First determine that the quotients and remainders computed\n\t with different functions are equal.  */\n      if (mpz_cmp (quotient, quotient2) != 0)\n\tdump_abort (\"quotients from mpz_fdiv_qr_ui and mpz_fdiv_q_ui differ\",\n\t\t    dividend, divisor);\n      if (mpz_cmp (remainder, remainder2) != 0)\n\tdump_abort (\"remainders from mpz_fdiv_qr_ui and mpz_fdiv_r_ui differ\",\n\t\t    dividend, divisor);\n\n      /* Check if the sign of the quotient is correct.  */\n      if (mpz_cmp_ui (quotient, 0) != 0)\n\tif ((mpz_cmp_ui (quotient, 0) < 0)\n\t    != (mpz_cmp_ui (dividend, 0) < 0))\n\tdump_abort (\"quotient sign wrong\", dividend, divisor);\n\n      /* Check if the remainder has the same sign as the (positive) divisor\n\t (quotient rounded towards minus infinity).  */\n      if (mpz_cmp_ui (remainder, 0) != 0)\n\tif (mpz_cmp_ui (remainder, 0) < 0)\n\t  dump_abort (\"remainder sign wrong\", dividend, divisor);\n\n      mpz_mul_ui (temp, quotient, divisor);\n      mpz_add (temp, temp, remainder);\n      if (mpz_cmp (temp, dividend) != 0)\n\tdump_abort (\"n mod d != n - [n/d]*d\", dividend, divisor);\n\n      mpz_abs (remainder, remainder);\n      if (mpz_cmp_ui (remainder, divisor) >= 0)\n\tdump_abort (\"remainder greater than divisor\", dividend, divisor);\n\n      if (mpz_cmp_ui (remainder, r_rq) != 0)\n\tdump_abort (\"remainder returned from mpz_fdiv_qr_ui is wrong\",\n\t\t    dividend, divisor);\n      if (mpz_cmp_ui (remainder, r_q) != 0)\n\tdump_abort (\"remainder returned from mpz_fdiv_q_ui is wrong\",\n\t\t    dividend, divisor);\n      if (mpz_cmp_ui (remainder, r_r) != 0)\n\tdump_abort (\"remainder returned from mpz_fdiv_r_ui is wrong\",\n\t\t    dividend, divisor);\n      if (mpz_cmp_ui (remainder, r) != 0)\n\tdump_abort (\"remainder returned from mpz_fdiv_ui is wrong\",\n\t\t    dividend, divisor);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (dividend);\n  mpz_clear (quotient);\n  mpz_clear (remainder);\n  mpz_clear (quotient2);\n  mpz_clear (remainder2);\n  mpz_clear (temp);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 114,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "dump_abort": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\ndump_abort (const char *str, mpz_t dividend, unsigned long divisor)\n{\n  fprintf (stderr, \"ERROR: %s\\n\", str);\n  fprintf (stderr, \"dividend = \"); debug_mp (dividend, -16);\n  fprintf (stderr, \"divisor  = %lX\\n\", divisor);\n  abort();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "debug_mp": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-fib_ui.c": {
    "check_fib_table": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\ncheck_fib_table (void)\n{\n  int        i;\n  mp_limb_t  want;\n\n  ASSERT_ALWAYS (FIB_TABLE(-1) == 1);\n  ASSERT_ALWAYS (FIB_TABLE(0) == 0);\n\n  for (i = 1; i <= FIB_TABLE_LIMIT; i++)\n    {\n      want = FIB_TABLE(i-1) + FIB_TABLE(i-2);\n      if (FIB_TABLE(i) != want)\n        {\n          printf (\"FIB_TABLE(%d) wrong\\n\", i);\n          gmp_printf (\"  got  %#Nx\\n\", &FIB_TABLE(i), 1);\n          gmp_printf (\"  want %#Nx\\n\", &want, 1);\n          abort ();\n        }\n    }\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  unsigned long  n;\n  unsigned long  limit = 100 * GMP_LIMB_BITS;\n  mpz_t          want_fn, want_fn1, got_fn, got_fn1;\n\n  tests_start ();\n  mp_trace_base = -16;\n  if (argc > 1 && argv[1][0] == 'x')\n    limit = ULONG_MAX;\n  else if (argc > 1)\n    limit = atoi (argv[1]);\n\n  check_fib_table ();\n\n  /* start at n==0 */\n  mpz_init_set_ui (want_fn1, 1);  /* F[-1] */\n  mpz_init_set_ui (want_fn,  0);  /* F[0]   */\n  mpz_init (got_fn);\n  mpz_init (got_fn1);\n\n  for (n = 0; n < limit; n++)\n    {\n      /* check our float formula seems right */\n      if (MPZ_FIB_SIZE_FLOAT (n) < SIZ(want_fn))\n        {\n          printf (\"MPZ_FIB_SIZE_FLOAT wrong at n=%lu\\n\", n);\n          printf (\"  MPZ_FIB_SIZE_FLOAT  %ld\\n\", MPZ_FIB_SIZE_FLOAT (n));\n          printf (\"  SIZ(want_fn)        %d\\n\", SIZ(want_fn));\n          abort ();\n        }\n\n      /* check MPN_FIB2_SIZE seems right, compared to actual size and\n         compared to our float formula */\n      if (MPN_FIB2_SIZE (n) < MPZ_FIB_SIZE_FLOAT (n))\n        {\n          printf (\"MPN_FIB2_SIZE wrong at n=%lu\\n\", n);\n          printf (\"  MPN_FIB2_SIZE       %ld\\n\", MPN_FIB2_SIZE (n));\n          printf (\"  MPZ_FIB_SIZE_FLOAT  %ld\\n\", MPZ_FIB_SIZE_FLOAT (n));\n          abort ();\n        }\n      if (MPN_FIB2_SIZE (n) < SIZ(want_fn))\n        {\n          printf (\"MPN_FIB2_SIZE wrong at n=%lu\\n\", n);\n          printf (\"  MPN_FIB2_SIZE  %ld\\n\", MPN_FIB2_SIZE (n));\n          printf (\"  SIZ(want_fn)   %d\\n\", SIZ(want_fn));\n          abort ();\n        }\n\n      mpz_fib2_ui (got_fn, got_fn1, n);\n      MPZ_CHECK_FORMAT (got_fn);\n      MPZ_CHECK_FORMAT (got_fn1);\n      if (mpz_cmp (got_fn, want_fn) != 0 || mpz_cmp (got_fn1, want_fn1) != 0)\n        {\n          printf (\"mpz_fib2_ui(%lu) wrong\\n\", n);\n          mpz_trace (\"want fn \", want_fn);\n          mpz_trace (\"got  fn \",  got_fn);\n          mpz_trace (\"want fn1\", want_fn1);\n          mpz_trace (\"got  fn1\",  got_fn1);\n          abort ();\n        }\n\n      mpz_fib_ui (got_fn, n);\n      MPZ_CHECK_FORMAT (got_fn);\n      if (mpz_cmp (got_fn, want_fn) != 0)\n        {\n          printf (\"mpz_fib_ui(%lu) wrong\\n\", n);\n          mpz_trace (\"want fn\", want_fn);\n          mpz_trace (\"got  fn\", got_fn);\n          abort ();\n        }\n\n      mpz_add (want_fn1, want_fn1, want_fn);  /* F[n+1] = F[n] + F[n-1] */\n      mpz_swap (want_fn1, want_fn);\n    }\n\n  mpz_clear (want_fn);\n  mpz_clear (want_fn1);\n  mpz_clear (got_fn);\n  mpz_clear (got_fn1);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 85,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-fits.c": {
    "main": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "int\nmain (void)\n{\n  mpz_t       z;\n  int         got;\n  const char  *expr;\n  int         error = 0;\n\n  tests_start ();\n  mpz_init (z);\n\n  mpz_set_ui (z, 0L);\n  expr = \"0\";\n  EXPECT (mpz_fits_ulong_p, 1);\n  EXPECT (mpz_fits_uint_p, 1);\n  EXPECT (mpz_fits_ushort_p, 1);\n  EXPECT (mpz_fits_slong_p, 1);\n  EXPECT (mpz_fits_sint_p, 1);\n  EXPECT (mpz_fits_sshort_p, 1);\n\n  mpz_set_ui (z, 1L);\n  expr = \"1\";\n  EXPECT (mpz_fits_ulong_p, 1);\n  EXPECT (mpz_fits_uint_p, 1);\n  EXPECT (mpz_fits_ushort_p, 1);\n  EXPECT (mpz_fits_slong_p, 1);\n  EXPECT (mpz_fits_sint_p, 1);\n  EXPECT (mpz_fits_sshort_p, 1);\n\n  mpz_set_si (z, -1L);\n  expr = \"-1\";\n  EXPECT (mpz_fits_ulong_p, 0);\n  EXPECT (mpz_fits_uint_p, 0);\n  EXPECT (mpz_fits_ushort_p, 0);\n  EXPECT (mpz_fits_slong_p, 1);\n  EXPECT (mpz_fits_sint_p, 1);\n  EXPECT (mpz_fits_sshort_p, 1);\n\n  mpz_set_ui (z, 1L);\n  mpz_mul_2exp (z, z, 5L*GMP_LIMB_BITS);\n  expr = \"2^(5*BPML)\";\n  EXPECT (mpz_fits_ulong_p, 0);\n  EXPECT (mpz_fits_uint_p, 0);\n  EXPECT (mpz_fits_ushort_p, 0);\n  EXPECT (mpz_fits_slong_p, 0);\n  EXPECT (mpz_fits_sint_p, 0);\n  EXPECT (mpz_fits_sshort_p, 0);\n\n\n  mpz_set_ui (z, (unsigned long) USHRT_MAX);\n  expr = \"USHRT_MAX\";\n  EXPECT (mpz_fits_ulong_p, 1);\n  EXPECT (mpz_fits_uint_p, 1);\n  EXPECT (mpz_fits_ushort_p, 1);\n\n  mpz_set_ui (z, (unsigned long) USHRT_MAX);\n  mpz_add_ui (z, z, 1L);\n  expr = \"USHRT_MAX + 1\";\n  EXPECT (mpz_fits_ushort_p, 0);\n\n\n  mpz_set_ui (z, (unsigned long) UINT_MAX);\n  expr = \"UINT_MAX\";\n  EXPECT (mpz_fits_ulong_p, 1);\n  EXPECT (mpz_fits_uint_p, 1);\n\n  mpz_set_ui (z, (unsigned long) UINT_MAX);\n  mpz_add_ui (z, z, 1L);\n  expr = \"UINT_MAX + 1\";\n  EXPECT (mpz_fits_uint_p, 0);\n\n\n  mpz_set_ui (z, ULONG_MAX);\n  expr = \"ULONG_MAX\";\n  EXPECT (mpz_fits_ulong_p, 1);\n\n  mpz_set_ui (z, ULONG_MAX);\n  mpz_add_ui (z, z, 1L);\n  expr = \"ULONG_MAX + 1\";\n  EXPECT (mpz_fits_ulong_p, 0);\n\n\n  mpz_set_si (z, (long) SHRT_MAX);\n  expr = \"SHRT_MAX\";\n  EXPECT (mpz_fits_slong_p, 1);\n  EXPECT (mpz_fits_sint_p, 1);\n  EXPECT (mpz_fits_sshort_p, 1);\n\n  mpz_set_si (z, (long) SHRT_MAX);\n  mpz_add_ui (z, z, 1L);\n  expr = \"SHRT_MAX + 1\";\n  EXPECT (mpz_fits_sshort_p, 0);\n\n\n  mpz_set_si (z, (long) INT_MAX);\n  expr = \"INT_MAX\";\n  EXPECT (mpz_fits_slong_p, 1);\n  EXPECT (mpz_fits_sint_p, 1);\n\n  mpz_set_si (z, (long) INT_MAX);\n  mpz_add_ui (z, z, 1L);\n  expr = \"INT_MAX + 1\";\n  EXPECT (mpz_fits_sint_p, 0);\n\n\n  mpz_set_si (z, LONG_MAX);\n  expr = \"LONG_MAX\";\n  EXPECT (mpz_fits_slong_p, 1);\n\n  mpz_set_si (z, LONG_MAX);\n  mpz_add_ui (z, z, 1L);\n  expr = \"LONG_MAX + 1\";\n  EXPECT (mpz_fits_slong_p, 0);\n\n\n  mpz_set_si (z, (long) SHRT_MIN);\n  expr = \"SHRT_MIN\";\n  EXPECT (mpz_fits_slong_p, 1);\n  EXPECT (mpz_fits_sint_p, 1);\n  EXPECT (mpz_fits_sshort_p, 1);\n\n  mpz_set_si (z, (long) SHRT_MIN);\n  mpz_sub_ui (z, z, 1L);\n  expr = \"SHRT_MIN + 1\";\n  EXPECT (mpz_fits_sshort_p, 0);\n\n\n  mpz_set_si (z, (long) INT_MIN);\n  expr = \"INT_MIN\";\n  EXPECT (mpz_fits_slong_p, 1);\n  EXPECT (mpz_fits_sint_p, 1);\n\n  mpz_set_si (z, (long) INT_MIN);\n  mpz_sub_ui (z, z, 1L);\n  expr = \"INT_MIN + 1\";\n  EXPECT (mpz_fits_sint_p, 0);\n\n\n  mpz_set_si (z, LONG_MIN);\n  expr = \"LONG_MIN\";\n  EXPECT (mpz_fits_slong_p, 1);\n\n  mpz_set_si (z, LONG_MIN);\n  mpz_sub_ui (z, z, 1L);\n  expr = \"LONG_MIN + 1\";\n  EXPECT (mpz_fits_slong_p, 0);\n\n\n  if (error)\n    abort ();\n\n  mpz_clear (z);\n  tests_end ();\n  exit (0);\n}",
      "lines": 155,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-gcd.c": {
    "check_data": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char *a;\n    const char *b;\n    const char *want;\n  } data[] = {\n    /* This tickled a bug in gmp 4.1.2 mpn/x86/k6/gcd_finda.asm. */\n    { \"0x3FFC000007FFFFFFFFFF00000000003F83FFFFFFFFFFFFFFF80000000000000001\",\n      \"0x1FFE0007FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC000000000000000000000001\",\n      \"5\" }\n  };\n\n  mpz_t  a, b, got, want;\n  int    i;\n\n  mpz_inits (a, b, got, want, NULL);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (a, data[i].a, 0);\n      mpz_set_str_or_abort (b, data[i].b, 0);\n      mpz_set_str_or_abort (want, data[i].want, 0);\n      mpz_gcd (got, a, b);\n      MPZ_CHECK_FORMAT (got);\n      if (mpz_cmp (got, want) != 0)\n\t{\n\t  printf    (\"mpz_gcd wrong on data[%d]\\n\", i);\n\t  printf    (\" a  %s\\n\", data[i].a);\n\t  printf    (\" b  %s\\n\", data[i].b);\n\t  mpz_trace (\" a\", a);\n\t  mpz_trace (\" b\", b);\n\t  mpz_trace (\" want\", want);\n\t  mpz_trace (\" got \", got);\n\t  abort ();\n\t}\n    }\n\n  mpz_clears (a, b, got, want, NULL);\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "make_chain_operands": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\nmake_chain_operands (mpz_t ref, mpz_t a, mpz_t b, gmp_randstate_t rs, int nb1, int nb2, int chain_len)\n{\n  mpz_t bs, temp1, temp2;\n  int j;\n\n  mpz_inits (bs, temp1, temp2, NULL);\n\n  /* Generate a division chain backwards, allowing otherwise unlikely huge\n     quotients.  */\n\n  mpz_set_ui (a, 0);\n  mpz_urandomb (bs, rs, 32);\n  mpz_urandomb (bs, rs, mpz_get_ui (bs) % nb1 + 1);\n  mpz_rrandomb (b, rs, mpz_get_ui (bs));\n  mpz_add_ui (b, b, 1);\n  mpz_set (ref, b);\n\n  for (j = 0; j < chain_len; j++)\n    {\n      mpz_urandomb (bs, rs, 32);\n      mpz_urandomb (bs, rs, mpz_get_ui (bs) % nb2 + 1);\n      mpz_rrandomb (temp2, rs, mpz_get_ui (bs) + 1);\n      mpz_add_ui (temp2, temp2, 1);\n      mpz_mul (temp1, b, temp2);\n      mpz_add (a, a, temp1);\n\n      mpz_urandomb (bs, rs, 32);\n      mpz_urandomb (bs, rs, mpz_get_ui (bs) % nb2 + 1);\n      mpz_rrandomb (temp2, rs, mpz_get_ui (bs) + 1);\n      mpz_add_ui (temp2, temp2, 1);\n      mpz_mul (temp1, a, temp2);\n      mpz_add (b, b, temp1);\n    }\n\n  mpz_clears (bs, temp1, temp2, NULL);\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_kolmo1": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void\ncheck_kolmo1 (void)\n{\n  static const struct {\n    unsigned int seed;\n    int nb;\n    const char *want;\n  } data[] = {\n    { 59618, 38208, \"5\"},\n    { 76521, 49024, \"3\"},\n    { 85869, 54976, \"1\"},\n    { 99449, 63680, \"1\"},\n    {112453, 72000, \"1\"}\n  };\n\n  gmp_randstate_t rs;\n  mpz_t  bs, a, b, want;\n  int    i, unb, vnb, nb;\n\n  gmp_randinit_default (rs);\n\n  mpz_inits (bs, a, b, want, NULL);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      nb = data[i].nb;\n\n      gmp_randseed_ui (rs, data[i].seed);\n\n      mpz_urandomb (bs, rs, 32);\n      unb = mpz_get_ui (bs) % nb;\n      mpz_urandomb (bs, rs, 32);\n      vnb = mpz_get_ui (bs) % nb;\n\n      mpz_rrandomb (a, rs, unb);\n      mpz_rrandomb (b, rs, vnb);\n\n      mpz_set_str_or_abort (want, data[i].want, 0);\n\n      one_test (a, b, want, -1);\n    }\n\n  mpz_clears (bs, a, b, want, NULL);\n  gmp_randclear (rs);\n}",
      "lines": 45,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_kolmo2": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "void\ncheck_kolmo2 (void)\n{\n  static const struct {\n    unsigned int seed;\n    int nb, chain_len;\n  } data[] = {\n    {  917, 15, 5 },\n    { 1032, 18, 6 },\n    { 1167, 18, 6 },\n    { 1174, 18, 6 },\n    { 1192, 18, 6 },\n  };\n\n  gmp_randstate_t rs;\n  mpz_t  bs, a, b, want;\n  int    i;\n\n  gmp_randinit_default (rs);\n\n  mpz_inits (bs, a, b, want, NULL);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      gmp_randseed_ui (rs, data[i].seed);\n      make_chain_operands (want, a, b, rs, data[i].nb, data[i].nb, data[i].chain_len);\n      one_test (a, b, want, -1);\n    }\n\n  mpz_clears (bs, a, b, want, NULL);\n  gmp_randclear (rs);\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t op1, op2, ref;\n  int i, chain_len;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n  long int reps = 200;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  rands = RANDS;\n\n  mpz_inits (bs, op1, op2, ref, gcd1, gcd2, temp1, temp2, temp3, s, NULL);\n\n  check_data ();\n  check_kolmo1 ();\n  check_kolmo2 ();\n\n  /* Testcase to exercise the u0 == u1 case in mpn_gcdext_lehmer_n. */\n  mpz_set_ui (op2, GMP_NUMB_MAX); /* FIXME: Huge limb doesn't always fit */\n  mpz_mul_2exp (op1, op2, 100);\n  mpz_add (op1, op1, op2);\n  mpz_mul_ui (op2, op2, 2);\n  one_test (op1, op2, NULL, -1);\n\n  for (i = 0; i < reps; i++)\n    {\n      /* Generate plain operands with unknown gcd.  These types of operands\n\t have proven to trigger certain bugs in development versions of the\n\t gcd code.  The \"hgcd->row[3].rsize > M\" ASSERT is not triggered by\n\t the division chain code below, but that is most likely just a result\n\t of that other ASSERTs are triggered before it.  */\n\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 17 + 2;\n\n      mpz_urandomb (bs, rands, size_range);\n      mpz_rrandomb (op1, rands, mpz_get_ui (bs) + MIN_OPERAND_BITSIZE);\n      mpz_urandomb (bs, rands, size_range);\n      mpz_rrandomb (op2, rands, mpz_get_ui (bs) + MIN_OPERAND_BITSIZE);\n\n      mpz_urandomb (bs, rands, 8);\n      bsi = mpz_get_ui (bs);\n\n      if ((bsi & 0x3c) == 4)\n\tmpz_mul (op1, op1, op2);\t/* make op1 a multiple of op2 */\n      else if ((bsi & 0x3c) == 8)\n\tmpz_mul (op2, op1, op2);\t/* make op2 a multiple of op1 */\n\n      if ((bsi & 1) != 0)\n\tmpz_neg (op1, op1);\n      if ((bsi & 2) != 0)\n\tmpz_neg (op2, op2);\n\n      one_test (op1, op2, NULL, i);\n\n      /* Generate a division chain backwards, allowing otherwise unlikely huge\n\t quotients.  */\n\n      mpz_urandomb (bs, rands, 32);\n      chain_len = mpz_get_ui (bs) % LOG2C (GMP_NUMB_BITS * MAX_SCHOENHAGE_THRESHOLD);\n      mpz_urandomb (bs, rands, 32);\n      chain_len = mpz_get_ui (bs) % (1 << chain_len) / 32;\n\n      make_chain_operands (ref, op1, op2, rands, 16, 12, chain_len);\n\n      one_test (op1, op2, ref, i);\n    }\n\n  mpz_clears (bs, op1, op2, ref, gcd1, gcd2, temp1, temp2, temp3, s, NULL);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 77,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "debug_mp": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "one_test": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "void\none_test (mpz_t op1, mpz_t op2, mpz_t ref, int i)\n{\n  /*\n  printf (\"%d %d %d\\n\", SIZ (op1), SIZ (op2), ref != NULL ? SIZ (ref) : 0);\n  fflush (stdout);\n  */\n\n  /*\n  fprintf (stderr, \"op1=\");  debug_mp (op1, -16);\n  fprintf (stderr, \"op2=\");  debug_mp (op2, -16);\n  */\n\n  mpz_gcdext (gcd1, s, NULL, op1, op2);\n  MPZ_CHECK_FORMAT (gcd1);\n  MPZ_CHECK_FORMAT (s);\n\n  if (ref && mpz_cmp (ref, gcd1) != 0)\n    {\n      fprintf (stderr, \"ERROR in test %d\\n\", i);\n      fprintf (stderr, \"mpz_gcdext returned incorrect result\\n\");\n      fprintf (stderr, \"op1=\");                 debug_mp (op1, -16);\n      fprintf (stderr, \"op2=\");                 debug_mp (op2, -16);\n      fprintf (stderr, \"expected result:\\n\");   debug_mp (ref, -16);\n      fprintf (stderr, \"mpz_gcdext returns:\\n\");debug_mp (gcd1, -16);\n      abort ();\n    }\n\n  if (!gcdext_valid_p(op1, op2, gcd1, s))\n    {\n      fprintf (stderr, \"ERROR in test %d\\n\", i);\n      fprintf (stderr, \"mpz_gcdext returned invalid result\\n\");\n      fprintf (stderr, \"op1=\");                 debug_mp (op1, -16);\n      fprintf (stderr, \"op2=\");                 debug_mp (op2, -16);\n      fprintf (stderr, \"mpz_gcdext returns:\\n\");debug_mp (gcd1, -16);\n      fprintf (stderr, \"s=\");                   debug_mp (s, -16);\n      abort ();\n    }\n\n  mpz_gcd (gcd2, op1, op2);\n  MPZ_CHECK_FORMAT (gcd2);\n\n  if (mpz_cmp (gcd2, gcd1) != 0)\n    {\n      fprintf (stderr, \"ERROR in test %d\\n\", i);\n      fprintf (stderr, \"mpz_gcd returned incorrect result\\n\");\n      fprintf (stderr, \"op1=\");                 debug_mp (op1, -16);\n      fprintf (stderr, \"op2=\");                 debug_mp (op2, -16);\n      fprintf (stderr, \"expected result:\\n\");   debug_mp (gcd1, -16);\n      fprintf (stderr, \"mpz_gcd returns:\\n\");   debug_mp (gcd2, -16);\n      abort ();\n    }\n\n  /* This should probably move to t-gcd_ui.c */\n  if (mpz_fits_ulong_p (op1) || mpz_fits_ulong_p (op2))\n    {\n      if (mpz_fits_ulong_p (op1))\n\tmpz_gcd_ui (gcd2, op2, mpz_get_ui (op1));\n      else\n\tmpz_gcd_ui (gcd2, op1, mpz_get_ui (op2));\n      if (mpz_cmp (gcd2, gcd1))\n\t{\n\t  fprintf (stderr, \"ERROR in test %d\\n\", i);\n\t  fprintf (stderr, \"mpz_gcd_ui returned incorrect result\\n\");\n\t  fprintf (stderr, \"op1=\");                 debug_mp (op1, -16);\n\t  fprintf (stderr, \"op2=\");                 debug_mp (op2, -16);\n\t  fprintf (stderr, \"expected result:\\n\");   debug_mp (gcd1, -16);\n\t  fprintf (stderr, \"mpz_gcd_ui returns:\\n\");   debug_mp (gcd2, -16);\n\t  abort ();\n\t}\n    }\n\n  mpz_gcdext (gcd2, temp1, temp2, op1, op2);\n  MPZ_CHECK_FORMAT (gcd2);\n  MPZ_CHECK_FORMAT (temp1);\n  MPZ_CHECK_FORMAT (temp2);\n\n  mpz_mul (temp1, temp1, op1);\n  mpz_mul (temp2, temp2, op2);\n  mpz_add (temp1, temp1, temp2);\n\n  if (mpz_cmp (gcd1, gcd2) != 0\n      || mpz_cmp (gcd2, temp1) != 0)\n    {\n      fprintf (stderr, \"ERROR in test %d\\n\", i);\n      fprintf (stderr, \"mpz_gcdext returned incorrect result\\n\");\n      fprintf (stderr, \"op1=\");                 debug_mp (op1, -16);\n      fprintf (stderr, \"op2=\");                 debug_mp (op2, -16);\n      fprintf (stderr, \"expected result:\\n\");   debug_mp (gcd1, -16);\n      fprintf (stderr, \"mpz_gcdext returns:\\n\");debug_mp (gcd2, -16);\n      abort ();\n    }\n}",
      "lines": 93,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "gcdext_valid_p": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "static int\ngcdext_valid_p (const mpz_t a, const mpz_t b, const mpz_t g, const mpz_t s)\n{\n  /* It's not clear that gcd(0,0) is well defined, but we allow it and require that\n     gcd(0,0) = 0. */\n  if (mpz_sgn (g) < 0)\n    return 0;\n\n  if (mpz_sgn (a) == 0)\n    {\n      /* Must have g == abs (b). Any value for s is in some sense \"correct\",\n\t but it makes sense to require that s == 0. */\n      return mpz_cmpabs (g, b) == 0 && mpz_sgn (s) == 0;\n    }\n  else if (mpz_sgn (b) == 0)\n    {\n      /* Must have g == abs (a), s == sign (a) */\n      return mpz_cmpabs (g, a) == 0 && mpz_cmp_si (s, mpz_sgn (a)) == 0;\n    }\n\n  if (mpz_sgn (g) <= 0)\n    return 0;\n\n  mpz_tdiv_qr (temp1, temp3, a, g);\n  if (mpz_sgn (temp3) != 0)\n    return 0;\n\n  mpz_tdiv_qr (temp2, temp3, b, g);\n  if (mpz_sgn (temp3) != 0)\n    return 0;\n\n  /* Require that 2 |s| < |b/g|, or |s| == 1. */\n  if (mpz_cmpabs_ui (s, 1) > 0)\n    {\n      mpz_mul_2exp (temp3, s, 1);\n      if (mpz_cmpabs (temp3, temp2) >= 0)\n\treturn 0;\n    }\n\n  /* Compute the other cofactor. */\n  mpz_mul(temp2, s, a);\n  mpz_sub(temp2, g, temp2);\n  mpz_tdiv_qr(temp2, temp3, temp2, b);\n\n  if (mpz_sgn (temp3) != 0)\n    return 0;\n\n  /* Require that 2 |t| < |a/g| or |t| == 1*/\n  if (mpz_cmpabs_ui (temp2, 1) > 0)\n    {\n      mpz_mul_2exp (temp2, temp2, 1);\n      if (mpz_cmpabs (temp2, temp1) >= 0)\n\treturn 0;\n    }\n  return 1;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-gcd_ui.c": {
    "check_ui_range": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static void\ncheck_ui_range (void)\n{\n  unsigned long  got;\n  mpz_t  x;\n  int  i;\n\n  mpz_init_set_ui (x, ULONG_MAX);\n\n  for (i = 0; i < 20; i++)\n    {\n      mpz_mul_2exp (x, x, 1L);\n      got = mpz_gcd_ui (NULL, x, 0L);\n      if (got != 0)\n        {\n          printf (\"mpz_gcd_ui (ULONG_MAX*2^%d, 0)\\n\", i);\n          printf (\"   return %#lx\\n\", got);\n          printf (\"   should be 0\\n\");\n          abort ();\n        }\n    }\n\n  mpz_clear (x);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_ui_range ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-get_d.c": {
    "check_onebit": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\ncheck_onebit (void)\n{\n  int     i;\n  mpz_t   z;\n  double  got, want;\n  /* FIXME: It'd be better to base this on the float format. */\n#if defined (__vax) || defined (__vax__)\n  int     limit = 127 - 1;  /* vax fp numbers have limited range */\n#else\n  int     limit = 512;\n#endif\n\n  mpz_init (z);\n\n  mpz_set_ui (z, 1L);\n  want = 1.0;\n\n  for (i = 0; i < limit; i++)\n    {\n      got = mpz_get_d (z);\n\n      if (got != want)\n        {\n          printf    (\"mpz_get_d wrong on 2**%d\\n\", i);\n          mpz_trace (\"   z    \", z);\n          printf    (\"   want  %.20g\\n\", want);\n          printf    (\"   got   %.20g\\n\", got);\n          abort();\n        }\n\n      mpz_mul_2exp (z, z, 1L);\n      want *= 2.0;\n    }\n  mpz_clear (z);\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_onebit ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-get_d_2exp.c": {
    "check_zero": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static void\ncheck_zero (void)\n{\n  mpz_t   z;\n  double  got, want;\n  long    got_exp, want_exp;\n\n  mpz_init_set_ui (z, 0);\n\n  want = 0.0;\n  want_exp = 0;\n  got = mpz_get_d_2exp (&got_exp, z);\n  if (got != want || got_exp != want_exp)\n    {\n      printf    (\"mpz_get_d_2exp wrong on zero\\n\");\n      mpz_trace (\"   z    \", z);\n      d_trace   (\"   want \", want);\n      d_trace   (\"   got  \", got);\n      printf    (\"   want exp %ld\\n\", want_exp);\n      printf    (\"   got exp  %ld\\n\", got_exp);\n      abort();\n    }\n\n  mpz_clear (z);\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_onebit": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static void\ncheck_onebit (void)\n{\n  static const unsigned long data[] = {\n    1, 32, 52, 53, 54, 63, 64, 65, 128, 256, 511, 512, 513\n  };\n  mpz_t   z;\n  double  got, want;\n  long    got_exp, want_exp;\n  int     i;\n\n  mpz_init (z);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_ui (z, 1L);\n      mpz_mul_2exp (z, z, data[i]);\n      want = 0.5;\n      want_exp = data[i] + 1;\n      got = mpz_get_d_2exp (&got_exp, z);\n      if (got != want || got_exp != want_exp)\n        {\n          printf    (\"mpz_get_d_2exp wrong on 2**%ld\\n\", data[i]);\n          mpz_trace (\"   z    \", z);\n          d_trace   (\"   want \", want);\n          d_trace   (\"   got  \", got);\n          printf    (\"   want exp %ld\\n\", want_exp);\n          printf    (\"   got exp  %ld\\n\", got_exp);\n          abort();\n        }\n\n      mpz_set_si (z, -1L);\n      mpz_mul_2exp (z, z, data[i]);\n      want = -0.5;\n      want_exp = data[i] + 1;\n      got = mpz_get_d_2exp (&got_exp, z);\n      if (got != want || got_exp != want_exp)\n        {\n          printf    (\"mpz_get_d_2exp wrong on -2**%ld\\n\", data[i]);\n          mpz_trace (\"   z    \", z);\n          d_trace   (\"   want \", want);\n          d_trace   (\"   got  \", got);\n          printf    (\"   want exp %ld\\n\", want_exp);\n          printf    (\"   got exp  %ld\\n\", got_exp);\n          abort();\n        }\n    }\n  mpz_clear (z);\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_round": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static void\ncheck_round (void)\n{\n  static const unsigned long data[] = { 1, 32, 53, 54, 64, 128, 256, 512 };\n  mpz_t   z;\n  double  got;\n  long    got_exp;\n  int     i, rnd_mode, old_rnd_mode;\n\n  mpz_init (z);\n  old_rnd_mode = tests_hardware_getround ();\n\n  for (rnd_mode = 0; rnd_mode < 4; rnd_mode++)\n    {\n      tests_hardware_setround (rnd_mode);\n\n      for (i = 0; i < numberof (data); i++)\n        {\n          mpz_set_ui (z, 1L);\n          mpz_mul_2exp (z, z, data[i]);\n          mpz_sub_ui (z, z, 1L);\n\n          got = mpz_get_d_2exp (&got_exp, z);\n          if (got < 0.5 || got >= 1.0)\n            {\n              printf    (\"mpz_get_d_2exp wrong on 2**%lu-1\\n\", data[i]);\n              printf    (\"result out of range, expect 0.5 <= got < 1.0\\n\");\n              printf    (\"   rnd_mode = %d\\n\", rnd_mode);\n              printf    (\"   data[i]  = %lu\\n\", data[i]);\n              mpz_trace (\"   z    \", z);\n              d_trace   (\"   got  \", got);\n              printf    (\"   got exp  %ld\\n\", got_exp);\n              abort();\n            }\n\n          mpz_neg (z, z);\n          got = mpz_get_d_2exp (&got_exp, z);\n          if (got <= -1.0 || got > -0.5)\n            {\n              printf    (\"mpz_get_d_2exp wrong on -2**%lu-1\\n\", data[i]);\n              printf    (\"result out of range, expect -1.0 < got <= -0.5\\n\");\n              printf    (\"   rnd_mode = %d\\n\", rnd_mode);\n              printf    (\"   data[i]  = %lu\\n\", data[i]);\n              mpz_trace (\"   z    \", z);\n              d_trace   (\"   got  \", got);\n              printf    (\"   got exp  %ld\\n\", got_exp);\n              abort();\n            }\n        }\n    }\n\n  mpz_clear (z);\n  tests_hardware_setround (old_rnd_mode);\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_rand": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static void\ncheck_rand (void)\n{\n  gmp_randstate_ptr rands = RANDS;\n  int     i;\n  mpz_t   z;\n  double  got;\n  long    got_exp;\n  unsigned long  bits;\n\n  mpz_init (z);\n\n  for (i = 0; i < 200; i++)\n    {\n      bits = gmp_urandomm_ui (rands, 512L);\n      mpz_urandomb (z, rands, bits);\n\n      got = mpz_get_d_2exp (&got_exp, z);\n      if (mpz_sgn (z) == 0)\n        continue;\n      bits = mpz_sizeinbase (z, 2);\n\n      if (got < 0.5 || got >= 1.0)\n        {\n          printf    (\"mpz_get_d_2exp out of range, expect 0.5 <= got < 1.0\\n\");\n          mpz_trace (\"   z    \", z);\n          d_trace   (\"   got  \", got);\n          printf    (\"   got exp  %ld\\n\", got_exp);\n          abort();\n        }\n\n      /* FIXME: If mpz_get_d_2exp rounds upwards we might have got_exp ==\n         bits+1, so leave this test disabled until we decide if that's what\n         should happen, or not.  */\n#if 0\n      if (got_exp != bits)\n        {\n          printf    (\"mpz_get_d_2exp wrong exponent\\n\", i);\n          mpz_trace (\"   z    \", z);\n          d_trace   (\"   bits \", bits);\n          d_trace   (\"   got  \", got);\n          printf    (\"   got exp  %ld\\n\", got_exp);\n          abort();\n        }\n#endif\n    }\n  mpz_clear (z);\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_zero ();\n  check_onebit ();\n  check_round ();\n  check_rand ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-get_si.c": {
    "check_data": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *n;\n    long        want;\n  } data[] = {\n    { \"0\",      0L },\n    { \"1\",      1L },\n    { \"-1\",     -1L },\n    { \"2\",      2L },\n    { \"-2\",     -2L },\n    { \"12345\",  12345L },\n    { \"-12345\", -12345L },\n  };\n\n  int    i;\n  mpz_t  n;\n  long   got;\n\n  mpz_init (n);\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (n, data[i].n, 0);\n\n      got = mpz_get_si (n);\n      if (got != data[i].want)\n\t{\n\t  printf (\"mpz_get_si wrong at data[%d]\\n\", i);\n\t  printf (\"   n     \\\"%s\\\" (\", data[i].n);\n\t  mpz_out_str (stdout, 10, n); printf (\", hex \");\n\t  mpz_out_str (stdout, 16, n); printf (\")\\n\");\n\t  printf (\"   got   %ld (0x%lX)\\n\", got, got);\n\t  printf (\"   want  %ld (0x%lX)\\n\", data[i].want, data[i].want);\n\t  abort();\n\t}\n    }\n  mpz_clear (n);\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_max": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "void\ncheck_max (void)\n{\n  mpz_t  n;\n  long   want;\n  long   got;\n\n  mpz_init (n);\n\n#define CHECK_MAX(name)                                 \\\n  if (got != want)                                      \\\n    {                                                   \\\n      printf (\"mpz_get_si wrong on %s\\n\", name);        \\\n      printf (\"   n    \");                              \\\n      mpz_out_str (stdout, 10, n); printf (\", hex \");   \\\n      mpz_out_str (stdout, 16, n); printf (\"\\n\");       \\\n      printf (\"   got  %ld, hex %lX\\n\", got, got);      \\\n      printf (\"   want %ld, hex %lX\\n\", want, want);    \\\n      abort();                                          \\\n    }\n\n  want = LONG_MAX;\n  mpz_set_si (n, want);\n  got = mpz_get_si (n);\n  CHECK_MAX (\"LONG_MAX\");\n\n  want = LONG_MIN;\n  mpz_set_si (n, want);\n  got = mpz_get_si (n);\n  CHECK_MAX (\"LONG_MIN\");\n\n  /* The following checks that -0x100000000 gives -0x80000000.  This doesn't\n     actually fit in a long and the result from mpz_get_si() is undefined,\n     but -0x80000000 is what comes out currently, and it should be that\n     value irrespective of the mp_limb_t size (long or long long).  */\n\n  want = LONG_MIN;\n  mpz_mul_2exp (n, n, 1);\n  CHECK_MAX (\"-0x100...00\");\n\n  mpz_clear (n);\n}",
      "lines": 42,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n  check_max ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-hamdist.c": {
    "check_twobits": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\ncheck_twobits (void)\n{\n  unsigned long  i, j, got, want;\n  mpz_t  x, y;\n\n  mpz_init (x);\n  mpz_init (y);\n  for (i = 0; i < 5 * GMP_NUMB_BITS; i++)\n    {\n      for (j = 0; j < 5 * GMP_NUMB_BITS; j++)\n        {\n          mpz_set_ui (x, 0L);\n          mpz_setbit (x, i);\n          mpz_set_ui (y, 0L);\n          mpz_setbit (y, j);\n\n          want = 2 * (i != j);\n          got = mpz_hamdist (x, y);\n          if (got != want)\n            {\n              printf    (\"mpz_hamdist wrong on 2 bits pos/pos\\n\");\n            wrong:\n              printf    (\"  i    %lu\\n\", i);\n              printf    (\"  j    %lu\\n\", j);\n              printf    (\"  got  %lu\\n\", got);\n              printf    (\"  want %lu\\n\", want);\n              mpz_trace (\"  x   \", x);\n              mpz_trace (\"  y   \", y);\n              abort();\n            }\n\n          mpz_neg (x, x);\n          mpz_neg (y, y);\n          want = ABS ((long) (i-j));\n          got = mpz_hamdist (x, y);\n          if (got != want)\n            {\n              printf    (\"mpz_hamdist wrong on 2 bits neg/neg\\n\");\n              goto wrong;\n            }\n        }\n\n    }\n  mpz_clear (x);\n  mpz_clear (y);\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "check_rand": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\ncheck_rand (void)\n{\n  gmp_randstate_ptr  rands = RANDS;\n  unsigned long  got, want;\n  int    i;\n  mpz_t  x, y;\n\n  mpz_init (x);\n  mpz_init (y);\n\n  for (i = 0; i < 2000; i++)\n    {\n      mpz_erandomb (x, rands, 6 * GMP_NUMB_BITS);\n      mpz_negrandom (x, rands);\n      mpz_mul_2exp (x, x, urandom() % (4 * GMP_NUMB_BITS));\n\n      mpz_erandomb (y, rands, 6 * GMP_NUMB_BITS);\n      mpz_negrandom (y, rands);\n      mpz_mul_2exp (y, y, urandom() % (4 * GMP_NUMB_BITS));\n\n      want = refmpz_hamdist (x, y);\n      got = mpz_hamdist (x, y);\n      if (got != want)\n        {\n          printf    (\"mpz_hamdist wrong on random\\n\");\n          printf    (\"  got  %lu\\n\", got);\n          printf    (\"  want %lu\\n\", want);\n          mpz_trace (\"  x   \", x);\n          mpz_trace (\"  y   \", y);\n          abort();\n        }\n    }\n  mpz_clear (x);\n  mpz_clear (y);\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_twobits ();\n  check_rand ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-import.c": {
    "check_data": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *want;\n    size_t      count;\n    int         order;\n    size_t      size;\n    int         endian;\n    int         nail;\n    char        src[64];\n\n  } data[] = {\n\n    { \"0\", 0,1, 1,1, 0 },\n    { \"0\", 1,1, 0,1, 0 },\n\n    { \"0x12345678\", 4,1,  1,1, 0, { '\\22', '\\64', '\\126', '\\170' } },\n    { \"0x12345678\", 1,1,  4,1, 0, { '\\22', '\\64', '\\126', '\\170' } },\n    { \"0x12345678\", 1,-1, 4,1, 0, { '\\22', '\\64', '\\126', '\\170' } },\n\n    { \"0x12345678\", 4,-1, 1,-1, 0, { '\\170', '\\126', '\\064', '\\22' } },\n    { \"0x12345678\", 1,1,  4,-1, 0, { '\\170', '\\126', '\\064', '\\22' } },\n    { \"0x12345678\", 1,-1, 4,-1, 0, { '\\170', '\\126', '\\064', '\\22' } },\n\n    { \"0\",    5,1,  1,1, 7, { '\\376', '\\376', '\\376', '\\376', '\\376' } },\n    { \"0\",    5,-1, 1,1, 7, { '\\376', '\\376', '\\376', '\\376', '\\376' } },\n    { \"0x15\", 5,1,  1,1, 7, { '\\377', '\\376', '\\377', '\\376', '\\377' } },\n\n    { \"0\",    3,1,  2,1,   1, { '\\200','\\000', '\\200','\\000', '\\200','\\000' }},\n    { \"0\",    3,1,  2,-1,  1, { '\\000','\\200', '\\000','\\200', '\\000','\\200' }},\n    { \"0\",    3,1,  2,1,  15, { '\\377','\\376', '\\377','\\376', '\\377','\\376' }},\n\n    { \"0x2A\", 3,1,  2,1, 14, { '\\377','\\376', '\\377','\\376', '\\377','\\376' } },\n    { \"0x06\", 3,1,  2,1, 14, { '\\377','\\374', '\\377','\\375', '\\377','\\376' } },\n    { \"0x24\", 3,-1, 2,1, 14, { '\\377','\\374', '\\377','\\375', '\\377','\\376' } },\n\n    { \"0x123456789ABC\", 3,1,  2,1,  0, {\n        '\\022','\\064', '\\126','\\170', '\\232','\\274' } },\n    { \"0x123456789ABC\", 3,-1, 2,1,  0, {\n        '\\232','\\274', '\\126','\\170', '\\022','\\064' } },\n    { \"0x123456789ABC\", 3,1,  2,-1, 0, {\n        '\\064','\\022', '\\170','\\126', '\\274','\\232' } },\n    { \"0x123456789ABC\", 3,-1, 2,-1, 0, {\n        '\\274','\\232', '\\170','\\126', '\\064','\\022' } },\n\n    { \"0x112233445566778899AABBCC\", 3,1,  4,1,  0,\n      { '\\021','\\042','\\063','\\104',\n        '\\125','\\146','\\167','\\210',\n        '\\231','\\252','\\273','\\314' } },\n    { \"0x112233445566778899AABBCC\", 3,-1, 4,1,  0,\n      { '\\231','\\252','\\273','\\314',\n        '\\125','\\146','\\167','\\210',\n        '\\021','\\042','\\063','\\104' } },\n    { \"0x112233445566778899AABBCC\", 3,1,  4,-1, 0,\n      { '\\104','\\063','\\042','\\021',\n        '\\210','\\167','\\146','\\125',\n        '\\314','\\273','\\252','\\231' } },\n    { \"0x112233445566778899AABBCC\", 3,-1, 4,-1, 0,\n      { '\\314','\\273','\\252','\\231',\n        '\\210','\\167','\\146','\\125',\n        '\\104','\\063','\\042','\\021' } },\n\n    { \"0x100120023003400450056006700780089009A00AB00BC00C\", 3,1,  8,1,  0,\n      { '\\020','\\001','\\040','\\002','\\060','\\003','\\100','\\004',\n        '\\120','\\005','\\140','\\006','\\160','\\007','\\200','\\010',\n        '\\220','\\011','\\240','\\012','\\260','\\013','\\300','\\014' } },\n    { \"0x100120023003400450056006700780089009A00AB00BC00C\", 3,-1, 8,1,  0,\n      { '\\220','\\011','\\240','\\012','\\260','\\013','\\300','\\014',\n        '\\120','\\005','\\140','\\006','\\160','\\007','\\200','\\010',\n        '\\020','\\001','\\040','\\002','\\060','\\003','\\100','\\004' } },\n    { \"0x100120023003400450056006700780089009A00AB00BC00C\", 3,1,  8,-1, 0,\n      { '\\004','\\100','\\003','\\060','\\002','\\040','\\001','\\020',\n        '\\010','\\200','\\007','\\160','\\006','\\140','\\005','\\120',\n        '\\014','\\300','\\013','\\260','\\012','\\240','\\011','\\220' } },\n    { \"0x100120023003400450056006700780089009A00AB00BC00C\", 3,-1, 8,-1, 0,\n      { '\\014','\\300','\\013','\\260','\\012','\\240','\\011','\\220',\n        '\\010','\\200','\\007','\\160','\\006','\\140','\\005','\\120',\n        '\\004','\\100','\\003','\\060','\\002','\\040','\\001','\\020' } },\n\n    { \"0x155555555555555555555555\", 3,1,  4,1,  1,\n      { '\\325','\\125','\\125','\\125',\n        '\\252','\\252','\\252','\\252',\n        '\\325','\\125','\\125','\\125' } },\n    { \"0x155555555555555555555555\", 3,-1,  4,1,  1,\n      { '\\325','\\125','\\125','\\125',\n        '\\252','\\252','\\252','\\252',\n        '\\325','\\125','\\125','\\125' } },\n    { \"0x155555555555555555555555\", 3,1,  4,-1,  1,\n      { '\\125','\\125','\\125','\\325',\n        '\\252','\\252','\\252','\\252',\n        '\\125','\\125','\\125','\\325' } },\n    { \"0x155555555555555555555555\", 3,-1,  4,-1,  1,\n      { '\\125','\\125','\\125','\\325',\n        '\\252','\\252','\\252','\\252',\n        '\\125','\\125','\\125','\\325' } },\n  };\n\n  char    buf[sizeof(data[0].src) + sizeof (mp_limb_t)];\n  char    *src;\n  size_t  align;\n  int     i;\n  mpz_t   got, want;\n\n  mpz_init (got);\n  mpz_init (want);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      for (align = 0; align < sizeof (mp_limb_t); align++)\n        {\n          mpz_set_str_or_abort (want, data[i].want, 0);\n          src = buf + align;\n          memcpy (src, data[i].src, data[i].count * data[i].size);\n\n          mpz_set_ui (got, 0L);\n          mpz_import (got, data[i].count, data[i].order,\n                      data[i].size, data[i].endian, data[i].nail, src);\n\n          MPZ_CHECK_FORMAT (got);\n          if (mpz_cmp (got, want) != 0)\n            {\n              printf (\"wrong at data[%d]\\n\", i);\n              printf (\"    count=%lu order=%d  size=%lu endian=%d nail=%u  align=%lu\\n\",\n                      (unsigned long) data[i].count, data[i].order,\n                      (unsigned long) data[i].size, data[i].endian, data[i].nail,\n                      (unsigned long) align);\n              mpz_trace (\"    got \", got);\n              mpz_trace (\"    want\", want);\n              abort ();\n            }\n        }\n    }\n  mpz_clear (got);\n  mpz_clear (want);\n}",
      "lines": 136,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  mp_trace_base = -16;\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-inp_str.c": {
    "check_data": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *inp;\n    int         base;\n    const char  *want;\n    int         want_nread;\n\n  } data[] = {\n\n    { \"0\",   10, \"0\", 1 },\n\n    { \"abc\", 10, \"0\", 0 },\n    { \"0xf\", 10, \"0\", 1 },\n    { \"ghi\", 16, \"0\", 0 },\n    { \"100\", 90, \"0\", 0 },\n\n    {  \"ff\", 16,  \"255\", 2 },\n    { \"-ff\", 16, \"-255\", 3 },\n    {  \"FF\", 16,  \"255\", 2 },\n    { \"-FF\", 16, \"-255\", 3 },\n\n    {  \"z\", 36, \"35\", 1 },\n    {  \"Z\", 36, \"35\", 1 },\n    { \"1B\", 59, \"70\", 2 },\n    {  \"a\", 60, \"36\", 1 },\n    {  \"A\", 61, \"10\", 1 },\n\n    {  \"0x0\",    0,   \"0\", 3 },\n    {  \"0X10\",   0,  \"16\", 4 },\n    { \"-0X0\",    0,   \"0\", 4 },\n    { \"-0x10\",   0, \"-16\", 5 },\n\n    {  \"0b0\",    0,  \"0\", 3 },\n    {  \"0B10\",   0,  \"2\", 4 },\n    { \"-0B0\",    0,  \"0\", 4 },\n    { \"-0b10\",   0, \"-2\", 5 },\n\n    {  \"00\",   0,  \"0\", 2 },\n    {  \"010\",  0,  \"8\", 3 },\n    { \"-00\",   0,  \"0\", 3 },\n    { \"-010\",  0, \"-8\", 4 },\n\n    {  \"0x\",     0,   \"0\", 2 },\n    {  \"0\",      0,   \"0\", 1 },\n    { \" 030\",   10,  \"30\", 4 },\n  };\n\n  mpz_t  got, want;\n  long   ftell_nread;\n  int    i, pre, post, j, got_nread, want_nread;\n  FILE   *fp;\n\n  mpz_init (got);\n  mpz_init (want);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      for (pre = 0; pre <= 3; pre++)\n\t{\n\t  for (post = 0; post <= 2; post++)\n\t    {\n\t      mpz_set_str_or_abort (want, data[i].want, 0);\n\t      MPZ_CHECK_FORMAT (want);\n\n\t      /* create the file new each time to ensure its length is what\n\t\t we want */\n\t      fp = fopen (FILENAME, \"w+\");\n\t      ASSERT_ALWAYS (fp != NULL);\n\t      for (j = 0; j < pre; j++)\n\t\tputc (' ', fp);\n\t      fputs (data[i].inp, fp);\n\t      for (j = 0; j < post; j++)\n\t\tputc (' ', fp);\n\t      fflush (fp);\n\t      ASSERT_ALWAYS (! ferror(fp));\n\n\t      rewind (fp);\n\t      got_nread = mpz_inp_str (got, fp, data[i].base);\n\n\t      if (got_nread != 0)\n\t\t{\n\t\t  ftell_nread = ftell (fp);\n\t\t  if (got_nread != ftell_nread)\n\t\t    {\n\t\t      printf (\"mpz_inp_str nread wrong\\n\");\n\t\t      printf (\"  inp          \\\"%s\\\"\\n\", data[i].inp);\n\t\t      printf (\"  base         %d\\n\", data[i].base);\n\t\t      printf (\"  pre          %d\\n\", pre);\n\t\t      printf (\"  post         %d\\n\", post);\n\t\t      printf (\"  got_nread    %d\\n\", got_nread);\n\t\t      printf (\"  ftell_nread  %ld\\n\", ftell_nread);\n\t\t      abort ();\n\t\t    }\n\t\t}\n\n\t      /* if data[i].inp is a whole string to read and there's no post\n\t\t whitespace then expect to have EOF */\n\t      if (post == 0 && data[i].want_nread == strlen(data[i].inp))\n\t\t{\n\t\t  int  c = getc(fp);\n\t\t  if (c != EOF)\n\t\t    {\n\t\t      printf (\"mpz_inp_str didn't read to EOF\\n\");\n\t\t      printf (\"  inp   \\\"%s\\\"\\n\", data[i].inp);\n\t\t      printf (\"  base  %d\\n\", data[i].base);\n\t\t      printf (\"  pre   %d\\n\", pre);\n\t\t      printf (\"  post  %d\\n\", post);\n\t\t      printf (\"  c     '%c' %#x\\n\", c, c);\n\t\t      abort ();\n\t\t    }\n\t\t}\n\n\t      /* only expect \"pre\" included in the count when non-zero */\n\t      want_nread = data[i].want_nread;\n\t      if (want_nread != 0)\n\t\twant_nread += pre;\n\n\t      if (got_nread != want_nread)\n\t\t{\n\t\t  printf (\"mpz_inp_str nread wrong\\n\");\n\t\t  printf (\"  inp         \\\"%s\\\"\\n\", data[i].inp);\n\t\t  printf (\"  base        %d\\n\", data[i].base);\n\t\t  printf (\"  pre         %d\\n\", pre);\n\t\t  printf (\"  post        %d\\n\", post);\n\t\t  printf (\"  got_nread   %d\\n\", got_nread);\n\t\t  printf (\"  want_nread  %d\\n\", want_nread);\n\t\t  abort ();\n\t\t}\n\n\t      MPZ_CHECK_FORMAT (got);\n\n\t      if (mpz_cmp (got, want) != 0)\n\t\t{\n\t\t  printf (\"mpz_inp_str wrong result\\n\");\n\t\t  printf (\"  inp   \\\"%s\\\"\\n\", data[i].inp);\n\t\t  printf (\"  base  %d\\n\", data[i].base);\n\t\t  mpz_trace (\"  got \",  got);\n\t\t  mpz_trace (\"  want\", want);\n\t\t  abort ();\n\t\t}\n\n\t      ASSERT_ALWAYS (fclose (fp) == 0);\n\t    }\n\t}\n    }\n\n  mpz_clear (got);\n  mpz_clear (want);\n}",
      "lines": 151,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n\n  unlink (FILENAME);\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-invert.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t a, m, ainv, t;\n  int test, r;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n  int reps = 1000;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  rands = RANDS;\n\n  mpz_init (bs);\n  mpz_init (a);\n  mpz_init (m);\n  mpz_init (ainv);\n  mpz_init (t);\n\n  for (test = 0; test < reps; test++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 16 + 2;\n\n      mpz_urandomb (bs, rands, size_range);\n      mpz_rrandomb (a, rands, mpz_get_ui (bs));\n      do {\n\tmpz_urandomb (bs, rands, size_range);\n\tmpz_rrandomb (m, rands, mpz_get_ui (bs));\n      } while (mpz_sgn (m) == 0);\n\n      mpz_urandomb (bs, rands, 8);\n      bsi = mpz_get_ui (bs);\n\n      if ((bsi & 1) != 0)\n\tmpz_neg (a, a);\n      if ((bsi & 2) != 0)\n\tmpz_neg (m, m);\n\n      r = mpz_invert (ainv, a, m);\n      if (r != 0)\n\t{\n\t  MPZ_CHECK_FORMAT (ainv);\n\n\t  if (mpz_cmp_ui (ainv, 0) < 0 || mpz_cmpabs (ainv, m) >= 0)\n\t    {\n\t      fprintf (stderr, \"ERROR in test %d\\n\", test);\n\t      gmp_fprintf (stderr, \"Inverse out of range.\\n\");\n\t      gmp_fprintf (stderr, \"a = %Zx\\n\", a);\n\t      gmp_fprintf (stderr, \"1/a = %Zx\\n\", ainv);\n\t      gmp_fprintf (stderr, \"m = %Zx\\n\", m);\n\t      abort ();\n\t    }\n\n\t  mpz_mul (t, ainv, a);\n\t  mpz_mod (t, t, m);\n\n\t  if (mpz_cmp_ui (t, mpz_cmpabs_ui (m, 1) != 0) != 0)\n\t    {\n\t      fprintf (stderr, \"ERROR in test %d\\n\", test);\n\t      gmp_fprintf (stderr, \"a^(-1)*a != 1 (mod m)\\n\");\n\t      gmp_fprintf (stderr, \"a = %Zx\\n\", a);\n\t      gmp_fprintf (stderr, \"m = %Zx\\n\", m);\n\t      abort ();\n\t    }\n\t}\n      else /* Inverse deos not exist */\n\t{\n\t  if (mpz_cmpabs_ui (m, 1) <= 0)\n\t    continue; /* OK */\n\n\t  mpz_gcd (t, a, m);\n\t  if (mpz_cmp_ui (t, 1) == 0)\n\t    {\n\t      fprintf (stderr, \"ERROR in test %d\\n\", test);\n\t      gmp_fprintf (stderr, \"Inverse exists, but was not found.\\n\");\n\t      gmp_fprintf (stderr, \"a = %Zx\\n\", a);\n\t      gmp_fprintf (stderr, \"m = %Zx\\n\", m);\n\t      abort ();\n\t    }\n\t}\n    }\n\n  mpz_clear (bs);\n  mpz_clear (a);\n  mpz_clear (m);\n  mpz_clear (ainv);\n  mpz_clear (t);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-io_raw.c": {
    "fopen_wplusb_or_die": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "FILE *\nfopen_wplusb_or_die (const char *filename)\n{\n  FILE  *fp;\n  fp = fopen (filename, \"w+b\");\n  if (fp == NULL)\n    fp = fopen (filename, \"w+\");\n\n  if (fp == NULL)\n    {\n      printf (\"Cannot create file %s\\n\", filename);\n      abort ();\n    }\n  return fp;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "FILE",
        "*\nfopen_wplusb_or_die (const char *filename)",
        "*"
      ]
    },
    "check_in": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\ncheck_in (void)\n{\n  int        i, j, zeros, neg, error = 0;\n  mpz_t      want, got;\n  size_t     want_ret, got_ret;\n  mp_size_t  size;\n  FILE       *fp;\n\n  mpz_init (want);\n  mpz_init (got);\n\n  for (i = 0; i < 32; i++)\n    {\n      for (zeros = 0; zeros < 8; zeros++)\n\t{\n\t  for (neg = 0; neg <= 1; neg++)\n\t    {\n\t      want_ret = i + zeros + 4;\n\n\t      /* need this to get the twos complement right */\n\t      ASSERT_ALWAYS (sizeof (size) >= 4);\n\n\t      size = i + zeros;\n\t      if (neg)\n\t\tsize = -size;\n\n\t      fp = fopen_wplusb_or_die (FILENAME);\n\t      for (j = 3; j >= 0; j--)\n\t\tASSERT_ALWAYS (putc ((size >> (j*8)) & 0xFF, fp) != EOF);\n\t      for (j = 0; j < zeros; j++)\n\t\tASSERT_ALWAYS (putc ('\\0', fp) != EOF);\n\t      for (j = 0; j < i; j++)\n\t\tASSERT_ALWAYS (putc (BYTEVAL (j), fp) != EOF);\n\t      /* and some trailing garbage */\n\t      ASSERT_ALWAYS (putc ('x', fp) != EOF);\n\t      ASSERT_ALWAYS (putc ('y', fp) != EOF);\n\t      ASSERT_ALWAYS (putc ('z', fp) != EOF);\n\t      ASSERT_ALWAYS (fflush (fp) == 0);\n\t      rewind (fp);\n\n\t      got_ret = mpz_inp_raw (got, fp);\n\t      ASSERT_ALWAYS (! ferror(fp));\n\t      ASSERT_ALWAYS (fclose (fp) == 0);\n\n\t      MPZ_CHECK_FORMAT (got);\n\n\t      if (got_ret != want_ret)\n\t\t{\n\t\t  printf (\"check_in: return value wrong\\n\");\n\t\t  error = 1;\n\t\t}\n\t      if (mpz_cmp (got, want) != 0)\n\t\t{\n\t\t  printf (\"check_in: result wrong\\n\");\n\t\t  error = 1;\n\t\t}\n\t      if (error)\n\t\t{\n\t\t  printf    (\"  i=%d zeros=%d neg=%d\\n\", i, zeros, neg);\n\t\t  printf    (\"  got_ret  %lu\\n\", (unsigned long) got_ret);\n\t\t  printf    (\"  want_ret %lu\\n\", (unsigned long) want_ret);\n\t\t  mpz_trace (\"  got      \", got);\n\t\t  mpz_trace (\"  want     \", want);\n\t\t  abort ();\n\t\t}\n\n\t      mpz_neg (want, want);\n\t    }\n\t}\n      mpz_mul_2exp (want, want, 8);\n      mpz_add_ui (want, want, (unsigned long) BYTEVAL (i));\n    }\n\n  mpz_clear (want);\n  mpz_clear (got);\n}",
      "lines": 77,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "check_out": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "void\ncheck_out (void)\n{\n  int        i, j, neg, error = 0;\n  mpz_t      z;\n  char       want[256], got[256], *p;\n  size_t     want_len, got_ret, got_read;\n  mp_size_t  size;\n  FILE       *fp;\n\n  mpz_init (z);\n\n  for (i = 0; i < 32; i++)\n    {\n      for (neg = 0; neg <= 1; neg++)\n\t{\n\t  want_len = i + 4;\n\n\t  /* need this to get the twos complement right */\n\t  ASSERT_ALWAYS (sizeof (size) >= 4);\n\n\t  size = i;\n\t  if (neg)\n\t    size = -size;\n\n\t  p = want;\n\t  for (j = 3; j >= 0; j--)\n\t    *p++ = size >> (j*8);\n\t  for (j = 0; j < i; j++)\n\t    *p++ = BYTEVAL (j);\n\t  ASSERT_ALWAYS (p <= want + sizeof (want));\n\n\t  fp = fopen_wplusb_or_die (FILENAME);\n\t  got_ret = mpz_out_raw (fp, z);\n\t  ASSERT_ALWAYS (fflush (fp) == 0);\n\t  rewind (fp);\n\t  got_read = fread (got, 1, sizeof(got), fp);\n\t  ASSERT_ALWAYS (! ferror(fp));\n\t  ASSERT_ALWAYS (fclose (fp) == 0);\n\n\t  if (got_ret != want_len)\n\t    {\n\t      printf (\"check_out: wrong return value\\n\");\n\t      error = 1;\n\t    }\n\t  if (got_read != want_len)\n\t    {\n\t      printf (\"check_out: wrong number of bytes read back\\n\");\n\t      error = 1;\n\t    }\n\t  if (memcmp (want, got, want_len) != 0)\n\t    {\n\t      printf (\"check_out: wrong data\\n\");\n\t      error = 1;\n\t    }\n\t  if (error)\n\t    {\n\t      printf    (\"  i=%d neg=%d\\n\", i, neg);\n\t      mpz_trace (\"  z\", z);\n\t      printf    (\"  got_ret  %lu\\n\", (unsigned long) got_ret);\n\t      printf    (\"  got_read %lu\\n\", (unsigned long) got_read);\n\t      printf    (\"  want_len %lu\\n\", (unsigned long) want_len);\n\t      printf    (\"  want\");\n\t      for (j = 0; j < want_len; j++)\n\t\tprintf (\" %02X\", (unsigned) (unsigned char) want[j]);\n\t      printf    (\"\\n\");\n\t      printf    (\"  got \");\n\t      for (j = 0; j < want_len; j++)\n\t\tprintf (\" %02X\", (unsigned) (unsigned char) got[j]);\n\t      printf    (\"\\n\");\n\t      abort ();\n\t    }\n\n\t  mpz_neg (z, z);\n\t}\n      mpz_mul_2exp (z, z, 8);\n      mpz_add_ui (z, z, (unsigned long) BYTEVAL (i));\n    }\n\n  mpz_clear (z);\n}",
      "lines": 81,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "check_rand": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "void\ncheck_rand (void)\n{\n  gmp_randstate_ptr  rands = RANDS;\n  int        i, error = 0;\n  mpz_t      got, want;\n  size_t     inp_ret, out_ret;\n  FILE       *fp;\n\n  mpz_init (want);\n  mpz_init (got);\n\n  for (i = 0; i < 500; i++)\n    {\n      mpz_erandomb (want, rands, 10*GMP_LIMB_BITS);\n      mpz_negrandom (want, rands);\n\n      fp = fopen_wplusb_or_die (FILENAME);\n      out_ret = mpz_out_raw (fp, want);\n      ASSERT_ALWAYS (fflush (fp) == 0);\n      rewind (fp);\n      inp_ret = mpz_inp_raw (got, fp);\n      ASSERT_ALWAYS (fclose (fp) == 0);\n\n      MPZ_CHECK_FORMAT (got);\n\n      if (inp_ret != out_ret)\n\t{\n\t  printf (\"check_rand: different inp/out return values\\n\");\n\t  error = 1;\n\t}\n      if (mpz_cmp (got, want) != 0)\n\t{\n\t  printf (\"check_rand: wrong result\\n\");\n\t  error = 1;\n\t}\n      if (error)\n\t{\n\t  printf    (\"  out_ret %lu\\n\", (unsigned long) out_ret);\n\t  printf    (\"  inp_ret %lu\\n\", (unsigned long) inp_ret);\n\t  mpz_trace (\"  want\", want);\n\t  mpz_trace (\"  got \", got);\n\t  abort ();\n\t}\n    }\n\n  mpz_clear (got);\n  mpz_clear (want);\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_in ();\n  check_out ();\n  check_rand ();\n\n  unlink (FILENAME);\n  tests_end ();\n\n  exit (0);\n}",
      "lines": 15,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-jac.c": {
    "mpz_mod4": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "unsigned long\nmpz_mod4 (mpz_srcptr z)\n{\n  mpz_t          m;\n  unsigned long  ret;\n\n  mpz_init (m);\n  mpz_fdiv_r_2exp (m, z, 2);\n  ret = mpz_get_ui (m);\n  mpz_clear (m);\n  return ret;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_fits_ulimb_p": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nmpz_fits_ulimb_p (mpz_srcptr z)\n{\n  return (SIZ(z) == 1 || SIZ(z) == 0);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_get_ulimb": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "mp_limb_t\nmpz_get_ulimb (mpz_srcptr z)\n{\n  if (SIZ(z) == 0)\n    return 0;\n  else\n    return PTR(z)[0];\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "try_base": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\ntry_base (mp_limb_t a, mp_limb_t b, int answer)\n{\n  int  got;\n\n  if ((b & 1) == 0 || b == 1 || a > b)\n    return;\n\n  got = mpn_jacobi_base (a, b, 0);\n  if (got != answer)\n    {\n      printf (LL(\"mpn_jacobi_base (%lu, %lu) is %d should be %d\\n\",\n\t\t \"mpn_jacobi_base (%llu, %llu) is %d should be %d\\n\"),\n\t      a, b, got, answer);\n      abort ();\n    }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "try_zi_ui": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void\ntry_zi_ui (mpz_srcptr a, unsigned long b, int answer)\n{\n  int  got;\n\n  got = mpz_kronecker_ui (a, b);\n  if (got != answer)\n    {\n      printf (\"mpz_kronecker_ui (\");\n      mpz_out_str (stdout, 10, a);\n      printf (\", %lu) is %d should be %d\\n\", b, got, answer);\n      abort ();\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "try_zi_si": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void\ntry_zi_si (mpz_srcptr a, long b, int answer)\n{\n  int  got;\n\n  got = mpz_kronecker_si (a, b);\n  if (got != answer)\n    {\n      printf (\"mpz_kronecker_si (\");\n      mpz_out_str (stdout, 10, a);\n      printf (\", %ld) is %d should be %d\\n\", b, got, answer);\n      abort ();\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "try_ui_zi": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\ntry_ui_zi (unsigned long a, mpz_srcptr b, int answer)\n{\n  int  got;\n\n  got = mpz_ui_kronecker (a, b);\n  if (got != answer)\n    {\n      printf (\"mpz_ui_kronecker (%lu, \", a);\n      mpz_out_str (stdout, 10, b);\n      printf (\") is %d should be %d\\n\", got, answer);\n      abort ();\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "try_si_zi": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "void\ntry_si_zi (long a, mpz_srcptr b, int answer)\n{\n  int  got;\n\n  got = mpz_si_kronecker (a, b);\n  if (got != answer)\n    {\n      printf (\"mpz_si_kronecker (%ld, \", a);\n      mpz_out_str (stdout, 10, b);\n      printf (\") is %d should be %d\\n\", got, answer);\n      abort ();\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "try_zi_zi": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void\ntry_zi_zi (mpz_srcptr a, mpz_srcptr b, int answer)\n{\n  int  got;\n\n  got = mpz_kronecker (a, b);\n  if (got != answer)\n    {\n      printf (\"mpz_kronecker (\");\n      mpz_out_str (stdout, 10, a);\n      printf (\", \");\n      mpz_out_str (stdout, 10, b);\n      printf (\") is %d should be %d\\n\", got, answer);\n      abort ();\n    }\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "try_pari": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "void\ntry_pari (mpz_srcptr a, mpz_srcptr b, int answer)\n{\n  printf (\"try(\");\n  mpz_out_str (stdout, 10, a);\n  printf (\",\");\n  mpz_out_str (stdout, 10, b);\n  printf (\",%d)\\n\", answer);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "try_each": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "void\ntry_each (mpz_srcptr a, mpz_srcptr b, int answer)\n{\n#if 0\n  fprintf(stderr, \"asize = %d, bsize = %d\\n\",\n\t  mpz_sizeinbase (a, 2), mpz_sizeinbase (b, 2));\n#endif\n  if (option_pari)\n    {\n      try_pari (a, b, answer);\n      return;\n    }\n\n  if (mpz_fits_ulimb_p (a) && mpz_fits_ulimb_p (b))\n    try_base (mpz_get_ulimb (a), mpz_get_ulimb (b), answer);\n\n  if (mpz_fits_ulong_p (b))\n    try_zi_ui (a, mpz_get_ui (b), answer);\n\n  if (mpz_fits_slong_p (b))\n    try_zi_si (a, mpz_get_si (b), answer);\n\n  if (mpz_fits_ulong_p (a))\n    try_ui_zi (mpz_get_ui (a), b, answer);\n\n  if (mpz_fits_sint_p (a))\n    try_si_zi (mpz_get_si (a), b, answer);\n\n  try_zi_zi (a, b, answer);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "try_pn": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "void\ntry_pn (mpz_srcptr a, mpz_srcptr b_orig, int answer)\n{\n  mpz_t  b;\n\n  mpz_init_set (b, b_orig);\n  try_each (a, b, answer);\n\n  mpz_neg (b, b);\n  if (mpz_sgn (a) < 0)\n    answer = -answer;\n\n  try_each (a, b, answer);\n\n  mpz_clear (b);\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "try_periodic_num": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "void\ntry_periodic_num (mpz_srcptr a_orig, mpz_srcptr b, int answer)\n{\n  mpz_t  a, a_period;\n  int    i;\n\n  if (mpz_sgn (b) <= 0)\n    return;\n\n  mpz_init_set (a, a_orig);\n  mpz_init_set (a_period, b);\n  if (mpz_mod4 (b) == 2)\n    mpz_mul_ui (a_period, a_period, 4);\n\n  /* don't bother with these tests if they're only going to produce\n     even/even */\n  if (mpz_even_p (a) && mpz_even_p (b) && mpz_even_p (a_period))\n    goto done;\n\n  for (i = 0; i < 6; i++)\n    {\n      mpz_add (a, a, a_period);\n      try_pn (a, b, answer);\n    }\n\n  mpz_set (a, a_orig);\n  for (i = 0; i < 6; i++)\n    {\n      mpz_sub (a, a, a_period);\n      try_pn (a, b, answer);\n    }\n\n done:\n  mpz_clear (a);\n  mpz_clear (a_period);\n}",
      "lines": 36,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "try_periodic_den": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "void\ntry_periodic_den (mpz_srcptr a, mpz_srcptr b_orig, int answer)\n{\n  mpz_t  b, b_period;\n  int    i;\n\n  if (mpz_sgn (a) == 0 || mpz_sgn (b_orig) == 0)\n    return;\n\n  mpz_init_set (b, b_orig);\n\n  mpz_init_set (b_period, a);\n  if (mpz_mod4 (a) == 3 && mpz_even_p (b))\n    mpz_mul_ui (b_period, b_period, 8L);\n  else if (mpz_mod4 (a) >= 2)\n    mpz_mul_ui (b_period, b_period, 4L);\n\n  /* don't bother with these tests if they're only going to produce\n     even/even */\n  if (mpz_even_p (a) && mpz_even_p (b) && mpz_even_p (b_period))\n    goto done;\n\n  for (i = 0; i < 6; i++)\n    {\n      mpz_add (b, b, b_period);\n      try_pn (a, b, answer);\n    }\n\n  mpz_set (b, b_orig);\n  for (i = 0; i < 6; i++)\n    {\n      mpz_sub (b, b, b_period);\n      try_pn (a, b, answer);\n    }\n\n done:\n  mpz_clear (b);\n  mpz_clear (b_period);\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "try_2den": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "void\ntry_2den (mpz_srcptr a, mpz_srcptr b_orig, int answer)\n{\n  mpz_t  b;\n  int    kindex;\n  int    answer_a2, answer_k;\n  unsigned long k;\n\n  /* don't bother when b==0 */\n  if (mpz_sgn (b_orig) == 0)\n    return;\n\n  mpz_init_set (b, b_orig);\n\n  /* (a/2) is 0 if a even, 1 if a==1 or 7 mod 8, -1 if a==3 or 5 mod 8 */\n  answer_a2 = (mpz_even_p (a) ? 0\n\t       : (((SIZ(a) >= 0 ? PTR(a)[0] : -PTR(a)[0]) + 2) & 7) < 4 ? 1\n\t       : -1);\n\n  for (kindex = 0; kindex < numberof (ktable); kindex++)\n    {\n      k = ktable[kindex];\n\n      /* answer_k = answer*(answer_a2^k) */\n      answer_k = (answer_a2 == 0 && k != 0 ? 0\n\t\t  : (k & 1) == 1 && answer_a2 == -1 ? -answer\n\t\t  : answer);\n\n      mpz_mul_2exp (b, b_orig, k);\n      try_pn (a, b, answer_k);\n    }\n\n  mpz_clear (b);\n}",
      "lines": 34,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "try_2num": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "void\ntry_2num (mpz_srcptr a_orig, mpz_srcptr b, int answer)\n{\n  mpz_t  a;\n  int    kindex;\n  int    answer_2b, answer_k;\n  unsigned long  k;\n\n  /* don't bother when a==0 */\n  if (mpz_sgn (a_orig) == 0)\n    return;\n\n  mpz_init (a);\n\n  /* (2/b) is 0 if b even, 1 if b==1 or 7 mod 8, -1 if b==3 or 5 mod 8 */\n  answer_2b = (mpz_even_p (b) ? 0\n\t       : (((SIZ(b) >= 0 ? PTR(b)[0] : -PTR(b)[0]) + 2) & 7) < 4 ? 1\n\t       : -1);\n\n  for (kindex = 0; kindex < numberof (ktable); kindex++)\n    {\n      k = ktable[kindex];\n\n      /* answer_k = answer*(answer_2b^k) */\n      answer_k = (answer_2b == 0 && k != 0 ? 0\n\t\t  : (k & 1) == 1 && answer_2b == -1 ? -answer\n\t\t  : answer);\n\n\tmpz_mul_2exp (a, a_orig, k);\n      try_pn (a, b, answer_k);\n    }\n\n  mpz_clear (a);\n}",
      "lines": 34,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "try_all": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "void\ntry_all (mpz_t a, mpz_t b, int answer)\n{\n  try_pn (a, b, answer);\n  try_periodic_num (a, b, answer);\n  try_periodic_den (a, b, answer);\n  try_2num (a, b, answer);\n  try_2den (a, b, answer);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        445,
        0
      ],
      "end_point": [
        662,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *a;\n    const char  *b;\n    int         answer;\n\n  } data[] = {\n\n    /* Note that the various derived checks in try_all() reduce the cases\n       that need to be given here.  */\n\n    /* some zeros */\n    {  \"0\",  \"0\", 0 },\n    {  \"0\",  \"2\", 0 },\n    {  \"0\",  \"6\", 0 },\n    {  \"5\",  \"0\", 0 },\n    { \"24\", \"60\", 0 },\n\n    /* (a/1) = 1, any a\n       In particular note (0/1)=1 so that (a/b)=(a mod b/b). */\n    { \"0\", \"1\", 1 },\n    { \"1\", \"1\", 1 },\n    { \"2\", \"1\", 1 },\n    { \"3\", \"1\", 1 },\n    { \"4\", \"1\", 1 },\n    { \"5\", \"1\", 1 },\n\n    /* (0/b) = 0, b != 1 */\n    { \"0\",  \"3\", 0 },\n    { \"0\",  \"5\", 0 },\n    { \"0\",  \"7\", 0 },\n    { \"0\",  \"9\", 0 },\n    { \"0\", \"11\", 0 },\n    { \"0\", \"13\", 0 },\n    { \"0\", \"15\", 0 },\n\n    /* (1/b) = 1 */\n    { \"1\",  \"1\", 1 },\n    { \"1\",  \"3\", 1 },\n    { \"1\",  \"5\", 1 },\n    { \"1\",  \"7\", 1 },\n    { \"1\",  \"9\", 1 },\n    { \"1\", \"11\", 1 },\n\n    /* (-1/b) = (-1)^((b-1)/2) which is -1 for b==3 mod 4 */\n    { \"-1\",  \"1\",  1 },\n    { \"-1\",  \"3\", -1 },\n    { \"-1\",  \"5\",  1 },\n    { \"-1\",  \"7\", -1 },\n    { \"-1\",  \"9\",  1 },\n    { \"-1\", \"11\", -1 },\n    { \"-1\", \"13\",  1 },\n    { \"-1\", \"15\", -1 },\n    { \"-1\", \"17\",  1 },\n    { \"-1\", \"19\", -1 },\n\n    /* (2/b) = (-1)^((b^2-1)/8) which is -1 for b==3,5 mod 8.\n       try_2num() will exercise multiple powers of 2 in the numerator.  */\n    { \"2\",  \"1\",  1 },\n    { \"2\",  \"3\", -1 },\n    { \"2\",  \"5\", -1 },\n    { \"2\",  \"7\",  1 },\n    { \"2\",  \"9\",  1 },\n    { \"2\", \"11\", -1 },\n    { \"2\", \"13\", -1 },\n    { \"2\", \"15\",  1 },\n    { \"2\", \"17\",  1 },\n\n    /* (-2/b) = (-1)^((b^2-1)/8)*(-1)^((b-1)/2) which is -1 for b==5,7mod8.\n       try_2num() will exercise multiple powers of 2 in the numerator, which\n       will test that the shift in mpz_si_kronecker() uses unsigned not\n       signed.  */\n    { \"-2\",  \"1\",  1 },\n    { \"-2\",  \"3\",  1 },\n    { \"-2\",  \"5\", -1 },\n    { \"-2\",  \"7\", -1 },\n    { \"-2\",  \"9\",  1 },\n    { \"-2\", \"11\",  1 },\n    { \"-2\", \"13\", -1 },\n    { \"-2\", \"15\", -1 },\n    { \"-2\", \"17\",  1 },\n\n    /* (a/2)=(2/a).\n       try_2den() will exercise multiple powers of 2 in the denominator. */\n    {  \"3\",  \"2\", -1 },\n    {  \"5\",  \"2\", -1 },\n    {  \"7\",  \"2\",  1 },\n    {  \"9\",  \"2\",  1 },\n    {  \"11\", \"2\", -1 },\n\n    /* Harriet Griffin, \"Elementary Theory of Numbers\", page 155, various\n       examples.  */\n    {   \"2\", \"135\",  1 },\n    { \"135\",  \"19\", -1 },\n    {   \"2\",  \"19\", -1 },\n    {  \"19\", \"135\",  1 },\n    { \"173\", \"135\",  1 },\n    {  \"38\", \"135\",  1 },\n    { \"135\", \"173\",  1 },\n    { \"173\",   \"5\", -1 },\n    {   \"3\",   \"5\", -1 },\n    {   \"5\", \"173\", -1 },\n    { \"173\",   \"3\", -1 },\n    {   \"2\",   \"3\", -1 },\n    {   \"3\", \"173\", -1 },\n    { \"253\",  \"21\",  1 },\n    {   \"1\",  \"21\",  1 },\n    {  \"21\", \"253\",  1 },\n    {  \"21\",  \"11\", -1 },\n    {  \"-1\",  \"11\", -1 },\n\n    /* Griffin page 147 */\n    {  \"-1\",  \"17\",  1 },\n    {   \"2\",  \"17\",  1 },\n    {  \"-2\",  \"17\",  1 },\n    {  \"-1\",  \"89\",  1 },\n    {   \"2\",  \"89\",  1 },\n\n    /* Griffin page 148 */\n    {  \"89\",  \"11\",  1 },\n    {   \"1\",  \"11\",  1 },\n    {  \"89\",   \"3\", -1 },\n    {   \"2\",   \"3\", -1 },\n    {   \"3\",  \"89\", -1 },\n    {  \"11\",  \"89\",  1 },\n    {  \"33\",  \"89\", -1 },\n\n    /* H. Davenport, \"The Higher Arithmetic\", page 65, the quadratic\n       residues and non-residues mod 19.  */\n    {  \"1\", \"19\",  1 },\n    {  \"4\", \"19\",  1 },\n    {  \"5\", \"19\",  1 },\n    {  \"6\", \"19\",  1 },\n    {  \"7\", \"19\",  1 },\n    {  \"9\", \"19\",  1 },\n    { \"11\", \"19\",  1 },\n    { \"16\", \"19\",  1 },\n    { \"17\", \"19\",  1 },\n    {  \"2\", \"19\", -1 },\n    {  \"3\", \"19\", -1 },\n    {  \"8\", \"19\", -1 },\n    { \"10\", \"19\", -1 },\n    { \"12\", \"19\", -1 },\n    { \"13\", \"19\", -1 },\n    { \"14\", \"19\", -1 },\n    { \"15\", \"19\", -1 },\n    { \"18\", \"19\", -1 },\n\n    /* Residues and non-residues mod 13 */\n    {  \"0\",  \"13\",  0 },\n    {  \"1\",  \"13\",  1 },\n    {  \"2\",  \"13\", -1 },\n    {  \"3\",  \"13\",  1 },\n    {  \"4\",  \"13\",  1 },\n    {  \"5\",  \"13\", -1 },\n    {  \"6\",  \"13\", -1 },\n    {  \"7\",  \"13\", -1 },\n    {  \"8\",  \"13\", -1 },\n    {  \"9\",  \"13\",  1 },\n    { \"10\",  \"13\",  1 },\n    { \"11\",  \"13\", -1 },\n    { \"12\",  \"13\",  1 },\n\n    /* various */\n    {  \"5\",   \"7\", -1 },\n    { \"15\",  \"17\",  1 },\n    { \"67\",  \"89\",  1 },\n\n    /* special values inducing a==b==1 at the end of jac_or_kron() */\n    { \"0x10000000000000000000000000000000000000000000000001\",\n      \"0x10000000000000000000000000000000000000000000000003\", 1 },\n\n    /* Test for previous bugs in jacobi_2. */\n    { \"0x43900000000\", \"0x42400000439\", -1 }, /* 32-bit limbs */\n    { \"0x4390000000000000000\", \"0x4240000000000000439\", -1 }, /* 64-bit limbs */\n\n    { \"198158408161039063\", \"198158360916398807\", -1 },\n\n    /* Some tests involving large quotients in the continued fraction\n       expansion. */\n    { \"37200210845139167613356125645445281805\",\n      \"451716845976689892447895811408978421929\", -1 },\n    { \"67674091930576781943923596701346271058970643542491743605048620644676477275152701774960868941561652032482173612421015\",\n      \"4902678867794567120224500687210807069172039735\", 0 },\n    { \"2666617146103764067061017961903284334497474492754652499788571378062969111250584288683585223600172138551198546085281683283672592\", \"2666617146103764067061017961903284334497474492754652499788571378062969111250584288683585223600172138551198546085281683290481773\", 1 },\n\n    /* Exercises the case asize == 1, btwos > 0 in mpz_jacobi. */\n    { \"804609\", \"421248363205206617296534688032638102314410556521742428832362659824\", 1 } ,\n    { \"4190209\", \"2239744742177804210557442048984321017460028974602978995388383905961079286530650825925074203175536427000\", 1 },\n\n    /* Exercises the case asize == 1, btwos = 63 in mpz_jacobi\n       (relevant when GMP_LIMB_BITS == 64). */\n    { \"17311973299000934401\", \"1675975991242824637446753124775689449936871337036614677577044717424700351103148799107651171694863695242089956242888229458836426332300124417011114380886016\", 1 },\n    { \"3220569220116583677\", \"41859917623035396746\", -1 },\n\n    /* Other test cases that triggered bugs during development. */\n    { \"37200210845139167613356125645445281805\", \"340116213441272389607827434472642576514\", -1 },\n    { \"74400421690278335226712251290890563610\", \"451716845976689892447895811408978421929\", -1 },\n  };\n\n  int    i;\n  mpz_t  a, b;\n\n  mpz_init (a);\n  mpz_init (b);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (a, data[i].a, 0);\n      mpz_set_str_or_abort (b, data[i].b, 0);\n      try_all (a, b, data[i].answer);\n    }\n\n  mpz_clear (a);\n  mpz_clear (b);\n}",
      "lines": 218,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_squares_zi": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        709,
        1
      ],
      "content": "void\ncheck_squares_zi (void)\n{\n  gmp_randstate_ptr rands = RANDS;\n  mpz_t  a, b, g;\n  int    i, answer;\n  mp_size_t size_range, an, bn;\n  mpz_t bs;\n\n  mpz_init (bs);\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (g);\n\n  for (i = 0; i < 50; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 10 + i/8 + 2;\n\n      mpz_urandomb (bs, rands, size_range);\n      an = mpz_get_ui (bs);\n      mpz_rrandomb (a, rands, an);\n\n      mpz_urandomb (bs, rands, size_range);\n      bn = mpz_get_ui (bs);\n      mpz_rrandomb (b, rands, bn);\n\n      mpz_gcd (g, a, b);\n      if (mpz_cmp_ui (g, 1L) == 0)\n\tanswer = 1;\n      else\n\tanswer = 0;\n\n      mpz_mul (a, a, a);\n\n      try_all (a, b, answer);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (g);\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_a_zero": {
      "start_point": [
        714,
        0
      ],
      "end_point": [
        748,
        1
      ],
      "content": "void\ncheck_a_zero (void)\n{\n  mpz_t  a, b;\n\n  mpz_init_set_ui (a, 0);\n  mpz_init (b);\n\n  mpz_set_ui (b, 1L);\n  PTR(a)[0] = 0;\n  try_all (a, b, 1);   /* (0/1)=1 */\n  PTR(a)[0] = 1;\n  try_all (a, b, 1);   /* (0/1)=1 */\n\n  mpz_set_si (b, -1L);\n  PTR(a)[0] = 0;\n  try_all (a, b, 1);   /* (0/-1)=1 */\n  PTR(a)[0] = 1;\n  try_all (a, b, 1);   /* (0/-1)=1 */\n\n  mpz_set_ui (b, 0);\n  PTR(a)[0] = 0;\n  try_all (a, b, 0);   /* (0/0)=0 */\n  PTR(a)[0] = 1;\n  try_all (a, b, 0);   /* (0/0)=0 */\n\n  mpz_set_ui (b, 2);\n  PTR(a)[0] = 0;\n  try_all (a, b, 0);   /* (0/2)=0 */\n  PTR(a)[0] = 1;\n  try_all (a, b, 0);   /* (0/2)=0 */\n\n  mpz_clear (a);\n  mpz_clear (b);\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ref_jacobi": {
      "start_point": [
        752,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "int\nref_jacobi (mpz_srcptr a, mpz_srcptr b, unsigned nprime,\n\t    mpz_t prime[], unsigned *exp)\n{\n  unsigned i;\n  int res;\n\n  for (i = 0, res = 1; i < nprime; i++)\n    if (exp[i])\n      {\n\tint legendre = refmpz_legendre (a, prime[i]);\n\tif (!legendre)\n\t  return 0;\n\tif (exp[i] & 1)\n\t  res *= legendre;\n      }\n  return res;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "check_jacobi_factored": {
      "start_point": [
        771,
        0
      ],
      "end_point": [
        844,
        1
      ],
      "content": "void\ncheck_jacobi_factored (void)\n{\n#define PRIME_N 10\n#define PRIME_MAX_SIZE 50\n#define PRIME_MAX_EXP 4\n#define PRIME_A_COUNT 10\n#define PRIME_B_COUNT 5\n#define PRIME_MAX_B_SIZE 2000\n\n  gmp_randstate_ptr rands = RANDS;\n  mpz_t prime[PRIME_N];\n  unsigned exp[PRIME_N];\n  mpz_t a, b, t, bs;\n  unsigned i;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (t);\n  mpz_init (bs);\n\n  /* Generate primes */\n  for (i = 0; i < PRIME_N; i++)\n    {\n      mp_size_t size;\n      mpz_init (prime[i]);\n      mpz_urandomb (bs, rands, 32);\n      size = mpz_get_ui (bs) % PRIME_MAX_SIZE + 2;\n      mpz_rrandomb (prime[i], rands, size);\n      if (mpz_cmp_ui (prime[i], 3) <= 0)\n\tmpz_set_ui (prime[i], 3);\n      else\n\tmpz_nextprime (prime[i], prime[i]);\n    }\n\n  for (i = 0; i < PRIME_B_COUNT; i++)\n    {\n      unsigned j, k;\n      mp_bitcnt_t bsize;\n\n      mpz_set_ui (b, 1);\n      bsize = 1;\n\n      for (j = 0; j < PRIME_N && bsize < PRIME_MAX_B_SIZE; j++)\n\t{\n\t  mpz_urandomb (bs, rands, 32);\n\t  exp[j] = mpz_get_ui (bs) % PRIME_MAX_EXP;\n\t  mpz_pow_ui (t, prime[j], exp[j]);\n\t  mpz_mul (b, b, t);\n\t  bsize = mpz_sizeinbase (b, 2);\n\t}\n      for (k = 0; k < PRIME_A_COUNT; k++)\n\t{\n\t  int answer;\n\t  mpz_rrandomb (a, rands, bsize + 2);\n\t  answer = ref_jacobi (a, b, j, prime, exp);\n\t  try_all (a, b, answer);\n\t}\n    }\n  for (i = 0; i < PRIME_N; i++)\n    mpz_clear (prime[i]);\n\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (t);\n  mpz_clear (bs);\n\n#undef PRIME_N\n#undef PRIME_MAX_SIZE\n#undef PRIME_MAX_EXP\n#undef PRIME_A_COUNT\n#undef PRIME_B_COUNT\n#undef PRIME_MAX_B_SIZE\n}",
      "lines": 74,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_large_quotients": {
      "start_point": [
        875,
        0
      ],
      "end_point": [
        983,
        1
      ],
      "content": "void\ncheck_large_quotients (void)\n{\n#define COUNT 50\n#define PBITS 200\n#define PPOWER 201\n#define MAX_QBITS 500\n\n  gmp_randstate_ptr rands = RANDS;\n\n  mpz_t p, n, q, g, s, t, x, y, bs;\n  mpz_t M[2][2];\n  mp_bitcnt_t nsize;\n  unsigned i;\n\n  mpz_init (p);\n  mpz_init (n);\n  mpz_init (q);\n  mpz_init (g);\n  mpz_init (s);\n  mpz_init (t);\n  mpz_init (x);\n  mpz_init (y);\n  mpz_init (bs);\n  mpz_init (M[0][0]);\n  mpz_init (M[0][1]);\n  mpz_init (M[1][0]);\n  mpz_init (M[1][1]);\n\n  /* First generate a number with known factorization, as a random\n     smallish prime raised to an odd power. Then (a|n) = (a|p). */\n  mpz_rrandomb (p, rands, PBITS);\n  mpz_nextprime (p, p);\n  mpz_pow_ui (n, p, PPOWER);\n\n  nsize = mpz_sizeinbase (n, 2);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      int answer;\n      mp_bitcnt_t msize;\n\n      mpz_set_ui (M[0][0], 1);\n      mpz_set_ui (M[0][1], 0);\n      mpz_set_ui (M[1][0], 0);\n      mpz_set_ui (M[1][1], 1);\n\n      for (msize = 1; 2*(msize + MAX_QBITS) + 1 < nsize ;)\n\t{\n\t  unsigned i;\n\t  mpz_rrandomb (bs, rands, 32);\n\t  mpz_rrandomb (q, rands, 1 + mpz_get_ui (bs) % MAX_QBITS);\n\n\t  /* Multiply by (q, 1; 1,0) from the right */\n\t  for (i = 0; i < 2; i++)\n\t    {\n\t      mp_bitcnt_t size;\n\t      mpz_swap (M[i][0], M[i][1]);\n\t      mpz_addmul (M[i][0], M[i][1], q);\n\t      size = mpz_sizeinbase (M[i][0], 2);\n\t      if (size > msize)\n\t\tmsize = size;\n\t    }\n\t}\n      mpz_gcdext (g, s, t, M[0][0], M[0][1]);\n      ASSERT_ALWAYS (mpz_cmp_ui (g, 1) == 0);\n\n      /* Solve n = M[0][0] * x + M[0][1] * y */\n      if (mpz_sgn (s) > 0)\n\t{\n\t  mpz_mul (x, n, s);\n\t  mpz_fdiv_qr (q, x, x, M[0][1]);\n\t  mpz_mul (y, q, M[0][0]);\n\t  mpz_addmul (y, t, n);\n\t  ASSERT_ALWAYS (mpz_sgn (y) > 0);\n\t}\n      else\n\t{\n\t  mpz_mul (y, n, t);\n\t  mpz_fdiv_qr (q, y, y, M[0][0]);\n\t  mpz_mul (x, q, M[0][1]);\n\t  mpz_addmul (x, s, n);\n\t  ASSERT_ALWAYS (mpz_sgn (x) > 0);\n\t}\n      mpz_mul (x, x, M[1][0]);\n      mpz_addmul (x, y, M[1][1]);\n\n      /* Now (x|n) has the selected large quotients */\n      answer = refmpz_legendre (x, p);\n      try_zi_zi (x, n, answer);\n    }\n  mpz_clear (p);\n  mpz_clear (n);\n  mpz_clear (q);\n  mpz_clear (g);\n  mpz_clear (s);\n  mpz_clear (t);\n  mpz_clear (x);\n  mpz_clear (y);\n  mpz_clear (bs);\n  mpz_clear (M[0][0]);\n  mpz_clear (M[0][1]);\n  mpz_clear (M[1][0]);\n  mpz_clear (M[1][1]);\n#undef COUNT\n#undef PBITS\n#undef PPOWER\n#undef MAX_QBITS\n}",
      "lines": 109,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        985,
        0
      ],
      "end_point": [
        1011,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  if (argc >= 2 && strcmp (argv[1], \"-p\") == 0)\n    {\n      option_pari = 1;\n\n      printf (\"\\\ntry(a,b,answer) =\\n\\\n{\\n\\\n  if (kronecker(a,b) != answer,\\n\\\n    print(\\\"wrong at \\\", a, \\\",\\\", b,\\n\\\n      \\\" expected \\\", answer,\\n\\\n      \\\" pari says \\\", kronecker(a,b)))\\n\\\n}\\n\");\n    }\n\n  check_data ();\n  check_squares_zi ();\n  check_a_zero ();\n  check_jacobi_factored ();\n  check_large_quotients ();\n  tests_end ();\n  exit (0);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-lcm.c": {
    "check_all": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\ncheck_all (mpz_ptr want, mpz_srcptr x_orig, mpz_srcptr y_orig)\n{\n  mpz_t  got, x, y;\n  int    negx, negy, swap, inplace;\n\n  mpz_init (got);\n  mpz_init_set (x, x_orig);\n  mpz_init_set (y, y_orig);\n\n  for (swap = 0; swap < 2; swap++)\n    {\n      mpz_swap (x, y);\n\n      for (negx = 0; negx < 2; negx++)\n\t{\n\t  mpz_neg (x, x);\n\n\t  for (negy = 0; negy < 2; negy++)\n\t    {\n\t      mpz_neg (y, y);\n\n\t      for (inplace = 0; inplace <= 1; inplace++)\n\t\t{\n\t\t  if (inplace)\n\t\t    { mpz_set (got, x); mpz_lcm (got, got, y); }\n\t\t  else\n\t\t    mpz_lcm (got, x, y);\n\t\t  MPZ_CHECK_FORMAT (got);\n\n\t\t  if (mpz_cmp (got, want) != 0)\n\t\t    {\n\t\t      printf (\"mpz_lcm wrong, inplace=%d\\n\", inplace);\n\t\t    fail:\n\t\t      mpz_trace (\"x\", x);\n\t\t      mpz_trace (\"y\", y);\n\t\t      mpz_trace (\"got\", got);\n\t\t      mpz_trace (\"want\", want);\n\t\t      abort ();\n\t\t    }\n\n\t\t  if (mpz_fits_ulong_p (y))\n\t\t    {\n\t\t      unsigned long  yu = mpz_get_ui (y);\n\t\t      if (inplace)\n\t\t\t{ mpz_set (got, x); mpz_lcm_ui (got, got, yu); }\n\t\t      else\n\t\t\tmpz_lcm_ui (got, x, yu);\n\n\t\t      if (mpz_cmp (got, want) != 0)\n\t\t\t{\n\t\t\t  printf (\"mpz_lcm_ui wrong, inplace=%d\\n\", inplace);\n\t\t\t  printf    (\"yu=%lu\\n\", yu);\n\t\t\t  goto fail;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n  mpz_clear (got);\n  mpz_clear (x);\n  mpz_clear (y);\n}",
      "lines": 65,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "check_primes": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\ncheck_primes (void)\n{\n  static unsigned long  prime[] = {\n    2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,\n    101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,\n    191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,\n    281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,\n    389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,\n  };\n  mpz_t  want, x, y;\n  int    i;\n\n  mpz_init (want);\n  mpz_init (x);\n  mpz_init (y);\n\n  /* Check zeros. */\n  mpz_set_ui (want, 0);\n  mpz_set_ui (x, 1);\n  check_all (want, want, want);\n  check_all (want, want, x);\n  check_all (want, x, want);\n\n  /* New prime each time. */\n  mpz_set_ui (want, 1L);\n  for (i = 0; i < numberof (prime); i++)\n    {\n      mpz_set (x, want);\n      mpz_set_ui (y, prime[i]);\n      mpz_mul_ui (want, want, prime[i]);\n      check_all (want, x, y);\n    }\n\n  /* Old prime each time. */\n  mpz_set (x, want);\n  for (i = 0; i < numberof (prime); i++)\n    {\n      mpz_set_ui (y, prime[i]);\n      check_all (want, x, y);\n    }\n\n  /* One old, one new each time. */\n  mpz_set_ui (want, prime[0]);\n  for (i = 1; i < numberof (prime); i++)\n    {\n      mpz_set (x, want);\n      mpz_set_ui (y, prime[i] * prime[i-1]);\n      mpz_mul_ui (want, want, prime[i]);\n      check_all (want, x, y);\n    }\n\n  /* Triplets with A,B in x and B,C in y. */\n  mpz_set_ui (want, 1L);\n  mpz_set_ui (x, 1L);\n  mpz_set_ui (y, 1L);\n  for (i = 0; i+2 < numberof (prime); i += 3)\n    {\n      mpz_mul_ui (want, want, prime[i]);\n      mpz_mul_ui (want, want, prime[i+1]);\n      mpz_mul_ui (want, want, prime[i+2]);\n\n      mpz_mul_ui (x, x, prime[i]);\n      mpz_mul_ui (x, x, prime[i+1]);\n\n      mpz_mul_ui (y, y, prime[i+1]);\n      mpz_mul_ui (y, y, prime[i+2]);\n\n      check_all (want, x, y);\n    }\n\n\n  mpz_clear (want);\n  mpz_clear (x);\n  mpz_clear (y);\n}",
      "lines": 76,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  check_primes ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-limbs.c": {
    "alt_add": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static void\nalt_add (mpz_ptr r, mpz_srcptr a, mpz_srcptr b)\n{\n  mp_size_t an = mpz_size (a);\n  mp_size_t bn = mpz_size (b);\n  mp_ptr rp;\n\n  ASSERT (an > 0);\n  ASSERT (bn > 0);\n  if (an < bn)\n    {\n      MP_SIZE_T_SWAP (an, bn);\n      MPZ_SRCPTR_SWAP (a, b);\n    }\n  rp = mpz_limbs_modify (r, an + 1);\n  rp[an] = mpn_add (rp, mpz_limbs_read (a), an, mpz_limbs_read (b), bn);\n  mpz_limbs_finish (r, an + 1);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_funcs": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static void\ncheck_funcs (const char *name,\n\t     void (*f)(mpz_ptr, mpz_srcptr, mpz_srcptr),\n\t     void (*ref_f)(mpz_ptr, mpz_srcptr, mpz_srcptr),\n\t     mpz_srcptr a, mpz_srcptr b)\n{\n  mpz_t r, ref;\n  mpz_inits (r, ref, NULL);\n\n  ref_f (ref, a, b);\n  MPZ_CHECK_FORMAT (ref);\n  f (r, a, b);\n  MPZ_CHECK_FORMAT (r);\n\n  if (mpz_cmp (r, ref) != 0)\n    {\n      printf (\"%s failed, abits %u, bbits %u\\n\",\n\t      name,\n\t      (unsigned) mpz_sizeinbase (a, 2),\n\t      (unsigned) mpz_sizeinbase (b, 2));\n      gmp_printf (\"a = %Zx\\n\", a);\n      gmp_printf (\"b = %Zx\\n\", b);\n      gmp_printf (\"r = %Zx (bad)\\n\", r);\n      gmp_printf (\"ref = %Zx\\n\", ref);\n      abort ();\n    }\n  mpz_clears (r, ref, NULL);\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_add": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static void\ncheck_add (void)\n{\n  gmp_randstate_ptr rands = RANDS;\n  mpz_t bs, a, b;\n  unsigned i;\n  mpz_inits (bs, a, b, NULL);\n  for (i = 0; i < COUNT; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      mpz_rrandomb (a, rands, 1 + mpz_get_ui (bs) % BITSIZE);\n      mpz_urandomb (bs, rands, 32);\n      mpz_rrandomb (b, rands, 1 + mpz_get_ui (bs) % BITSIZE);\n\n      check_funcs (\"add\", alt_add, mpz_add, a, b);\n    }\n  mpz_clears (bs, a, b, NULL);\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "alt_mul": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static void\nalt_mul (mpz_ptr r, mpz_srcptr a, mpz_srcptr b)\n{\n  mp_size_t an = mpz_size (a);\n  mp_size_t bn = mpz_size (b);\n  mp_srcptr ap, bp;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  ASSERT (an > 0);\n  ASSERT (bn > 0);\n  if (an < bn)\n    {\n      MP_SIZE_T_SWAP (an, bn);\n      MPZ_SRCPTR_SWAP (a, b);\n    }\n  /* NOTE: This copying seems unnecessary; better to allocate new\n     result area, and free the old area when done. */\n  if (r == a)\n    {\n      mp_ptr tp =  TMP_ALLOC_LIMBS (an);\n      MPN_COPY (tp, mpz_limbs_read (a), an);\n      ap = tp;\n      bp = (a == b) ? ap : mpz_limbs_read (b);\n    }\n  else if (r == b)\n    {\n      mp_ptr tp = TMP_ALLOC_LIMBS (bn);\n      MPN_COPY (tp, mpz_limbs_read (b), bn);\n      bp = tp;\n      ap = mpz_limbs_read (a);\n    }\n  else\n    {\n      ap = mpz_limbs_read (a);\n      bp = mpz_limbs_read (b);\n    }\n  mpn_mul (mpz_limbs_write (r, an + bn),\n\t   ap, an, bp, bn);\n\n  mpz_limbs_finish (r, an + bn);\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_mul": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\ncheck_mul (void)\n{\n  gmp_randstate_ptr rands = RANDS;\n  mpz_t bs, a, b;\n  unsigned i;\n  mpz_inits (bs, a, b, NULL);\n  for (i = 0; i < COUNT; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      mpz_rrandomb (a, rands, 1 + mpz_get_ui (bs) % BITSIZE);\n      mpz_urandomb (bs, rands, 32);\n      mpz_rrandomb (b, rands, 1 + mpz_get_ui (bs) % BITSIZE);\n\n      check_funcs (\"mul\", alt_mul, mpz_mul, a, b);\n    }\n  mpz_clears (bs, a, b, NULL);\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_roinit": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static void\ncheck_roinit (void)\n{\n  gmp_randstate_ptr rands = RANDS;\n  mpz_t bs, a, b, r, ref;\n  unsigned i;\n\n  mpz_inits (bs, a, b, r, ref, NULL);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      mp_srcptr ap, bp;\n      mp_size_t an, bn;\n      mpz_urandomb (bs, rands, 32);\n      mpz_rrandomb (a, rands, 1 + mpz_get_ui (bs) % BITSIZE);\n      mpz_urandomb (bs, rands, 32);\n      mpz_rrandomb (b, rands, 1 + mpz_get_ui (bs) % BITSIZE);\n\n      an = mpz_size (a);\n      ap = mpz_limbs_read (a);\n      bn = mpz_size (b);\n      bp = mpz_limbs_read (b);\n\n      mpz_add (ref, a, b);\n      {\n\tmpz_t a1, b1;\n#if __STDC_VERSION__ >= 199901\n\tconst mpz_t a2 = MPZ_ROINIT_N ( (mp_ptr) ap, an);\n\tconst mpz_t b2 = MPZ_ROINIT_N ( (mp_ptr) bp, bn);\n\n\tmpz_set_ui (r, 0);\n\tmpz_add (r, a2, b2);\n\tif (mpz_cmp (r, ref) != 0)\n\t  {\n\t    printf (\"MPZ_ROINIT_N failed\\n\");\n\t    gmp_printf (\"a = %Zx\\n\", a);\n\t    gmp_printf (\"b = %Zx\\n\", b);\n\t    gmp_printf (\"r = %Zx (bad)\\n\", r);\n\t    gmp_printf (\"ref = %Zx\\n\", ref);\n\t    abort ();\n\t  }\n#endif\n\tmpz_set_ui (r, 0);\n\tmpz_add (r, mpz_roinit_n (a1, ap, an), mpz_roinit_n (b1, bp, bn));\n\tif (mpz_cmp (r, ref) != 0)\n\t  {\n\t    printf (\"mpz_roinit_n failed\\n\");\n\t    gmp_printf (\"a = %Zx\\n\", a);\n\t    gmp_printf (\"b = %Zx\\n\", b);\n\t    gmp_printf (\"r = %Zx (bad)\\n\", r);\n\t    gmp_printf (\"ref = %Zx\\n\", ref);\n\t    abort ();\n\t  }\n      }\n    }\n  mpz_clears (bs, a, b, r, ref, NULL);\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n  tests_end ();\n\n  check_add ();\n  check_mul ();\n  check_roinit ();\n\n  return 0;\n\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-lucnum_ui.c": {
    "check_sequence": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\ncheck_sequence (int argc, char *argv[])\n{\n  unsigned long  n;\n  unsigned long  limit = 100 * GMP_LIMB_BITS;\n  mpz_t          want_ln, want_ln1, got_ln, got_ln1;\n\n  if (argc > 1 && argv[1][0] == 'x')\n    limit = ULONG_MAX;\n  else if (argc > 1)\n    limit = atoi (argv[1]);\n\n  /* start at n==0 */\n  mpz_init_set_si (want_ln1, -1); /* L[-1] */\n  mpz_init_set_ui (want_ln,  2);  /* L[0]   */\n  mpz_init (got_ln);\n  mpz_init (got_ln1);\n\n  for (n = 0; n < limit; n++)\n    {\n      mpz_lucnum2_ui (got_ln, got_ln1, n);\n      MPZ_CHECK_FORMAT (got_ln);\n      MPZ_CHECK_FORMAT (got_ln1);\n      if (mpz_cmp (got_ln, want_ln) != 0 || mpz_cmp (got_ln1, want_ln1) != 0)\n        {\n          printf (\"mpz_lucnum2_ui(%lu) wrong\\n\", n);\n          mpz_trace (\"want ln \", want_ln);\n          mpz_trace (\"got  ln \",  got_ln);\n          mpz_trace (\"want ln1\", want_ln1);\n          mpz_trace (\"got  ln1\",  got_ln1);\n          abort ();\n        }\n\n      mpz_lucnum_ui (got_ln, n);\n      MPZ_CHECK_FORMAT (got_ln);\n      if (mpz_cmp (got_ln, want_ln) != 0)\n        {\n          printf (\"mpz_lucnum_ui(%lu) wrong\\n\", n);\n          mpz_trace (\"want ln\", want_ln);\n          mpz_trace (\"got  ln\", got_ln);\n          abort ();\n        }\n\n      mpz_add (want_ln1, want_ln1, want_ln);  /* L[n+1] = L[n] + L[n-1] */\n      mpz_swap (want_ln1, want_ln);\n    }\n\n  mpz_clear (want_ln);\n  mpz_clear (want_ln1);\n  mpz_clear (got_ln);\n  mpz_clear (got_ln1);\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_sequence (argc, argv);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-mfac_uiui.c": {
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  mpz_t ref[MULTIFAC_WHEEL], ref2[MULTIFAC_WHEEL2], res;\n  unsigned long n, j, m, m2;\n  unsigned long limit = 2222, step = 1;\n\n  tests_start ();\n\n  if (argc > 1 && argv[1][0] == 'x')\n    limit = ULONG_MAX;\n  else if (argc > 1)\n    limit = atoi (argv[1]);\n\n  /* for small limb testing */\n  limit = MIN (limit, MP_LIMB_T_MAX);\n\n  for (m = 0; m < MULTIFAC_WHEEL; m++)\n    mpz_init_set_ui(ref [m],1);\n  for (m2 = 0; m2 < MULTIFAC_WHEEL2; m2++)\n    mpz_init_set_ui(ref2 [m2],1);\n\n  mpz_init (res);\n\n  m = 0;\n  m2 = 0;\n  for (n = 0; n <= limit;)\n    {\n      mpz_mfac_uiui (res, n, MULTIFAC_WHEEL);\n      MPZ_CHECK_FORMAT (res);\n      if (mpz_cmp (ref[m], res) != 0)\n        {\n          printf (\"mpz_mfac_uiui(%lu,%d) wrong\\n\", n, MULTIFAC_WHEEL);\n          printf (\"  got  \"); mpz_out_str (stdout, 10, res); printf(\"\\n\");\n          printf (\"  want \"); mpz_out_str (stdout, 10, ref[m]); printf(\"\\n\");\n          abort ();\n        }\n      mpz_mfac_uiui (res, n, MULTIFAC_WHEEL2);\n      MPZ_CHECK_FORMAT (res);\n      if (mpz_cmp (ref2[m2], res) != 0)\n        {\n          printf (\"mpz_mfac_uiui(%lu,%d) wrong\\n\", n, MULTIFAC_WHEEL2);\n          printf (\"  got  \"); mpz_out_str (stdout, 10, res); printf(\"\\n\");\n          printf (\"  want \"); mpz_out_str (stdout, 10, ref2[m2]); printf(\"\\n\");\n          abort ();\n        }\n      if (n + step <= limit)\n\tfor (j = 0; j < step; j++) {\n\t  n++; m++; m2++;\n\t  if (m >= MULTIFAC_WHEEL) m -= MULTIFAC_WHEEL;\n\t  if (m2 >= MULTIFAC_WHEEL2) m2 -= MULTIFAC_WHEEL2;\n\t  mpz_mul_ui (ref[m], ref[m], n); /* Compute a reference, with current library */\n\t  mpz_mul_ui (ref2[m2], ref2[m2], n); /* Compute a reference, with current library */\n\t}\n      else n += step;\n    }\n  mpz_fac_ui (ref[0], n);\n  mpz_mfac_uiui (res, n, 1);\n  MPZ_CHECK_FORMAT (res);\n  if (mpz_cmp (ref[0], res) != 0)\n    {\n      printf (\"mpz_mfac_uiui(%lu,1) wrong\\n\", n);\n      printf (\"  got  \"); mpz_out_str (stdout, 10, res); printf(\"\\n\");\n      printf (\"  want \"); mpz_out_str (stdout, 10, ref[0]); printf(\"\\n\");\n      abort ();\n    }\n\n  mpz_2fac_ui (ref[0], n);\n  mpz_mfac_uiui (res, n, 2);\n  MPZ_CHECK_FORMAT (res);\n  if (mpz_cmp (ref[0], res) != 0)\n    {\n      printf (\"mpz_mfac_uiui(%lu,1) wrong\\n\", n);\n      printf (\"  got  \"); mpz_out_str (stdout, 10, res); printf(\"\\n\");\n      printf (\"  want \"); mpz_out_str (stdout, 10, ref[0]); printf(\"\\n\");\n      abort ();\n    }\n\n  n++;\n  mpz_2fac_ui (ref[0], n);\n  mpz_mfac_uiui (res, n, 2);\n  MPZ_CHECK_FORMAT (res);\n  if (mpz_cmp (ref[0], res) != 0)\n    {\n      printf (\"mpz_mfac_uiui(%lu,2) wrong\\n\", n);\n      printf (\"  got  \"); mpz_out_str (stdout, 10, res); printf(\"\\n\");\n      printf (\"  want \"); mpz_out_str (stdout, 10, ref[0]); printf(\"\\n\");\n      abort ();\n    }\n\n  for (m = 0; m < MULTIFAC_WHEEL; m++)\n    mpz_clear (ref[m]);\n  for (m2 = 0; m2 < MULTIFAC_WHEEL2; m2++)\n    mpz_clear (ref2[m2]);\n  mpz_clear (res);\n\n  tests_end ();\n\n  exit (0);\n}",
      "lines": 100,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-mul.c": {
    "one": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\none (int i, mpz_t multiplicand, mpz_t multiplier)\n{\n  mpz_t product, ref_product;\n\n  mpz_init (product);\n  mpz_init (ref_product);\n\n  /* Test plain multiplication comparing results against reference code.  */\n  mpz_mul (product, multiplier, multiplicand);\n  refmpz_mul (ref_product, multiplier, multiplicand);\n  if (mpz_cmp (product, ref_product))\n    dump_abort (i, \"incorrect plain product\",\n\t\tmultiplier, multiplicand, product, ref_product);\n\n  /* Test squaring, comparing results against plain multiplication  */\n  mpz_mul (product, multiplier, multiplier);\n  mpz_set (multiplicand, multiplier);\n  mpz_mul (ref_product, multiplier, multiplicand);\n  if (mpz_cmp (product, ref_product))\n    dump_abort (i, \"incorrect square product\",\n\t\tmultiplier, multiplier, product, ref_product);\n\n  mpz_clear (product);\n  mpz_clear (ref_product);\n}",
      "lines": 26,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t op1, op2;\n  int i;\n  int fft_max_2exp;\n\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range, fsize_range;\n\n  tests_start ();\n  rands = RANDS;\n\n  extra_fft = getenv (\"GMP_CHECK_FFT\");\n  fft_max_2exp = 0;\n  if (extra_fft != NULL)\n    fft_max_2exp = atoi (extra_fft);\n\n  if (fft_max_2exp <= 1)\t/* compat with old use of GMP_CHECK_FFT */\n    fft_max_2exp = 22;\t\t/* default limit, good for any machine */\n\n  mpz_init (bs);\n  mpz_init (op1);\n  mpz_init (op2);\n\n  fsize_range = 4 << 8;\t\t/* a fraction 1/256 of size_range */\n  for (i = 0;; i++)\n    {\n      size_range = fsize_range >> 8;\n      fsize_range = fsize_range * 33 / 32;\n\n      if (size_range > fft_max_2exp)\n\tbreak;\n\n      mpz_urandomb (bs, rands, size_range);\n      mpz_rrandomb (op1, rands, mpz_get_ui (bs));\n      if (i & 1)\n\tmpz_urandomb (bs, rands, size_range);\n      mpz_rrandomb (op2, rands, mpz_get_ui (bs));\n\n      mpz_urandomb (bs, rands, 4);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 0x3) == 0)\n\tmpz_neg (op1, op1);\n      if ((bsi & 0xC) == 0)\n\tmpz_neg (op2, op2);\n\n      /* printf (\"%d %d\\n\", SIZ (op1), SIZ (op2)); */\n      one (i, op2, op1);\n    }\n\n  for (i = -50; i < 0; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % fft_max_2exp;\n\n      mpz_urandomb (bs, rands, size_range);\n      mpz_rrandomb (op1, rands, mpz_get_ui (bs) + FFT_MIN_BITSIZE);\n      mpz_urandomb (bs, rands, size_range);\n      mpz_rrandomb (op2, rands, mpz_get_ui (bs) + FFT_MIN_BITSIZE);\n\n      /* printf (\"%d: %d %d\\n\", i, SIZ (op1), SIZ (op2)); */\n      fflush (stdout);\n      one (-1, op2, op1);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (op1);\n  mpz_clear (op2);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 74,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "refmpz_mul": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static void\nrefmpz_mul (mpz_t w, const mpz_t u, const mpz_t v)\n{\n  mp_size_t usize = u->_mp_size;\n  mp_size_t vsize = v->_mp_size;\n  mp_size_t wsize;\n  mp_size_t sign_product;\n  mp_ptr up, vp;\n  mp_ptr wp;\n  mp_size_t talloc;\n\n  sign_product = usize ^ vsize;\n  usize = ABS (usize);\n  vsize = ABS (vsize);\n\n  if (usize == 0 || vsize == 0)\n    {\n      SIZ (w) = 0;\n      return;\n    }\n\n  talloc = usize + vsize;\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  wp = __GMP_ALLOCATE_FUNC_LIMBS (talloc);\n\n  if (usize > vsize)\n    refmpn_mul (wp, up, usize, vp, vsize);\n  else\n    refmpn_mul (wp, vp, vsize, up, usize);\n  wsize = usize + vsize;\n  wsize -= wp[wsize - 1] == 0;\n  MPZ_REALLOC (w, wsize);\n  MPN_COPY (PTR(w), wp, wsize);\n\n  SIZ(w) = sign_product < 0 ? -wsize : wsize;\n  __GMP_FREE_FUNC_LIMBS (wp, talloc);\n}",
      "lines": 40,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_abort": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "void\ndump_abort (int i, const char *s,\n            mpz_t op1, mpz_t op2, mpz_t product, mpz_t ref_product)\n{\n  mp_size_t b, e;\n  fprintf (stderr, \"ERROR: %s in test %d\\n\", s, i);\n  fprintf (stderr, \"op1          = \"); debug_mp (op1);\n  fprintf (stderr, \"op2          = \"); debug_mp (op2);\n  fprintf (stderr, \"    product  = \"); debug_mp (product);\n  fprintf (stderr, \"ref_product  = \"); debug_mp (ref_product);\n  for (b = 0; b < ABSIZ(ref_product); b++)\n    if (PTR(ref_product)[b] != PTR(product)[b])\n      break;\n  for (e = ABSIZ(ref_product) - 1; e >= 0; e--)\n    if (PTR(ref_product)[e] != PTR(product)[e])\n      break;\n  printf (\"ERRORS in %ld--%ld\\n\", b, e);\n  abort();\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "debug_mp": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x)\n{\n  size_t siz = mpz_sizeinbase (x, 16);\n\n  if (siz > 65)\n    {\n      mpz_t q;\n      mpz_init (q);\n      mpz_tdiv_q_2exp (q, x, 4 * (mpz_sizeinbase (x, 16) - 25));\n      gmp_fprintf (stderr, \"%ZX...\", q);\n      mpz_tdiv_r_2exp (q, x, 4 * 25);\n      gmp_fprintf (stderr, \"%025ZX [%d]\\n\", q, (int) siz);\n      mpz_clear (q);\n    }\n  else\n    {\n      gmp_fprintf (stderr, \"%ZX\\n\", x);\n    }\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-mul_i.c": {
    "compare_si": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void\ncompare_si (long y)\n{\n  if (mpz_cmp (got, want) != 0)\n    {\n      printf    (\"mpz_mul_si wrong\\n\");\n      mpz_trace (\"  x\", x);\n      printf    (\"  y=%ld (0x%lX)\\n\", y, y);\n      mpz_trace (\"  got \", got);\n      mpz_trace (\"  want\", want);\n      abort ();\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "compare_ui": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\ncompare_ui (unsigned long y)\n{\n  if (mpz_cmp (got, want) != 0)\n    {\n      printf    (\"mpz_mul_ui wrong\\n\");\n      mpz_trace (\"  x\", x);\n      printf    (\"  y=%lu (0x%lX)\\n\", y, y);\n      mpz_trace (\"  got \", got);\n      mpz_trace (\"  want\", want);\n      abort ();\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_samples": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\ncheck_samples (void)\n{\n  {\n    long  y;\n\n    mpz_set_ui (x, 1L);\n    y = 0;\n    mpz_mul_si (got, x, y);\n    mpz_set_si (want, y);\n    compare_si (y);\n\n    mpz_set_ui (x, 1L);\n    y = 1;\n    mpz_mul_si (got, x, y);\n    mpz_set_si (want, y);\n    compare_si (y);\n\n    mpz_set_ui (x, 1L);\n    y = -1;\n    mpz_mul_si (got, x, y);\n    mpz_set_si (want, y);\n    compare_si (y);\n\n    mpz_set_ui (x, 1L);\n    y = LONG_MIN;\n    mpz_mul_si (got, x, y);\n    mpz_set_si (want, y);\n    compare_si (y);\n\n    mpz_set_ui (x, 1L);\n    y = LONG_MAX;\n    mpz_mul_si (got, x, y);\n    mpz_set_si (want, y);\n    compare_si (y);\n  }\n\n  {\n    unsigned long y;\n\n    mpz_set_ui (x, 1L);\n    y = 0;\n    mpz_mul_ui (got, x, y);\n    mpz_set_ui (want, y);\n    compare_ui (y);\n\n    mpz_set_ui (x, 1L);\n    y = 1;\n    mpz_mul_ui (got, x, y);\n    mpz_set_ui (want, y);\n    compare_ui (y);\n\n    mpz_set_ui (x, 1L);\n    y = ULONG_MAX;\n    mpz_mul_ui (got, x, y);\n    mpz_set_ui (want, y);\n    compare_ui (y);\n  }\n}",
      "lines": 59,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  tests_start ();\n\n  mpz_init (x);\n  mpz_init (got);\n  mpz_init (want);\n\n  check_samples ();\n\n  mpz_clear (x);\n  mpz_clear (got);\n  mpz_clear (want);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-nextprime.c": {
    "refmpz_nextprime": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "void\nrefmpz_nextprime (mpz_ptr p, mpz_srcptr t)\n{\n  mpz_add_ui (p, t, 1L);\n  while (! mpz_probab_prime_p (p, 10))\n    mpz_add_ui (p, p, 1L);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "run": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nrun (const char *start, int reps, const char *end, short diffs[])\n{\n  mpz_t x, y;\n  int i;\n\n  mpz_init_set_str (x, start, 0);\n  mpz_init (y);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_nextprime (y, x);\n      mpz_sub (x, y, x);\n      if (diffs != NULL && diffs[i] != mpz_get_ui (x))\n\t{\n\t  gmp_printf (\"diff list discrepancy\\n\");\n\t  abort ();\n\t}\n      mpz_set (x, y);\n    }\n\n  mpz_set_str (y, end, 0);\n\n  if (mpz_cmp (x, y) != 0)\n    {\n      gmp_printf (\"got  %Zx\\n\", x);\n      gmp_printf (\"want %Zx\\n\", y);\n      abort ();\n    }\n\n  mpz_clear (y);\n  mpz_clear (x);\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int reps = 20;\n  gmp_randstate_ptr rands;\n  mpz_t bs, x, nxtp, ref_nxtp;\n  unsigned long size_range;\n\n  tests_start();\n  rands = RANDS;\n\n  run (\"2\", 1000, \"0x1ef7\", diff1);\n\n  run (\"3\", 1000 - 1, \"0x1ef7\", NULL);\n\n  run (\"0x8a43866f5776ccd5b02186e90d28946aeb0ed914\", 50,\n       \"0x8a43866f5776ccd5b02186e90d28946aeb0eeec5\", diff3);\n\n  run (\"0x10000000000000000000000000000000000000\", 50,\n       \"0x100000000000000000000000000000000010ab\", diff4);\n\n  run (\"0x1c2c26be55317530311facb648ea06b359b969715db83292ab8cf898d8b1b\", 50,\n       \"0x1c2c26be55317530311facb648ea06b359b969715db83292ab8cf898da957\", diff5);\n\n  mpz_init (bs);\n  mpz_init (x);\n  mpz_init (nxtp);\n  mpz_init (ref_nxtp);\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 8 + 2; /* 0..1024 bit operands */\n\n      mpz_urandomb (bs, rands, size_range);\n      mpz_rrandomb (x, rands, mpz_get_ui (bs));\n\n/*      gmp_printf (\"%ld: %Zd\\n\", mpz_sizeinbase (x, 2), x); */\n\n      mpz_nextprime (nxtp, x);\n      refmpz_nextprime (ref_nxtp, x);\n      if (mpz_cmp (nxtp, ref_nxtp) != 0)\n\tabort ();\n    }\n\n  mpz_clear (bs);\n  mpz_clear (x);\n  mpz_clear (nxtp);\n  mpz_clear (ref_nxtp);\n\n  tests_end ();\n  return 0;\n}",
      "lines": 57,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-oddeven.c": {
    "check_data": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char  *n;\n    int          odd, even;\n  } data[] = {\n    {   \"0\", 0, 1 },\n    {   \"1\", 1, 0 },\n    {   \"2\", 0, 1 },\n    {   \"3\", 1, 0 },\n    {   \"4\", 0, 1 },\n\n    {  \"-4\", 0, 1 },\n    {  \"-3\", 1, 0 },\n    {  \"-2\", 0, 1 },\n    {  \"-1\", 1, 0 },\n\n    {  \"0x1000000000000000000000000000000000000000000000000000\", 0, 1 },\n    {  \"0x1000000000000000000000000000000000000000000000000001\", 1, 0 },\n    {  \"0x1000000000000000000000000000000000000000000000000002\", 0, 1 },\n    {  \"0x1000000000000000000000000000000000000000000000000003\", 1, 0 },\n\n    { \"-0x1000000000000000000000000000000000000000000000000004\", 0, 1 },\n    { \"-0x1000000000000000000000000000000000000000000000000003\", 1, 0 },\n    { \"-0x1000000000000000000000000000000000000000000000000002\", 0, 1 },\n    { \"-0x1000000000000000000000000000000000000000000000000001\", 1, 0 },\n  };\n\n  mpz_t  n;\n  int    i;\n\n  mpz_init (n);\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (n, data[i].n, 0);\n\n      if ((mpz_odd_p (n) != 0) != data[i].odd)\n\t{\n\t  printf (\"mpz_odd_p wrong on data[%d]\\n\", i);\n\t  abort();\n\t}\n\n      if ((mpz_even_p (n) != 0) != data[i].even)\n\t{\n\t  printf (\"mpz_even_p wrong on data[%d]\\n\", i);\n\t  abort();\n\t}\n    }\n\n  mpz_clear (n);\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-perfpow.c": {
    "check_tests": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "void\ncheck_tests ()\n{\n  mpz_t x;\n  int i;\n  int got, want;\n\n  mpz_init (x);\n\n  for (i = 0; tests[i].num_as_str != NULL; i++)\n    {\n      mpz_set_str (x, tests[i].num_as_str, 0);\n      got = mpz_perfect_power_p (x);\n      want = tests[i].want;\n      if (got != want)\n\t{\n\t  fprintf (stderr, \"mpz_perfect_power_p returns %d when %d was expected\\n\", got, want);\n\t  fprintf (stderr, \"fault operand: %s\\n\", tests[i].num_as_str);\n\t  abort ();\n\t}\n    }\n\n  mpz_clear (x);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "void\ncheck_random (int reps)\n{\n  mpz_t n, np, temp, primes[NRP];\n  int i, j, k, unique, destroy, res;\n  unsigned long int nrprimes, primebits;\n  mp_limb_t g, exp[NRP], e;\n  gmp_randstate_ptr rands;\n\n  rands = RANDS;\n\n  mpz_init (n);\n  mpz_init (np);\n  mpz_init (temp);\n\n  for (i = 0; i < NRP; i++)\n    mpz_init (primes[i]);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (np, rands, 32);\n      nrprimes = mpz_get_ui (np) % NRP + 1; /* 1-NRP unique primes */\n\n      mpz_urandomb (np, rands, 32);\n      g = mpz_get_ui (np) % 32 + 2; /* gcd 2-33 */\n\n      for (j = 0; j < nrprimes;)\n\t{\n\t  mpz_urandomb (np, rands, 32);\n\t  primebits = mpz_get_ui (np) % 100 + 3; /* 3-102 bit primes */\n\t  mpz_urandomb (primes[j], rands, primebits);\n\t  mpz_nextprime (primes[j], primes[j]);\n\t  unique = 1;\n\t  for (k = 0; k < j; k++)\n\t    {\n\t      if (mpz_cmp (primes[j], primes[k]) == 0)\n\t\t{\n\t\t  unique = 0;\n\t\t  break;\n\t\t}\n\t    }\n\t  if (unique)\n\t    {\n\t      mpz_urandomb (np, rands, 32);\n\t      e = 371 / (10 * primebits) + mpz_get_ui (np) % 11 + 1; /* Magic constants */\n\t      exp[j++] = g * e;\n\t    }\n\t}\n\n      if (nrprimes > 1)\n\t{\n\t  /* Destroy d exponents, d in [1, nrprimes - 1] */\n\t  if (nrprimes == 2)\n\t    {\n\t      destroy = 1;\n\t    }\n\t  else\n\t    {\n\t      mpz_urandomb (np, rands, 32);\n\t      destroy = mpz_get_ui (np) % (nrprimes - 2);\n\t    }\n\n\t  g = exp[destroy];\n\t  for (k = destroy + 1; k < nrprimes; k++)\n\t    g = mpn_gcd_1 (&g, 1, exp[k]);\n\n\t  for (j = 0; j < destroy; j++)\n\t    {\n\t      mpz_urandomb (np, rands, 32);\n\t      e = mpz_get_ui (np) % 50 + 1;\n\t      while (mpn_gcd_1 (&g, 1, e) > 1)\n\t\te++;\n\n\t      exp[j] = e;\n\t    }\n\t}\n\n      /* Compute n */\n      mpz_pow_ui (n, primes[0], exp[0]);\n      for (j = 1; j < nrprimes; j++)\n\t{\n\t  mpz_pow_ui (temp, primes[j], exp[j]);\n\t  mpz_mul (n, n, temp);\n\t}\n\n      res = mpz_perfect_power_p (n);\n\n      if (nrprimes == 1)\n\t{\n\tif (res == 0 && exp[0] > 1)\n\t  {\n\t    printf(\"n is a perfect power, perfpow_p disagrees\\n\");\n\t    gmp_printf(\"n = %Zu\\nprimes[0] = %Zu\\nexp[0] = %lu\\n\", n, primes[0], exp[0]);\n\t    abort ();\n\t  }\n\telse if (res == 1 && exp[0] == 1)\n\t  {\n\t    gmp_printf(\"n = %Zu\\n\", n);\n\t    printf(\"n is now a prime number, but perfpow_p still believes n is a perfect power\\n\");\n\t    abort ();\n\t  }\n\t}\n      else\n\t{\n\t  if (res == 1 && destroy != 0)\n\t    {\n\t      gmp_printf(\"n = %Zu\\nn was destroyed, but perfpow_p still believes n is a perfect power\\n\", n);\n\t      abort ();\n\t    }\n\t  else if (res == 0 && destroy == 0)\n\t    {\n\t      gmp_printf(\"n = %Zu\\nn is a perfect power, perfpow_p disagrees\\n\", n);\n\t      abort ();\n\t    }\n\t}\n    }\n\n  mpz_clear (n);\n  mpz_clear (np);\n  mpz_clear (temp);\n  for (i = 0; i < NRP; i++)\n    mpz_clear (primes[i]);\n}",
      "lines": 123,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int n_tests;\n\n  tests_start ();\n  mp_trace_base = -16;\n\n  check_tests ();\n\n  n_tests = 500;\n  if (argc == 2)\n    n_tests = atoi (argv[1]);\n  check_random (n_tests);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-perfsqr.c": {
    "check_modulo": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\ncheck_modulo (void)\n{\n  static const unsigned long  divisor[] = PERFSQR_DIVISORS;\n  unsigned long  i, j;\n\n  mpz_t  alldiv, others, n;\n\n  mpz_init (alldiv);\n  mpz_init (others);\n  mpz_init (n);\n\n  /* product of all divisors */\n  mpz_set_ui (alldiv, 1L);\n  for (i = 0; i < numberof (divisor); i++)\n    mpz_mul_ui (alldiv, alldiv, divisor[i]);\n\n  for (i = 0; i < numberof (divisor); i++)\n    {\n      /* product of all divisors except i */\n      mpz_set_ui (others, 1L);\n      for (j = 0; j < numberof (divisor); j++)\n        if (i != j)\n          mpz_mul_ui (others, others, divisor[j]);\n\n      for (j = 1; j <= divisor[i]; j++)\n        {\n          /* square */\n          mpz_mul_ui (n, others, j);\n          mpz_mul (n, n, n);\n          if (! mpz_perfect_square_p (n))\n            {\n              printf (\"mpz_perfect_square_p got 0, want 1\\n\");\n              mpz_trace (\"  n\", n);\n              abort ();\n            }\n        }\n    }\n\n  mpz_clear (alldiv);\n  mpz_clear (others);\n  mpz_clear (n);\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_sqrt": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\ncheck_sqrt (int reps)\n{\n  mpz_t x2, x2t, x;\n  mp_size_t x2n;\n  int res;\n  int i;\n  /* int cnt = 0; */\n  gmp_randstate_ptr rands = RANDS;\n  mpz_t bs;\n\n  mpz_init (bs);\n\n  mpz_init (x2);\n  mpz_init (x);\n  mpz_init (x2t);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 9);\n      x2n = mpz_get_ui (bs);\n      mpz_rrandomb (x2, rands, x2n);\n      /* mpz_out_str (stdout, -16, x2); puts (\"\"); */\n\n      res = mpz_perfect_square_p (x2);\n      mpz_sqrt (x, x2);\n      mpz_mul (x2t, x, x);\n\n      if (res != (mpz_cmp (x2, x2t) == 0))\n        {\n          printf    (\"mpz_perfect_square_p and mpz_sqrt differ\\n\");\n          mpz_trace (\"   x  \", x);\n          mpz_trace (\"   x2 \", x2);\n          mpz_trace (\"   x2t\", x2t);\n          printf    (\"   mpz_perfect_square_p %d\\n\", res);\n          printf    (\"   mpz_sqrt             %d\\n\", mpz_cmp (x2, x2t) == 0);\n          abort ();\n        }\n\n      /* cnt += res != 0; */\n    }\n  /* printf (\"%d/%d perfect squares\\n\", cnt, reps); */\n\n  mpz_clear (bs);\n  mpz_clear (x2);\n  mpz_clear (x);\n  mpz_clear (x2t);\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int reps = 200000;\n\n  tests_start ();\n  mp_trace_base = -16;\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  check_modulo ();\n  check_sqrt (reps);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-popcount.c": {
    "check_onebit": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\ncheck_onebit (void)\n{\n  mpz_t          n;\n  unsigned long  i, got;\n\n  mpz_init (n);\n  for (i = 0; i < 5 * GMP_LIMB_BITS; i++)\n    {\n      mpz_setbit (n, i);\n      got = mpz_popcount (n);\n      if (got != 1)\n\t{\n\t  printf (\"mpz_popcount wrong on single bit at %lu\\n\", i);\n\t  printf (\"   got %lu, want 1\\n\", got);\n\t  abort();\n\t}\n      mpz_clrbit (n, i);\n    }\n  mpz_clear (n);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_data": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    const char     *n;\n    unsigned long  want;\n  } data[] = {\n    { \"-1\", ~ (unsigned long) 0 },\n    { \"-12345678\", ~ (unsigned long) 0 },\n    { \"0\", 0 },\n    { \"1\", 1 },\n    { \"3\", 2 },\n    { \"5\", 2 },\n    { \"0xFFFF\", 16 },\n    { \"0xFFFFFFFF\", 32 },\n    { \"0xFFFFFFFFFFFFFFFF\", 64 },\n    { \"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", 128 },\n  };\n\n  unsigned long   got;\n  int    i;\n  mpz_t  n;\n\n  mpz_init (n);\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (n, data[i].n, 0);\n      got = mpz_popcount (n);\n      if (got != data[i].want)\n\t{\n\t  printf (\"mpz_popcount wrong at data[%d]\\n\", i);\n\t  printf (\"   n     \\\"%s\\\"\\n\", data[i].n);\n\t  printf (\"         \");   mpz_out_str (stdout, 10, n); printf (\"\\n\");\n\t  printf (\"         0x\"); mpz_out_str (stdout, 16, n); printf (\"\\n\");\n\t  printf (\"   got   %lu\\n\", got);\n\t  printf (\"   want  %lu\\n\", data[i].want);\n\t  abort ();\n\t}\n    }\n  mpz_clear (n);\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "refmpz_popcount": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "unsigned long\nrefmpz_popcount (mpz_t arg)\n{\n  mp_size_t n, i;\n  unsigned long cnt;\n  mp_limb_t x;\n\n  n = SIZ(arg);\n  if (n < 0)\n    return ~(unsigned long) 0;\n\n  cnt = 0;\n  for (i = 0; i < n; i++)\n    {\n      x = PTR(arg)[i];\n      while (x != 0)\n\t{\n\t  cnt += (x & 1);\n\t  x >>= 1;\n\t}\n    }\n  return cnt;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "check_random": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void\ncheck_random (void)\n{\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  mpz_t arg;\n  unsigned long arg_size, size_range;\n  unsigned long got, ref;\n  int i;\n\n  rands = RANDS;\n\n  mpz_init (bs);\n  mpz_init (arg);\n\n  for (i = 0; i < 10000; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 11 + 2; /* 0..4096 bit operands */\n\n      mpz_urandomb (bs, rands, size_range);\n      arg_size = mpz_get_ui (bs);\n      mpz_rrandomb (arg, rands, arg_size);\n\n      got = mpz_popcount (arg);\n      ref = refmpz_popcount (arg);\n      if (got != ref)\n\t{\n\t  printf (\"mpz_popcount wrong on random\\n\");\n\t  printf (\"         \");   mpz_out_str (stdout, 10, arg); printf (\"\\n\");\n\t  printf (\"         0x\"); mpz_out_str (stdout, 16, arg); printf (\"\\n\");\n\t  printf (\"   got   %lu\\n\", got);\n\t  printf (\"   want  %lu\\n\", ref);\n\t  abort ();\n\t}\n    }\n  mpz_clear (arg);\n  mpz_clear (bs);\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_onebit ();\n  check_data ();\n  check_random ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-pow.c": {
    "check_one": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "void\ncheck_one (mpz_srcptr want, mpz_srcptr base, unsigned long exp)\n{\n  mpz_t  got;\n\n  mpz_init (got);\n\n  MPZ_CHECK_FORMAT (want);\n\n  mpz_pow_ui (got, base, exp);\n  if (mpz_cmp (got, want))\n    {\n      printf (\"mpz_pow_ui wrong\\n\");\n      mpz_trace (\"  base\", base);\n      printf    (\"  exp = %lu (0x%lX)\\n\", exp, exp);\n      mpz_trace (\"  got \", got);\n      mpz_trace (\"  want\", want);\n      abort ();\n    }\n\n  mpz_set (got, base);\n  mpz_pow_ui (got, got, exp);\n  if (mpz_cmp (got, want))\n    {\n      printf (\"mpz_pow_ui wrong\\n\");\n      mpz_trace (\"  base\", base);\n      printf    (\"  exp = %lu (0x%lX)\\n\", exp, exp);\n      mpz_trace (\"  got \", got);\n      mpz_trace (\"  want\", want);\n      abort ();\n    }\n\n  if (mpz_fits_ulong_p (base))\n    {\n      unsigned long  base_u = mpz_get_ui (base);\n      mpz_ui_pow_ui (got, base_u, exp);\n      if (mpz_cmp (got, want))\n\t{\n\t  printf    (\"mpz_ui_pow_ui wrong\\n\");\n\t  printf    (\"  base=%lu (0x%lX)\\n\", base_u, base_u);\n\t  printf    (\"  exp = %lu (0x%lX)\\n\", exp, exp);\n\t  mpz_trace (\"  got \", got);\n\t  mpz_trace (\"  want\", want);\n\t  abort ();\n\t}\n    }\n\n  mpz_clear (got);\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_base": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\ncheck_base (mpz_srcptr base)\n{\n  unsigned long  exp;\n  mpz_t          want;\n\n  mpz_init (want);\n  mpz_set_ui (want, 1L);\n\n  for (exp = 0; exp < 20; exp++)\n    {\n      check_one (want, base, exp);\n      mpz_mul (want, want, base);\n    }\n\n  mpz_clear (want);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  static const struct {\n    const char *base;\n  } data[] = {\n    { \"0\" },\n    { \"1\" },\n    { \"2\" },\n    { \"3\" },\n    { \"4\" },\n    { \"5\" },\n    { \"6\" },\n    { \"10\" },\n    { \"15\" },\n    { \"16\" },\n\n    { \"0x1F\" },\n    { \"0xFF\" },\n    { \"0x1001\" },\n    { \"0xFFFF\" },\n    { \"0x10000001\" },\n    { \"0x1000000000000001\" },\n\n    /* actual size closest to estimate */\n    { \"0xFFFFFFFF\" },\n    { \"0xFFFFFFFFFFFFFFFF\" },\n\n    /* same after rshift */\n    { \"0xFFFFFFFF0\" },\n    { \"0xFFFFFFFF00\" },\n    { \"0xFFFFFFFFFFFFFFFF0\" },\n    { \"0xFFFFFFFFFFFFFFFF00\" },\n\n    /* change from 2 limbs to 1 after rshift */\n    { \"0x180000000\" },\n    { \"0x18000000000000000\" },\n\n    /* change from 3 limbs to 2 after rshift */\n    { \"0x18000000100000000\" },\n    { \"0x180000000000000010000000000000000\" },\n\n    /* handling of absolute value */\n    { \"-0x80000000\" },\n    { \"-0x8000000000000000\" },\n\n    /* low zero limb, and size>2, checking argument overlap detection */\n    { \"0x3000000000000000300000000000000030000000000000000\" },\n  };\n\n  mpz_t  base;\n  int    i;\n\n  mpz_init (base);\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_set_str_or_abort (base, data[i].base, 0);\n      check_base (base);\n    }\n\n  mpz_clear (base);\n}",
      "lines": 63,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_random": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "void\ncheck_random (int reps)\n{\n  mpz_t              base, want;\n  mp_size_t          base_size;\n  int                i;\n  unsigned long      size_range, exp;\n  gmp_randstate_ptr  rands = RANDS;\n\n  mpz_init (base);\n  mpz_init (want);\n\n  for (i = 0; i < reps; i++)\n    {\n      /* exponentially random 0 to 2^13 bits for base */\n      mpz_urandomb (want, rands, 32);\n      size_range = mpz_get_ui (want) % 12 + 2;\n      mpz_urandomb (want, rands, size_range);\n      base_size = mpz_get_ui (want);\n      mpz_rrandomb (base, rands, base_size);\n\n      /* randomly signed base */\n      mpz_urandomb (want, rands, 2);\n      if ((mpz_get_ui (want) & 1) != 0)\n\tmpz_neg (base, base);\n\n      /* random 5 bits for exponent */\n      mpz_urandomb (want, rands, 5L);\n      exp = mpz_get_ui (want);\n\n      refmpz_pow_ui (want, base, exp);\n      check_one (want, base, exp);\n    }\n\n  mpz_clear (base);\n  mpz_clear (want);\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int reps = 5000;\n\n  /* dummy call to drag in refmpn.o for testing mpz/n_pow_ui.c with\n     refmpn_mul_2 */\n  refmpn_zero_p (NULL, (mp_size_t) 0);\n\n  tests_start ();\n  mp_trace_base = -16;\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  check_various ();\n  check_random (reps);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-powm.c": {
    "allsizes_seen": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nallsizes_seen (unsigned int *allsizes)\n{\n  mp_size_t i;\n\n  for (i = 1; i < MUL_TOOM22_THRESHOLD + 4; i++)\n    if (allsizes[i] < 4)\n      return 0;\n  return 1;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t base, exp, mod;\n  mpz_t r1, r2, t1, exp2, base2;\n  mp_size_t base_size, exp_size, mod_size;\n  int i;\n  int reps = 1000;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n  unsigned int allsizes[1 << (SIZEM + 2 - 1)];\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  mpz_init (base);\n  mpz_init (exp);\n  mpz_init (mod);\n  mpz_init (r1);\n  mpz_init (r2);\n  mpz_init (t1);\n  mpz_init (exp2);\n  mpz_init (base2);\n\n  memset (allsizes, 0, (1 << (SIZEM + 2 - 1)) * sizeof (int));\n\n  for (i = 0; i < reps || ! allsizes_seen (allsizes); i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % SIZEM + 2;\n\n      do  /* Loop until mathematically well-defined.  */\n\t{\n\t  mpz_urandomb (bs, rands, size_range);\n\t  base_size = mpz_get_ui (bs);\n\t  mpz_rrandomb (base, rands, base_size);\n\n\t  mpz_urandomb (bs, rands, 7L);\n\t  exp_size = mpz_get_ui (bs);\n\t  mpz_rrandomb (exp, rands, exp_size);\n\t}\n      while (mpz_cmp_ui (base, 0) == 0 && mpz_cmp_ui (exp, 0) == 0);\n\n      do\n        {\n\t  mpz_urandomb (bs, rands, size_range);\n\t  mod_size = mpz_get_ui (bs);\n\t  mpz_rrandomb (mod, rands, mod_size);\n\t}\n      while (mpz_cmp_ui (mod, 0) == 0);\n\n      allsizes[SIZ(mod)] += 1;\n\n      mpz_urandomb (bs, rands, 2);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (base, base);\n\n      /* printf (\"%ld %ld %ld\\n\", SIZ (base), SIZ (exp), SIZ (mod)); */\n\n      mpz_set_ui (r2, 1);\n      mpz_mod (base2, base, mod);\n      mpz_set (exp2, exp);\n      mpz_mod (r2, r2, mod);\n\n      for (;;)\n\t{\n\t  if (mpz_tstbit (exp2, 0))\n\t    {\n\t      mpz_mul (r2, r2, base2);\n\t      mpz_mod (r2, r2, mod);\n\t    }\n\t  if  (mpz_cmp_ui (exp2, 1) <= 0)\n\t    break;\n\t  mpz_mul (base2, base2, base2);\n\t  mpz_mod (base2, base2, mod);\n\t  mpz_tdiv_q_2exp (exp2, exp2, 1);\n\t}\n\n      mpz_powm (r1, base, exp, mod);\n      MPZ_CHECK_FORMAT (r1);\n\n      if (mpz_cmp (r1, r2) != 0)\n\t{\n\t  fprintf (stderr, \"\\nIncorrect results in test %d for operands:\\n\", i);\n\t  debug_mp (base, -16);\n\t  debug_mp (exp, -16);\n\t  debug_mp (mod, -16);\n\t  fprintf (stderr, \"mpz_powm result:\\n\");\n\t  debug_mp (r1, -16);\n\t  fprintf (stderr, \"reference result:\\n\");\n\t  debug_mp (r2, -16);\n\t  abort ();\n\t}\n\n      if (mpz_tdiv_ui (mod, 2) == 0)\n\tcontinue;\n\n      mpz_powm_sec (r1, base, exp, mod);\n      MPZ_CHECK_FORMAT (r1);\n\n      if (mpz_cmp (r1, r2) != 0)\n\t{\n\t  fprintf (stderr, \"\\nIncorrect results in test %d for operands:\\n\", i);\n\t  debug_mp (base, -16);\n\t  debug_mp (exp, -16);\n\t  debug_mp (mod, -16);\n\t  fprintf (stderr, \"mpz_powm_sec result:\\n\");\n\t  debug_mp (r1, -16);\n\t  fprintf (stderr, \"reference result:\\n\");\n\t  debug_mp (r2, -16);\n\t  abort ();\n\t}\n    }\n\n  mpz_clear (bs);\n  mpz_clear (base);\n  mpz_clear (exp);\n  mpz_clear (mod);\n  mpz_clear (r1);\n  mpz_clear (r2);\n  mpz_clear (t1);\n  mpz_clear (exp2);\n  mpz_clear (base2);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 133,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "debug_mp": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-powm_ui.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t base, exp, mod;\n  mpz_t r1, r2, base2;\n  mp_size_t base_size, exp_size, mod_size;\n  unsigned long int exp2;\n  int i;\n  int reps = 100;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n\n  tests_start ();\n  rands = RANDS;\n\n  TESTS_REPS (reps, argv, argc);\n\n  mpz_inits (bs, base, exp, mod, r1, r2, base2, NULL);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 18 + 2;\n\n      do  /* Loop until mathematically well-defined.  */\n\t{\n\t  mpz_urandomb (bs, rands, size_range);\n\t  base_size = mpz_get_ui (bs);\n\t  mpz_rrandomb (base, rands, base_size);\n\n\t  mpz_urandomb (bs, rands, 6L);\n\t  exp_size = mpz_get_ui (bs);\n\t  mpz_rrandomb (exp, rands, exp_size);\n\t  exp2 = mpz_getlimbn (exp, (mp_size_t) 0);\n\t}\n      while (mpz_cmp_ui (base, 0) == 0 && exp2 == 0);\n\n      do\n        {\n\t  mpz_urandomb (bs, rands, size_range);\n\t  mod_size = mpz_get_ui (bs);\n\t  mpz_rrandomb (mod, rands, mod_size);\n\t}\n      while (mpz_cmp_ui (mod, 0) == 0);\n\n      mpz_urandomb (bs, rands, 2);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (base, base);\n\n      /* printf (\"%ld %ld\\n\", SIZ (base), SIZ (mod)); */\n\n#if 0\n      putc ('\\n', stderr);\n      gmp_fprintf (stderr, \"B = 0x%Zx\\n\", base);\n      gmp_fprintf (stderr, \"M = 0x%Zx\\n\", mod);\n#endif\n\n      exp2 = mpz_getlimbn (exp, (mp_size_t) 0);\n      mpz_set_ui (r2, 1);\n      mpz_set (base2, base);\n      mpz_mod (r2, r2, mod);\t/* needed when exp==0 and mod==1 */\n      while (exp2 != 0)\n\t{\n\t  if (exp2 % 2 != 0)\n\t    {\n\t      mpz_mul (r2, r2, base2);\n\t      mpz_mod (r2, r2, mod);\n\t    }\n\t  mpz_mul (base2, base2, base2);\n\t  mpz_mod (base2, base2, mod);\n\t  exp2 = exp2 / 2;\n\t}\n\n      exp2 = mpz_getlimbn (exp, (mp_size_t) 0);\n      mpz_powm_ui (r1, base, exp2, mod);\n      MPZ_CHECK_FORMAT (r1);\n\n#if 0\n      gmp_fprintf (stderr, \"R   = 0x%Zx\\n\", r1);\n      gmp_fprintf (stderr, \"REF = 0x%Zx\\n\", r2);\n#endif\n\n      if (mpz_cmp (r1, r2) != 0)\n\t{\n\t  fprintf (stderr, \"\\ntest %d: Incorrect results for operands:\\n\", i);\n\t  gmp_fprintf (stderr, \"B = 0x%Zx\\n\", base);\n\t  gmp_fprintf (stderr, \"E = 0x%Zx\\n\", exp);\n\t  gmp_fprintf (stderr, \"M = 0x%Zx\\n\", mod);\n\t  gmp_fprintf (stderr, \"R   = 0x%Zx\\n\", r1);\n\t  gmp_fprintf (stderr, \"REF = 0x%Zx\\n\", r2);\n\t  abort ();\n\t}\n    }\n\n  mpz_clears (bs, base, exp, mod, r1, r2, base2, NULL);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 101,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-pprime_p.c": {
    "isprime": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nisprime (long n)\n{\n  long  i;\n\n  n = ABS(n);\n\n  if (n < 2)\n    return 0;\n  if (n == 2)\n    return 1;\n  if ((n & 1) == 0)\n    return 0;\n\n  for (i = 3; i < n; i++)\n    if ((n % i) == 0)\n      return 0;\n\n  return 1;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "check_one": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "void\ncheck_one (mpz_srcptr n, int want)\n{\n  int  got;\n\n  got = mpz_probab_prime_p (n, 25);\n\n  /* \"definitely prime\" is fine if we only wanted \"probably prime\" */\n  if (got == 2 && want == 1)\n    want = 2;\n\n  if (got != want)\n    {\n      printf (\"mpz_probab_prime_p\\n\");\n      mpz_trace (\"  n    \", n);\n      printf    (\"  got =%d\", got);\n      printf    (\"  want=%d\", want);\n      abort ();\n    }\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_pn": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "void\ncheck_pn (mpz_ptr n, int want)\n{\n  check_one (n, want);\n  mpz_neg (n, n);\n  check_one (n, want);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_small": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\ncheck_small (void)\n{\n  mpz_t  n;\n  long   i;\n\n  mpz_init (n);\n\n  for (i = 0; i < 300; i++)\n    {\n      mpz_set_si (n, i);\n      check_pn (n, isprime (i));\n    }\n\n  mpz_clear (n);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_composites": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void\ncheck_composites (int count)\n{\n  int i;\n  mpz_t a, b, n, bs;\n  unsigned long size_range, size;\n  gmp_randstate_ptr rands = RANDS;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (n);\n  mpz_init (bs);\n\n  for (i = 0; i < count; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 13 + 1; /* 0..8192 bit operands */\n\n      mpz_urandomb (bs, rands, size_range);\n      size = mpz_get_ui (bs);\n      mpz_rrandomb (a, rands, size);\n\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 13 + 1; /* 0..8192 bit operands */\n      mpz_rrandomb (b, rands, size);\n\n      /* Exclude trivial factors */\n      if (mpz_cmp_ui (a, 1) == 0)\n\tmpz_set_ui (a, 2);\n      if (mpz_cmp_ui (b, 1) == 0)\n\tmpz_set_ui (b, 2);\n\n      mpz_mul (n, a, b);\n\n      check_pn (n, 0);\n    }\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (n);\n  mpz_clear (bs);\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_primes": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "static void\ncheck_primes (void)\n{\n  static const char * const primes[] = {\n    \"2\", \"17\", \"65537\",\n    /* diffie-hellman-group1-sha1, also \"Well known group 2\" in RFC\n       2412, 2^1024 - 2^960 - 1 + 2^64 * { [2^894 pi] + 129093 } */\n    \"0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\"\n    \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\"\n    \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\"\n    \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\"\n    \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381\"\n    \"FFFFFFFFFFFFFFFF\",\n    NULL\n  };\n\n  mpz_t n;\n  int i;\n\n  mpz_init (n);\n\n  for (i = 0; primes[i]; i++)\n    {\n      mpz_set_str_or_abort (n, primes[i], 0);\n      check_one (n, 1);\n    }\n  mpz_clear (n);\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int count = 1000;\n\n  TESTS_REPS (count, argv, argc);\n\n  tests_start ();\n\n  check_small ();\n  check_composites (count);\n  check_primes ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-primorial_ui.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  unsigned long  n;\n  unsigned long  limit = 2222;\n  mpz_t          f, r;\n\n  tests_start ();\n\n  if (argc > 1 && argv[1][0] == 'x')\n    limit = ULONG_MAX;\n  else if (argc > 1)\n    limit = atoi (argv[1]);\n\n  /* for small limb testing */\n  limit = MIN (limit, MP_LIMB_T_MAX);\n\n  mpz_init_set_ui (f, 1);  /* 0# = 1 */\n  mpz_init (r);\n\n  for (n = 0; n < limit; n++)\n    {\n      mpz_primorial_ui (r, n);\n      MPZ_CHECK_FORMAT (r);\n\n      if (mpz_cmp (f, r) != 0)\n        {\n          printf (\"mpz_primorial_ui(%lu) wrong\\n\", n);\n          printf (\"  got  \"); mpz_out_str (stdout, 10, r); printf(\"\\n\");\n          printf (\"  want \"); mpz_out_str (stdout, 10, f); printf(\"\\n\");\n          abort ();\n        }\n\n      if (isprime (n+1))\n\tmpz_mul_ui (f, f, n+1);  /* p# = (p-1)# * (p) */\n    }\n\n  mpz_clear (f);\n  mpz_clear (r);\n\n  tests_end ();\n\n  exit (0);\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "isprime": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int\nisprime (unsigned long int t)\n{\n  unsigned long int q, r, d;\n\n  if (t < 3 || (t & 1) == 0)\n    return t == 2;\n\n  for (d = 3, r = 1; r != 0; d += 2)\n    {\n      q = t / d;\n      r = t - q * d;\n      if (q < d)\n\treturn 1;\n    }\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-remove.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  unsigned long int exp;\n  mpz_t t, dest, refdest, dividend, divisor;\n  mp_size_t dividend_size, divisor_size;\n  int i;\n  int reps = 1000;\n  unsigned long int pwr, refpwr;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long size_range;\n\n  tests_start ();\n  rands = RANDS;\n\n  if (argc == 2)\n    reps = atoi (argv[1]);\n\n  mpz_inits (bs, t, dest, refdest, dividend, divisor, NULL);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 18 + 1; /* 1..524288 bit operands */\n\n      do\n\t{\n\t  mpz_urandomb (bs, rands, size_range);\n\t  divisor_size = mpz_get_ui (bs);\n\t  mpz_rrandomb (divisor, rands, divisor_size);\n\t}\n      while (mpz_sgn (divisor) == 0);\n\n      mpz_urandomb (bs, rands, size_range);\n      dividend_size = mpz_get_ui (bs) + divisor_size;\n      mpz_rrandomb (dividend, rands, dividend_size);\n\n      mpz_urandomb (bs, rands, 32);\n      exp = mpz_get_ui (bs) % (5 + 10000 / mpz_sizeinbase (divisor, 2));\n      if (mpz_get_ui (bs) & 2)\n\tmpz_neg (divisor, divisor);\n      mpz_pow_ui (t, divisor, exp);\n      mpz_mul (dividend, dividend, t);\n\n      refpwr = mpz_refremove (refdest, dividend, divisor);\n      pwr = mpz_remove (dest, dividend, divisor);\n\n      if (refpwr != pwr || mpz_cmp (refdest, dest) != 0)\n\t{\n\t  fprintf (stderr, \"ERROR after %d tests\\n\", i);\n\t  fprintf (stderr, \"refpower = %lu\\n\", refpwr);\n\t  fprintf (stderr, \"   power = %lu\\n\", pwr);\n\t  fprintf (stderr, \"    op1 = \"); debug_mp (dividend);\n\t  fprintf (stderr, \"    op2 = \"); debug_mp (divisor);\n\t  fprintf (stderr, \"refdest = \"); debug_mp (refdest);\n\t  fprintf (stderr, \"   dest = \"); debug_mp (dest);\n\t  abort ();\n\t}\n    }\n\n  mpz_clears (bs, t, dest, refdest, dividend, divisor, NULL);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 66,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "mpz_refremove": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "unsigned long int\nmpz_refremove (mpz_t dest, const mpz_t src, const mpz_t f)\n{\n  unsigned long int pwr;\n\n  pwr = 0;\n\n  mpz_set (dest, src);\n  if (mpz_cmpabs_ui (f, 1) > 0)\n    {\n      mpz_t rem, x;\n\n      mpz_init (x);\n      mpz_init (rem);\n\n      for (;; pwr++)\n\t{\n\t  mpz_tdiv_qr (x, rem, dest, f);\n\t  if (mpz_cmp_ui (rem, 0) != 0)\n\t    break;\n\t  mpz_swap (dest, x);\n\t}\n\n      mpz_clear (x);\n      mpz_clear (rem);\n    }\n\n  return pwr;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    },
    "debug_mp": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x)\n{\n  size_t siz = mpz_sizeinbase (x, 16);\n\n  if (siz > 65)\n    {\n      mpz_t q;\n      mpz_init (q);\n      mpz_tdiv_q_2exp (q, x, 4 * (mpz_sizeinbase (x, 16) - 25));\n      gmp_fprintf (stderr, \"%ZX...\", q);\n      mpz_tdiv_r_2exp (q, x, 4 * 25);\n      gmp_fprintf (stderr, \"%025ZX [%d]\\n\", q, (int) siz);\n      mpz_clear (q);\n    }\n  else\n    {\n      gmp_fprintf (stderr, \"%ZX\\n\", x);\n    }\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-root.c": {
    "check_one": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\ncheck_one (mpz_t root1, mpz_t x2, unsigned long nth, int res, int i)\n{\n  mpz_t temp, temp2;\n  mpz_t root2, rem2;\n\n  mpz_init (root2);\n  mpz_init (rem2);\n  mpz_init (temp);\n  mpz_init (temp2);\n\n  MPZ_CHECK_FORMAT (root1);\n\n  mpz_rootrem (root2, rem2, x2, nth);\n  MPZ_CHECK_FORMAT (root2);\n  MPZ_CHECK_FORMAT (rem2);\n\n  mpz_pow_ui (temp, root1, nth);\n  MPZ_CHECK_FORMAT (temp);\n\n  mpz_add (temp2, temp, rem2);\n\n  /* Is power of result > argument?  */\n  if (mpz_cmp (root1, root2) != 0 || mpz_cmp (x2, temp2) != 0 || mpz_cmpabs (temp, x2) > 0 || res == mpz_cmp_ui (rem2, 0))\n    {\n      fprintf (stderr, \"ERROR after test %d\\n\", i);\n      debug_mp (x2, 10);\n      debug_mp (root1, 10);\n      debug_mp (root2, 10);\n      fprintf (stderr, \"nth: %lu ,res: %i\\n\", nth, res);\n      abort ();\n    }\n\n  if (nth > 1 && mpz_cmp_ui (temp, 1L) > 0 && ! mpz_perfect_power_p (temp))\n    {\n      fprintf (stderr, \"ERROR in mpz_perfect_power_p after test %d\\n\", i);\n      debug_mp (temp, 10);\n      debug_mp (root1, 10);\n      fprintf (stderr, \"nth: %lu\\n\", nth);\n      abort ();\n    }\n\n  if (nth <= 10000 && mpz_sgn(x2) > 0)\t\t/* skip too expensive test */\n    {\n      mpz_add_ui (temp2, root1, 1L);\n      mpz_pow_ui (temp2, temp2, nth);\n      MPZ_CHECK_FORMAT (temp2);\n\n      /* Is square of (result + 1) <= argument?  */\n      if (mpz_cmp (temp2, x2) <= 0)\n\t{\n\t  fprintf (stderr, \"ERROR after test %d\\n\", i);\n\t  debug_mp (x2, 10);\n\t  debug_mp (root1, 10);\n\t  fprintf (stderr, \"nth: %lu\\n\", nth);\n\t  abort ();\n\t}\n    }\n\n  mpz_clear (root2);\n  mpz_clear (rem2);\n  mpz_clear (temp);\n  mpz_clear (temp2);\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t x2;\n  mpz_t root1;\n  mp_size_t x2_size;\n  int i, res;\n  int reps = 500;\n  unsigned long nth;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  mpz_init (x2);\n  mpz_init (root1);\n\n  /* This triggers a gcc 4.3.2 bug */\n  mpz_set_str (x2, \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000000000000000000000000000000000000000000000000000000000002\", 16);\n  res = mpz_root (root1, x2, 2);\n  check_one (root1, x2, 2, res, -1);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 17 + 2;\n\n      mpz_urandomb (bs, rands, size_range);\n      x2_size = mpz_get_ui (bs) + 10;\n      mpz_rrandomb (x2, rands, x2_size);\n\n      mpz_urandomb (bs, rands, 15);\n      nth = mpz_getlimbn (bs, 0) % mpz_sizeinbase (x2, 2) + 2;\n\n      res = mpz_root (root1, x2, nth);\n\n      mpz_urandomb (bs, rands, 4);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\t{\n\t  /* With 50% probability, set x2 near a perfect power.  */\n\t  mpz_pow_ui (x2, root1, nth);\n\t  if ((bsi & 2) != 0)\n\t    {\n\t      mpz_sub_ui (x2, x2, bsi >> 2);\n\t      mpz_abs (x2, x2);\n\t    }\n\t  else\n\t    mpz_add_ui (x2, x2, bsi >> 2);\n\t  res = mpz_root (root1, x2, nth);\n\t}\n\n      check_one (root1, x2, nth, res, i);\n\n      if (((nth & 1) != 0) && ((bsi & 2) != 0))\n\t{\n\t  mpz_neg (x2, x2);\n\t  mpz_neg (root1, root1);\n\t  check_one (root1, x2, nth, res, i);\n\t}\n    }\n\n  mpz_clear (bs);\n  mpz_clear (x2);\n  mpz_clear (root1);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "debug_mp": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-scan.c": {
    "refmpz_scan": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "unsigned long\nrefmpz_scan (mpz_srcptr z, unsigned long i, int sought)\n{\n  unsigned long  z_bits = (unsigned long) ABSIZ(z) * GMP_NUMB_BITS;\n\n  do\n    {\n      if (mpz_tstbit (z, i) == sought)\n        return i;\n      i++;\n    }\n  while (i <= z_bits);\n\n  return ULONG_MAX;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "refmpz_scan0": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "unsigned long\nrefmpz_scan0 (mpz_srcptr z, unsigned long starting_bit)\n{\n  return refmpz_scan (z, starting_bit, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "refmpz_scan1": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "unsigned long\nrefmpz_scan1 (mpz_srcptr z, unsigned long starting_bit)\n{\n  return refmpz_scan (z, starting_bit, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "check_ref": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void\ncheck_ref (void)\n{\n  static const int offset[] = {\n    -2, -1, 0, 1, 2, 3\n  };\n\n  mpz_t          z;\n  int            test, neg, sought, oindex, o;\n  mp_size_t      size, isize;\n  unsigned long  start, got, want;\n\n  mpz_init (z);\n  for (test = 0; test < 5; test++)\n    {\n      for (size = 0; size < 5; size++)\n        {\n          mpz_random2 (z, size);\n\n          for (neg = 0; neg <= 1; neg++)\n            {\n              if (neg)\n                mpz_neg (z, z);\n\n              for (isize = 0; isize <= size; isize++)\n                {\n                  for (oindex = 0; oindex < numberof (offset); oindex++)\n                    {\n                      o = offset[oindex];\n                      if ((int) isize*GMP_NUMB_BITS < -o)\n                        continue;  /* start would be negative */\n\n                      start = isize*GMP_NUMB_BITS + o;\n\n                      for (sought = 0; sought <= 1; sought++)\n                        {\n                          if (sought == 0)\n                            {\n                              got = mpz_scan0 (z, start);\n                              want = refmpz_scan0 (z, start);\n                            }\n                          else\n                            {\n                              got = mpz_scan1 (z, start);\n                              want = refmpz_scan1 (z, start);\n                            }\n\n                          if (got != want)\n                            {\n                              printf (\"wrong at test=%d, size=%ld, neg=%d, start=%lu, sought=%d\\n\",\n                                      test, size, neg, start, sought);\n                              printf (\"   z 0x\");\n                              mpz_out_str (stdout, -16, z);\n                              printf (\"\\n\");\n                              printf (\"   got=%lu, want=%lu\\n\", got, want);\n                              exit (1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n  mpz_clear (z);\n}",
      "lines": 65,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  check_ref ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-set_d.c": {
    "check_data": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n  static const struct {\n    double     d;\n    mp_size_t  want_size;\n    mp_limb_t  want_data[2];\n  } data[] = {\n\n    {  0.0,  0 },\n    {  1.0,  1, { 1 } },\n    { -1.0, -1, { 1 } },\n\n    {  123.0,  1, { 123 } },\n    { -123.0, -1, { 123 } },\n\n    { 1e-1, 0, { 0 } },\n    { -1e-1, 0, { 0 } },\n    { 2.328306436538696e-10, 0, { 0 } },\n    { -2.328306436538696e-10, 0, { 0 } },\n    { 5.421010862427522e-20, 0, { 0 } },\n    { -5.421010862427522e-20, 0, { 0 } },\n    { 2.938735877055719e-39, 0, { 0 } },\n    { -2.938735877055719e-39, 0, { 0 } },\n  };\n\n  mpz_t  z;\n  int    i;\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_init (z);\n      mpz_set_d (z, data[i].d);\n      MPZ_CHECK_FORMAT (z);\n      if (z->_mp_size != data[i].want_size\n          || refmpn_cmp_allowzero (z->_mp_d, data[i].want_data,\n                                   ABS (data[i].want_size)) != 0)\n        {\n          printf (\"mpz_set_d wrong on data[%d]\\n\", i);\n        bad:\n          d_trace   (\"  d  \", data[i].d);\n          printf    (\"  got  size %ld\\n\", (long) z->_mp_size);\n          printf    (\"  want size %ld\\n\", (long) data[i].want_size);\n          mpn_trace (\"  got  z\", z->_mp_d, z->_mp_size);\n          mpn_trace (\"  want z\", data[i].want_data, data[i].want_size);\n          abort();\n        }\n      mpz_clear (z);\n\n      mpz_init_set_d (z, data[i].d);\n      MPZ_CHECK_FORMAT (z);\n      if (z->_mp_size != data[i].want_size\n          || refmpn_cmp_allowzero (z->_mp_d, data[i].want_data,\n                                   ABS (data[i].want_size)) != 0)\n        {\n          printf (\"mpz_init_set_d wrong on data[%d]\\n\", i);\n          goto bad;\n        }\n      mpz_clear (z);\n    }\n}",
      "lines": 61,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "check_2n_plus_1": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\ncheck_2n_plus_1 (void)\n{\n  volatile double  p, d, diff;\n  mpz_t  want, got;\n  int    i;\n\n  mpz_init (want);\n  mpz_init (got);\n\n  p = 1.0;\n  mpz_set_ui (want, 2L);  /* gives 3 on first step */\n\n  for (i = 1; i < 500; i++)\n    {\n      mpz_mul_2exp (want, want, 1L);\n      mpz_sub_ui (want, want, 1L);   /* want = 2^i+1 */\n\n      p *= 2.0;  /* p = 2^i */\n      d = p + 1.0;\n      diff = d - p;\n      if (diff != 1.0)\n        break;   /* rounding occurred, stop now */\n\n      mpz_set_d (got, d);\n      MPZ_CHECK_FORMAT (got);\n      if (mpz_cmp (got, want) != 0)\n        {\n          printf (\"mpz_set_d wrong on 2^%d+1\\n\", i);\n          d_trace   (\"  d \", d);\n          mpz_trace (\"  got  \", got);\n          mpz_trace (\"  want \", want);\n          abort ();\n        }\n    }\n\n  mpz_clear (want);\n  mpz_clear (got);\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n  check_2n_plus_1 ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-set_f.c": {
    "check_one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "void\ncheck_one (mpz_srcptr z)\n{\n  static const int shift[] = {\n    0, 1, GMP_LIMB_BITS, 2*GMP_LIMB_BITS, 5*GMP_LIMB_BITS\n  };\n\n  int    sh, shneg, neg;\n  mpf_t  f;\n  mpz_t  got, want;\n\n  mpf_init2 (f, mpz_sizeinbase(z,2));\n  mpz_init (got);\n  mpz_init (want);\n\n  for (sh = 0; sh < numberof(shift); sh++)\n    {\n      for (shneg = 0; shneg <= 1; shneg++)\n\t{\n\t  for (neg = 0; neg <= 1; neg++)\n\t    {\n\t      mpf_set_z (f, z);\n\t      mpz_set (want, z);\n\n\t      if (neg)\n\t\t{\n\t\t  mpf_neg (f, f);\n\t\t  mpz_neg (want, want);\n\t\t}\n\n\t      if (shneg)\n\t\t{\n\t\t  mpz_tdiv_q_2exp (want, want, shift[sh]);\n\t\t  mpf_div_2exp (f, f, shift[sh]);\n\t\t}\n\t      else\n\t\t{\n\t\t  mpz_mul_2exp (want, want, shift[sh]);\n\t\t  mpf_mul_2exp (f, f, shift[sh]);\n\t\t}\n\n\t      mpz_set_f (got, f);\n\t      MPZ_CHECK_FORMAT (got);\n\n\t      if (mpz_cmp (got, want) != 0)\n\t\t{\n\t\t  printf (\"wrong result\\n\");\n\t\t  printf (\"  shift  %d\\n\", shneg ? -shift[sh] : shift[sh]);\n\t\t  printf (\"  neg    %d\\n\", neg);\n\t\t  mpf_trace (\"     f\", f);\n\t\t  mpz_trace (\"   got\", got);\n\t\t  mpz_trace (\"  want\", want);\n\t\t  abort ();\n\t\t}\n\t    }\n\t}\n    }\n\n  mpf_clear (f);\n  mpz_clear (got);\n  mpz_clear (want);\n}",
      "lines": 62,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "check_various": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\ncheck_various (void)\n{\n  mpz_t  z;\n\n  mpz_init (z);\n\n  mpz_set_ui (z, 0L);\n  check_one (z);\n\n  mpz_set_si (z, 123L);\n  check_one (z);\n\n  mpz_rrandomb (z, RANDS, 2*GMP_LIMB_BITS);\n  check_one (z);\n\n  mpz_rrandomb (z, RANDS, 5*GMP_LIMB_BITS);\n  check_one (z);\n\n  mpz_clear (z);\n}",
      "lines": 21,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n#if GMP_NAIL_BITS == 0\n  tests_start ();\n  mp_trace_base = 16;\n\n  check_various ();\n\n  tests_end ();\n#endif\n  exit (0);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-set_si.c": {
    "check_data": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\ncheck_data (void)\n{\n#if GMP_NUMB_BITS <= BITS_PER_ULONG\n#define ENTRY(n)   { n, { n, 0 } }\n#else\n#define ENTRY(n)   { n, { (n) & GMP_NUMB_MASK, (n) >> GMP_NUMB_BITS } }\n#endif\n\n  static const struct {\n    long       n;\n    mp_size_t  want_size;\n    mp_limb_t  want_data[2];\n  } data[] = {\n\n    {  0L,  0 },\n    {  1L,  1, { 1 } },\n    { -1L, -1, { 1 } },\n\n#if GMP_NUMB_BITS >= BITS_PER_ULONG\n    { LONG_MAX,  1, { LONG_MAX, 0 } },\n    { -LONG_MAX,  -1, { LONG_MAX, 0 } },\n    { LONG_HIGHBIT,  -1, { ULONG_HIGHBIT, 0 } },\n#else\n    { LONG_MAX,  2, { LONG_MAX & GMP_NUMB_MASK, LONG_MAX >> GMP_NUMB_BITS } },\n    { -LONG_MAX,  -2, { LONG_MAX & GMP_NUMB_MASK, LONG_MAX >> GMP_NUMB_BITS }},\n    { LONG_HIGHBIT,  -2, { 0, ULONG_HIGHBIT >> GMP_NUMB_BITS } },\n#endif\n  };\n\n  mpz_t  n;\n  int    i;\n\n  for (i = 0; i < numberof (data); i++)\n    {\n      mpz_init (n);\n      mpz_set_si (n, data[i].n);\n      MPZ_CHECK_FORMAT (n);\n      if (n->_mp_size != data[i].want_size\n          || refmpn_cmp_allowzero (n->_mp_d, data[i].want_data,\n                                   ABS (data[i].want_size)) != 0)\n        {\n          printf (\"mpz_set_si wrong on data[%d]\\n\", i);\n          abort();\n        }\n      mpz_clear (n);\n\n      mpz_init_set_si (n, data[i].n);\n      MPZ_CHECK_FORMAT (n);\n      if (n->_mp_size != data[i].want_size\n          || refmpn_cmp_allowzero (n->_mp_d, data[i].want_data,\n                                   ABS (data[i].want_size)) != 0)\n        {\n          printf (\"mpz_init_set_si wrong on data[%d]\\n\", i);\n          abort();\n        }\n      mpz_clear (n);\n    }\n}",
      "lines": 59,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_data ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-set_str.c": {
    "check_one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\ncheck_one (mpz_srcptr want, int fail, int base, const char *str)\n{\n  mpz_t   got;\n\n  MPZ_CHECK_FORMAT (want);\n  mp_trace_base = (base == 0 ? 16 : base);\n\n  mpz_init (got);\n\n  if (mpz_set_str (got, str, base) != fail)\n    {\n      printf (\"mpz_set_str unexpectedly failed\\n\");\n      printf (\"  base %d\\n\", base);\n      printf (\"  str  \\\"%s\\\"\\n\", str);\n      abort ();\n    }\n  MPZ_CHECK_FORMAT (got);\n\n  if (fail == 0 && mpz_cmp (got, want) != 0)\n    {\n      printf (\"mpz_set_str wrong\\n\");\n      printf (\"  base %d\\n\", base);\n      printf (\"  str  \\\"%s\\\"\\n\", str);\n      mpz_trace (\"got \", got);\n      mpz_trace (\"want\", want);\n      abort ();\n    }\n\n  mpz_clear (got);\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_samples": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\ncheck_samples (void)\n{\n  mpz_t  z;\n\n  mpz_init (z);\n\n  mpz_set_ui (z, 0L);\n  check_one (z, 0, 0, \"0 \");\n  check_one (z, 0, 0, \" 0 0 0 \");\n  check_one (z, 0, 0, \" -0B 0 \");\n  check_one (z, 0, 0, \"  0X 0 \");\n  check_one (z, 0, 10, \"0 \");\n  check_one (z, 0, 10, \"-0   \");\n  check_one (z, 0, 10, \" 0 000 000    \");\n\n  mpz_set_ui (z, 123L);\n  check_one (z, 0, 0, \"123 \");\n  check_one (z, 0, 0, \"123    \");\n  check_one (z, 0, 0, \"0173   \");\n  check_one (z, 0, 0, \" 0b 1 11 10 11  \");\n  check_one (z, 0, 0, \" 0x 7b \");\n  check_one (z, 0, 0, \"0x7B\");\n  check_one (z, 0, 10, \"123 \");\n  check_one (z, 0, 10, \"123    \");\n  check_one (z, 0, 0, \" 123 \");\n  check_one (z, 0, 0, \"  123    \");\n  check_one (z, 0, 10, \"  0000123 \");\n  check_one (z, 0, 10, \"  123    \");\n  check_one (z,-1, 10, \"1%\");\n  check_one (z,-1, 0, \"3!\");\n  check_one (z,-1, 0, \"0123456789\");\n  check_one (z,-1, 0, \"13579BDF\");\n  check_one (z,-1, 0, \"0b0102\");\n  check_one (z,-1, 0, \"0x010G\");\n  check_one (z,-1, 37,\"0x010G\");\n  check_one (z,-1, 99,\"0x010G\");\n\n  mpz_clear (z);\n}",
      "lines": 40,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_samples ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-sizeinbase.c": {
    "mpz_fake_bits": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nmpz_fake_bits (mpz_ptr z, unsigned long totbits)\n{\n  static mp_limb_t  n;\n  unsigned long     zero_bits, zero_limbs;\n\n  zero_bits = totbits - 1;\n  zero_limbs = zero_bits / GMP_NUMB_BITS;\n  zero_bits %= GMP_NUMB_BITS;\n\n  SIZ(z) = zero_limbs + 1;\n  PTR(z) = (&n) - (SIZ(z) - 1);\n  n = CNST_LIMB(1) << zero_bits;\n\n  ASSERT_ALWAYS (mpz_sizeinbase (z, 2) == totbits);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_sample": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\ncheck_sample (void)\n{\n  unsigned long  totbits = 198096465;\n  int        base = 10;\n  size_t     want = 59632979;\n  size_t     got;\n  mpz_t      z;\n\n  mpz_fake_bits (z, totbits);\n  got = mpz_sizeinbase (z, base);\n  if (got != want)\n    {\n      printf (\"mpz_sizeinbase\\n\");\n      printf (\"  base    %d\\n\",  base);\n      printf (\"  totbits %lu\\n\", totbits);\n      printf (\"  got     %u\\n\",  got);\n      printf (\"  want    %u\\n\",  want);\n      abort ();\n    }\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  /* check_sample (); */\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-sqrtrem.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t x2;\n  mpz_t x, rem;\n  mpz_t temp, temp2;\n  mp_size_t x2_size;\n  int i;\n  int reps = 1000;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long size_range;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  mpz_init (x2);\n  mpz_init (x);\n  mpz_init (rem);\n  mpz_init (temp);\n  mpz_init (temp2);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 17 + 2; /* 0..262144 bit operands */\n\n      mpz_urandomb (bs, rands, size_range);\n      x2_size = mpz_get_ui (bs);\n      mpz_rrandomb (x2, rands, x2_size);\n\n      /* printf (\"%ld\\n\", SIZ (x2)); */\n\n      mpz_sqrt (temp, x2);\n      MPZ_CHECK_FORMAT (temp);\n\n      mpz_sqrtrem (x, rem, x2);\n      MPZ_CHECK_FORMAT (x);\n      MPZ_CHECK_FORMAT (rem);\n\n      /* Are results different?  */\n      if (mpz_cmp (temp, x) != 0)\n\tdump_abort (x2, x, rem);\n\n      mpz_mul (temp, x, x);\n\n      /* Is square of result > argument?  */\n      if (mpz_cmp (temp, x2) > 0)\n\tdump_abort (x2, x, rem);\n\n      mpz_add_ui (temp2, x, 1);\n      mpz_mul (temp2, temp2, temp2);\n\n      /* Is square of (result + 1) <= argument?  */\n      if (mpz_cmp (temp2, x2) <= 0)\n\tdump_abort (x2, x, rem);\n\n      mpz_add (temp2, temp, rem);\n\n      /* Is the remainder wrong?  */\n      if (mpz_cmp (x2, temp2) != 0)\n\tdump_abort (x2, x, rem);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (x2);\n  mpz_clear (x);\n  mpz_clear (rem);\n  mpz_clear (temp);\n  mpz_clear (temp2);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 78,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "dump_abort": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\ndump_abort (mpz_t x2, mpz_t x, mpz_t rem)\n{\n  fprintf (stderr, \"ERROR\\n\");\n  fprintf (stderr, \"x2        = \"); debug_mp (x2, -16);\n  fprintf (stderr, \"x         = \"); debug_mp (x, -16);\n  fprintf (stderr, \"remainder = \"); debug_mp (rem, -16);\n  abort();\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "debug_mp": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-tdiv.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t dividend, divisor;\n  mpz_t quotient, remainder;\n  mpz_t quotient2, remainder2;\n  mpz_t temp;\n  mp_size_t dividend_size, divisor_size;\n  int i;\n  int reps = 1000;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n\n  tests_start ();\n  TESTS_REPS (reps, argv, argc);\n\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  mpz_init (dividend);\n  mpz_init (divisor);\n  mpz_init (quotient);\n  mpz_init (remainder);\n  mpz_init (quotient2);\n  mpz_init (remainder2);\n  mpz_init (temp);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 18 + 2; /* 0..524288 bit operands */\n\n      do\n\t{\n\t  mpz_urandomb (bs, rands, size_range);\n\t  divisor_size = mpz_get_ui (bs);\n\t  mpz_rrandomb (divisor, rands, divisor_size);\n\t}\n      while (mpz_sgn (divisor) == 0);\n\n      mpz_urandomb (bs, rands, size_range);\n      dividend_size = mpz_get_ui (bs) + divisor_size;\n      mpz_rrandomb (dividend, rands, dividend_size);\n\n      mpz_urandomb (bs, rands, 2);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (dividend, dividend);\n      if ((bsi & 2) != 0)\n\tmpz_neg (divisor, divisor);\n\n      /* printf (\"%ld %ld\\n\", SIZ (dividend), SIZ (divisor)); */\n\n      mpz_tdiv_qr (quotient, remainder, dividend, divisor);\n      mpz_tdiv_q (quotient2, dividend, divisor);\n      mpz_tdiv_r (remainder2, dividend, divisor);\n\n      /* First determine that the quotients and remainders computed\n\t with different functions are equal.  */\n      if (mpz_cmp (quotient, quotient2) != 0)\n\tdump_abort (dividend, divisor);\n      if (mpz_cmp (remainder, remainder2) != 0)\n\tdump_abort (dividend, divisor);\n\n      /* Check if the sign of the quotient is correct.  */\n      if (mpz_cmp_ui (quotient, 0) != 0)\n\tif ((mpz_cmp_ui (quotient, 0) < 0)\n\t    != ((mpz_cmp_ui (dividend, 0) ^ mpz_cmp_ui (divisor, 0)) < 0))\n\tdump_abort (dividend, divisor);\n\n      /* Check if the remainder has the same sign as the dividend\n\t (quotient rounded towards 0).  */\n      if (mpz_cmp_ui (remainder, 0) != 0)\n\tif ((mpz_cmp_ui (remainder, 0) < 0) != (mpz_cmp_ui (dividend, 0) < 0))\n\t  dump_abort (dividend, divisor);\n\n      mpz_mul (temp, quotient, divisor);\n      mpz_add (temp, temp, remainder);\n      if (mpz_cmp (temp, dividend) != 0)\n\tdump_abort (dividend, divisor);\n\n      mpz_abs (temp, divisor);\n      mpz_abs (remainder, remainder);\n      if (mpz_cmp (remainder, temp) >= 0)\n\tdump_abort (dividend, divisor);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (dividend);\n  mpz_clear (divisor);\n  mpz_clear (quotient);\n  mpz_clear (remainder);\n  mpz_clear (quotient2);\n  mpz_clear (remainder2);\n  mpz_clear (temp);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 101,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "dump_abort": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "void\ndump_abort (mpz_t dividend, mpz_t divisor)\n{\n  fprintf (stderr, \"ERROR\\n\");\n  fprintf (stderr, \"dividend = \"); debug_mp (dividend, -16);\n  fprintf (stderr, \"divisor  = \"); debug_mp (divisor, -16);\n  abort();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "debug_mp": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/mpz/t-tdiv_ui.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  mpz_t dividend;\n  mpz_t quotient, remainder;\n  mpz_t quotient2, remainder2;\n  mpz_t temp;\n  mp_size_t dividend_size;\n  unsigned long divisor;\n  int i;\n  int reps = 200000;\n  gmp_randstate_ptr rands;\n  mpz_t bs;\n  unsigned long bsi, size_range;\n  unsigned long r_rq, r_q, r_r, r;\n\n  tests_start ();\n  rands = RANDS;\n\n  mpz_init (bs);\n\n  if (argc == 2)\n     reps = atoi (argv[1]);\n\n  mpz_init (dividend);\n  mpz_init (quotient);\n  mpz_init (remainder);\n  mpz_init (quotient2);\n  mpz_init (remainder2);\n  mpz_init (temp);\n\n  for (i = 0; i < reps; i++)\n    {\n      mpz_urandomb (bs, rands, 32);\n      size_range = mpz_get_ui (bs) % 10 + 2; /* 0..2047 bit operands */\n\n      do\n\t{\n\t  mpz_rrandomb (bs, rands, 64);\n\t  divisor = mpz_get_ui (bs);\n\t}\n      while (divisor == 0);\n\n      mpz_urandomb (bs, rands, size_range);\n      dividend_size = mpz_get_ui (bs);\n      mpz_rrandomb (dividend, rands, dividend_size);\n\n      mpz_urandomb (bs, rands, 2);\n      bsi = mpz_get_ui (bs);\n      if ((bsi & 1) != 0)\n\tmpz_neg (dividend, dividend);\n\n      /* printf (\"%ld\\n\", SIZ (dividend)); */\n\n      r_rq = mpz_tdiv_qr_ui (quotient, remainder, dividend, divisor);\n      r_q = mpz_tdiv_q_ui (quotient2, dividend, divisor);\n      r_r = mpz_tdiv_r_ui (remainder2, dividend, divisor);\n      r = mpz_tdiv_ui (dividend, divisor);\n\n      /* First determine that the quotients and remainders computed\n\t with different functions are equal.  */\n      if (mpz_cmp (quotient, quotient2) != 0)\n\tdump_abort (\"quotients from mpz_tdiv_qr_ui and mpz_tdiv_q_ui differ\",\n\t\t    dividend, divisor);\n      if (mpz_cmp (remainder, remainder2) != 0)\n\tdump_abort (\"remainders from mpz_tdiv_qr_ui and mpz_tdiv_r_ui differ\",\n\t\t    dividend, divisor);\n\n      /* Check if the sign of the quotient is correct.  */\n      if (mpz_cmp_ui (quotient, 0) != 0)\n\tif ((mpz_cmp_ui (quotient, 0) < 0)\n\t    != (mpz_cmp_ui (dividend, 0) < 0))\n\tdump_abort (\"quotient sign wrong\", dividend, divisor);\n\n      /* Check if the remainder has the same sign as the dividend\n\t (quotient rounded towards 0).  */\n      if (mpz_cmp_ui (remainder, 0) != 0)\n\tif ((mpz_cmp_ui (remainder, 0) < 0) != (mpz_cmp_ui (dividend, 0) < 0))\n\t  dump_abort (\"remainder sign wrong\", dividend, divisor);\n\n      mpz_mul_ui (temp, quotient, divisor);\n      mpz_add (temp, temp, remainder);\n      if (mpz_cmp (temp, dividend) != 0)\n\tdump_abort (\"n mod d != n - [n/d]*d\", dividend, divisor);\n\n      mpz_abs (remainder, remainder);\n      if (mpz_cmp_ui (remainder, divisor) >= 0)\n\tdump_abort (\"remainder greater than divisor\", dividend, divisor);\n\n      if (mpz_cmp_ui (remainder, r_rq) != 0)\n\tdump_abort (\"remainder returned from mpz_tdiv_qr_ui is wrong\",\n\t\t    dividend, divisor);\n      if (mpz_cmp_ui (remainder, r_q) != 0)\n\tdump_abort (\"remainder returned from mpz_tdiv_q_ui is wrong\",\n\t\t    dividend, divisor);\n      if (mpz_cmp_ui (remainder, r_r) != 0)\n\tdump_abort (\"remainder returned from mpz_tdiv_r_ui is wrong\",\n\t\t    dividend, divisor);\n      if (mpz_cmp_ui (remainder, r) != 0)\n\tdump_abort (\"remainder returned from mpz_tdiv_ui is wrong\",\n\t\t    dividend, divisor);\n    }\n\n  mpz_clear (bs);\n  mpz_clear (dividend);\n  mpz_clear (quotient);\n  mpz_clear (remainder);\n  mpz_clear (quotient2);\n  mpz_clear (remainder2);\n  mpz_clear (temp);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 114,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "dump_abort": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\ndump_abort (const char *str, mpz_t dividend, unsigned long divisor)\n{\n  fprintf (stderr, \"ERROR: %s\\n\", str);\n  fprintf (stderr, \"dividend = \"); debug_mp (dividend, -16);\n  fprintf (stderr, \"divisor  = %lX\\n\", divisor);\n  abort();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "debug_mp": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\ndebug_mp (mpz_t x, int base)\n{\n  mpz_out_str (stderr, base, x); fputc ('\\n', stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/findlc.c": {
    "sh_status": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static void\nsh_status (int sig)\n{\n  printf (\"sh_status: signal %d caught. dumping status.\\n\", sig);\n\n  printf (\"  a = \");\n  mpz_out_str (stdout, 10, a);\n  printf (\"\\n\");\n  fflush (stdout);\n\n  if (SIGSEGV == sig)\t\t/* remove SEGV handler */\n    signal (SIGSEGV, SIG_DFL);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_true_random": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\nmpz_true_random (mpz_t s, unsigned long int nbits)\n{\n#if __FreeBSD__\n  FILE *fs;\n  char c[1];\n  int i;\n\n  mpz_set_ui (s, 0);\n  for (i = 0; i < nbits; i += 8)\n    {\n      for (;;)\n\t{\n\t  int nread;\n\t  fs = fopen (\"/dev/random\", \"r\");\n\t  nread = fread (c, 1, 1, fs);\n\t  fclose (fs);\n\t  if (nread != 0)\n\t    break;\n\t  sleep (1);\n\t}\n      mpz_mul_2exp (s, s, 8);\n      mpz_add_ui (s, s, ((unsigned long int) c[0]) & 0xff);\n      printf (\"%d random bits\\n\", i + 8);\n    }\n  if (nbits % 8 != 0)\n    mpz_mod_2exp (s, s, nbits);\n#endif\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char usage[] = \"usage: findlc [-dv] m2exp [low_merit [high_merit]]\\n\";\n  int f;\n  int v_lose, m_lose, v_best, m_best;\n  int c;\n  int debug = 1;\n  int cnt_high_merit;\n  mpz_t m;\n  unsigned long int m2exp;\n#define DIMS 6\t\t\t/* dimensions run in spectral test */\n  mpf_t v[DIMS-1];\t\t/* spectral test result (there's no v\n\t\t\t\t   for 1st dimension */\n  mpf_t f_merit, low_merit, high_merit;\n  mpz_t acc, minus8;\n  mpz_t min, max;\n  mpz_t s;\n\n\n  mpz_init (m);\n  mpz_init (a);\n  for (f = 0; f < DIMS-1; f++)\n    mpf_init (v[f]);\n  mpf_init (f_merit);\n  mpf_init_set_d (low_merit, .1);\n  mpf_init_set_d (high_merit, .1);\n\n  while ((c = getopt (argc, argv, \"a:di:hv\")) != -1)\n    switch (c)\n      {\n      case 'd':\t\t\t/* debug */\n\tg_debug++;\n\tbreak;\n\n      case 'v':\t\t\t/* print version */\n\tputs (rcsid[1]);\n\texit (0);\n\n      case 'h':\n      case '?':\n      default:\n\tfputs (usage, stderr);\n\texit (1);\n      }\n\n  argc -= optind;\n  argv += optind;\n\n  if (argc < 1)\n    {\n      fputs (usage, stderr);\n      exit (1);\n    }\n\n  /* Install signal handler. */\n  if (SIG_ERR == signal (SIGSEGV, sh_status))\n    {\n      perror (\"signal (SIGSEGV)\");\n      exit (1);\n    }\n  if (SIG_ERR == signal (SIGHUP, sh_status))\n    {\n      perror (\"signal (SIGHUP)\");\n      exit (1);\n    }\n\n  printf (\"findlc: version: %s\\n\", rcsid[1]);\n  m2exp = atol (argv[0]);\n  mpz_init_set_ui (m, 1);\n  mpz_mul_2exp (m, m, m2exp);\n  printf (\"m = 0x\");\n  mpz_out_str (stdout, 16, m);\n  puts (\"\");\n\n  if (argc > 1)\t\t\t/* have low_merit */\n    mpf_set_str (low_merit, argv[1], 0);\n  if (argc > 2)\t\t\t/* have high_merit */\n    mpf_set_str (high_merit, argv[2], 0);\n\n  if (debug)\n    {\n      fprintf (stderr, \"low_merit = \");\n      mpf_out_str (stderr, 10, 2, low_merit);\n      fprintf (stderr, \"; high_merit = \");\n      mpf_out_str (stderr, 10, 2, high_merit);\n      fputs (\"\\n\", stderr);\n    }\n\n  mpz_init (minus8);\n  mpz_set_si (minus8, -8L);\n  mpz_init_set_ui (acc, 0);\n  mpz_init (s);\n  mpz_init_set_d (min, 0.01 * pow (2.0, (double) m2exp));\n  mpz_init_set_d (max, 0.99 * pow (2.0, (double) m2exp));\n\n  mpz_true_random (s, m2exp);\t/* Start.  */\n  mpz_setbit (s, 0);\t\t/* Make it odd.  */\n\n  v_best = m_best = 2*(DIMS-1);\n  for (;;)\n    {\n      mpz_add (acc, acc, s);\n      mpz_mod_2exp (acc, acc, m2exp);\n#if later\n      mpz_and_si (a, acc, -8L);\n#else\n      mpz_and (a, acc, minus8);\n#endif\n      mpz_add_ui (a, a, 5);\n      if (mpz_cmp (a, min) <= 0 || mpz_cmp (a, max) >= 0)\n\tcontinue;\n\n      spectral_test (v, DIMS, a, m);\n      for (f = 0, v_lose = m_lose = 0, cnt_high_merit = DIMS-1;\n\t   f < DIMS-1; f++)\n\t{\n\t  merit (f_merit, f + 2, v[f], m);\n\n\t  if (mpf_cmp_ui (v[f], 1 << (30 / (f + 2) + (f == 2))) < 0)\n\t    v_lose++;\n\n\t  if (mpf_cmp (f_merit, low_merit) < 0)\n\t    m_lose++;\n\n\t  if (mpf_cmp (f_merit, high_merit) >= 0)\n\t    cnt_high_merit--;\n\t}\n\n      if (0 == v_lose && 0 == m_lose)\n\t{\n\t  mpz_out_str (stdout, 10, a); puts (\"\"); fflush (stdout);\n\t  if (0 == cnt_high_merit)\n\t    break;\t\t/* leave loop */\n\t}\n      if (v_lose < v_best)\n\t{\n\t  v_best = v_lose;\n\t  printf (\"best (v_lose=%d; m_lose=%d): \", v_lose, m_lose);\n\t  mpz_out_str (stdout, 10, a); puts (\"\"); fflush (stdout);\n\t}\n      if (m_lose < m_best)\n\t{\n\t  m_best = m_lose;\n\t  printf (\"best (v_lose=%d; m_lose=%d): \", v_lose, m_lose);\n\t  mpz_out_str (stdout, 10, a); puts (\"\"); fflush (stdout);\n\t}\n    }\n\n  mpz_clear (m);\n  mpz_clear (a);\n  for (f = 0; f < DIMS-1; f++)\n    mpf_clear (v[f]);\n  mpf_clear (f_merit);\n  mpf_clear (low_merit);\n  mpf_clear (high_merit);\n\n  printf (\"done.\\n\");\n  return 0;\n}",
      "lines": 160,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/gen.c": {},
  "gmp/gmp-6.1.2/tests/rand/gmpstat.h": {},
  "gmp/gmp-6.1.2/tests/rand/spect.c": {
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char usage[] = \"usage: spect [-d] a m n\\n\";\n  int c;\n  unsigned int n;\n  mpz_t a, m;\n  mpf_t res[GMP_SPECT_MAXT], res_min[GMP_SPECT_MAXT], f_tmp;\n  int f;\n\n\n  mpz_init (a);\n  mpz_init (m);\n  for (f = 0; f < GMP_SPECT_MAXT; f++)\n    {\n      mpf_init (res[f]);\n      mpf_init (res_min[f]);\n    }\n  mpf_init (f_tmp);\n  mpf_set_ui (res_min[0], 32768); /* 2^15 */\n  mpf_set_ui (res_min[1], 1024); /* 2^10 */\n  mpf_set_ui (res_min[2], 256); /* 2^8 */\n  mpf_set_ui (res_min[3], 64); /* 2^6 */\n  mpf_set_ui (res_min[4], 32); /* 2^5 */\n\n  while ((c = getopt (argc, argv, \"dh\")) != -1)\n    switch (c)\n      {\n      case 'd':\t\t\t/* debug */\n\tg_debug++;\n\tbreak;\n      case 'h':\n      default:\n\tfputs (usage, stderr);\n\texit (1);\n      }\n  argc -= optind;\n  argv += optind;\n\n  if (argc < 3)\n    {\n      fputs (usage, stderr);\n      exit (1);\n    }\n\n  mpz_set_str (a, argv[0], 0);\n  mpz_set_str (m, argv[1], 0);\n  n = (unsigned int) atoi (argv[2]);\n  if (n + 1 > GMP_SPECT_MAXT)\n    n = GMP_SPECT_MAXT + 1;\n\n  spectral_test (res, n, a, m);\n\n  for (f = 0; f < n - 1; f++)\n    {\n      /* print v */\n      printf (\"%d: v = \", f + 2);\n      mpf_out_str (stdout, 10, 4, res[f]);\n\n#ifdef PRINT_RAISED_BY_TWO_AS_WELL\n      printf (\" (^2 = \");\n      mpf_mul (f_tmp, res[f], res[f]);\n      mpf_out_str (stdout, 10, 4, f_tmp);\n      printf (\")\");\n#endif /* PRINT_RAISED_BY_TWO_AS_WELL */\n\n      /* print merit */\n      printf (\" m = \");\n      merit (f_tmp, f + 2, res[f], m);\n      mpf_out_str (stdout, 10, 4, f_tmp);\n\n      if (mpf_cmp (res[f], res_min[f]) < 0)\n\tprintf (\"\\t*** v too low ***\");\n      if (mpf_get_d (f_tmp) < .1)\n\tprintf (\"\\t*** merit too low ***\");\n\n      puts (\"\");\n    }\n\n  mpz_clear (a);\n  mpz_clear (m);\n  for (f = 0; f < GMP_SPECT_MAXT; f++)\n    {\n      mpf_clear (res[f]);\n      mpf_clear (res_min[f]);\n    }\n  mpf_clear (f_tmp);\n\n  return 0;\n}",
      "lines": 90,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "debug_foo": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\ndebug_foo()\n{\n  if (0)\n    {\n      mpz_dump (0);\n      mpf_dump (0);\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/stat.c": {
    "print_ks_results": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void\nprint_ks_results (mpf_t f_p, mpf_t f_p_prob,\n\t\t  mpf_t f_m, mpf_t f_m_prob,\n\t\t  FILE *fp)\n{\n  double p, pp, m, mp;\n\n  p = mpf_get_d (f_p);\n  m = mpf_get_d (f_m);\n  pp = mpf_get_d (f_p_prob);\n  mp = mpf_get_d (f_m_prob);\n\n  fprintf (fp, \"%.4f (%.0f%%)\\t\", p, pp * 100.0);\n  fprintf (fp, \"%.4f (%.0f%%)\\n\", m, mp * 100.0);\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_x2_table": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static void\nprint_x2_table (unsigned int v, FILE *fp)\n{\n  double t[7];\n  int f;\n\n\n  fprintf (fp, \"Chi-square table for v=%u\\n\", v);\n  fprintf (fp, \"1%%\\t5%%\\t25%%\\t50%%\\t75%%\\t95%%\\t99%%\\n\");\n  x2_table (t, v);\n  for (f = 0; f < 7; f++)\n    fprintf (fp, \"%.2f\\t\", t[f]);\n  fputs (\"\\n\", fp);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "Pks": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static void\nPks (mpf_t p, mpf_t x)\n{\n  double dt;\t\t\t/* temp double */\n\n  mpf_set (p, x);\n  mpf_mul (p, p, p);\t\t/* p = x^2 */\n  mpf_mul_ui (p, p, 2);\t\t/* p = 2*x^2 */\n  mpf_neg (p, p);\t\t/* p = -2*x^2 */\n  /* No pow() in gmp.  Use doubles. */\n  /* FIXME: Use exp()? */\n  dt = pow (M_E, mpf_get_d (p));\n  mpf_set_d (p, dt);\n  mpf_ui_sub (p, 1, p);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "f_freq": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static void\nf_freq (const unsigned l1runs, const unsigned l2runs,\n\tmpf_t fvec[], const unsigned long n)\n{\n  unsigned f;\n  mpf_t f_p, f_p_prob;\n  mpf_t f_m, f_m_prob;\n  mpf_t *l1res;\t\t\t/* level 1 result array */\n\n  mpf_init (f_p);  mpf_init (f_m);\n  mpf_init (f_p_prob);  mpf_init (f_m_prob);\n\n\n  /* Allocate space for 1st level results. */\n  l1res = (mpf_t *) malloc (l2runs * 2 * sizeof (mpf_t));\n  if (NULL == l1res)\n    {\n      fprintf (stderr, \"stat: malloc failure\\n\");\n      exit (1);\n    }\n\n  printf (\"\\nEquidistribution/Frequency test on real numbers (0<=X<1):\\n\");\n  printf (\"\\tKp\\t\\tKm\\n\");\n\n  for (f = 0; f < l2runs; f++)\n    {\n      /*  f_printvec (fvec, n); */\n      mpf_freqt (f_p, f_m, fvec + f * n, n);\n\n      /* what's the probability of getting these results? */\n      ks_table (f_p_prob, f_p, n);\n      ks_table (f_m_prob, f_m, n);\n\n      if (l1runs == 0)\n\t{\n\t  /*printf (\"%u:\\t\", f + 1);*/\n\t  print_ks_results (f_p, f_p_prob, f_m, f_m_prob, stdout);\n\t}\n      else\n\t{\n\t  /* save result */\n\t  mpf_init_set (l1res[f], f_p);\n\t  mpf_init_set (l1res[f + l2runs], f_m);\n\t}\n    }\n\n  /* Now, apply the KS test on the results from the 1st level rounds\n     with the distribution\n     F(x) = 1 - pow(e, -2*x^2)\t[Knuth, vol 2, p.51] */\n\n  if (l1runs != 0)\n    {\n      /*printf (\"-------------------------------------\\n\");*/\n\n      /* The Kp's. */\n      ks (f_p, f_m, l1res, Pks, l2runs);\n      ks_table (f_p_prob, f_p, l2runs);\n      ks_table (f_m_prob, f_m, l2runs);\n      printf (\"Kp:\\t\");\n      print_ks_results (f_p, f_p_prob, f_m, f_m_prob, stdout);\n\n      /* The Km's. */\n      ks (f_p, f_m, l1res + l2runs, Pks, l2runs);\n      ks_table (f_p_prob, f_p, l2runs);\n      ks_table (f_m_prob, f_m, l2runs);\n      printf (\"Km:\\t\");\n      print_ks_results (f_p, f_p_prob, f_m, f_m_prob, stdout);\n    }\n\n  mpf_clear (f_p);  mpf_clear (f_m);\n  mpf_clear (f_p_prob);  mpf_clear (f_m_prob);\n  free (l1res);\n}",
      "lines": 73,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "z_freq": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static void\nz_freq (const unsigned l1runs,\n\tconst unsigned l2runs,\n\tmpz_t zvec[],\n\tconst unsigned long n,\n\tunsigned int max)\n{\n  mpf_t V;\t\t\t/* result */\n  double d_V;\t\t\t/* result as a double */\n\n  mpf_init (V);\n\n\n  printf (\"\\nEquidistribution/Frequency test on integers (0<=X<=%u):\\n\", max);\n  print_x2_table (max, stdout);\n\n  mpz_freqt (V, zvec, max, n);\n\n  d_V = mpf_get_d (V);\n  printf (\"V = %.2f (n = %lu)\\n\", d_V, n);\n\n  mpf_clear (V);\n}",
      "lines": 23,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/statlib.c": {
    "ks": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void\nks (mpf_t Kp,\n    mpf_t Km,\n    mpf_t X[],\n    void (P) (mpf_t, mpf_t),\n    unsigned long int n)\n{\n  mpf_t Kt;\t\t\t/* temp */\n  mpf_t f_x;\n  mpf_t f_j;\t\t\t/* j */\n  mpf_t f_jnq;\t\t\t/* j/n or (j-1)/n */\n  unsigned long int j;\n\n  /* Sort the vector in ascending order. */\n  qsort (X, n, sizeof (__mpf_struct), mpf_cmp);\n\n  /* K-S test. */\n  /*\tKp = sqr(n) * max(j/n - F(Xj))\t\tfor all 1<=j<=n\n\tKm = sqr(n) * max(F(Xj) - (j-1)/n))\tfor all 1<=j<=n\n  */\n\n  mpf_init (Kt); mpf_init (f_x); mpf_init (f_j); mpf_init (f_jnq);\n  mpf_set_ui (Kp, 0);  mpf_set_ui (Km, 0);\n  for (j = 1; j <= n; j++)\n    {\n      P (f_x, X[j-1]);\n      mpf_set_ui (f_j, j);\n\n      mpf_div_ui (f_jnq, f_j, n);\n      mpf_sub (Kt, f_jnq, f_x);\n      if (mpf_cmp (Kt, Kp) > 0)\n\tmpf_set (Kp, Kt);\n      if (g_debug > DEBUG_2)\n\t{\n\t  printf (\"j=%lu \", j);\n\t  printf (\"P()=\"); mpf_out_str (stdout, 10, 2, f_x); printf (\"\\t\");\n\n\t  printf (\"jnq=\"); mpf_out_str (stdout, 10, 2, f_jnq); printf (\" \");\n\t  printf (\"diff=\"); mpf_out_str (stdout, 10, 2, Kt); printf (\" \");\n\t  printf (\"Kp=\"); mpf_out_str (stdout, 10, 2, Kp); printf (\"\\t\");\n\t}\n      mpf_sub_ui (f_j, f_j, 1);\n      mpf_div_ui (f_jnq, f_j, n);\n      mpf_sub (Kt, f_x, f_jnq);\n      if (mpf_cmp (Kt, Km) > 0)\n\tmpf_set (Km, Kt);\n\n      if (g_debug > DEBUG_2)\n\t{\n\t  printf (\"jnq=\"); mpf_out_str (stdout, 10, 2, f_jnq); printf (\" \");\n\t  printf (\"diff=\"); mpf_out_str (stdout, 10, 2, Kt); printf (\" \");\n\t  printf (\"Km=\"); mpf_out_str (stdout, 10, 2, Km); printf (\" \");\n\t  printf (\"\\n\");\n\t}\n    }\n  mpf_sqrt_ui (Kt, n);\n  mpf_mul (Kp, Kp, Kt);\n  mpf_mul (Km, Km, Kt);\n\n  mpf_clear (Kt); mpf_clear (f_x); mpf_clear (f_j); mpf_clear (f_jnq);\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ks_table": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "void\nks_table (mpf_t p, mpf_t val, const unsigned int n)\n{\n  /* We use Eq. (27), Knuth p.58, skipping O(1/n) for simplicity.\n     This shortcut will result in too high probabilities, especially\n     when n is small.\n\n     Pr(Kp(n) <= s) = 1 - pow(e, -2*s^2) * (1 - 2/3*s/sqrt(n) + O(1/n)) */\n\n  /* We have 's' in variable VAL and store the result in P. */\n\n  mpf_t t1, t2;\n\n  mpf_init (t1); mpf_init (t2);\n\n  /* t1 = 1 - 2/3 * s/sqrt(n) */\n  mpf_sqrt_ui (t1, n);\n  mpf_div (t1, val, t1);\n  mpf_mul_ui (t1, t1, 2);\n  mpf_div_ui (t1, t1, 3);\n  mpf_ui_sub (t1, 1, t1);\n\n  /* t2 = pow(e, -2*s^2) */\n#ifndef OLDGMP\n  mpf_pow_ui (t2, val, 2);\t/* t2 = s^2 */\n  mpf_set_d (t2, exp (-(2.0 * mpf_get_d (t2))));\n#else\n  /* hmmm, gmp doesn't have pow() for floats.  use doubles. */\n  mpf_set_d (t2, pow (M_E, -(2 * pow (mpf_get_d (val), 2))));\n#endif\n\n  /* p = 1 - t1 * t2 */\n  mpf_mul (t1, t1, t2);\n  mpf_ui_sub (p, 1, t1);\n\n  mpf_clear (t1); mpf_clear (t2);\n}",
      "lines": 37,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "x2_table": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "void\nx2_table (double t[],\n\t  unsigned int v)\n{\n  int f;\n\n\n  /* FIXME: Do a table lookup for v <= 30 since the following formula\n     [Knuth, vol 2, 3.3.1] is only good for v > 30. */\n\n  /* value = v + sqrt(2*v) * X[p] + (2/3) * X[p]^2 - 2/3 + O(1/sqrt(t) */\n  /* NOTE: The O() term is ignored for simplicity. */\n\n  for (f = 0; f < 7; f++)\n      t[f] =\n\tv +\n\tsqrt (2 * v) * x2_table_X[0][f] +\n\t_2D3 * x2_table_X[1][f] - _2D3;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "P": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "static void\nP (mpf_t p, mpf_t x)\n{\n  mpf_set (p, x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpf_freqt": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nmpf_freqt (mpf_t Kp,\n\t   mpf_t Km,\n\t   mpf_t X[],\n\t   const unsigned long int n)\n{\n  ks (Kp, Km, X, P, n);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "x2": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "void\nx2 (mpf_t V,\t\t\t/* result */\n    unsigned long int X[],\t/* data */\n    unsigned int k,\t\t/* #of categories */\n    void (P) (mpf_t, unsigned long int, void *), /* probability func */\n    void *x,\t\t\t/* extra user data passed to P() */\n    unsigned long int n)\t/* #of samples */\n{\n  unsigned int f;\n  mpf_t f_t, f_t2;\t\t/* temp floats */\n\n  mpf_init (f_t); mpf_init (f_t2);\n\n\n  mpf_set_ui (V, 0);\n  for (f = 0; f < k; f++)\n    {\n      if (g_debug > DEBUG_2)\n\tfprintf (stderr, \"%u: P()=\", f);\n      mpf_set_ui (f_t, X[f]);\n      mpf_mul (f_t, f_t, f_t);\t/* f_t = X[f]^2 */\n      P (f_t2, f, x);\t\t/* f_t2 = Pr(f) */\n      if (g_debug > DEBUG_2)\n\tmpf_out_str (stderr, 10, 2, f_t2);\n      mpf_div (f_t, f_t, f_t2);\n      mpf_add (V, V, f_t);\n      if (g_debug > DEBUG_2)\n\t{\n\t  fprintf (stderr, \"\\tV=\");\n\t  mpf_out_str (stderr, 10, 2, V);\n\t  fprintf (stderr, \"\\t\");\n\t}\n    }\n  if (g_debug > DEBUG_2)\n    fprintf (stderr, \"\\n\");\n  mpf_div_ui (V, V, n);\n  mpf_sub_ui (V, V, n);\n\n  mpf_clear (f_t); mpf_clear (f_t2);\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "Pzf": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "static void\nPzf (mpf_t p, unsigned long int s, void *x)\n{\n  mpf_set_ui (p, 1);\n  mpf_div_ui (p, p, *((unsigned int *) x));\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_freqt": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "unsigned long int\nmpz_freqt (mpf_t V,\n\t   mpz_t X[],\n\t   unsigned int imax,\n\t   const unsigned long int n)\n{\n  unsigned long int *v;\t\t/* result */\n  unsigned int f;\n  unsigned int d;\t\t/* number of categories = imax+1 */\n  unsigned int uitemp;\n  unsigned long int usedn;\n\n\n  d = imax + 1;\n\n  v = (unsigned long int *) calloc (imax + 1, sizeof (unsigned long int));\n  if (NULL == v)\n    {\n      fprintf (stderr, \"mpz_freqt(): out of memory\\n\");\n      exit (1);\n    }\n\n  /* count */\n  usedn = n;\t\t\t/* actual number of observations */\n  for (f = 0; f < n; f++)\n    {\n      uitemp = mpz_get_ui(X[f]);\n      if (uitemp > imax)\t/* sanity check */\n\t{\n\t  if (g_debug)\n\t    fprintf (stderr, \"mpz_freqt(): warning: input insanity: %u, \"\\\n\t\t     \"ignored.\\n\", uitemp);\n\t  usedn--;\n\t  continue;\n\t}\n      v[uitemp]++;\n    }\n\n  if (g_debug > DEBUG_2)\n    {\n      fprintf (stderr, \"counts:\\n\");\n      for (f = 0; f <= imax; f++)\n\tfprintf (stderr, \"%u:\\t%lu\\n\", f, v[f]);\n    }\n\n  /* chi-square with k=imax+1 and P(x)=1/(imax+1) for all x.*/\n  x2 (V, v, d, Pzf, (void *) &d, usedn);\n\n  free (v);\n  return (usedn);\n}",
      "lines": 51,
      "depth": 13,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    },
    "foo_debug": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "void\nfoo_debug ()\n{\n  if (0)\n    {\n      mpf_dump (0);\n#ifndef OLDGMP\n      mpz_dump (0);\n#endif\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "merit": {
      "start_point": [
        377,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "void\nmerit (mpf_t rop, unsigned int t, mpf_t v, mpz_t m)\n{\n  int f;\n  mpf_t f_m, f_const, f_pi;\n\n  mpf_init (f_m);\n  mpf_set_z (f_m, m);\n  mpf_init_set_d (f_const, M_PI);\n  mpf_init_set_d (f_pi, M_PI);\n\n  switch (t)\n    {\n    case 2:\t\t\t/* PI */\n      break;\n    case 3:\t\t\t/* PI * 4/3 */\n      mpf_mul_ui (f_const, f_const, 4);\n      mpf_div_ui (f_const, f_const, 3);\n      break;\n    case 4:\t\t\t/* PI^2 * 1/2 */\n      mpf_mul (f_const, f_const, f_pi);\n      mpf_div_ui (f_const, f_const, 2);\n      break;\n    case 5:\t\t\t/* PI^2 * 8/15 */\n      mpf_mul (f_const, f_const, f_pi);\n      mpf_mul_ui (f_const, f_const, 8);\n      mpf_div_ui (f_const, f_const, 15);\n      break;\n    case 6:\t\t\t/* PI^3 * 1/6 */\n      mpf_mul (f_const, f_const, f_pi);\n      mpf_mul (f_const, f_const, f_pi);\n      mpf_div_ui (f_const, f_const, 6);\n      break;\n    default:\n      fprintf (stderr,\n\t       \"spect (merit): can't calculate merit for dimensions > 6\\n\");\n      mpf_set_ui (f_const, 0);\n      break;\n    }\n\n  /* rop = v^t */\n  mpf_set (rop, v);\n  for (f = 1; f < t; f++)\n    mpf_mul (rop, rop, v);\n  mpf_mul (rop, rop, f_const);\n  mpf_div (rop, rop, f_m);\n\n  mpf_clear (f_m);\n  mpf_clear (f_const);\n  mpf_clear (f_pi);\n}",
      "lines": 51,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "merit_u": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "double\nmerit_u (unsigned int t, mpf_t v, mpz_t m)\n{\n  mpf_t rop;\n  double res;\n\n  mpf_init (rop);\n  merit (rop, t, v, m);\n  res = mpf_get_d (rop);\n  mpf_clear (rop);\n  return res;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "f_floor": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "void\nf_floor (mpf_t rop, mpf_t op)\n{\n  mpz_t z;\n\n  mpz_init (z);\n\n  /* No mpf_floor().  Convert to mpz and back. */\n  mpz_set_f (z, op);\n  mpf_set_z (rop, z);\n\n  mpz_clear (z);\n}",
      "lines": 13,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "vz_dot": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "void\nvz_dot (mpz_t rop, mpz_t V1[], mpz_t V2[], unsigned int n)\n{\n  mpz_t t;\n\n  mpz_init (t);\n  mpz_set_ui (rop, 0);\n  while (n--)\n    {\n      mpz_mul (t, V1[n], V2[n]);\n      mpz_add (rop, rop, t);\n    }\n\n  mpz_clear (t);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spectral_test": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "void\nspectral_test (mpf_t rop[], unsigned int T, mpz_t a, mpz_t m)\n{\n  /* Knuth \"Seminumerical Algorithms, Third Edition\", section 3.3.4\n     (pp. 101-103). */\n\n  /* v[t] = min { sqrt (x[1]^2 + ... + x[t]^2) |\n     x[1] + a*x[2] + ... + pow (a, t-1) * x[t] is congruent to 0 (mod m) } */\n\n\n  /* Variables. */\n  unsigned int ui_t;\n  unsigned int ui_i, ui_j, ui_k, ui_l;\n  mpf_t f_tmp1, f_tmp2;\n  mpz_t tmp1, tmp2, tmp3;\n  mpz_t U[GMP_SPECT_MAXT][GMP_SPECT_MAXT],\n    V[GMP_SPECT_MAXT][GMP_SPECT_MAXT],\n    X[GMP_SPECT_MAXT],\n    Y[GMP_SPECT_MAXT],\n    Z[GMP_SPECT_MAXT];\n  mpz_t h, hp, r, s, p, pp, q, u, v;\n\n  /* GMP inits. */\n  mpf_init (f_tmp1);\n  mpf_init (f_tmp2);\n  for (ui_i = 0; ui_i < GMP_SPECT_MAXT; ui_i++)\n    {\n      for (ui_j = 0; ui_j < GMP_SPECT_MAXT; ui_j++)\n\t{\n\t  mpz_init_set_ui (U[ui_i][ui_j], 0);\n\t  mpz_init_set_ui (V[ui_i][ui_j], 0);\n\t}\n      mpz_init_set_ui (X[ui_i], 0);\n      mpz_init_set_ui (Y[ui_i], 0);\n      mpz_init (Z[ui_i]);\n    }\n  mpz_init (tmp1);\n  mpz_init (tmp2);\n  mpz_init (tmp3);\n  mpz_init (h);\n  mpz_init (hp);\n  mpz_init (r);\n  mpz_init (s);\n  mpz_init (p);\n  mpz_init (pp);\n  mpz_init (q);\n  mpz_init (u);\n  mpz_init (v);\n\n  /* Implementation inits. */\n  if (T > GMP_SPECT_MAXT)\n    T = GMP_SPECT_MAXT;\t\t\t/* FIXME: Lazy. */\n\n  /* S1 [Initialize.] */\n  ui_t = 2 - 1;\t\t\t/* NOTE: `t' in description == ui_t + 1\n\t\t\t\t   for easy indexing */\n  mpz_set (h, a);\n  mpz_set (hp, m);\n  mpz_set_ui (p, 1);\n  mpz_set_ui (pp, 0);\n  mpz_set (r, a);\n  mpz_pow_ui (s, a, 2);\n  mpz_add_ui (s, s, 1);\t\t/* s = 1 + a^2 */\n\n  /* S2 [Euclidean step.] */\n  while (1)\n    {\n      if (g_debug > DEBUG_1)\n\t{\n\t  mpz_mul (tmp1, h, pp);\n\t  mpz_mul (tmp2, hp, p);\n\t  mpz_sub (tmp1, tmp1, tmp2);\n\t  if (mpz_cmpabs (m, tmp1))\n\t    {\n\t      printf (\"***BUG***: h*pp - hp*p = \");\n\t      mpz_out_str (stdout, 10, tmp1);\n\t      printf (\"\\n\");\n\t    }\n\t}\n      if (g_debug > DEBUG_2)\n\t{\n\t  printf (\"hp = \");\n\t  mpz_out_str (stdout, 10, hp);\n\t  printf (\"\\nh = \");\n\t  mpz_out_str (stdout, 10, h);\n\t  printf (\"\\n\");\n\t  fflush (stdout);\n\t}\n\n      if (mpz_sgn (h))\n\tmpz_tdiv_q (q, hp, h);\t/* q = floor(hp/h) */\n      else\n\tmpz_set_ui (q, 1);\n\n      if (g_debug > DEBUG_2)\n\t{\n\t  printf (\"q = \");\n\t  mpz_out_str (stdout, 10, q);\n\t  printf (\"\\n\");\n\t  fflush (stdout);\n\t}\n\n      mpz_mul (tmp1, q, h);\n      mpz_sub (u, hp, tmp1);\t/* u = hp - q*h */\n\n      mpz_mul (tmp1, q, p);\n      mpz_sub (v, pp, tmp1);\t/* v = pp - q*p */\n\n      mpz_pow_ui (tmp1, u, 2);\n      mpz_pow_ui (tmp2, v, 2);\n      mpz_add (tmp1, tmp1, tmp2);\n      if (mpz_cmp (tmp1, s) < 0)\n\t{\n\t  mpz_set (s, tmp1);\t/* s = u^2 + v^2 */\n\t  mpz_set (hp, h);\t/* hp = h */\n\t  mpz_set (h, u);\t/* h = u */\n\t  mpz_set (pp, p);\t/* pp = p */\n\t  mpz_set (p, v);\t/* p = v */\n\t}\n      else\n\tbreak;\n    }\n\n  /* S3 [Compute v2.] */\n  mpz_sub (u, u, h);\n  mpz_sub (v, v, p);\n\n  mpz_pow_ui (tmp1, u, 2);\n  mpz_pow_ui (tmp2, v, 2);\n  mpz_add (tmp1, tmp1, tmp2);\n  if (mpz_cmp (tmp1, s) < 0)\n    {\n      mpz_set (s, tmp1);\t/* s = u^2 + v^2 */\n      mpz_set (hp, u);\n      mpz_set (pp, v);\n    }\n  mpf_set_z (f_tmp1, s);\n  mpf_sqrt (rop[ui_t - 1], f_tmp1);\n\n  /* S4 [Advance t.] */\n  mpz_neg (U[0][0], h);\n  mpz_set (U[0][1], p);\n  mpz_neg (U[1][0], hp);\n  mpz_set (U[1][1], pp);\n\n  mpz_set (V[0][0], pp);\n  mpz_set (V[0][1], hp);\n  mpz_neg (V[1][0], p);\n  mpz_neg (V[1][1], h);\n  if (mpz_cmp_ui (pp, 0) > 0)\n    {\n      mpz_neg (V[0][0], V[0][0]);\n      mpz_neg (V[0][1], V[0][1]);\n      mpz_neg (V[1][0], V[1][0]);\n      mpz_neg (V[1][1], V[1][1]);\n    }\n\n  while (ui_t + 1 != T)\t\t/* S4 loop */\n    {\n      ui_t++;\n      mpz_mul (r, a, r);\n      mpz_mod (r, r, m);\n\n      /* Add new row and column to U and V.  They are initialized with\n\t all elements set to zero, so clearing is not necessary. */\n\n      mpz_neg (U[ui_t][0], r); /* U: First col in new row. */\n      mpz_set_ui (U[ui_t][ui_t], 1); /* U: Last col in new row. */\n\n      mpz_set (V[ui_t][ui_t], m); /* V: Last col in new row. */\n\n      /* \"Finally, for 1 <= i < t,\n\t   set q = round (vi1 * r / m),\n\t   vit = vi1*r - q*m,\n\t   and Ut=Ut+q*Ui */\n\n      for (ui_i = 0; ui_i < ui_t; ui_i++)\n\t{\n\t  mpz_mul (tmp1, V[ui_i][0], r); /* tmp1=vi1*r */\n\t  zdiv_round (q, tmp1, m); /* q=round(vi1*r/m) */\n\t  mpz_mul (tmp2, q, m);\t/* tmp2=q*m */\n\t  mpz_sub (V[ui_i][ui_t], tmp1, tmp2);\n\n\t  for (ui_j = 0; ui_j <= ui_t; ui_j++) /* U[t] = U[t] + q*U[i] */\n\t    {\n\t      mpz_mul (tmp1, q, U[ui_i][ui_j]);\t/* tmp=q*uij */\n\t      mpz_add (U[ui_t][ui_j], U[ui_t][ui_j], tmp1); /* utj = utj + q*uij */\n\t    }\n\t}\n\n      /* s = min (s, zdot (U[t], U[t]) */\n      vz_dot (tmp1, U[ui_t], U[ui_t], ui_t + 1);\n      if (mpz_cmp (tmp1, s) < 0)\n\tmpz_set (s, tmp1);\n\n      ui_k = ui_t;\n      ui_j = 0;\t\t\t/* WARNING: ui_j no longer a temp. */\n\n      /* S5 [Transform.] */\n      if (g_debug > DEBUG_2)\n\tprintf (\"(t, k, j, q1, q2, ...)\\n\");\n      do\n\t{\n\t  if (g_debug > DEBUG_2)\n\t    printf (\"(%u, %u, %u\", ui_t + 1, ui_k + 1, ui_j + 1);\n\n\t  for (ui_i = 0; ui_i <= ui_t; ui_i++)\n\t    {\n\t      if (ui_i != ui_j)\n\t\t{\n\t\t  vz_dot (tmp1, V[ui_i], V[ui_j], ui_t + 1); /* tmp1=dot(Vi,Vj). */\n\t\t  mpz_abs (tmp2, tmp1);\n\t\t  mpz_mul_ui (tmp2, tmp2, 2); /* tmp2 = 2*abs(dot(Vi,Vj) */\n\t\t  vz_dot (tmp3, V[ui_j], V[ui_j], ui_t + 1); /* tmp3=dot(Vj,Vj). */\n\n\t\t  if (mpz_cmp (tmp2, tmp3) > 0)\n\t\t    {\n\t\t      zdiv_round (q, tmp1, tmp3); /* q=round(Vi.Vj/Vj.Vj) */\n\t\t      if (g_debug > DEBUG_2)\n\t\t\t{\n\t\t\t  printf (\", \");\n\t\t\t  mpz_out_str (stdout, 10, q);\n\t\t\t}\n\n\t\t      for (ui_l = 0; ui_l <= ui_t; ui_l++)\n\t\t\t{\n\t\t\t  mpz_mul (tmp1, q, V[ui_j][ui_l]);\n\t\t\t  mpz_sub (V[ui_i][ui_l], V[ui_i][ui_l], tmp1); /* Vi=Vi-q*Vj */\n\t\t\t  mpz_mul (tmp1, q, U[ui_i][ui_l]);\n\t\t\t  mpz_add (U[ui_j][ui_l], U[ui_j][ui_l], tmp1); /* Uj=Uj+q*Ui */\n\t\t\t}\n\n\t\t      vz_dot (tmp1, U[ui_j], U[ui_j], ui_t + 1); /* tmp1=dot(Uj,Uj) */\n\t\t      if (mpz_cmp (tmp1, s) < 0) /* s = min(s,dot(Uj,Uj)) */\n\t\t\tmpz_set (s, tmp1);\n\t\t      ui_k = ui_j;\n\t\t    }\n\t\t  else if (g_debug > DEBUG_2)\n\t\t    printf (\", #\"); /* 2|Vi.Vj| <= Vj.Vj */\n\t\t}\n\t      else if (g_debug > DEBUG_2)\n\t\tprintf (\", *\");\t/* i == j */\n\t    }\n\n\t  if (g_debug > DEBUG_2)\n\t    printf (\")\\n\");\n\n\t  /* S6 [Advance j.] */\n\t  if (ui_j == ui_t)\n\t    ui_j = 0;\n\t  else\n\t    ui_j++;\n\t}\n      while (ui_j != ui_k);\t/* S5 */\n\n      /* From Knuth p. 104: \"The exhaustive search in steps S8-S10\n\t reduces the value of s only rarely.\" */\n#ifdef DO_SEARCH\n      /* S7 [Prepare for search.] */\n      /* Find minimum in (x[1], ..., x[t]) satisfying condition\n\t x[k]^2 <= f(y[1], ...,y[t]) * dot(V[k],V[k]) */\n\n      ui_k = ui_t;\n      if (g_debug > DEBUG_2)\n\t{\n\t  printf (\"searching...\");\n\t  /*for (f = 0; f < ui_t*/\n\t  fflush (stdout);\n\t}\n\n      /* Z[i] = floor (sqrt (floor (dot(V[i],V[i]) * s / m^2))); */\n      mpz_pow_ui (tmp1, m, 2);\n      mpf_set_z (f_tmp1, tmp1);\n      mpf_set_z (f_tmp2, s);\n      mpf_div (f_tmp1, f_tmp2, f_tmp1);\t/* f_tmp1 = s/m^2 */\n      for (ui_i = 0; ui_i <= ui_t; ui_i++)\n\t{\n\t  vz_dot (tmp1, V[ui_i], V[ui_i], ui_t + 1);\n\t  mpf_set_z (f_tmp2, tmp1);\n\t  mpf_mul (f_tmp2, f_tmp2, f_tmp1);\n\t  f_floor (f_tmp2, f_tmp2);\n\t  mpf_sqrt (f_tmp2, f_tmp2);\n\t  mpz_set_f (Z[ui_i], f_tmp2);\n\t}\n\n      /* S8 [Advance X[k].] */\n      do\n\t{\n\t  if (g_debug > DEBUG_2)\n\t    {\n\t      printf (\"X[%u] = \", ui_k);\n\t      mpz_out_str (stdout, 10, X[ui_k]);\n\t      printf (\"\\tZ[%u] = \", ui_k);\n\t      mpz_out_str (stdout, 10, Z[ui_k]);\n\t      printf (\"\\n\");\n\t      fflush (stdout);\n\t    }\n\n\t  if (mpz_cmp (X[ui_k], Z[ui_k]))\n\t    {\n\t      mpz_add_ui (X[ui_k], X[ui_k], 1);\n\t      for (ui_i = 0; ui_i <= ui_t; ui_i++)\n\t\tmpz_add (Y[ui_i], Y[ui_i], U[ui_k][ui_i]);\n\n\t      /* S9 [Advance k.] */\n\t      while (++ui_k <= ui_t)\n\t\t{\n\t\t  mpz_neg (X[ui_k], Z[ui_k]);\n\t\t  mpz_mul_ui (tmp1, Z[ui_k], 2);\n\t\t  for (ui_i = 0; ui_i <= ui_t; ui_i++)\n\t\t    {\n\t\t      mpz_mul (tmp2, tmp1, U[ui_k][ui_i]);\n\t\t      mpz_sub (Y[ui_i], Y[ui_i], tmp2);\n\t\t    }\n\t\t}\n\t      vz_dot (tmp1, Y, Y, ui_t + 1);\n\t      if (mpz_cmp (tmp1, s) < 0)\n\t\tmpz_set (s, tmp1);\n\t    }\n\t}\n      while (--ui_k);\n#endif /* DO_SEARCH */\n      mpf_set_z (f_tmp1, s);\n      mpf_sqrt (rop[ui_t - 1], f_tmp1);\n#ifdef DO_SEARCH\n      if (g_debug > DEBUG_2)\n\tprintf (\"done.\\n\");\n#endif /* DO_SEARCH */\n    } /* S4 loop */\n\n  /* Clear GMP variables. */\n\n  mpf_clear (f_tmp1);\n  mpf_clear (f_tmp2);\n  for (ui_i = 0; ui_i < GMP_SPECT_MAXT; ui_i++)\n    {\n      for (ui_j = 0; ui_j < GMP_SPECT_MAXT; ui_j++)\n\t{\n\t  mpz_clear (U[ui_i][ui_j]);\n\t  mpz_clear (V[ui_i][ui_j]);\n\t}\n      mpz_clear (X[ui_i]);\n      mpz_clear (Y[ui_i]);\n      mpz_clear (Z[ui_i]);\n    }\n  mpz_clear (tmp1);\n  mpz_clear (tmp2);\n  mpz_clear (tmp3);\n  mpz_clear (h);\n  mpz_clear (hp);\n  mpz_clear (r);\n  mpz_clear (s);\n  mpz_clear (p);\n  mpz_clear (pp);\n  mpz_clear (q);\n  mpz_clear (u);\n  mpz_clear (v);\n\n  return;\n}",
      "lines": 360,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/t-iset.c": {
    "check_one": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\ncheck_one (const char *name, gmp_randstate_ptr src)\n{\n  gmp_randstate_t dst;\n  mpz_t  sz, dz;\n  int    i;\n\n  gmp_randinit_set (dst, src);\n  mpz_init (sz);\n  mpz_init (dz);\n\n  for (i = 0; i < 20; i++)\n    {\n      mpz_urandomb (sz, src, 123);\n      mpz_urandomb (dz, dst, 123);\n\n      if (mpz_cmp (sz, dz) != 0)\n        {\n          printf     (\"gmp_randinit_set didn't duplicate randstate\\n\");\n          printf     (\"  algorithm: %s\\n\", name);\n          gmp_printf (\"  from src:  %#Zx\\n\", sz);\n          gmp_printf (\"  from dst:  %#Zx\\n\", dz);\n          abort ();\n        }\n    }\n\n  mpz_clear (sz);\n  mpz_clear (dz);\n  gmp_randclear (dst);\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  call_rand_algs (check_one);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/t-lc2exp.c": {
    "check_zero": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\ncheck_zero (unsigned long m2exp)\n{\n  gmp_randstate_t  r;\n  mpz_t            a;\n  unsigned long    c;\n  int              i;\n\n  mpz_init_set_ui (a, 0L);\n  c = 0L;\n\n  gmp_randinit_lc_2exp (r, a, c, m2exp);\n  gmp_randseed_ui (r, 0L);\n\n  for (i = 0; i < 5; i++)\n    {\n      mpz_urandomb (a, r, 123L);\n      if (mpz_sgn (a) != 0)\n        {\n          printf (\"check_zero m2exp=%lu: didn't get zero\\n\", m2exp);\n          gmp_printf (\"  rand=%#Zx\\n\", a);\n          abort ();\n        }\n    }\n\n  mpz_clear (a);\n  gmp_randclear (r);\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_nega": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "void\ncheck_nega (void)\n{\n  gmp_randstate_t  r;\n  mpz_t            a;\n  unsigned long    c, m2exp;\n  int              i;\n\n  mpz_init (a);\n  mpz_setbit (a, 1000L);\n  mpz_neg (a, a);\n  c = 0L;\n  m2exp = 45L;\n\n  gmp_randinit_lc_2exp (r, a, c, m2exp);\n  gmp_randseed_ui (r, 0L);\n\n  for (i = 0; i < 5; i++)\n    {\n      mpz_urandomb (a, r, 123L);\n      if (mpz_sgn (a) != 0)\n        printf (\"check_nega m2exp=%lu: didn't get zero\\n\", m2exp);\n    }\n\n  mpz_clear (a);\n  gmp_randclear (r);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_bigc": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\ncheck_bigc (void)\n{\n  gmp_randstate_t  r;\n  mpz_t            a;\n  unsigned long    c, m2exp, bits;\n  int              i;\n\n  mpz_init_set_ui (a, 0L);\n  c = ULONG_MAX;\n  m2exp = 8;\n\n  gmp_randinit_lc_2exp (r, a, c, m2exp);\n  gmp_randseed_ui (r, 0L);\n\n  for (i = 0; i < 20; i++)\n    {\n      bits = 123L;\n      mpz_urandomb (a, r, bits);\n      if (mpz_sgn (a) < 0 || mpz_sizeinbase (a, 2) > bits)\n        {\n          printf     (\"check_bigc: mpz_urandomb out of range\\n\");\n          printf     (\"   m2exp=%lu\\n\", m2exp);\n          gmp_printf (\"   rand=%#ZX\\n\", a);\n          gmp_printf (\"   sizeinbase2=%u\\n\", mpz_sizeinbase (a, 2));\n\t  abort ();\n        }\n    }\n\n  mpz_clear (a);\n  gmp_randclear (r);\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_bigc1": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\ncheck_bigc1 (void)\n{\n  gmp_randstate_t  r;\n  mpz_t            a;\n  unsigned long    c, m2exp;\n  int              i;\n\n  mpz_init_set_ui (a, 0L);\n  c = ULONG_MAX;\n  m2exp = 2;\n\n  gmp_randinit_lc_2exp (r, a, c, m2exp);\n  gmp_randseed_ui (r, 0L);\n\n  for (i = 0; i < 20; i++)\n    {\n      mpz_urandomb (a, r, 1L);\n      if (mpz_cmp_ui (a, 1L) != 0)\n        {\n          printf     (\"check_bigc1: mpz_urandomb didn't give 1\\n\");\n          printf     (\"   m2exp=%lu\\n\", m2exp);\n          gmp_printf (\"   got rand=%#ZX\\n\", a);\n          abort ();\n        }\n    }\n\n  mpz_clear (a);\n  gmp_randclear (r);\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_bigm": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\ncheck_bigm (void)\n{\n  gmp_randstate_t rstate;\n  mpz_t a;\n\n  mpz_init_set_ui (a, 5L);\n  gmp_randinit_lc_2exp (rstate, a, 1L, 384L);\n\n  mpz_urandomb (a, rstate, 20L);\n\n  gmp_randclear (rstate);\n  mpz_clear (a);\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_bigs": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "void\ncheck_bigs (void)\n{\n  gmp_randstate_t rstate;\n  mpz_t sd, a;\n  int i;\n\n  mpz_init (sd);\n  mpz_setbit (sd, 300L);\n  mpz_sub_ui (sd, sd, 1L);\n  mpz_clrbit (sd, 13L);\n  mpz_init_set_ui (a, 123456789L);\n\n  gmp_randinit_lc_2exp (rstate, a, 5L, 64L);\n\n  for (i = 0; i < 20; i++)\n    {\n      mpz_neg (sd, sd);\n      gmp_randseed (rstate, sd);\n      mpz_mul_ui (sd, sd, 7L);\n\n      mpz_urandomb (a, rstate, 80L);\n    }\n\n  gmp_randclear (rstate);\n  mpz_clear (a);\n  mpz_clear (sd);\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "int\nmain (void)\n{\n  tests_start ();\n\n  check_zero (2L);\n  check_zero (7L);\n  check_zero (32L);\n  check_zero (64L);\n  check_zero (1000L);\n\n  check_nega ();\n  check_bigc ();\n  check_bigc1 ();\n\n  check_bigm ();\n  check_bigs ();\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 21,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/t-mt.c": {
    "chk_default_seed": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nchk_default_seed (void)\n{\n  gmp_randstate_t r1, r2;\n  mpz_t a, b;\n  int i;\n  int ok = TRUE;\n\n  mpz_init2 (a, 19936L);\n  mpz_init2 (b, 19936L);\n\n  gmp_randinit_mt (r1);\n  gmp_randinit_mt (r2);\n  gmp_randseed_ui (r2, 5489L); /* Must match DEFAULT_SEED in randmt.c */\n  for (i = 0; i < 3; i++)\n    {\n      /* Extract one whole buffer per iteration.  */\n      mpz_urandomb (a, r1, 19936L);\n      mpz_urandomb (b, r2, 19936L);\n      if (mpz_cmp (a, b) != 0)\n\t{\n\t  ok = FALSE;\n\t  printf (\"Default seed fails in iteration %d\\n\", i);\n\t  break;\n\t}\n    }\n  gmp_randclear (r1);\n  gmp_randclear (r2);\n\n  mpz_clear (a);\n  mpz_clear (b);\n  return ok;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int ok;\n\n  tests_start ();\n\n  ok = chk_default_seed ();\n\n  tests_end ();\n\n  if (ok)\n    return 0; /* pass */\n  else\n    return 1; /* fail */\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/t-rand.c": {
    "main": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  static char usage[] = \"\\\nusage: t-rand [function nbits]\\n\\\n  function is one of z, f\\n\\\n  nbits is number of bits\\n\\\n\";\n  gmp_randstate_t rstate;\n  mpz_t z, rz;\n  mpf_t f, rf;\n  enum { Z, F } func = Z;\n  int nbits = 1;\n  int verify_mode_flag = 1;\n  int i;\n  struct rt *a;\n\n\n  if (argc > 1)\n    {\n      if (argc < 3)\n\t{\n\t  fputs (usage, stderr);\n\t  exit (1);\n\t}\n      verify_mode_flag = 0;\n      if (*argv[1] == 'z')\n\tfunc = Z;\n      if (*argv[1] == 'f')\n\tfunc = F;\n      nbits = atoi (argv[2]);\n    }\n\n  mpz_init (rz);\n\n  if (verify_mode_flag)\n    {\n#ifdef VERBOSE\n      printf (\"%s: verifying random numbers: \", argv[0]);\n#endif\n\n      /* Test z.  */\n      mpz_init (z);\n      for (a = zarr; a->s != NULL; a++)\n\t{\n\t  gmp_randinit (rstate, GMP_RAND_ALG_LC, a->nbits);\n\t  if (gmp_errno != GMP_ERROR_NONE)\n\t    exit (1);\n\t  gmp_randseed_ui (rstate, SEED);\n\n\t  for (i = 0; i < ENTS; i++)\n\t    {\n\t      mpz_urandomb (rz, rstate, a->nbits);\n\t      mpz_set_str (z, a->s[i], BASE);\n\t      if (mpz_cmp (z, rz) != 0)\n\t\t{\n\t\t  printf (\"z%d: \", a->nbits);\n\t\t  mpz_out_str (stdout, BASE, rz);\n\t\t  printf (\" should be \");\n\t\t  mpz_out_str (stdout, BASE, z);\n\t\t  puts (\"\");\n\t\t  exit (1);\n\t\t}\n\t    }\n#ifdef VERBOSE\n\t  printf (\"z%d \", a->nbits);\n#endif\n\t  gmp_randclear (rstate);\n\t}\n      mpz_clear (z);\n\n\n      /* Test f.  */\n      for (a = farr; a->s != NULL; a++)\n\t{\n\t  gmp_randinit (rstate, GMP_RAND_ALG_LC, a->nbits);\n\t  if (gmp_errno != GMP_ERROR_NONE)\n\t    exit (1);\n\t  gmp_randseed_ui (rstate, SEED);\n\n\t  mpf_init2 (f, a->nbits);\n\t  mpf_init2 (rf, a->nbits);\n\t  for (i = 0; i < ENTS; i++)\n\t    {\n\t      mpf_urandomb (rf, rstate, a->nbits);\n\t      mpf_set_str (f, a->s[i], BASE);\n\t      if (mpf_cmp (f, rf) != 0)\n\t\t{\n\t\t  printf (\"f%d: \", a->nbits);\n\t\t  mpf_out_str (stdout, BASE, a->nbits, rf);\n\t\t  printf (\" should be \");\n\t\t  mpf_out_str (stdout, BASE, a->nbits, f);\n\t\t  puts (\"\");\n\t\t  exit (1);\n\t\t}\n\t    }\n#ifdef VERBOSE\n\t  printf (\"f%d \", a->nbits);\n#endif\n\t  gmp_randclear (rstate);\n\t  mpf_clear (f);\n\t  mpf_clear (rf);\n\t}\n\n#ifdef VERBOSE\n      puts (\"\");\n#endif\n    }\n  else\t\t\t\t/* Print mode.  */\n    {\n      gmp_randinit (rstate, GMP_RAND_ALG_LC, nbits);\n      if (gmp_errno != GMP_ERROR_NONE)\n\texit (1);\n      gmp_randseed_ui (rstate, SEED);\n\n      switch (func)\n\t{\n\tcase Z:\n\t  printf (\"char *z%d[ENTS] = {\", nbits);\n\t  for (i = 0; i < ENTS; i++)\n\t    {\n\t      mpz_urandomb (rz, rstate, nbits);\n\t      printf (\"\\\"\");\n\t      mpz_out_str (stdout, BASE, rz);\n\t      printf (\"\\\"\");\n\t      if (i != ENTS - 1)\n\t\tprintf (\", \");\n\t    }\n\t  printf (\"};\\n\");\n\t  printf (\"  {z%d, %d},\\n\", nbits, nbits);\n\t  break;\n\n\tcase F:\n\t  printf (\"char *f%d[ENTS] = {\", nbits);\n\t  mpf_init2 (rf, nbits);\n\t  for (i = 0; i < ENTS; i++)\n\t    {\n\t      mpf_urandomb (rf, rstate, nbits);\n\t      printf (\"\\\"\");\n\t      mpf_out_str (stdout, BASE, nbits, rf);\n\t      printf (\"\\\"\");\n\t      if (i != ENTS - 1)\n\t\tprintf (\", \");\n\t    }\n\t  printf (\"};\\n\");\n\t  printf (\"  {f%d, %d},\\n\", nbits, nbits);\n\t  mpf_clear (rf);\n\t  break;\n\n\tdefault:\n\t  exit (1);\n\t}\n\n      gmp_randclear (rstate);\n    }\n\n  mpz_clear (rz);\n\n  return 0;\n}",
      "lines": 160,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/t-urbui.c": {
    "check_one": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\ncheck_one (const char *name, gmp_randstate_ptr rstate)\n{\n  unsigned long  bits, limit, got;\n  int    i;\n\n  for (bits = 0; bits < BITS_PER_ULONG; bits++)\n    {\n      /* will demand got < limit */\n      limit = (1UL << bits);\n\n      for (i = 0; i < 5; i++)\n        {\n          got = gmp_urandomb_ui (rstate, bits);\n          if (got >= limit)\n            {\n              printf (\"Return value out of range:\\n\");\n              printf (\"  algorithm: %s\\n\", name);\n              printf (\"  bits:  %lu\\n\", bits);\n              printf (\"  limit: %#lx\\n\", limit);\n              printf (\"  got:   %#lx\\n\", got);\n              abort ();\n            }\n        }\n    }\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  call_rand_algs (check_one);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/t-urmui.c": {
    "check_one": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\ncheck_one (const char *name, gmp_randstate_ptr rstate)\n{\n  static const unsigned long  n_table[] = {\n    1, 2, 3, 4, 5, 6, 7, 8,\n    123, 456, 789,\n\n    255, 256, 257,\n    1023, 1024, 1025,\n    32767, 32768, 32769,\n\n    ULONG_MAX/2-2, ULONG_MAX/2-1, ULONG_MAX/2, ULONG_MAX/2+1, ULONG_MAX/2+2,\n\n    ULONG_MAX-2, ULONG_MAX-1, ULONG_MAX,\n  };\n\n  unsigned long  got, n;\n  int    i, j;\n\n  for (i = 0; i < numberof (n_table); i++)\n    {\n      n = n_table[i];\n\n      for (j = 0; j < 5; j++)\n        {\n          got = gmp_urandomm_ui (rstate, n);\n          if (got >= n)\n            {\n              printf (\"Return value out of range:\\n\");\n              printf (\"  algorithm: %s\\n\", name);\n              printf (\"  n:     %#lx\\n\", n);\n              printf (\"  got:   %#lx\\n\", got);\n              abort ();\n            }\n        }\n    }\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  tests_start ();\n\n  call_rand_algs (check_one);\n\n  tests_end ();\n  exit (0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/t-urndmm.c": {
    "check_params": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\ncheck_params (void)\n{\n  gmp_randstate_t r1, r2;\n  mpz_t a, b, m;\n  int i;\n  int result;\n\n  result = TRUE;\n\n  mpz_init (a);\n  mpz_init (b);\n  mpz_init (m);\n\n  if (result)\n    {\n      /* Test the consistency between urandomm and urandomb. */\n      gmp_randinit_default (r1);\n      gmp_randinit_default (r2);\n      gmp_randseed_ui (r1, 85L);\n      gmp_randseed_ui (r2, 85L);\n      mpz_set_ui (m, 0L);\n      mpz_setbit (m, 80L);\n      for (i = 0; i < 100; i++)\n\t{\n\t  mpz_urandomm (a, r1, m);\n\t  mpz_urandomb (b, r2, 80L);\n\t  if (mpz_cmp (a, b) != 0)\n\t    {\n\t      result = FALSE;\n\t      printf (\"mpz_urandomm != mpz_urandomb\\n\");\n\t      break;\n\t    }\n\t}\n      gmp_randclear (r1);\n      gmp_randclear (r2);\n    }\n\n  if (result)\n    {\n      /* Test that mpz_urandomm returns the correct result with a\n\t broken LC.  */\n      mpz_set_ui (a, 0L);\n      gmp_randinit_lc_2exp (r1, a, 0xffL, 8L);\n      mpz_set_ui (m, 5L);\n      /* Warning: This code hangs in gmp 4.1 and below */\n      for (i = 0; i < 100; i++)\n\t{\n\t  mpz_urandomm (a, r1, m);\n\t  if (mpz_cmp_ui (a, 2L) != 0)\n\t    {\n\t      result = FALSE;\n\t      gmp_printf (\"mpz_urandomm returns %Zd instead of 2\\n\", a);\n\t      break;\n\t    }\n\t}\n      gmp_randclear (r1);\n    }\n\n  if (result)\n    {\n      /* Test that the results are always in range for either\n         positive or negative values of m.  */\n      gmp_randinit_default (r1);\n      mpz_set_ui (m, 5L);\n      mpz_set_si (b, -5L);\n      for (i = 0; i < 100; i++)\n\t{\n\t  mpz_urandomm (a, r1, m);\n\t  if (mpz_cmp_ui (a, 5L) >= 0 || mpz_sgn (a) < 0)\n\t    {\n\t      result = FALSE;\n\t      gmp_printf (\"Out-of-range or non-positive value: %Zd\\n\", a);\n\t      break;\n\t    }\n\t  mpz_urandomm (a, r1, b);\n\t  if (mpz_cmp_ui (a, 5L) >= 0 || mpz_sgn (a) < 0)\n\t    {\n\t      result = FALSE;\n\t      gmp_printf (\"Out-of-range or non-positive value (from negative modulus): %Zd\\n\", a);\n\t      break;\n\t    }\n\t}\n      gmp_randclear (r1);\n    }\n\n  if (result)\n    {\n      /* Test that m=1 forces always result=0.  */\n      gmp_randinit_default (r1);\n      mpz_set_ui (m, 1L);\n      for (i = 0; i < 100; i++)\n\t{\n\t  mpz_urandomm (a, r1, m);\n\t  if (mpz_sgn (a) != 0)\n\t    {\n\t      result = FALSE;\n\t      gmp_printf (\"mpz_urandomm fails with m=1 (result=%Zd)\\n\", a);\n\t      break;\n\t    }\n\t}\n      gmp_randclear (r1);\n    }\n\n  mpz_clear (a);\n  mpz_clear (b);\n  mpz_clear (m);\n  return result;\n}",
      "lines": 109,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int result = TRUE;\n\n  tests_start ();\n\n  if (result)\n    if (!check_params ())\n      result = FALSE;\n\n  tests_end ();\n\n  if (result)\n    return 0; /* pass */\n  else\n    return 1; /* fail */\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tests/rand/zdiv_round.c": {
    "zdiv_round": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\nzdiv_round (mpz_t rop, mpz_t n, mpz_t d)\n{\n  mpf_t f_n, f_d;\n\n  mpf_init (f_n);\n  mpf_init (f_d);\n\n  mpf_set_z (f_d, d);\n  mpf_set_z (f_n, n);\n\n  mpf_div (f_n, f_n, f_d);\n  mpf_set_d (f_d, .5);\n  if (mpf_sgn (f_n) < 0)\n    mpf_neg (f_d, f_d);\n  mpf_add (f_n, f_n, f_d);\n  mpz_set_f (rop, f_n);\n\n  mpf_clear (f_n);\n  mpf_clear (f_d);\n  return;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tune/common.c": {
    "pentium_wbinvd": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void\npentium_wbinvd(void)\n{\n#if 0\n  {\n    static int  fd = -2;\n\n    if (fd == -2)\n      {\n\tfd = open (\"/dev/wbinvd\", O_RDWR);\n\tif (fd == -1)\n\t  perror (\"open /dev/wbinvd\");\n      }\n\n    if (fd != -1)\n      ioctl (fd, 0, 0);\n  }\n#endif\n\n#if 0\n#define WBINVDSIZE  1024*1024*2\n  {\n    static char  *p = NULL;\n    int   i, sum;\n\n    if (p == NULL)\n      p = malloc (WBINVDSIZE);\n\n#if 0\n    for (i = 0; i < WBINVDSIZE; i++)\n      p[i] = i & 0xFF;\n#endif\n\n    sum = 0;\n    for (i = 0; i < WBINVDSIZE; i++)\n      sum += p[i];\n\n    mpn_cache_fill_dummy (sum);\n  }\n#endif\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "double_cmp_ptr": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\ndouble_cmp_ptr (const double *p, const double *q)\n{\n  if (*p > *q)  return 1;\n  if (*p < *q)  return -1;\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "speed_measure": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "double\nspeed_measure (double (*fun) (struct speed_params *s), struct speed_params *s)\n{\n#define TOLERANCE    1.01  /* 1% */\n  const int max_zeros = 10;\n\n  struct speed_params  s_dummy;\n  int     i, j, e;\n  double  t[30];\n  double  t_unsorted[30];\n  double  reps_d;\n  int     zeros = 0;\n\n  /* Use dummy parameters if caller doesn't provide any.  Only a few special\n     \"fun\"s will cope with this, speed_noop() is one.  */\n  if (s == NULL)\n    {\n      memset (&s_dummy, '\\0', sizeof (s_dummy));\n      s = &s_dummy;\n    }\n\n  s->reps = 1;\n  s->time_divisor = 1.0;\n  for (i = 0; i < numberof (t); i++)\n    {\n      for (;;)\n\t{\n\t  s->src_num = 0;\n\t  s->dst_num = 0;\n\n\t  t[i] = (*fun) (s);\n\n\t  if (speed_option_verbose >= 3)\n\t    gmp_printf(\"size=%ld reps=%u r=%Md attempt=%d  %.9f\\n\",\n\t\t       (long) s->size, s->reps, s->r, i, t[i]);\n\n\t  if (t[i] == 0.0)\n\t    {\n\t      zeros++;\n\t      if (zeros > max_zeros)\n\t\t{\n\t\t  fprintf (stderr, \"Fatal error: too many (%d) failed measurements (0.0)\\n\", zeros);\n\t\t  abort ();\n\t\t}\n\t     if (s->reps < 10000)\n\t       s->reps *= 2;\n\n\t      continue;\n\t    }\n\n\t  if (t[i] == -1.0)\n\t    return -1.0;\n\n\t  if (t[i] >= speed_unittime * speed_precision)\n\t    break;\n\n\t  /* go to a value of reps to make t[i] >= precision */\n\t  reps_d = ceil (1.1 * s->reps\n\t\t\t * speed_unittime * speed_precision\n\t\t\t / MAX (t[i], speed_unittime));\n\t  if (reps_d > 2e9 || reps_d < 1.0)\n\t    {\n\t      fprintf (stderr, \"Fatal error: new reps bad: %.2f\\n\", reps_d);\n\t      fprintf (stderr, \"  (old reps %u, unittime %.4g, precision %d, t[i] %.4g)\\n\",\n\t\t       s->reps, speed_unittime, speed_precision, t[i]);\n\t      abort ();\n\t    }\n\t  s->reps = (unsigned) reps_d;\n\t}\n      t[i] /= s->reps;\n      t_unsorted[i] = t[i];\n\n      if (speed_precision == 0)\n\treturn t[i];\n\n      /* require 3 values within TOLERANCE when >= 2 secs, 4 when below */\n      if (t[0] >= 2.0)\n\te = 3;\n      else\n\te = 4;\n\n      /* Look for e many t[]'s within TOLERANCE of each other to consider a\n\t valid measurement.  Return smallest among them.  */\n      if (i >= e)\n\t{\n\t  qsort (t, i+1, sizeof(t[0]), (qsort_function_t) double_cmp_ptr);\n\t  for (j = e-1; j < i; j++)\n\t    if (t[j] <= t[j-e+1] * TOLERANCE)\n\t      return t[j-e+1] / s->time_divisor;\n\t}\n    }\n\n  fprintf (stderr, \"speed_measure() could not get %d results within %.1f%%\\n\",\n\t   e, (TOLERANCE-1.0)*100.0);\n  fprintf (stderr, \"    unsorted         sorted\\n\");\n  fprintf (stderr, \"  %.12f    %.12f    is about 0.5%%\\n\",\n\t   t_unsorted[0]*(TOLERANCE-1.0), t[0]*(TOLERANCE-1.0));\n  for (i = 0; i < numberof (t); i++)\n    fprintf (stderr, \"  %.09f       %.09f\\n\", t_unsorted[i], t[i]);\n\n  return -1.0;\n}",
      "lines": 102,
      "depth": 16,
      "decorators": [
        "double"
      ]
    },
    "mpn_cache_fill": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nmpn_cache_fill (mp_srcptr ptr, mp_size_t size)\n{\n  mp_limb_t  sum = 0;\n  mp_size_t  i;\n\n  for (i = 0; i < size; i++)\n    sum += ptr[i];\n\n  mpn_cache_fill_dummy(sum);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpn_cache_fill_write": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "void\nmpn_cache_fill_write (mp_ptr ptr, mp_size_t size)\n{\n  mpn_cache_fill (ptr, size);\n\n#if 0\n  mpn_random (ptr, size);\n#endif\n\n#if 0\n  mp_size_t  i;\n\n  for (i = 0; i < size; i++)\n    ptr[i] = i;\n#endif\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "speed_operand_src": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "void\nspeed_operand_src (struct speed_params *s, mp_ptr ptr, mp_size_t size)\n{\n  if (s->src_num >= numberof (s->src))\n    {\n      fprintf (stderr, \"speed_operand_src: no room left in s->src[]\\n\");\n      abort ();\n    }\n  s->src[s->src_num].ptr = ptr;\n  s->src[s->src_num].size = size;\n  s->src_num++;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "speed_operand_dst": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "void\nspeed_operand_dst (struct speed_params *s, mp_ptr ptr, mp_size_t size)\n{\n  if (s->dst_num >= numberof (s->dst))\n    {\n      fprintf (stderr, \"speed_operand_dst: no room left in s->dst[]\\n\");\n      abort ();\n    }\n  s->dst[s->dst_num].ptr = ptr;\n  s->dst[s->dst_num].size = size;\n  s->dst_num++;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "speed_cache_fill": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "void\nspeed_cache_fill (struct speed_params *s)\n{\n  static struct speed_params  prev;\n  int  i;\n\n  /* FIXME: need a better way to get the format string for a pointer */\n\n  if (speed_option_addrs)\n    {\n      int  different;\n\n      different = (s->dst_num != prev.dst_num || s->src_num != prev.src_num);\n      for (i = 0; i < s->dst_num; i++)\n\tdifferent |= (s->dst[i].ptr != prev.dst[i].ptr);\n      for (i = 0; i < s->src_num; i++)\n\tdifferent |= (s->src[i].ptr != prev.src[i].ptr);\n\n      if (different)\n\t{\n\t  if (s->dst_num != 0)\n\t    {\n\t      printf (\"dst\");\n\t      for (i = 0; i < s->dst_num; i++)\n\t\tprintf (\" %08lX\", (unsigned long) s->dst[i].ptr);\n\t      printf (\" \");\n\t    }\n\n\t  if (s->src_num != 0)\n\t    {\n\t      printf (\"src\");\n\t      for (i = 0; i < s->src_num; i++)\n\t\tprintf (\" %08lX\", (unsigned long) s->src[i].ptr);\n\t      printf (\" \");\n\t    }\n\t  printf (\"  (cf sp approx %08lX)\\n\", (unsigned long) &different);\n\n\t}\n\n      memcpy (&prev, s, sizeof(prev));\n    }\n\n  switch (s->cache) {\n  case 0:\n    for (i = 0; i < s->dst_num; i++)\n      mpn_cache_fill_write (s->dst[i].ptr, s->dst[i].size);\n    for (i = 0; i < s->src_num; i++)\n      mpn_cache_fill (s->src[i].ptr, s->src[i].size);\n    break;\n  case 1:\n    pentium_wbinvd();\n    break;\n  }\n}",
      "lines": 54,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "speed_option_set": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "void\nspeed_option_set (const char *s)\n{\n  int  n;\n\n  if (strcmp (s, \"addrs\") == 0)\n    {\n      speed_option_addrs = 1;\n    }\n  else if (strcmp (s, \"verbose\") == 0)\n    {\n      speed_option_verbose++;\n    }\n  else if (sscanf (s, \"verbose=%d\", &n) == 1)\n    {\n      speed_option_verbose = n;\n    }\n  else if (strcmp (s, \"cycles-broken\") == 0)\n    {\n      speed_option_cycles_broken = 1;\n    }\n  else\n    {\n      printf (\"Unrecognised -o option: %s\\n\", s);\n      exit (1);\n    }\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "speed_MPN_COPY": {
      "start_point": [
        436,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "double\nspeed_MPN_COPY (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (MPN_COPY);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_MPN_COPY_INCR": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "double\nspeed_MPN_COPY_INCR (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (MPN_COPY_INCR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_MPN_COPY_DECR": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "double\nspeed_MPN_COPY_DECR (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (MPN_COPY_DECR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_copyi": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        456,
        1
      ],
      "content": "double\nspeed_mpn_copyi (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (mpn_copyi);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_copyd": {
      "start_point": [
        459,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "double\nspeed_mpn_copyd (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (mpn_copyd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_memcpy": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "double\nspeed_memcpy (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY_BYTES (memcpy);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_com": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        474,
        1
      ],
      "content": "double\nspeed_mpn_com (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (mpn_com);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_neg": {
      "start_point": [
        475,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "double\nspeed_mpn_neg (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (mpn_neg);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sec_tabselect": {
      "start_point": [
        480,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "double\nspeed_mpn_sec_tabselect (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TABSELECT (mpn_sec_tabselect);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addmul_1": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "double\nspeed_mpn_addmul_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1 (mpn_addmul_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_submul_1": {
      "start_point": [
        492,
        0
      ],
      "end_point": [
        496,
        1
      ],
      "content": "double\nspeed_mpn_submul_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1 (mpn_submul_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addmul_2": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "double\nspeed_mpn_addmul_2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_2 (mpn_addmul_2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addmul_3": {
      "start_point": [
        506,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "double\nspeed_mpn_addmul_3 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_3 (mpn_addmul_3);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addmul_4": {
      "start_point": [
        513,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "double\nspeed_mpn_addmul_4 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_4 (mpn_addmul_4);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addmul_5": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "double\nspeed_mpn_addmul_5 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_5 (mpn_addmul_5);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addmul_6": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        531,
        1
      ],
      "content": "double\nspeed_mpn_addmul_6 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_6 (mpn_addmul_6);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addmul_7": {
      "start_point": [
        534,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "double\nspeed_mpn_addmul_7 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_7 (mpn_addmul_7);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addmul_8": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "double\nspeed_mpn_addmul_8 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_8 (mpn_addmul_8);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_1": {
      "start_point": [
        548,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "double\nspeed_mpn_mul_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1 (mpn_mul_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_1_inplace": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        557,
        1
      ],
      "content": "double\nspeed_mpn_mul_1_inplace (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1_INPLACE (mpn_mul_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_2": {
      "start_point": [
        560,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "double\nspeed_mpn_mul_2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_2 (mpn_mul_2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_3": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "double\nspeed_mpn_mul_3 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_3 (mpn_mul_3);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_4": {
      "start_point": [
        574,
        0
      ],
      "end_point": [
        578,
        1
      ],
      "content": "double\nspeed_mpn_mul_4 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_4 (mpn_mul_4);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_5": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "double\nspeed_mpn_mul_5 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_5 (mpn_mul_5);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_6": {
      "start_point": [
        588,
        0
      ],
      "end_point": [
        592,
        1
      ],
      "content": "double\nspeed_mpn_mul_6 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_6 (mpn_mul_6);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_lshift": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        600,
        1
      ],
      "content": "double\nspeed_mpn_lshift (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1 (mpn_lshift);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_lshiftc": {
      "start_point": [
        601,
        0
      ],
      "end_point": [
        605,
        1
      ],
      "content": "double\nspeed_mpn_lshiftc (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1 (mpn_lshiftc);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_rshift": {
      "start_point": [
        606,
        0
      ],
      "end_point": [
        610,
        1
      ],
      "content": "double\nspeed_mpn_rshift (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1 (mpn_rshift);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_1": {
      "start_point": [
        616,
        0
      ],
      "end_point": [
        620,
        1
      ],
      "content": "double\nspeed_mpn_divrem_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_1 (mpn_divrem_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_1f": {
      "start_point": [
        621,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "double\nspeed_mpn_divrem_1f (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_1F (mpn_divrem_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_1c": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "double\nspeed_mpn_divrem_1c (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_1C (mpn_divrem_1c);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_1cf": {
      "start_point": [
        632,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "double\nspeed_mpn_divrem_1cf (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_1CF (mpn_divrem_1c);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_1_div": {
      "start_point": [
        639,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "double\nspeed_mpn_divrem_1_div (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_1 (mpn_divrem_1_div);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_1f_div": {
      "start_point": [
        644,
        0
      ],
      "end_point": [
        648,
        1
      ],
      "content": "double\nspeed_mpn_divrem_1f_div (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_1F (mpn_divrem_1_div);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_1_inv": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        653,
        1
      ],
      "content": "double\nspeed_mpn_divrem_1_inv (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_1 (mpn_divrem_1_inv);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_1f_inv": {
      "start_point": [
        654,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "double\nspeed_mpn_divrem_1f_inv (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_1F (mpn_divrem_1_inv);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mod_1_div": {
      "start_point": [
        659,
        0
      ],
      "end_point": [
        663,
        1
      ],
      "content": "double\nspeed_mpn_mod_1_div (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_1 (mpn_mod_1_div);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mod_1_inv": {
      "start_point": [
        664,
        0
      ],
      "end_point": [
        668,
        1
      ],
      "content": "double\nspeed_mpn_mod_1_inv (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_1 (mpn_mod_1_inv);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_preinv_divrem_1": {
      "start_point": [
        670,
        0
      ],
      "end_point": [
        674,
        1
      ],
      "content": "double\nspeed_mpn_preinv_divrem_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PREINV_DIVREM_1 (mpn_preinv_divrem_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_preinv_divrem_1f": {
      "start_point": [
        675,
        0
      ],
      "end_point": [
        679,
        1
      ],
      "content": "double\nspeed_mpn_preinv_divrem_1f (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PREINV_DIVREM_1F (mpn_preinv_divrem_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mod_34lsub1": {
      "start_point": [
        682,
        0
      ],
      "end_point": [
        686,
        1
      ],
      "content": "double\nspeed_mpn_mod_34lsub1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_34LSUB1 (mpn_mod_34lsub1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_2": {
      "start_point": [
        689,
        0
      ],
      "end_point": [
        693,
        1
      ],
      "content": "double\nspeed_mpn_divrem_2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_2 (mpn_divrem_2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_2_div": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        698,
        1
      ],
      "content": "double\nspeed_mpn_divrem_2_div (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_2 (mpn_divrem_2_div);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_2_inv": {
      "start_point": [
        699,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "double\nspeed_mpn_divrem_2_inv (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_2 (mpn_divrem_2_inv);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_div_qr_1n_pi1": {
      "start_point": [
        705,
        0
      ],
      "end_point": [
        709,
        1
      ],
      "content": "double\nspeed_mpn_div_qr_1n_pi1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIV_QR_1N_PI1 (mpn_div_qr_1n_pi1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_div_qr_1n_pi1_1": {
      "start_point": [
        710,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "double\nspeed_mpn_div_qr_1n_pi1_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIV_QR_1N_PI1 (mpn_div_qr_1n_pi1_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_div_qr_1n_pi1_2": {
      "start_point": [
        715,
        0
      ],
      "end_point": [
        719,
        1
      ],
      "content": "double\nspeed_mpn_div_qr_1n_pi1_2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIV_QR_1N_PI1 (mpn_div_qr_1n_pi1_2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_div_qr_1": {
      "start_point": [
        721,
        0
      ],
      "end_point": [
        725,
        1
      ],
      "content": "double\nspeed_mpn_div_qr_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIV_QR_1 (mpn_div_qr_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_div_qr_2n": {
      "start_point": [
        727,
        0
      ],
      "end_point": [
        731,
        1
      ],
      "content": "double\nspeed_mpn_div_qr_2n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIV_QR_2 (mpn_div_qr_2, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_div_qr_2u": {
      "start_point": [
        732,
        0
      ],
      "end_point": [
        736,
        1
      ],
      "content": "double\nspeed_mpn_div_qr_2u (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIV_QR_2 (mpn_div_qr_2, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mod_1": {
      "start_point": [
        738,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "double\nspeed_mpn_mod_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_1 (mpn_mod_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mod_1c": {
      "start_point": [
        744,
        0
      ],
      "end_point": [
        748,
        1
      ],
      "content": "double\nspeed_mpn_mod_1c (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_1C (mpn_mod_1c);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_preinv_mod_1": {
      "start_point": [
        750,
        0
      ],
      "end_point": [
        754,
        1
      ],
      "content": "double\nspeed_mpn_preinv_mod_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PREINV_MOD_1 (mpn_preinv_mod_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mod_1_1": {
      "start_point": [
        755,
        0
      ],
      "end_point": [
        759,
        1
      ],
      "content": "double\nspeed_mpn_mod_1_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_1_1 (mpn_mod_1_1p,mpn_mod_1_1p_cps);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mod_1_1_1": {
      "start_point": [
        760,
        0
      ],
      "end_point": [
        764,
        1
      ],
      "content": "double\nspeed_mpn_mod_1_1_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_1_1 (mpn_mod_1_1p_1,mpn_mod_1_1p_cps_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mod_1_1_2": {
      "start_point": [
        765,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "double\nspeed_mpn_mod_1_1_2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_1_1 (mpn_mod_1_1p_2,mpn_mod_1_1p_cps_2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mod_1_2": {
      "start_point": [
        770,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "double\nspeed_mpn_mod_1_2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_1_N (mpn_mod_1s_2p,mpn_mod_1s_2p_cps,2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mod_1_3": {
      "start_point": [
        775,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "double\nspeed_mpn_mod_1_3 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_1_N (mpn_mod_1s_3p,mpn_mod_1s_3p_cps,3);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mod_1_4": {
      "start_point": [
        780,
        0
      ],
      "end_point": [
        784,
        1
      ],
      "content": "double\nspeed_mpn_mod_1_4 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_1_N (mpn_mod_1s_4p,mpn_mod_1s_4p_cps,4);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divexact_1": {
      "start_point": [
        786,
        0
      ],
      "end_point": [
        790,
        1
      ],
      "content": "double\nspeed_mpn_divexact_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVEXACT_1 (mpn_divexact_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divexact_by3": {
      "start_point": [
        792,
        0
      ],
      "end_point": [
        796,
        1
      ],
      "content": "double\nspeed_mpn_divexact_by3 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (mpn_divexact_by3);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_bdiv_dbm1c": {
      "start_point": [
        798,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "double\nspeed_mpn_bdiv_dbm1c (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BDIV_DBM1C (mpn_bdiv_dbm1c);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_bdiv_q_1": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "double\nspeed_mpn_bdiv_q_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BDIV_Q_1 (mpn_bdiv_q_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_pi1_bdiv_q_1": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        814,
        1
      ],
      "content": "double\nspeed_mpn_pi1_bdiv_q_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PI1_BDIV_Q_1 (mpn_pi1_bdiv_q_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_modexact_1_odd": {
      "start_point": [
        817,
        0
      ],
      "end_point": [
        821,
        1
      ],
      "content": "double\nspeed_mpn_modexact_1_odd (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MODEXACT_1_ODD (mpn_modexact_1_odd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_modexact_1c_odd": {
      "start_point": [
        824,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "double\nspeed_mpn_modexact_1c_odd (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MODEXACT_1C_ODD (mpn_modexact_1c_odd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_mod": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "double\nspeed_mpz_mod (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_MOD (mpz_mod);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sbpi1_div_qr": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "double\nspeed_mpn_sbpi1_div_qr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PI1_DIV (mpn_sbpi1_div_qr, inv.inv32, 2,0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_dcpi1_div_qr": {
      "start_point": [
        841,
        0
      ],
      "end_point": [
        845,
        1
      ],
      "content": "double\nspeed_mpn_dcpi1_div_qr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PI1_DIV (mpn_dcpi1_div_qr, &inv, 6,3);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sbpi1_divappr_q": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "double\nspeed_mpn_sbpi1_divappr_q (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PI1_DIV (mpn_sbpi1_divappr_q, inv.inv32, 2,0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_dcpi1_divappr_q": {
      "start_point": [
        851,
        0
      ],
      "end_point": [
        855,
        1
      ],
      "content": "double\nspeed_mpn_dcpi1_divappr_q (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PI1_DIV (mpn_dcpi1_divappr_q, &inv, 6,3);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mu_div_qr": {
      "start_point": [
        856,
        0
      ],
      "end_point": [
        860,
        1
      ],
      "content": "double\nspeed_mpn_mu_div_qr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MU_DIV_QR (mpn_mu_div_qr, mpn_mu_div_qr_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mu_divappr_q": {
      "start_point": [
        861,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "double\nspeed_mpn_mu_divappr_q (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MU_DIV_Q (mpn_mu_divappr_q, mpn_mu_divappr_q_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mu_div_q": {
      "start_point": [
        866,
        0
      ],
      "end_point": [
        870,
        1
      ],
      "content": "double\nspeed_mpn_mu_div_q (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MU_DIV_Q (mpn_mu_div_q, mpn_mu_div_q_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mupi_div_qr": {
      "start_point": [
        871,
        0
      ],
      "end_point": [
        875,
        1
      ],
      "content": "double\nspeed_mpn_mupi_div_qr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MUPI_DIV_QR (mpn_preinv_mu_div_qr, mpn_preinv_mu_div_qr_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sbpi1_bdiv_qr": {
      "start_point": [
        877,
        0
      ],
      "end_point": [
        881,
        1
      ],
      "content": "double\nspeed_mpn_sbpi1_bdiv_qr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PI1_BDIV_QR (mpn_sbpi1_bdiv_qr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_dcpi1_bdiv_qr": {
      "start_point": [
        882,
        0
      ],
      "end_point": [
        886,
        1
      ],
      "content": "double\nspeed_mpn_dcpi1_bdiv_qr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PI1_BDIV_QR (mpn_dcpi1_bdiv_qr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sbpi1_bdiv_q": {
      "start_point": [
        887,
        0
      ],
      "end_point": [
        891,
        1
      ],
      "content": "double\nspeed_mpn_sbpi1_bdiv_q (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PI1_BDIV_Q (mpn_sbpi1_bdiv_q);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_dcpi1_bdiv_q": {
      "start_point": [
        892,
        0
      ],
      "end_point": [
        896,
        1
      ],
      "content": "double\nspeed_mpn_dcpi1_bdiv_q (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_PI1_BDIV_Q (mpn_dcpi1_bdiv_q);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mu_bdiv_q": {
      "start_point": [
        897,
        0
      ],
      "end_point": [
        901,
        1
      ],
      "content": "double\nspeed_mpn_mu_bdiv_q (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MU_BDIV_Q (mpn_mu_bdiv_q, mpn_mu_bdiv_q_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mu_bdiv_qr": {
      "start_point": [
        902,
        0
      ],
      "end_point": [
        906,
        1
      ],
      "content": "double\nspeed_mpn_mu_bdiv_qr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MU_BDIV_QR (mpn_mu_bdiv_qr, mpn_mu_bdiv_qr_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_broot": {
      "start_point": [
        908,
        0
      ],
      "end_point": [
        912,
        1
      ],
      "content": "double\nspeed_mpn_broot (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BROOT (mpn_broot);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_broot_invm1": {
      "start_point": [
        913,
        0
      ],
      "end_point": [
        917,
        1
      ],
      "content": "double\nspeed_mpn_broot_invm1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BROOT (mpn_broot_invm1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_brootinv": {
      "start_point": [
        918,
        0
      ],
      "end_point": [
        922,
        1
      ],
      "content": "double\nspeed_mpn_brootinv (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BROOTINV (mpn_brootinv, 5*s->size);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_binvert": {
      "start_point": [
        924,
        0
      ],
      "end_point": [
        928,
        1
      ],
      "content": "double\nspeed_mpn_binvert (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINVERT (mpn_binvert, mpn_binvert_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_invert": {
      "start_point": [
        930,
        0
      ],
      "end_point": [
        934,
        1
      ],
      "content": "double\nspeed_mpn_invert (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_INVERT (mpn_invert, mpn_invert_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_invertappr": {
      "start_point": [
        936,
        0
      ],
      "end_point": [
        940,
        1
      ],
      "content": "double\nspeed_mpn_invertappr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_INVERTAPPR (mpn_invertappr, mpn_invertappr_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_ni_invertappr": {
      "start_point": [
        942,
        0
      ],
      "end_point": [
        946,
        1
      ],
      "content": "double\nspeed_mpn_ni_invertappr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_INVERTAPPR (mpn_ni_invertappr, mpn_invertappr_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sec_invert": {
      "start_point": [
        948,
        0
      ],
      "end_point": [
        952,
        1
      ],
      "content": "double\nspeed_mpn_sec_invert (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SEC_INVERT (mpn_sec_invert, mpn_sec_invert_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_redc_1": {
      "start_point": [
        954,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "double\nspeed_mpn_redc_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_REDC_1 (mpn_redc_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_redc_2": {
      "start_point": [
        959,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "double\nspeed_mpn_redc_2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_REDC_2 (mpn_redc_2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_redc_n": {
      "start_point": [
        964,
        0
      ],
      "end_point": [
        968,
        1
      ],
      "content": "double\nspeed_mpn_redc_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_REDC_N (mpn_redc_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_popcount": {
      "start_point": [
        971,
        0
      ],
      "end_point": [
        975,
        1
      ],
      "content": "double\nspeed_mpn_popcount (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_POPCOUNT (mpn_popcount);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_hamdist": {
      "start_point": [
        976,
        0
      ],
      "end_point": [
        980,
        1
      ],
      "content": "double\nspeed_mpn_hamdist (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_HAMDIST (mpn_hamdist);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_add_n": {
      "start_point": [
        983,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "double\nspeed_mpn_add_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N (mpn_add_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sub_n": {
      "start_point": [
        988,
        0
      ],
      "end_point": [
        992,
        1
      ],
      "content": "double\nspeed_mpn_sub_n (struct speed_params *s)\n{\nSPEED_ROUTINE_MPN_BINARY_N (mpn_sub_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_add_1": {
      "start_point": [
        993,
        0
      ],
      "end_point": [
        997,
        1
      ],
      "content": "double\nspeed_mpn_add_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1 (mpn_add_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_add_1_inplace": {
      "start_point": [
        998,
        0
      ],
      "end_point": [
        1002,
        1
      ],
      "content": "double\nspeed_mpn_add_1_inplace (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1_INPLACE (mpn_add_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sub_1": {
      "start_point": [
        1003,
        0
      ],
      "end_point": [
        1007,
        1
      ],
      "content": "double\nspeed_mpn_sub_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1 (mpn_sub_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sub_1_inplace": {
      "start_point": [
        1008,
        0
      ],
      "end_point": [
        1012,
        1
      ],
      "content": "double\nspeed_mpn_sub_1_inplace (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1_INPLACE (mpn_sub_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_add_err1_n": {
      "start_point": [
        1014,
        0
      ],
      "end_point": [
        1018,
        1
      ],
      "content": "double\nspeed_mpn_add_err1_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_ERR1_N (mpn_add_err1_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sub_err1_n": {
      "start_point": [
        1019,
        0
      ],
      "end_point": [
        1023,
        1
      ],
      "content": "double\nspeed_mpn_sub_err1_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_ERR1_N (mpn_sub_err1_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_add_err2_n": {
      "start_point": [
        1024,
        0
      ],
      "end_point": [
        1028,
        1
      ],
      "content": "double\nspeed_mpn_add_err2_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_ERR2_N (mpn_add_err2_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sub_err2_n": {
      "start_point": [
        1029,
        0
      ],
      "end_point": [
        1033,
        1
      ],
      "content": "double\nspeed_mpn_sub_err2_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_ERR2_N (mpn_sub_err2_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_add_err3_n": {
      "start_point": [
        1034,
        0
      ],
      "end_point": [
        1038,
        1
      ],
      "content": "double\nspeed_mpn_add_err3_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_ERR3_N (mpn_add_err3_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sub_err3_n": {
      "start_point": [
        1039,
        0
      ],
      "end_point": [
        1043,
        1
      ],
      "content": "double\nspeed_mpn_sub_err3_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_ERR3_N (mpn_sub_err3_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_add_n_sub_n": {
      "start_point": [
        1047,
        0
      ],
      "end_point": [
        1051,
        1
      ],
      "content": "double\nspeed_mpn_add_n_sub_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_ADDSUB_N_CALL (mpn_add_n_sub_n (ap, sp, s->xp, s->yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addlsh1_n": {
      "start_point": [
        1055,
        0
      ],
      "end_point": [
        1059,
        1
      ],
      "content": "double\nspeed_mpn_addlsh1_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N (mpn_addlsh1_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sublsh1_n": {
      "start_point": [
        1062,
        0
      ],
      "end_point": [
        1066,
        1
      ],
      "content": "double\nspeed_mpn_sublsh1_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N (mpn_sublsh1_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addlsh1_n_ip1": {
      "start_point": [
        1069,
        0
      ],
      "end_point": [
        1073,
        1
      ],
      "content": "double\nspeed_mpn_addlsh1_n_ip1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (mpn_addlsh1_n_ip1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addlsh1_n_ip2": {
      "start_point": [
        1076,
        0
      ],
      "end_point": [
        1080,
        1
      ],
      "content": "double\nspeed_mpn_addlsh1_n_ip2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (mpn_addlsh1_n_ip2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sublsh1_n_ip1": {
      "start_point": [
        1083,
        0
      ],
      "end_point": [
        1087,
        1
      ],
      "content": "double\nspeed_mpn_sublsh1_n_ip1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (mpn_sublsh1_n_ip1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_rsblsh1_n": {
      "start_point": [
        1090,
        0
      ],
      "end_point": [
        1094,
        1
      ],
      "content": "double\nspeed_mpn_rsblsh1_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N (mpn_rsblsh1_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addlsh2_n": {
      "start_point": [
        1097,
        0
      ],
      "end_point": [
        1101,
        1
      ],
      "content": "double\nspeed_mpn_addlsh2_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N (mpn_addlsh2_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sublsh2_n": {
      "start_point": [
        1104,
        0
      ],
      "end_point": [
        1108,
        1
      ],
      "content": "double\nspeed_mpn_sublsh2_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N (mpn_sublsh2_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addlsh2_n_ip1": {
      "start_point": [
        1111,
        0
      ],
      "end_point": [
        1115,
        1
      ],
      "content": "double\nspeed_mpn_addlsh2_n_ip1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (mpn_addlsh2_n_ip1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addlsh2_n_ip2": {
      "start_point": [
        1118,
        0
      ],
      "end_point": [
        1122,
        1
      ],
      "content": "double\nspeed_mpn_addlsh2_n_ip2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (mpn_addlsh2_n_ip2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sublsh2_n_ip1": {
      "start_point": [
        1125,
        0
      ],
      "end_point": [
        1129,
        1
      ],
      "content": "double\nspeed_mpn_sublsh2_n_ip1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_COPY (mpn_sublsh2_n_ip1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_rsblsh2_n": {
      "start_point": [
        1132,
        0
      ],
      "end_point": [
        1136,
        1
      ],
      "content": "double\nspeed_mpn_rsblsh2_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N (mpn_rsblsh2_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addlsh_n": {
      "start_point": [
        1139,
        0
      ],
      "end_point": [
        1143,
        1
      ],
      "content": "double\nspeed_mpn_addlsh_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_addlsh_n (wp, xp, yp, s->size, 7));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sublsh_n": {
      "start_point": [
        1146,
        0
      ],
      "end_point": [
        1150,
        1
      ],
      "content": "double\nspeed_mpn_sublsh_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_sublsh_n (wp, xp, yp, s->size, 7));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addlsh_n_ip1": {
      "start_point": [
        1153,
        0
      ],
      "end_point": [
        1157,
        1
      ],
      "content": "double\nspeed_mpn_addlsh_n_ip1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1_CALL (mpn_addlsh_n_ip1 (wp, s->xp, s->size, 7));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_addlsh_n_ip2": {
      "start_point": [
        1160,
        0
      ],
      "end_point": [
        1164,
        1
      ],
      "content": "double\nspeed_mpn_addlsh_n_ip2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1_CALL (mpn_addlsh_n_ip2 (wp, s->xp, s->size, 7));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sublsh_n_ip1": {
      "start_point": [
        1167,
        0
      ],
      "end_point": [
        1171,
        1
      ],
      "content": "double\nspeed_mpn_sublsh_n_ip1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_UNARY_1_CALL (mpn_sublsh_n_ip1 (wp, s->xp, s->size, 7));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_rsblsh_n": {
      "start_point": [
        1174,
        0
      ],
      "end_point": [
        1178,
        1
      ],
      "content": "double\nspeed_mpn_rsblsh_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_rsblsh_n (wp, xp, yp, s->size, 7));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_rsh1add_n": {
      "start_point": [
        1181,
        0
      ],
      "end_point": [
        1185,
        1
      ],
      "content": "double\nspeed_mpn_rsh1add_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N (mpn_rsh1add_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_rsh1sub_n": {
      "start_point": [
        1188,
        0
      ],
      "end_point": [
        1192,
        1
      ],
      "content": "double\nspeed_mpn_rsh1sub_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N (mpn_rsh1sub_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_cnd_add_n": {
      "start_point": [
        1195,
        0
      ],
      "end_point": [
        1199,
        1
      ],
      "content": "double\nspeed_mpn_cnd_add_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_cnd_add_n (1, wp, xp, yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_cnd_sub_n": {
      "start_point": [
        1200,
        0
      ],
      "end_point": [
        1204,
        1
      ],
      "content": "double\nspeed_mpn_cnd_sub_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_cnd_sub_n (1, wp, xp, yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_and_n": {
      "start_point": [
        1208,
        0
      ],
      "end_point": [
        1212,
        1
      ],
      "content": "double\nspeed_mpn_and_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_and_n (wp, xp, yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_andn_n": {
      "start_point": [
        1213,
        0
      ],
      "end_point": [
        1217,
        1
      ],
      "content": "double\nspeed_mpn_andn_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_andn_n (wp, xp, yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_nand_n": {
      "start_point": [
        1218,
        0
      ],
      "end_point": [
        1222,
        1
      ],
      "content": "double\nspeed_mpn_nand_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_nand_n (wp, xp, yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_ior_n": {
      "start_point": [
        1223,
        0
      ],
      "end_point": [
        1227,
        1
      ],
      "content": "double\nspeed_mpn_ior_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_ior_n (wp, xp, yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_iorn_n": {
      "start_point": [
        1228,
        0
      ],
      "end_point": [
        1232,
        1
      ],
      "content": "double\nspeed_mpn_iorn_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_iorn_n (wp, xp, yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_nior_n": {
      "start_point": [
        1233,
        0
      ],
      "end_point": [
        1237,
        1
      ],
      "content": "double\nspeed_mpn_nior_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_nior_n (wp, xp, yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_xor_n": {
      "start_point": [
        1238,
        0
      ],
      "end_point": [
        1242,
        1
      ],
      "content": "double\nspeed_mpn_xor_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_xor_n (wp, xp, yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_xnor_n": {
      "start_point": [
        1243,
        0
      ],
      "end_point": [
        1247,
        1
      ],
      "content": "double\nspeed_mpn_xnor_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_BINARY_N_CALL (mpn_xnor_n (wp, xp, yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_n": {
      "start_point": [
        1250,
        0
      ],
      "end_point": [
        1254,
        1
      ],
      "content": "double\nspeed_mpn_mul_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MUL_N (mpn_mul_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sqr": {
      "start_point": [
        1255,
        0
      ],
      "end_point": [
        1259,
        1
      ],
      "content": "double\nspeed_mpn_sqr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQR (mpn_sqr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_n_sqr": {
      "start_point": [
        1260,
        0
      ],
      "end_point": [
        1264,
        1
      ],
      "content": "double\nspeed_mpn_mul_n_sqr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQR_CALL (mpn_mul_n (wp, s->xp, s->xp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_basecase": {
      "start_point": [
        1266,
        0
      ],
      "end_point": [
        1270,
        1
      ],
      "content": "double\nspeed_mpn_mul_basecase (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MUL(mpn_mul_basecase);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul": {
      "start_point": [
        1271,
        0
      ],
      "end_point": [
        1275,
        1
      ],
      "content": "double\nspeed_mpn_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MUL(mpn_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sqr_basecase": {
      "start_point": [
        1276,
        0
      ],
      "end_point": [
        1281,
        1
      ],
      "content": "double\nspeed_mpn_sqr_basecase (struct speed_params *s)\n{\n  /* FIXME: size restrictions on some versions of sqr_basecase */\n  SPEED_ROUTINE_MPN_SQR (mpn_sqr_basecase);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sqr_diagonal": {
      "start_point": [
        1284,
        0
      ],
      "end_point": [
        1288,
        1
      ],
      "content": "double\nspeed_mpn_sqr_diagonal (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQR (mpn_sqr_diagonal);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sqr_diag_addlsh1": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1296,
        1
      ],
      "content": "double\nspeed_mpn_sqr_diag_addlsh1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQR_DIAG_ADDLSH1_CALL (mpn_sqr_diag_addlsh1 (wp, tp, s->xp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom2_sqr": {
      "start_point": [
        1299,
        0
      ],
      "end_point": [
        1303,
        1
      ],
      "content": "double\nspeed_mpn_toom2_sqr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM2_SQR (mpn_toom2_sqr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom3_sqr": {
      "start_point": [
        1304,
        0
      ],
      "end_point": [
        1308,
        1
      ],
      "content": "double\nspeed_mpn_toom3_sqr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM3_SQR (mpn_toom3_sqr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom4_sqr": {
      "start_point": [
        1309,
        0
      ],
      "end_point": [
        1313,
        1
      ],
      "content": "double\nspeed_mpn_toom4_sqr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM4_SQR (mpn_toom4_sqr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom6_sqr": {
      "start_point": [
        1314,
        0
      ],
      "end_point": [
        1318,
        1
      ],
      "content": "double\nspeed_mpn_toom6_sqr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM6_SQR (mpn_toom6_sqr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom8_sqr": {
      "start_point": [
        1319,
        0
      ],
      "end_point": [
        1323,
        1
      ],
      "content": "double\nspeed_mpn_toom8_sqr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM8_SQR (mpn_toom8_sqr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom22_mul": {
      "start_point": [
        1324,
        0
      ],
      "end_point": [
        1328,
        1
      ],
      "content": "double\nspeed_mpn_toom22_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM22_MUL_N (mpn_toom22_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom33_mul": {
      "start_point": [
        1329,
        0
      ],
      "end_point": [
        1333,
        1
      ],
      "content": "double\nspeed_mpn_toom33_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM33_MUL_N (mpn_toom33_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom44_mul": {
      "start_point": [
        1334,
        0
      ],
      "end_point": [
        1338,
        1
      ],
      "content": "double\nspeed_mpn_toom44_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM44_MUL_N (mpn_toom44_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom6h_mul": {
      "start_point": [
        1339,
        0
      ],
      "end_point": [
        1343,
        1
      ],
      "content": "double\nspeed_mpn_toom6h_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM6H_MUL_N (mpn_toom6h_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom8h_mul": {
      "start_point": [
        1344,
        0
      ],
      "end_point": [
        1348,
        1
      ],
      "content": "double\nspeed_mpn_toom8h_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM8H_MUL_N (mpn_toom8h_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom32_mul": {
      "start_point": [
        1350,
        0
      ],
      "end_point": [
        1354,
        1
      ],
      "content": "double\nspeed_mpn_toom32_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM32_MUL (mpn_toom32_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom42_mul": {
      "start_point": [
        1355,
        0
      ],
      "end_point": [
        1359,
        1
      ],
      "content": "double\nspeed_mpn_toom42_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM42_MUL (mpn_toom42_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom43_mul": {
      "start_point": [
        1360,
        0
      ],
      "end_point": [
        1364,
        1
      ],
      "content": "double\nspeed_mpn_toom43_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM43_MUL (mpn_toom43_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom63_mul": {
      "start_point": [
        1365,
        0
      ],
      "end_point": [
        1369,
        1
      ],
      "content": "double\nspeed_mpn_toom63_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM63_MUL (mpn_toom63_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom32_for_toom43_mul": {
      "start_point": [
        1370,
        0
      ],
      "end_point": [
        1374,
        1
      ],
      "content": "double\nspeed_mpn_toom32_for_toom43_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM32_FOR_TOOM43_MUL (mpn_toom32_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom43_for_toom32_mul": {
      "start_point": [
        1375,
        0
      ],
      "end_point": [
        1379,
        1
      ],
      "content": "double\nspeed_mpn_toom43_for_toom32_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM43_FOR_TOOM32_MUL (mpn_toom43_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom32_for_toom53_mul": {
      "start_point": [
        1380,
        0
      ],
      "end_point": [
        1384,
        1
      ],
      "content": "double\nspeed_mpn_toom32_for_toom53_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM32_FOR_TOOM53_MUL (mpn_toom32_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom53_for_toom32_mul": {
      "start_point": [
        1385,
        0
      ],
      "end_point": [
        1389,
        1
      ],
      "content": "double\nspeed_mpn_toom53_for_toom32_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM53_FOR_TOOM32_MUL (mpn_toom53_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom42_for_toom53_mul": {
      "start_point": [
        1390,
        0
      ],
      "end_point": [
        1394,
        1
      ],
      "content": "double\nspeed_mpn_toom42_for_toom53_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM42_FOR_TOOM53_MUL (mpn_toom42_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom53_for_toom42_mul": {
      "start_point": [
        1395,
        0
      ],
      "end_point": [
        1399,
        1
      ],
      "content": "double\nspeed_mpn_toom53_for_toom42_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM53_FOR_TOOM42_MUL (mpn_toom53_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom43_for_toom54_mul": {
      "start_point": [
        1400,
        0
      ],
      "end_point": [
        1404,
        1
      ],
      "content": "double\nspeed_mpn_toom43_for_toom54_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM43_FOR_TOOM54_MUL (mpn_toom43_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom54_for_toom43_mul": {
      "start_point": [
        1405,
        0
      ],
      "end_point": [
        1409,
        1
      ],
      "content": "double\nspeed_mpn_toom54_for_toom43_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM54_FOR_TOOM43_MUL (mpn_toom54_mul);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_nussbaumer_mul": {
      "start_point": [
        1411,
        0
      ],
      "end_point": [
        1416,
        1
      ],
      "content": "double\nspeed_mpn_nussbaumer_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MUL_N_CALL\n    (mpn_nussbaumer_mul (wp, s->xp, s->size, s->yp, s->size));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_nussbaumer_mul_sqr": {
      "start_point": [
        1417,
        0
      ],
      "end_point": [
        1422,
        1
      ],
      "content": "double\nspeed_mpn_nussbaumer_mul_sqr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQR_CALL\n    (mpn_nussbaumer_mul (wp, s->xp, s->size, s->xp, s->size));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_fft_full": {
      "start_point": [
        1425,
        0
      ],
      "end_point": [
        1430,
        1
      ],
      "content": "double\nspeed_mpn_mul_fft_full (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MUL_N_CALL\n    (mpn_mul_fft_full (wp, s->xp, s->size, s->yp, s->size));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_fft_full_sqr": {
      "start_point": [
        1431,
        0
      ],
      "end_point": [
        1436,
        1
      ],
      "content": "double\nspeed_mpn_mul_fft_full_sqr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQR_CALL\n    (mpn_mul_fft_full (wp, s->xp, s->size, s->xp, s->size));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_fft": {
      "start_point": [
        1480,
        0
      ],
      "end_point": [
        1485,
        1
      ],
      "content": "double\nspeed_mpn_mul_fft (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MUL_FFT_CALL\n    (mpn_mul_fft (wp, pl, s->xp, s->size, s->yp, s->size, k), 0);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mul_fft_sqr": {
      "start_point": [
        1487,
        0
      ],
      "end_point": [
        1492,
        1
      ],
      "content": "double\nspeed_mpn_mul_fft_sqr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MUL_FFT_CALL\n    (mpn_mul_fft (wp, pl, s->xp, s->size, s->xp, s->size, k), 1);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_fft_mul": {
      "start_point": [
        1494,
        0
      ],
      "end_point": [
        1498,
        1
      ],
      "content": "double\nspeed_mpn_fft_mul (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MUL_N_CALL (mpn_fft_mul (wp, s->xp, s->size, s->yp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_fft_sqr": {
      "start_point": [
        1500,
        0
      ],
      "end_point": [
        1504,
        1
      ],
      "content": "double\nspeed_mpn_fft_sqr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQR_CALL (mpn_fft_mul (wp, s->xp, s->size, s->xp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sqrlo": {
      "start_point": [
        1506,
        0
      ],
      "end_point": [
        1510,
        1
      ],
      "content": "double\nspeed_mpn_sqrlo (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQRLO (mpn_sqrlo);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sqrlo_basecase": {
      "start_point": [
        1511,
        0
      ],
      "end_point": [
        1515,
        1
      ],
      "content": "double\nspeed_mpn_sqrlo_basecase (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQRLO (mpn_sqrlo_basecase);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mullo_n": {
      "start_point": [
        1516,
        0
      ],
      "end_point": [
        1520,
        1
      ],
      "content": "double\nspeed_mpn_mullo_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MULLO_N (mpn_mullo_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mullo_basecase": {
      "start_point": [
        1521,
        0
      ],
      "end_point": [
        1525,
        1
      ],
      "content": "double\nspeed_mpn_mullo_basecase (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MULLO_BASECASE (mpn_mullo_basecase);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mulmid_basecase": {
      "start_point": [
        1527,
        0
      ],
      "end_point": [
        1531,
        1
      ],
      "content": "double\nspeed_mpn_mulmid_basecase (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MULMID (mpn_mulmid_basecase);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mulmid": {
      "start_point": [
        1533,
        0
      ],
      "end_point": [
        1537,
        1
      ],
      "content": "double\nspeed_mpn_mulmid (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MULMID (mpn_mulmid);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mulmid_n": {
      "start_point": [
        1539,
        0
      ],
      "end_point": [
        1543,
        1
      ],
      "content": "double\nspeed_mpn_mulmid_n (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MULMID_N (mpn_mulmid_n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_toom42_mulmid": {
      "start_point": [
        1545,
        0
      ],
      "end_point": [
        1549,
        1
      ],
      "content": "double\nspeed_mpn_toom42_mulmid (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_TOOM42_MULMID (mpn_toom42_mulmid);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mulmod_bnm1": {
      "start_point": [
        1551,
        0
      ],
      "end_point": [
        1555,
        1
      ],
      "content": "double\nspeed_mpn_mulmod_bnm1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MULMOD_BNM1_CALL (mpn_mulmod_bnm1 (wp, s->size, s->xp, s->size, s->yp, s->size, tp));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_bc_mulmod_bnm1": {
      "start_point": [
        1557,
        0
      ],
      "end_point": [
        1561,
        1
      ],
      "content": "double\nspeed_mpn_bc_mulmod_bnm1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MULMOD_BNM1_CALL (mpn_bc_mulmod_bnm1 (wp, s->xp, s->yp, s->size, tp));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_mulmod_bnm1_rounded": {
      "start_point": [
        1563,
        0
      ],
      "end_point": [
        1567,
        1
      ],
      "content": "double\nspeed_mpn_mulmod_bnm1_rounded (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MULMOD_BNM1_ROUNDED (mpn_mulmod_bnm1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sqrmod_bnm1": {
      "start_point": [
        1569,
        0
      ],
      "end_point": [
        1573,
        1
      ],
      "content": "double\nspeed_mpn_sqrmod_bnm1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MULMOD_BNM1_CALL (mpn_sqrmod_bnm1 (wp, s->size, s->xp, s->size, tp));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_matrix22_mul": {
      "start_point": [
        1575,
        0
      ],
      "end_point": [
        1626,
        1
      ],
      "content": "double\nspeed_mpn_matrix22_mul (struct speed_params *s)\n{\n  /* Speed params only includes 2 inputs, so we have to invent the\n     other 6. */\n\n  mp_ptr a;\n  mp_ptr r;\n  mp_ptr b;\n  mp_ptr tp;\n  mp_size_t itch;\n  unsigned i;\n  double t;\n  TMP_DECL;\n\n  TMP_MARK;\n  SPEED_TMP_ALLOC_LIMBS (a, 4 * s->size, s->align_xp);\n  SPEED_TMP_ALLOC_LIMBS (b, 4 * s->size, s->align_yp);\n  SPEED_TMP_ALLOC_LIMBS (r, 8 * s->size + 4, s->align_wp);\n\n  MPN_COPY (a, s->xp, s->size);\n  mpn_random (a + s->size, 3 * s->size);\n  MPN_COPY (b, s->yp, s->size);\n  mpn_random (b + s->size, 3 * s->size);\n\n  itch = mpn_matrix22_mul_itch (s->size, s->size);\n  SPEED_TMP_ALLOC_LIMBS (tp, itch, s->align_wp2);\n\n  speed_operand_src (s, a, 4 * s->size);\n  speed_operand_src (s, b, 4 * s->size);\n  speed_operand_dst (s, r, 8 * s->size + 4);\n  speed_operand_dst (s, tp, itch);\n  speed_cache_fill (s);\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    {\n      mp_size_t sz = s->size;\n      MPN_COPY (r + 0 * sz + 0, a + 0 * sz, sz);\n      MPN_COPY (r + 2 * sz + 1, a + 1 * sz, sz);\n      MPN_COPY (r + 4 * sz + 2, a + 2 * sz, sz);\n      MPN_COPY (r + 6 * sz + 3, a + 3 * sz, sz);\n      mpn_matrix22_mul (r, r + 2 * sz + 1, r + 4 * sz + 2, r + 6 * sz + 3, sz,\n\t\t\tb, b + 1 * sz,     b + 2 * sz,     b + 3 * sz,     sz,\n\t\t\ttp);\n    }\n  while (--i != 0);\n  t = speed_endtime();\n  TMP_FREE;\n  return t;\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_hgcd": {
      "start_point": [
        1628,
        0
      ],
      "end_point": [
        1632,
        1
      ],
      "content": "double\nspeed_mpn_hgcd (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_HGCD_CALL (mpn_hgcd, mpn_hgcd_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_hgcd_lehmer": {
      "start_point": [
        1634,
        0
      ],
      "end_point": [
        1638,
        1
      ],
      "content": "double\nspeed_mpn_hgcd_lehmer (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_HGCD_CALL (mpn_hgcd_lehmer, mpn_hgcd_lehmer_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_hgcd_appr": {
      "start_point": [
        1640,
        0
      ],
      "end_point": [
        1644,
        1
      ],
      "content": "double\nspeed_mpn_hgcd_appr (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_HGCD_CALL (mpn_hgcd_appr, mpn_hgcd_appr_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_hgcd_appr_lehmer": {
      "start_point": [
        1646,
        0
      ],
      "end_point": [
        1650,
        1
      ],
      "content": "double\nspeed_mpn_hgcd_appr_lehmer (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_HGCD_CALL (mpn_hgcd_appr_lehmer, mpn_hgcd_appr_lehmer_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_hgcd_reduce": {
      "start_point": [
        1652,
        0
      ],
      "end_point": [
        1656,
        1
      ],
      "content": "double\nspeed_mpn_hgcd_reduce (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_HGCD_REDUCE_CALL (mpn_hgcd_reduce, mpn_hgcd_reduce_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_hgcd_reduce_1": {
      "start_point": [
        1657,
        0
      ],
      "end_point": [
        1661,
        1
      ],
      "content": "double\nspeed_mpn_hgcd_reduce_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_HGCD_REDUCE_CALL (mpn_hgcd_reduce_1, mpn_hgcd_reduce_1_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_hgcd_reduce_2": {
      "start_point": [
        1662,
        0
      ],
      "end_point": [
        1666,
        1
      ],
      "content": "double\nspeed_mpn_hgcd_reduce_2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_HGCD_REDUCE_CALL (mpn_hgcd_reduce_2, mpn_hgcd_reduce_2_itch);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_gcd": {
      "start_point": [
        1668,
        0
      ],
      "end_point": [
        1672,
        1
      ],
      "content": "double\nspeed_mpn_gcd (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_GCD (mpn_gcd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_gcdext": {
      "start_point": [
        1674,
        0
      ],
      "end_point": [
        1678,
        1
      ],
      "content": "double\nspeed_mpn_gcdext (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_GCDEXT (mpn_gcdext);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_gcdext_lehmer": {
      "start_point": [
        1680,
        0
      ],
      "end_point": [
        1684,
        1
      ],
      "content": "double\nspeed_mpn_gcdext_lehmer (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_GCDEXT (__gmpn_gcdext_lehmer);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_gcdext_single": {
      "start_point": [
        1686,
        0
      ],
      "end_point": [
        1690,
        1
      ],
      "content": "double\nspeed_mpn_gcdext_single (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_GCDEXT (mpn_gcdext_single);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_gcdext_double": {
      "start_point": [
        1691,
        0
      ],
      "end_point": [
        1695,
        1
      ],
      "content": "double\nspeed_mpn_gcdext_double (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_GCDEXT (mpn_gcdext_double);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_gcdext_one_single": {
      "start_point": [
        1696,
        0
      ],
      "end_point": [
        1700,
        1
      ],
      "content": "double\nspeed_mpn_gcdext_one_single (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_GCDEXT_ONE (mpn_gcdext_one_single);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_gcdext_one_double": {
      "start_point": [
        1701,
        0
      ],
      "end_point": [
        1705,
        1
      ],
      "content": "double\nspeed_mpn_gcdext_one_double (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_GCDEXT_ONE (mpn_gcdext_one_double);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_gcd_1": {
      "start_point": [
        1706,
        0
      ],
      "end_point": [
        1710,
        1
      ],
      "content": "double\nspeed_mpn_gcd_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_GCD_1 (mpn_gcd_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_gcd_1N": {
      "start_point": [
        1711,
        0
      ],
      "end_point": [
        1715,
        1
      ],
      "content": "double\nspeed_mpn_gcd_1N (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_GCD_1N (mpn_gcd_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_jacobi": {
      "start_point": [
        1718,
        0
      ],
      "end_point": [
        1722,
        1
      ],
      "content": "double\nspeed_mpz_jacobi (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_JACOBI (mpz_jacobi);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_jacobi_base": {
      "start_point": [
        1723,
        0
      ],
      "end_point": [
        1727,
        1
      ],
      "content": "double\nspeed_mpn_jacobi_base (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_JACBASE (mpn_jacobi_base);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_jacobi_base_1": {
      "start_point": [
        1728,
        0
      ],
      "end_point": [
        1732,
        1
      ],
      "content": "double\nspeed_mpn_jacobi_base_1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_JACBASE (mpn_jacobi_base_1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_jacobi_base_2": {
      "start_point": [
        1733,
        0
      ],
      "end_point": [
        1737,
        1
      ],
      "content": "double\nspeed_mpn_jacobi_base_2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_JACBASE (mpn_jacobi_base_2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_jacobi_base_3": {
      "start_point": [
        1738,
        0
      ],
      "end_point": [
        1742,
        1
      ],
      "content": "double\nspeed_mpn_jacobi_base_3 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_JACBASE (mpn_jacobi_base_3);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_jacobi_base_4": {
      "start_point": [
        1743,
        0
      ],
      "end_point": [
        1747,
        1
      ],
      "content": "double\nspeed_mpn_jacobi_base_4 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_JACBASE (mpn_jacobi_base_4);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sqrtrem": {
      "start_point": [
        1750,
        0
      ],
      "end_point": [
        1754,
        1
      ],
      "content": "double\nspeed_mpn_sqrtrem (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQRTROOT_CALL (mpn_sqrtrem (wp, wp2, s->xp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_sqrt": {
      "start_point": [
        1756,
        0
      ],
      "end_point": [
        1760,
        1
      ],
      "content": "double\nspeed_mpn_sqrt (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQRTROOT_CALL (mpn_sqrtrem (wp, NULL, s->xp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_rootrem": {
      "start_point": [
        1762,
        0
      ],
      "end_point": [
        1766,
        1
      ],
      "content": "double\nspeed_mpn_rootrem (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQRTROOT_CALL (mpn_rootrem (wp, wp2, s->xp, s->size, s->r));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_root": {
      "start_point": [
        1768,
        0
      ],
      "end_point": [
        1772,
        1
      ],
      "content": "double\nspeed_mpn_root (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SQRTROOT_CALL (mpn_rootrem (wp, NULL, s->xp, s->size, s->r));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_fac_ui": {
      "start_point": [
        1775,
        0
      ],
      "end_point": [
        1779,
        1
      ],
      "content": "double\nspeed_mpz_fac_ui (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_FAC_UI (mpz_fac_ui);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_2fac_ui": {
      "start_point": [
        1781,
        0
      ],
      "end_point": [
        1785,
        1
      ],
      "content": "double\nspeed_mpz_2fac_ui (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_UI (mpz_2fac_ui);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_fib2_ui": {
      "start_point": [
        1788,
        0
      ],
      "end_point": [
        1792,
        1
      ],
      "content": "double\nspeed_mpn_fib2_ui (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_FIB2_UI (mpn_fib2_ui);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_fib_ui": {
      "start_point": [
        1793,
        0
      ],
      "end_point": [
        1797,
        1
      ],
      "content": "double\nspeed_mpz_fib_ui (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_FIB_UI (mpz_fib_ui);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_fib2_ui": {
      "start_point": [
        1798,
        0
      ],
      "end_point": [
        1802,
        1
      ],
      "content": "double\nspeed_mpz_fib2_ui (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_FIB2_UI (mpz_fib2_ui);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_lucnum_ui": {
      "start_point": [
        1803,
        0
      ],
      "end_point": [
        1807,
        1
      ],
      "content": "double\nspeed_mpz_lucnum_ui (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_LUCNUM_UI (mpz_lucnum_ui);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_lucnum2_ui": {
      "start_point": [
        1808,
        0
      ],
      "end_point": [
        1812,
        1
      ],
      "content": "double\nspeed_mpz_lucnum2_ui (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_LUCNUM2_UI (mpz_lucnum2_ui);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_powm": {
      "start_point": [
        1815,
        0
      ],
      "end_point": [
        1819,
        1
      ],
      "content": "double\nspeed_mpz_powm (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_POWM (mpz_powm);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_powm_mod": {
      "start_point": [
        1820,
        0
      ],
      "end_point": [
        1824,
        1
      ],
      "content": "double\nspeed_mpz_powm_mod (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_POWM (mpz_powm_mod);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_powm_redc": {
      "start_point": [
        1825,
        0
      ],
      "end_point": [
        1829,
        1
      ],
      "content": "double\nspeed_mpz_powm_redc (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_POWM (mpz_powm_redc);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_powm_sec": {
      "start_point": [
        1830,
        0
      ],
      "end_point": [
        1834,
        1
      ],
      "content": "double\nspeed_mpz_powm_sec (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_POWM (mpz_powm_sec);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_powm_ui": {
      "start_point": [
        1835,
        0
      ],
      "end_point": [
        1839,
        1
      ],
      "content": "double\nspeed_mpz_powm_ui (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_POWM_UI (mpz_powm_ui);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_binvert_limb": {
      "start_point": [
        1842,
        0
      ],
      "end_point": [
        1846,
        1
      ],
      "content": "double\nspeed_binvert_limb (struct speed_params *s)\n{\n  SPEED_ROUTINE_MODLIMB_INVERT (binvert_limb);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_noop": {
      "start_point": [
        1849,
        0
      ],
      "end_point": [
        1860,
        1
      ],
      "content": "double\nspeed_noop (struct speed_params *s)\n{\n  unsigned  i;\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    noop ();\n  while (--i != 0);\n  return speed_endtime ();\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "speed_noop_wxs": {
      "start_point": [
        1862,
        0
      ],
      "end_point": [
        1882,
        1
      ],
      "content": "double\nspeed_noop_wxs (struct speed_params *s)\n{\n  mp_ptr   wp;\n  unsigned i;\n  double   t;\n  TMP_DECL;\n\n  TMP_MARK;\n  wp = TMP_ALLOC_LIMBS (1);\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    noop_wxs (wp, s->xp, s->size);\n  while (--i != 0);\n  t = speed_endtime ();\n\n  TMP_FREE;\n  return t;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "speed_noop_wxys": {
      "start_point": [
        1884,
        0
      ],
      "end_point": [
        1904,
        1
      ],
      "content": "double\nspeed_noop_wxys (struct speed_params *s)\n{\n  mp_ptr   wp;\n  unsigned i;\n  double   t;\n  TMP_DECL;\n\n  TMP_MARK;\n  wp = TMP_ALLOC_LIMBS (1);\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    noop_wxys (wp, s->xp, s->yp, s->size);\n  while (--i != 0);\n  t = speed_endtime ();\n\n  TMP_FREE;\n  return t;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "speed_malloc_free": {
      "start_point": [
        1928,
        0
      ],
      "end_point": [
        1935,
        1
      ],
      "content": "double\nspeed_malloc_free (struct speed_params *s)\n{\n  size_t  bytes = s->size * GMP_LIMB_BYTES;\n  SPEED_ROUTINE_ALLOC_FREE (void *p,\n\t\t\t    p = malloc (bytes);\n\t\t\t    free (p));\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_malloc_realloc_free": {
      "start_point": [
        1937,
        0
      ],
      "end_point": [
        1945,
        1
      ],
      "content": "double\nspeed_malloc_realloc_free (struct speed_params *s)\n{\n  size_t  bytes = s->size * GMP_LIMB_BYTES;\n  SPEED_ROUTINE_ALLOC_FREE (void *p,\n\t\t\t    p = malloc (GMP_LIMB_BYTES);\n\t\t\t    p = realloc (p, bytes);\n\t\t\t    free (p));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_gmp_allocate_free": {
      "start_point": [
        1947,
        0
      ],
      "end_point": [
        1954,
        1
      ],
      "content": "double\nspeed_gmp_allocate_free (struct speed_params *s)\n{\n  size_t  bytes = s->size * GMP_LIMB_BYTES;\n  SPEED_ROUTINE_ALLOC_FREE (void *p,\n\t\t\t    p = (*__gmp_allocate_func) (bytes);\n\t\t\t    (*__gmp_free_func) (p, bytes));\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "speed_gmp_allocate_reallocate_free": {
      "start_point": [
        1956,
        0
      ],
      "end_point": [
        1965,
        1
      ],
      "content": "double\nspeed_gmp_allocate_reallocate_free (struct speed_params *s)\n{\n  size_t  bytes = s->size * GMP_LIMB_BYTES;\n  SPEED_ROUTINE_ALLOC_FREE\n    (void *p,\n     p = (*__gmp_allocate_func) (GMP_LIMB_BYTES);\n     p = (*__gmp_reallocate_func) (p, bytes, GMP_LIMB_BYTES);\n     (*__gmp_free_func) (p, bytes));\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_init_clear": {
      "start_point": [
        1967,
        0
      ],
      "end_point": [
        1973,
        1
      ],
      "content": "double\nspeed_mpz_init_clear (struct speed_params *s)\n{\n  SPEED_ROUTINE_ALLOC_FREE (mpz_t z,\n\t\t\t    mpz_init (z);\n\t\t\t    mpz_clear (z));\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_init_realloc_clear": {
      "start_point": [
        1975,
        0
      ],
      "end_point": [
        1982,
        1
      ],
      "content": "double\nspeed_mpz_init_realloc_clear (struct speed_params *s)\n{\n  SPEED_ROUTINE_ALLOC_FREE (mpz_t z,\n\t\t\t    mpz_init (z);\n\t\t\t    _mpz_realloc (z, s->size);\n\t\t\t    mpz_clear (z));\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "speed_mpq_init_clear": {
      "start_point": [
        1984,
        0
      ],
      "end_point": [
        1990,
        1
      ],
      "content": "double\nspeed_mpq_init_clear (struct speed_params *s)\n{\n  SPEED_ROUTINE_ALLOC_FREE (mpq_t q,\n\t\t\t    mpq_init (q);\n\t\t\t    mpq_clear (q));\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "speed_mpf_init_clear": {
      "start_point": [
        1992,
        0
      ],
      "end_point": [
        1998,
        1
      ],
      "content": "double\nspeed_mpf_init_clear (struct speed_params *s)\n{\n  SPEED_ROUTINE_ALLOC_FREE (mpf_t f,\n\t\t\t    mpf_init (f);\n\t\t\t    mpf_clear (f));\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_add": {
      "start_point": [
        2005,
        0
      ],
      "end_point": [
        2033,
        1
      ],
      "content": "double\nspeed_mpz_add (struct speed_params *s)\n{\n  mpz_t     w, x, y;\n  unsigned  i;\n  double    t;\n\n  mpz_init (w);\n  mpz_init (x);\n  mpz_init (y);\n\n  mpz_set_n (x, s->xp, s->size);\n  mpz_set_n (y, s->yp, s->size);\n  mpz_add (w, x, y);\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    {\n      mpz_add (w, x, y);\n    }\n  while (--i != 0);\n  t = speed_endtime ();\n\n  mpz_clear (w);\n  mpz_clear (x);\n  mpz_clear (y);\n  return t;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_bin_uiui": {
      "start_point": [
        2039,
        0
      ],
      "end_point": [
        2064,
        1
      ],
      "content": "double\nspeed_mpz_bin_uiui (struct speed_params *s)\n{\n  mpz_t          w;\n  unsigned long  k;\n  unsigned  i;\n  double    t;\n\n  mpz_init (w);\n  if (s->r != 0)\n    k = s->r;\n  else\n    k = s->size/2;\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    {\n      mpz_bin_uiui (w, s->size, k);\n    }\n  while (--i != 0);\n  t = speed_endtime ();\n\n  mpz_clear (w);\n  return t;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_bin_ui": {
      "start_point": [
        2069,
        0
      ],
      "end_point": [
        2099,
        1
      ],
      "content": "double\nspeed_mpz_bin_ui (struct speed_params *s)\n{\n  mpz_t          w, x;\n  unsigned long  k;\n  unsigned  i;\n  double    t;\n\n  mpz_init (w);\n  mpz_init_set_ui (x, 0);\n\n  mpz_setbit (x, s->size);\n\n  if (s->r != 0)\n    k = s->r;\n  else\n    k = s->size;\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    {\n      mpz_bin_ui (w, x, k);\n    }\n  while (--i != 0);\n  t = speed_endtime ();\n\n  mpz_clear (w);\n  mpz_clear (x);\n  return t;\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "speed_umul_ppmm": {
      "start_point": [
        2166,
        0
      ],
      "end_point": [
        2196,
        1
      ],
      "content": "double\nspeed_umul_ppmm (struct speed_params *s)\n{\n  SPEED_MACRO_UMUL_PPMM_A;\n  {\n    umul_ppmm (h, l, l, h);  h ^= s->xp_block[0]; l ^= s->yp_block[0];\n     umul_ppmm (h, l, l, h); h ^= s->xp_block[1]; l ^= s->yp_block[1];\n     umul_ppmm (h, l, l, h); h ^= s->xp_block[2]; l ^= s->yp_block[2];\n    umul_ppmm (h, l, l, h);  h ^= s->xp_block[3]; l ^= s->yp_block[3];\n     umul_ppmm (h, l, l, h); h ^= s->xp_block[4]; l ^= s->yp_block[4];\n     umul_ppmm (h, l, l, h); h ^= s->xp_block[5]; l ^= s->yp_block[5];\n    umul_ppmm (h, l, l, h);  h ^= s->xp_block[6]; l ^= s->yp_block[6];\n     umul_ppmm (h, l, l, h); h ^= s->xp_block[7]; l ^= s->yp_block[7];\n     umul_ppmm (h, l, l, h); h ^= s->xp_block[8]; l ^= s->yp_block[8];\n    umul_ppmm (h, l, l, h);  h ^= s->xp_block[9]; l ^= s->yp_block[9];\n  }\n  SPEED_MACRO_UMUL_PPMM_B;\n  {\n    umul_ppmm (h, l, l, h);\n     umul_ppmm (h, l, l, h);\n     umul_ppmm (h, l, l, h);\n    umul_ppmm (h, l, l, h);\n     umul_ppmm (h, l, l, h);\n     umul_ppmm (h, l, l, h);\n    umul_ppmm (h, l, l, h);\n     umul_ppmm (h, l, l, h);\n     umul_ppmm (h, l, l, h);\n    umul_ppmm (h, l, l, h);\n  }\n  SPEED_MACRO_UMUL_PPMM_C;\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_umul_ppmm": {
      "start_point": [
        2200,
        0
      ],
      "end_point": [
        2230,
        1
      ],
      "content": "double\nspeed_mpn_umul_ppmm (struct speed_params *s)\n{\n  SPEED_MACRO_UMUL_PPMM_A;\n  {\n    h = mpn_umul_ppmm (&l, h, l);  h ^= s->xp_block[0]; l ^= s->yp_block[0];\n     h = mpn_umul_ppmm (&l, h, l); h ^= s->xp_block[1]; l ^= s->yp_block[1];\n     h = mpn_umul_ppmm (&l, h, l); h ^= s->xp_block[2]; l ^= s->yp_block[2];\n    h = mpn_umul_ppmm (&l, h, l);  h ^= s->xp_block[3]; l ^= s->yp_block[3];\n     h = mpn_umul_ppmm (&l, h, l); h ^= s->xp_block[4]; l ^= s->yp_block[4];\n     h = mpn_umul_ppmm (&l, h, l); h ^= s->xp_block[5]; l ^= s->yp_block[5];\n    h = mpn_umul_ppmm (&l, h, l);  h ^= s->xp_block[6]; l ^= s->yp_block[6];\n     h = mpn_umul_ppmm (&l, h, l); h ^= s->xp_block[7]; l ^= s->yp_block[7];\n     h = mpn_umul_ppmm (&l, h, l); h ^= s->xp_block[8]; l ^= s->yp_block[8];\n    h = mpn_umul_ppmm (&l, h, l);  h ^= s->xp_block[9]; l ^= s->yp_block[9];\n  }\n  SPEED_MACRO_UMUL_PPMM_B;\n  {\n    h = mpn_umul_ppmm (&l, h, l);\n     h = mpn_umul_ppmm (&l, h, l);\n     h = mpn_umul_ppmm (&l, h, l);\n    h = mpn_umul_ppmm (&l, h, l);\n     h = mpn_umul_ppmm (&l, h, l);\n     h = mpn_umul_ppmm (&l, h, l);\n    h = mpn_umul_ppmm (&l, h, l);\n     h = mpn_umul_ppmm (&l, h, l);\n     h = mpn_umul_ppmm (&l, h, l);\n    h = mpn_umul_ppmm (&l, h, l);\n  }\n  SPEED_MACRO_UMUL_PPMM_C;\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_umul_ppmm_r": {
      "start_point": [
        2234,
        0
      ],
      "end_point": [
        2264,
        1
      ],
      "content": "double\nspeed_mpn_umul_ppmm_r (struct speed_params *s)\n{\n  SPEED_MACRO_UMUL_PPMM_A;\n  {\n    h = mpn_umul_ppmm_r (h, l, &l);  h ^= s->xp_block[0]; l ^= s->yp_block[0];\n     h = mpn_umul_ppmm_r (h, l, &l); h ^= s->xp_block[1]; l ^= s->yp_block[1];\n     h = mpn_umul_ppmm_r (h, l, &l); h ^= s->xp_block[2]; l ^= s->yp_block[2];\n    h = mpn_umul_ppmm_r (h, l, &l);  h ^= s->xp_block[3]; l ^= s->yp_block[3];\n     h = mpn_umul_ppmm_r (h, l, &l); h ^= s->xp_block[4]; l ^= s->yp_block[4];\n     h = mpn_umul_ppmm_r (h, l, &l); h ^= s->xp_block[5]; l ^= s->yp_block[5];\n    h = mpn_umul_ppmm_r (h, l, &l);  h ^= s->xp_block[6]; l ^= s->yp_block[6];\n     h = mpn_umul_ppmm_r (h, l, &l); h ^= s->xp_block[7]; l ^= s->yp_block[7];\n     h = mpn_umul_ppmm_r (h, l, &l); h ^= s->xp_block[8]; l ^= s->yp_block[8];\n    h = mpn_umul_ppmm_r (h, l, &l);  h ^= s->xp_block[9]; l ^= s->yp_block[9];\n  }\n  SPEED_MACRO_UMUL_PPMM_B;\n  {\n    h = mpn_umul_ppmm_r (h, l, &l);\n     h = mpn_umul_ppmm_r (h, l, &l);\n     h = mpn_umul_ppmm_r (h, l, &l);\n    h = mpn_umul_ppmm_r (h, l, &l);\n     h = mpn_umul_ppmm_r (h, l, &l);\n     h = mpn_umul_ppmm_r (h, l, &l);\n    h = mpn_umul_ppmm_r (h, l, &l);\n     h = mpn_umul_ppmm_r (h, l, &l);\n     h = mpn_umul_ppmm_r (h, l, &l);\n    h = mpn_umul_ppmm_r (h, l, &l);\n  }\n  SPEED_MACRO_UMUL_PPMM_C;\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_udiv_qrnnd": {
      "start_point": [
        2333,
        0
      ],
      "end_point": [
        2350,
        1
      ],
      "content": "double\nspeed_udiv_qrnnd (struct speed_params *s)\n{\n  SPEED_ROUTINE_UDIV_QRNND_A (UDIV_NEEDS_NORMALIZATION);\n  {\n    udiv_qrnnd (q, r, r, q, d);\n     udiv_qrnnd (q, r, r, q, d);\n     udiv_qrnnd (q, r, r, q, d);\n    udiv_qrnnd (q, r, r, q, d);\n     udiv_qrnnd (q, r, r, q, d);\n     udiv_qrnnd (q, r, r, q, d);\n    udiv_qrnnd (q, r, r, q, d);\n     udiv_qrnnd (q, r, r, q, d);\n     udiv_qrnnd (q, r, r, q, d);\n    udiv_qrnnd (q, r, r, q, d);\n  }\n  SPEED_ROUTINE_UDIV_QRNND_B;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "speed_udiv_qrnnd_c": {
      "start_point": [
        2352,
        0
      ],
      "end_point": [
        2369,
        1
      ],
      "content": "double\nspeed_udiv_qrnnd_c (struct speed_params *s)\n{\n  SPEED_ROUTINE_UDIV_QRNND_A (1);\n  {\n    __udiv_qrnnd_c (q, r, r, q, d);\n     __udiv_qrnnd_c (q, r, r, q, d);\n     __udiv_qrnnd_c (q, r, r, q, d);\n    __udiv_qrnnd_c (q, r, r, q, d);\n     __udiv_qrnnd_c (q, r, r, q, d);\n     __udiv_qrnnd_c (q, r, r, q, d);\n    __udiv_qrnnd_c (q, r, r, q, d);\n     __udiv_qrnnd_c (q, r, r, q, d);\n     __udiv_qrnnd_c (q, r, r, q, d);\n    __udiv_qrnnd_c (q, r, r, q, d);\n  }\n  SPEED_ROUTINE_UDIV_QRNND_B;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_udiv_qrnnd": {
      "start_point": [
        2372,
        0
      ],
      "end_point": [
        2389,
        1
      ],
      "content": "double\nspeed_mpn_udiv_qrnnd (struct speed_params *s)\n{\n  SPEED_ROUTINE_UDIV_QRNND_A (1);\n  {\n    q = mpn_udiv_qrnnd (&r, r, q, d);\n     q = mpn_udiv_qrnnd (&r, r, q, d);\n     q = mpn_udiv_qrnnd (&r, r, q, d);\n    q = mpn_udiv_qrnnd (&r, r, q, d);\n     q = mpn_udiv_qrnnd (&r, r, q, d);\n     q = mpn_udiv_qrnnd (&r, r, q, d);\n    q = mpn_udiv_qrnnd (&r, r, q, d);\n     q = mpn_udiv_qrnnd (&r, r, q, d);\n     q = mpn_udiv_qrnnd (&r, r, q, d);\n    q = mpn_udiv_qrnnd (&r, r, q, d);\n  }\n  SPEED_ROUTINE_UDIV_QRNND_B;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_udiv_qrnnd_r": {
      "start_point": [
        2393,
        0
      ],
      "end_point": [
        2410,
        1
      ],
      "content": "double\nspeed_mpn_udiv_qrnnd_r (struct speed_params *s)\n{\n  SPEED_ROUTINE_UDIV_QRNND_A (1);\n  {\n    q = mpn_udiv_qrnnd_r (r, q, d, &r);\n     q = mpn_udiv_qrnnd_r (r, q, d, &r);\n     q = mpn_udiv_qrnnd_r (r, q, d, &r);\n    q = mpn_udiv_qrnnd_r (r, q, d, &r);\n     q = mpn_udiv_qrnnd_r (r, q, d, &r);\n     q = mpn_udiv_qrnnd_r (r, q, d, &r);\n    q = mpn_udiv_qrnnd_r (r, q, d, &r);\n     q = mpn_udiv_qrnnd_r (r, q, d, &r);\n     q = mpn_udiv_qrnnd_r (r, q, d, &r);\n    q = mpn_udiv_qrnnd_r (r, q, d, &r);\n  }\n  SPEED_ROUTINE_UDIV_QRNND_B;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_invert_limb": {
      "start_point": [
        2414,
        0
      ],
      "end_point": [
        2418,
        1
      ],
      "content": "double\nspeed_invert_limb (struct speed_params *s)\n{\n  SPEED_ROUTINE_INVERT_LIMB_CALL (invert_limb (dinv, d));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "speed_operator_div": {
      "start_point": [
        2423,
        0
      ],
      "end_point": [
        2462,
        1
      ],
      "content": "double\nspeed_operator_div (struct speed_params *s)\n{\n  double     t;\n  unsigned   i;\n  mp_limb_t  x, q, d;\n\n  s->time_divisor = 10;\n\n  /* divisor from \"r\" parameter, or a default */\n  d = s->r;\n  if (d == 0)\n    d = mp_bases[10].big_base;\n\n  x = s->xp[0];\n  q = 0;\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    {\n      q ^= x; q /= d;\n       q ^= x; q /= d;\n       q ^= x; q /= d;\n      q ^= x; q /= d;\n       q ^= x; q /= d;\n       q ^= x; q /= d;\n      q ^= x; q /= d;\n       q ^= x; q /= d;\n       q ^= x; q /= d;\n      q ^= x; q /= d;\n    }\n  while (--i != 0);\n  t = speed_endtime ();\n\n  /* stop the compiler optimizing away the whole calculation! */\n  noop_1 (q);\n\n  return t;\n}",
      "lines": 40,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "speed_operator_mod": {
      "start_point": [
        2464,
        0
      ],
      "end_point": [
        2503,
        1
      ],
      "content": "double\nspeed_operator_mod (struct speed_params *s)\n{\n  double     t;\n  unsigned   i;\n  mp_limb_t  x, r, d;\n\n  s->time_divisor = 10;\n\n  /* divisor from \"r\" parameter, or a default */\n  d = s->r;\n  if (d == 0)\n    d = mp_bases[10].big_base;\n\n  x = s->xp[0];\n  r = 0;\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    {\n      r ^= x; r %= d;\n       r ^= x; r %= d;\n       r ^= x; r %= d;\n      r ^= x; r %= d;\n       r ^= x; r %= d;\n       r ^= x; r %= d;\n      r ^= x; r %= d;\n       r ^= x; r %= d;\n       r ^= x; r %= d;\n      r ^= x; r %= d;\n    }\n  while (--i != 0);\n  t = speed_endtime ();\n\n  /* stop the compiler optimizing away the whole calculation! */\n  noop_1 (r);\n\n  return t;\n}",
      "lines": 40,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "speed_routine_count_zeros_setup": {
      "start_point": [
        2513,
        0
      ],
      "end_point": [
        2563,
        1
      ],
      "content": "int\nspeed_routine_count_zeros_setup (struct speed_params *s,\n\t\t\t\t mp_ptr xp, int leading, int zero)\n{\n  int        i, c;\n  mp_limb_t  n;\n\n  if (s->r == 0)\n    {\n      /* Make uniformly distributed data.  If zero isn't allowed then change\n\t it to 1 for leading, or 0x800..00 for trailing.  */\n      MPN_COPY (xp, s->xp_block, SPEED_BLOCK_SIZE);\n      if (! zero)\n\tfor (i = 0; i < SPEED_BLOCK_SIZE; i++)\n\t  if (xp[i] == 0)\n\t    xp[i] = leading ? 1 : GMP_LIMB_HIGHBIT;\n    }\n  else if (s->r == 1)\n    {\n      /* Make counts uniformly distributed.  A randomly chosen bit is set, and\n\t for leading the rest above it are cleared, or for trailing then the\n\t rest below.  */\n      for (i = 0; i < SPEED_BLOCK_SIZE; i++)\n\t{\n\t  mp_limb_t  set = CNST_LIMB(1) << (s->yp_block[i] % GMP_LIMB_BITS);\n\t  mp_limb_t  keep_below = set-1;\n\t  mp_limb_t  keep_above = MP_LIMB_T_MAX ^ keep_below;\n\t  mp_limb_t  keep = (leading ? keep_below : keep_above);\n\t  xp[i] = (s->xp_block[i] & keep) | set;\n\t}\n    }\n  else\n    {\n      return 0;\n    }\n\n  /* Account for the effect of n^=c. */\n  c = 0;\n  for (i = 0; i < SPEED_BLOCK_SIZE; i++)\n    {\n      n = xp[i];\n      xp[i] ^= c;\n\n      if (leading)\n\tcount_leading_zeros (c, n);\n      else\n\tcount_trailing_zeros (c, n);\n    }\n\n  return 1;\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "speed_count_leading_zeros": {
      "start_point": [
        2565,
        0
      ],
      "end_point": [
        2577,
        1
      ],
      "content": "double\nspeed_count_leading_zeros (struct speed_params *s)\n{\n#ifdef COUNT_LEADING_ZEROS_0\n#define COUNT_LEADING_ZEROS_0_ALLOWED   1\n#else\n#define COUNT_LEADING_ZEROS_0_ALLOWED   0\n#endif\n\n  SPEED_ROUTINE_COUNT_ZEROS_A (1, COUNT_LEADING_ZEROS_0_ALLOWED);\n  count_leading_zeros (c, n);\n  SPEED_ROUTINE_COUNT_ZEROS_B ();\n}",
      "lines": 13,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_count_trailing_zeros": {
      "start_point": [
        2578,
        0
      ],
      "end_point": [
        2584,
        1
      ],
      "content": "double\nspeed_count_trailing_zeros (struct speed_params *s)\n{\n  SPEED_ROUTINE_COUNT_ZEROS_A (0, 0);\n  count_trailing_zeros (c, n);\n  SPEED_ROUTINE_COUNT_ZEROS_B ();\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_get_str": {
      "start_point": [
        2587,
        0
      ],
      "end_point": [
        2591,
        1
      ],
      "content": "double\nspeed_mpn_get_str (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_GET_STR (mpn_get_str);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_set_str": {
      "start_point": [
        2593,
        0
      ],
      "end_point": [
        2597,
        1
      ],
      "content": "double\nspeed_mpn_set_str (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SET_STR_CALL (mpn_set_str (wp, xp, s->size, base));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_bc_set_str": {
      "start_point": [
        2598,
        0
      ],
      "end_point": [
        2602,
        1
      ],
      "content": "double\nspeed_mpn_bc_set_str (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_SET_STR_CALL (mpn_bc_set_str (wp, xp, s->size, base));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_MPN_ZERO": {
      "start_point": [
        2604,
        0
      ],
      "end_point": [
        2608,
        1
      ],
      "content": "double\nspeed_MPN_ZERO (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_ZERO_CALL (MPN_ZERO (wp, s->size));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_randinit": {
      "start_point": [
        2611,
        0
      ],
      "end_point": [
        2623,
        1
      ],
      "content": "int\nspeed_randinit (struct speed_params *s, gmp_randstate_ptr rstate)\n{\n  if (s->r == 0)\n    gmp_randinit_default (rstate);\n  else if (s->r == 1)\n    gmp_randinit_mt (rstate);\n  else\n    {\n      return gmp_randinit_lc_2exp_size (rstate, s->r);\n    }\n  return 1;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "speed_gmp_randseed": {
      "start_point": [
        2625,
        0
      ],
      "end_point": [
        2653,
        1
      ],
      "content": "double\nspeed_gmp_randseed (struct speed_params *s)\n{\n  gmp_randstate_t  rstate;\n  unsigned  i;\n  double    t;\n  mpz_t     x;\n\n  SPEED_RESTRICT_COND (s->size >= 1);\n  SPEED_RESTRICT_COND (speed_randinit (s, rstate));\n\n  /* s->size bits of seed */\n  mpz_init_set_n (x, s->xp, s->size);\n  mpz_fdiv_r_2exp (x, x, (unsigned long) s->size);\n\n  /* cache priming */\n  gmp_randseed (rstate, x);\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    gmp_randseed (rstate, x);\n  while (--i != 0);\n  t = speed_endtime ();\n\n  gmp_randclear (rstate);\n  mpz_clear (x);\n  return t;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "speed_gmp_randseed_ui": {
      "start_point": [
        2655,
        0
      ],
      "end_point": [
        2682,
        1
      ],
      "content": "double\nspeed_gmp_randseed_ui (struct speed_params *s)\n{\n  gmp_randstate_t  rstate;\n  unsigned  i, j;\n  double    t;\n\n  SPEED_RESTRICT_COND (speed_randinit (s, rstate));\n\n  /* cache priming */\n  gmp_randseed_ui (rstate, 123L);\n\n  speed_starttime ();\n  i = s->reps;\n  j = 0;\n  do\n    {\n      gmp_randseed_ui (rstate, (unsigned long) s->xp_block[j]);\n      j++;\n      if (j >= SPEED_BLOCK_SIZE)\n\tj = 0;\n    }\n  while (--i != 0);\n  t = speed_endtime ();\n\n  gmp_randclear (rstate);\n  return t;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_urandomb": {
      "start_point": [
        2684,
        0
      ],
      "end_point": [
        2711,
        1
      ],
      "content": "double\nspeed_mpz_urandomb (struct speed_params *s)\n{\n  gmp_randstate_t  rstate;\n  mpz_t     z;\n  unsigned  i;\n  double    t;\n\n  SPEED_RESTRICT_COND (s->size >= 0);\n  SPEED_RESTRICT_COND (speed_randinit (s, rstate));\n\n  mpz_init (z);\n\n  /* cache priming */\n  mpz_urandomb (z, rstate, (unsigned long) s->size);\n  mpz_urandomb (z, rstate, (unsigned long) s->size);\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    mpz_urandomb (z, rstate, (unsigned long) s->size);\n  while (--i != 0);\n  t = speed_endtime ();\n\n  mpz_clear (z);\n  gmp_randclear (rstate);\n  return t;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "double"
      ]
    }
  },
  "gmp/gmp-6.1.2/tune/divrem1div.c": {},
  "gmp/gmp-6.1.2/tune/divrem1inv.c": {},
  "gmp/gmp-6.1.2/tune/divrem2div.c": {},
  "gmp/gmp-6.1.2/tune/divrem2inv.c": {},
  "gmp/gmp-6.1.2/tune/div_qr_1n_pi1_1.c": {},
  "gmp/gmp-6.1.2/tune/div_qr_1n_pi1_2.c": {},
  "gmp/gmp-6.1.2/tune/div_qr_1_tune.c": {},
  "gmp/gmp-6.1.2/tune/freq.c": {
    "freq_environment": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static int\nfreq_environment (int help)\n{\n  char  *e;\n\n  HELP (\"environment variable GMP_CPU_FREQUENCY (in Hertz)\");\n\n  e = getenv (\"GMP_CPU_FREQUENCY\");\n  if (e == NULL)\n    return 0;\n\n  speed_cycletime = 1.0 / atof (e);\n\n  if (speed_option_verbose)\n    printf (\"Using GMP_CPU_FREQUENCY %.2f for cycle time %.3g\\n\",\n            atof (e), speed_cycletime);\n\n  return 1;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_getsysinfo": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "static int\nfreq_getsysinfo (int help)\n{\n#if HAVE_GETSYSINFO\n  struct cpu_info  c;\n  int              start;\n\n  HELP (\"getsysinfo() GSI_CPU_INFO\");\n\n  start = 0;\n  if (getsysinfo (GSI_CPU_INFO, (caddr_t) &c, sizeof (c),\n                  &start, NULL, NULL) != -1)\n    {\n      speed_cycletime = 1e-6 / (double) c.mhz;\n      if (speed_option_verbose)\n        printf (\"Using getsysinfo() GSI_CPU_INFO %u for cycle time %.3g\\n\",\n                c.mhz, speed_cycletime);\n      return 1;\n    }\n#endif\n  return 0;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_pstat_getprocessor": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "static int\nfreq_pstat_getprocessor (int help)\n{\n#if HAVE_PSTAT_GETPROCESSOR && HAVE_PSP_ITICKSPERCLKTICK\n  struct pst_processor  p;\n\n  HELP (\"pstat_getprocessor() psp_iticksperclktick\");\n\n  if (pstat_getprocessor (&p, sizeof(p), 1, 0) != -1)\n    {\n      long  c = clk_tck();\n      speed_cycletime = 1.0 / (c * p.psp_iticksperclktick);\n      if (speed_option_verbose)\n        printf (\"Using pstat_getprocessor() psp_iticksperclktick %lu and clk_tck %ld for cycle time %.3g\\n\",\n                (unsigned long) p.psp_iticksperclktick, c,\n                speed_cycletime);\n      return 1;\n    }\n#endif\n  return 0;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_sysctlbyname_i586_freq": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static int\nfreq_sysctlbyname_i586_freq (int help)\n{\n#if HAVE_SYSCTLBYNAME\n  unsigned  val;\n  size_t    size;\n\n  HELP (\"sysctlbyname() machdep.i586_freq\");\n\n  size = sizeof(val);\n  if (sysctlbyname (\"machdep.i586_freq\", &val, &size, NULL, 0) == 0\n      && size == sizeof(val))\n    {\n      speed_cycletime = 1.0 / (double) val;\n      if (speed_option_verbose)\n        printf (\"Using sysctlbyname() machdep.i586_freq %u for cycle time %.3g\\n\",\n                val, speed_cycletime);\n      return 1;\n    }\n#endif\n  return 0;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_sysctlbyname_tsc_freq": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "static int\nfreq_sysctlbyname_tsc_freq (int help)\n{\n#if HAVE_SYSCTLBYNAME\n  unsigned  val;\n  size_t    size;\n\n  HELP (\"sysctlbyname() machdep.tsc_freq\");\n\n  size = sizeof(val);\n  if (sysctlbyname (\"machdep.tsc_freq\", &val, &size, NULL, 0) == 0\n      && size == sizeof(val))\n    {\n      speed_cycletime = 1.0 / (double) val;\n      if (speed_option_verbose)\n        printf (\"Using sysctlbyname() machdep.tsc_freq %u for cycle time %.3g\\n\",\n                val, speed_cycletime);\n      return 1;\n    }\n#endif\n  return 0;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_sysctl_hw_cpufrequency": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "static int\nfreq_sysctl_hw_cpufrequency (int help)\n{\n#if HAVE_SYSCTL && defined (CTL_HW) && defined (HW_CPU_FREQ)\n  int       mib[2];\n  unsigned  val;\n  size_t    size;\n\n  HELP (\"sysctl() hw.cpufrequency\");\n\n  mib[0] = CTL_HW;\n  mib[1] = HW_CPU_FREQ;\n  size = sizeof(val);\n  if (sysctl (mib, 2, &val, &size, NULL, 0) == 0)\n    {\n      speed_cycletime = 1.0 / (double) val;\n      if (speed_option_verbose)\n        printf (\"Using sysctl() hw.cpufrequency %u for cycle time %.3g\\n\",\n                val, speed_cycletime);\n      return 1;\n    }\n#endif\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_sysctl_hw_model": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "static int\nfreq_sysctl_hw_model (int help)\n{\n#if HAVE_SYSCTL && defined (CTL_HW) && defined (HW_MODEL)\n  int       mib[2];\n  char      str[128];\n  unsigned  val;\n  size_t    size;\n  char      *p;\n  int       end;\n\n  HELP (\"sysctl() hw.model\");\n\n  mib[0] = CTL_HW;\n  mib[1] = HW_MODEL;\n  size = sizeof(str);\n  if (sysctl (mib, 2, str, &size, NULL, 0) == 0)\n    {\n      for (p = str; *p != '\\0'; p++)\n        {\n          end = 0;\n          if (sscanf (p, \"%u MHz%n\", &val, &end) == 1 && end != 0)\n            {\n              speed_cycletime = 1e-6 / (double) val;\n              if (speed_option_verbose)\n                printf (\"Using sysctl() hw.model %u for cycle time %.3g\\n\",\n                        val, speed_cycletime);\n              return 1;\n            }\n        }\n    }\n#endif\n  return 0;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_proc_cpuinfo": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "static int\nfreq_proc_cpuinfo (int help)\n{\n  FILE    *fp;\n  char    buf[128];\n  double  val;\n  int     ret = 0;\n  int     end;\n\n  HELP (\"linux kernel /proc/cpuinfo file, cpu MHz or bogomips\");\n\n  if ((fp = fopen (\"/proc/cpuinfo\", \"r\")) != NULL)\n    {\n      while (fgets (buf, sizeof (buf), fp) != NULL)\n        {\n          if (sscanf (buf, \"cycle frequency [Hz]    : %lf\", &val) == 1\n              && val != 0.0)\n            {\n              speed_cycletime = 1.0 / val;\n              if (speed_option_verbose)\n                printf (\"Using /proc/cpuinfo \\\"cycle frequency\\\" %.2f for cycle time %.3g\\n\", val, speed_cycletime);\n              ret = 1;\n              break;\n            }\n          if (sscanf (buf, \"cpu MHz : %lf\\n\", &val) == 1)\n            {\n              speed_cycletime = 1e-6 / val;\n              if (speed_option_verbose)\n                printf (\"Using /proc/cpuinfo \\\"cpu MHz\\\" %.2f for cycle time %.3g\\n\", val, speed_cycletime);\n              ret = 1;\n              break;\n            }\n          end = 0;\n          if (sscanf (buf, \"clock : %lfMHz\\n%n\", &val, &end) == 1 && end != 0)\n            {\n              speed_cycletime = 1e-6 / val;\n              if (speed_option_verbose)\n                printf (\"Using /proc/cpuinfo \\\"clock\\\" %.2f for cycle time %.3g\\n\", val, speed_cycletime);\n              ret = 1;\n              break;\n            }\n          if (sscanf (buf, \"bogomips : %lf\\n\", &val) == 1\n              || sscanf (buf, \"BogoMIPS : %lf\\n\", &val) == 1)\n            {\n              speed_cycletime = 1e-6 / val;\n              if (speed_option_verbose)\n                printf (\"Using /proc/cpuinfo \\\"bogomips\\\" %.2f for cycle time %.3g\\n\", val, speed_cycletime);\n              ret = 1;\n              break;\n            }\n        }\n      fclose (fp);\n    }\n  return ret;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_sunos_sysinfo": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        468,
        1
      ],
      "content": "static int\nfreq_sunos_sysinfo (int help)\n{\n  int     ret = 0;\n#if HAVE_POPEN\n  FILE    *fp;\n  char    buf[128];\n  double  val;\n  int     end;\n\n  HELP (\"SunOS /bin/sysinfo program output, cpu0\");\n\n  /* Error messages are sent to /dev/null in case /bin/sysinfo doesn't\n     exist.  The brackets are necessary for some shells. */\n  if ((fp = popen (\"(/bin/sysinfo) 2>/dev/null\", \"r\")) != NULL)\n    {\n      while (fgets (buf, sizeof (buf), fp) != NULL)\n        {\n          end = 0;\n          if (sscanf (buf, \" cpu0 is a \\\"%lf MHz%n\", &val, &end) == 1\n              && end != 0)\n            {\n              speed_cycletime = 1e-6 / val;\n              if (speed_option_verbose)\n                printf (\"Using /bin/sysinfo \\\"cpu0 MHz\\\" %.2f for cycle time %.3g\\n\", val, speed_cycletime);\n              ret = 1;\n              break;\n            }\n        }\n      pclose (fp);\n    }\n#endif\n  return ret;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_sco_etchw": {
      "start_point": [
        474,
        0
      ],
      "end_point": [
        508,
        1
      ],
      "content": "static int\nfreq_sco_etchw (int help)\n{\n  int     ret = 0;\n#if HAVE_POPEN\n  FILE    *fp;\n  char    buf[128];\n  double  val;\n  int     end;\n\n  HELP (\"SCO /etc/hw program output\");\n\n  /* Error messages are sent to /dev/null in case /etc/hw doesn't exist.\n     The brackets are necessary for some shells. */\n  if ((fp = popen (\"(/etc/hw -r cpu) 2>/dev/null\", \"r\")) != NULL)\n    {\n      while (fgets (buf, sizeof (buf), fp) != NULL)\n        {\n          end = 0;\n          if (sscanf (buf, \" The speed of the CPU is approximately %lfMHz%n\",\n                      &val, &end) == 1 && end != 0)\n            {\n              speed_cycletime = 1e-6 / val;\n              if (speed_option_verbose)\n                printf (\"Using /etc/hw %.2f MHz, for cycle time %.3g\\n\",\n                        val, speed_cycletime);\n              ret = 1;\n              break;\n            }\n        }\n      pclose (fp);\n    }\n#endif\n  return ret;\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_attr_get_invent": {
      "start_point": [
        518,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "static int\nfreq_attr_get_invent (int help)\n{\n  int     ret = 0;\n#if HAVE_ATTR_GET && HAVE_INVENT_H && defined (INFO_LBL_DETAIL_INVENT)\n  invent_cpuinfo_t  inv;\n  int               len, val;\n\n  HELP (\"attr_get(\\\"/hw/cpunum/0\\\") ic_cpu_info.cpufq\");\n\n  len = sizeof (inv);\n  if (attr_get (\"/hw/cpunum/0\", INFO_LBL_DETAIL_INVENT,\n                (char *) &inv, &len, 0) == 0\n      && len == sizeof (inv)\n      && inv.ic_gen.ig_invclass == INV_PROCESSOR)\n    {\n      val = inv.ic_cpu_info.cpufq;\n      speed_cycletime = 1e-6 / val;\n      if (speed_option_verbose)\n        printf (\"Using attr_get(\\\"/hw/cpunum/0\\\") ic_cpu_info.cpufq %d MHz for cycle time %.3g\\n\", val, speed_cycletime);\n      ret = 1;\n    }\n#endif\n  return ret;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_bsd_dmesg": {
      "start_point": [
        559,
        0
      ],
      "end_point": [
        593,
        1
      ],
      "content": "static int\nfreq_bsd_dmesg (int help)\n{\n  FILE    *fp;\n  char    buf[256], *p;\n  double  val;\n  int     ret = 0;\n  int     end;\n\n  HELP (\"BSD /var/run/dmesg.boot file\");\n\n  if ((fp = fopen (\"/var/run/dmesg.boot\", \"r\")) != NULL)\n    {\n      while (fgets (buf, sizeof (buf), fp) != NULL)\n        {\n          if (memcmp (buf, \"CPU:\", 4) == 0)\n            {\n              for (p = buf; *p != '\\0'; p++)\n                {\n                  end = 0;\n                  if (sscanf (p, \"(%lf-MHz%n\", &val, &end) == 1 && end != 0)\n                    {\n                      speed_cycletime = 1e-6 / val;\n                      if (speed_option_verbose)\n                        printf (\"Using /var/run/dmesg.boot CPU: %.2f MHz for cycle time %.3g\\n\", val, speed_cycletime);\n                      ret = 1;\n                      break;\n                    }\n                }\n            }\n        }\n      fclose (fp);\n    }\n  return ret;\n}",
      "lines": 35,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_irix_hinv": {
      "start_point": [
        606,
        0
      ],
      "end_point": [
        644,
        1
      ],
      "content": "static int\nfreq_irix_hinv (int help)\n{\n  int     ret = 0;\n#if HAVE_POPEN\n  FILE    *fp;\n  char    buf[128];\n  double  val;\n  int     nproc, end;\n\n  HELP (\"IRIX \\\"hinv -c processor\\\" output\");\n\n  /* Error messages are sent to /dev/null in case hinv doesn't exist.  The\n     brackets are necessary for some shells. */\n  if ((fp = popen (\"(hinv -c processor) 2>/dev/null\", \"r\")) != NULL)\n    {\n      while (fgets (buf, sizeof (buf), fp) != NULL)\n        {\n          end = 0;\n          if (sscanf (buf, \"Processor 0: %lf MHZ%n\", &val, &end) == 1\n              && end != 0)\n            {\n            found:\n              speed_cycletime = 1e-6 / val;\n              if (speed_option_verbose)\n                printf (\"Using hinv -c processor \\\"%.2f MHZ\\\" for cycle time %.3g\\n\", val, speed_cycletime);\n              ret = 1;\n              break;\n            }\n          end = 0;\n          if (sscanf (buf, \"%d %lf MHZ%n\", &nproc, &val, &end) == 2\n              && end != 0)\n            goto found;\n        }\n      pclose (fp);\n    }\n#endif\n  return ret;\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_processor_info": {
      "start_point": [
        653,
        0
      ],
      "end_point": [
        690,
        1
      ],
      "content": "static int\nfreq_processor_info (int help)\n{\n#if HAVE_PROCESSOR_INFO && HAVE_SYS_PROCESSOR_H\n  processor_info_t  p;\n  int  i, n, mhz = 0;\n\n  HELP (\"processor_info() pi_clock\");\n\n  n = sysconf (_SC_NPROCESSORS_CONF);\n  for (i = 0; i < n; i++)\n    {\n      if (processor_info (i, &p) != 0)\n        continue;\n      if (p.pi_state != P_ONLINE)\n        continue;\n\n      if (mhz != 0 && p.pi_clock != mhz)\n        {\n          fprintf (stderr,\n                   \"freq_processor_info(): There's more than one CPU and they have different clock speeds\\n\");\n          return 0;\n        }\n\n      mhz = p.pi_clock;\n    }\n\n  speed_cycletime = 1.0e-6 / (double) mhz;\n\n  if (speed_option_verbose)\n    printf (\"Using processor_info() %d mhz for cycle time %.3g\\n\",\n            mhz, speed_cycletime);\n  return 1;\n\n#else\n  return 0;\n#endif\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_measure_gettimeofday_one": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "static double\nfreq_measure_gettimeofday_one (void)\n{\n#define call_gettimeofday(t)   gettimeofday (&(t), NULL)\n#define timeval_tv_sec(t)      ((t).tv_sec)\n#define timeval_tv_usec(t)     ((t).tv_usec)\n  FREQ_MEASURE_ONE (\"gettimeofday\", struct timeval,\n                    call_gettimeofday, speed_cyclecounter,\n                    timeval_tv_sec, timeval_tv_usec);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "freq_measure_getrusage_one": {
      "start_point": [
        707,
        0
      ],
      "end_point": [
        716,
        1
      ],
      "content": "static double\nfreq_measure_getrusage_one (void)\n{\n#define call_getrusage(t)   getrusage (0, &(t))\n#define rusage_tv_sec(t)    ((t).ru_utime.tv_sec)\n#define rusage_tv_usec(t)   ((t).ru_utime.tv_usec)\n  FREQ_MEASURE_ONE (\"getrusage\", struct rusage,\n                    call_getrusage, speed_cyclecounter,\n                    rusage_tv_sec, rusage_tv_usec);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "freq_measure": {
      "start_point": [
        726,
        0
      ],
      "end_point": [
        751,
        1
      ],
      "content": "double\nfreq_measure (const char *name, double (*one) (void))\n{\n  double  t[MEASURE_MAX_ATTEMPTS];\n  int     i, j;\n\n  for (i = 0; i < numberof (t); i++)\n    {\n      t[i] = (*one) ();\n\n      qsort (t, i+1, sizeof(t[0]), (qsort_function_t) double_cmp_ptr);\n      if (speed_option_verbose >= 3)\n        for (j = 0; j <= i; j++)\n          printf (\"   t[%d] is %.6g\\n\", j, t[j]);\n\n      for (j = 0; j+MEASURE_MATCH-1 <= i; j++)\n        {\n          if (t[j+MEASURE_MATCH-1] <= t[j] * MEASURE_TOLERANCE)\n            {\n              /* use the average of the range found */\n                return (t[j+MEASURE_MATCH-1] + t[j]) / 2.0;\n            }\n        }\n    }\n  return -1.0;\n}",
      "lines": 26,
      "depth": 16,
      "decorators": [
        "double"
      ]
    },
    "freq_measure_getrusage": {
      "start_point": [
        753,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "static int\nfreq_measure_getrusage (int help)\n{\n#if HAVE_SPEED_CYCLECOUNTER && HAVE_GETRUSAGE\n  double  cycletime;\n\n  if (! getrusage_microseconds_p ())\n    return 0;\n  if (! cycles_works_p ())\n    return 0;\n\n  HELP (\"cycle counter measured with microsecond getrusage()\");\n\n  cycletime = freq_measure (\"getrusage\", freq_measure_getrusage_one);\n  if (cycletime == -1.0)\n    return 0;\n\n  speed_cycletime = cycletime;\n  if (speed_option_verbose)\n    printf (\"Using getrusage() measured cycle counter %.4g (%.2f MHz)\\n\",\n            speed_cycletime, 1e-6/speed_cycletime);\n  return 1;\n\n#else\n  return 0;\n#endif\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_measure_gettimeofday": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        806,
        1
      ],
      "content": "static int\nfreq_measure_gettimeofday (int help)\n{\n#if HAVE_SPEED_CYCLECOUNTER && HAVE_GETTIMEOFDAY\n  double  cycletime;\n\n  if (! gettimeofday_microseconds_p ())\n    return 0;\n  if (! cycles_works_p ())\n    return 0;\n\n  HELP (\"cycle counter measured with microsecond gettimeofday()\");\n\n  cycletime = freq_measure (\"gettimeofday\", freq_measure_gettimeofday_one);\n  if (cycletime == -1.0)\n    return 0;\n\n  speed_cycletime = cycletime;\n  if (speed_option_verbose)\n    printf (\"Using gettimeofday() measured cycle counter %.4g (%.2f MHz)\\n\",\n            speed_cycletime, 1e-6/speed_cycletime);\n  return 1;\n#else\n  return 0;\n#endif\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "freq_all": {
      "start_point": [
        817,
        0
      ],
      "end_point": [
        844,
        1
      ],
      "content": "static int\nfreq_all (int help)\n{\n  return\n    /* This should be first, so an environment variable can override\n       anything the system gives. */\n    freq_environment (help)\n\n    || freq_attr_get_invent (help)\n    || freq_getsysinfo (help)\n    || freq_pstat_getprocessor (help)\n    || freq_sysctl_hw_model (help)\n    || freq_sysctl_hw_cpufrequency (help)\n    || freq_sysctlbyname_i586_freq (help)\n    || freq_sysctlbyname_tsc_freq (help)\n\n    /* SCO openunix 8 puts a dummy pi_clock==16 in processor_info, so be\n       sure to check /etc/hw before that function. */\n    || freq_sco_etchw (help)\n\n    || freq_processor_info (help)\n    || freq_proc_cpuinfo (help)\n    || freq_bsd_dmesg (help)\n    || freq_irix_hinv (help)\n    || freq_sunos_sysinfo (help)\n    || freq_measure_getrusage (help)\n    || freq_measure_gettimeofday (help);\n}",
      "lines": 28,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "speed_cycletime_init": {
      "start_point": [
        847,
        0
      ],
      "end_point": [
        861,
        1
      ],
      "content": "void\nspeed_cycletime_init (void)\n{\n  static int  attempted = 0;\n\n  if (attempted)\n    return;\n  attempted = 1;\n\n  if (freq_all (0))\n    return;\n\n  if (speed_option_verbose)\n    printf (\"CPU frequency couldn't be determined\\n\");\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "speed_cycletime_fail": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        872,
        1
      ],
      "content": "void\nspeed_cycletime_fail (const char *str)\n{\n  fprintf (stderr, \"Measuring with: %s\\n\", speed_time_string);\n  fprintf (stderr, \"%s,\\n\", str);\n  fprintf (stderr, \"but none of the following are available,\\n\");\n  freq_all (1);\n  abort ();\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "speed_cycletime_need_cycles": {
      "start_point": [
        878,
        0
      ],
      "end_point": [
        885,
        1
      ],
      "content": "void\nspeed_cycletime_need_cycles (void)\n{\n  speed_time_init ();\n  if (speed_cycletime == 0.0)\n    speed_cycletime_fail\n      (\"Need to know CPU frequency to give times in cycles\");\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "speed_cycletime_need_seconds": {
      "start_point": [
        886,
        0
      ],
      "end_point": [
        893,
        1
      ],
      "content": "void\nspeed_cycletime_need_seconds (void)\n{\n  speed_time_init ();\n  if (speed_cycletime == 1.0)\n    speed_cycletime_fail\n      (\"Need to know CPU frequency to convert cycles to seconds\");\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tune/gcdextod.c": {},
  "gmp/gmp-6.1.2/tune/gcdextos.c": {},
  "gmp/gmp-6.1.2/tune/gcdext_double.c": {},
  "gmp/gmp-6.1.2/tune/gcdext_single.c": {},
  "gmp/gmp-6.1.2/tune/hgcd_appr_lehmer.c": {},
  "gmp/gmp-6.1.2/tune/hgcd_lehmer.c": {},
  "gmp/gmp-6.1.2/tune/hgcd_reduce_1.c": {},
  "gmp/gmp-6.1.2/tune/hgcd_reduce_2.c": {},
  "gmp/gmp-6.1.2/tune/jacbase1.c": {},
  "gmp/gmp-6.1.2/tune/jacbase2.c": {},
  "gmp/gmp-6.1.2/tune/jacbase3.c": {},
  "gmp/gmp-6.1.2/tune/jacbase4.c": {},
  "gmp/gmp-6.1.2/tune/modlinv.c": {
    "speed_binvert_limb_mul1": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "double\nspeed_binvert_limb_mul1 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MODLIMB_INVERT (binvert_limb_mul1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_binvert_limb_loop": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "double\nspeed_binvert_limb_loop (struct speed_params *s)\n{\n  SPEED_ROUTINE_MODLIMB_INVERT (binvert_limb_loop);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_binvert_limb_cond": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "double\nspeed_binvert_limb_cond (struct speed_params *s)\n{\n  SPEED_ROUTINE_MODLIMB_INVERT (binvert_limb_cond);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_binvert_limb_arith": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "double\nspeed_binvert_limb_arith (struct speed_params *s)\n{\n  SPEED_ROUTINE_MODLIMB_INVERT (binvert_limb_arith);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    }
  },
  "gmp/gmp-6.1.2/tune/mod_1_1-1.c": {},
  "gmp/gmp-6.1.2/tune/mod_1_1-2.c": {},
  "gmp/gmp-6.1.2/tune/mod_1_div.c": {},
  "gmp/gmp-6.1.2/tune/mod_1_inv.c": {},
  "gmp/gmp-6.1.2/tune/noop.c": {
    "noop": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\nnoop (void)\n{\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "noop_1": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "void\nnoop_1 (mp_limb_t n)\n{\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "noop_wxs": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\nnoop_wxs (mp_ptr wp, mp_srcptr xp, mp_size_t size)\n{\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "noop_wxys": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\nnoop_wxys (mp_ptr wp, mp_srcptr xp, mp_srcptr yp, mp_size_t size)\n{\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "mpn_cache_fill_dummy": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nmpn_cache_fill_dummy (mp_limb_t n)\n{\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tune/powm_mod.c": {},
  "gmp/gmp-6.1.2/tune/powm_redc.c": {},
  "gmp/gmp-6.1.2/tune/pre_divrem_1.c": {},
  "gmp/gmp-6.1.2/tune/set_strb.c": {},
  "gmp/gmp-6.1.2/tune/set_strp.c": {
    "mpn_pre_set_str": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\nmpn_pre_set_str (mp_ptr wp, unsigned char *str, size_t str_len, powers_t *powtab, mp_ptr tp)\n{\n  if (BELOW_THRESHOLD (str_len, set_str_dc_threshold))\n    mpn_bc_set_str (wp, str, str_len, powtab->base);\n  else\n    mpn_dc_set_str (wp, str, str_len, powtab, tp);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gmp/gmp-6.1.2/tune/set_strs.c": {},
  "gmp/gmp-6.1.2/tune/speed-ext.c": {
    "mean_calls": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "mp_limb_t\nmean_calls (mp_ptr wp, mp_srcptr xp, mp_srcptr yp, mp_size_t size)\n{\n  mp_limb_t  c, ret;\n\n  ASSERT (size >= 1);\n\n  c = mpn_add_n (wp, xp, yp, size);\n  ret = mpn_rshift (wp, wp, size, 1) >> (GMP_LIMB_BITS-1);\n  wp[size-1] |= (c << (GMP_LIMB_BITS-1));\n  return ret;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mean_open": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "mp_limb_t\nmean_open (mp_ptr wp, mp_srcptr xp, mp_srcptr yp, mp_size_t size)\n{\n  mp_limb_t  w, wprev, x, y, c, ret;\n  mp_size_t  i;\n\n  ASSERT (size >= 1);\n\n  x = xp[0];\n  y = yp[0];\n\n  wprev = x + y;\n  c = (wprev < x);\n  ret = (wprev & 1);\n\n#define RSHIFT(hi,lo)   (((lo) >> 1) | ((hi) << (GMP_LIMB_BITS-1)))\n\n  for (i = 1; i < size; i++)\n    {\n      x = xp[i];\n      y = yp[i];\n\n      w = x + c;\n      c = (w < x);\n      w += y;\n      c += (w < y);\n\n      wp[i-1] = RSHIFT (w, wprev);\n      wprev = w;\n    }\n\n  wp[i-1] = RSHIFT (c, wprev);\n\n  return ret;\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mean_open2": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "mp_limb_t\nmean_open2 (mp_ptr wp, mp_srcptr xp, mp_srcptr yp, mp_size_t size)\n{\n  mp_limb_t  w, x, y, xnext, ynext, c, ret;\n  mp_size_t  i;\n\n  ASSERT (size >= 1);\n\n  x = xp[0];\n  y = yp[0];\n\n  /* ret is the low bit of x+y, c is the carry out of that low bit add */\n  ret = (x ^ y) & 1;\n  c   = (x & y) & 1;\n\n  for (i = 0; i < size-1; i++)\n    {\n      xnext = xp[i+1];\n      ynext = yp[i+1];\n      x = RSHIFT (xnext, x);\n      y = RSHIFT (ynext, y);\n\n      w = x + c;\n      c = (w < x);\n      w += y;\n      c += (w < y);\n      wp[i] = w;\n\n      x = xnext;\n      y = ynext;\n    }\n\n  wp[i] = (x >> 1) + (y >> 1) + c;\n\n  return ret;\n}",
      "lines": 36,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "speed_mean_calls": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "double\nspeed_mean_calls (struct speed_params *s)\n{\n  SPEED_ROUTINE_MEAN (mean_calls);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mean_open": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "double\nspeed_mean_open (struct speed_params *s)\n{\n  SPEED_ROUTINE_MEAN (mean_open);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mean_open2": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "double\nspeed_mean_open2 (struct speed_params *s)\n{\n  SPEED_ROUTINE_MEAN (mean_open2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    }
  },
  "gmp/gmp-6.1.2/tune/speed.c": {
    "data_fill": {
      "start_point": [
        563,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "void\ndata_fill (mp_ptr ptr, mp_size_t size)\n{\n  switch (option_data) {\n  case DATA_RANDOM:\n    mpn_random (ptr, size);\n    break;\n  case DATA_RANDOM2:\n    mpn_random2 (ptr, size);\n    break;\n  case DATA_ZEROS:\n    MPN_ZERO (ptr, size);\n    break;\n  case DATA_AAS:\n    MPN_FILL (ptr, size, GMP_NUMB_0xAA);\n    break;\n  case DATA_FFS:\n    MPN_FILL (ptr, size, GMP_NUMB_MAX);\n    break;\n  case DATA_2FD:\n    MPN_FILL (ptr, size, GMP_NUMB_MAX);\n    ptr[0] -= 2;\n    break;\n  default:\n    abort();\n    /*NOTREACHED*/\n  }\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "run_one": {
      "start_point": [
        600,
        0
      ],
      "end_point": [
        773,
        1
      ],
      "content": "void\nrun_one (FILE *fp, struct speed_params *s, mp_size_t prev_size)\n{\n  const char  *first_open_fastest, *first_open_notfastest, *first_close;\n  int         i, fastest, want_data;\n  double      fastest_time;\n  TMP_DECL;\n\n  TMP_MARK;\n\n  /* allocate data, unless all routines are NODATA */\n  want_data = 0;\n  for (i = 0; i < num_choices; i++)\n    want_data |= ((choice[i].p->flag & FLAG_NODATA) == 0);\n\n  if (want_data)\n    {\n      SPEED_TMP_ALLOC_LIMBS (sp.xp, s->size, s->align_xp);\n      SPEED_TMP_ALLOC_LIMBS (sp.yp, s->size, s->align_yp);\n\n      data_fill (s->xp, s->size);\n      data_fill (s->yp, s->size);\n    }\n  else\n    {\n      sp.xp = NULL;\n      sp.yp = NULL;\n    }\n\n  if (prev_size == -1 && option_cmp == CMP_DIFFPREV)\n    {\n      first_open_fastest = \"(#\";\n      first_open_notfastest = \" (\";\n      first_close = \")\";\n    }\n  else\n    {\n      first_open_fastest = \"#\";\n      first_open_notfastest = \" \";\n      first_close = \"\";\n    }\n\n  fastest = -1;\n  fastest_time = -1.0;\n  for (i = 0; i < num_choices; i++)\n    {\n      s->r = choice[i].r;\n      choice[i].time = speed_measure (choice[i].p->fun, s);\n      choice[i].no_time = (choice[i].time == -1.0);\n      if (! choice[i].no_time)\n        choice[i].time *= choice[i].scale;\n\n      /* Apply the effect of CMP_DIFFPREV, but the new choice[i].prev_time\n         is before any differences.  */\n      {\n        double     t;\n        t = choice[i].time;\n        if (t != -1.0 && option_cmp == CMP_DIFFPREV && prev_size != -1)\n          {\n            if (choice[i].prev_time == -1.0)\n              choice[i].no_time = 1;\n            else\n              choice[i].time = choice[i].time - choice[i].prev_time;\n          }\n        choice[i].prev_time = t;\n      }\n\n      if (choice[i].no_time)\n        continue;\n\n      /* Look for the fastest after CMP_DIFFPREV has been applied, but\n         before CMP_RATIO or CMP_DIFFERENCE.  There's only a fastest shown\n         if there's more than one routine.  */\n      if (num_choices > 1 && (fastest == -1 || choice[i].time < fastest_time))\n        {\n          fastest = i;\n          fastest_time = choice[i].time;\n        }\n\n      if (option_cmp == CMP_DIFFPREV)\n        {\n          /* Conversion for UNIT_CYCLESPERLIMB differs in CMP_DIFFPREV. */\n          if (option_unit == UNIT_CYCLES)\n            choice[i].time /= speed_cycletime;\n          else if (option_unit == UNIT_CYCLESPERLIMB)\n            {\n              if (prev_size == -1)\n                choice[i].time /= speed_cycletime;\n              else\n                choice[i].time /=  (speed_cycletime\n                                    * (SIZE_TO_DIVISOR(s->size)\n                                       - SIZE_TO_DIVISOR(prev_size)));\n            }\n        }\n      else\n        {\n          if (option_unit == UNIT_CYCLES)\n            choice[i].time /= speed_cycletime;\n          else if (option_unit == UNIT_CYCLESPERLIMB)\n            choice[i].time /= (speed_cycletime * SIZE_TO_DIVISOR(s->size));\n\n          if (option_cmp == CMP_RATIO && i > 0)\n            {\n              /* A ratio isn't affected by the units chosen. */\n              if (choice[0].no_time || choice[0].time == 0.0)\n                choice[i].no_time = 1;\n              else\n                choice[i].time /= choice[0].time;\n            }\n          else if (option_cmp == CMP_DIFFERENCE && i > 0)\n            {\n              if (choice[0].no_time)\n                {\n                  choice[i].no_time = 1;\n                  continue;\n                }\n              choice[i].time -= choice[0].time;\n            }\n        }\n    }\n\n  if (option_gnuplot)\n    {\n      /* In CMP_DIFFPREV, don't print anything for the first size, start\n         with the second where an actual difference is available.\n\n         In CMP_RATIO, print the first column as 1.0.\n\n         The 9 decimals printed is much more than the expected precision of\n         the measurements actually. */\n\n      if (! (option_cmp == CMP_DIFFPREV && prev_size == -1))\n        {\n          fprintf (fp, \"%-6ld \", s->size);\n          for (i = 0; i < num_choices; i++)\n            fprintf (fp, \"  %.9e\",\n                     choice[i].no_time ? 0.0\n                     : (option_cmp == CMP_RATIO && i == 0) ? 1.0\n                     : choice[i].time);\n          fprintf (fp, \"\\n\");\n        }\n    }\n  else\n    {\n      fprintf (fp, \"%-6ld \", s->size);\n      for (i = 0; i < num_choices; i++)\n        {\n          char  buf[128];\n          int   decimals;\n\n          if (choice[i].no_time)\n            {\n              fprintf (fp, \" %*s\", COLUMN_WIDTH, \"n/a\");\n            }\n          else\n            {if (option_unit == UNIT_CYCLESPERLIMB\n                 || (option_cmp == CMP_RATIO && i > 0))\n                decimals = 4;\n              else if (option_unit == UNIT_CYCLES)\n                decimals = 2;\n              else\n                decimals = 9;\n\n              sprintf (buf, \"%s%.*f%s\",\n                       i == fastest ? first_open_fastest : first_open_notfastest,\n                       decimals, choice[i].time, first_close);\n              fprintf (fp, \" %*s\", COLUMN_WIDTH, buf);\n            }\n        }\n      fprintf (fp, \"\\n\");\n    }\n\n  TMP_FREE;\n}",
      "lines": 174,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "run_all": {
      "start_point": [
        775,
        0
      ],
      "end_point": [
        824,
        1
      ],
      "content": "void\nrun_all (FILE *fp)\n{\n  mp_size_t  prev_size;\n  int        i;\n  TMP_DECL;\n\n  TMP_MARK;\n  SPEED_TMP_ALLOC_LIMBS (sp.xp_block, SPEED_BLOCK_SIZE, sp.align_xp);\n  SPEED_TMP_ALLOC_LIMBS (sp.yp_block, SPEED_BLOCK_SIZE, sp.align_yp);\n\n  data_fill (sp.xp_block, SPEED_BLOCK_SIZE);\n  data_fill (sp.yp_block, SPEED_BLOCK_SIZE);\n\n  for (i = 0; i < size_num; i++)\n    {\n      sp.size = size_array[i].start;\n      prev_size = -1;\n      for (;;)\n        {\n          mp_size_t  step;\n\n          if (option_data == DATA_2FD && sp.size >= 2)\n            sp.xp[sp.size-1] = 2;\n\n          run_one (fp, &sp, prev_size);\n          prev_size = sp.size;\n\n          if (option_data == DATA_2FD && sp.size >= 2)\n            sp.xp[sp.size-1] = MP_LIMB_T_MAX;\n\n          if (option_factor != 0.0)\n            {\n              step = (mp_size_t) (sp.size * option_factor - sp.size);\n              if (step < 1)\n                step = 1;\n            }\n          else\n            step = 1;\n          if (step < option_step)\n            step = option_step;\n\n          sp.size += step;\n          if (sp.size > size_array[i].end)\n            break;\n        }\n    }\n\n  TMP_FREE;\n}",
      "lines": 50,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "fopen_for_write": {
      "start_point": [
        827,
        0
      ],
      "end_point": [
        837,
        1
      ],
      "content": "FILE *\nfopen_for_write (const char *filename)\n{\n  FILE  *fp;\n  if ((fp = fopen (filename, \"w\")) == NULL)\n    {\n      fprintf (stderr, \"Cannot create %s\\n\", filename);\n      exit(1);\n    }\n  return fp;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "FILE",
        "*\nfopen_for_write (const char *filename)",
        "*"
      ]
    },
    "fclose_written": {
      "start_point": [
        839,
        0
      ],
      "end_point": [
        852,
        1
      ],
      "content": "void\nfclose_written (FILE *fp, const char *filename)\n{\n  int  err;\n\n  err = ferror (fp);\n  err |= fclose (fp);\n\n  if (err)\n    {\n      fprintf (stderr, \"Error writing %s\\n\", filename);\n      exit(1);\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "run_gnuplot": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        911,
        1
      ],
      "content": "void\nrun_gnuplot (int argc, char *argv[])\n{\n  char  *plot_filename;\n  char  *data_filename;\n  FILE  *fp;\n  int   i;\n\n  plot_filename = (char *) (*__gmp_allocate_func)\n    (strlen (option_gnuplot_basename) + 20);\n  data_filename = (char *) (*__gmp_allocate_func)\n    (strlen (option_gnuplot_basename) + 20);\n\n  sprintf (plot_filename, \"%s.gnuplot\", option_gnuplot_basename);\n  sprintf (data_filename, \"%s.data\",    option_gnuplot_basename);\n\n  fp = fopen_for_write (plot_filename);\n\n  fprintf (fp, \"# Generated with:\\n\");\n  fprintf (fp, \"#\");\n  for (i = 0; i < argc; i++)\n    fprintf (fp, \" %s\", argv[i]);\n  fprintf (fp, \"\\n\");\n  fprintf (fp, \"\\n\");\n\n  fprintf (fp, \"reset\\n\");\n\n  /* Putting the key at the top left is usually good, and you can change it\n     interactively if it's not. */\n  fprintf (fp, \"set key left\\n\");\n\n  /* designed to make it possible to see crossovers easily */\n  fprintf (fp, \"set style data lines\\n\");\n\n  fprintf (fp, \"plot \");\n  for (i = 0; i < num_choices; i++)\n    {\n      fprintf (fp, \" \\\"%s\\\" using 1:%d\", data_filename, i+2);\n      fprintf (fp, \" title \\\"%s\\\"\", choice[i].name);\n\n      if (i != num_choices-1)\n        fprintf (fp, \", \\\\\");\n      fprintf (fp, \"\\n\");\n    }\n\n  fprintf (fp, \"load \\\"-\\\"\\n\");\n  fclose_written (fp, plot_filename);\n\n  fp = fopen_for_write (data_filename);\n\n  /* Unbuffered so you can see where the program was up to if it crashes or\n     you kill it. */\n  setbuf (fp, NULL);\n\n  run_all (fp);\n  fclose_written (fp, data_filename);\n}",
      "lines": 57,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "r_string": {
      "start_point": [
        921,
        0
      ],
      "end_point": [
        983,
        1
      ],
      "content": "mp_limb_t\nr_string (const char *s)\n{\n  const char  *s_orig = s;\n  long        n;\n\n  if (strcmp (s, \"aas\") == 0)\n    return GMP_NUMB_0xAA;\n\n  {\n    mpz_t      z;\n    mp_limb_t  l;\n    int        set, siz;\n\n    mpz_init (z);\n    set = mpz_set_str (z, s, 0);\n    siz = SIZ(z);\n    l = (siz == 0 ? 0 : siz > 0 ? PTR(z)[0] : -PTR(z)[0]);\n    mpz_clear (z);\n    if (set == 0)\n      {\n        if (siz > 1 || siz < -1)\n          printf (\"Warning, r parameter %s truncated to %d bits\\n\",\n                  s_orig, GMP_LIMB_BITS);\n        return l;\n      }\n  }\n\n  if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))\n    n = strtoul (s+2, (char **) &s, 16);\n  else\n    n = strtol (s, (char **) &s, 10);\n\n  if (strcmp (s, \"bits\") == 0)\n    {\n      mp_limb_t  l;\n      if (n > GMP_LIMB_BITS)\n        {\n          fprintf (stderr, \"%ld bit parameter invalid (max %d bits)\\n\",\n                   n, GMP_LIMB_BITS);\n          exit (1);\n        }\n      mpn_random (&l, 1);\n      return (l | (CNST_LIMB(1) << (n-1))) & LIMB_ONES(n);\n    }\n  else  if (strcmp (s, \"ones\") == 0)\n    {\n      if (n > GMP_LIMB_BITS)\n        {\n          fprintf (stderr, \"%ld bit parameter invalid (max %d bits)\\n\",\n                   n, GMP_LIMB_BITS);\n          exit (1);\n        }\n      return LIMB_ONES (n);\n    }\n  else if (*s != '\\0')\n    {\n      fprintf (stderr, \"invalid r parameter: %s\\n\", s_orig);\n      exit (1);\n    }\n\n  return n;\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "routine_find": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1049,
        1
      ],
      "content": "void\nroutine_find (struct choice_t *c, const char *s_orig)\n{\n  const char  *s;\n  int     i;\n  size_t  nlen;\n\n  c->name = s_orig;\n  s = strchr (s_orig, '*');\n  if (s != NULL)\n    {\n      c->scale = atof(s_orig);\n      s++;\n    }\n  else\n    {\n      c->scale = 1.0;\n      s = s_orig;\n    }\n\n  for (i = 0; i < numberof (routine); i++)\n    {\n      nlen = strlen (routine[i].name);\n      if (memcmp (s, routine[i].name, nlen) != 0)\n        continue;\n\n      if (s[nlen] == '.')\n        {\n          /* match, with a .r parameter */\n\n          if (! (routine[i].flag & (FLAG_R|FLAG_R_OPTIONAL)))\n            {\n              fprintf (stderr,\n                       \"Choice %s bad: doesn't take a \\\".<r>\\\" parameter\\n\",\n                       s_orig);\n              exit (1);\n            }\n\n          c->p = &routine[i];\n          c->r = r_string (s + nlen + 1);\n          return;\n        }\n\n      if (s[nlen] == '\\0')\n        {\n          /* match, with no parameter */\n\n          if (routine[i].flag & FLAG_R)\n            {\n              fprintf (stderr,\n                       \"Choice %s bad: needs a \\\".<r>\\\" parameter\\n\",\n                       s_orig);\n              exit (1);\n            }\n\n          c->p = &routine[i];\n          c->r = 0;\n          return;\n        }\n    }\n\n  fprintf (stderr, \"Choice %s unrecognised\\n\", s_orig);\n  exit (1);\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "usage": {
      "start_point": [
        1052,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "void\nusage (void)\n{\n  int  i;\n\n  speed_time_init ();\n\n  printf (\"Usage: speed [-options] -s size <routine>...\\n\");\n  printf (\"Measure the speed of some routines.\\n\");\n  printf (\"Times are in seconds, accuracy is shown.\\n\");\n  printf (\"\\n\");\n  printf (\"   -p num     set precision as number of time units each routine must run\\n\");\n  printf (\"   -s size[-end][,size[-end]]...   sizes to measure\\n\");\n  printf (\"              single sizes or ranges, sep with comma or use multiple -s\\n\");\n  printf (\"   -t step    step through sizes by given amount\\n\");\n  printf (\"   -f factor  step through sizes by given factor (eg. 1.05)\\n\");\n  printf (\"   -r         show times as ratios of the first routine\\n\");\n  printf (\"   -d         show times as difference from the first routine\\n\");\n  printf (\"   -D         show times as difference from previous size shown\\n\");\n  printf (\"   -c         show times in CPU cycles\\n\");\n  printf (\"   -C         show times in cycles per limb\\n\");\n  printf (\"   -u         print resource usage (memory) at end\\n\");\n  printf (\"   -P name    output plot files \\\"name.gnuplot\\\" and \\\"name.data\\\"\\n\");\n  printf (\"   -a <type>  use given data: random(default), random2, zeros, aas, ffs, 2fd\\n\");\n  printf (\"   -x, -y, -w, -W <align>  specify data alignments, sources and dests\\n\");\n  printf (\"   -o addrs   print addresses of data blocks\\n\");\n  printf (\"\\n\");\n  printf (\"If both -t and -f are used, it means step by the factor or the step, whichever\\n\");\n  printf (\"is greater.\\n\");\n  printf (\"If both -C and -D are used, it means cycles per however many limbs between a\\n\");\n  printf (\"size and the previous size.\\n\");\n  printf (\"\\n\");\n  printf (\"After running with -P, plots can be viewed with Gnuplot or Quickplot.\\n\");\n  printf (\"\\\"gnuplot name.gnuplot\\\" (use \\\"set logscale xy; replot\\\" at the prompt for\\n\");\n  printf (\"a log/log plot).\\n\");\n  printf (\"\\\"quickplot -s name.data\\\" (has interactive zooming, and note -s is important\\n\");\n  printf (\"when viewing more than one routine, it means same axis scales for all data).\\n\");\n  printf (\"\\n\");\n  printf (\"The available routines are as follows.\\n\");\n  printf (\"\\n\");\n\n  for (i = 0; i < numberof (routine); i++)\n    {\n      if (routine[i].flag & FLAG_R)\n        printf (\"\\t%s.r\\n\", routine[i].name);\n      else if (routine[i].flag & FLAG_R_OPTIONAL)\n        printf (\"\\t%s (optional .r)\\n\", routine[i].name);\n      else\n        printf (\"\\t%s\\n\", routine[i].name);\n    }\n  printf (\"\\n\");\n  printf (\"Routines with a \\\".r\\\" need an extra parameter, for example mpn_lshift.6\\n\");\n  printf (\"r should be in decimal, or use 0xN for hexadecimal.\\n\");\n  printf (\"\\n\");\n  printf (\"Special forms for r are \\\"<N>bits\\\" for a random N bit number, \\\"<N>ones\\\" for\\n\");\n  printf (\"N one bits, or \\\"aas\\\" for 0xAA..AA.\\n\");\n  printf (\"\\n\");\n  printf (\"Times for sizes out of the range accepted by a routine are shown as 0.\\n\");\n  printf (\"The fastest routine at each size is marked with a # (free form output only).\\n\");\n  printf (\"\\n\");\n  printf (\"%s\", speed_time_string);\n  printf (\"\\n\");\n  printf (\"Gnuplot home page http://www.gnuplot.info/\\n\");\n  printf (\"Quickplot home page http://quickplot.sourceforge.net/\\n\");\n}",
      "lines": 65,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_align_option": {
      "start_point": [
        1118,
        0
      ],
      "end_point": [
        1129,
        1
      ],
      "content": "void\ncheck_align_option (const char *name, mp_size_t align)\n{\n  if (align < 0 || align > SPEED_TMP_ALLOC_ADJUST_MASK)\n    {\n      fprintf (stderr, \"Alignment request out of range: %s %ld\\n\",\n               name, (long) align);\n      fprintf (stderr, \"  should be 0 to %d (limbs), inclusive\\n\",\n               SPEED_TMP_ALLOC_ADJUST_MASK);\n      exit (1);\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        1131,
        0
      ],
      "end_point": [
        1384,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int  i;\n  int  opt;\n\n  /* Unbuffered so output goes straight out when directed to a pipe or file\n     and isn't lost on killing the program half way.  */\n  setbuf (stdout, NULL);\n\n  for (;;)\n    {\n      opt = getopt(argc, argv, \"a:CcDdEFf:o:p:P:rRs:t:ux:y:w:W:z\");\n      if (opt == EOF)\n        break;\n\n      switch (opt) {\n      case 'a':\n        if (strcmp (optarg, \"random\") == 0)       option_data = DATA_RANDOM;\n        else if (strcmp (optarg, \"random2\") == 0) option_data = DATA_RANDOM2;\n        else if (strcmp (optarg, \"zeros\") == 0)   option_data = DATA_ZEROS;\n        else if (strcmp (optarg, \"aas\") == 0)     option_data = DATA_AAS;\n        else if (strcmp (optarg, \"ffs\") == 0)     option_data = DATA_FFS;\n        else if (strcmp (optarg, \"2fd\") == 0)     option_data = DATA_2FD;\n        else\n          {\n            fprintf (stderr, \"unrecognised data option: %s\\n\", optarg);\n            exit (1);\n          }\n        break;\n      case 'C':\n        if (option_unit  != UNIT_SECONDS) goto bad_unit;\n        option_unit = UNIT_CYCLESPERLIMB;\n        break;\n      case 'c':\n        if (option_unit != UNIT_SECONDS)\n          {\n          bad_unit:\n            fprintf (stderr, \"cannot use more than one of -c, -C\\n\");\n            exit (1);\n          }\n        option_unit = UNIT_CYCLES;\n        break;\n      case 'D':\n        if (option_cmp != CMP_ABSOLUTE) goto bad_cmp;\n        option_cmp = CMP_DIFFPREV;\n        break;\n      case 'd':\n        if (option_cmp != CMP_ABSOLUTE)\n          {\n          bad_cmp:\n            fprintf (stderr, \"cannot use more than one of -d, -D, -r\\n\");\n            exit (1);\n          }\n        option_cmp = CMP_DIFFERENCE;\n        break;\n      case 'E':\n        option_square = 1;\n        break;\n      case 'F':\n        option_square = 2;\n        break;\n      case 'f':\n        option_factor = atof (optarg);\n        if (option_factor <= 1.0)\n          {\n            fprintf (stderr, \"-f factor must be > 1.0\\n\");\n            exit (1);\n          }\n        break;\n      case 'o':\n        speed_option_set (optarg);\n        break;\n      case 'P':\n        option_gnuplot = 1;\n        option_gnuplot_basename = optarg;\n        break;\n      case 'p':\n        speed_precision = atoi (optarg);\n        break;\n      case 'R':\n        option_seed = time (NULL);\n        break;\n      case 'r':\n        if (option_cmp != CMP_ABSOLUTE)\n          goto bad_cmp;\n        option_cmp = CMP_RATIO;\n        break;\n      case 's':\n        {\n          char  *s;\n          for (s = strtok (optarg, \",\"); s != NULL; s = strtok (NULL, \",\"))\n            {\n              if (size_num == size_allocnum)\n                {\n                  size_array = (struct size_array_t *)\n                    __gmp_allocate_or_reallocate\n                    (size_array,\n                     size_allocnum * sizeof(size_array[0]),\n                     (size_allocnum+10) * sizeof(size_array[0]));\n                  size_allocnum += 10;\n                }\n              if (sscanf (s, \"%ld-%ld\",\n                          &size_array[size_num].start,\n                          &size_array[size_num].end) != 2)\n                {\n                  size_array[size_num].start = size_array[size_num].end\n                    = atol (s);\n                }\n\n              if (size_array[size_num].start < 0\n                  || size_array[size_num].end < 0\n                  || size_array[size_num].start > size_array[size_num].end)\n                {\n                  fprintf (stderr, \"invalid size parameter: %s\\n\", s);\n                  exit (1);\n                }\n\n              size_num++;\n            }\n        }\n        break;\n      case 't':\n        option_step = atol (optarg);\n        if (option_step < 1)\n          {\n            fprintf (stderr, \"-t step must be >= 1\\n\");\n            exit (1);\n          }\n        break;\n      case 'u':\n        option_resource_usage = 1;\n        break;\n      case 'z':\n        sp.cache = 1;\n        break;\n      case 'x':\n        sp.align_xp = atol (optarg);\n        check_align_option (\"-x\", sp.align_xp);\n        break;\n      case 'y':\n        sp.align_yp = atol (optarg);\n        check_align_option (\"-y\", sp.align_yp);\n        break;\n      case 'w':\n        sp.align_wp = atol (optarg);\n        check_align_option (\"-w\", sp.align_wp);\n        break;\n      case 'W':\n        sp.align_wp2 = atol (optarg);\n        check_align_option (\"-W\", sp.align_wp2);\n        break;\n      case '?':\n        exit(1);\n      }\n    }\n\n  if (optind >= argc)\n    {\n      usage ();\n      exit (1);\n    }\n\n  if (size_num == 0)\n    {\n      fprintf (stderr, \"-s <size> must be specified\\n\");\n      exit (1);\n    }\n\n  gmp_randinit_default (__gmp_rands);\n  __gmp_rands_initialized = 1;\n  gmp_randseed_ui (__gmp_rands, option_seed);\n\n  choice = (struct choice_t *) (*__gmp_allocate_func)\n    ((argc - optind) * sizeof(choice[0]));\n  for ( ; optind < argc; optind++)\n    {\n      struct choice_t  c;\n      routine_find (&c, argv[optind]);\n      choice[num_choices] = c;\n      num_choices++;\n    }\n\n  if ((option_cmp == CMP_RATIO || option_cmp == CMP_DIFFERENCE) &&\n      num_choices < 2)\n    {\n      fprintf (stderr, \"WARNING, -d or -r does nothing when only one routine requested\\n\");\n    }\n\n  speed_time_init ();\n  if (option_unit == UNIT_CYCLES || option_unit == UNIT_CYCLESPERLIMB)\n    speed_cycletime_need_cycles ();\n  else\n    speed_cycletime_need_seconds ();\n\n  if (option_gnuplot)\n    {\n      run_gnuplot (argc, argv);\n    }\n  else\n    {\n      if (option_unit == UNIT_SECONDS)\n        printf (\"overhead %.9f secs\", speed_measure (speed_noop, NULL));\n      else\n        printf (\"overhead %.2f cycles\",\n                speed_measure (speed_noop, NULL) / speed_cycletime);\n      printf (\", precision %d units of %.2e secs\",\n              speed_precision, speed_unittime);\n\n      if (speed_cycletime == 1.0 || speed_cycletime == 0.0)\n        printf (\", CPU freq unknown\\n\");\n      else\n        printf (\", CPU freq %.2f MHz\\n\", 1e-6/speed_cycletime);\n\n      printf (\"       \");\n      for (i = 0; i < num_choices; i++)\n        printf (\" %*s\", COLUMN_WIDTH, choice[i].name);\n      printf (\"\\n\");\n\n      run_all (stdout);\n    }\n\n  if (option_resource_usage)\n    {\n#if HAVE_GETRUSAGE\n      {\n        /* This doesn't give data sizes on linux 2.0.x, only utime. */\n        struct rusage  r;\n        if (getrusage (RUSAGE_SELF, &r) != 0)\n          perror (\"getrusage\");\n        else\n          printf (\"getrusage(): utime %ld.%06ld data %ld stack %ld maxresident %ld\\n\",\n                  r.ru_utime.tv_sec, r.ru_utime.tv_usec,\n                  r.ru_idrss, r.ru_isrss, r.ru_ixrss);\n      }\n#else\n      printf (\"getrusage() not available\\n\");\n#endif\n\n      /* Linux kernel. */\n      {\n        char  buf[128];\n        sprintf (buf, \"/proc/%d/status\", getpid());\n        if (access (buf, R_OK) == 0)\n          {\n            sprintf (buf, \"cat /proc/%d/status\", getpid());\n            system (buf);\n          }\n\n      }\n    }\n\n  return 0;\n}",
      "lines": 254,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tune/speed.h": {},
  "gmp/gmp-6.1.2/tune/time.c": {
    "unittime_string": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "char *\nunittime_string (double t)\n{\n  static char  buf[128];\n\n  const char  *unit;\n  int         prec;\n\n  /* choose units and scale */\n  if (t < 1e-6)\n    t *= 1e9, unit = \"ns\";\n  else if (t < 1e-3)\n    t *= 1e6, unit = \"us\";\n  else if (t < 1.0)\n    t *= 1e3, unit = \"ms\";\n  else\n    unit = \"s\";\n\n  /* want 4 significant figures */\n  if (t < 1.0)\n    prec = 4;\n  else if (t < 10.0)\n    prec = 3;\n  else if (t < 100.0)\n    prec = 2;\n  else\n    prec = 1;\n\n  sprintf (buf, \"%.*f%s\", prec, t, unit);\n  return buf;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "char",
        "*\nunittime_string (double t)",
        "*"
      ]
    },
    "cycles_works_handler": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "static RETSIGTYPE\ncycles_works_handler (int sig)\n{\n  longjmp (cycles_works_buf, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "RETSIGTYPE"
      ]
    },
    "cycles_works_p": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        518,
        1
      ],
      "content": "int\ncycles_works_p (void)\n{\n  static int  result = -1;\n\n  if (result != -1)\n    goto done;\n\n  /* FIXME: On linux, the cycle counter is not saved and restored over\n   * context switches, making it almost useless for precise cputime\n   * measurements. When available, it's better to use clock_gettime,\n   * which seems to have reasonable accuracy (tested on x86_32,\n   * linux-2.6.26, glibc-2.7). However, there are also some linux\n   * systems where clock_gettime is broken in one way or the other,\n   * like CLOCK_PROCESS_CPUTIME_ID not implemented (easy case) or\n   * kind-of implemented but broken (needs code to detect that), and\n   * on those systems a wall-clock cycle counter is the least bad\n   * fallback.\n   *\n   * So we need some code to disable the cycle counter on some but not\n   * all linux systems. */\n#ifdef SIGILL\n  {\n    RETSIGTYPE (*old_handler) (int);\n    unsigned  cycles[2];\n\n    old_handler = signal (SIGILL, cycles_works_handler);\n    if (old_handler == SIG_ERR)\n      {\n\tif (speed_option_verbose)\n\t  printf (\"cycles_works_p(): SIGILL not supported, assuming speed_cyclecounter() works\\n\");\n\tgoto yes;\n      }\n    if (setjmp (cycles_works_buf))\n      {\n\tif (speed_option_verbose)\n\t  printf (\"cycles_works_p(): SIGILL during speed_cyclecounter(), so doesn't work\\n\");\n\tresult = 0;\n\tgoto done;\n      }\n    speed_cyclecounter (cycles);\n    signal (SIGILL, old_handler);\n    if (speed_option_verbose)\n      printf (\"cycles_works_p(): speed_cyclecounter() works\\n\");\n  }\n#else\n\n  if (speed_option_verbose)\n    printf (\"cycles_works_p(): SIGILL not defined, assuming speed_cyclecounter() works\\n\");\n  goto yes;\n#endif\n\n yes:\n  result = 1;\n\n done:\n  return result;\n}",
      "lines": 58,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "clk_tck": {
      "start_point": [
        523,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "long\nclk_tck (void)\n{\n  static long  result = -1L;\n  if (result != -1L)\n    return result;\n\n#if HAVE_SYSCONF\n  result = sysconf (_SC_CLK_TCK);\n  if (result != -1L)\n    {\n      if (speed_option_verbose)\n\tprintf (\"sysconf(_SC_CLK_TCK) is %ld per second\\n\", result);\n      return result;\n    }\n\n  fprintf (stderr,\n\t   \"sysconf(_SC_CLK_TCK) not working, using CLK_TCK instead\\n\");\n#endif\n\n#ifdef CLK_TCK\n  result = CLK_TCK;\n  if (speed_option_verbose)\n    printf (\"CLK_TCK is %ld per second\\n\", result);\n  return result;\n#else\n  fprintf (stderr, \"CLK_TCK not defined, cannot continue\\n\");\n  abort ();\n#endif\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "long",
        "long"
      ]
    },
    "gettimeofday_microseconds_p": {
      "start_point": [
        637,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "int\ngettimeofday_microseconds_p (void)\n{\n#define call_gettimeofday(t)   gettimeofday (&(t), NULL)\n#define timeval_tv_sec(t)      ((t).tv_sec)\n#define timeval_tv_usec(t)     ((t).tv_usec)\n  MICROSECONDS_P (\"gettimeofday\", struct_timeval,\n\t\t  call_gettimeofday, timeval_tv_sec, timeval_tv_usec);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getrusage_microseconds_p": {
      "start_point": [
        647,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "int\ngetrusage_microseconds_p (void)\n{\n#define call_getrusage(t)   getrusage (0, &(t))\n#define rusage_tv_sec(t)    ((t).ru_utime.tv_sec)\n#define rusage_tv_usec(t)   ((t).ru_utime.tv_usec)\n  MICROSECONDS_P (\"getrusage\", struct_rusage,\n\t\t  call_getrusage, rusage_tv_sec, rusage_tv_usec);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getrusage_backwards_p": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        713,
        1
      ],
      "content": "int\ngetrusage_backwards_p (void)\n{\n  static int result = -1;\n  struct rusage  start, prev, next;\n  long  d;\n  int   i;\n\n  if (result != -1)\n    return result;\n\n  getrusage (0, &start);\n  memcpy (&next, &start, sizeof (next));\n\n  result = 0;\n  i = 0;\n  for (;;)\n    {\n      memcpy (&prev, &next, sizeof (prev));\n      getrusage (0, &next);\n\n      if (next.ru_utime.tv_sec < prev.ru_utime.tv_sec\n\t  || (next.ru_utime.tv_sec == prev.ru_utime.tv_sec\n\t      && next.ru_utime.tv_usec < prev.ru_utime.tv_usec))\n\t{\n\t  if (speed_option_verbose)\n\t    printf (\"getrusage went backwards (attempt %d: %ld.%06ld -> %ld.%06ld)\\n\",\n\t\t    i,\n\t\t    (long) prev.ru_utime.tv_sec, (long) prev.ru_utime.tv_usec,\n\t\t    (long) next.ru_utime.tv_sec, (long) next.ru_utime.tv_usec);\n\t  result = 1;\n\t  break;\n\t}\n\n      /* minimum 1000 attempts, then stop after either 0.1 seconds or 50000\n\t attempts, whichever comes first */\n      d = 1000000 * (next.ru_utime.tv_sec - start.ru_utime.tv_sec)\n\t+ (next.ru_utime.tv_usec - start.ru_utime.tv_usec);\n      i++;\n      if (i > 50000 || (i > 1000 && d > 100000))\n\tbreak;\n    }\n\n  return result;\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "cgt_works_p": {
      "start_point": [
        737,
        0
      ],
      "end_point": [
        818,
        1
      ],
      "content": "int\ncgt_works_p (void)\n{\n  static int  result = -1;\n  struct_timespec  unit;\n\n  if (! have_cgt)\n    return 0;\n\n  if (! have_cgt_id)\n    {\n      if (speed_option_verbose)\n\tprintf (\"clock_gettime don't know what ID to use\\n\");\n      result = 0;\n      return result;\n    }\n\n  if (result != -1)\n    return result;\n\n  /* trial run to see if it works */\n  if (clock_gettime (CGT_ID, &unit) != 0)\n    {\n      if (speed_option_verbose)\n\tprintf (\"clock_gettime id=%d error: %s\\n\", CGT_ID, strerror (errno));\n      result = 0;\n      return result;\n    }\n\n  /* get the resolution */\n  if (clock_getres (CGT_ID, &unit) != 0)\n    {\n      if (speed_option_verbose)\n\tprintf (\"clock_getres id=%d error: %s\\n\", CGT_ID, strerror (errno));\n      result = 0;\n      return result;\n    }\n\n  cgt_unittime = unit.tv_sec + unit.tv_nsec * 1e-9;\n  if (speed_option_verbose)\n    printf (\"clock_gettime is %s accurate\\n\", unittime_string (cgt_unittime));\n\n  if (cgt_unittime < 10e-9)\n    {\n      /* Do we believe this? */\n      struct timespec start, end;\n      static volatile int counter;\n      double duration;\n      if (clock_gettime (CGT_ID, &start))\n\t{\n\t  if (speed_option_verbose)\n\t    printf (\"clock_gettime id=%d error: %s\\n\", CGT_ID, strerror (errno));\n\t  result = 0;\n\t  return result;\n\t}\n      /* Loop of at least 1000 memory accesses, ought to take at\n\t least 100 ns*/\n      for (counter = 0; counter < CGT_DELAY_COUNT; counter++)\n\t;\n      if (clock_gettime (CGT_ID, &end))\n\t{\n\t  if (speed_option_verbose)\n\t    printf (\"clock_gettime id=%d error: %s\\n\", CGT_ID, strerror (errno));\n\t  result = 0;\n\t  return result;\n\t}\n      duration = (end.tv_sec + end.tv_nsec * 1e-9\n\t\t  - start.tv_sec - start.tv_nsec * 1e-9);\n      if (speed_option_verbose)\n\tprintf (\"delay loop of %d rounds took %s (according to clock_gettime)\\n\",\n\t\tCGT_DELAY_COUNT, unittime_string (duration));\n      if (duration < 100e-9)\n\t{\n\t  if (speed_option_verbose)\n\t    printf (\"clock_gettime id=%d not believable\\n\", CGT_ID);\n\t  result = 0;\n\t  return result;\n\t}\n    }\n  result = 1;\n  return result;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "freq_measure_mftb_one": {
      "start_point": [
        821,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "static double\nfreq_measure_mftb_one (void)\n{\n#define call_gettimeofday(t)   gettimeofday (&(t), NULL)\n#define timeval_tv_sec(t)      ((t).tv_sec)\n#define timeval_tv_usec(t)     ((t).tv_usec)\n  FREQ_MEASURE_ONE (\"mftb\", struct_timeval,\n\t\t    call_gettimeofday, MFTB,\n\t\t    timeval_tv_sec, timeval_tv_usec);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "mftb_works_handler": {
      "start_point": [
        835,
        0
      ],
      "end_point": [
        839,
        1
      ],
      "content": "static RETSIGTYPE\nmftb_works_handler (int sig)\n{\n  longjmp (mftb_works_buf, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "RETSIGTYPE"
      ]
    },
    "mftb_works_p": {
      "start_point": [
        841,
        0
      ],
      "end_point": [
        896,
        1
      ],
      "content": "int\nmftb_works_p (void)\n{\n  unsigned   a[2];\n  RETSIGTYPE (*old_handler) (int);\n  double     cycletime;\n\n  /* suppress a warning about a[] unused */\n  a[0] = 0;\n\n  if (! have_mftb)\n    return 0;\n\n#ifdef SIGILL\n  old_handler = signal (SIGILL, mftb_works_handler);\n  if (old_handler == SIG_ERR)\n    {\n      if (speed_option_verbose)\n\tprintf (\"mftb_works_p(): SIGILL not supported, assuming mftb works\\n\");\n      return 1;\n    }\n  if (setjmp (mftb_works_buf))\n    {\n      if (speed_option_verbose)\n\tprintf (\"mftb_works_p(): SIGILL during mftb, so doesn't work\\n\");\n      return 0;\n    }\n  MFTB (a);\n  signal (SIGILL, old_handler);\n  if (speed_option_verbose)\n    printf (\"mftb_works_p(): mftb works\\n\");\n#else\n\n  if (speed_option_verbose)\n    printf (\"mftb_works_p(): SIGILL not defined, assuming mftb works\\n\");\n#endif\n\n#if ! HAVE_GETTIMEOFDAY\n  if (speed_option_verbose)\n    printf (\"mftb_works_p(): no gettimeofday available to measure mftb\\n\");\n  return 0;\n#endif\n\n  /* The time base is normally 1/4 of the bus speed on 6xx and 7xx chips, on\n     other chips it can be driven from an external clock. */\n  cycletime = freq_measure (\"mftb\", freq_measure_mftb_one);\n  if (cycletime == -1.0)\n    {\n      if (speed_option_verbose)\n\tprintf (\"mftb_works_p(): cannot measure mftb period\\n\");\n      return 0;\n    }\n\n  mftb_unittime = cycletime;\n  return 1;\n}",
      "lines": 56,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "sgi_works_p": {
      "start_point": [
        901,
        0
      ],
      "end_point": [
        986,
        1
      ],
      "content": "int\nsgi_works_p (void)\n{\n#if HAVE_SYSSGI && HAVE_MMAP\n  static int  result = -1;\n\n  size_t          pagesize, offset;\n  __psunsigned_t  phys, physpage;\n  void            *virtpage;\n  unsigned        period_picoseconds;\n  int             size, fd;\n\n  if (result != -1)\n    return result;\n\n  phys = syssgi (SGI_QUERY_CYCLECNTR, &period_picoseconds);\n  if (phys == (__psunsigned_t) -1)\n    {\n      /* ENODEV is the error when a counter is not available */\n      if (speed_option_verbose)\n\tprintf (\"syssgi SGI_QUERY_CYCLECNTR error: %s\\n\", strerror (errno));\n      result = 0;\n      return result;\n    }\n  sgi_unittime = period_picoseconds * 1e-12;\n\n  /* IRIX 5 doesn't have SGI_CYCLECNTR_SIZE, assume 32 bits in that case.\n     Challenge/ONYX hardware has a 64 bit byte counter, but there seems no\n     obvious way to identify that without SGI_CYCLECNTR_SIZE.  */\n#ifdef SGI_CYCLECNTR_SIZE\n  size = syssgi (SGI_CYCLECNTR_SIZE);\n  if (size == -1)\n    {\n      if (speed_option_verbose)\n\t{\n\t  printf (\"syssgi SGI_CYCLECNTR_SIZE error: %s\\n\", strerror (errno));\n\t  printf (\"    will assume size==4\\n\");\n\t}\n      size = 32;\n    }\n#else\n  size = 32;\n#endif\n\n  if (size < 32)\n    {\n      printf (\"syssgi SGI_CYCLECNTR_SIZE gives %d, expected 32 or 64\\n\", size);\n      result = 0;\n      return result;\n    }\n\n  pagesize = getpagesize();\n  offset = (size_t) phys & (pagesize-1);\n  physpage = phys - offset;\n\n  /* shouldn't cross over a page boundary */\n  ASSERT_ALWAYS (offset + size/8 <= pagesize);\n\n  fd = open(\"/dev/mmem\", O_RDONLY);\n  if (fd == -1)\n    {\n      if (speed_option_verbose)\n\tprintf (\"open /dev/mmem: %s\\n\", strerror (errno));\n      result = 0;\n      return result;\n    }\n\n  virtpage = mmap (0, pagesize, PROT_READ, MAP_PRIVATE, fd, (off_t) physpage);\n  if (virtpage == (void *) -1)\n    {\n      if (speed_option_verbose)\n\tprintf (\"mmap /dev/mmem: %s\\n\", strerror (errno));\n      result = 0;\n      return result;\n    }\n\n  /* address of least significant 4 bytes, knowing mips is big endian */\n  sgi_addr = (unsigned *) ((char *) virtpage + offset\n\t\t\t   + size/8 - sizeof(unsigned));\n  result = 1;\n  return result;\n\n#else /* ! (HAVE_SYSSGI && HAVE_MMAP) */\n  return 0;\n#endif\n}",
      "lines": 86,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "speed_time_init": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        1212,
        1
      ],
      "content": "void\nspeed_time_init (void)\n{\n  double supplement_unittime = 0.0;\n\n  static int  speed_time_initialized = 0;\n  if (speed_time_initialized)\n    return;\n  speed_time_initialized = 1;\n\n  speed_cycletime_init ();\n\n  if (!speed_option_cycles_broken && have_cycles && cycles_works_p ())\n    {\n      use_cycles = 1;\n      DEFAULT (speed_cycletime, 1.0);\n      speed_unittime = speed_cycletime;\n      DEFAULT (speed_precision, 10000);\n      strcpy (speed_time_string, \"CPU cycle counter\");\n\n      /* only used if a supplementary method is chosen below */\n      cycles_limit = (have_cycles == 1 ? M_2POW32 : M_2POW64) / 2.0\n\t* speed_cycletime;\n\n      if (have_grus && getrusage_microseconds_p() && ! getrusage_backwards_p())\n\t{\n\t  /* this is a good combination */\n\t  use_grus = 1;\n\t  supplement_unittime = grus_unittime = 1.0e-6;\n\t  strcpy (speed_time_string, \"CPU cycle counter, supplemented by microsecond getrusage()\");\n\t}\n      else if (have_cycles == 1)\n\t{\n\t  /* When speed_cyclecounter has a limited range, look for something\n\t     to supplement it. */\n\t  if (have_gtod && gettimeofday_microseconds_p())\n\t    {\n\t      use_gtod = 1;\n\t      supplement_unittime = gtod_unittime = 1.0e-6;\n\t      strcpy (speed_time_string, \"CPU cycle counter, supplemented by microsecond gettimeofday()\");\n\t    }\n\t  else if (have_grus)\n\t    {\n\t      use_grus = 1;\n\t      supplement_unittime = grus_unittime = 1.0 / (double) clk_tck ();\n\t      sprintf (speed_time_string, \"CPU cycle counter, supplemented by %s clock tick getrusage()\", unittime_string (supplement_unittime));\n\t    }\n\t  else if (have_times)\n\t    {\n\t      use_times = 1;\n\t      supplement_unittime = times_unittime = 1.0 / (double) clk_tck ();\n\t      sprintf (speed_time_string, \"CPU cycle counter, supplemented by %s clock tick times()\", unittime_string (supplement_unittime));\n\t    }\n\t  else if (have_gtod)\n\t    {\n\t      use_gtod = 1;\n\t      supplement_unittime = gtod_unittime = 1.0 / (double) clk_tck ();\n\t      sprintf (speed_time_string, \"CPU cycle counter, supplemented by %s clock tick gettimeofday()\", unittime_string (supplement_unittime));\n\t    }\n\t  else\n\t    {\n\t      fprintf (stderr, \"WARNING: cycle counter is 32 bits and there's no other functions.\\n\");\n\t      fprintf (stderr, \"    Wraparounds may produce bad results on long measurements.\\n\");\n\t    }\n\t}\n\n      if (use_grus || use_times || use_gtod)\n\t{\n\t  /* must know cycle period to compare cycles to other measuring\n\t     (via cycles_limit) */\n\t  speed_cycletime_need_seconds ();\n\n\t  if (speed_precision * supplement_unittime > cycles_limit)\n\t    {\n\t      fprintf (stderr, \"WARNING: requested precision can't always be achieved due to limited range\\n\");\n\t      fprintf (stderr, \"    cycle counter and limited precision supplemental method\\n\");\n\t      fprintf (stderr, \"    (%s)\\n\", speed_time_string);\n\t    }\n\t}\n    }\n  else if (have_stck)\n    {\n      strcpy (speed_time_string, \"STCK timestamp\");\n      /* stck is in units of 2^-12 microseconds, which is very likely higher\n\t resolution than a cpu cycle */\n      if (speed_cycletime == 0.0)\n\tspeed_cycletime_fail\n\t  (\"Need to know CPU frequency for effective stck unit\");\n      speed_unittime = MAX (speed_cycletime, STCK_PERIOD);\n      DEFAULT (speed_precision, 10000);\n    }\n  else if (have_mftb && mftb_works_p ())\n    {\n      use_mftb = 1;\n      DEFAULT (speed_precision, 10000);\n      speed_unittime = mftb_unittime;\n      sprintf (speed_time_string, \"mftb counter (%s)\",\n\t       unittime_string (speed_unittime));\n    }\n  else if (have_sgi && sgi_works_p ())\n    {\n      use_sgi = 1;\n      DEFAULT (speed_precision, 10000);\n      speed_unittime = sgi_unittime;\n      sprintf (speed_time_string, \"syssgi() mmap counter (%s), supplemented by millisecond getrusage()\",\n\t       unittime_string (speed_unittime));\n      /* supplemented with getrusage, which we assume to have 1ms resolution */\n      use_grus = 1;\n      supplement_unittime = 1e-3;\n    }\n  else if (have_rrt)\n    {\n      timebasestruct_t  t;\n      use_rrt = 1;\n      DEFAULT (speed_precision, 10000);\n      read_real_time (&t, sizeof(t));\n      switch (t.flag) {\n      case RTC_POWER:\n\t/* FIXME: What's the actual RTC resolution? */\n\tspeed_unittime = 1e-7;\n\tstrcpy (speed_time_string, \"read_real_time() power nanoseconds\");\n\tbreak;\n      case RTC_POWER_PC:\n\tt.tb_high = 1;\n\tt.tb_low = 0;\n\ttime_base_to_time (&t, sizeof(t));\n\tspeed_unittime = TIMEBASESTRUCT_SECS(&t) / M_2POW32;\n\tsprintf (speed_time_string, \"%s read_real_time() powerpc ticks\",\n\t\t unittime_string (speed_unittime));\n\tbreak;\n      default:\n\tfprintf (stderr, \"ERROR: Unrecognised timebasestruct_t flag=%d\\n\",\n\t\t t.flag);\n\tabort ();\n      }\n    }\n  else if (have_cgt && cgt_works_p() && cgt_unittime < 1.5e-6)\n    {\n      /* use clock_gettime if microsecond or better resolution */\n    choose_cgt:\n      use_cgt = 1;\n      speed_unittime = cgt_unittime;\n      DEFAULT (speed_precision, (cgt_unittime <= 0.1e-6 ? 10000 : 1000));\n      strcpy (speed_time_string, \"microsecond accurate clock_gettime()\");\n    }\n  else if (have_times && clk_tck() > 1000000)\n    {\n      /* Cray vector systems have times() which is clock cycle resolution\n\t (eg. 450 MHz).  */\n      DEFAULT (speed_precision, 10000);\n      goto choose_times;\n    }\n  else if (have_grus && getrusage_microseconds_p() && ! getrusage_backwards_p())\n    {\n      use_grus = 1;\n      speed_unittime = grus_unittime = 1.0e-6;\n      DEFAULT (speed_precision, 1000);\n      strcpy (speed_time_string, \"microsecond accurate getrusage()\");\n    }\n  else if (have_gtod && gettimeofday_microseconds_p())\n    {\n      use_gtod = 1;\n      speed_unittime = gtod_unittime = 1.0e-6;\n      DEFAULT (speed_precision, 1000);\n      strcpy (speed_time_string, \"microsecond accurate gettimeofday()\");\n    }\n  else if (have_cgt && cgt_works_p() && cgt_unittime < 1.5/clk_tck())\n    {\n      /* use clock_gettime if 1 tick or better resolution */\n      goto choose_cgt;\n    }\n  else if (have_times)\n    {\n      use_tick_boundary = 1;\n      DEFAULT (speed_precision, 200);\n    choose_times:\n      use_times = 1;\n      speed_unittime = times_unittime = 1.0 / (double) clk_tck ();\n      sprintf (speed_time_string, \"%s clock tick times()\",\n\t       unittime_string (speed_unittime));\n    }\n  else if (have_grus)\n    {\n      use_grus = 1;\n      use_tick_boundary = 1;\n      speed_unittime = grus_unittime = 1.0 / (double) clk_tck ();\n      DEFAULT (speed_precision, 200);\n      sprintf (speed_time_string, \"%s clock tick getrusage()\\n\",\n\t       unittime_string (speed_unittime));\n    }\n  else if (have_gtod)\n    {\n      use_gtod = 1;\n      use_tick_boundary = 1;\n      speed_unittime = gtod_unittime = 1.0 / (double) clk_tck ();\n      DEFAULT (speed_precision, 200);\n      sprintf (speed_time_string, \"%s clock tick gettimeofday()\",\n\t       unittime_string (speed_unittime));\n    }\n  else\n    {\n      fprintf (stderr, \"No time measuring method available\\n\");\n      fprintf (stderr, \"None of: speed_cyclecounter(), STCK(), getrusage(), gettimeofday(), times()\\n\");\n      abort ();\n    }\n\n  if (speed_option_verbose)\n    {\n      printf (\"speed_time_init: %s\\n\", speed_time_string);\n      printf (\"    speed_precision     %d\\n\", speed_precision);\n      printf (\"    speed_unittime      %.2g\\n\", speed_unittime);\n      if (supplement_unittime)\n\tprintf (\"    supplement_unittime %.2g\\n\", supplement_unittime);\n      printf (\"    use_tick_boundary   %d\\n\", use_tick_boundary);\n      if (have_cycles)\n\tprintf (\"    cycles_limit        %.2g seconds\\n\", cycles_limit);\n    }\n}",
      "lines": 218,
      "depth": 24,
      "decorators": [
        "void"
      ]
    },
    "grus_tick_boundary": {
      "start_point": [
        1219,
        0
      ],
      "end_point": [
        1227,
        1
      ],
      "content": "void\ngrus_tick_boundary (void)\n{\n  struct_rusage  prev;\n  getrusage (0, &prev);\n  do {\n    getrusage (0, &start_grus);\n  } while (start_grus.ru_utime.tv_usec == prev.ru_utime.tv_usec);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gtod_tick_boundary": {
      "start_point": [
        1229,
        0
      ],
      "end_point": [
        1237,
        1
      ],
      "content": "void\ngtod_tick_boundary (void)\n{\n  struct_timeval  prev;\n  gettimeofday (&prev, NULL);\n  do {\n    gettimeofday (&start_gtod, NULL);\n  } while (start_gtod.tv_usec == prev.tv_usec);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "times_tick_boundary": {
      "start_point": [
        1239,
        0
      ],
      "end_point": [
        1247,
        1
      ],
      "content": "void\ntimes_tick_boundary (void)\n{\n  struct_tms  prev;\n  times (&prev);\n  do\n    times (&start_times);\n  while (start_times.tms_utime == prev.tms_utime);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "speed_starttime": {
      "start_point": [
        1252,
        0
      ],
      "end_point": [
        1299,
        1
      ],
      "content": "void\nspeed_starttime (void)\n{\n  speed_time_init ();\n\n  if (have_grus && use_grus)\n    {\n      if (use_tick_boundary)\n\tgrus_tick_boundary ();\n      else\n\tgetrusage (0, &start_grus);\n    }\n\n  if (have_gtod && use_gtod)\n    {\n      if (use_tick_boundary)\n\tgtod_tick_boundary ();\n      else\n\tgettimeofday (&start_gtod, NULL);\n    }\n\n  if (have_times && use_times)\n    {\n      if (use_tick_boundary)\n\ttimes_tick_boundary ();\n      else\n\ttimes (&start_times);\n    }\n\n  if (have_cgt && use_cgt)\n    clock_gettime (CGT_ID, &start_cgt);\n\n  if (have_rrt && use_rrt)\n    read_real_time (&start_rrt, sizeof(start_rrt));\n\n  if (have_sgi && use_sgi)\n    start_sgi = *sgi_addr;\n\n  if (have_mftb && use_mftb)\n    MFTB (start_mftb);\n\n  if (have_stck && use_stck)\n    STCK (start_stck);\n\n  /* Cycles sampled last for maximum accuracy. */\n  if (have_cycles && use_cycles)\n    speed_cyclecounter (start_cycles);\n}",
      "lines": 48,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "speed_cyclecounter_diff": {
      "start_point": [
        1311,
        0
      ],
      "end_point": [
        1328,
        1
      ],
      "content": "double\nspeed_cyclecounter_diff (const unsigned end[2], const unsigned start[2])\n{\n  unsigned  d;\n  double    t;\n\n  if (have_cycles == 1)\n    {\n      t = (end[0] - start[0]);\n    }\n  else\n    {\n      d = end[0] - start[0];\n      t = d - (d > end[0] ? M_2POWU : 0.0);\n      t += (end[1] - start[1]) * M_2POW32;\n    }\n  return t;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "speed_mftb_diff": {
      "start_point": [
        1331,
        0
      ],
      "end_point": [
        1341,
        1
      ],
      "content": "double\nspeed_mftb_diff (const unsigned end[2], const unsigned start[2])\n{\n  unsigned  d;\n  double    t;\n\n  d = end[0] - start[0];\n  t = (double) d - (d > end[0] ? M_2POW32 : 0.0);\n  t += (end[1] - start[1]) * M_2POW32;\n  return t;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "timeval_diff_secs": {
      "start_point": [
        1366,
        0
      ],
      "end_point": [
        1370,
        1
      ],
      "content": "double\ntimeval_diff_secs (const struct_timeval *end, const struct_timeval *start)\n{\n  DIFF_SECS_ROUTINE (tv_sec, tv_usec, 1e-6);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "rusage_diff_secs": {
      "start_point": [
        1372,
        0
      ],
      "end_point": [
        1376,
        1
      ],
      "content": "double\nrusage_diff_secs (const struct_rusage *end, const struct_rusage *start)\n{\n  DIFF_SECS_ROUTINE (ru_utime.tv_sec, ru_utime.tv_usec, 1e-6);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "timespec_diff_secs": {
      "start_point": [
        1378,
        0
      ],
      "end_point": [
        1382,
        1
      ],
      "content": "double\ntimespec_diff_secs (const struct_timespec *end, const struct_timespec *start)\n{\n  DIFF_SECS_ROUTINE (tv_sec, tv_nsec, 1e-9);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "timebasestruct_diff_secs": {
      "start_point": [
        1385,
        0
      ],
      "end_point": [
        1390,
        1
      ],
      "content": "double\ntimebasestruct_diff_secs (const timebasestruct_t *end,\n\t\t\t  const timebasestruct_t *start)\n{\n  DIFF_SECS_ROUTINE (tb_high, tb_low, 1e-9);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_endtime": {
      "start_point": [
        1393,
        0
      ],
      "end_point": [
        1596,
        1
      ],
      "content": "double\nspeed_endtime (void)\n{\n#define END_USE(name,value)                             \\\n  do {                                                  \\\n    if (speed_option_verbose >= 3)                      \\\n      printf (\"speed_endtime(): used %s\\n\", name);      \\\n    result = value;                                     \\\n    goto done;                                          \\\n  } while (0)\n\n#define END_ENOUGH(name,value)                                          \\\n  do {                                                                  \\\n    if (speed_option_verbose >= 3)                                      \\\n      printf (\"speed_endtime(): %s gives enough precision\\n\", name);    \\\n    result = value;                                                     \\\n    goto done;                                                          \\\n  } while (0)\n\n#define END_EXCEED(name,value)                                            \\\n  do {                                                                    \\\n    if (speed_option_verbose >= 3)                                        \\\n      printf (\"speed_endtime(): cycle counter limit exceeded, used %s\\n\", \\\n\t      name);                                                      \\\n    result = value;                                                       \\\n    goto done;                                                            \\\n  } while (0)\n\n  unsigned          end_cycles[2];\n  stck_t            end_stck;\n  unsigned          end_mftb[2];\n  unsigned          end_sgi;\n  timebasestruct_t  end_rrt;\n  struct_timespec   end_cgt;\n  struct_timeval    end_gtod;\n  struct_rusage     end_grus;\n  struct_tms        end_times;\n  double            t_gtod, t_grus, t_times, t_cgt;\n  double            t_rrt, t_sgi, t_mftb, t_stck, t_cycles;\n  double            result;\n\n  /* Cycles sampled first for maximum accuracy.\n     \"have_\" values tested to let unused code go dead.  */\n\n  if (have_cycles && use_cycles)  speed_cyclecounter (end_cycles);\n  if (have_stck   && use_stck)    STCK (end_stck);\n  if (have_mftb   && use_mftb)    MFTB (end_mftb);\n  if (have_sgi    && use_sgi)     end_sgi = *sgi_addr;\n  if (have_rrt    && use_rrt)     read_real_time (&end_rrt, sizeof(end_rrt));\n  if (have_cgt    && use_cgt)     clock_gettime (CGT_ID, &end_cgt);\n  if (have_gtod   && use_gtod)    gettimeofday (&end_gtod, NULL);\n  if (have_grus   && use_grus)    getrusage (0, &end_grus);\n  if (have_times  && use_times)   times (&end_times);\n\n  result = -1.0;\n\n  if (speed_option_verbose >= 4)\n    {\n      printf (\"speed_endtime():\\n\");\n      if (use_cycles)\n\tprintf (\"   cycles  0x%X,0x%X -> 0x%X,0x%X\\n\",\n\t\tstart_cycles[1], start_cycles[0],\n\t\tend_cycles[1], end_cycles[0]);\n\n      if (use_stck)\n\tprintf (\"   stck  0x%lX -> 0x%lX\\n\", start_stck, end_stck);\n\n      if (use_mftb)\n\tprintf (\"   mftb  0x%X,%08X -> 0x%X,%08X\\n\",\n\t\tstart_mftb[1], start_mftb[0],\n\t\tend_mftb[1], end_mftb[0]);\n\n      if (use_sgi)\n\tprintf (\"   sgi  0x%X -> 0x%X\\n\", start_sgi, end_sgi);\n\n      if (use_rrt)\n\tprintf (\"   read_real_time  (%d)%u,%u -> (%d)%u,%u\\n\",\n\t\tstart_rrt.flag, start_rrt.tb_high, start_rrt.tb_low,\n\t\tend_rrt.flag, end_rrt.tb_high, end_rrt.tb_low);\n\n      if (use_cgt)\n\tprintf (\"   clock_gettime  %ld.%09ld -> %ld.%09ld\\n\",\n\t\tstart_cgt.tv_sec, start_cgt.tv_nsec,\n\t\tend_cgt.tv_sec, end_cgt.tv_nsec);\n\n      if (use_gtod)\n\tprintf (\"   gettimeofday  %ld.%06ld -> %ld.%06ld\\n\",\n\t\tstart_gtod.tv_sec, start_gtod.tv_usec,\n\t\tend_gtod.tv_sec, end_gtod.tv_usec);\n\n      if (use_grus)\n\tprintf (\"   getrusage  %ld.%06ld -> %ld.%06ld\\n\",\n\t\tstart_grus.ru_utime.tv_sec, start_grus.ru_utime.tv_usec,\n\t\tend_grus.ru_utime.tv_sec, end_grus.ru_utime.tv_usec);\n\n      if (use_times)\n\tprintf (\"   times  %ld -> %ld\\n\",\n\t\tstart_times.tms_utime, end_times.tms_utime);\n    }\n\n  if (use_rrt)\n    {\n      time_base_to_time (&start_rrt, sizeof(start_rrt));\n      time_base_to_time (&end_rrt, sizeof(end_rrt));\n      t_rrt = timebasestruct_diff_secs (&end_rrt, &start_rrt);\n      END_USE (\"read_real_time()\", t_rrt);\n    }\n\n  if (use_cgt)\n    {\n      t_cgt = timespec_diff_secs (&end_cgt, &start_cgt);\n      END_USE (\"clock_gettime()\", t_cgt);\n    }\n\n  if (use_grus)\n    {\n      t_grus = rusage_diff_secs (&end_grus, &start_grus);\n\n      /* Use getrusage() if the cycle counter limit would be exceeded, or if\n\t it provides enough accuracy already. */\n      if (use_cycles)\n\t{\n\t  if (t_grus >= speed_precision*grus_unittime)\n\t    END_ENOUGH (\"getrusage()\", t_grus);\n\t  if (t_grus >= cycles_limit)\n\t    END_EXCEED (\"getrusage()\", t_grus);\n\t}\n    }\n\n  if (use_times)\n    {\n      t_times = (end_times.tms_utime - start_times.tms_utime) * times_unittime;\n\n      /* Use times() if the cycle counter limit would be exceeded, or if\n\t it provides enough accuracy already. */\n      if (use_cycles)\n\t{\n\t  if (t_times >= speed_precision*times_unittime)\n\t    END_ENOUGH (\"times()\", t_times);\n\t  if (t_times >= cycles_limit)\n\t    END_EXCEED (\"times()\", t_times);\n\t}\n    }\n\n  if (use_gtod)\n    {\n      t_gtod = timeval_diff_secs (&end_gtod, &start_gtod);\n\n      /* Use gettimeofday() if it measured a value bigger than the cycle\n\t counter can handle.  */\n      if (use_cycles)\n\t{\n\t  if (t_gtod >= cycles_limit)\n\t    END_EXCEED (\"gettimeofday()\", t_gtod);\n\t}\n    }\n\n  if (use_mftb)\n    {\n      t_mftb = speed_mftb_diff (end_mftb, start_mftb) * mftb_unittime;\n      END_USE (\"mftb\", t_mftb);\n    }\n\n  if (use_stck)\n    {\n      t_stck = (end_stck - start_stck) * STCK_PERIOD;\n      END_USE (\"stck\", t_stck);\n    }\n\n  if (use_sgi)\n    {\n      t_sgi = (end_sgi - start_sgi) * sgi_unittime;\n      END_USE (\"SGI hardware counter\", t_sgi);\n    }\n\n  if (use_cycles)\n    {\n      t_cycles = speed_cyclecounter_diff (end_cycles, start_cycles)\n\t* speed_cycletime;\n      END_USE (\"cycle counter\", t_cycles);\n    }\n\n  if (use_grus && getrusage_microseconds_p())\n    END_USE (\"getrusage()\", t_grus);\n\n  if (use_gtod && gettimeofday_microseconds_p())\n    END_USE (\"gettimeofday()\", t_gtod);\n\n  if (use_times)  END_USE (\"times()\",        t_times);\n  if (use_grus)   END_USE (\"getrusage()\",    t_grus);\n  if (use_gtod)   END_USE (\"gettimeofday()\", t_gtod);\n\n  fprintf (stderr, \"speed_endtime(): oops, no time method available\\n\");\n  abort ();\n\n done:\n  if (result < 0.0)\n    {\n      if (speed_option_verbose >= 2)\n\tfprintf (stderr, \"speed_endtime(): warning, treating negative time as zero: %.9f\\n\", result);\n      result = 0.0;\n    }\n  return result;\n}",
      "lines": 204,
      "depth": 12,
      "decorators": [
        "double"
      ]
    }
  },
  "gmp/gmp-6.1.2/tune/tune-gcd-p.c": {
    "search": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static int\nsearch (double *minp, double (*f)(void *, int), void *ctx, int start, int end)\n{\n  int x[4];\n  double y[4];\n\n  int best_i;\n\n  x[0] = start;\n  x[3] = end;\n\n  y[0] = f(ctx, x[0]);\n  y[3] = f(ctx, x[3]);\n\n  for (;;)\n    {\n      int i;\n      int length = x[3] - x[0];\n\n      x[1] = x[0] + length/3;\n      x[2] = x[0] + 2*length/3;\n\n      y[1] = f(ctx, x[1]);\n      y[2] = f(ctx, x[2]);\n\n#if 0\n      printf(\"%d: %f, %d: %f, %d:, %f %d: %f\\n\",\n\t     x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3]);\n#endif\n      for (best_i = 0, i = 1; i < 4; i++)\n\tif (y[i] < y[best_i])\n\t  best_i = i;\n\n      if (length <= 4)\n\tbreak;\n\n      if (best_i >= 2)\n\t{\n\t  x[0] = x[1];\n\t  y[0] = y[1];\n\t}\n      else\n\t{\n\t  x[3] = x[2];\n\t  y[3] = y[2];\n\t}\n    }\n  *minp = y[best_i];\n  return x[best_i];\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "compare_double": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\ncompare_double(const void *ap, const void *bp)\n{\n  double a = * (const double *) ap;\n  double b = * (const double *) bp;\n\n  if (a < b)\n    return -1;\n  else if (a > b)\n    return 1;\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "median": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static double\nmedian (double *v, size_t n)\n{\n  qsort(v, n, sizeof(*v), compare_double);\n\n  return v[n/2];\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "bench_gcd": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        152,
        5
      ],
      "content": "static double\nbench_gcd (void *ctx, int p)\n{\n  struct bench_data *data = (struct bench_data *) ctx;\n  double t;\n\n  p_table[data->n] = p;\n  TIME(t, {\n      MPN_COPY (data->up, data->ap, data->n);\n      MPN_COPY (data->vp, data->bp, data->n);\n      mpn_gcd (data->gp, data->up, data->n, data->vp, data->n);\n    }",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "main": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  gmp_randstate_t rands;  struct bench_data data;\n  mp_size_t n;\n\n  TMP_DECL;\n\n  /* Unbuffered so if output is redirected to a file it isn't lost if the\n     program is killed part way through.  */\n  setbuf (stdout, NULL);\n  setbuf (stderr, NULL);\n\n  gmp_randinit_default (rands);\n\n  TMP_MARK;\n\n  data.ap = TMP_ALLOC_LIMBS (P_TABLE_SIZE);\n  data.bp = TMP_ALLOC_LIMBS (P_TABLE_SIZE);\n  data.up = TMP_ALLOC_LIMBS (P_TABLE_SIZE);\n  data.vp = TMP_ALLOC_LIMBS (P_TABLE_SIZE);\n  data.gp = TMP_ALLOC_LIMBS (P_TABLE_SIZE);\n\n  mpn_random (data.ap, P_TABLE_SIZE);\n  mpn_random (data.bp, P_TABLE_SIZE);\n\n  memset (p_table, 0, sizeof(p_table));\n\n  for (n = 100; n < P_TABLE_SIZE; n++)\n    {\n      mp_size_t p;\n      mp_size_t best_p;\n      double best_time;\n      double lehmer_time;\n\n      if (data.ap[n-1] == 0)\n\tdata.ap[n-1] = 1;\n\n      if (data.bp[n-1] == 0)\n\tdata.bp[n-1] = 1;\n\n      data.n = n;\n\n      lehmer_time = bench_gcd (&data, 0);\n\n      best_p = search (&best_time, bench_gcd, &data, n/5, 4*n/5);\n      if (best_time > lehmer_time)\n\tbest_p = 0;\n\n      printf(\"%6d %6d %5.3g\", n, best_p, (double) best_p / n);\n      if (best_p > 0)\n\t{\n\t  double speedup = 100 * (lehmer_time - best_time) / lehmer_time;\n\t  printf(\" %5.3g%%\", speedup);\n\t  if (speedup < 1.0)\n\t    {\n\t      printf(\" (ignored)\");\n\t      best_p = 0;\n\t    }\n\t}\n      printf(\"\\n\");\n\n      p_table[n] = best_p;\n    }\n  TMP_FREE;\n  gmp_randclear(rands);\n  return 0;\n}",
      "lines": 68,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gmp/gmp-6.1.2/tune/tuneup.c": {
    "randlimb_norm": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "mp_limb_t\nrandlimb_norm (void)\n{\n  mp_limb_t  n;\n  mpn_random (&n, 1);\n  n |= GMP_NUMB_HIGHBIT;\n  return n;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "randlimb_half": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "mp_limb_t\nrandlimb_half (void)\n{\n  mp_limb_t  n;\n  mpn_random (&n, 1);\n  n &= GMP_NUMB_HALFMASK;\n  n += (n==0);\n  return n;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "add_dat": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "void\nadd_dat (mp_size_t size, double d)\n{\n#define ALLOCDAT_STEP  500\n\n  ASSERT_ALWAYS (ndat <= allocdat);\n\n  if (ndat == allocdat)\n    {\n      dat = (struct dat_t *) __gmp_allocate_or_reallocate\n        (dat, allocdat * sizeof(dat[0]),\n         (allocdat+ALLOCDAT_STEP) * sizeof(dat[0]));\n      allocdat += ALLOCDAT_STEP;\n    }\n\n  dat[ndat].size = size;\n  dat[ndat].d = d;\n  ndat++;\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "analyze_dat": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "mp_size_t\nanalyze_dat (int final)\n{\n  double  x, min_x;\n  int     j, min_j;\n\n  /* If the threshold is set at dat[0].size, any positive values are bad. */\n  x = 0.0;\n  for (j = 0; j < ndat; j++)\n    if (dat[j].d > 0.0)\n      x += dat[j].d;\n\n  if (option_trace >= 2 && final)\n    {\n      printf (\"\\n\");\n      printf (\"x is the sum of the badness from setting thresh at given size\\n\");\n      printf (\"  (minimum x is sought)\\n\");\n      printf (\"size=%ld  first x=%.4f\\n\", (long) dat[j].size, x);\n    }\n\n  min_x = x;\n  min_j = 0;\n\n\n  /* When stepping to the next dat[j].size, positive values are no longer\n     bad (so subtracted), negative values become bad (so add the absolute\n     value, meaning subtract). */\n  for (j = 0; j < ndat; x -= dat[j].d, j++)\n    {\n      if (option_trace >= 2 && final)\n        printf (\"size=%ld  x=%.4f\\n\", (long) dat[j].size, x);\n\n      if (x < min_x)\n        {\n          min_x = x;\n          min_j = j;\n        }\n    }\n\n  return min_j;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "mp_size_t"
      ]
    },
    "speed_mpn_mod_1_tune": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "double\nspeed_mpn_mod_1_tune (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_MOD_1 (mpn_mod_1_tune);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_divrem_1_tune": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "double\nspeed_mpn_divrem_1_tune (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIVREM_1 (mpn_divrem_1_tune);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpz_fac_ui_tune": {
      "start_point": [
        415,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "double\nspeed_mpz_fac_ui_tune (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPZ_FAC_UI (mpz_fac_ui_tune);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "speed_mpn_div_qr_1_tune": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "double\nspeed_mpn_div_qr_1_tune (struct speed_params *s)\n{\n  SPEED_ROUTINE_MPN_DIV_QR_1 (mpn_div_qr_1_tune);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "tuneup_measure": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        464,
        1
      ],
      "content": "double\ntuneup_measure (speed_function_t fun,\n                const struct param_t *param,\n                struct speed_params *s)\n{\n  static struct param_t  dummy;\n  double   t;\n  TMP_DECL;\n\n  if (! param)\n    param = &dummy;\n\n  s->size += param->size_extra;\n\n  TMP_MARK;\n  SPEED_TMP_ALLOC_LIMBS (s->xp, s->size, 0);\n  SPEED_TMP_ALLOC_LIMBS (s->yp, s->size, 0);\n\n  mpn_random (s->xp, s->size);\n  mpn_random (s->yp, s->size);\n\n  switch (param->data_high) {\n  case DATA_HIGH_LT_R:\n    s->xp[s->size-1] %= s->r;\n    s->yp[s->size-1] %= s->r;\n    break;\n  case DATA_HIGH_GE_R:\n    s->xp[s->size-1] |= s->r;\n    s->yp[s->size-1] |= s->r;\n    break;\n  }\n\n  t = speed_measure (fun, s);\n\n  s->size -= param->size_extra;\n\n  TMP_FREE;\n  return t;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "print_define_start": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "void\nprint_define_start (const char *name)\n{\n  printf (\"#define %-*s  \", PRINT_WIDTH, name);\n  if (option_trace)\n    printf (\"...\\n\");\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "print_define_end_remark": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        492,
        1
      ],
      "content": "void\nprint_define_end_remark (const char *name, mp_size_t value, const char *remark)\n{\n  if (option_trace)\n    printf (\"#define %-*s  \", PRINT_WIDTH, name);\n\n  if (value == MP_SIZE_T_MAX)\n    printf (\"MP_SIZE_T_MAX\");\n  else\n    printf (\"%5ld\", (long) value);\n\n  if (remark != NULL)\n    printf (\"  /* %s */\", remark);\n  printf (\"\\n\");\n  fflush (stdout);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print_define_end": {
      "start_point": [
        494,
        0
      ],
      "end_point": [
        505,
        1
      ],
      "content": "void\nprint_define_end (const char *name, mp_size_t value)\n{\n  const char  *remark;\n  if (value == MP_SIZE_T_MAX)\n    remark = \"never\";\n  else if (value == 0)\n    remark = \"always\";\n  else\n    remark = NULL;\n  print_define_end_remark (name, value, remark);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "print_define": {
      "start_point": [
        507,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "void\nprint_define (const char *name, mp_size_t value)\n{\n  print_define_start (name);\n  print_define_end (name, value);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "print_define_remark": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        519,
        1
      ],
      "content": "void\nprint_define_remark (const char *name, mp_size_t value, const char *remark)\n{\n  print_define_start (name);\n  print_define_end_remark (name, value, remark);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "one": {
      "start_point": [
        522,
        0
      ],
      "end_point": [
        704,
        1
      ],
      "content": "void\none (mp_size_t *threshold, struct param_t *param)\n{\n  int  since_positive, since_thresh_change;\n  int  thresh_idx, new_thresh_idx;\n\n#define DEFAULT(x,n)  do { if (! (x))  (x) = (n); } while (0)\n\n  DEFAULT (param->function_fudge, 1.0);\n  DEFAULT (param->function2, param->function);\n  DEFAULT (param->step_factor, 0.01);  /* small steps by default */\n  DEFAULT (param->step, 1);            /* small steps by default */\n  DEFAULT (param->stop_since_change, 80);\n  DEFAULT (param->stop_factor, 1.2);\n  DEFAULT (param->min_size, 10);\n  DEFAULT (param->max_size, DEFAULT_MAX_SIZE);\n\n  if (param->check_size != 0)\n    {\n      double   t1, t2;\n      s.size = param->check_size;\n\n      *threshold = s.size+1;\n      t1 = tuneup_measure (param->function, param, &s);\n\n      *threshold = s.size;\n      t2 = tuneup_measure (param->function2, param, &s);\n      if (t1 == -1.0 || t2 == -1.0)\n        {\n          printf (\"Oops, can't run both functions at size %ld\\n\",\n                  (long) s.size);\n          abort ();\n        }\n      t1 *= param->function_fudge;\n\n      /* ask that t2 is at least 4% below t1 */\n      if (t1 < t2*1.04)\n        {\n          if (option_trace)\n            printf (\"function2 never enough faster: t1=%.9f t2=%.9f\\n\", t1, t2);\n          *threshold = MP_SIZE_T_MAX;\n          if (! param->noprint)\n            print_define (param->name, *threshold);\n          return;\n        }\n\n      if (option_trace >= 2)\n        printf (\"function2 enough faster at size=%ld: t1=%.9f t2=%.9f\\n\",\n                (long) s.size, t1, t2);\n    }\n\n  if (! param->noprint || option_trace)\n    print_define_start (param->name);\n\n  ndat = 0;\n  since_positive = 0;\n  since_thresh_change = 0;\n  thresh_idx = 0;\n\n  if (option_trace >= 2)\n    {\n      printf (\"             algorithm-A  algorithm-B   ratio  possible\\n\");\n      printf (\"              (seconds)    (seconds)    diff    thresh\\n\");\n    }\n\n  for (s.size = param->min_size;\n       s.size < param->max_size;\n       s.size += MAX ((mp_size_t) floor (s.size * param->step_factor), param->step))\n    {\n      double   ti, tiplus1, d;\n\n      /*\n        FIXME: check minimum size requirements are met, possibly by just\n        checking for the -1 returns from the speed functions.\n      */\n\n      /* using method A at this size */\n      *threshold = s.size+1;\n      ti = tuneup_measure (param->function, param, &s);\n      if (ti == -1.0)\n        abort ();\n      ti *= param->function_fudge;\n\n      /* using method B at this size */\n      *threshold = s.size;\n      tiplus1 = tuneup_measure (param->function2, param, &s);\n      if (tiplus1 == -1.0)\n        abort ();\n\n      /* Calculate the fraction by which the one or the other routine is\n         slower.  */\n      if (tiplus1 >= ti)\n        d = (tiplus1 - ti) / tiplus1;  /* negative */\n      else\n        d = (tiplus1 - ti) / ti;       /* positive */\n\n      add_dat (s.size, d);\n\n      new_thresh_idx = analyze_dat (0);\n\n      if (option_trace >= 2)\n        printf (\"size=%ld  %.9f  %.9f  % .4f %c  %ld\\n\",\n                (long) s.size, ti, tiplus1, d,\n                ti > tiplus1 ? '#' : ' ',\n                (long) dat[new_thresh_idx].size);\n\n      /* Stop if the last time method i was faster was more than a\n         certain number of measurements ago.  */\n#define STOP_SINCE_POSITIVE  200\n      if (d >= 0)\n        since_positive = 0;\n      else\n        if (++since_positive > STOP_SINCE_POSITIVE)\n          {\n            if (option_trace >= 1)\n              printf (\"stopped due to since_positive (%d)\\n\",\n                      STOP_SINCE_POSITIVE);\n            break;\n          }\n\n      /* Stop if method A has become slower by a certain factor. */\n      if (ti >= tiplus1 * param->stop_factor)\n        {\n          if (option_trace >= 1)\n            printf (\"stopped due to ti >= tiplus1 * factor (%.1f)\\n\",\n                    param->stop_factor);\n          break;\n        }\n\n      /* Stop if the threshold implied hasn't changed in a certain\n         number of measurements.  (It's this condition that usually\n         stops the loop.) */\n      if (thresh_idx != new_thresh_idx)\n        since_thresh_change = 0, thresh_idx = new_thresh_idx;\n      else\n        if (++since_thresh_change > param->stop_since_change)\n          {\n            if (option_trace >= 1)\n              printf (\"stopped due to since_thresh_change (%d)\\n\",\n                      param->stop_since_change);\n            break;\n          }\n\n      /* Stop if the threshold implied is more than a certain number of\n         measurements ago.  */\n#define STOP_SINCE_AFTER   500\n      if (ndat - thresh_idx > STOP_SINCE_AFTER)\n        {\n          if (option_trace >= 1)\n            printf (\"stopped due to ndat - thresh_idx > amount (%d)\\n\",\n                    STOP_SINCE_AFTER);\n          break;\n        }\n\n      /* Stop when the size limit is reached before the end of the\n         crossover, but only show this as an error for >= the default max\n         size.  FIXME: Maybe should make it a param choice whether this is\n         an error.  */\n      if (s.size >= param->max_size && param->max_size >= DEFAULT_MAX_SIZE)\n        {\n          fprintf (stderr, \"%s\\n\", param->name);\n          fprintf (stderr, \"sizes %ld to %ld total %d measurements\\n\",\n                   (long) dat[0].size, (long) dat[ndat-1].size, ndat);\n          fprintf (stderr, \"    max size reached before end of crossover\\n\");\n          break;\n        }\n    }\n\n  if (option_trace >= 1)\n    printf (\"sizes %ld to %ld total %d measurements\\n\",\n            (long) dat[0].size, (long) dat[ndat-1].size, ndat);\n\n  *threshold = dat[analyze_dat (1)].size;\n\n  if (param->min_is_always)\n    {\n      if (*threshold == param->min_size)\n        *threshold = 0;\n    }\n\n  if (! param->noprint || option_trace)\n    print_define_end (param->name, *threshold);\n}",
      "lines": 183,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "fft_step_size": {
      "start_point": [
        737,
        0
      ],
      "end_point": [
        752,
        1
      ],
      "content": "mp_size_t\nfft_step_size (int k)\n{\n  mp_size_t  step;\n\n  step = MAX ((mp_size_t) 1 << (k-1), GMP_LIMB_BITS) / GMP_LIMB_BITS;\n  step *= (mp_size_t) 1 << k;\n\n  if (step <= 0)\n    {\n      printf (\"Can't handle k=%d\\n\", k);\n      abort ();\n    }\n\n  return step;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "mp_size_t"
      ]
    },
    "fft_next_size": {
      "start_point": [
        754,
        0
      ],
      "end_point": [
        766,
        1
      ],
      "content": "mp_size_t\nfft_next_size (mp_size_t pl, int k)\n{\n  mp_size_t  m = fft_step_size (k);\n\n/*    printf (\"[k=%d %ld] %ld ->\", k, m, pl); */\n\n  if (pl == 0 || (pl & (m-1)) != 0)\n    pl = (pl | (m-1)) + 1;\n\n/*    printf (\" %ld\\n\", pl); */\n  return pl;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpn_mul_fft_lcm": {
      "start_point": [
        772,
        0
      ],
      "end_point": [
        783,
        1
      ],
      "content": "static inline size_t\nmpn_mul_fft_lcm (size_t a, unsigned int k)\n{\n  unsigned int l = k;\n\n  while (a % 2 == 0 && k > 0)\n    {\n      a >>= 1;\n      k--;\n    }\n  return a << l;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "size_t"
      ]
    },
    "fftfill": {
      "start_point": [
        785,
        0
      ],
      "end_point": [
        813,
        1
      ],
      "content": "mp_size_t\nfftfill (mp_size_t pl, int k, int sqr)\n{\n  mp_size_t maxLK;\n  mp_bitcnt_t N, Nprime, nprime, M;\n\n  N = pl * GMP_NUMB_BITS;\n  M = N >> k;\n\n  maxLK = mpn_mul_fft_lcm ((unsigned long) GMP_NUMB_BITS, k);\n\n  Nprime = (1 + (2 * M + k + 2) / maxLK) * maxLK;\n  nprime = Nprime / GMP_NUMB_BITS;\n  if (nprime >= (sqr ? SQR_FFT_MODF_THRESHOLD : MUL_FFT_MODF_THRESHOLD))\n    {\n      size_t K2;\n      for (;;)\n\t{\n\t  K2 = 1L << mpn_fft_best_k (nprime, sqr);\n\t  if ((nprime & (K2 - 1)) == 0)\n\t    break;\n\t  nprime = (nprime + K2 - 1) & -K2;\n\t  Nprime = nprime * GMP_LIMB_BITS;\n\t}\n    }\n  ASSERT_ALWAYS (nprime < pl);\n\n  return Nprime;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "mp_size_t"
      ]
    },
    "compare_double": {
      "start_point": [
        815,
        0
      ],
      "end_point": [
        827,
        1
      ],
      "content": "static int\ncompare_double (const void *ap, const void *bp)\n{\n  double a = * (const double *) ap;\n  double b = * (const double *) bp;\n\n  if (a < b)\n    return -1;\n  else if (a > b)\n    return 1;\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "median": {
      "start_point": [
        829,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "double\nmedian (double *times, int n)\n{\n  qsort (times, n, sizeof (double), compare_double);\n  return times[n/2];\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "cached_measure": {
      "start_point": [
        845,
        0
      ],
      "end_point": [
        866,
        1
      ],
      "content": "double\ncached_measure (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n, int k,\n\t\tint n_measurements)\n{\n  int i;\n  double t, ttab[MAX_REPS];\n\n  if (fft_cache[k].n == n)\n    return fft_cache[k].time;\n\n  for (i = 0; i < n_measurements; i++)\n    {\n      speed_starttime ();\n      mpn_mul_fft (rp, n, ap, n, bp, n, k);\n      ttab[i] = speed_endtime ();\n    }\n\n  t = median (ttab, n_measurements);\n  fft_cache[k].n = n;\n  fft_cache[k].time = t;\n  return t;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "fftmes": {
      "start_point": [
        876,
        0
      ],
      "end_point": [
        1065,
        1
      ],
      "content": "int\nfftmes (mp_size_t nmin, mp_size_t nmax, int initial_k, struct fft_param_t *p, int idx, int print)\n{\n  mp_size_t n, n1, prev_n1;\n  int k, best_k, last_best_k, kmax;\n  int eff, prev_eff;\n  double t0, t1;\n  int n_measurements;\n  mp_limb_t *ap, *bp, *rp;\n  mp_size_t alloc;\n  struct fft_table_nk *fft_tab;\n\n  fft_tab = mpn_fft_table3[p->sqr];\n\n  for (k = 0; k < FFT_CACHE_SIZE; k++)\n    fft_cache[k].n = 0;\n\n  if (nmin < (p->sqr ? SQR_FFT_MODF_THRESHOLD : MUL_FFT_MODF_THRESHOLD))\n    {\n      nmin = (p->sqr ? SQR_FFT_MODF_THRESHOLD : MUL_FFT_MODF_THRESHOLD);\n    }\n\n  if (print)\n    printf (\"#define %s%*s\", p->table_name, 38, \"\");\n\n  if (idx == 0)\n    {\n      INSERT_FFTTAB (0, nmin, initial_k);\n\n      if (print)\n\t{\n\t  printf (\"\\\\\\n  { \");\n\t  printf (\"{%7u,%2u}\", fft_tab[0].n, fft_tab[0].k);\n\t}\n\n      idx = 1;\n    }\n\n  ap = (mp_ptr) malloc (sizeof (mp_limb_t));\n  if (p->sqr)\n    bp = ap;\n  else\n    bp = (mp_ptr) malloc (sizeof (mp_limb_t));\n  rp = (mp_ptr) malloc (sizeof (mp_limb_t));\n  alloc = 1;\n\n  /* Round n to comply to initial k value */\n  n = (nmin + ((1ul << initial_k) - 1)) & (MP_SIZE_T_MAX << initial_k);\n\n  n_measurements = (18 - initial_k) | 1;\n  n_measurements = MAX (n_measurements, MIN_REPS);\n  n_measurements = MIN (n_measurements, MAX_REPS);\n\n  last_best_k = initial_k;\n  best_k = initial_k;\n\n  while (n < nmax)\n    {\n      int start_k, end_k;\n\n      /* Assume the current best k is best until we hit its next FFT step.  */\n      t0 = 99999;\n\n      prev_n1 = n + 1;\n\n      start_k = MAX (4, best_k - 4);\n      end_k = MIN (24, best_k + 4);\n      for (k = start_k; k <= end_k; k++)\n\t{\n          n1 = mpn_fft_next_size (prev_n1, k);\n\n\t  eff = 200 * (n1 * GMP_NUMB_BITS >> k) / fftfill (n1, k, p->sqr);\n\n\t  if (eff < 70)\t\t/* avoid measuring too slow fft:s */\n\t    continue;\n\n\t  if (n1 > alloc)\n\t    {\n\t      alloc = n1;\n\t      if (p->sqr)\n\t\t{\n\t\t  ap = (mp_ptr) realloc (ap, sizeof (mp_limb_t));\n\t\t  rp = (mp_ptr) realloc (rp, sizeof (mp_limb_t));\n\t\t  ap = bp = (mp_ptr) realloc (ap, alloc * sizeof (mp_limb_t));\n\t\t  mpn_random (ap, alloc);\n\t\t  rp = (mp_ptr) realloc (rp, alloc * sizeof (mp_limb_t));\n\t\t}\n\t      else\n\t\t{\n\t\t  ap = (mp_ptr) realloc (ap, sizeof (mp_limb_t));\n\t\t  bp = (mp_ptr) realloc (bp, sizeof (mp_limb_t));\n\t\t  rp = (mp_ptr) realloc (rp, sizeof (mp_limb_t));\n\t\t  ap = (mp_ptr) realloc (ap, alloc * sizeof (mp_limb_t));\n\t\t  mpn_random (ap, alloc);\n\t\t  bp = (mp_ptr) realloc (bp, alloc * sizeof (mp_limb_t));\n\t\t  mpn_random (bp, alloc);\n\t\t  rp = (mp_ptr) realloc (rp, alloc * sizeof (mp_limb_t));\n\t\t}\n\t    }\n\n\t  t1 = cached_measure (rp, ap, bp, n1, k, n_measurements);\n\n\t  if (t1 * n_measurements > 0.3)\n\t    n_measurements -= 2;\n\t  n_measurements = MAX (n_measurements, MIN_REPS);\n\n\t  if (t1 < t0)\n\t    {\n\t      best_k = k;\n\t      t0 = t1;\n\t    }\n\t}\n\n      n1 = mpn_fft_next_size (prev_n1, best_k);\n\n      if (last_best_k != best_k)\n\t{\n\t  ASSERT_ALWAYS ((prev_n1 & ((1ul << last_best_k) - 1)) == 1);\n\n\t  if (idx >= FFT_TABLE3_SIZE)\n\t    {\n\t      printf (\"FFT table exhausted, increase FFT_TABLE3_SIZE in gmp-impl.h\\n\");\n\t      abort ();\n\t    }\n\t  INSERT_FFTTAB (idx, prev_n1 >> last_best_k, best_k);\n\n\t  if (print)\n\t    {\n\t      printf (\", \");\n\t      if (idx % 4 == 0)\n\t\tprintf (\"\\\\\\n    \");\n\t      printf (\"{%7u,%2u}\", fft_tab[idx].n, fft_tab[idx].k);\n\t    }\n\n\t  if (option_trace >= 2)\n\t    {\n\t      printf (\"{%lu,%u}\\n\", prev_n1, best_k);\n\t      fflush (stdout);\n\t    }\n\n\t  last_best_k = best_k;\n\t  idx++;\n\t}\n\n      for (;;)\n\t{\n\t  prev_n1 = n1;\n\t  prev_eff = fftfill (prev_n1, best_k, p->sqr);\n\t  n1 = mpn_fft_next_size (prev_n1 + 1, best_k);\n\t  eff = fftfill (n1, best_k, p->sqr);\n\n\t  if (eff != prev_eff)\n\t    break;\n\t}\n\n      n = prev_n1;\n    }\n\n  kmax = sizeof (mp_size_t) * 4;\t/* GMP_MP_SIZE_T_BITS / 2 */\n  kmax = MIN (kmax, 25-1);\n  for (k = last_best_k + 1; k <= kmax; k++)\n    {\n      if (idx >= FFT_TABLE3_SIZE)\n\t{\n\t  printf (\"FFT table exhausted, increase FFT_TABLE3_SIZE in gmp-impl.h\\n\");\n\t  abort ();\n\t}\n      INSERT_FFTTAB (idx, ((1ul << (2*k-2)) + 1) >> (k-1), k);\n\n      if (print)\n\t{\n\t  printf (\", \");\n\t  if (idx % 4 == 0)\n\t    printf (\"\\\\\\n    \");\n\t  printf (\"{%7u,%2u}\", fft_tab[idx].n, fft_tab[idx].k);\n\t}\n\n      idx++;\n    }\n\n  if (print)\n    printf (\" }\\n\");\n\n  free (ap);\n  if (! p->sqr)\n    free (bp);\n  free (rp);\n\n  return idx;\n}",
      "lines": 190,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "fft": {
      "start_point": [
        1067,
        0
      ],
      "end_point": [
        1195,
        1
      ],
      "content": "void\nfft (struct fft_param_t *p)\n{\n  mp_size_t  size;\n  int        k, idx, initial_k;\n\n  /*** Generate MUL_FFT_MODF_THRESHOLD / SQR_FFT_MODF_THRESHOLD ***/\n\n#if 1\n  {\n    /* Use plain one() mechanism, for some reasonable initial values of k.  The\n       advantage is that we don't depend on mpn_fft_table3, which can therefore\n       leave it completely uninitialized.  */\n\n    static struct param_t param;\n    mp_size_t thres, best_thres;\n    int best_k;\n    char buf[20];\n\n    best_thres = MP_SIZE_T_MAX;\n    best_k = -1;\n\n    for (k = 5; k <= 7; k++)\n      {\n\tparam.name = p->modf_threshold_name;\n\tparam.min_size = 100;\n\tparam.max_size = 2000;\n\tparam.function  = p->mul_function;\n\tparam.step_factor = 0.0;\n\tparam.step = 4;\n\tparam.function2 = p->mul_modf_function;\n\tparam.noprint = 1;\n\ts.r = k;\n\tone (&thres, &param);\n\tif (thres < best_thres)\n\t  {\n\t    best_thres = thres;\n\t    best_k = k;\n\t  }\n      }\n\n    *(p->p_modf_threshold) = best_thres;\n    sprintf (buf, \"k = %d\", best_k);\n    print_define_remark (p->modf_threshold_name, best_thres, buf);\n    initial_k = best_k;\n  }\n#else\n  size = p->first_size;\n  for (;;)\n    {\n      double  tk, tm;\n\n      size = mpn_fft_next_size (size+1, mpn_fft_best_k (size+1, p->sqr));\n      k = mpn_fft_best_k (size, p->sqr);\n\n      if (size >= p->max_size)\n        break;\n\n      s.size = size + fft_step_size (k) / 2;\n      s.r = k;\n      tk = tuneup_measure (p->mul_modf_function, NULL, &s);\n      if (tk == -1.0)\n        abort ();\n\n      tm = tuneup_measure (p->mul_function, NULL, &s);\n      if (tm == -1.0)\n        abort ();\n\n      if (option_trace >= 2)\n        printf (\"at %ld   size=%ld  k=%d  %.9f   size=%ld modf %.9f\\n\",\n                (long) size,\n                (long) size + fft_step_size (k) / 2, k, tk,\n                (long) s.size, tm);\n\n      if (tk < tm)\n        {\n\t  *p->p_modf_threshold = s.size;\n\t  print_define (p->modf_threshold_name, *p->p_modf_threshold);\n\t  break;\n        }\n    }\n  initial_k = ?;\n#endif\n\n  /*** Generate MUL_FFT_TABLE3 / SQR_FFT_TABLE3 ***/\n\n  idx = fftmes (*p->p_modf_threshold, p->max_size, initial_k, p, 0, 1);\n  printf (\"#define %s_SIZE %d\\n\", p->table_name, idx);\n\n  /*** Generate MUL_FFT_THRESHOLD / SQR_FFT_THRESHOLD ***/\n\n  size = 2 * *p->p_modf_threshold;\t/* OK? */\n  for (;;)\n    {\n      double  tk, tm;\n      mp_size_t mulmod_size, mul_size;;\n\n      if (size >= p->max_size)\n        break;\n\n      mulmod_size = mpn_mulmod_bnm1_next_size (2 * (size + 1)) / 2;\n      mul_size = (size + mulmod_size) / 2;\t/* middle of step */\n\n      s.size = mulmod_size;\n      tk = tuneup_measure (p->function, NULL, &s);\n      if (tk == -1.0)\n        abort ();\n\n      s.size = mul_size;\n      tm = tuneup_measure (p->mul_function, NULL, &s);\n      if (tm == -1.0)\n        abort ();\n\n      if (option_trace >= 2)\n        printf (\"at %ld   size=%ld  %.9f   size=%ld mul %.9f\\n\",\n                (long) size,\n                (long) mulmod_size, tk,\n                (long) mul_size, tm);\n\n      size = mulmod_size;\n\n      if (tk < tm)\n        {\n\t  *p->p_threshold = s.size;\n\t  print_define (p->threshold_name, *p->p_threshold);\n\t  break;\n        }\n    }\n}",
      "lines": 129,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "tune_mul_n": {
      "start_point": [
        1201,
        0
      ],
      "end_point": [
        1296,
        1
      ],
      "content": "void\ntune_mul_n (void)\n{\n  static struct param_t  param;\n  mp_size_t next_toom_start;\n  int something_changed;\n\n  param.function = speed_mpn_mul_n;\n\n  param.name = \"MUL_TOOM22_THRESHOLD\";\n  param.min_size = MAX (4, MPN_TOOM22_MUL_MINSIZE);\n  param.max_size = MUL_TOOM22_THRESHOLD_LIMIT-1;\n  one (&mul_toom22_threshold, &param);\n\n  param.noprint = 1;\n\n  /* Threshold sequence loop.  Disable functions that would be used in a very\n     narrow range, re-measuring things when that happens.  */\n  something_changed = 1;\n  while (something_changed)\n    {\n      something_changed = 0;\n\n\tnext_toom_start = mul_toom22_threshold;\n\n\tif (mul_toom33_threshold != 0)\n\t  {\n\t    param.name = \"MUL_TOOM33_THRESHOLD\";\n\t    param.min_size = MAX (next_toom_start, MPN_TOOM33_MUL_MINSIZE);\n\t    param.max_size = MUL_TOOM33_THRESHOLD_LIMIT-1;\n\t    one (&mul_toom33_threshold, &param);\n\n\t    if (next_toom_start * 1.05 >= mul_toom33_threshold)\n\t      {\n\t\tmul_toom33_threshold = 0;\n\t\tsomething_changed = 1;\n\t      }\n\t  }\n\n\tnext_toom_start = MAX (next_toom_start, mul_toom33_threshold);\n\n\tif (mul_toom44_threshold != 0)\n\t  {\n\t    param.name = \"MUL_TOOM44_THRESHOLD\";\n\t    param.min_size = MAX (next_toom_start, MPN_TOOM44_MUL_MINSIZE);\n\t    param.max_size = MUL_TOOM44_THRESHOLD_LIMIT-1;\n\t    one (&mul_toom44_threshold, &param);\n\n\t    if (next_toom_start * 1.05 >= mul_toom44_threshold)\n\t      {\n\t\tmul_toom44_threshold = 0;\n\t\tsomething_changed = 1;\n\t      }\n\t  }\n\n\tnext_toom_start = MAX (next_toom_start, mul_toom44_threshold);\n\n\tif (mul_toom6h_threshold != 0)\n\t  {\n\t    param.name = \"MUL_TOOM6H_THRESHOLD\";\n\t    param.min_size = MAX (next_toom_start, MPN_TOOM6H_MUL_MINSIZE);\n\t    param.max_size = MUL_TOOM6H_THRESHOLD_LIMIT-1;\n\t    one (&mul_toom6h_threshold, &param);\n\n\t    if (next_toom_start * 1.05 >= mul_toom6h_threshold)\n\t      {\n\t\tmul_toom6h_threshold = 0;\n\t\tsomething_changed = 1;\n\t      }\n\t  }\n\n\tnext_toom_start = MAX (next_toom_start, mul_toom6h_threshold);\n\n\tif (mul_toom8h_threshold != 0)\n\t  {\n\t    param.name = \"MUL_TOOM8H_THRESHOLD\";\n\t    param.min_size = MAX (next_toom_start, MPN_TOOM8H_MUL_MINSIZE);\n\t    param.max_size = MUL_TOOM8H_THRESHOLD_LIMIT-1;\n\t    one (&mul_toom8h_threshold, &param);\n\n\t    if (next_toom_start * 1.05 >= mul_toom8h_threshold)\n\t      {\n\t\tmul_toom8h_threshold = 0;\n\t\tsomething_changed = 1;\n\t      }\n\t  }\n    }\n\n    print_define (\"MUL_TOOM33_THRESHOLD\", MUL_TOOM33_THRESHOLD);\n    print_define (\"MUL_TOOM44_THRESHOLD\", MUL_TOOM44_THRESHOLD);\n    print_define (\"MUL_TOOM6H_THRESHOLD\", MUL_TOOM6H_THRESHOLD);\n    print_define (\"MUL_TOOM8H_THRESHOLD\", MUL_TOOM8H_THRESHOLD);\n\n  /* disabled until tuned */\n  MUL_FFT_THRESHOLD = MP_SIZE_T_MAX;\n}",
      "lines": 96,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "tune_mul": {
      "start_point": [
        1298,
        0
      ],
      "end_point": [
        1346,
        1
      ],
      "content": "void\ntune_mul (void)\n{\n  static struct param_t  param;\n  mp_size_t thres;\n\n  param.noprint = 1;\n\n  param.function = speed_mpn_toom32_for_toom43_mul;\n  param.function2 = speed_mpn_toom43_for_toom32_mul;\n  param.name = \"MUL_TOOM32_TO_TOOM43_THRESHOLD\";\n  param.min_size = MPN_TOOM43_MUL_MINSIZE * 24 / 17;\n  one (&thres, &param);\n  mul_toom32_to_toom43_threshold = thres * 17 / 24;\n  print_define (\"MUL_TOOM32_TO_TOOM43_THRESHOLD\", mul_toom32_to_toom43_threshold);\n\n  param.function = speed_mpn_toom32_for_toom53_mul;\n  param.function2 = speed_mpn_toom53_for_toom32_mul;\n  param.name = \"MUL_TOOM32_TO_TOOM53_THRESHOLD\";\n  param.min_size = MPN_TOOM53_MUL_MINSIZE * 30 / 19;\n  one (&thres, &param);\n  mul_toom32_to_toom53_threshold = thres * 19 / 30;\n  print_define (\"MUL_TOOM32_TO_TOOM53_THRESHOLD\", mul_toom32_to_toom53_threshold);\n\n  param.function = speed_mpn_toom42_for_toom53_mul;\n  param.function2 = speed_mpn_toom53_for_toom42_mul;\n  param.name = \"MUL_TOOM42_TO_TOOM53_THRESHOLD\";\n  param.min_size = MPN_TOOM53_MUL_MINSIZE * 20 / 11;\n  one (&thres, &param);\n  mul_toom42_to_toom53_threshold = thres * 11 / 20;\n  print_define (\"MUL_TOOM42_TO_TOOM53_THRESHOLD\", mul_toom42_to_toom53_threshold);\n\n  param.function = speed_mpn_toom42_mul;\n  param.function2 = speed_mpn_toom63_mul;\n  param.name = \"MUL_TOOM42_TO_TOOM63_THRESHOLD\";\n  param.min_size = MPN_TOOM63_MUL_MINSIZE * 2;\n  one (&thres, &param);\n  mul_toom42_to_toom63_threshold = thres / 2;\n  print_define (\"MUL_TOOM42_TO_TOOM63_THRESHOLD\", mul_toom42_to_toom63_threshold);\n\n  /* Use ratio 5/6 when measuring, the middle of the range 2/3 to 1. */\n  param.function = speed_mpn_toom43_for_toom54_mul;\n  param.function2 = speed_mpn_toom54_for_toom43_mul;\n  param.name = \"MUL_TOOM43_TO_TOOM54_THRESHOLD\";\n  param.min_size = MPN_TOOM54_MUL_MINSIZE * 6 / 5;\n  one (&thres, &param);\n  mul_toom43_to_toom54_threshold = thres * 5 / 6;\n  print_define (\"MUL_TOOM43_TO_TOOM54_THRESHOLD\", mul_toom43_to_toom54_threshold);\n}",
      "lines": 49,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_mullo": {
      "start_point": [
        1349,
        0
      ],
      "end_point": [
        1393,
        1
      ],
      "content": "void\ntune_mullo (void)\n{\n  static struct param_t  param;\n\n  param.function = speed_mpn_mullo_n;\n\n  param.name = \"MULLO_BASECASE_THRESHOLD\";\n  param.min_size = 1;\n  param.min_is_always = 1;\n  param.max_size = MULLO_BASECASE_THRESHOLD_LIMIT-1;\n  param.stop_factor = 1.5;\n  param.noprint = 1;\n  one (&mullo_basecase_threshold, &param);\n\n  param.name = \"MULLO_DC_THRESHOLD\";\n  param.min_size = 8;\n  param.min_is_always = 0;\n  param.max_size = 1000;\n  one (&mullo_dc_threshold, &param);\n\n  if (mullo_basecase_threshold >= mullo_dc_threshold)\n    {\n      print_define (\"MULLO_BASECASE_THRESHOLD\", mullo_dc_threshold);\n      print_define_remark (\"MULLO_DC_THRESHOLD\", 0, \"never mpn_mullo_basecase\");\n    }\n  else\n    {\n      print_define (\"MULLO_BASECASE_THRESHOLD\", mullo_basecase_threshold);\n      print_define (\"MULLO_DC_THRESHOLD\", mullo_dc_threshold);\n    }\n\n  if (WANT_FFT && mul_fft_threshold < MP_SIZE_T_MAX / 2)\n    {\n      param.name = \"MULLO_MUL_N_THRESHOLD\";\n      param.min_size = mullo_dc_threshold;\n      param.max_size = 2 * mul_fft_threshold;\n      param.noprint = 0;\n      param.step_factor = 0.03;\n      one (&mullo_mul_n_threshold, &param);\n    }\n  else\n    print_define_remark (\"MULLO_MUL_N_THRESHOLD\", MP_SIZE_T_MAX,\n\t\t\t \"without FFT use mullo forever\");\n}",
      "lines": 45,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "tune_sqrlo": {
      "start_point": [
        1395,
        0
      ],
      "end_point": [
        1439,
        1
      ],
      "content": "void\ntune_sqrlo (void)\n{\n  static struct param_t  param;\n\n  param.function = speed_mpn_sqrlo;\n\n  param.name = \"SQRLO_BASECASE_THRESHOLD\";\n  param.min_size = 1;\n  param.min_is_always = 1;\n  param.max_size = SQRLO_BASECASE_THRESHOLD_LIMIT-1;\n  param.stop_factor = 1.5;\n  param.noprint = 1;\n  one (&sqrlo_basecase_threshold, &param);\n\n  param.name = \"SQRLO_DC_THRESHOLD\";\n  param.min_size = 8;\n  param.min_is_always = 0;\n  param.max_size = SQRLO_DC_THRESHOLD_LIMIT-1;\n  one (&sqrlo_dc_threshold, &param);\n\n  if (sqrlo_basecase_threshold >= sqrlo_dc_threshold)\n    {\n      print_define (\"SQRLO_BASECASE_THRESHOLD\", sqrlo_dc_threshold);\n      print_define_remark (\"SQRLO_DC_THRESHOLD\", 0, \"never mpn_sqrlo_basecase\");\n    }\n  else\n    {\n      print_define (\"SQRLO_BASECASE_THRESHOLD\", sqrlo_basecase_threshold);\n      print_define (\"SQRLO_DC_THRESHOLD\", sqrlo_dc_threshold);\n    }\n\n  if (WANT_FFT && sqr_fft_threshold < MP_SIZE_T_MAX / 2)\n    {\n      param.name = \"SQRLO_SQR_THRESHOLD\";\n      param.min_size = sqrlo_dc_threshold;\n      param.max_size = 2 * sqr_fft_threshold;\n      param.noprint = 0;\n      param.step_factor = 0.03;\n      one (&sqrlo_sqr_threshold, &param);\n    }\n  else\n    print_define_remark (\"SQRLO_SQR_THRESHOLD\", MP_SIZE_T_MAX,\n\t\t\t \"without FFT use sqrlo forever\");\n}",
      "lines": 45,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "tune_mulmid": {
      "start_point": [
        1441,
        0
      ],
      "end_point": [
        1451,
        1
      ],
      "content": "void\ntune_mulmid (void)\n{\n  static struct param_t  param;\n\n  param.name = \"MULMID_TOOM42_THRESHOLD\";\n  param.function = speed_mpn_mulmid_n;\n  param.min_size = 4;\n  param.max_size = 100;\n  one (&mulmid_toom42_threshold, &param);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_mulmod_bnm1": {
      "start_point": [
        1453,
        0
      ],
      "end_point": [
        1463,
        1
      ],
      "content": "void\ntune_mulmod_bnm1 (void)\n{\n  static struct param_t  param;\n\n  param.name = \"MULMOD_BNM1_THRESHOLD\";\n  param.function = speed_mpn_mulmod_bnm1;\n  param.min_size = 4;\n  param.max_size = 100;\n  one (&mulmod_bnm1_threshold, &param);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_sqrmod_bnm1": {
      "start_point": [
        1465,
        0
      ],
      "end_point": [
        1475,
        1
      ],
      "content": "void\ntune_sqrmod_bnm1 (void)\n{\n  static struct param_t  param;\n\n  param.name = \"SQRMOD_BNM1_THRESHOLD\";\n  param.function = speed_mpn_sqrmod_bnm1;\n  param.min_size = 4;\n  param.max_size = 100;\n  one (&sqrmod_bnm1_threshold, &param);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_sqr": {
      "start_point": [
        1482,
        0
      ],
      "end_point": [
        1620,
        1
      ],
      "content": "void\ntune_sqr (void)\n{\n  /* disabled until tuned */\n  SQR_FFT_THRESHOLD = MP_SIZE_T_MAX;\n\n  if (HAVE_NATIVE_mpn_sqr_basecase)\n    {\n      print_define_remark (\"SQR_BASECASE_THRESHOLD\", 0, \"always (native)\");\n      sqr_basecase_threshold = 0;\n    }\n  else\n    {\n      static struct param_t  param;\n      param.name = \"SQR_BASECASE_THRESHOLD\";\n      param.function = speed_mpn_sqr;\n      param.min_size = 3;\n      param.min_is_always = 1;\n      param.max_size = TUNE_SQR_TOOM2_MAX;\n      param.noprint = 1;\n      one (&sqr_basecase_threshold, &param);\n    }\n\n  {\n    static struct param_t  param;\n    param.name = \"SQR_TOOM2_THRESHOLD\";\n    param.function = speed_mpn_sqr;\n    param.min_size = MAX (4, MPN_TOOM2_SQR_MINSIZE);\n    param.max_size = TUNE_SQR_TOOM2_MAX;\n    param.noprint = 1;\n    one (&sqr_toom2_threshold, &param);\n\n    if (! HAVE_NATIVE_mpn_sqr_basecase\n        && sqr_toom2_threshold < sqr_basecase_threshold)\n      {\n        /* Karatsuba becomes faster than mul_basecase before\n           sqr_basecase does.  Arrange for the expression\n           \"BELOW_THRESHOLD (un, SQR_TOOM2_THRESHOLD))\" which\n           selects mpn_sqr_basecase in mpn_sqr to be false, by setting\n           SQR_TOOM2_THRESHOLD to zero, making\n           SQR_BASECASE_THRESHOLD the toom2 threshold.  */\n\n        sqr_basecase_threshold = SQR_TOOM2_THRESHOLD;\n        SQR_TOOM2_THRESHOLD = 0;\n\n        print_define_remark (\"SQR_BASECASE_THRESHOLD\", sqr_basecase_threshold,\n                             \"toom2\");\n        print_define_remark (\"SQR_TOOM2_THRESHOLD\",SQR_TOOM2_THRESHOLD,\n                             \"never sqr_basecase\");\n      }\n    else\n      {\n        if (! HAVE_NATIVE_mpn_sqr_basecase)\n          print_define (\"SQR_BASECASE_THRESHOLD\", sqr_basecase_threshold);\n        print_define (\"SQR_TOOM2_THRESHOLD\", SQR_TOOM2_THRESHOLD);\n      }\n  }\n\n  {\n    static struct param_t  param;\n    mp_size_t next_toom_start;\n    int something_changed;\n\n    param.function = speed_mpn_sqr;\n    param.noprint = 1;\n\n  /* Threshold sequence loop.  Disable functions that would be used in a very\n     narrow range, re-measuring things when that happens.  */\n    something_changed = 1;\n    while (something_changed)\n      {\n\tsomething_changed = 0;\n\n\tnext_toom_start = MAX (sqr_toom2_threshold, sqr_basecase_threshold);\n\n\tsqr_toom3_threshold = SQR_TOOM3_THRESHOLD_LIMIT;\n\tparam.name = \"SQR_TOOM3_THRESHOLD\";\n\tparam.min_size = MAX (next_toom_start, MPN_TOOM3_SQR_MINSIZE);\n\tparam.max_size = SQR_TOOM3_THRESHOLD_LIMIT-1;\n\tone (&sqr_toom3_threshold, &param);\n\n\tnext_toom_start = MAX (next_toom_start, sqr_toom3_threshold);\n\n\tif (sqr_toom4_threshold != 0)\n\t  {\n\t    param.name = \"SQR_TOOM4_THRESHOLD\";\n\t    sqr_toom4_threshold = SQR_TOOM4_THRESHOLD_LIMIT;\n\t    param.min_size = MAX (next_toom_start, MPN_TOOM4_SQR_MINSIZE);\n\t    param.max_size = SQR_TOOM4_THRESHOLD_LIMIT-1;\n\t    one (&sqr_toom4_threshold, &param);\n\n\t    if (next_toom_start * 1.05 >= sqr_toom4_threshold)\n\t      {\n\t\tsqr_toom4_threshold = 0;\n\t\tsomething_changed = 1;\n\t      }\n\t  }\n\n\tnext_toom_start = MAX (next_toom_start, sqr_toom4_threshold);\n\n\tif (sqr_toom6_threshold != 0)\n\t  {\n\t    param.name = \"SQR_TOOM6_THRESHOLD\";\n\t    sqr_toom6_threshold = SQR_TOOM6_THRESHOLD_LIMIT;\n\t    param.min_size = MAX (next_toom_start, MPN_TOOM6_SQR_MINSIZE);\n\t    param.max_size = SQR_TOOM6_THRESHOLD_LIMIT-1;\n\t    one (&sqr_toom6_threshold, &param);\n\n\t    if (next_toom_start * 1.05 >= sqr_toom6_threshold)\n\t      {\n\t\tsqr_toom6_threshold = 0;\n\t\tsomething_changed = 1;\n\t      }\n\t  }\n\n\tnext_toom_start = MAX (next_toom_start, sqr_toom6_threshold);\n\n\tif (sqr_toom8_threshold != 0)\n\t  {\n\t    param.name = \"SQR_TOOM8_THRESHOLD\";\n\t    sqr_toom8_threshold = SQR_TOOM8_THRESHOLD_LIMIT;\n\t    param.min_size = MAX (next_toom_start, MPN_TOOM8_SQR_MINSIZE);\n\t    param.max_size = SQR_TOOM8_THRESHOLD_LIMIT-1;\n\t    one (&sqr_toom8_threshold, &param);\n\n\t    if (next_toom_start * 1.05 >= sqr_toom8_threshold)\n\t      {\n\t\tsqr_toom8_threshold = 0;\n\t\tsomething_changed = 1;\n\t      }\n\t  }\n      }\n\n    print_define (\"SQR_TOOM3_THRESHOLD\", SQR_TOOM3_THRESHOLD);\n    print_define (\"SQR_TOOM4_THRESHOLD\", SQR_TOOM4_THRESHOLD);\n    print_define (\"SQR_TOOM6_THRESHOLD\", SQR_TOOM6_THRESHOLD);\n    print_define (\"SQR_TOOM8_THRESHOLD\", SQR_TOOM8_THRESHOLD);\n  }\n}",
      "lines": 139,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "tune_dc_div": {
      "start_point": [
        1623,
        0
      ],
      "end_point": [
        1643,
        1
      ],
      "content": "void\ntune_dc_div (void)\n{\n  s.r = 0;\t\t/* clear to make speed function do 2n/n */\n  {\n    static struct param_t  param;\n    param.name = \"DC_DIV_QR_THRESHOLD\";\n    param.function = speed_mpn_sbpi1_div_qr;\n    param.function2 = speed_mpn_dcpi1_div_qr;\n    param.min_size = 6;\n    one (&dc_div_qr_threshold, &param);\n  }\n  {\n    static struct param_t  param;\n    param.name = \"DC_DIVAPPR_Q_THRESHOLD\";\n    param.function = speed_mpn_sbpi1_divappr_q;\n    param.function2 = speed_mpn_dcpi1_divappr_q;\n    param.min_size = 6;\n    one (&dc_divappr_q_threshold, &param);\n  }\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "speed_mpn_sbordcpi1_div_qr": {
      "start_point": [
        1645,
        0
      ],
      "end_point": [
        1652,
        1
      ],
      "content": "static double\nspeed_mpn_sbordcpi1_div_qr (struct speed_params *s)\n{\n  if (s->size < DC_DIV_QR_THRESHOLD)\n    return speed_mpn_sbpi1_div_qr (s);\n  else\n    return speed_mpn_dcpi1_div_qr (s);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "tune_mu_div": {
      "start_point": [
        1654,
        0
      ],
      "end_point": [
        1689,
        1
      ],
      "content": "void\ntune_mu_div (void)\n{\n  s.r = 0;\t\t/* clear to make speed function do 2n/n */\n  {\n    static struct param_t  param;\n    param.name = \"MU_DIV_QR_THRESHOLD\";\n    param.function = speed_mpn_dcpi1_div_qr;\n    param.function2 = speed_mpn_mu_div_qr;\n    param.min_size = mul_toom22_threshold;\n    param.max_size = 5000;\n    param.step_factor = 0.02;\n    one (&mu_div_qr_threshold, &param);\n  }\n  {\n    static struct param_t  param;\n    param.name = \"MU_DIVAPPR_Q_THRESHOLD\";\n    param.function = speed_mpn_dcpi1_divappr_q;\n    param.function2 = speed_mpn_mu_divappr_q;\n    param.min_size = mul_toom22_threshold;\n    param.max_size = 5000;\n    param.step_factor = 0.02;\n    one (&mu_divappr_q_threshold, &param);\n  }\n  {\n    static struct param_t  param;\n    param.name = \"MUPI_DIV_QR_THRESHOLD\";\n    param.function = speed_mpn_sbordcpi1_div_qr;\n    param.function2 = speed_mpn_mupi_div_qr;\n    param.min_size = 6;\n    param.min_is_always = 1;\n    param.max_size = 1000;\n    param.step_factor = 0.02;\n    one (&mupi_div_qr_threshold, &param);\n  }\n}",
      "lines": 36,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "tune_dc_bdiv": {
      "start_point": [
        1691,
        0
      ],
      "end_point": [
        1711,
        1
      ],
      "content": "void\ntune_dc_bdiv (void)\n{\n  s.r = 0;\t\t/* clear to make speed function do 2n/n*/\n  {\n    static struct param_t  param;\n    param.name = \"DC_BDIV_QR_THRESHOLD\";\n    param.function = speed_mpn_sbpi1_bdiv_qr;\n    param.function2 = speed_mpn_dcpi1_bdiv_qr;\n    param.min_size = 4;\n    one (&dc_bdiv_qr_threshold, &param);\n  }\n  {\n    static struct param_t  param;\n    param.name = \"DC_BDIV_Q_THRESHOLD\";\n    param.function = speed_mpn_sbpi1_bdiv_q;\n    param.function2 = speed_mpn_dcpi1_bdiv_q;\n    param.min_size = 4;\n    one (&dc_bdiv_q_threshold, &param);\n  }\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "tune_mu_bdiv": {
      "start_point": [
        1713,
        0
      ],
      "end_point": [
        1737,
        1
      ],
      "content": "void\ntune_mu_bdiv (void)\n{\n  s.r = 0;\t\t/* clear to make speed function do 2n/n*/\n  {\n    static struct param_t  param;\n    param.name = \"MU_BDIV_QR_THRESHOLD\";\n    param.function = speed_mpn_dcpi1_bdiv_qr;\n    param.function2 = speed_mpn_mu_bdiv_qr;\n    param.min_size = dc_bdiv_qr_threshold;\n    param.max_size = 5000;\n    param.step_factor = 0.02;\n    one (&mu_bdiv_qr_threshold, &param);\n  }\n  {\n    static struct param_t  param;\n    param.name = \"MU_BDIV_Q_THRESHOLD\";\n    param.function = speed_mpn_dcpi1_bdiv_q;\n    param.function2 = speed_mpn_mu_bdiv_q;\n    param.min_size = dc_bdiv_q_threshold;\n    param.max_size = 5000;\n    param.step_factor = 0.02;\n    one (&mu_bdiv_q_threshold, &param);\n  }\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "tune_invertappr": {
      "start_point": [
        1739,
        0
      ],
      "end_point": [
        1753,
        1
      ],
      "content": "void\ntune_invertappr (void)\n{\n  static struct param_t  param;\n\n  param.function = speed_mpn_ni_invertappr;\n  param.name = \"INV_MULMOD_BNM1_THRESHOLD\";\n  param.min_size = 5;\n  one (&inv_mulmod_bnm1_threshold, &param);\n\n  param.function = speed_mpn_invertappr;\n  param.name = \"INV_NEWTON_THRESHOLD\";\n  param.min_size = 5;\n  one (&inv_newton_threshold, &param);\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_invert": {
      "start_point": [
        1755,
        0
      ],
      "end_point": [
        1764,
        1
      ],
      "content": "void\ntune_invert (void)\n{\n  static struct param_t  param;\n\n  param.function = speed_mpn_invert;\n  param.name = \"INV_APPR_THRESHOLD\";\n  param.min_size = 5;\n  one (&inv_appr_threshold, &param);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_binvert": {
      "start_point": [
        1766,
        0
      ],
      "end_point": [
        1775,
        1
      ],
      "content": "void\ntune_binvert (void)\n{\n  static struct param_t  param;\n\n  param.function = speed_mpn_binvert;\n  param.name = \"BINV_NEWTON_THRESHOLD\";\n  param.min_size = 8;\t\t/* pointless with smaller operands */\n  one (&binv_newton_threshold, &param);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_redc": {
      "start_point": [
        1777,
        0
      ],
      "end_point": [
        1835,
        1
      ],
      "content": "void\ntune_redc (void)\n{\n#define TUNE_REDC_2_MAX 100\n#if HAVE_NATIVE_mpn_addmul_2 || HAVE_NATIVE_mpn_redc_2\n#define WANT_REDC_2 1\n#endif\n\n#if WANT_REDC_2\n  {\n    static struct param_t  param;\n    param.name = \"REDC_1_TO_REDC_2_THRESHOLD\";\n    param.function = speed_mpn_redc_1;\n    param.function2 = speed_mpn_redc_2;\n    param.min_size = 1;\n    param.min_is_always = 1;\n    param.max_size = TUNE_REDC_2_MAX;\n    param.noprint = 1;\n    param.stop_factor = 1.5;\n    one (&redc_1_to_redc_2_threshold, &param);\n  }\n  {\n    static struct param_t  param;\n    param.name = \"REDC_2_TO_REDC_N_THRESHOLD\";\n    param.function = speed_mpn_redc_2;\n    param.function2 = speed_mpn_redc_n;\n    param.min_size = 16;\n    param.noprint = 1;\n    one (&redc_2_to_redc_n_threshold, &param);\n  }\n  if (redc_1_to_redc_2_threshold >= redc_2_to_redc_n_threshold)\n    {\n      redc_2_to_redc_n_threshold = 0;\t/* disable redc_2 */\n\n      /* Never use redc2, measure redc_1 -> redc_n cutoff, store result as\n\t REDC_1_TO_REDC_2_THRESHOLD.  */\n      {\n\tstatic struct param_t  param;\n\tparam.name = \"REDC_1_TO_REDC_2_THRESHOLD\";\n\tparam.function = speed_mpn_redc_1;\n\tparam.function2 = speed_mpn_redc_n;\n\tparam.min_size = 16;\n\tparam.noprint = 1;\n\tone (&redc_1_to_redc_2_threshold, &param);\n      }\n    }\n  print_define (\"REDC_1_TO_REDC_2_THRESHOLD\", REDC_1_TO_REDC_2_THRESHOLD);\n  print_define (\"REDC_2_TO_REDC_N_THRESHOLD\", REDC_2_TO_REDC_N_THRESHOLD);\n#else\n  {\n    static struct param_t  param;\n    param.name = \"REDC_1_TO_REDC_N_THRESHOLD\";\n    param.function = speed_mpn_redc_1;\n    param.function2 = speed_mpn_redc_n;\n    param.min_size = 16;\n    one (&redc_1_to_redc_n_threshold, &param);\n  }\n#endif\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "tune_matrix22_mul": {
      "start_point": [
        1837,
        0
      ],
      "end_point": [
        1845,
        1
      ],
      "content": "void\ntune_matrix22_mul (void)\n{\n  static struct param_t  param;\n  param.name = \"MATRIX22_STRASSEN_THRESHOLD\";\n  param.function = speed_mpn_matrix22_mul;\n  param.min_size = 2;\n  one (&matrix22_strassen_threshold, &param);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_hgcd": {
      "start_point": [
        1847,
        0
      ],
      "end_point": [
        1856,
        1
      ],
      "content": "void\ntune_hgcd (void)\n{\n  static struct param_t  param;\n  param.name = \"HGCD_THRESHOLD\";\n  param.function = speed_mpn_hgcd;\n  /* We seem to get strange results for small sizes */\n  param.min_size = 30;\n  one (&hgcd_threshold, &param);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_hgcd_appr": {
      "start_point": [
        1858,
        0
      ],
      "end_point": [
        1868,
        1
      ],
      "content": "void\ntune_hgcd_appr (void)\n{\n  static struct param_t  param;\n  param.name = \"HGCD_APPR_THRESHOLD\";\n  param.function = speed_mpn_hgcd_appr;\n  /* We seem to get strange results for small sizes */\n  param.min_size = 50;\n  param.stop_since_change = 150;\n  one (&hgcd_appr_threshold, &param);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_hgcd_reduce": {
      "start_point": [
        1870,
        0
      ],
      "end_point": [
        1880,
        1
      ],
      "content": "void\ntune_hgcd_reduce (void)\n{\n  static struct param_t  param;\n  param.name = \"HGCD_REDUCE_THRESHOLD\";\n  param.function = speed_mpn_hgcd_reduce;\n  param.min_size = 30;\n  param.max_size = 7000;\n  param.step_factor = 0.04;\n  one (&hgcd_reduce_threshold, &param);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_gcd_dc": {
      "start_point": [
        1882,
        0
      ],
      "end_point": [
        1892,
        1
      ],
      "content": "void\ntune_gcd_dc (void)\n{\n  static struct param_t  param;\n  param.name = \"GCD_DC_THRESHOLD\";\n  param.function = speed_mpn_gcd;\n  param.min_size = hgcd_threshold;\n  param.max_size = 3000;\n  param.step_factor = 0.02;\n  one (&gcd_dc_threshold, &param);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_gcdext_dc": {
      "start_point": [
        1894,
        0
      ],
      "end_point": [
        1904,
        1
      ],
      "content": "void\ntune_gcdext_dc (void)\n{\n  static struct param_t  param;\n  param.name = \"GCDEXT_DC_THRESHOLD\";\n  param.function = speed_mpn_gcdext;\n  param.min_size = hgcd_threshold;\n  param.max_size = 3000;\n  param.step_factor = 0.02;\n  one (&gcdext_dc_threshold, &param);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "win_size": {
      "start_point": [
        1915,
        0
      ],
      "end_point": [
        1919,
        1
      ],
      "content": "int\nwin_size (mp_bitcnt_t eb)\n{\n  return winsize;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "tune_powm_sec": {
      "start_point": [
        1921,
        0
      ],
      "end_point": [
        2037,
        1
      ],
      "content": "void\ntune_powm_sec (void)\n{\n  mp_size_t n;\n  int k, i;\n  mp_size_t itch;\n  mp_bitcnt_t nbits, nbits_next, possible_nbits_cutoff;\n  const int n_max = 3000 / GMP_NUMB_BITS;\n  const int n_measurements = 5;\n  mp_ptr rp, bp, ep, mp, tp;\n  double ttab[n_measurements], tk, tkp1;\n  TMP_DECL;\n  TMP_MARK;\n\n  possible_nbits_cutoff = 0;\n\n  k = 1;\n\n  winsize = 10;\t\t\t/* the itch function needs this */\n  itch = mpn_sec_powm_itch (n_max, n_max * GMP_NUMB_BITS, n_max);\n\n  rp = TMP_ALLOC_LIMBS (n_max);\n  bp = TMP_ALLOC_LIMBS (n_max);\n  ep = TMP_ALLOC_LIMBS (n_max);\n  mp = TMP_ALLOC_LIMBS (n_max);\n  tp = TMP_ALLOC_LIMBS (itch);\n\n  mpn_random (bp, n_max);\n  mpn_random (mp, n_max);\n  mp[0] |= 1;\n\n/* How about taking the M operand size into account?\n\n   An operation R=powm(B,E,N) will take time O(log(E)*M(log(N))) (assuming\n   B = O(M)).\n\n   Using k-ary and no sliding window, the precomputation will need time\n   O(2^(k-1)*M(log(N))) and the main computation will need O(log(E)*S(N)) +\n   O(log(E)/k*M(N)), for the squarings, multiplications, respectively.\n\n   An operation R=powm_sec(B,E,N) will take time like powm.\n\n   Using k-ary, the precomputation will need time O(2^k*M(log(N))) and the\n   main computation will need O(log(E)*S(N)) + O(log(E)/k*M(N)) +\n   O(log(E)/k*2^k*log(N)), for the squarings, multiplications, and full\n   table reads, respectively.  */\n\n  printf (\"#define POWM_SEC_TABLE  \");\n\n  /* For nbits == 1, we should always use k == 1, so no need to tune\n     that. Starting with nbits == 2 also ensure that nbits always is\n     larger than the windowsize k+1. */\n  for (nbits = 2; nbits <= n_max * GMP_NUMB_BITS; )\n    {\n      n = (nbits - 1) / GMP_NUMB_BITS + 1;\n\n      /* Generate E such that sliding-window for k and k+1 works equally\n\t well/poorly (but sliding is not used in powm_sec, of course). */\n      for (i = 0; i < n; i++)\n\tep[i] = ~CNST_LIMB(0);\n\n      winsize = k;\n      for (i = 0; i < n_measurements; i++)\n\t{\n\t  speed_starttime ();\n\t  mpn_sec_powm (rp, bp, n, ep, nbits, mp, n, tp);\n\t  ttab[i] = speed_endtime ();\n\t}\n      tk = median (ttab, n_measurements);\n\n      winsize = k + 1;\n      speed_starttime ();\n      for (i = 0; i < n_measurements; i++)\n\t{\n\t  speed_starttime ();\n\t  mpn_sec_powm (rp, bp, n, ep, nbits, mp, n, tp);\n\t  ttab[i] = speed_endtime ();\n\t}\n      tkp1 = median (ttab, n_measurements);\n/*\n      printf (\"testing: %ld, %d\", nbits, k, ep[n-1]);\n      printf (\"   %10.5f  %10.5f\\n\", tk, tkp1);\n*/\n      if (tkp1 < tk)\n\t{\n\t  if (possible_nbits_cutoff)\n\t    {\n\t      /* Two consecutive sizes indicate k increase, obey.  */\n\n\t      /* Must always have x[k] >= k */\n\t      ASSERT_ALWAYS (possible_nbits_cutoff >= k);\n\n\t      if (k > 1)\n\t\tprintf (\",\");\n\t      printf (\"%ld\", (long) possible_nbits_cutoff);\n\t      k++;\n\t      possible_nbits_cutoff = 0;\n\t    }\n\t  else\n\t    {\n\t      /* One measurement indicate k increase, save nbits for further\n\t\t consideration.  */\n\t      /* The new larger k gets used for sizes > the cutoff\n\t\t value, hence the cutoff should be one less than the\n\t\t smallest size where it gives a speedup. */\n\t      possible_nbits_cutoff = nbits - 1;\n\t    }\n\t}\n      else\n\tpossible_nbits_cutoff = 0;\n\n      nbits_next = nbits * 65 / 64;\n      nbits = nbits_next + (nbits_next == nbits);\n    }\n  printf (\"\\n\");\n  TMP_FREE;\n}",
      "lines": 117,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "tune_divrem_1": {
      "start_point": [
        2060,
        0
      ],
      "end_point": [
        2109,
        1
      ],
      "content": "void\ntune_divrem_1 (void)\n{\n  /* plain version by default */\n  tuned_speed_mpn_divrem_1 = speed_mpn_divrem_1;\n\n  /* No support for tuning native assembler code, do that by hand and put\n     the results in the .asm file, there's no need for such thresholds to\n     appear in gmp-mparam.h.  */\n  if (HAVE_NATIVE_mpn_divrem_1)\n    return;\n\n  if (GMP_NAIL_BITS != 0)\n    {\n      print_define_remark (\"DIVREM_1_NORM_THRESHOLD\", MP_SIZE_T_MAX,\n                           \"no preinv with nails\");\n      print_define_remark (\"DIVREM_1_UNNORM_THRESHOLD\", MP_SIZE_T_MAX,\n                           \"no preinv with nails\");\n      return;\n    }\n\n  if (UDIV_PREINV_ALWAYS)\n    {\n      print_define_remark (\"DIVREM_1_NORM_THRESHOLD\", 0L, \"preinv always\");\n      print_define (\"DIVREM_1_UNNORM_THRESHOLD\", 0L);\n      return;\n    }\n\n  tuned_speed_mpn_divrem_1 = speed_mpn_divrem_1_tune;\n\n  /* Tune for the integer part of mpn_divrem_1.  This will very possibly be\n     a bit out for the fractional part, but that's too bad, the integer part\n     is more important. */\n  {\n    static struct param_t  param;\n    param.name = \"DIVREM_1_NORM_THRESHOLD\";\n    DIV_1_PARAMS;\n    s.r = randlimb_norm ();\n    param.function = speed_mpn_divrem_1_tune;\n    one (&divrem_1_norm_threshold, &param);\n  }\n  {\n    static struct param_t  param;\n    param.name = \"DIVREM_1_UNNORM_THRESHOLD\";\n    DIV_1_PARAMS;\n    s.r = randlimb_half ();\n    param.function = speed_mpn_divrem_1_tune;\n    one (&divrem_1_unnorm_threshold, &param);\n  }\n}",
      "lines": 50,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "tune_div_qr_1": {
      "start_point": [
        2111,
        0
      ],
      "end_point": [
        2158,
        1
      ],
      "content": "void\ntune_div_qr_1 (void)\n{\n  static struct param_t  param;\n  double            t1, t2;\n\n  if (!HAVE_NATIVE_mpn_div_qr_1n_pi1)\n    {\n      static struct param_t  param;\n      double   t1, t2;\n\n      s.size = 10;\n      s.r = randlimb_norm ();\n\n      t1 = tuneup_measure (speed_mpn_div_qr_1n_pi1_1, &param, &s);\n      t2 = tuneup_measure (speed_mpn_div_qr_1n_pi1_2, &param, &s);\n\n      if (t1 == -1.0 || t2 == -1.0)\n\t{\n\t  printf (\"Oops, can't measure all mpn_div_qr_1n_pi1 methods at %ld\\n\",\n\t\t  (long) s.size);\n\t  abort ();\n\t}\n      div_qr_1n_pi1_method = (t1 < t2) ? 1 : 2;\n      print_define (\"DIV_QR_1N_PI1_METHOD\", div_qr_1n_pi1_method);\n    }\n\n  {\n    static struct param_t  param;\n    param.name = \"DIV_QR_1_NORM_THRESHOLD\";\n    DIV_1_PARAMS;\n    param.min_size = 1;\n    param.min_is_always = 0;\n    s.r = randlimb_norm ();\n    param.function = speed_mpn_div_qr_1_tune;\n    one (&div_qr_1_norm_threshold, &param);\n  }\n  {\n    static struct param_t  param;\n    param.name = \"DIV_QR_1_UNNORM_THRESHOLD\";\n    DIV_1_PARAMS;\n    param.min_size = 1;\n    param.min_is_always = 0;\n    s.r = randlimb_half();\n    param.function = speed_mpn_div_qr_1_tune;\n    one (&div_qr_1_unnorm_threshold, &param);\n  }\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "tune_mod_1": {
      "start_point": [
        2161,
        0
      ],
      "end_point": [
        2302,
        1
      ],
      "content": "void\ntune_mod_1 (void)\n{\n  /* No support for tuning native assembler code, do that by hand and put\n     the results in the .asm file, there's no need for such thresholds to\n     appear in gmp-mparam.h.  */\n  if (HAVE_NATIVE_mpn_mod_1)\n    return;\n\n  if (GMP_NAIL_BITS != 0)\n    {\n      print_define_remark (\"MOD_1_NORM_THRESHOLD\", MP_SIZE_T_MAX,\n                           \"no preinv with nails\");\n      print_define_remark (\"MOD_1_UNNORM_THRESHOLD\", MP_SIZE_T_MAX,\n                           \"no preinv with nails\");\n      return;\n    }\n\n  if (!HAVE_NATIVE_mpn_mod_1_1p)\n    {\n      static struct param_t  param;\n      double   t1, t2;\n\n      s.size = 10;\n      s.r = randlimb_half ();\n\n      t1 = tuneup_measure (speed_mpn_mod_1_1_1, &param, &s);\n      t2 = tuneup_measure (speed_mpn_mod_1_1_2, &param, &s);\n\n      if (t1 == -1.0 || t2 == -1.0)\n\t{\n\t  printf (\"Oops, can't measure all mpn_mod_1_1 methods at %ld\\n\",\n\t\t  (long) s.size);\n\t  abort ();\n\t}\n      mod_1_1p_method = (t1 < t2) ? 1 : 2;\n      print_define (\"MOD_1_1P_METHOD\", mod_1_1p_method);\n    }\n\n  if (UDIV_PREINV_ALWAYS)\n    {\n      print_define (\"MOD_1_NORM_THRESHOLD\", 0L);\n      print_define (\"MOD_1_UNNORM_THRESHOLD\", 0L);\n    }\n  else\n    {\n      {\n\tstatic struct param_t  param;\n\tparam.name = \"MOD_1_NORM_THRESHOLD\";\n\tDIV_1_PARAMS;\n\ts.r = randlimb_norm ();\n\tparam.function = speed_mpn_mod_1_tune;\n\tone (&mod_1_norm_threshold, &param);\n      }\n      {\n\tstatic struct param_t  param;\n\tparam.name = \"MOD_1_UNNORM_THRESHOLD\";\n\tDIV_1_PARAMS;\n\ts.r = randlimb_half ();\n\tparam.function = speed_mpn_mod_1_tune;\n\tone (&mod_1_unnorm_threshold, &param);\n      }\n    }\n  {\n    static struct param_t  param;\n\n    param.check_size = 256;\n\n    s.r = randlimb_norm ();\n    param.function = speed_mpn_mod_1_tune;\n\n    param.name = \"MOD_1N_TO_MOD_1_1_THRESHOLD\";\n    param.min_size = 2;\n    one (&mod_1n_to_mod_1_1_threshold, &param);\n  }\n\n  {\n    static struct param_t  param;\n\n    param.check_size = 256;\n    s.r = randlimb_half ();\n    param.noprint = 1;\n\n    param.function = speed_mpn_mod_1_1;\n    param.function2 = speed_mpn_mod_1_2;\n    param.min_is_always = 1;\n    param.name = \"MOD_1_1_TO_MOD_1_2_THRESHOLD\";\n    param.min_size = 2;\n    one (&mod_1_1_to_mod_1_2_threshold, &param);\n\n    param.function = speed_mpn_mod_1_2;\n    param.function2 = speed_mpn_mod_1_4;\n    param.min_is_always = 1;\n    param.name = \"MOD_1_2_TO_MOD_1_4_THRESHOLD\";\n    param.min_size = 1;\n    one (&mod_1_2_to_mod_1_4_threshold, &param);\n\n    if (mod_1_1_to_mod_1_2_threshold >= mod_1_2_to_mod_1_4_threshold)\n      {\n\t/* Never use mod_1_2, measure mod_1_1 -> mod_1_4 */\n\tmod_1_2_to_mod_1_4_threshold = 0;\n\n\tparam.function = speed_mpn_mod_1_1;\n\tparam.function2 = speed_mpn_mod_1_4;\n\tparam.min_is_always = 1;\n\tparam.name = \"MOD_1_1_TO_MOD_1_4_THRESHOLD fake\";\n\tparam.min_size = 2;\n\tone (&mod_1_1_to_mod_1_2_threshold, &param);\n      }\n\n    param.function = speed_mpn_mod_1_tune;\n    param.function2 = NULL;\n    param.name = \"MOD_1U_TO_MOD_1_1_THRESHOLD\";\n    param.min_size = 2;\n    param.min_is_always = 0;\n    one (&mod_1u_to_mod_1_1_threshold, &param);\n\n    if (mod_1u_to_mod_1_1_threshold >= mod_1_1_to_mod_1_2_threshold)\n      mod_1_1_to_mod_1_2_threshold = 0;\n    if (mod_1u_to_mod_1_1_threshold >= mod_1_2_to_mod_1_4_threshold)\n      mod_1_2_to_mod_1_4_threshold = 0;\n\n    print_define_remark (\"MOD_1U_TO_MOD_1_1_THRESHOLD\", mod_1u_to_mod_1_1_threshold, NULL);\n    print_define_remark (\"MOD_1_1_TO_MOD_1_2_THRESHOLD\", mod_1_1_to_mod_1_2_threshold,\n\t\t\t mod_1_1_to_mod_1_2_threshold == 0 ? \"never mpn_mod_1_1p\" : NULL);\n    print_define_remark (\"MOD_1_2_TO_MOD_1_4_THRESHOLD\", mod_1_2_to_mod_1_4_threshold,\n\t\t\t mod_1_2_to_mod_1_4_threshold == 0 ? \"never mpn_mod_1s_2p\" : NULL);\n  }\n\n  {\n    static struct param_t  param;\n\n    param.check_size = 256;\n\n    param.name = \"PREINV_MOD_1_TO_MOD_1_THRESHOLD\";\n    s.r = randlimb_norm ();\n    param.function = speed_mpn_preinv_mod_1;\n    param.function2 = speed_mpn_mod_1_tune;\n    param.min_size = 1;\n    one (&preinv_mod_1_to_mod_1_threshold, &param);\n  }\n}",
      "lines": 142,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "tune_preinv_divrem_1": {
      "start_point": [
        2310,
        0
      ],
      "end_point": [
        2374,
        1
      ],
      "content": "void\ntune_preinv_divrem_1 (void)\n{\n  static struct param_t  param;\n  speed_function_t  divrem_1;\n  const char        *divrem_1_name;\n  double            t1, t2;\n\n  if (GMP_NAIL_BITS != 0)\n    {\n      print_define_remark (\"USE_PREINV_DIVREM_1\", 0, \"no preinv with nails\");\n      return;\n    }\n\n  /* Any native version of mpn_preinv_divrem_1 is assumed to exist because\n     it's faster than mpn_divrem_1.  */\n  if (HAVE_NATIVE_mpn_preinv_divrem_1)\n    {\n      print_define_remark (\"USE_PREINV_DIVREM_1\", 1, \"native\");\n      return;\n    }\n\n  /* If udiv_qrnnd_preinv is the only division method then of course\n     mpn_preinv_divrem_1 should be used.  */\n  if (UDIV_PREINV_ALWAYS)\n    {\n      print_define_remark (\"USE_PREINV_DIVREM_1\", 1, \"preinv always\");\n      return;\n    }\n\n  /* If we've got an assembler version of mpn_divrem_1, then compare against\n     that, not the mpn_divrem_1_div generic C.  */\n  if (HAVE_NATIVE_mpn_divrem_1)\n    {\n      divrem_1 = speed_mpn_divrem_1;\n      divrem_1_name = \"mpn_divrem_1\";\n    }\n  else\n    {\n      divrem_1 = speed_mpn_divrem_1_div;\n      divrem_1_name = \"mpn_divrem_1_div\";\n    }\n\n  param.data_high = DATA_HIGH_LT_R; /* allow skip one division */\n  s.size = 200;                     /* generous but not too big */\n  /* Divisor, nonzero.  Unnormalized so as to exercise the shift!=0 case,\n     since in general that's probably most common, though in fact for a\n     64-bit limb mp_bases[10].big_base is normalized.  */\n  s.r = urandom() & (GMP_NUMB_MASK >> 4);\n  if (s.r == 0) s.r = 123;\n\n  t1 = tuneup_measure (speed_mpn_preinv_divrem_1, &param, &s);\n  t2 = tuneup_measure (divrem_1, &param, &s);\n  if (t1 == -1.0 || t2 == -1.0)\n    {\n      printf (\"Oops, can't measure mpn_preinv_divrem_1 and %s at %ld\\n\",\n              divrem_1_name, (long) s.size);\n      abort ();\n    }\n  if (option_trace >= 1)\n    printf (\"size=%ld, mpn_preinv_divrem_1 %.9f, %s %.9f\\n\",\n            (long) s.size, t1, divrem_1_name, t2);\n\n  print_define_remark (\"USE_PREINV_DIVREM_1\", (mp_size_t) (t1 < t2), NULL);\n}",
      "lines": 65,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "tune_divrem_2": {
      "start_point": [
        2378,
        0
      ],
      "end_point": [
        2418,
        1
      ],
      "content": "void\ntune_divrem_2 (void)\n{\n  static struct param_t  param;\n\n  /* No support for tuning native assembler code, do that by hand and put\n     the results in the .asm file, and there's no need for such thresholds\n     to appear in gmp-mparam.h.  */\n  if (HAVE_NATIVE_mpn_divrem_2)\n    return;\n\n  if (GMP_NAIL_BITS != 0)\n    {\n      print_define_remark (\"DIVREM_2_THRESHOLD\", MP_SIZE_T_MAX,\n                           \"no preinv with nails\");\n      return;\n    }\n\n  if (UDIV_PREINV_ALWAYS)\n    {\n      print_define_remark (\"DIVREM_2_THRESHOLD\", 0L, \"preinv always\");\n      return;\n    }\n\n  /* Tune for the integer part of mpn_divrem_2.  This will very possibly be\n     a bit out for the fractional part, but that's too bad, the integer part\n     is more important.\n\n     min_size must be >=2 since nsize>=2 is required, but is set to 4 to save\n     code space if plain division is better only at size==2 or size==3. */\n  param.name = \"DIVREM_2_THRESHOLD\";\n  param.check_size = 256;\n  param.min_size = 4;\n  param.min_is_always = 1;\n  param.size_extra = 2;      /* does qsize==nsize-2 divisions */\n  param.stop_factor = 2.0;\n\n  s.r = randlimb_norm ();\n  param.function = speed_mpn_divrem_2;\n  one (&divrem_2_threshold, &param);\n}",
      "lines": 41,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "tune_div_qr_2": {
      "start_point": [
        2420,
        0
      ],
      "end_point": [
        2429,
        1
      ],
      "content": "void\ntune_div_qr_2 (void)\n{\n  static struct param_t  param;\n  param.name = \"DIV_QR_2_PI2_THRESHOLD\";\n  param.function = speed_mpn_div_qr_2n;\n  param.check_size = 500;\n  param.min_size = 4;\n  one (&div_qr_2_pi2_threshold, &param);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_divexact_1": {
      "start_point": [
        2439,
        0
      ],
      "end_point": [
        2506,
        1
      ],
      "content": "void\ntune_divexact_1 (void)\n{\n  static struct param_t  param;\n  mp_size_t  thresh[2], average;\n  int        low, i;\n\n  /* Any native mpn_divexact_1 is assumed to incorporate all the speed of a\n     full mpn_divrem_1.  */\n  if (HAVE_NATIVE_mpn_divexact_1)\n    {\n      print_define_remark (\"DIVEXACT_1_THRESHOLD\", 0, \"always (native)\");\n      return;\n    }\n\n  ASSERT_ALWAYS (tuned_speed_mpn_divrem_1 != NULL);\n\n  param.name = \"DIVEXACT_1_THRESHOLD\";\n  param.data_high = DATA_HIGH_GE_R;\n  param.check_size = 256;\n  param.min_size = 2;\n  param.stop_factor = 1.5;\n  param.function  = tuned_speed_mpn_divrem_1;\n  param.function2 = speed_mpn_divexact_1;\n  param.noprint = 1;\n\n  print_define_start (param.name);\n\n  for (low = 0; low <= 1; low++)\n    {\n      s.r = randlimb_half();\n      if (low == 0)\n        s.r |= 1;\n      else\n        s.r &= ~CNST_LIMB(7);\n\n      one (&thresh[low], &param);\n      if (option_trace)\n        printf (\"low=%d thresh %ld\\n\", low, (long) thresh[low]);\n\n      if (thresh[low] == MP_SIZE_T_MAX)\n        {\n          average = MP_SIZE_T_MAX;\n          goto divexact_1_done;\n        }\n    }\n\n  if (option_trace)\n    {\n      printf (\"average of:\");\n      for (i = 0; i < numberof(thresh); i++)\n        printf (\" %ld\", (long) thresh[i]);\n      printf (\"\\n\");\n    }\n\n  average = 0;\n  for (i = 0; i < numberof(thresh); i++)\n    average += thresh[i];\n  average /= numberof(thresh);\n\n  /* If divexact turns out to be better as early as 3 limbs, then use it\n     always, so as to reduce code size and conditional jumps.  */\n  if (average <= 3)\n    average = 0;\n\n divexact_1_done:\n  print_define_end (param.name, average);\n}",
      "lines": 68,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "tune_modexact_1_odd": {
      "start_point": [
        2517,
        0
      ],
      "end_point": [
        2566,
        1
      ],
      "content": "void\ntune_modexact_1_odd (void)\n{\n  static struct param_t  param;\n  mp_size_t  thresh_lt, thresh_ge, average;\n\n#if 0\n  /* Any native mpn_modexact_1_odd is assumed to incorporate all the speed\n     of a full mpn_mod_1.  */\n  if (HAVE_NATIVE_mpn_modexact_1_odd)\n    {\n      print_define_remark (\"BMOD_1_TO_MOD_1_THRESHOLD\", MP_SIZE_T_MAX, \"always bmod_1\");\n      return;\n    }\n#endif\n\n  param.name = \"BMOD_1_TO_MOD_1_THRESHOLD\";\n  param.check_size = 256;\n  param.min_size = 2;\n  param.stop_factor = 1.5;\n  param.function  = speed_mpn_modexact_1c_odd;\n  param.function2 = speed_mpn_mod_1_tune;\n  param.noprint = 1;\n  s.r = randlimb_half () | 1;\n\n  print_define_start (param.name);\n\n  param.data_high = DATA_HIGH_LT_R;\n  one (&thresh_lt, &param);\n  if (option_trace)\n    printf (\"lt thresh %ld\\n\", (long) thresh_lt);\n\n  average = thresh_lt;\n  if (thresh_lt != MP_SIZE_T_MAX)\n    {\n      param.data_high = DATA_HIGH_GE_R;\n      one (&thresh_ge, &param);\n      if (option_trace)\n        printf (\"ge thresh %ld\\n\", (long) thresh_ge);\n\n      if (thresh_ge != MP_SIZE_T_MAX)\n        {\n          average = (thresh_ge + thresh_lt) / 2;\n          if (thresh_ge <= 3)\n            average = 0;\n        }\n    }\n\n  print_define_end (param.name, average);\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "tune_jacobi_base": {
      "start_point": [
        2569,
        0
      ],
      "end_point": [
        2611,
        1
      ],
      "content": "void\ntune_jacobi_base (void)\n{\n  static struct param_t  param;\n  double   t1, t2, t3, t4;\n  int      method;\n\n  s.size = GMP_LIMB_BITS * 3 / 4;\n\n  t1 = tuneup_measure (speed_mpn_jacobi_base_1, &param, &s);\n  if (option_trace >= 1)\n    printf (\"size=%ld, mpn_jacobi_base_1 %.9f\\n\", (long) s.size, t1);\n\n  t2 = tuneup_measure (speed_mpn_jacobi_base_2, &param, &s);\n  if (option_trace >= 1)\n    printf (\"size=%ld, mpn_jacobi_base_2 %.9f\\n\", (long) s.size, t2);\n\n  t3 = tuneup_measure (speed_mpn_jacobi_base_3, &param, &s);\n  if (option_trace >= 1)\n    printf (\"size=%ld, mpn_jacobi_base_3 %.9f\\n\", (long) s.size, t3);\n\n  t4 = tuneup_measure (speed_mpn_jacobi_base_4, &param, &s);\n  if (option_trace >= 1)\n    printf (\"size=%ld, mpn_jacobi_base_4 %.9f\\n\", (long) s.size, t4);\n\n  if (t1 == -1.0 || t2 == -1.0 || t3 == -1.0 || t4 == -1.0)\n    {\n      printf (\"Oops, can't measure all mpn_jacobi_base methods at %ld\\n\",\n              (long) s.size);\n      abort ();\n    }\n\n  if (t1 < t2 && t1 < t3 && t1 < t4)\n    method = 1;\n  else if (t2 < t3 && t2 < t4)\n    method = 2;\n  else if (t3 < t4)\n    method = 3;\n  else\n    method = 4;\n\n  print_define (\"JACOBI_BASE_METHOD\", method);\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "tune_get_str": {
      "start_point": [
        2614,
        0
      ],
      "end_point": [
        2637,
        1
      ],
      "content": "void\ntune_get_str (void)\n{\n  /* Tune for decimal, it being most common.  Some rough testing suggests\n     other bases are different, but not by very much.  */\n  s.r = 10;\n  {\n    static struct param_t  param;\n    GET_STR_PRECOMPUTE_THRESHOLD = 0;\n    param.name = \"GET_STR_DC_THRESHOLD\";\n    param.function = speed_mpn_get_str;\n    param.min_size = 4;\n    param.max_size = GET_STR_THRESHOLD_LIMIT;\n    one (&get_str_dc_threshold, &param);\n  }\n  {\n    static struct param_t  param;\n    param.name = \"GET_STR_PRECOMPUTE_THRESHOLD\";\n    param.function = speed_mpn_get_str;\n    param.min_size = GET_STR_DC_THRESHOLD;\n    param.max_size = GET_STR_THRESHOLD_LIMIT;\n    one (&get_str_precompute_threshold, &param);\n  }\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "speed_mpn_pre_set_str": {
      "start_point": [
        2640,
        0
      ],
      "end_point": [
        2695,
        1
      ],
      "content": "double\nspeed_mpn_pre_set_str (struct speed_params *s)\n{\n  unsigned char *str;\n  mp_ptr     wp;\n  mp_size_t  wn;\n  unsigned   i;\n  int        base;\n  double     t;\n  mp_ptr powtab_mem, tp;\n  powers_t powtab[GMP_LIMB_BITS];\n  mp_size_t un;\n  int chars_per_limb;\n  TMP_DECL;\n\n  SPEED_RESTRICT_COND (s->size >= 1);\n\n  base = s->r == 0 ? 10 : s->r;\n  SPEED_RESTRICT_COND (base >= 2 && base <= 256);\n\n  TMP_MARK;\n\n  str = (unsigned char *) TMP_ALLOC (s->size);\n  for (i = 0; i < s->size; i++)\n    str[i] = s->xp[i] % base;\n\n  LIMBS_PER_DIGIT_IN_BASE (wn, s->size, base);\n  SPEED_TMP_ALLOC_LIMBS (wp, wn, s->align_wp);\n\n  /* use this during development to check wn is big enough */\n  /*\n  ASSERT_ALWAYS (mpn_set_str (wp, str, s->size, base) <= wn);\n  */\n\n  speed_operand_src (s, (mp_ptr) str, s->size/GMP_LIMB_BYTES);\n  speed_operand_dst (s, wp, wn);\n  speed_cache_fill (s);\n\n  chars_per_limb = mp_bases[base].chars_per_limb;\n  un = s->size / chars_per_limb + 1;\n  powtab_mem = TMP_BALLOC_LIMBS (mpn_dc_set_str_powtab_alloc (un));\n  mpn_set_str_compute_powtab (powtab, powtab_mem, un, base);\n  tp = TMP_BALLOC_LIMBS (mpn_dc_set_str_itch (un));\n\n  speed_starttime ();\n  i = s->reps;\n  do\n    {\n      mpn_pre_set_str (wp, str, s->size, powtab, tp);\n    }\n  while (--i != 0);\n  t = speed_endtime ();\n\n  TMP_FREE;\n  return t;\n}",
      "lines": 56,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "tune_set_str": {
      "start_point": [
        2697,
        0
      ],
      "end_point": [
        2720,
        1
      ],
      "content": "void\ntune_set_str (void)\n{\n  s.r = 10;  /* decimal */\n  {\n    static struct param_t  param;\n    SET_STR_PRECOMPUTE_THRESHOLD = 0;\n    param.step_factor = 0.01;\n    param.name = \"SET_STR_DC_THRESHOLD\";\n    param.function = speed_mpn_pre_set_str;\n    param.min_size = 100;\n    param.max_size = 50000;\n    one (&set_str_dc_threshold, &param);\n  }\n  {\n    static struct param_t  param;\n    param.step_factor = 0.02;\n    param.name = \"SET_STR_PRECOMPUTE_THRESHOLD\";\n    param.function = speed_mpn_set_str;\n    param.min_size = SET_STR_DC_THRESHOLD;\n    param.max_size = 100000;\n    one (&set_str_precompute_threshold, &param);\n  }\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "tune_fft_mul": {
      "start_point": [
        2723,
        0
      ],
      "end_point": [
        2743,
        1
      ],
      "content": "void\ntune_fft_mul (void)\n{\n  static struct fft_param_t  param;\n\n  if (option_fft_max_size == 0)\n    return;\n\n  param.table_name          = \"MUL_FFT_TABLE3\";\n  param.threshold_name      = \"MUL_FFT_THRESHOLD\";\n  param.p_threshold         = &mul_fft_threshold;\n  param.modf_threshold_name = \"MUL_FFT_MODF_THRESHOLD\";\n  param.p_modf_threshold    = &mul_fft_modf_threshold;\n  param.first_size          = MUL_TOOM33_THRESHOLD / 2;\n  param.max_size            = option_fft_max_size;\n  param.function            = speed_mpn_fft_mul;\n  param.mul_modf_function   = speed_mpn_mul_fft;\n  param.mul_function        = speed_mpn_mul_n;\n  param.sqr = 0;\n  fft (&param);\n}",
      "lines": 21,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_fft_sqr": {
      "start_point": [
        2746,
        0
      ],
      "end_point": [
        2766,
        1
      ],
      "content": "void\ntune_fft_sqr (void)\n{\n  static struct fft_param_t  param;\n\n  if (option_fft_max_size == 0)\n    return;\n\n  param.table_name          = \"SQR_FFT_TABLE3\";\n  param.threshold_name      = \"SQR_FFT_THRESHOLD\";\n  param.p_threshold         = &sqr_fft_threshold;\n  param.modf_threshold_name = \"SQR_FFT_MODF_THRESHOLD\";\n  param.p_modf_threshold    = &sqr_fft_modf_threshold;\n  param.first_size          = SQR_TOOM3_THRESHOLD / 2;\n  param.max_size            = option_fft_max_size;\n  param.function            = speed_mpn_fft_sqr;\n  param.mul_modf_function   = speed_mpn_mul_fft_sqr;\n  param.mul_function        = speed_mpn_sqr;\n  param.sqr = 1;\n  fft (&param);\n}",
      "lines": 21,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tune_fac_ui": {
      "start_point": [
        2768,
        0
      ],
      "end_point": [
        2785,
        1
      ],
      "content": "void\ntune_fac_ui (void)\n{\n  static struct param_t  param;\n\n  param.function = speed_mpz_fac_ui_tune;\n\n  param.name = \"FAC_DSC_THRESHOLD\";\n  param.min_size = 70;\n  param.max_size = FAC_DSC_THRESHOLD_LIMIT;\n  one (&fac_dsc_threshold, &param);\n\n  param.name = \"FAC_ODD_THRESHOLD\";\n  param.min_size = 22;\n  param.stop_factor = 1.7;\n  param.min_is_always = 1;\n  one (&fac_odd_threshold, &param);\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "all": {
      "start_point": [
        2787,
        0
      ],
      "end_point": [
        2931,
        1
      ],
      "content": "void\nall (void)\n{\n  time_t  start_time, end_time;\n  TMP_DECL;\n\n  TMP_MARK;\n  SPEED_TMP_ALLOC_LIMBS (s.xp_block, SPEED_BLOCK_SIZE, 0);\n  SPEED_TMP_ALLOC_LIMBS (s.yp_block, SPEED_BLOCK_SIZE, 0);\n\n  mpn_random (s.xp_block, SPEED_BLOCK_SIZE);\n  mpn_random (s.yp_block, SPEED_BLOCK_SIZE);\n\n  fprintf (stderr, \"Parameters for %s\\n\", GMP_MPARAM_H_SUGGEST);\n\n  speed_time_init ();\n  fprintf (stderr, \"Using: %s\\n\", speed_time_string);\n\n  fprintf (stderr, \"speed_precision %d\", speed_precision);\n  if (speed_unittime == 1.0)\n    fprintf (stderr, \", speed_unittime 1 cycle\");\n  else\n    fprintf (stderr, \", speed_unittime %.2e secs\", speed_unittime);\n  if (speed_cycletime == 1.0 || speed_cycletime == 0.0)\n    fprintf (stderr, \", CPU freq unknown\\n\");\n  else\n    fprintf (stderr, \", CPU freq %.2f MHz\\n\", 1e-6/speed_cycletime);\n\n  fprintf (stderr, \"DEFAULT_MAX_SIZE %d, fft_max_size %ld\\n\",\n           DEFAULT_MAX_SIZE, (long) option_fft_max_size);\n  fprintf (stderr, \"\\n\");\n\n  time (&start_time);\n  {\n    struct tm  *tp;\n    tp = localtime (&start_time);\n    printf (\"/* Generated by tuneup.c, %d-%02d-%02d, \",\n            tp->tm_year+1900, tp->tm_mon+1, tp->tm_mday);\n\n#ifdef __GNUC__\n    /* gcc sub-minor version doesn't seem to come through as a define */\n    printf (\"gcc %d.%d */\\n\", __GNUC__, __GNUC_MINOR__);\n#define PRINTED_COMPILER\n#endif\n#if defined (__SUNPRO_C)\n    printf (\"Sun C %d.%d */\\n\", __SUNPRO_C / 0x100, __SUNPRO_C % 0x100);\n#define PRINTED_COMPILER\n#endif\n#if ! defined (__GNUC__) && defined (__sgi) && defined (_COMPILER_VERSION)\n    /* gcc defines __sgi and _COMPILER_VERSION on irix 6, avoid that */\n    printf (\"MIPSpro C %d.%d.%d */\\n\",\n\t    _COMPILER_VERSION / 100,\n\t    _COMPILER_VERSION / 10 % 10,\n\t    _COMPILER_VERSION % 10);\n#define PRINTED_COMPILER\n#endif\n#if defined (__DECC) && defined (__DECC_VER)\n    printf (\"DEC C %d */\\n\", __DECC_VER);\n#define PRINTED_COMPILER\n#endif\n#if ! defined (PRINTED_COMPILER)\n    printf (\"system compiler */\\n\");\n#endif\n  }\n  printf (\"\\n\");\n\n  tune_divrem_1 ();\n  tune_mod_1 ();\n  tune_preinv_divrem_1 ();\n  tune_div_qr_1 ();\n#if 0\n  tune_divrem_2 ();\n#endif\n  tune_div_qr_2 ();\n  tune_divexact_1 ();\n  tune_modexact_1_odd ();\n  printf(\"\\n\");\n\n  tune_mul_n ();\n  printf(\"\\n\");\n\n  tune_mul ();\n  printf(\"\\n\");\n\n  tune_sqr ();\n  printf(\"\\n\");\n\n  tune_mulmid ();\n  printf(\"\\n\");\n\n  tune_mulmod_bnm1 ();\n  tune_sqrmod_bnm1 ();\n  printf(\"\\n\");\n\n  tune_fft_mul ();\n  printf(\"\\n\");\n\n  tune_fft_sqr ();\n  printf (\"\\n\");\n\n  tune_mullo ();\n  tune_sqrlo ();\n  printf(\"\\n\");\n\n  tune_dc_div ();\n  tune_dc_bdiv ();\n\n  printf(\"\\n\");\n  tune_invertappr ();\n  tune_invert ();\n  printf(\"\\n\");\n\n  tune_binvert ();\n  tune_redc ();\n  printf(\"\\n\");\n\n  tune_mu_div ();\n  tune_mu_bdiv ();\n  printf(\"\\n\");\n\n  tune_powm_sec ();\n  printf(\"\\n\");\n\n  tune_get_str ();\n  tune_set_str ();\n  printf(\"\\n\");\n\n  tune_fac_ui ();\n  printf(\"\\n\");\n\n  tune_matrix22_mul ();\n  tune_hgcd ();\n  tune_hgcd_appr ();\n  tune_hgcd_reduce();\n  tune_gcd_dc ();\n  tune_gcdext_dc ();\n  tune_jacobi_base ();\n  printf(\"\\n\");\n\n  time (&end_time);\n  printf (\"/* Tuneup completed successfully, took %ld seconds */\\n\",\n          (long) (end_time - start_time));\n\n  TMP_FREE;\n}",
      "lines": 145,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        2934,
        0
      ],
      "end_point": [
        2969,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int  opt;\n\n  /* Unbuffered so if output is redirected to a file it isn't lost if the\n     program is killed part way through.  */\n  setbuf (stdout, NULL);\n  setbuf (stderr, NULL);\n\n  while ((opt = getopt(argc, argv, \"f:o:p:t\")) != EOF)\n    {\n      switch (opt) {\n      case 'f':\n        if (optarg[0] == 't')\n          option_fft_trace = 2;\n        else\n          option_fft_max_size = atol (optarg);\n        break;\n      case 'o':\n        speed_option_set (optarg);\n        break;\n      case 'p':\n        speed_precision = atoi (optarg);\n        break;\n      case 't':\n        option_trace++;\n        break;\n      case '?':\n        exit(1);\n      }\n    }\n\n  all ();\n  exit (0);\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  }
}