{
  "osip/libosip2-5.0.0/include/osip2/internal.h": {},
  "osip/libosip2-5.0.0/include/osip2/osip.h": {},
  "osip/libosip2-5.0.0/include/osip2/osip_condv.h": {},
  "osip/libosip2-5.0.0/include/osip2/osip_dialog.h": {},
  "osip/libosip2-5.0.0/include/osip2/osip_fifo.h": {},
  "osip/libosip2-5.0.0/include/osip2/osip_mt.h": {},
  "osip/libosip2-5.0.0/include/osip2/osip_time.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/internal.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/osip_body.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/osip_const.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/osip_headers.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/osip_list.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/osip_md5.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/osip_message.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/osip_parser.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/osip_port.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/osip_uri.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/sdp_message.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_accept.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_accept_encoding.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_accept_language.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_alert_info.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_allow.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_authentication_info.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_authorization.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_call_id.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_call_info.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_contact.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_content_disposition.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_content_encoding.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_content_length.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_content_type.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_cseq.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_error_info.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_from.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_header.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_mime_version.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_proxy_authenticate.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_proxy_authentication_info.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_proxy_authorization.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_record_route.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_route.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_to.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_via.h": {},
  "osip/libosip2-5.0.0/include/osipparser2/headers/osip_www_authenticate.h": {},
  "osip/libosip2-5.0.0/src/osip2/fsm.h": {},
  "osip/libosip2-5.0.0/src/osip2/fsm_misc.c": {
    "fsm_findmethod": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static transition_t *\nfsm_findmethod (type_t type, state_t state, osip_statemachine_t * statemachine)\n{\n  transition_t *transition;\n\n  for (transition = statemachine->transitions; transition != NULL; transition = transition->next) {\n    if (transition->type == type && transition->state == state)\n      return transition;\n  }\n  return NULL;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "transition_t",
        "*\nfsm_findmethod (type_t type, state_t state, osip_statemachine_t * statemachine)",
        "*"
      ]
    },
    "fsm_callmethod": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nfsm_callmethod (type_t type, state_t state, osip_statemachine_t * statemachine, void *sipevent, void *transaction)\n{\n  transition_t *transition;\n\n  transition = fsm_findmethod (type, state, statemachine);\n  if (transition == NULL) {\n    /* No transition found for this event */\n    return OSIP_UNDEFINED_ERROR;        /* error */\n  }\n  transition->method (transaction, sipevent);\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/ict.c": {
    "__osip_ict_init": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\n__osip_ict_init (osip_ict_t ** ict, osip_t * osip, osip_message_t * invite)\n{\n  osip_route_t *route;\n  int i;\n\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"allocating ICT context\\n\"));\n\n  *ict = (osip_ict_t *) osip_malloc (sizeof (osip_ict_t));\n  if (*ict == NULL)\n    return OSIP_NOMEM;\n\n  memset (*ict, 0, sizeof (osip_ict_t));\n  /* for INVITE retransmissions */\n  {\n    osip_via_t *via;\n    char *proto;\n\n    i = osip_message_get_via (invite, 0, &via); /* get top via */\n    if (i < 0) {\n      osip_free (*ict);\n      return i;\n    }\n    proto = via_get_protocol (via);\n    if (proto == NULL) {\n      osip_free (*ict);\n      return OSIP_SYNTAXERROR;\n    }\n#ifdef USE_BLOCKINGSOCKET\n    if (osip_strcasecmp (proto, \"TCP\") != 0 && osip_strcasecmp (proto, \"TLS\") != 0 && osip_strcasecmp (proto, \"SCTP\") != 0) {   /* for other reliable protocol than TCP, the timer\n                                                                                                                                   must be desactived by the external application */\n      (*ict)->timer_a_length = DEFAULT_T1;\n      if (64 * DEFAULT_T1 < 32000)\n        (*ict)->timer_d_length = 32000;\n      else\n        (*ict)->timer_d_length = 64 * DEFAULT_T1;\n      osip_gettimeofday (&(*ict)->timer_a_start, NULL);\n      add_gettimeofday (&(*ict)->timer_a_start, (*ict)->timer_a_length);\n      (*ict)->timer_d_start.tv_sec = -1;        /* not started */\n    }\n    else {                      /* reliable protocol is used: */\n      (*ict)->timer_a_length = -1;      /* A is not ACTIVE */\n      (*ict)->timer_d_length = 0;       /* MUST do the transition immediatly */\n      (*ict)->timer_a_start.tv_sec = -1;        /* not started */\n      (*ict)->timer_d_start.tv_sec = -1;        /* not started */\n    }\n  }\n#else\n    if (osip_strcasecmp (proto, \"TCP\") != 0 && osip_strcasecmp (proto, \"TLS\") != 0 && osip_strcasecmp (proto, \"SCTP\") != 0) {   /* for other reliable protocol than TCP, the timer\n                                                                                                                                   must be desactived by the external application */\n      (*ict)->timer_a_length = DEFAULT_T1;\n      if (64 * DEFAULT_T1 < 32000)\n        (*ict)->timer_d_length = 32000;\n      else\n        (*ict)->timer_d_length = 64 * DEFAULT_T1;\n      osip_gettimeofday (&(*ict)->timer_a_start, NULL);\n      add_gettimeofday (&(*ict)->timer_a_start, (*ict)->timer_a_length);\n      (*ict)->timer_d_start.tv_sec = -1;        /* not started */\n    }\n    else {                      /* reliable protocol is used: */\n      (*ict)->timer_a_length = DEFAULT_T1;\n      (*ict)->timer_d_length = 0;       /* MUST do the transition immediatly */\n      osip_gettimeofday (&(*ict)->timer_a_start, NULL);\n      add_gettimeofday (&(*ict)->timer_a_start, (*ict)->timer_a_length);\n      (*ict)->timer_d_start.tv_sec = -1;        /* not started */\n    }\n  }\n#endif\n\n  /* for PROXY, the destination MUST be set by the application layer,\n     this one may not be correct. */\n  osip_message_get_route (invite, 0, &route);\n  if (route != NULL && route->url != NULL) {\n    osip_uri_param_t *lr_param;\n\n    osip_uri_uparam_get_byname (route->url, \"lr\", &lr_param);\n    if (lr_param == NULL) {\n      /* using uncompliant proxy: destination is the request-uri */\n      route = NULL;\n    }\n  }\n\n  if (route != NULL && route->url != NULL) {\n    int port = 5060;\n\n    if (route->url->port != NULL)\n      port = osip_atoi (route->url->port);\n    osip_ict_set_destination ((*ict), osip_strdup (route->url->host), port);\n  }\n  else {\n    int port = 5060;\n\n    /* search for maddr parameter */\n    osip_uri_param_t *maddr_param = NULL;\n    osip_uri_param_t *obr_param = NULL;\n    osip_uri_param_t *obp_param = NULL;\n\n    port = 5060;\n    if (invite->req_uri->port != NULL)\n      port = osip_atoi (invite->req_uri->port);\n\n    /* if ob was used in Contact, then exosip adds \"x-obr\" and \"x-obp\", thus, when\n    processing request, the ip/port destination are re-used here */\n    osip_uri_uparam_get_byname(invite->req_uri, \"x-obr\", &obr_param);\n    osip_uri_uparam_get_byname(invite->req_uri, \"x-obp\", &obp_param);\n\n    osip_uri_uparam_get_byname (invite->req_uri, \"maddr\", &maddr_param);\n    if (maddr_param != NULL && maddr_param->gvalue != NULL)\n      osip_ict_set_destination ((*ict), osip_strdup (maddr_param->gvalue), port);\n    else if (obr_param != NULL && obr_param->gvalue != NULL && obp_param != NULL && obp_param->gvalue != NULL)\n      osip_ict_set_destination ((*ict), osip_strdup (obr_param->gvalue), osip_atoi(obp_param->gvalue));\n    else\n      osip_ict_set_destination ((*ict), osip_strdup (invite->req_uri->host), port);\n  }\n\n  (*ict)->timer_b_length = 64 * DEFAULT_T1;\n  osip_gettimeofday (&(*ict)->timer_b_start, NULL);\n  add_gettimeofday (&(*ict)->timer_b_start, (*ict)->timer_b_length);\n\n  /* Oups! A bug! */\n  /*  (*ict)->port  = 5060; */\n\n  return OSIP_SUCCESS;\n}\n\nint\n__osip_ict_free (osip_ict_t * ict)\n{\n  if (ict == NULL)\n    return OSIP_SUCCESS;\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"free ict resource\\n\"));\n\n  osip_free (ict->destination);\n  osip_free (ict);\n  return OSIP_SUCCESS;\n}\n\nint\nosip_ict_set_destination (osip_ict_t * ict, char *destination, int port)\n{\n  if (ict == NULL)\n    return OSIP_BADPARAMETER;\n  if (ict->destination != NULL)\n    osip_free (ict->destination);\n  ict->destination = destination;\n  ict->port = port;\n  return OSIP_SUCCESS;\n}\n\nosip_event_t *\n__osip_ict_need_timer_a_event (osip_ict_t * ict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (ict, &ict->timer_a_start, state == ICT_CALLING, transactionid, TIMEOUT_A);\n}\n\nosip_event_t *\n__osip_ict_need_timer_b_event (osip_ict_t * ict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (ict, &ict->timer_b_start, state == ICT_CALLING, transactionid, TIMEOUT_B);\n}\n\nosip_event_t *\n__osip_ict_need_timer_d_event (osip_ict_t * ict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (ict, &ict->timer_d_start, state == ICT_COMPLETED, transactionid, TIMEOUT_D);\n}",
      "lines": 166,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "__osip_ict_free": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "int\n__osip_ict_free (osip_ict_t * ict)\n{\n  if (ict == NULL)\n    return OSIP_SUCCESS;\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"free ict resource\\n\"));\n\n  osip_free (ict->destination);\n  osip_free (ict);\n  return OSIP_SUCCESS;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_ict_set_destination": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\nosip_ict_set_destination (osip_ict_t * ict, char *destination, int port)\n{\n  if (ict == NULL)\n    return OSIP_BADPARAMETER;\n  if (ict->destination != NULL)\n    osip_free (ict->destination);\n  ict->destination = destination;\n  ict->port = port;\n  return OSIP_SUCCESS;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "__osip_ict_need_timer_a_event": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "osip_event_t *\n__osip_ict_need_timer_a_event (osip_ict_t * ict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (ict, &ict->timer_a_start, state == ICT_CALLING, transactionid, TIMEOUT_A);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "osip_event_t",
        "*\n__osip_ict_need_timer_a_event (osip_ict_t * ict, state_t state, int transactionid)",
        "*"
      ]
    },
    "__osip_ict_need_timer_b_event": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "osip_event_t *\n__osip_ict_need_timer_b_event (osip_ict_t * ict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (ict, &ict->timer_b_start, state == ICT_CALLING, transactionid, TIMEOUT_B);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "osip_event_t",
        "*\n__osip_ict_need_timer_b_event (osip_ict_t * ict, state_t state, int transactionid)",
        "*"
      ]
    },
    "__osip_ict_need_timer_d_event": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "osip_event_t *\n__osip_ict_need_timer_d_event (osip_ict_t * ict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (ict, &ict->timer_d_start, state == ICT_COMPLETED, transactionid, TIMEOUT_D);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "osip_event_t",
        "*\n__osip_ict_need_timer_d_event (osip_ict_t * ict, state_t state, int transactionid)",
        "*"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/ict_fsm.c": {
    "ict_handle_transport_error": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static void\nict_handle_transport_error (osip_transaction_t * ict, int err)\n{\n  __osip_transport_error_callback (OSIP_ICT_TRANSPORT_ERROR, ict, err);\n  __osip_transaction_set_state (ict, ICT_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_ICT_KILL_TRANSACTION, ict);\n  /* TODO: MUST BE DELETED NOW */\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ict_snd_invite": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "void\nict_snd_invite (osip_transaction_t * ict, osip_event_t * evt)\n{\n  int i;\n  osip_t *osip = (osip_t *) ict->config;\n\n  /* Here we have ict->orig_request == NULL */\n  ict->orig_request = evt->sip;\n\n  i = osip->cb_send_message (ict, evt->sip, ict->ict_context->destination, ict->ict_context->port, ict->out_socket);\n\n  if (i < 0) {\n    ict_handle_transport_error (ict, i);\n    return;\n  }\n#ifndef USE_BLOCKINGSOCKET\n  /*\n     stop timer E in reliable transport - non blocking socket: \n     the message was just sent\n   */\n  if (i == 0) {                 /* but message was really sent */\n    osip_via_t *via;\n    char *proto;\n\n    i = osip_message_get_via (ict->orig_request, 0, &via);      /* get top via */\n    if (i < 0) {\n      ict_handle_transport_error (ict, i);\n      return;\n    }\n    proto = via_get_protocol (via);\n    if (proto == NULL) {\n      ict_handle_transport_error (ict, i);\n      return;\n    }\n    if (osip_strcasecmp (proto, \"TCP\") != 0 && osip_strcasecmp (proto, \"TLS\") != 0 && osip_strcasecmp (proto, \"SCTP\") != 0) {\n    }\n    else {                      /* reliable protocol is used: */\n      ict->ict_context->timer_a_length = -1;    /* A is not ACTIVE */\n      ict->ict_context->timer_a_start.tv_sec = -1;\n    }\n  }\n#endif\n\n  __osip_message_callback (OSIP_ICT_INVITE_SENT, ict, ict->orig_request);\n  __osip_transaction_set_state (ict, ICT_CALLING);\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "osip_ict_timeout_a_event": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\nosip_ict_timeout_a_event (osip_transaction_t * ict, osip_event_t * evt)\n{\n  osip_t *osip = (osip_t *) ict->config;\n  int i;\n\n  /* reset timer */\n  ict->ict_context->timer_a_length = ict->ict_context->timer_a_length * 2;\n  osip_gettimeofday (&ict->ict_context->timer_a_start, NULL);\n  add_gettimeofday (&ict->ict_context->timer_a_start, ict->ict_context->timer_a_length);\n\n  /* retransmit REQUEST */\n  i = osip->cb_send_message (ict, ict->orig_request, ict->ict_context->destination, ict->ict_context->port, ict->out_socket);\n  if (i < 0) {\n    ict_handle_transport_error (ict, i);\n    return;\n  }\n#ifndef USE_BLOCKINGSOCKET\n  /*\n     stop timer E in reliable transport - non blocking socket: \n     the message was just sent\n   */\n  if (i == 0) {                 /* but message was really sent */\n    osip_via_t *via;\n    char *proto;\n\n    i = osip_message_get_via (ict->orig_request, 0, &via);      /* get top via */\n    if (i < 0) {\n      ict_handle_transport_error (ict, i);\n      return;\n    }\n    proto = via_get_protocol (via);\n    if (proto == NULL) {\n      ict_handle_transport_error (ict, i);\n      return;\n    }\n    if (osip_strcasecmp (proto, \"TCP\") != 0 && osip_strcasecmp (proto, \"TLS\") != 0 && osip_strcasecmp (proto, \"SCTP\") != 0) {\n    }\n    else {                      /* reliable protocol is used: */\n      ict->ict_context->timer_a_length = -1;    /* A is not ACTIVE */\n      ict->ict_context->timer_a_start.tv_sec = -1;\n    }\n  }\n#endif\n\n  if (i == 0)\n    __osip_message_callback (OSIP_ICT_INVITE_SENT_AGAIN, ict, ict->orig_request);\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "osip_ict_timeout_b_event": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "void\nosip_ict_timeout_b_event (osip_transaction_t * ict, osip_event_t * evt)\n{\n  ict->ict_context->timer_b_length = -1;\n  ict->ict_context->timer_b_start.tv_sec = -1;\n\n  __osip_message_callback (OSIP_ICT_STATUS_TIMEOUT, ict, evt->sip);\n  __osip_transaction_set_state (ict, ICT_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_ICT_KILL_TRANSACTION, ict);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ict_rcv_1xx": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "void\nict_rcv_1xx (osip_transaction_t * ict, osip_event_t * evt)\n{\n  /* leave this answer to the core application */\n\n  if (ict->last_response != NULL) {\n    osip_message_free (ict->last_response);\n  }\n  ict->last_response = evt->sip;\n  __osip_message_callback (OSIP_ICT_STATUS_1XX_RECEIVED, ict, evt->sip);\n  __osip_transaction_set_state (ict, ICT_PROCEEDING);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ict_rcv_2xx": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "void\nict_rcv_2xx (osip_transaction_t * ict, osip_event_t * evt)\n{\n  /* leave this answer to the core application */\n\n  if (ict->last_response != NULL) {\n    osip_message_free (ict->last_response);\n  }\n  ict->last_response = evt->sip;\n\n  __osip_message_callback (OSIP_ICT_STATUS_2XX_RECEIVED, ict, evt->sip);\n\n  __osip_transaction_set_state (ict, ICT_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_ICT_KILL_TRANSACTION, ict);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ict_create_ack": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "osip_message_t *\nict_create_ack (osip_transaction_t * ict, osip_message_t * response)\n{\n  int i;\n  osip_message_t *ack;\n\n  i = osip_message_init (&ack);\n  if (i != 0)\n    return NULL;\n\n  /* Section 17.1.1.3: Construction of the ACK request: */\n  i = osip_from_clone (response->from, &(ack->from));\n  if (i != 0) {\n    osip_message_free (ack);\n    return NULL;\n  }\n  i = osip_to_clone (response->to, &(ack->to)); /* include the tag! */\n  if (i != 0) {\n    osip_message_free (ack);\n    return NULL;\n  }\n  i = osip_call_id_clone (response->call_id, &(ack->call_id));\n  if (i != 0) {\n    osip_message_free (ack);\n    return NULL;\n  }\n  i = osip_cseq_clone (response->cseq, &(ack->cseq));\n  if (i != 0) {\n    osip_message_free (ack);\n    return NULL;\n  }\n  osip_free (ack->cseq->method);\n  ack->cseq->method = osip_strdup (\"ACK\");\n  if (ack->cseq->method == NULL) {\n    osip_message_free (ack);\n    return NULL;\n  }\n\n  ack->sip_method = (char *) osip_malloc (5);\n  if (ack->sip_method == NULL) {\n    osip_message_free (ack);\n    return NULL;\n  }\n  sprintf (ack->sip_method, \"ACK\");\n  ack->sip_version = osip_strdup (ict->orig_request->sip_version);\n  if (ack->sip_version == NULL) {\n    osip_message_free (ack);\n    return NULL;\n  }\n\n  ack->status_code = 0;\n  ack->reason_phrase = NULL;\n\n  /* MUST copy REQUEST-URI from Contact header! */\n  i = osip_uri_clone (ict->orig_request->req_uri, &(ack->req_uri));\n  if (i != 0) {\n    osip_message_free (ack);\n    return NULL;\n  }\n\n  /* ACK MUST contain only the TOP Via field from original request */\n  {\n    osip_via_t *via;\n    osip_via_t *orig_via;\n\n    osip_message_get_via (ict->orig_request, 0, &orig_via);\n    if (orig_via == NULL) {\n      osip_message_free (ack);\n      return NULL;\n    }\n    i = osip_via_clone (orig_via, &via);\n    if (i != 0) {\n      osip_message_free (ack);\n      return NULL;\n    }\n    osip_list_add (&ack->vias, via, -1);\n  }\n\n  /* ack MUST contains the ROUTE headers field from the original request */\n  /* IS IT TRUE??? */\n  /* if the answers contains a set of route (or record route), then it */\n  /* should be used instead?? ......May be not..... */\n  {\n    int pos = 0;\n    osip_route_t *route;\n    osip_route_t *orig_route;\n\n    while (!osip_list_eol (&ict->orig_request->routes, pos)) {\n      orig_route = (osip_route_t *) osip_list_get (&ict->orig_request->routes, pos);\n      i = osip_route_clone (orig_route, &route);\n      if (i != 0) {\n        osip_message_free (ack);\n        return NULL;\n      }\n      osip_list_add (&ack->routes, route, -1);\n      pos++;\n    }\n  }\n\n  if (response->status_code!=401 && response->status_code!=407) {\n    /* ack MUST contains the Authorization headers field from the original request */\n    if (osip_list_size (&ict->orig_request->authorizations) > 0) {\n      i = osip_list_clone (&ict->orig_request->authorizations, &ack->authorizations, (int (*)(void *, void **)) &osip_authorization_clone);\n      if (i != 0) {\n        osip_message_free (ack);\n        return NULL;\n      }\n    }\n\n    /* ack MUST contains the Proxy-Authorization headers field from the original request */\n    if (osip_list_size (&ict->orig_request->proxy_authorizations) > 0) {\n      i = osip_list_clone (&ict->orig_request->proxy_authorizations, &ack->proxy_authorizations, (int (*)(void *, void **)) &osip_proxy_authorization_clone);\n      if (i != 0) {\n        osip_message_free (ack);\n        return NULL;\n      }\n    }\n  }\n\n  /* may be we could add some other headers: */\n  /* For example \"Max-Forward\" */\n\n  return ack;\n}",
      "lines": 124,
      "depth": 18,
      "decorators": [
        "osip_message_t",
        "*\nict_create_ack (osip_transaction_t * ict, osip_message_t * response)",
        "*"
      ]
    },
    "ict_rcv_3456xx": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "void\nict_rcv_3456xx (osip_transaction_t * ict, osip_event_t * evt)\n{\n  osip_route_t *route;\n  int i;\n  osip_t *osip = (osip_t *) ict->config;\n\n  /* leave this answer to the core application */\n\n  if (ict->last_response != NULL)\n    osip_message_free (ict->last_response);\n\n  ict->last_response = evt->sip;\n  if (ict->state != ICT_COMPLETED) {    /* not a retransmission */\n    /* automatic handling of ack! */\n    osip_message_t *ack = ict_create_ack (ict, evt->sip);\n\n    ict->ack = ack;\n\n    if (ict->ack == NULL) {\n      __osip_transaction_set_state (ict, ICT_TERMINATED);\n      __osip_kill_transaction_callback (OSIP_ICT_KILL_TRANSACTION, ict);\n      return;\n    }\n\n    /* reset ict->ict_context->destination only if\n       it is not yet set. */\n    if (ict->ict_context->destination == NULL) {\n      osip_message_get_route (ack, 0, &route);\n      if (route != NULL && route->url != NULL) {\n        osip_uri_param_t *lr_param;\n\n        osip_uri_uparam_get_byname (route->url, \"lr\", &lr_param);\n        if (lr_param == NULL) {\n          /* using uncompliant proxy: destination is the request-uri */\n          route = NULL;\n        }\n      }\n\n      if (route != NULL && route->url != NULL) {\n        int port = 5060;\n\n        if (route->url->port != NULL)\n          port = osip_atoi (route->url->port);\n        osip_ict_set_destination (ict->ict_context, osip_strdup (route->url->host), port);\n      }\n      else {\n        int port = 5060;\n\n        /* search for maddr parameter */\n        osip_uri_param_t *maddr_param = NULL;\n        osip_uri_param_t *obr_param = NULL;\n        osip_uri_param_t *obp_param = NULL;\n\n        port = 5060;\n        if (ack->req_uri->port != NULL)\n          port = osip_atoi (ack->req_uri->port);\n\n        /* if ob was used in Contact, then exosip adds \"x-obr\" and \"x-obp\", thus, when\n        processing request, the ip/port destination are re-used here */\n        osip_uri_uparam_get_byname(ack->req_uri, \"x-obr\", &obr_param);\n        osip_uri_uparam_get_byname(ack->req_uri, \"x-obp\", &obp_param);\n\n        osip_uri_uparam_get_byname (ack->req_uri, \"maddr\", &maddr_param);\n        if (maddr_param != NULL && maddr_param->gvalue != NULL)\n          osip_ict_set_destination (ict->ict_context, osip_strdup (maddr_param->gvalue), port);\n        else if (obr_param != NULL && obr_param->gvalue != NULL && obp_param != NULL && obp_param->gvalue != NULL)\n          osip_ict_set_destination (ict->ict_context, osip_strdup (obr_param->gvalue), osip_atoi(obp_param->gvalue));\n        else\n          osip_ict_set_destination (ict->ict_context, osip_strdup (ack->req_uri->host), port);\n      }\n    }\n    i = osip->cb_send_message (ict, ack, ict->ict_context->destination, ict->ict_context->port, ict->out_socket);\n    if (i != 0) {\n      ict_handle_transport_error (ict, i);\n      return;\n    }\n    if (MSG_IS_STATUS_3XX (evt->sip))\n      __osip_message_callback (OSIP_ICT_STATUS_3XX_RECEIVED, ict, evt->sip);\n    else if (MSG_IS_STATUS_4XX (evt->sip))\n      __osip_message_callback (OSIP_ICT_STATUS_4XX_RECEIVED, ict, evt->sip);\n    else if (MSG_IS_STATUS_5XX (evt->sip))\n      __osip_message_callback (OSIP_ICT_STATUS_5XX_RECEIVED, ict, evt->sip);\n    else\n      __osip_message_callback (OSIP_ICT_STATUS_6XX_RECEIVED, ict, evt->sip);\n\n    __osip_message_callback (OSIP_ICT_ACK_SENT, ict, ack);\n  }\n\n  /* start timer D (length is set to MAX (64*DEFAULT_T1 or 32000) */\n  osip_gettimeofday (&ict->ict_context->timer_d_start, NULL);\n  add_gettimeofday (&ict->ict_context->timer_d_start, ict->ict_context->timer_d_length);\n  __osip_transaction_set_state (ict, ICT_COMPLETED);\n}",
      "lines": 94,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "osip_ict_timeout_d_event": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "void\nosip_ict_timeout_d_event (osip_transaction_t * ict, osip_event_t * evt)\n{\n  ict->ict_context->timer_d_length = -1;\n  ict->ict_context->timer_d_start.tv_sec = -1;\n\n  __osip_transaction_set_state (ict, ICT_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_ICT_KILL_TRANSACTION, ict);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ict_retransmit_ack": {
      "start_point": [
        462,
        0
      ],
      "end_point": [
        485,
        1
      ],
      "content": "void\nict_retransmit_ack (osip_transaction_t * ict, osip_event_t * evt)\n{\n  int i;\n  osip_t *osip = (osip_t *) ict->config;\n\n  /* this could be another 3456xx ??? */\n  /* we should make a new ACK and send it!!! */\n  /* TODO */\n\n  __osip_message_callback (OSIP_ICT_STATUS_3456XX_RECEIVED_AGAIN, ict, evt->sip);\n\n  osip_message_free (evt->sip);\n\n  i = osip->cb_send_message (ict, ict->ack, ict->ict_context->destination, ict->ict_context->port, ict->out_socket);\n\n  if (i == 0) {\n    __osip_message_callback (OSIP_ICT_ACK_SENT_AGAIN, ict, ict->ack);\n    __osip_transaction_set_state (ict, ICT_COMPLETED);\n  }\n  else {\n    ict_handle_transport_error (ict, i);\n  }\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/ist.c": {
    "__osip_ist_init": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\n__osip_ist_init (osip_ist_t ** ist, osip_t * osip, osip_message_t * invite)\n{\n  int i;\n\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"allocating IST context\\n\"));\n\n  *ist = (osip_ist_t *) osip_malloc (sizeof (osip_ist_t));\n  if (*ist == NULL)\n    return OSIP_NOMEM;\n  memset (*ist, 0, sizeof (osip_ist_t));\n  /* for INVITE retransmissions */\n  {\n    osip_via_t *via;\n    char *proto;\n\n    i = osip_message_get_via (invite, 0, &via); /* get top via */\n    if (i < 0) {\n      osip_free (*ist);\n      *ist = NULL;\n      return i;\n    }\n    proto = via_get_protocol (via);\n    if (proto == NULL) {\n      osip_free (*ist);\n      *ist = NULL;\n      return OSIP_UNDEFINED_ERROR;\n    }\n\n    if (osip_strcasecmp (proto, \"TCP\") != 0 && osip_strcasecmp (proto, \"TLS\") != 0 && osip_strcasecmp (proto, \"SCTP\") != 0) {   /* for other reliable protocol than TCP, the timer\n                                                                                                                                   must be desactived by the external application */\n      (*ist)->timer_g_length = DEFAULT_T1;\n      (*ist)->timer_i_length = DEFAULT_T4;\n      (*ist)->timer_g_start.tv_sec = -1;        /* not started */\n      (*ist)->timer_i_start.tv_sec = -1;        /* not started */\n    }\n    else {                      /* reliable protocol is used: */\n      (*ist)->timer_g_length = -1;      /* A is not ACTIVE */\n      (*ist)->timer_i_length = 0;       /* MUST do the transition immediatly */\n      (*ist)->timer_g_start.tv_sec = -1;        /* not started */\n      (*ist)->timer_i_start.tv_sec = -1;        /* not started */\n    }\n  }\n\n  (*ist)->timer_h_length = 64 * DEFAULT_T1;\n  (*ist)->timer_h_start.tv_sec = -1;    /* not started */\n\n  return OSIP_SUCCESS;\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "__osip_ist_free": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\n__osip_ist_free (osip_ist_t * ist)\n{\n  if (ist == NULL)\n    return OSIP_SUCCESS;\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"free ist resource\\n\"));\n  osip_free (ist);\n  return OSIP_SUCCESS;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "__osip_ist_need_timer_g_event": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "osip_event_t *\n__osip_ist_need_timer_g_event (osip_ist_t * ist, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (ist, &ist->timer_g_start, state == IST_COMPLETED, transactionid, TIMEOUT_G);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "osip_event_t",
        "*\n__osip_ist_need_timer_g_event (osip_ist_t * ist, state_t state, int transactionid)",
        "*"
      ]
    },
    "__osip_ist_need_timer_h_event": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "osip_event_t *\n__osip_ist_need_timer_h_event (osip_ist_t * ist, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (ist, &ist->timer_h_start, state == IST_COMPLETED, transactionid, TIMEOUT_H);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "osip_event_t",
        "*\n__osip_ist_need_timer_h_event (osip_ist_t * ist, state_t state, int transactionid)",
        "*"
      ]
    },
    "__osip_ist_need_timer_i_event": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "osip_event_t *\n__osip_ist_need_timer_i_event (osip_ist_t * ist, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (ist, &ist->timer_i_start, state == IST_CONFIRMED, transactionid, TIMEOUT_I);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "osip_event_t",
        "*\n__osip_ist_need_timer_i_event (osip_ist_t * ist, state_t state, int transactionid)",
        "*"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/ist_fsm.c": {
    "ist_handle_transport_error": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static void\nist_handle_transport_error (osip_transaction_t * ist, int err)\n{\n  __osip_transport_error_callback (OSIP_IST_TRANSPORT_ERROR, ist, err);\n  __osip_transaction_set_state (ist, IST_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_IST_KILL_TRANSACTION, ist);\n  /* TODO: MUST BE DELETED NOW */\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ist_rcv_invite": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "void\nist_rcv_invite (osip_transaction_t * ist, osip_event_t * evt)\n{\n  int i;\n\n  if (ist->state == IST_PRE_PROCEEDING) {       /* announce new INVITE */\n    /* Here we have ist->orig_request == NULL */\n    ist->orig_request = evt->sip;\n\n    __osip_message_callback (OSIP_IST_INVITE_RECEIVED, ist, evt->sip);\n  }\n  else {                        /* IST_PROCEEDING or IST_COMPLETED */\n\n    /* delete retransmission */\n    osip_message_free (evt->sip);\n\n    __osip_message_callback (OSIP_IST_INVITE_RECEIVED_AGAIN, ist, ist->orig_request);\n    if (ist->last_response != NULL) {   /* retransmit last response */\n      i = __osip_transaction_snd_xxx (ist, ist->last_response);\n      if (i != 0) {\n        ist_handle_transport_error (ist, i);\n        return;\n      }\n      else {\n        if (MSG_IS_STATUS_1XX (ist->last_response))\n          __osip_message_callback (OSIP_IST_STATUS_1XX_SENT, ist, ist->last_response);\n        else if (MSG_IS_STATUS_2XX (ist->last_response))\n          __osip_message_callback (OSIP_IST_STATUS_2XX_SENT_AGAIN, ist, ist->last_response);\n        else\n          __osip_message_callback (OSIP_IST_STATUS_3456XX_SENT_AGAIN, ist, ist->last_response);\n      }\n    }\n    return;\n  }\n\n  /* we come here only if it was the first INVITE received */\n  __osip_transaction_set_state (ist, IST_PROCEEDING);\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "osip_ist_timeout_g_event": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void\nosip_ist_timeout_g_event (osip_transaction_t * ist, osip_event_t * evt)\n{\n  int i;\n\n  ist->ist_context->timer_g_length = ist->ist_context->timer_g_length * 2;\n  if (ist->ist_context->timer_g_length > DEFAULT_T2)\n    ist->ist_context->timer_g_length = DEFAULT_T2;\n  osip_gettimeofday (&ist->ist_context->timer_g_start, NULL);\n  add_gettimeofday (&ist->ist_context->timer_g_start, ist->ist_context->timer_g_length);\n\n  i = __osip_transaction_snd_xxx (ist, ist->last_response);\n  if (i != 0) {\n    ist_handle_transport_error (ist, i);\n    return;\n  }\n  __osip_message_callback (OSIP_IST_STATUS_3456XX_SENT_AGAIN, ist, ist->last_response);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "osip_ist_timeout_h_event": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "void\nosip_ist_timeout_h_event (osip_transaction_t * ist, osip_event_t * evt)\n{\n  ist->ist_context->timer_h_length = -1;\n  ist->ist_context->timer_h_start.tv_sec = -1;\n\n  __osip_transaction_set_state (ist, IST_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_IST_KILL_TRANSACTION, ist);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_ist_timeout_i_event": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void\nosip_ist_timeout_i_event (osip_transaction_t * ist, osip_event_t * evt)\n{\n  ist->ist_context->timer_i_length = -1;\n  ist->ist_context->timer_i_start.tv_sec = -1;\n\n  __osip_transaction_set_state (ist, IST_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_IST_KILL_TRANSACTION, ist);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ist_snd_1xx": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "void\nist_snd_1xx (osip_transaction_t * ist, osip_event_t * evt)\n{\n  int i;\n\n  if (ist->last_response != NULL) {\n    osip_message_free (ist->last_response);\n  }\n  ist->last_response = evt->sip;\n\n  i = __osip_transaction_snd_xxx (ist, evt->sip);\n  if (i != 0) {\n    ist_handle_transport_error (ist, i);\n    return;\n  }\n  else\n    __osip_message_callback (OSIP_IST_STATUS_1XX_SENT, ist, ist->last_response);\n\n  /* we are already in the proper state */\n  return;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ist_snd_2xx": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "void\nist_snd_2xx (osip_transaction_t * ist, osip_event_t * evt)\n{\n  int i;\n\n  if (ist->last_response != NULL) {\n    osip_message_free (ist->last_response);\n  }\n  ist->last_response = evt->sip;\n\n  i = __osip_transaction_snd_xxx (ist, evt->sip);\n  if (i != 0) {\n    ist_handle_transport_error (ist, i);\n    return;\n  }\n  else {\n    __osip_message_callback (OSIP_IST_STATUS_2XX_SENT, ist, ist->last_response);\n    __osip_transaction_set_state (ist, IST_TERMINATED);\n    __osip_kill_transaction_callback (OSIP_IST_KILL_TRANSACTION, ist);\n  }\n  return;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ist_snd_3456xx": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "void\nist_snd_3456xx (osip_transaction_t * ist, osip_event_t * evt)\n{\n  int i;\n\n  if (ist->last_response != NULL) {\n    osip_message_free (ist->last_response);\n  }\n  ist->last_response = evt->sip;\n\n  i = __osip_transaction_snd_xxx (ist, evt->sip);\n  if (i != 0) {\n    ist_handle_transport_error (ist, i);\n    return;\n  }\n  else {\n    if (MSG_IS_STATUS_3XX (ist->last_response))\n      __osip_message_callback (OSIP_IST_STATUS_3XX_SENT, ist, ist->last_response);\n    else if (MSG_IS_STATUS_4XX (ist->last_response))\n      __osip_message_callback (OSIP_IST_STATUS_4XX_SENT, ist, ist->last_response);\n    else if (MSG_IS_STATUS_5XX (ist->last_response))\n      __osip_message_callback (OSIP_IST_STATUS_5XX_SENT, ist, ist->last_response);\n    else\n      __osip_message_callback (OSIP_IST_STATUS_6XX_SENT, ist, ist->last_response);\n  }\n\n  if (ist->ist_context->timer_g_length != -1) {\n    osip_gettimeofday (&ist->ist_context->timer_g_start, NULL);\n    add_gettimeofday (&ist->ist_context->timer_g_start, ist->ist_context->timer_g_length);\n  }\n  osip_gettimeofday (&ist->ist_context->timer_h_start, NULL);\n  add_gettimeofday (&ist->ist_context->timer_h_start, ist->ist_context->timer_h_length);\n  __osip_transaction_set_state (ist, IST_COMPLETED);\n  return;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "ist_rcv_ack": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "void\nist_rcv_ack (osip_transaction_t * ist, osip_event_t * evt)\n{\n  if (ist->ack != NULL) {\n    osip_message_free (ist->ack);\n  }\n\n  ist->ack = evt->sip;\n\n  if (ist->state == IST_COMPLETED)\n    __osip_message_callback (OSIP_IST_ACK_RECEIVED, ist, ist->ack);\n  else                          /* IST_CONFIRMED */\n    __osip_message_callback (OSIP_IST_ACK_RECEIVED_AGAIN, ist, ist->ack);\n  /* set the timer to 0 for reliable, and T4 for unreliable (already set) */\n  osip_gettimeofday (&ist->ist_context->timer_i_start, NULL);\n  add_gettimeofday (&ist->ist_context->timer_i_start, ist->ist_context->timer_i_length);\n  __osip_transaction_set_state (ist, IST_CONFIRMED);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/nict.c": {
    "__osip_nict_init": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\n__osip_nict_init (osip_nict_t ** nict, osip_t * osip, osip_message_t * request)\n{\n  osip_route_t *route;\n  int i;\n\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"allocating NICT context\\n\"));\n\n  *nict = (osip_nict_t *) osip_malloc (sizeof (osip_nict_t));\n  if (*nict == NULL)\n    return OSIP_NOMEM;\n\n  memset (*nict, 0, sizeof (osip_nict_t));\n  /* for REQUEST retransmissions */\n  {\n    osip_via_t *via;\n    char *proto;\n\n    i = osip_message_get_via (request, 0, &via);        /* get top via */\n    if (i < 0) {\n      osip_free (*nict);\n      *nict = NULL;\n      return i;\n    }\n    proto = via_get_protocol (via);\n    if (proto == NULL) {\n      osip_free (*nict);\n      *nict = NULL;\n      return OSIP_UNDEFINED_ERROR;\n    }\n#ifdef USE_BLOCKINGSOCKET\n    if (osip_strcasecmp (proto, \"TCP\") != 0 && osip_strcasecmp (proto, \"TLS\") != 0 && osip_strcasecmp (proto, \"SCTP\") != 0) {\n      (*nict)->timer_e_length = DEFAULT_T1;\n      (*nict)->timer_k_length = DEFAULT_T4;\n      (*nict)->timer_e_start.tv_sec = -1;\n      (*nict)->timer_k_start.tv_sec = -1;       /* not started */\n    }\n    else {                      /* reliable protocol is used: */\n      (*nict)->timer_e_length = -1;     /* E is not ACTIVE */\n      (*nict)->timer_k_length = 0;      /* MUST do the transition immediatly */\n      (*nict)->timer_e_start.tv_sec = -1;\n      (*nict)->timer_k_start.tv_sec = -1;       /* not started */\n    }\n  }\n#else\n    if (osip_strcasecmp (proto, \"TCP\") != 0 && osip_strcasecmp (proto, \"TLS\") != 0 && osip_strcasecmp (proto, \"SCTP\") != 0) {\n      (*nict)->timer_e_length = DEFAULT_T1;\n      (*nict)->timer_k_length = DEFAULT_T4;\n      (*nict)->timer_e_start.tv_sec = -1;\n      (*nict)->timer_k_start.tv_sec = -1;       /* not started */\n    }\n    else {                      /* reliable protocol is used: */\n      (*nict)->timer_e_length = DEFAULT_T1;\n      (*nict)->timer_k_length = 0;      /* MUST do the transition immediatly */\n      (*nict)->timer_e_start.tv_sec = -1;\n      (*nict)->timer_k_start.tv_sec = -1;       /* not started */\n    }\n  }\n#endif\n  /* for PROXY, the destination MUST be set by the application layer,\n     this one may not be correct. */\n  osip_message_get_route (request, 0, &route);\n  if (route != NULL && route->url != NULL) {\n    osip_uri_param_t *lr_param;\n\n    osip_uri_uparam_get_byname (route->url, \"lr\", &lr_param);\n    if (lr_param == NULL) {\n      /* using uncompliant proxy: destination is the request-uri */\n      route = NULL;\n    }\n  }\n\n  if (route != NULL && route->url != NULL) {\n    int port = 5060;\n\n    if (route->url->port != NULL)\n      port = osip_atoi (route->url->port);\n    osip_nict_set_destination ((*nict), osip_strdup (route->url->host), port);\n  }\n  else {\n    int port = 5060;\n\n    /* search for maddr parameter */\n    osip_uri_param_t *maddr_param = NULL;\n    osip_uri_param_t *obr_param = NULL;\n    osip_uri_param_t *obp_param = NULL;\n\n    port = 5060;\n    if (request->req_uri->port != NULL)\n      port = osip_atoi (request->req_uri->port);\n\n    /* if ob was used in Contact, then exosip adds \"x-obr\" and \"x-obp\", thus, when\n    processing request, the ip/port destination are re-used here */\n    osip_uri_uparam_get_byname(request->req_uri, \"x-obr\", &obr_param);\n    osip_uri_uparam_get_byname(request->req_uri, \"x-obp\", &obp_param);\n\n    osip_uri_uparam_get_byname (request->req_uri, \"maddr\", &maddr_param);\n\n    if (maddr_param != NULL && maddr_param->gvalue != NULL)\n      osip_nict_set_destination ((*nict), osip_strdup (maddr_param->gvalue), port);\n    else if (obr_param != NULL && obr_param->gvalue != NULL && obp_param != NULL && obp_param->gvalue != NULL)\n      osip_nict_set_destination ((*nict), osip_strdup (obr_param->gvalue), osip_atoi(obp_param->gvalue));\n    else\n      osip_nict_set_destination ((*nict), osip_strdup (request->req_uri->host), port);\n  }\n\n  (*nict)->timer_f_length = 64 * DEFAULT_T1;\n  osip_gettimeofday (&(*nict)->timer_f_start, NULL);\n  add_gettimeofday (&(*nict)->timer_f_start, (*nict)->timer_f_length);\n\n  /* Oups! a Bug! */\n  /*  (*nict)->port  = 5060; */\n\n  return OSIP_SUCCESS;\n}\n\nint\n__osip_nict_free (osip_nict_t * nict)\n{\n  if (nict == NULL)\n    return OSIP_SUCCESS;\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"free nict resource\\n\"));\n\n  osip_free (nict->destination);\n  osip_free (nict);\n  return OSIP_SUCCESS;\n}\n\nint\nosip_nict_set_destination (osip_nict_t * nict, char *destination, int port)\n{\n  if (nict == NULL)\n    return OSIP_BADPARAMETER;\n  if (nict->destination != NULL)\n    osip_free (nict->destination);\n  nict->destination = destination;\n  nict->port = port;\n  return OSIP_SUCCESS;\n}\n\nosip_event_t *\n__osip_nict_need_timer_e_event (osip_nict_t * nict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (nict, &nict->timer_e_start, state == NICT_PROCEEDING || state == NICT_TRYING, transactionid, TIMEOUT_E);\n}\n\nosip_event_t *\n__osip_nict_need_timer_f_event (osip_nict_t * nict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (nict, &nict->timer_f_start, state == NICT_PROCEEDING || state == NICT_TRYING, transactionid, TIMEOUT_F);\n}\n\nosip_event_t *\n__osip_nict_need_timer_k_event (osip_nict_t * nict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (nict, &nict->timer_k_start, state == NICT_COMPLETED, transactionid, TIMEOUT_K);\n}",
      "lines": 157,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "__osip_nict_free": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\n__osip_nict_free (osip_nict_t * nict)\n{\n  if (nict == NULL)\n    return OSIP_SUCCESS;\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"free nict resource\\n\"));\n\n  osip_free (nict->destination);\n  osip_free (nict);\n  return OSIP_SUCCESS;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_nict_set_destination": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "int\nosip_nict_set_destination (osip_nict_t * nict, char *destination, int port)\n{\n  if (nict == NULL)\n    return OSIP_BADPARAMETER;\n  if (nict->destination != NULL)\n    osip_free (nict->destination);\n  nict->destination = destination;\n  nict->port = port;\n  return OSIP_SUCCESS;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "__osip_nict_need_timer_e_event": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "osip_event_t *\n__osip_nict_need_timer_e_event (osip_nict_t * nict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (nict, &nict->timer_e_start, state == NICT_PROCEEDING || state == NICT_TRYING, transactionid, TIMEOUT_E);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "osip_event_t",
        "*\n__osip_nict_need_timer_e_event (osip_nict_t * nict, state_t state, int transactionid)",
        "*"
      ]
    },
    "__osip_nict_need_timer_f_event": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "osip_event_t *\n__osip_nict_need_timer_f_event (osip_nict_t * nict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (nict, &nict->timer_f_start, state == NICT_PROCEEDING || state == NICT_TRYING, transactionid, TIMEOUT_F);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "osip_event_t",
        "*\n__osip_nict_need_timer_f_event (osip_nict_t * nict, state_t state, int transactionid)",
        "*"
      ]
    },
    "__osip_nict_need_timer_k_event": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "osip_event_t *\n__osip_nict_need_timer_k_event (osip_nict_t * nict, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (nict, &nict->timer_k_start, state == NICT_COMPLETED, transactionid, TIMEOUT_K);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "osip_event_t",
        "*\n__osip_nict_need_timer_k_event (osip_nict_t * nict, state_t state, int transactionid)",
        "*"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/nict_fsm.c": {
    "nict_handle_transport_error": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static void\nnict_handle_transport_error (osip_transaction_t * nict, int err)\n{\n  __osip_transport_error_callback (OSIP_NICT_TRANSPORT_ERROR, nict, err);\n  __osip_transaction_set_state (nict, NICT_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_NICT_KILL_TRANSACTION, nict);\n  /* TODO: MUST BE DELETED NOW */\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nict_snd_request": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void\nnict_snd_request (osip_transaction_t * nict, osip_event_t * evt)\n{\n  int i;\n  osip_t *osip = (osip_t *) nict->config;\n\n  /* Here we have ict->orig_request == NULL */\n  nict->orig_request = evt->sip;\n\n  i = osip->cb_send_message (nict, evt->sip, nict->nict_context->destination, nict->nict_context->port, nict->out_socket);\n\n  if (i >= 0) {\n    /* invoke the right callback! */\n    if (MSG_IS_REGISTER (evt->sip))\n      __osip_message_callback (OSIP_NICT_REGISTER_SENT, nict, nict->orig_request);\n    else if (MSG_IS_BYE (evt->sip))\n      __osip_message_callback (OSIP_NICT_BYE_SENT, nict, nict->orig_request);\n    else if (MSG_IS_OPTIONS (evt->sip))\n      __osip_message_callback (OSIP_NICT_OPTIONS_SENT, nict, nict->orig_request);\n    else if (MSG_IS_INFO (evt->sip))\n      __osip_message_callback (OSIP_NICT_INFO_SENT, nict, nict->orig_request);\n    else if (MSG_IS_CANCEL (evt->sip))\n      __osip_message_callback (OSIP_NICT_CANCEL_SENT, nict, nict->orig_request);\n    else if (MSG_IS_NOTIFY (evt->sip))\n      __osip_message_callback (OSIP_NICT_NOTIFY_SENT, nict, nict->orig_request);\n    else if (MSG_IS_SUBSCRIBE (evt->sip))\n      __osip_message_callback (OSIP_NICT_SUBSCRIBE_SENT, nict, nict->orig_request);\n    else\n      __osip_message_callback (OSIP_NICT_UNKNOWN_REQUEST_SENT, nict, nict->orig_request);\n#ifndef USE_BLOCKINGSOCKET\n    /*\n       stop timer E in reliable transport - non blocking socket: \n       the message was just sent\n     */\n    {\n      osip_via_t *via;\n      char *proto;\n      int k;\n      k = osip_message_get_via (nict->orig_request, 0, &via);   /* get top via */\n      if (k < 0) {\n        nict_handle_transport_error (nict, -1);\n        return;\n      }\n      proto = via_get_protocol (via);\n      if (proto == NULL) {\n        nict_handle_transport_error (nict, -1);\n        return;\n      }\n      if (i == 0) {               /* but message was really sent */\n        if (osip_strcasecmp (proto, \"TCP\") != 0 && osip_strcasecmp (proto, \"TLS\") != 0 && osip_strcasecmp (proto, \"SCTP\") != 0) {\n        }\n        else {                    /* reliable protocol is used: */\n          nict->nict_context->timer_e_length = -1;        /* E is not ACTIVE */\n          nict->nict_context->timer_e_start.tv_sec = -1;\n        }\n      } else {\n        if (osip_strcasecmp (proto, \"TCP\") != 0 && osip_strcasecmp (proto, \"TLS\") != 0 && osip_strcasecmp (proto, \"SCTP\") != 0) {\n        }\n        else {                    /* reliable protocol is used: */\n          nict->nict_context->timer_e_length = DEFAULT_T1_TCP_PROGRESS;\n        }\n      }\n    }\n#endif\n    if (nict->nict_context->timer_e_length > 0) {\n      osip_gettimeofday (&nict->nict_context->timer_e_start, NULL);\n      add_gettimeofday (&nict->nict_context->timer_e_start, nict->nict_context->timer_e_length);\n    }\n    __osip_transaction_set_state (nict, NICT_TRYING);\n  }\n  else {\n    nict_handle_transport_error (nict, i);\n  }\n}",
      "lines": 74,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "osip_nict_timeout_e_event": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "void\nosip_nict_timeout_e_event (osip_transaction_t * nict, osip_event_t * evt)\n{\n  osip_t *osip = (osip_t *) nict->config;\n  int i;\n\n  /* reset timer */\n  if (nict->state == NICT_TRYING) {\n    if (nict->nict_context->timer_e_length < DEFAULT_T1)\n      nict->nict_context->timer_e_length = nict->nict_context->timer_e_length + DEFAULT_T1_TCP_PROGRESS;\n    else\n      nict->nict_context->timer_e_length = nict->nict_context->timer_e_length * 2;\n    if (nict->nict_context->timer_e_length > DEFAULT_T2)\n      nict->nict_context->timer_e_length = DEFAULT_T2;\n  }\n  else                          /* in PROCEEDING STATE, TIMER is always DEFAULT_T2 */\n    nict->nict_context->timer_e_length = DEFAULT_T2;\n\n  osip_gettimeofday (&nict->nict_context->timer_e_start, NULL);\n  add_gettimeofday (&nict->nict_context->timer_e_start, nict->nict_context->timer_e_length);\n\n  /* retransmit REQUEST */\n  i = osip->cb_send_message (nict, nict->orig_request, nict->nict_context->destination, nict->nict_context->port, nict->out_socket);\n  if (i < 0) {\n    nict_handle_transport_error (nict, i);\n    return;\n  }\n#ifndef USE_BLOCKINGSOCKET\n  /*\n     stop timer E in reliable transport - non blocking socket: \n     the message was just sent\n   */\n  if (i == 0) {                 /* but message was really sent */\n    osip_via_t *via;\n    char *proto;\n\n    i = osip_message_get_via (nict->orig_request, 0, &via);     /* get top via */\n    if (i < 0) {\n      nict_handle_transport_error (nict, -1);\n      return;\n    }\n    proto = via_get_protocol (via);\n    if (proto == NULL) {\n      nict_handle_transport_error (nict, -1);\n      return;\n    }\n    if (osip_strcasecmp (proto, \"TCP\") != 0 && osip_strcasecmp (proto, \"TLS\") != 0 && osip_strcasecmp (proto, \"SCTP\") != 0) {\n    }\n    else {                      /* reliable protocol is used: */\n      nict->nict_context->timer_e_length = -1;  /* E is not ACTIVE */\n      nict->nict_context->timer_e_start.tv_sec = -1;\n    }\n  }\n#endif\n  if (i == 0)                   /* but message was really sent */\n    __osip_message_callback (OSIP_NICT_REQUEST_SENT_AGAIN, nict, nict->orig_request);\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "osip_nict_timeout_f_event": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "void\nosip_nict_timeout_f_event (osip_transaction_t * nict, osip_event_t * evt)\n{\n  nict->nict_context->timer_f_length = -1;\n  nict->nict_context->timer_f_start.tv_sec = -1;\n\n  __osip_message_callback (OSIP_NICT_STATUS_TIMEOUT, nict, evt->sip);\n  __osip_transaction_set_state (nict, NICT_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_NICT_KILL_TRANSACTION, nict);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_nict_timeout_k_event": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "void\nosip_nict_timeout_k_event (osip_transaction_t * nict, osip_event_t * evt)\n{\n  nict->nict_context->timer_k_length = -1;\n  nict->nict_context->timer_k_start.tv_sec = -1;\n\n  __osip_transaction_set_state (nict, NICT_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_NICT_KILL_TRANSACTION, nict);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "nict_rcv_1xx": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void\nnict_rcv_1xx (osip_transaction_t * nict, osip_event_t * evt)\n{\n  /* leave this answer to the core application */\n\n  if (nict->last_response != NULL) {\n    osip_message_free (nict->last_response);\n  }\n  nict->last_response = evt->sip;\n\n  /* for unreliable transport increase the retransmission timeout */\n  if (nict->nict_context->timer_e_length > 0) {\n    nict->nict_context->timer_e_length = DEFAULT_T2;\n    osip_gettimeofday (&nict->nict_context->timer_e_start, NULL);\n    add_gettimeofday (&nict->nict_context->timer_e_start, nict->nict_context->timer_e_length);\n  }\n\n  __osip_message_callback (OSIP_NICT_STATUS_1XX_RECEIVED, nict, evt->sip);\n  __osip_transaction_set_state (nict, NICT_PROCEEDING);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "nict_rcv_23456xx": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "void\nnict_rcv_23456xx (osip_transaction_t * nict, osip_event_t * evt)\n{\n  /* leave this answer to the core application */\n\n  if (nict->last_response != NULL) {\n    osip_message_free (nict->last_response);\n  }\n  nict->last_response = evt->sip;\n\n  if (EVT_IS_RCV_STATUS_2XX (evt))\n    __osip_message_callback (OSIP_NICT_STATUS_2XX_RECEIVED, nict, nict->last_response);\n  else if (MSG_IS_STATUS_3XX (nict->last_response))\n    __osip_message_callback (OSIP_NICT_STATUS_3XX_RECEIVED, nict, nict->last_response);\n  else if (MSG_IS_STATUS_4XX (nict->last_response))\n    __osip_message_callback (OSIP_NICT_STATUS_4XX_RECEIVED, nict, nict->last_response);\n  else if (MSG_IS_STATUS_5XX (nict->last_response))\n    __osip_message_callback (OSIP_NICT_STATUS_5XX_RECEIVED, nict, nict->last_response);\n  else\n    __osip_message_callback (OSIP_NICT_STATUS_6XX_RECEIVED, nict, nict->last_response);\n\n  if (nict->state != NICT_COMPLETED) {  /* reset timer K */\n    osip_gettimeofday (&nict->nict_context->timer_k_start, NULL);\n    add_gettimeofday (&nict->nict_context->timer_k_start, nict->nict_context->timer_k_length);\n  }\n  __osip_transaction_set_state (nict, NICT_COMPLETED);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/nist.c": {
    "__osip_nist_init": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\n__osip_nist_init (osip_nist_t ** nist, osip_t * osip, osip_message_t * invite)\n{\n  int i;\n\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"allocating NIST context\\n\"));\n\n  *nist = (osip_nist_t *) osip_malloc (sizeof (osip_nist_t));\n  if (*nist == NULL)\n    return OSIP_NOMEM;\n  memset (*nist, 0, sizeof (osip_nist_t));\n  /* for INVITE retransmissions */\n  {\n    osip_via_t *via;\n    char *proto;\n\n    i = osip_message_get_via (invite, 0, &via); /* get top via */\n    if (i < 0) {\n      osip_free (*nist);\n      *nist = NULL;\n      return i;\n    }\n    proto = via_get_protocol (via);\n    if (proto == NULL) {\n      osip_free (*nist);\n      *nist = NULL;\n      return OSIP_UNDEFINED_ERROR;\n    }\n\n    if (osip_strcasecmp (proto, \"TCP\") != 0 && osip_strcasecmp (proto, \"TLS\") != 0 && osip_strcasecmp (proto, \"SCTP\") != 0) {\n      (*nist)->timer_j_length = 64 * DEFAULT_T1;\n      (*nist)->timer_j_start.tv_sec = -1;       /* not started */\n    }\n    else {                      /* reliable protocol is used: */\n      (*nist)->timer_j_length = 0;      /* MUST do the transition immediatly */\n      (*nist)->timer_j_start.tv_sec = -1;       /* not started */\n    }\n  }\n\n  return OSIP_SUCCESS;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "__osip_nist_free": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\n__osip_nist_free (osip_nist_t * nist)\n{\n  if (nist == NULL)\n    return OSIP_SUCCESS;\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"free nist resource\\n\"));\n\n  osip_free (nist);\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "__osip_nist_need_timer_j_event": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "osip_event_t *\n__osip_nist_need_timer_j_event (osip_nist_t * nist, state_t state, int transactionid)\n{\n  return __osip_transaction_need_timer_x_event (nist, &nist->timer_j_start, state == NIST_COMPLETED, transactionid, TIMEOUT_J);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "osip_event_t",
        "*\n__osip_nist_need_timer_j_event (osip_nist_t * nist, state_t state, int transactionid)",
        "*"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/nist_fsm.c": {
    "nist_handle_transport_error": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static void\nnist_handle_transport_error (osip_transaction_t * nist, int err)\n{\n  __osip_transport_error_callback (OSIP_NIST_TRANSPORT_ERROR, nist, err);\n  __osip_transaction_set_state (nist, NIST_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_NIST_KILL_TRANSACTION, nist);\n  /* TODO: MUST BE DELETED NOW */\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nist_rcv_request": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "void\nnist_rcv_request (osip_transaction_t * nist, osip_event_t * evt)\n{\n  int i;\n\n  if (nist->state == NIST_PRE_TRYING) { /* announce new REQUEST */\n    /* Here we have ist->orig_request == NULL */\n    nist->orig_request = evt->sip;\n\n    if (MSG_IS_REGISTER (evt->sip))\n      __osip_message_callback (OSIP_NIST_REGISTER_RECEIVED, nist, nist->orig_request);\n    else if (MSG_IS_BYE (evt->sip))\n      __osip_message_callback (OSIP_NIST_BYE_RECEIVED, nist, nist->orig_request);\n    else if (MSG_IS_OPTIONS (evt->sip))\n      __osip_message_callback (OSIP_NIST_OPTIONS_RECEIVED, nist, nist->orig_request);\n    else if (MSG_IS_INFO (evt->sip))\n      __osip_message_callback (OSIP_NIST_INFO_RECEIVED, nist, nist->orig_request);\n    else if (MSG_IS_CANCEL (evt->sip))\n      __osip_message_callback (OSIP_NIST_CANCEL_RECEIVED, nist, nist->orig_request);\n    else if (MSG_IS_NOTIFY (evt->sip))\n      __osip_message_callback (OSIP_NIST_NOTIFY_RECEIVED, nist, nist->orig_request);\n    else if (MSG_IS_SUBSCRIBE (evt->sip))\n      __osip_message_callback (OSIP_NIST_SUBSCRIBE_RECEIVED, nist, nist->orig_request);\n    else\n      __osip_message_callback (OSIP_NIST_UNKNOWN_REQUEST_RECEIVED, nist, nist->orig_request);\n  }\n  else {                        /* NIST_PROCEEDING or NIST_COMPLETED */\n\n    /* delete retransmission */\n    osip_message_free (evt->sip);\n\n    __osip_message_callback (OSIP_NIST_REQUEST_RECEIVED_AGAIN, nist, nist->orig_request);\n    if (nist->last_response != NULL) {  /* retransmit last response */\n      i = __osip_transaction_snd_xxx (nist, nist->last_response);\n      if (i != 0) {\n        nist_handle_transport_error (nist, i);\n        return;\n      }\n      else {\n        if (MSG_IS_STATUS_1XX (nist->last_response))\n          __osip_message_callback (OSIP_NIST_STATUS_1XX_SENT, nist, nist->last_response);\n        else if (MSG_IS_STATUS_2XX (nist->last_response))\n          __osip_message_callback (OSIP_NIST_STATUS_2XX_SENT_AGAIN, nist, nist->last_response);\n        else\n          __osip_message_callback (OSIP_NIST_STATUS_3456XX_SENT_AGAIN, nist, nist->last_response);\n        return;\n      }\n    }\n    /* we are already in the proper state */\n    return;\n  }\n\n  /* we come here only if it was the first REQUEST received */\n  __osip_transaction_set_state (nist, NIST_TRYING);\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "nist_snd_1xx": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nnist_snd_1xx (osip_transaction_t * nist, osip_event_t * evt)\n{\n  int i;\n\n  if (nist->last_response != NULL) {\n    osip_message_free (nist->last_response);\n  }\n  nist->last_response = evt->sip;\n\n  i = __osip_transaction_snd_xxx (nist, nist->last_response);\n  if (i != 0) {\n    nist_handle_transport_error (nist, i);\n    return;\n  }\n  else\n    __osip_message_callback (OSIP_NIST_STATUS_1XX_SENT, nist, nist->last_response);\n\n  __osip_transaction_set_state (nist, NIST_PROCEEDING);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "nist_snd_23456xx": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "void\nnist_snd_23456xx (osip_transaction_t * nist, osip_event_t * evt)\n{\n  int i;\n\n  if (nist->last_response != NULL) {\n    osip_message_free (nist->last_response);\n  }\n  nist->last_response = evt->sip;\n\n  i = __osip_transaction_snd_xxx (nist, nist->last_response);\n  if (i != 0) {\n    nist_handle_transport_error (nist, i);\n    return;\n  }\n  else {\n    if (EVT_IS_SND_STATUS_2XX (evt))\n      __osip_message_callback (OSIP_NIST_STATUS_2XX_SENT, nist, nist->last_response);\n    else if (MSG_IS_STATUS_3XX (nist->last_response))\n      __osip_message_callback (OSIP_NIST_STATUS_3XX_SENT, nist, nist->last_response);\n    else if (MSG_IS_STATUS_4XX (nist->last_response))\n      __osip_message_callback (OSIP_NIST_STATUS_4XX_SENT, nist, nist->last_response);\n    else if (MSG_IS_STATUS_5XX (nist->last_response))\n      __osip_message_callback (OSIP_NIST_STATUS_5XX_SENT, nist, nist->last_response);\n    else\n      __osip_message_callback (OSIP_NIST_STATUS_6XX_SENT, nist, nist->last_response);\n  }\n\n  if (nist->state != NIST_COMPLETED) {  /* start J timer */\n    osip_gettimeofday (&nist->nist_context->timer_j_start, NULL);\n    add_gettimeofday (&nist->nist_context->timer_j_start, nist->nist_context->timer_j_length);\n  }\n\n  __osip_transaction_set_state (nist, NIST_COMPLETED);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "osip_nist_timeout_j_event": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "void\nosip_nist_timeout_j_event (osip_transaction_t * nist, osip_event_t * evt)\n{\n  nist->nist_context->timer_j_length = -1;\n  nist->nist_context->timer_j_start.tv_sec = -1;\n\n  __osip_transaction_set_state (nist, NIST_TERMINATED);\n  __osip_kill_transaction_callback (OSIP_NIST_KILL_TRANSACTION, nist);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/osip.c": {
    "osip_response_get_destination": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\nosip_response_get_destination (osip_message_t * response, char **address, int *portnum)\n{\n  osip_via_t *via;\n  char *host = NULL;\n  int port = 0;\n\n  via = (osip_via_t *) osip_list_get (&response->vias, 0);\n  if (via) {\n    osip_generic_param_t *maddr;\n    osip_generic_param_t *received;\n    osip_generic_param_t *rport;\n\n    osip_via_param_get_byname (via, \"maddr\", &maddr);\n    osip_via_param_get_byname (via, \"received\", &received);\n    osip_via_param_get_byname (via, \"rport\", &rport);\n    /* 1: user should not use the provided information\n       (host and port) if they are using a reliable\n       transport. Instead, they should use the already\n       open socket attached to this transaction. */\n    /* 2: check maddr and multicast usage */\n    if (maddr != NULL)\n      host = maddr->gvalue;\n    /* we should check if this is a multicast address and use\n       set the \"ttl\" in this case. (this must be done in the\n       UDP message (not at the SIP layer) */\n    else if (received != NULL)\n      host = received->gvalue;\n    else\n      host = via->host;\n\n    if (rport == NULL || rport->gvalue == NULL) {\n      if (via->port != NULL)\n        port = osip_atoi (via->port);\n      else\n        port = 5060;\n    }\n    else\n      port = osip_atoi (rport->gvalue);\n  }\n  *portnum = port;\n  if (host != NULL)\n    *address = osip_strdup (host);\n  else\n    *address = NULL;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "osip_ixt_lock": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static int\nosip_ixt_lock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_lock (osip->ixt_fastmutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "osip_ixt_unlock": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int\nosip_ixt_unlock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_unlock (osip->ixt_fastmutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "osip_id_mutex_lock": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "int\nosip_id_mutex_lock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_lock (osip->id_mutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_id_mutex_unlock": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nosip_id_mutex_unlock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_unlock (osip->id_mutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_add_ixt": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "static void\nosip_add_ixt (osip_t * osip, ixt_t * ixt)\n{\n  /* add in list osip_t->ixt */\n  osip_ixt_lock (osip);\n  osip_list_add (&osip->ixt_retransmissions, (void *) ixt, 0);\n  osip_ixt_unlock (osip);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ixt_init": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static int\nixt_init (ixt_t ** ixt)\n{\n  ixt_t *pixt;\n\n  *ixt = pixt = (ixt_t *) osip_malloc (sizeof (ixt_t));\n  if (pixt == NULL)\n    return OSIP_NOMEM;\n  pixt->dialog = NULL;\n  pixt->msg2xx = NULL;\n  pixt->ack = NULL;\n  pixt->interval = DEFAULT_T1;\n  osip_gettimeofday (&pixt->start, NULL);\n  add_gettimeofday (&pixt->start, pixt->interval + 10);\n  pixt->counter = 10;\n  pixt->dest = NULL;\n  pixt->port = 5060;\n  pixt->sock = -1;\n  return OSIP_SUCCESS;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ixt_free": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static void\nixt_free (ixt_t * ixt)\n{\n  osip_message_free (ixt->ack);\n  osip_message_free (ixt->msg2xx);\n  osip_free (ixt->dest);\n  osip_free (ixt);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "osip_start_200ok_retransmissions": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "void\nosip_start_200ok_retransmissions (osip_t * osip, osip_dialog_t * dialog, osip_message_t * msg200ok, int sock)\n{\n  int i;\n  ixt_t *ixt;\n\n  i = ixt_init (&ixt);\n  if (i != 0)\n    return;\n  ixt->dialog = dialog;\n  osip_message_clone (msg200ok, &ixt->msg2xx);\n  ixt->sock = sock;\n  osip_response_get_destination (msg200ok, &ixt->dest, &ixt->port);\n  osip_add_ixt (osip, ixt);\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_start_ack_retransmissions": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void\nosip_start_ack_retransmissions (osip_t * osip, osip_dialog_t * dialog, osip_message_t * ack, char *dest, int port, int sock)\n{\n  int i;\n  ixt_t *ixt;\n\n  i = ixt_init (&ixt);\n  if (i != 0)\n    return;\n  ixt->dialog = dialog;\n  osip_message_clone (ack, &ixt->ack);\n  ixt->dest = osip_strdup (dest);\n  ixt->port = port;\n  ixt->sock = sock;\n  osip_add_ixt (osip, ixt);\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_stop_200ok_retransmissions": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "struct osip_dialog *\nosip_stop_200ok_retransmissions (osip_t * osip, osip_message_t * ack)\n{\n  osip_dialog_t *dialog = NULL;\n  int i;\n  ixt_t *ixt;\n\n  if (ack==NULL || ack->cseq==NULL || ack->cseq->number==NULL)\n    return NULL;\n\n  osip_ixt_lock (osip);\n  for (i = 0; !osip_list_eol (&osip->ixt_retransmissions, i); i++) {\n    ixt = (ixt_t *) osip_list_get (&osip->ixt_retransmissions, i);\n    if (ixt->msg2xx == NULL || ixt->msg2xx->cseq == NULL || ixt->msg2xx->cseq->number == NULL)\n      continue;\n    if (osip_dialog_match_as_uas (ixt->dialog, ack) == 0  && strcmp (ixt->msg2xx->cseq->number, ack->cseq->number) == 0) {\n      osip_list_remove (&osip->ixt_retransmissions, i);\n      dialog = ixt->dialog;\n      ixt_free (ixt);\n      break;\n    }\n  }\n  osip_ixt_unlock (osip);\n  return dialog;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "struct osip_dialog",
        "struct",
        "osip_dialog",
        "*\nosip_stop_200ok_retransmissions (osip_t * osip, osip_message_t * ack)",
        "*"
      ]
    },
    "osip_stop_retransmissions_from_dialog": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "void\nosip_stop_retransmissions_from_dialog (osip_t * osip, osip_dialog_t * dialog)\n{\n  int i;\n  ixt_t *ixt;\n\n  osip_ixt_lock (osip);\n  for (i = 0; !osip_list_eol (&osip->ixt_retransmissions, i); i++) {\n    ixt = (ixt_t *) osip_list_get (&osip->ixt_retransmissions, i);\n    if (ixt->dialog == dialog) {\n      osip_list_remove (&osip->ixt_retransmissions, i);\n      ixt_free (ixt);\n      i--;\n    }\n  }\n  osip_ixt_unlock (osip);\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "ixt_retransmit": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "static void\nixt_retransmit (osip_t * osip, ixt_t * ixt, struct timeval *current)\n{\n  if (osip_timercmp (current, &ixt->start, >)) {\n    ixt->interval = ixt->interval * 2;\n    if (ixt->interval > DEFAULT_T2)\n      ixt->interval = DEFAULT_T2;\n    add_gettimeofday (&ixt->start, ixt->interval);\n    if (ixt->ack != NULL)\n      osip->cb_send_message (NULL, ixt->ack, ixt->dest, ixt->port, ixt->sock);\n    else if (ixt->msg2xx != NULL)\n      osip->cb_send_message (NULL, ixt->msg2xx, ixt->dest, ixt->port, ixt->sock);\n    ixt->counter--;\n  }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "osip_retransmissions_execute": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "void\nosip_retransmissions_execute (osip_t * osip)\n{\n  int i;\n  ixt_t *ixt;\n  struct timeval current;\n\n  osip_gettimeofday (&current, NULL);\n\n  osip_ixt_lock (osip);\n  for (i = 0; !osip_list_eol (&osip->ixt_retransmissions, i); i++) {\n    ixt = (ixt_t *) osip_list_get (&osip->ixt_retransmissions, i);\n    ixt_retransmit (osip, ixt, &current);\n    if (ixt->counter == 0) {\n      /* remove it */\n      osip_list_remove (&osip->ixt_retransmissions, i);\n      ixt_free (ixt);\n      i--;\n    }\n  }\n  osip_ixt_unlock (osip);\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "osip_ict_lock": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "int\nosip_ict_lock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_lock (osip->ict_fastmutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_ict_unlock": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nosip_ict_unlock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_unlock (osip->ict_fastmutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_ist_lock": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "int\nosip_ist_lock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_lock (osip->ist_fastmutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_ist_unlock": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "int\nosip_ist_unlock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_unlock (osip->ist_fastmutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_nict_lock": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "int\nosip_nict_lock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_lock (osip->nict_fastmutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_nict_unlock": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "int\nosip_nict_unlock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_unlock (osip->nict_fastmutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_nist_lock": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "int\nosip_nist_lock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_lock (osip->nist_fastmutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_nist_unlock": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "int\nosip_nist_unlock (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  return osip_mutex_unlock (osip->nist_fastmutex);\n#else\n  return OSIP_SUCCESS;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "s_hash": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "unsigned\ns_hash (const unsigned char *p)\n{\n  unsigned hash = 0;\n\n  while (*p) {\n    hash *= 31;\n    hash ^= *p++;\n  }\n  return hash;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    },
    "__osip_add_ict": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        407,
        1
      ],
      "content": "int\n__osip_add_ict (osip_t * osip, osip_transaction_t * ict)\n{\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->ict_fastmutex);\n#endif\n#if defined(HAVE_DICT_DICT_H)\n  {\n    osip_generic_param_t *b_request = NULL;\n    int rv = -99;\n\n    osip_via_param_get_byname (ict->topvia, \"branch\", &b_request);\n    if (b_request != NULL && b_request->gvalue != NULL)\n      rv = dict_insert ((dict*)osip->osip_ict_hastable, b_request->gvalue, (void *) ict, FALSE);\n\n    if (rv == 0) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO1, NULL, \"New key inserted in ict hastable `%s'\\n\", b_request->gvalue));\n    }\n    else if (rv != -99) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"already inserted `%s'\\n\", b_request->gvalue));\n    }\n  }\n#endif\n  osip_list_add (&osip->osip_ict_transactions, ict, -1);\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->ict_fastmutex);\n#endif\n  return OSIP_SUCCESS;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "__osip_add_ist": {
      "start_point": [
        409,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "int\n__osip_add_ist (osip_t * osip, osip_transaction_t * ist)\n{\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->ist_fastmutex);\n#endif\n#if defined(HAVE_DICT_DICT_H)\n  {\n    osip_generic_param_t *b_request = NULL;\n    int rv = -99;\n\n    osip_via_param_get_byname (ist->topvia, \"branch\", &b_request);\n    if (b_request != NULL && b_request->gvalue != NULL)\n      rv = dict_insert ((dict*)osip->osip_ist_hastable, b_request->gvalue, (void *) ist, FALSE);\n    if (rv == 0) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO1, NULL, \"New key inserted in ist hastable `%s'\\n\", b_request->gvalue));\n    }\n    else if (rv != -99) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"already inserted `%s'\\n\", b_request->gvalue));\n    }\n  }\n#endif\n  osip_list_add (&osip->osip_ist_transactions, ist, -1);\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->ist_fastmutex);\n#endif\n  return OSIP_SUCCESS;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "__osip_add_nict": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "int\n__osip_add_nict (osip_t * osip, osip_transaction_t * nict)\n{\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->nict_fastmutex);\n#endif\n#if defined(HAVE_DICT_DICT_H)\n  {\n    osip_generic_param_t *b_request = NULL;\n    int rv = -99;\n\n    osip_via_param_get_byname (nict->topvia, \"branch\", &b_request);\n    if (b_request != NULL && b_request->gvalue != NULL)\n      rv = dict_insert ((dict*)osip->osip_nict_hastable, b_request->gvalue, (void *) nict, FALSE);\n\n    if (rv == 0) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO1, NULL, \"New key inserted in nict hastable `%s'\\n\", b_request->gvalue));\n    }\n    else if (rv != -99) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"already inserted `%s'\\n\", b_request->gvalue));\n    }\n  }\n#endif\n  osip_list_add (&osip->osip_nict_transactions, nict, -1);\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->nict_fastmutex);\n#endif\n  return OSIP_SUCCESS;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "__osip_add_nist": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        495,
        1
      ],
      "content": "int\n__osip_add_nist (osip_t * osip, osip_transaction_t * nist)\n{\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->nist_fastmutex);\n#endif\n#if defined(HAVE_DICT_DICT_H)\n  {\n    osip_generic_param_t *b_request = NULL;\n    int rv = -99;\n\n    osip_via_param_get_byname (nist->topvia, \"branch\", &b_request);\n    if (b_request != NULL && b_request->gvalue != NULL)\n      rv = dict_insert ((dict*)osip->osip_nist_hastable, b_request->gvalue, (void *) nist, FALSE);\n    if (rv == 0) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO1, NULL, \"New key inserted in ict hastable `%s'\\n\", b_request->gvalue));\n    }\n    else if (rv != -99) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"already inserted `%s'\\n\", b_request->gvalue));\n    }\n  }\n#endif\n  osip_list_add (&osip->osip_nist_transactions, nist, -1);\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->nist_fastmutex);\n#endif\n  return OSIP_SUCCESS;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_remove_transaction": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "int\nosip_remove_transaction (osip_t * osip, osip_transaction_t * tr)\n{\n  int i = -1;\n\n  if (tr == NULL)\n    return OSIP_BADPARAMETER;\n  if (tr->ctx_type == ICT)\n    i = __osip_remove_ict_transaction (osip, tr);\n  else if (tr->ctx_type == IST)\n    i = __osip_remove_ist_transaction (osip, tr);\n  else if (tr->ctx_type == NICT)\n    i = __osip_remove_nict_transaction (osip, tr);\n  else if (tr->ctx_type == NIST)\n    i = __osip_remove_nist_transaction (osip, tr);\n  else\n    return OSIP_BADPARAMETER;\n  return i;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "__osip_remove_ict_transaction": {
      "start_point": [
        517,
        0
      ],
      "end_point": [
        560,
        1
      ],
      "content": "int\n__osip_remove_ict_transaction (osip_t * osip, osip_transaction_t * ict)\n{\n  osip_list_iterator_t iterator;\n  osip_transaction_t *tmp;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->ict_fastmutex);\n#endif\n\n#if defined(HAVE_DICT_DICT_H)\n  {\n    osip_generic_param_t *b_request = NULL;\n    int rv;\n\n    osip_via_param_get_byname (ict->topvia, \"branch\", &b_request);\n    if (b_request != NULL && b_request->gvalue != NULL) {\n      rv = dict_remove ((dict*)osip->osip_ict_hastable, b_request->gvalue, TRUE);\n      if (rv == 0) {\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO1, NULL, \"New key deleted in ict hastable `%s'\\n\", b_request->gvalue));\n      }\n      else {\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"key not removed `%s'\\n\", b_request->gvalue));\n      }\n    }\n  }\n#endif\n\n  tmp = (osip_transaction_t *) osip_list_get_first (&osip->osip_ict_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    if (tmp->transactionid == ict->transactionid) {\n      osip_list_iterator_remove (&iterator);\n#ifndef OSIP_MONOTHREAD\n      osip_mutex_unlock (osip->ict_fastmutex);\n#endif\n      return OSIP_SUCCESS;\n    }\n    tmp = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->ict_fastmutex);\n#endif\n  return OSIP_UNDEFINED_ERROR;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "__osip_remove_ist_transaction": {
      "start_point": [
        562,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "int\n__osip_remove_ist_transaction (osip_t * osip, osip_transaction_t * ist)\n{\n  osip_list_iterator_t iterator;\n  osip_transaction_t *tmp;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->ist_fastmutex);\n#endif\n\n#if defined(HAVE_DICT_DICT_H)\n  {\n    osip_generic_param_t *b_request = NULL;\n    int rv;\n\n    osip_via_param_get_byname (ist->topvia, \"branch\", &b_request);\n    if (b_request != NULL && b_request->gvalue != NULL) {\n      rv = dict_remove ((dict*)osip->osip_ist_hastable, b_request->gvalue, TRUE);\n\n      if (rv == 0) {\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO1, NULL, \"New key deleted in ist hastable `%s'\\n\", b_request->gvalue));\n      }\n      else {\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"key not removed `%s'\\n\", b_request->gvalue));\n      }\n    }\n  }\n#endif\n\n  tmp = (osip_transaction_t *) osip_list_get_first (&osip->osip_ist_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    if (tmp->transactionid == ist->transactionid) {\n      osip_list_iterator_remove (&iterator);\n#ifndef OSIP_MONOTHREAD\n      osip_mutex_unlock (osip->ist_fastmutex);\n#endif\n      return OSIP_SUCCESS;\n    }\n    tmp = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->ist_fastmutex);\n#endif\n  return OSIP_UNDEFINED_ERROR;\n}",
      "lines": 45,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "__osip_remove_nict_transaction": {
      "start_point": [
        608,
        0
      ],
      "end_point": [
        652,
        1
      ],
      "content": "int\n__osip_remove_nict_transaction (osip_t * osip, osip_transaction_t * nict)\n{\n  osip_list_iterator_t iterator;\n  osip_transaction_t *tmp;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->nict_fastmutex);\n#endif\n\n#if defined(HAVE_DICT_DICT_H)\n  {\n    osip_generic_param_t *b_request = NULL;\n    int rv;\n\n    osip_via_param_get_byname (nict->topvia, \"branch\", &b_request);\n    if (b_request != NULL && b_request->gvalue != NULL) {\n      rv = dict_remove ((dict*)osip->osip_nict_hastable, b_request->gvalue, TRUE);\n\n      if (rv == 0) {\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO1, NULL, \"New key deleted in nict hastable `%s'\\n\", b_request->gvalue));\n      }\n      else {\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"key not removed `%s'\\n\", b_request->gvalue));\n      }\n    }\n  }\n#endif\n\n  tmp = (osip_transaction_t *) osip_list_get_first (&osip->osip_nict_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    if (tmp->transactionid == nict->transactionid) {\n      osip_list_iterator_remove (&iterator);\n#ifndef OSIP_MONOTHREAD\n      osip_mutex_unlock (osip->nict_fastmutex);\n#endif\n      return OSIP_SUCCESS;\n    }\n    tmp = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->nict_fastmutex);\n#endif\n  return OSIP_UNDEFINED_ERROR;\n}",
      "lines": 45,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "__osip_remove_nist_transaction": {
      "start_point": [
        654,
        0
      ],
      "end_point": [
        698,
        1
      ],
      "content": "int\n__osip_remove_nist_transaction (osip_t * osip, osip_transaction_t * nist)\n{\n  osip_list_iterator_t iterator;\n  osip_transaction_t *tmp;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->nist_fastmutex);\n#endif\n\n#if defined(HAVE_DICT_DICT_H)\n  {\n    osip_generic_param_t *b_request = NULL;\n    int rv;\n\n    osip_via_param_get_byname (nist->topvia, \"branch\", &b_request);\n    if (b_request != NULL && b_request->gvalue != NULL) {\n      rv = dict_remove ((dict*)osip->osip_nist_hastable, b_request->gvalue, TRUE);\n\n      if (rv == 0) {\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO1, NULL, \"New key deleted in ict hastable `%s'\\n\", b_request->gvalue));\n      }\n      else {\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"key not removed `%s'\\n\", b_request->gvalue));\n      }\n    }\n  }\n#endif\n\n  tmp = (osip_transaction_t *) osip_list_get_first (&osip->osip_nist_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    if (tmp->transactionid == nist->transactionid) {\n      osip_list_iterator_remove (&iterator);\n#ifndef OSIP_MONOTHREAD\n      osip_mutex_unlock (osip->nist_fastmutex);\n#endif\n      return OSIP_SUCCESS;\n    }\n    tmp = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->nist_fastmutex);\n#endif\n  return OSIP_UNDEFINED_ERROR;\n}",
      "lines": 45,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "osip_find_transaction_and_add_event": {
      "start_point": [
        700,
        0
      ],
      "end_point": [
        708,
        1
      ],
      "content": "int\nosip_find_transaction_and_add_event (osip_t * osip, osip_event_t * evt)\n{\n  osip_transaction_t *transaction = __osip_find_transaction (osip, evt, 1);\n\n  if (transaction == NULL)\n    return OSIP_UNDEFINED_ERROR;\n  return OSIP_SUCCESS;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "osip_find_transaction": {
      "start_point": [
        711,
        0
      ],
      "end_point": [
        715,
        1
      ],
      "content": "osip_transaction_t *\nosip_find_transaction (osip_t * osip, osip_event_t * evt)\n{\n  return __osip_find_transaction (osip, evt, 0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "osip_transaction_t",
        "*\nosip_find_transaction (osip_t * osip, osip_event_t * evt)",
        "*"
      ]
    },
    "__osip_find_transaction": {
      "start_point": [
        718,
        0
      ],
      "end_point": [
        814,
        1
      ],
      "content": "osip_transaction_t *\n__osip_find_transaction (osip_t * osip, osip_event_t * evt, int consume)\n{\n  osip_transaction_t *transaction = NULL;\n  osip_list_t *transactions = NULL;\n\n#ifndef OSIP_MONOTHREAD\n  struct osip_mutex *mut = NULL;\n#endif\n\n  if (evt == NULL || evt->sip == NULL || evt->sip->cseq == NULL)\n    return NULL;\n\n  if (EVT_IS_INCOMINGMSG (evt)) {\n    if (MSG_IS_REQUEST (evt->sip)) {\n      if (0 == strcmp (evt->sip->cseq->method, \"INVITE\")\n          || 0 == strcmp (evt->sip->cseq->method, \"ACK\")) {\n        transactions = &osip->osip_ist_transactions;\n#ifndef OSIP_MONOTHREAD\n        mut = osip->ist_fastmutex;\n#endif\n      }\n      else {\n        transactions = &osip->osip_nist_transactions;\n#ifndef OSIP_MONOTHREAD\n        mut = osip->nist_fastmutex;\n#endif\n      }\n    }\n    else {\n      if (0 == strcmp (evt->sip->cseq->method, \"INVITE\")) {\n        transactions = &osip->osip_ict_transactions;\n#ifndef OSIP_MONOTHREAD\n        mut = osip->ict_fastmutex;\n#endif\n      }\n      else {\n        transactions = &osip->osip_nict_transactions;\n#ifndef OSIP_MONOTHREAD\n        mut = osip->nict_fastmutex;\n#endif\n      }\n    }\n  }\n  else if (EVT_IS_OUTGOINGMSG (evt)) {\n    if (MSG_IS_RESPONSE (evt->sip)) {\n      if (0 == strcmp (evt->sip->cseq->method, \"INVITE\")) {\n        transactions = &osip->osip_ist_transactions;\n#ifndef OSIP_MONOTHREAD\n        mut = osip->ist_fastmutex;\n#endif\n      }\n      else {\n        transactions = &osip->osip_nist_transactions;\n#ifndef OSIP_MONOTHREAD\n        mut = osip->nist_fastmutex;\n#endif\n      }\n    }\n    else {\n      if (0 == strcmp (evt->sip->cseq->method, \"INVITE\")\n          || 0 == strcmp (evt->sip->cseq->method, \"ACK\")) {\n        transactions = &osip->osip_ict_transactions;\n#ifndef OSIP_MONOTHREAD\n        mut = osip->ict_fastmutex;\n#endif\n      }\n      else {\n        transactions = &osip->osip_nict_transactions;\n#ifndef OSIP_MONOTHREAD\n        mut = osip->nict_fastmutex;\n#endif\n      }\n    }\n  }\n  if (transactions == NULL)\n    return NULL;                /* not a message??? */\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (mut);\n#endif\n  transaction = osip_transaction_find (transactions, evt);\n  if (consume == 1) {           /* we add the event before releasing the mutex!! */\n    if (transaction != NULL) {\n      osip_transaction_add_event (transaction, evt);\n#ifndef OSIP_MONOTHREAD\n      osip_mutex_unlock (mut);\n#endif\n      return transaction;\n    }\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (mut);\n#endif\n\n  return transaction;\n}",
      "lines": 97,
      "depth": 17,
      "decorators": [
        "osip_transaction_t",
        "*\n__osip_find_transaction (osip_t * osip, osip_event_t * evt, int consume)",
        "*"
      ]
    },
    "osip_create_transaction": {
      "start_point": [
        816,
        0
      ],
      "end_point": [
        868,
        1
      ],
      "content": "osip_transaction_t *\nosip_create_transaction (osip_t * osip, osip_event_t * evt)\n{\n  osip_transaction_t *transaction;\n  int i;\n  osip_fsm_type_t ctx_type;\n\n  if (evt == NULL)\n    return NULL;\n  if (evt->sip == NULL)\n    return NULL;\n\n  /* make sure the request's method reflect the cseq value. */\n  if (MSG_IS_REQUEST (evt->sip)) {\n    /* delete request where cseq method does not match\n       the method in request-line */\n    if (evt->sip->cseq == NULL || evt->sip->cseq->method == NULL || evt->sip->sip_method == NULL) {\n      return NULL;\n    }\n    if (0 != strcmp (evt->sip->cseq->method, evt->sip->sip_method)) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"core module: Discard invalid message with method!=cseq!\\n\"));\n      return NULL;\n    }\n  }\n\n  if (MSG_IS_ACK (evt->sip))    /* ACK never create transactions */\n    return NULL;\n\n  if (EVT_IS_INCOMINGREQ (evt)) {\n    /* we create a new context for this incoming request */\n    if (0 == strcmp (evt->sip->cseq->method, \"INVITE\"))\n      ctx_type = IST;\n    else\n      ctx_type = NIST;\n  }\n  else if (EVT_IS_OUTGOINGREQ (evt)) {\n    if (0 == strcmp (evt->sip->cseq->method, \"INVITE\"))\n      ctx_type = ICT;\n    else\n      ctx_type = NICT;\n  }\n  else {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Cannot build a transaction for this message!\\n\"));\n    return NULL;\n  }\n\n  i = osip_transaction_init (&transaction, ctx_type, osip, evt->sip);\n  if (i != 0) {\n    return NULL;\n  }\n  evt->transactionid = transaction->transactionid;\n  return transaction;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "osip_transaction_t",
        "*\nosip_create_transaction (osip_t * osip, osip_event_t * evt)",
        "*"
      ]
    },
    "osip_transaction_find": {
      "start_point": [
        870,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "osip_transaction_t *\nosip_transaction_find (osip_list_t * transactions, osip_event_t * evt)\n{\n  osip_list_iterator_t iterator;\n  osip_transaction_t *transaction;\n  osip_t *osip = NULL;\n\n  transaction = (osip_transaction_t *) osip_list_get_first (transactions, &iterator);\n  if (transaction != NULL)\n    osip = (osip_t *) transaction->config;\n  if (osip == NULL)\n    return NULL;\n\n  if (EVT_IS_INCOMINGREQ (evt)) {\n#ifdef HAVE_DICT_DICT_H\n    /* search in hastable! */\n    osip_generic_param_t *b_request;\n    osip_via_t *topvia_request;\n\n    topvia_request = osip_list_get (&evt->sip->vias, 0);\n    if (topvia_request == NULL) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Remote UA is not compliant: missing a Via header!\\n\"));\n      return NULL;\n    }\n    osip_via_param_get_byname (topvia_request, \"branch\", &b_request);\n    if (b_request != NULL && b_request->gvalue != NULL) {\n      if (MSG_IS_INVITE (evt->sip) || MSG_IS_ACK (evt->sip)) {\n        transaction = (osip_transaction_t *) dict_search ((dict*)osip->osip_ist_hastable, b_request->gvalue);\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"Find matching Via header for INVITE(ACK) REQUEST!\\n\"));\n        if (transaction != NULL)\n          return transaction;\n      }\n      else {\n        transaction = (osip_transaction_t *) dict_search ((dict*)osip->osip_nist_hastable, b_request->gvalue);\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"Find matching Via header for NON-INVITE REQUEST!\\n\"));\n        if (transaction != NULL)\n          return transaction;\n      }\n    }\n#endif\n\n    transaction = (osip_transaction_t *) osip_list_get_first (transactions, &iterator);\n    while (osip_list_iterator_has_elem (iterator)) {\n      if (0 == __osip_transaction_matching_request_osip_to_xist_17_2_3 (transaction, evt->sip))\n        return transaction;\n      transaction = (osip_transaction_t *) osip_list_get_next (&iterator);\n    }\n  }\n  else if (EVT_IS_INCOMINGRESP (evt)) {\n#ifdef HAVE_DICT_DICT_H\n    /* search in hastable! */\n    osip_generic_param_t *b_request;\n    osip_via_t *topvia_request;\n\n    topvia_request = osip_list_get (&evt->sip->vias, 0);\n    if (topvia_request == NULL) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Remote UA is not compliant: missing a Via header!\\n\"));\n      return NULL;\n    }\n    osip_via_param_get_byname (topvia_request, \"branch\", &b_request);\n    if (b_request != NULL && b_request->gvalue != NULL) {\n      if (MSG_IS_RESPONSE_FOR (evt->sip, \"INVITE\")) {\n        transaction = (osip_transaction_t *) dict_search ((dict*)osip->osip_ict_hastable, b_request->gvalue);\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"Find matching Via header for INVITE ANSWER!\\n\"));\n        if (transaction != NULL)\n          return transaction;\n      }\n      else {\n        transaction = (osip_transaction_t *) dict_search ((dict*)osip->osip_nict_hastable, b_request->gvalue);\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"Find matching Via header for NON-INVITE ANSWER!\\n\"));\n        if (transaction != NULL)\n          return transaction;\n      }\n    }\n#endif\n\n    transaction = (osip_transaction_t *) osip_list_get_first (transactions, &iterator);\n    while (osip_list_iterator_has_elem (iterator)) {\n      if (0 == __osip_transaction_matching_response_osip_to_xict_17_1_3 (transaction, evt->sip))\n        return transaction;\n      transaction = (osip_transaction_t *) osip_list_get_next (&iterator);\n    }\n  }\n  else {                        /* handle OUTGOING message */\n    /* THE TRANSACTION ID MUST BE SET */\n    transaction = (osip_transaction_t *) osip_list_get_first (transactions, &iterator);\n    while (osip_list_iterator_has_elem (iterator)) {\n      if (transaction->transactionid == evt->transactionid)\n        return transaction;\n      transaction = (osip_transaction_t *) osip_list_get_next (&iterator);\n    }\n  }\n  return NULL;\n}",
      "lines": 94,
      "depth": 19,
      "decorators": [
        "osip_transaction_t",
        "*\nosip_transaction_find (osip_list_t * transactions, osip_event_t * evt)",
        "*"
      ]
    },
    "osip_init": {
      "start_point": [
        965,
        0
      ],
      "end_point": [
        1008,
        1
      ],
      "content": "int\nosip_init (osip_t ** osip)\n{\n  static int ref_count = 0;\n\n  if (ref_count == 0) {\n    ref_count++;\n    /* load the parser configuration */\n    parser_init ();\n  }\n\n  *osip = (osip_t *) osip_malloc (sizeof (osip_t));\n  if (*osip == NULL)\n    return OSIP_NOMEM;          /* allocation failed */\n\n  memset (*osip, 0, sizeof (osip_t));\n\n#ifndef OSIP_MONOTHREAD\n  (*osip)->ict_fastmutex = osip_mutex_init ();\n  (*osip)->ist_fastmutex = osip_mutex_init ();\n  (*osip)->nict_fastmutex = osip_mutex_init ();\n  (*osip)->nist_fastmutex = osip_mutex_init ();\n\n  (*osip)->ixt_fastmutex = osip_mutex_init ();\n  (*osip)->id_mutex = osip_mutex_init ();\n#endif\n\n  osip_list_init (&(*osip)->osip_ict_transactions);\n  osip_list_init (&(*osip)->osip_ist_transactions);\n  osip_list_init (&(*osip)->osip_nict_transactions);\n  osip_list_init (&(*osip)->osip_nist_transactions);\n  osip_list_init (&(*osip)->ixt_retransmissions);\n\n  (*osip)->transactionid = 1;\n\n#if defined(HAVE_DICT_DICT_H)\n  (*osip)->osip_ict_hastable = (dict*)hashtable_dict_new ((dict_cmp_func) strcmp, (dict_hsh_func) s_hash, NULL, NULL, HSIZE);\n  (*osip)->osip_ist_hastable = (dict*)hashtable_dict_new ((dict_cmp_func) strcmp, (dict_hsh_func) s_hash, NULL, NULL, HSIZE);\n  (*osip)->osip_nict_hastable = (dict*)hashtable_dict_new ((dict_cmp_func) strcmp, (dict_hsh_func) s_hash, NULL, NULL, HSIZE);\n  (*osip)->osip_nist_hastable = (dict*)hashtable_dict_new ((dict_cmp_func) strcmp, (dict_hsh_func) s_hash, NULL, NULL, HSIZE);\n#endif\n\n  return OSIP_SUCCESS;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_release": {
      "start_point": [
        1010,
        0
      ],
      "end_point": [
        1024,
        1
      ],
      "content": "void\nosip_release (osip_t * osip)\n{\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_destroy (osip->ict_fastmutex);\n  osip_mutex_destroy (osip->ist_fastmutex);\n  osip_mutex_destroy (osip->nict_fastmutex);\n  osip_mutex_destroy (osip->nist_fastmutex);\n\n  osip_mutex_destroy (osip->ixt_fastmutex);\n  osip_mutex_destroy (osip->id_mutex);\n#endif\n\n  osip_free (osip);\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_set_application_context": {
      "start_point": [
        1026,
        0
      ],
      "end_point": [
        1030,
        1
      ],
      "content": "void\nosip_set_application_context (osip_t * osip, void *pointer)\n{\n  osip->application_context = pointer;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_get_application_context": {
      "start_point": [
        1032,
        0
      ],
      "end_point": [
        1038,
        1
      ],
      "content": "void *\nosip_get_application_context (osip_t * osip)\n{\n  if (osip == NULL)\n    return NULL;\n  return osip->application_context;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void",
        "*\nosip_get_application_context (osip_t * osip)",
        "*"
      ]
    },
    "osip_ict_execute": {
      "start_point": [
        1040,
        0
      ],
      "end_point": [
        1094,
        1
      ],
      "content": "int\nosip_ict_execute (osip_t * osip)\n{\n  osip_transaction_t *transaction;\n  osip_event_t *se;\n  int more_event;\n  osip_list_iterator_t iterator;\n  void **array;\n  int len;\n  int index = 0;\n\n  /* list must be copied because osip_transaction_execute() may change it */\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->ict_fastmutex);\n#endif\n  len = osip_list_size (&osip->osip_ict_transactions);\n  if (0 >= len) {\n#ifndef OSIP_MONOTHREAD\n    osip_mutex_unlock (osip->ict_fastmutex);\n#endif\n    return OSIP_SUCCESS;\n  }\n  array = osip_malloc (sizeof (void *) * len);\n  if (array == NULL) {\n#ifndef OSIP_MONOTHREAD\n    osip_mutex_unlock (osip->ict_fastmutex);\n#endif\n    return OSIP_NOMEM;          /* OSIP_SUCCESS; */\n  }\n  transaction = (osip_transaction_t *) osip_list_get_first (&osip->osip_ict_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    array[index++] = transaction;\n    transaction = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->ict_fastmutex);\n#endif\n\n  for (index = 0; index < len; ++index) {\n    transaction = (osip_transaction_t *) array[index];\n    more_event = 1;\n    do {\n      se = (osip_event_t *) osip_fifo_tryget (transaction->transactionff);\n      if (se == NULL)           /* no more event for this transaction */\n        more_event = 0;\n      else\n        osip_transaction_execute (transaction, se);\n    }\n    while (more_event == 1);\n  }\n\n  osip_free (array);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_ist_execute": {
      "start_point": [
        1096,
        0
      ],
      "end_point": [
        1151,
        1
      ],
      "content": "int\nosip_ist_execute (osip_t * osip)\n{\n  osip_transaction_t *transaction;\n  osip_event_t *se;\n  int more_event;\n  osip_list_iterator_t iterator;\n  void **array;\n  int len;\n  int index = 0;\n\n  /* list must be copied because osip_transaction_execute() may change it */\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->ist_fastmutex);\n#endif\n  len = osip_list_size (&osip->osip_ist_transactions);\n  if (0 >= len) {\n#ifndef OSIP_MONOTHREAD\n    osip_mutex_unlock (osip->ist_fastmutex);\n#endif\n    return OSIP_SUCCESS;\n  }\n  array = osip_malloc (sizeof (void *) * len);\n  if (array == NULL) {\n#ifndef OSIP_MONOTHREAD\n    osip_mutex_unlock (osip->ist_fastmutex);\n#endif\n    return OSIP_NOMEM;          /* OSIP_SUCCESS; */\n  }\n  transaction = (osip_transaction_t *) osip_list_get_first (&osip->osip_ist_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    array[index++] = transaction;\n    transaction = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->ist_fastmutex);\n#endif\n\n  for (index = 0; index < len; ++index) {\n    transaction = (osip_transaction_t *) array[index];\n    more_event = 1;\n    do {\n      se = (osip_event_t *) osip_fifo_tryget (transaction->transactionff);\n      if (se == NULL)           /* no more event for this transaction */\n        more_event = 0;\n      else\n        osip_transaction_execute (transaction, se);\n    }\n    while (more_event == 1);\n\n  }\n\n  osip_free (array);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_nict_execute": {
      "start_point": [
        1153,
        0
      ],
      "end_point": [
        1207,
        1
      ],
      "content": "int\nosip_nict_execute (osip_t * osip)\n{\n  osip_transaction_t *transaction;\n  osip_event_t *se;\n  int more_event;\n  osip_list_iterator_t iterator;\n  void **array;\n  int len;\n  int index = 0;\n\n  /* list must be copied because osip_transaction_execute() may change it */\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->nict_fastmutex);\n#endif\n  len = osip_list_size (&osip->osip_nict_transactions);\n  if (0 >= len) {\n#ifndef OSIP_MONOTHREAD\n    osip_mutex_unlock (osip->nict_fastmutex);\n#endif\n    return OSIP_SUCCESS;\n  }\n  array = osip_malloc (sizeof (void *) * len);\n  if (array == NULL) {\n#ifndef OSIP_MONOTHREAD\n    osip_mutex_unlock (osip->nict_fastmutex);\n#endif\n    return OSIP_NOMEM;          /* OSIP_SUCCESS; */\n  }\n  transaction = (osip_transaction_t *) osip_list_get_first (&osip->osip_nict_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    array[index++] = transaction;\n    transaction = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->nict_fastmutex);\n#endif\n\n  for (index = 0; index < len; ++index) {\n    transaction = (osip_transaction_t *) array[index];\n    more_event = 1;\n    do {\n      se = (osip_event_t *) osip_fifo_tryget (transaction->transactionff);\n      if (se == NULL)           /* no more event for this transaction */\n        more_event = 0;\n      else\n        osip_transaction_execute (transaction, se);\n    }\n    while (more_event == 1);\n  }\n\n  osip_free (array);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_nist_execute": {
      "start_point": [
        1209,
        0
      ],
      "end_point": [
        1263,
        1
      ],
      "content": "int\nosip_nist_execute (osip_t * osip)\n{\n  osip_transaction_t *transaction;\n  osip_event_t *se;\n  int more_event;\n  osip_list_iterator_t iterator;\n  void **array;\n  int len;\n  int index = 0;\n\n  /* list must be copied because osip_transaction_execute() may change it */\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->nist_fastmutex);\n#endif\n  len = osip_list_size (&osip->osip_nist_transactions);\n  if (0 >= len) {\n#ifndef OSIP_MONOTHREAD\n    osip_mutex_unlock (osip->nist_fastmutex);\n#endif\n    return OSIP_SUCCESS;\n  }\n  array = osip_malloc (sizeof (void *) * len);\n  if (array == NULL) {\n#ifndef OSIP_MONOTHREAD\n    osip_mutex_unlock (osip->nist_fastmutex);\n#endif\n    return OSIP_NOMEM;          /* OSIP_SUCCESS; */\n  }\n  transaction = (osip_transaction_t *) osip_list_get_first (&osip->osip_nist_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    array[index++] = transaction;\n    transaction = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->nist_fastmutex);\n#endif\n\n  for (index = 0; index < len; ++index) {\n    transaction = (osip_transaction_t *) array[index];\n    more_event = 1;\n    do {\n      se = (osip_event_t *) osip_fifo_tryget (transaction->transactionff);\n      if (se == NULL)           /* no more event for this transaction */\n        more_event = 0;\n      else\n        osip_transaction_execute (transaction, se);\n    }\n    while (more_event == 1);\n  }\n\n  osip_free (array);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_timers_gettimeout": {
      "start_point": [
        1265,
        0
      ],
      "end_point": [
        1429,
        1
      ],
      "content": "void\nosip_timers_gettimeout (osip_t * osip, struct timeval *lower_tv)\n{\n  struct timeval now;\n  osip_transaction_t *tr;\n  osip_list_iterator_t iterator;\n\n  osip_gettimeofday (&now, NULL);\n  lower_tv->tv_sec = now.tv_sec + 3600 * 24 * 365;      /* wake up evry year :-) */\n  lower_tv->tv_usec = now.tv_usec;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->ict_fastmutex);\n#endif\n  /* handle ict timers */\n  tr = (osip_transaction_t *) osip_list_get_first (&osip->osip_ict_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    if (1 <= osip_fifo_size (tr->transactionff)) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO4, NULL, \"1 Pending event already in transaction !\\n\"));\n      lower_tv->tv_sec = 0;\n      lower_tv->tv_usec = 0;\n#ifndef OSIP_MONOTHREAD\n      osip_mutex_unlock (osip->ict_fastmutex);\n#endif\n      return;\n    }\n    else {\n      if (tr->state == ICT_CALLING)\n        min_timercmp (lower_tv, &tr->ict_context->timer_b_start);\n      if (tr->state == ICT_CALLING)\n        min_timercmp (lower_tv, &tr->ict_context->timer_a_start);\n      if (tr->state == ICT_COMPLETED)\n        min_timercmp (lower_tv, &tr->ict_context->timer_d_start);\n      if (osip_timercmp (&now, lower_tv, >)) {\n        lower_tv->tv_sec = 0;\n        lower_tv->tv_usec = 0;\n#ifndef OSIP_MONOTHREAD\n        osip_mutex_unlock (osip->ict_fastmutex);\n#endif\n        return;\n      }\n    }\n    tr = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->ict_fastmutex);\n#endif\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->ist_fastmutex);\n#endif\n  /* handle ist timers */\n  tr = (osip_transaction_t *) osip_list_get_first (&osip->osip_ist_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    if (tr->state == IST_CONFIRMED)\n      min_timercmp (lower_tv, &tr->ist_context->timer_i_start);\n    if (tr->state == IST_COMPLETED)\n      min_timercmp (lower_tv, &tr->ist_context->timer_h_start);\n    if (tr->state == IST_COMPLETED)\n      min_timercmp (lower_tv, &tr->ist_context->timer_g_start);\n    if (osip_timercmp (&now, lower_tv, >)) {\n      lower_tv->tv_sec = 0;\n      lower_tv->tv_usec = 0;\n#ifndef OSIP_MONOTHREAD\n      osip_mutex_unlock (osip->ist_fastmutex);\n#endif\n      return;\n    }\n    tr = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->ist_fastmutex);\n#endif\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->nict_fastmutex);\n#endif\n  /* handle nict timers */\n  tr = (osip_transaction_t *) osip_list_get_first (&osip->osip_nict_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    if (tr->state == NICT_COMPLETED)\n      min_timercmp (lower_tv, &tr->nict_context->timer_k_start);\n    if (tr->state == NICT_PROCEEDING || tr->state == NICT_TRYING)\n      min_timercmp (lower_tv, &tr->nict_context->timer_f_start);\n    if (tr->state == NICT_PROCEEDING || tr->state == NICT_TRYING)\n      min_timercmp (lower_tv, &tr->nict_context->timer_e_start);\n    if (osip_timercmp (&now, lower_tv, >)) {\n      lower_tv->tv_sec = 0;\n      lower_tv->tv_usec = 0;\n#ifndef OSIP_MONOTHREAD\n      osip_mutex_unlock (osip->nict_fastmutex);\n#endif\n      return;\n    }\n    tr = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->nict_fastmutex);\n#endif\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->nist_fastmutex);\n#endif\n  /* handle nist timers */\n  tr = (osip_transaction_t *) osip_list_get_first (&osip->osip_nist_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    if (tr->state == NIST_COMPLETED)\n      min_timercmp (lower_tv, &tr->nist_context->timer_j_start);\n    if (osip_timercmp (&now, lower_tv, >)) {\n      lower_tv->tv_sec = 0;\n      lower_tv->tv_usec = 0;\n#ifndef OSIP_MONOTHREAD\n      osip_mutex_unlock (osip->nist_fastmutex);\n#endif\n      return;\n    }\n    tr = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->nist_fastmutex);\n#endif\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->ixt_fastmutex);\n#endif\n  {\n    ixt_t *ixt;\n\n    ixt = (ixt_t *) osip_list_get_first (&osip->ixt_retransmissions, &iterator);\n    while (osip_list_iterator_has_elem (iterator)) {\n      min_timercmp (lower_tv, &ixt->start);\n      if (osip_timercmp (&now, lower_tv, >)) {\n        lower_tv->tv_sec = 0;\n        lower_tv->tv_usec = 0;\n#ifndef OSIP_MONOTHREAD\n        osip_mutex_unlock (osip->ixt_fastmutex);\n#endif\n        return;\n      }\n\n      ixt = (ixt_t *) osip_list_get_next (&iterator);\n    }\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->ixt_fastmutex);\n#endif\n\n  lower_tv->tv_sec = lower_tv->tv_sec - now.tv_sec;\n  lower_tv->tv_usec = lower_tv->tv_usec - now.tv_usec;\n\n  /* just make sure the value is correct! */\n  if (lower_tv->tv_usec < 0) {\n    lower_tv->tv_usec = lower_tv->tv_usec + 1000000;\n    lower_tv->tv_sec--;\n  }\n  if (lower_tv->tv_sec < 0) {\n    lower_tv->tv_sec = 0;\n    lower_tv->tv_usec = 0;\n  }\n  if (lower_tv->tv_usec > 1000000) {\n    lower_tv->tv_usec = lower_tv->tv_usec - 1000000;\n    lower_tv->tv_sec++;\n  }\n  return;\n}",
      "lines": 165,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "osip_timers_ict_execute": {
      "start_point": [
        1431,
        0
      ],
      "end_point": [
        1468,
        1
      ],
      "content": "void\nosip_timers_ict_execute (osip_t * osip)\n{\n  osip_transaction_t *tr;\n  osip_list_iterator_t iterator;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->ict_fastmutex);\n#endif\n  /* handle ict timers */\n  tr = (osip_transaction_t *) osip_list_get_first (&osip->osip_ict_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    osip_event_t *evt;\n\n    if (1 <= osip_fifo_size (tr->transactionff)) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO4, NULL, \"1 Pending event already in transaction !\\n\"));\n    }\n    else {\n      evt = __osip_ict_need_timer_b_event (tr->ict_context, tr->state, tr->transactionid);\n      if (evt != NULL)\n        osip_fifo_add (tr->transactionff, evt);\n      else {\n        evt = __osip_ict_need_timer_a_event (tr->ict_context, tr->state, tr->transactionid);\n        if (evt != NULL)\n          osip_fifo_add (tr->transactionff, evt);\n        else {\n          evt = __osip_ict_need_timer_d_event (tr->ict_context, tr->state, tr->transactionid);\n          if (evt != NULL)\n            osip_fifo_add (tr->transactionff, evt);\n        }\n      }\n    }\n    tr = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->ict_fastmutex);\n#endif\n}",
      "lines": 38,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "osip_timers_ist_execute": {
      "start_point": [
        1470,
        0
      ],
      "end_point": [
        1502,
        1
      ],
      "content": "void\nosip_timers_ist_execute (osip_t * osip)\n{\n  osip_transaction_t *tr;\n  osip_list_iterator_t iterator;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->ist_fastmutex);\n#endif\n  /* handle ist timers */\n  tr = (osip_transaction_t *) osip_list_get_first (&osip->osip_ist_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    osip_event_t *evt;\n\n    evt = __osip_ist_need_timer_i_event (tr->ist_context, tr->state, tr->transactionid);\n    if (evt != NULL)\n      osip_fifo_add (tr->transactionff, evt);\n    else {\n      evt = __osip_ist_need_timer_h_event (tr->ist_context, tr->state, tr->transactionid);\n      if (evt != NULL)\n        osip_fifo_add (tr->transactionff, evt);\n      else {\n        evt = __osip_ist_need_timer_g_event (tr->ist_context, tr->state, tr->transactionid);\n        if (evt != NULL)\n          osip_fifo_add (tr->transactionff, evt);\n      }\n    }\n    tr = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->ist_fastmutex);\n#endif\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "osip_timers_nict_execute": {
      "start_point": [
        1504,
        0
      ],
      "end_point": [
        1536,
        1
      ],
      "content": "void\nosip_timers_nict_execute (osip_t * osip)\n{\n  osip_transaction_t *tr;\n  osip_list_iterator_t iterator;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->nict_fastmutex);\n#endif\n  /* handle nict timers */\n  tr = (osip_transaction_t *) osip_list_get_first (&osip->osip_nict_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    osip_event_t *evt;\n\n    evt = __osip_nict_need_timer_k_event (tr->nict_context, tr->state, tr->transactionid);\n    if (evt != NULL)\n      osip_fifo_add (tr->transactionff, evt);\n    else {\n      evt = __osip_nict_need_timer_f_event (tr->nict_context, tr->state, tr->transactionid);\n      if (evt != NULL)\n        osip_fifo_add (tr->transactionff, evt);\n      else {\n        evt = __osip_nict_need_timer_e_event (tr->nict_context, tr->state, tr->transactionid);\n        if (evt != NULL)\n          osip_fifo_add (tr->transactionff, evt);\n      }\n    }\n    tr = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->nict_fastmutex);\n#endif\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "osip_timers_nist_execute": {
      "start_point": [
        1539,
        0
      ],
      "end_point": [
        1561,
        1
      ],
      "content": "void\nosip_timers_nist_execute (osip_t * osip)\n{\n  osip_transaction_t *tr;\n  osip_list_iterator_t iterator;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (osip->nist_fastmutex);\n#endif\n  /* handle nist timers */\n  tr = (osip_transaction_t *) osip_list_get_first (&osip->osip_nist_transactions, &iterator);\n  while (osip_list_iterator_has_elem (iterator)) {\n    osip_event_t *evt;\n\n    evt = __osip_nist_need_timer_j_event (tr->nist_context, tr->state, tr->transactionid);\n    if (evt != NULL)\n      osip_fifo_add (tr->transactionff, evt);\n    tr = (osip_transaction_t *) osip_list_get_next (&iterator);\n  }\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (osip->nist_fastmutex);\n#endif\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "osip_set_cb_send_message": {
      "start_point": [
        1563,
        0
      ],
      "end_point": [
        1567,
        1
      ],
      "content": "void\nosip_set_cb_send_message (osip_t * cf, int (*cb) (osip_transaction_t *, osip_message_t *, char *, int, int))\n{\n  cf->cb_send_message = cb;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "__osip_message_callback": {
      "start_point": [
        1569,
        0
      ],
      "end_point": [
        1581,
        1
      ],
      "content": "void\n__osip_message_callback (int type, osip_transaction_t * tr, osip_message_t * msg)\n{\n  osip_t *config = tr->config;\n\n  if (type >= OSIP_MESSAGE_CALLBACK_COUNT) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_BUG, NULL, \"invalid callback type %d\\n\", type));\n    return;\n  }\n  if (config->msg_callbacks[type] == NULL)\n    return;\n  config->msg_callbacks[type] (type, tr, msg);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "__osip_kill_transaction_callback": {
      "start_point": [
        1583,
        0
      ],
      "end_point": [
        1596,
        1
      ],
      "content": "void\n__osip_kill_transaction_callback (int type, osip_transaction_t * tr)\n{\n  osip_t *config = tr->config;\n\n  if (type >= OSIP_KILL_CALLBACK_COUNT) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_BUG, NULL, \"invalid callback type %d\\n\", type));\n    return;\n  }\n  tr->completed_time = osip_getsystemtime (NULL);\n  if (config->kill_callbacks[type] == NULL)\n    return;\n  config->kill_callbacks[type] (type, tr);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "__osip_transport_error_callback": {
      "start_point": [
        1598,
        0
      ],
      "end_point": [
        1610,
        1
      ],
      "content": "void\n__osip_transport_error_callback (int type, osip_transaction_t * tr, int error)\n{\n  osip_t *config = tr->config;\n\n  if (type >= OSIP_TRANSPORT_ERROR_CALLBACK_COUNT) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_BUG, NULL, \"invalid callback type %d\\n\", type));\n    return;\n  }\n  if (config->tp_error_callbacks[type] == NULL)\n    return;\n  config->tp_error_callbacks[type] (type, tr, error);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "osip_set_message_callback": {
      "start_point": [
        1613,
        0
      ],
      "end_point": [
        1623,
        1
      ],
      "content": "int\nosip_set_message_callback (osip_t * config, int type, osip_message_cb_t cb)\n{\n  if (type >= OSIP_MESSAGE_CALLBACK_COUNT) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"invalid callback type %d\\n\", type));\n    return OSIP_BADPARAMETER;\n  }\n  config->msg_callbacks[type] = cb;\n\n  return OSIP_SUCCESS;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_set_kill_transaction_callback": {
      "start_point": [
        1625,
        0
      ],
      "end_point": [
        1634,
        1
      ],
      "content": "int\nosip_set_kill_transaction_callback (osip_t * config, int type, osip_kill_transaction_cb_t cb)\n{\n  if (type >= OSIP_KILL_CALLBACK_COUNT) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"invalid callback type %d\\n\", type));\n    return OSIP_BADPARAMETER;\n  }\n  config->kill_callbacks[type] = cb;\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_set_transport_error_callback": {
      "start_point": [
        1636,
        0
      ],
      "end_point": [
        1645,
        1
      ],
      "content": "int\nosip_set_transport_error_callback (osip_t * config, int type, osip_transport_error_cb_t cb)\n{\n  if (type >= OSIP_TRANSPORT_ERROR_CALLBACK_COUNT) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"invalid callback type %d\\n\", type));\n    return OSIP_BADPARAMETER;\n  }\n  config->tp_error_callbacks[type] = cb;\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/osip_dialog.c": {
    "osip_dialog_set_state": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "void\nosip_dialog_set_state (osip_dialog_t * dialog, state_t state)\n{\n  if (dialog == NULL)\n    return;\n  dialog->state = state;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_dialog_update_route_set_as_uas": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nosip_dialog_update_route_set_as_uas (osip_dialog_t * dialog, osip_message_t * invite)\n{\n  osip_contact_t *contact;\n  int i;\n\n  if (dialog == NULL)\n    return OSIP_BADPARAMETER;\n  if (invite == NULL)\n    return OSIP_BADPARAMETER;\n\n  if (osip_list_eol (&invite->contacts, 0)) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"missing a contact in invite!\\n\"));\n  }\n  else {\n    if (dialog->remote_contact_uri != NULL) {\n      osip_contact_free (dialog->remote_contact_uri);\n    }\n    dialog->remote_contact_uri = NULL;\n    contact = osip_list_get (&invite->contacts, 0);\n    i = osip_contact_clone (contact, &(dialog->remote_contact_uri));\n    if (i != 0)\n      return i;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_dialog_update_osip_cseq_as_uas": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nosip_dialog_update_osip_cseq_as_uas (osip_dialog_t * dialog, osip_message_t * invite)\n{\n  if (dialog == NULL)\n    return OSIP_BADPARAMETER;\n  if (invite == NULL || invite->cseq == NULL || invite->cseq->number == NULL)\n    return OSIP_BADPARAMETER;\n\n  dialog->remote_cseq = osip_atoi (invite->cseq->number);\n  return OSIP_SUCCESS;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_dialog_update_route_set_as_uac": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\nosip_dialog_update_route_set_as_uac (osip_dialog_t * dialog, osip_message_t * response)\n{\n  /* only the remote target URI is updated here... */\n  osip_contact_t *contact;\n  int i;\n\n  if (dialog == NULL)\n    return OSIP_BADPARAMETER;\n  if (response == NULL)\n    return OSIP_BADPARAMETER;\n\n  if (osip_list_eol (&response->contacts, 0)) { /* no contact header in response? */\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"missing a contact in response!\\n\"));\n  }\n  else {\n    /* I personally think it's a bad idea to keep the old\n       value in case the new one is broken... */\n    if (dialog->remote_contact_uri != NULL) {\n      osip_contact_free (dialog->remote_contact_uri);\n    }\n    dialog->remote_contact_uri = NULL;\n    contact = osip_list_get (&response->contacts, 0);\n    i = osip_contact_clone (contact, &(dialog->remote_contact_uri));\n    if (i != 0)\n      return i;\n  }\n\n  if (dialog->state == DIALOG_EARLY && osip_list_size (&dialog->route_set) > 0) {\n    osip_list_special_free (&dialog->route_set, (void (*)(void *)) &osip_record_route_free);\n    osip_list_init (&dialog->route_set);\n  }\n\n  if (dialog->state == DIALOG_EARLY && osip_list_size (&dialog->route_set) == 0) {      /* update the route set */\n    int pos = 0;\n\n    while (!osip_list_eol (&response->record_routes, pos)) {\n      osip_record_route_t *rr;\n      osip_record_route_t *rr2;\n\n      rr = (osip_record_route_t *) osip_list_get (&response->record_routes, pos);\n      i = osip_record_route_clone (rr, &rr2);\n      if (i != 0)\n        return i;\n      osip_list_add (&dialog->route_set, rr2, 0);\n      pos++;\n    }\n  }\n\n  if (MSG_IS_STATUS_2XX (response))\n    dialog->state = DIALOG_CONFIRMED;\n  return OSIP_SUCCESS;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_dialog_update_tag_as_uac": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\nosip_dialog_update_tag_as_uac (osip_dialog_t * dialog, osip_message_t * response)\n{\n  osip_generic_param_t *tag;\n  int i;\n\n  if (dialog == NULL)\n    return OSIP_BADPARAMETER;\n  if (response == NULL || response->to == NULL)\n    return OSIP_BADPARAMETER;\n\n  if (dialog->remote_tag != NULL) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"This dialog already have a remote tag: it can't be changed!\\n\"));\n    return OSIP_WRONG_STATE;\n  }\n\n  i = osip_to_get_tag (response->to, &tag);\n  if (i != 0 || tag == NULL || tag->gvalue == NULL) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"Remote UA is not compliant: missing a tag in response!\\n\"));\n    dialog->remote_tag = NULL;\n  }\n  else\n    dialog->remote_tag = osip_strdup (tag->gvalue);\n  return OSIP_SUCCESS;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_dialog_match_as_uac": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "int\nosip_dialog_match_as_uac (osip_dialog_t * dlg, osip_message_t * answer)\n{\n  osip_generic_param_t *tag_param_local;\n  osip_generic_param_t *tag_param_remote;\n  char *tmp;\n  int i;\n\n  if (dlg == NULL || dlg->call_id == NULL)\n    return OSIP_BADPARAMETER;\n  if (answer == NULL || answer->call_id == NULL || answer->from == NULL || answer->to == NULL)\n    return OSIP_BADPARAMETER;\n\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"Using this method is discouraged. See source code explanations!\\n\"));\n  /*\n     When starting a new transaction and when receiving several answers,\n     you must be prepared to receive several answers from different sources.\n     (because of forking).\n\n     Because some UAs are not compliant (a to tag is missing!), this method\n     may match the wrong dialog when a dialog has been created with an empty\n     tag in the To header.\n\n     Personnaly, I would recommend to discard 1xx>=101 answers without To tags!\n     Just my own feelings.\n   */\n  i = osip_call_id_to_str (answer->call_id, &tmp);\n  if (i != 0)\n    return i;\n\n  if (0 != strcmp (dlg->call_id, tmp)) {\n    osip_free (tmp);\n    return OSIP_UNDEFINED_ERROR;\n  }\n  osip_free (tmp);\n\n  /* for INCOMING RESPONSE:\n     To: remote_uri;remote_tag\n     From: local_uri;local_tag           <- LOCAL TAG ALWAYS EXIST\n   */\n  i = osip_from_get_tag (answer->from, &tag_param_local);\n  if (i != 0)\n    return OSIP_SYNTAXERROR;\n  if (dlg->local_tag == NULL)\n    /* NOT POSSIBLE BECAUSE I MANAGE REMOTE_TAG AND I ALWAYS ADD IT! */\n    return OSIP_SYNTAXERROR;\n  if (0 != strcmp (tag_param_local->gvalue, dlg->local_tag))\n    return OSIP_UNDEFINED_ERROR;\n\n  i = osip_to_get_tag (answer->to, &tag_param_remote);\n  if (i != 0 && dlg->remote_tag != NULL)        /* no tag in response but tag in dialog */\n    return OSIP_SYNTAXERROR;    /* impossible... */\n  if (i != 0 && dlg->remote_tag == NULL) {      /* no tag in response AND no tag in dialog */\n    if (0 == osip_from_compare ((osip_from_t *) dlg->local_uri, (osip_from_t *) answer->from)\n        && 0 == osip_from_compare (dlg->remote_uri, answer->to))\n      return OSIP_SUCCESS;\n    return OSIP_UNDEFINED_ERROR;\n  }\n\n  if (dlg->remote_tag == NULL) {        /* tag in response BUT no tag in dialog */\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"Remote UA is not compliant: missing a tag in To fields!\\n\"));\n    if (0 == osip_from_compare ((osip_from_t *) dlg->local_uri, (osip_from_t *) answer->from)\n        && 0 == osip_from_compare (dlg->remote_uri, answer->to))\n      return OSIP_SUCCESS;\n    return OSIP_UNDEFINED_ERROR;\n  }\n\n  /* we don't have to compare\n     remote_uri with from\n     && local_uri with to.    ----> we have both tag recognized, it's enough..\n   */\n  if (0 == strcmp (tag_param_remote->gvalue, dlg->remote_tag))\n    return OSIP_SUCCESS;\n  return OSIP_UNDEFINED_ERROR;\n}",
      "lines": 75,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_dialog_match_as_uas": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "int\nosip_dialog_match_as_uas (osip_dialog_t * dlg, osip_message_t * request)\n{\n  osip_generic_param_t *tag_param_remote;\n  int i;\n  char *tmp;\n\n  if (dlg == NULL || dlg->call_id == NULL)\n    return OSIP_BADPARAMETER;\n  if (request == NULL || request->call_id == NULL || request->from == NULL || request->to == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_call_id_to_str (request->call_id, &tmp);\n  if (i != 0)\n    return i;\n  if (0 != strcmp (dlg->call_id, tmp)) {\n    osip_free (tmp);\n    return OSIP_UNDEFINED_ERROR;\n  }\n  osip_free (tmp);\n\n  /* for INCOMING REQUEST:\n     To: local_uri;local_tag           <- LOCAL TAG ALWAYS EXIST\n     From: remote_uri;remote_tag\n   */\n\n  if (dlg->local_tag == NULL)\n    /* NOT POSSIBLE BECAUSE I MANAGE REMOTE_TAG AND I ALWAYS ADD IT! */\n    return OSIP_SYNTAXERROR;\n\n#if 0\n  /* VR-2785: use line param to distinguish between two registrations by the same user */\n  if (dlg->line_param) {\n    osip_uri_param_t *line_param;\n\n    i = osip_uri_param_get_byname (&request->req_uri->url_params, \"line\", &line_param);\n    if (i == 0 && strcmp (dlg->line_param, line_param->gvalue))\n      return OSIP_UNDEFINED_ERROR;      /* both dlg and req_uri have line params and they do not match */\n  }\n#endif\n\n  i = osip_from_get_tag (request->from, &tag_param_remote);\n  if (i != 0 && dlg->remote_tag != NULL)        /* no tag in request but tag in dialog */\n    return OSIP_SYNTAXERROR;    /* impossible... */\n  if (i != 0 && dlg->remote_tag == NULL) {      /* no tag in request AND no tag in dialog */\n    if (0 == osip_from_compare ((osip_from_t *) dlg->remote_uri, (osip_from_t *) request->from)\n        && 0 == osip_from_compare (dlg->local_uri, request->to))\n      return OSIP_SUCCESS;\n    return OSIP_UNDEFINED_ERROR;\n  }\n\n  if (dlg->remote_tag == NULL) {        /* tag in response BUT no tag in dialog */\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"Remote UA is not compliant: missing a tag in To feilds!\\n\"));\n    if (0 == osip_from_compare ((osip_from_t *) dlg->remote_uri, (osip_from_t *) request->from)\n        && 0 == osip_from_compare (dlg->local_uri, request->to))\n      return OSIP_SUCCESS;\n    return OSIP_UNDEFINED_ERROR;\n  }\n  /* we don't have to compare\n     remote_uri with from\n     && local_uri with to.    ----> we have both tag recognized, it's enough..\n   */\n  if (0 == strcmp (tag_param_remote->gvalue, dlg->remote_tag))\n    return OSIP_SUCCESS;\n\n  return OSIP_UNDEFINED_ERROR;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "__osip_dialog_init": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "static int\n__osip_dialog_init (osip_dialog_t ** dialog, osip_message_t * invite, osip_message_t * response, osip_from_t * local, osip_to_t * remote, osip_message_t * remote_msg)\n{\n  int i;\n  int pos;\n  osip_generic_param_t *tag;\n\n  *dialog = NULL;\n  if (response == NULL)\n    return OSIP_BADPARAMETER;\n  if (response->cseq == NULL || local == NULL || remote == NULL)\n    return OSIP_SYNTAXERROR;\n\n  (*dialog) = (osip_dialog_t *) osip_malloc (sizeof (osip_dialog_t));\n  if (*dialog == NULL)\n    return OSIP_NOMEM;\n\n  memset (*dialog, 0, sizeof (osip_dialog_t));\n  (*dialog)->your_instance = NULL;\n\n  if (MSG_IS_STATUS_2XX (response))\n    (*dialog)->state = DIALOG_CONFIRMED;\n  else                          /* 1XX */\n    (*dialog)->state = DIALOG_EARLY;\n\n  i = osip_call_id_to_str (response->call_id, &((*dialog)->call_id));\n  if (i != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Could not establish dialog!\\n\"));\n    osip_dialog_free (*dialog);\n    *dialog = NULL;\n    return i;\n  }\n\n  i = osip_to_get_tag (local, &tag);\n  if (i != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Could not establish dialog!\\n\"));\n    osip_dialog_free (*dialog);\n    *dialog = NULL;\n    return i;\n  }\n\n  (*dialog)->local_tag = osip_strdup (tag->gvalue);\n\n  i = osip_from_get_tag (remote, &tag);\n  if (i == 0)\n    (*dialog)->remote_tag = osip_strdup (tag->gvalue);\n\n  /* VR-2785: remember line value */\n  if (invite) {\n    osip_uri_param_t *line_param;\n\n    i = osip_uri_param_get_byname (&invite->req_uri->url_params, \"line\", &line_param);\n    if (i == 0 && line_param != NULL && line_param->gvalue != NULL)\n      (*dialog)->line_param = osip_strdup (line_param->gvalue);\n  }\n\n  osip_list_init (&(*dialog)->route_set);\n\n  pos = 0;\n  while (!osip_list_eol (&response->record_routes, pos)) {\n    osip_record_route_t *rr;\n    osip_record_route_t *rr2;\n\n    rr = (osip_record_route_t *) osip_list_get (&response->record_routes, pos);\n    i = osip_record_route_clone (rr, &rr2);\n    if (i != 0) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Could not establish dialog!\\n\"));\n      osip_dialog_free (*dialog);\n      *dialog = NULL;\n      return i;\n    }\n    if (invite == NULL)\n      osip_list_add (&(*dialog)->route_set, rr2, 0);\n    else\n      osip_list_add (&(*dialog)->route_set, rr2, -1);\n\n    pos++;\n  }\n\n  /* local_cseq is set to response->cseq->number for better\n     handling of bad UA */\n  (*dialog)->local_cseq = osip_atoi (response->cseq->number);\n\n  i = osip_from_clone (remote, &((*dialog)->remote_uri));\n  if (i != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Could not establish dialog!\\n\"));\n    osip_dialog_free (*dialog);\n    *dialog = NULL;\n    return i;\n  }\n\n  i = osip_to_clone (local, &((*dialog)->local_uri));\n  if (i != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Could not establish dialog!\\n\"));\n    osip_dialog_free (*dialog);\n    *dialog = NULL;\n    return i;\n  }\n\n  {\n    osip_contact_t *contact;\n\n    if (!osip_list_eol (&remote_msg->contacts, 0)) {\n      contact = osip_list_get (&remote_msg->contacts, 0);\n      i = osip_contact_clone (contact, &((*dialog)->remote_contact_uri));\n      if (i != 0) {\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Could not establish dialog!\\n\"));\n        osip_dialog_free (*dialog);\n        *dialog = NULL;\n        return i;\n      }\n    }\n    else {\n      (*dialog)->remote_contact_uri = NULL;\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"Remote UA is not compliant: missing a contact in remote message!\\n\"));\n    }\n  }\n  (*dialog)->secure = -1;       /* non secure */\n\n  return OSIP_SUCCESS;\n}",
      "lines": 121,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "osip_dialog_init_as_uac": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "int\nosip_dialog_init_as_uac (osip_dialog_t ** dialog, osip_message_t * response)\n{\n  int i;\n\n  i = __osip_dialog_init (dialog, NULL, response, response->from, response->to, response);\n\n  if (i != 0) {\n    *dialog = NULL;\n    return i;\n  }\n\n  (*dialog)->type = CALLER;\n  (*dialog)->remote_cseq = -1;\n\n  return OSIP_SUCCESS;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_dialog_init_as_uac_with_remote_request": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "int\nosip_dialog_init_as_uac_with_remote_request (osip_dialog_t ** dialog, osip_message_t * next_request, int local_cseq)\n{\n  int i;\n\n  *dialog = NULL;\n  if (next_request->cseq == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = __osip_dialog_init (dialog, next_request, next_request, next_request->to, next_request->from, next_request);\n\n  if (i != 0) {\n    *dialog = NULL;\n    return i;\n  }\n\n  (*dialog)->type = CALLER;\n  (*dialog)->state = DIALOG_CONFIRMED;\n\n  (*dialog)->local_cseq = local_cseq;   /* -1 osip_atoi (xxx->cseq->number); */\n  (*dialog)->remote_cseq = osip_atoi (next_request->cseq->number);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_dialog_init_as_uas": {
      "start_point": [
        463,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "int\nosip_dialog_init_as_uas (osip_dialog_t ** dialog, osip_message_t * invite, osip_message_t * response)\n{\n  int i;\n\n  *dialog = NULL;\n  if (response->cseq == NULL)\n    return OSIP_SYNTAXERROR;\n\n  i = __osip_dialog_init (dialog, invite, response, response->to, response->from, invite);\n\n  if (i != 0) {\n    *dialog = NULL;\n    return i;\n  }\n\n  (*dialog)->type = CALLEE;\n  (*dialog)->remote_cseq = osip_atoi (response->cseq->number);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_dialog_free": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        499,
        1
      ],
      "content": "void\nosip_dialog_free (osip_dialog_t * dialog)\n{\n  if (dialog == NULL)\n    return;\n  osip_contact_free (dialog->remote_contact_uri);\n  osip_from_free (dialog->local_uri);\n  osip_to_free (dialog->remote_uri);\n  osip_list_special_free (&dialog->route_set, (void (*)(void *)) &osip_record_route_free);\n  osip_free (dialog->line_param);\n  osip_free (dialog->remote_tag);\n  osip_free (dialog->local_tag);\n  osip_free (dialog->call_id);\n  osip_free (dialog);\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/osip_event.c": {
    "osip_parse": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "osip_event_t *\nosip_parse (const char *buf, size_t length)\n{\n  int i;\n  osip_event_t *se = __osip_event_new (UNKNOWN_EVT, 0);\n\n  if (se == NULL)\n    return NULL;\n\n  /* parse message and set up an event */\n  i = osip_message_init (&(se->sip));\n  if (i != 0) {\n    osip_free (se);\n    return NULL;\n  }\n  if (osip_message_parse (se->sip, buf, length) != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"could not parse message\\n\"));\n    osip_message_free (se->sip);\n    osip_free (se);\n    return NULL;\n  }\n  else {\n    if (se->sip->call_id != NULL && se->sip->call_id->number != NULL) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO3, NULL, \"MESSAGE REC. CALLID:%s\\n\", se->sip->call_id->number));\n    }\n\n    if (MSG_IS_REQUEST (se->sip)) {\n      if (se->sip->sip_method == NULL || se->sip->req_uri == NULL) {\n        osip_message_free (se->sip);\n        osip_free (se);\n        return NULL;\n      }\n    }\n\n    se->type = evt_set_type_incoming_sipmessage (se->sip);\n    return se;\n  }\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "osip_event_t",
        "*\nosip_parse (const char *buf, size_t length)",
        "*"
      ]
    },
    "__osip_event_new": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "osip_event_t *\n__osip_event_new (type_t type, int transactionid)\n{\n  osip_event_t *sipevent;\n\n  sipevent = (osip_event_t *) osip_malloc (sizeof (osip_event_t));\n  if (sipevent == NULL)\n    return NULL;\n  sipevent->type = type;\n  sipevent->sip = NULL;\n  sipevent->transactionid = transactionid;\n  return sipevent;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "osip_event_t",
        "*\n__osip_event_new (type_t type, int transactionid)",
        "*"
      ]
    },
    "osip_new_outgoing_sipmessage": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "osip_event_t *\nosip_new_outgoing_sipmessage (osip_message_t * sip)\n{\n  osip_event_t *sipevent;\n\n  if (sip == NULL)\n    return NULL;\n  if (MSG_IS_REQUEST (sip)) {\n    if (sip->sip_method == NULL)\n      return NULL;\n    if (sip->req_uri == NULL)\n      return NULL;\n  }\n  sipevent = (osip_event_t *) osip_malloc (sizeof (osip_event_t));\n  if (sipevent == NULL)\n    return NULL;\n\n  sipevent->sip = sip;\n  sipevent->type = evt_set_type_outgoing_sipmessage (sip);\n  sipevent->transactionid = 0;\n  return sipevent;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "osip_event_t",
        "*\nosip_new_outgoing_sipmessage (osip_message_t * sip)",
        "*"
      ]
    },
    "evt_set_type_incoming_sipmessage": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "type_t\nevt_set_type_incoming_sipmessage (osip_message_t * sip)\n{\n  if (MSG_IS_REQUEST (sip)) {\n    if (MSG_IS_INVITE (sip))\n      return RCV_REQINVITE;\n    else if (MSG_IS_ACK (sip))\n      return RCV_REQACK;\n    return RCV_REQUEST;\n  }\n  else {\n    if (MSG_IS_STATUS_1XX (sip))\n      return RCV_STATUS_1XX;\n    else if (MSG_IS_STATUS_2XX (sip))\n      return RCV_STATUS_2XX;\n    return RCV_STATUS_3456XX;\n  }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "type_t"
      ]
    },
    "evt_set_type_outgoing_sipmessage": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "type_t\nevt_set_type_outgoing_sipmessage (osip_message_t * sip)\n{\n\n  if (MSG_IS_REQUEST (sip)) {\n    if (MSG_IS_INVITE (sip))\n      return SND_REQINVITE;\n    if (MSG_IS_ACK (sip))\n      return SND_REQACK;\n    return SND_REQUEST;\n  }\n  else {\n    if (MSG_IS_STATUS_1XX (sip))\n      return SND_STATUS_1XX;\n    else if (MSG_IS_STATUS_2XX (sip))\n      return SND_STATUS_2XX;\n    return SND_STATUS_3456XX;\n  }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "type_t"
      ]
    },
    "osip_event_free": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void\nosip_event_free (osip_event_t * event)\n{\n  if (event != NULL) {\n    osip_message_free (event->sip);\n    osip_free (event);\n  }\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/osip_time.c": {
    "add_gettimeofday": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\nadd_gettimeofday (struct timeval *atv, int ms)\n{\n  int m;\n\n  if (ms >= 1000000) {\n    atv->tv_usec = 0;\n    m = ms / 1000;\n  }\n  else {\n    atv->tv_usec += ms * 1000;\n    m = atv->tv_usec / 1000000;\n    atv->tv_usec = atv->tv_usec % 1000000;\n  }\n  atv->tv_sec += m;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "min_timercmp": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\nmin_timercmp (struct timeval *tv1, struct timeval *tv2)\n{\n  if (tv2->tv_sec == -1)\n    return;\n  if (osip_timercmp (tv1, tv2, >)) {\n    /* replace tv1 with tv2 info */\n    tv1->tv_sec = tv2->tv_sec;\n    tv1->tv_usec = tv2->tv_usec;\n  }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_gettimeofday": [
      {
        "start_point": [
          63,
          0
        ],
        "end_point": [
          71,
          1
        ],
        "content": "int\nosip_gettimeofday (struct timeval *tp, void *tz)\n{\n  DWORD timemillis = GetTickCount ();\n\n  tp->tv_sec = (timemillis / 1000) + offset.tv_sec;\n  tp->tv_usec = (timemillis - (tp->tv_sec * 1000)) * 1000;\n  return 0;\n}",
        "lines": 9,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          98,
          0
        ],
        "end_point": [
          107,
          1
        ],
        "content": "int\nosip_gettimeofday (struct timeval *tp, void *tz)\n{\n  struct _timeb timebuffer;\n\n  _ftime (&timebuffer);\n  tp->tv_sec = (long) timebuffer.time + offset.tv_sec;\n  tp->tv_usec = timebuffer.millitm * 1000;\n  return 0;\n}",
        "lines": 10,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          125,
          0
        ],
        "end_point": [
          137,
          1
        ],
        "content": "int\nosip_gettimeofday (struct timeval *tp, void *tz)\n{\n  struct timespec ts;\n\n  if (clock_gettime (CLOCK_MONOTONIC, &ts) < 0) {\n    gettimeofday (tp, tz);\n    return 0;\n  }\n  tp->tv_sec = ts.tv_sec + offset.tv_sec;\n  tp->tv_usec = ts.tv_nsec / 1000;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          155,
          0
        ],
        "end_point": [
          167,
          1
        ],
        "content": "int\nosip_gettimeofday (struct timeval *tp, void *tz)\n{\n  clock_serv_t cclock;\n  mach_timespec_t mts;\n\n  host_get_clock_service (mach_host_self (), SYSTEM_CLOCK, &cclock);\n  clock_get_time (cclock, &mts);\n  mach_port_deallocate (mach_task_self (), cclock);\n  tp->tv_sec = mts.tv_sec + offset.tv_sec;\n  tp->tv_usec = mts.tv_nsec / 1000;\n  return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          181,
          0
        ],
        "end_point": [
          187,
          1
        ],
        "content": "int\nosip_gettimeofday (struct timeval *tp, void *tz)\n{\n  gettimeofday (tp, tz);\n  tp->tv_sec += offset.tv_sec;\n  return 0;\n}",
        "lines": 7,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "_osip_gettimeofday_realtime": [
      {
        "start_point": [
          73,
          0
        ],
        "end_point": [
          79,
          1
        ],
        "content": "static int\n_osip_gettimeofday_realtime (struct timeval *tp, void *tz)\n{\n  tp->tv_sec = 0;\n  tp->tv_usec = 0;\n  return 0;\n}",
        "lines": 7,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          109,
          0
        ],
        "end_point": [
          121,
          1
        ],
        "content": "static int\n_osip_gettimeofday_realtime (struct timeval *tp, void *tz)\n{\n  FILETIME lSystemTimeAsFileTime;\n  LONGLONG ll_now;\n\n  GetSystemTimeAsFileTime (&lSystemTimeAsFileTime);\n  ll_now = (LONGLONG) lSystemTimeAsFileTime.dwLowDateTime + ((LONGLONG) (lSystemTimeAsFileTime.dwHighDateTime) << 32LL);\n  ll_now = ll_now / 10;         /* in us */\n  tp->tv_sec = (long) ll_now / 1000000;\n  tp->tv_usec = (long) ll_now % 1000000;\n  return 0;\n}",
        "lines": 13,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          139,
          0
        ],
        "end_point": [
          151,
          1
        ],
        "content": "static int\n_osip_gettimeofday_realtime (struct timeval *tp, void *tz)\n{\n  struct timespec ts;\n\n  if (clock_gettime (CLOCK_REALTIME, &ts) < 0) {\n    gettimeofday (tp, tz);\n    return 0;\n  }\n  tp->tv_sec = ts.tv_sec;\n  tp->tv_usec = ts.tv_nsec / 1000;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          169,
          0
        ],
        "end_point": [
          176,
          1
        ],
        "content": "static int\n_osip_gettimeofday_realtime (struct timeval *tp, void *tz)\n{\n  /* TODO */\n  tp->tv_sec = 0;\n  tp->tv_usec = 0;\n  return 0;\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          189,
          0
        ],
        "end_point": [
          195,
          1
        ],
        "content": "static int\n_osip_gettimeofday_realtime (struct timeval *tp, void *tz)\n{\n  tp->tv_sec = 0;\n  tp->tv_usec = 0;\n  return 0;\n}",
        "lines": 7,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "time": [
      {
        "start_point": [
          81,
          0
        ],
        "end_point": [
          91,
          1
        ],
        "content": "time_t\ntime (time_t * t)\n{\n  DWORD timemillis = GetTickCount ();\n\n  if (timemillis > 0) {\n    if (t != NULL)\n      *t = timemillis / 1000;\n  }\n  return timemillis / 1000;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "time_t"
        ]
      },
      {
        "start_point": [
          201,
          0
        ],
        "end_point": [
          212,
          1
        ],
        "content": "time_t\ntime (time_t * t)\n{\n  struct timeval now;\n\n  osip_gettimeofday (&now, NULL);\n\n  if (t != NULL) {\n    *t = now.tv_sec;\n  }\n  return now.tv_sec;\n}",
        "lines": 12,
        "depth": 8,
        "decorators": [
          "time_t"
        ]
      }
    ],
    "osip_compensatetime": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "void\nosip_compensatetime ()\n{\n  static struct timeval last_now_monotonic = { 0, 0 };\n  static struct timeval last_now_real = { 0, 0 };\n  struct timeval now_monotonic;\n  struct timeval now_real;\n  struct timeval diff_monotonic;\n  struct timeval diff_real;\n\n#ifndef ANDROID\n  return;\n#endif\n\n  _osip_gettimeofday_realtime (&now_real, NULL);\n  osip_gettimeofday (&now_monotonic, NULL);\n  now_monotonic.tv_sec -= offset.tv_sec;\n\n  if (now_real.tv_sec == 0)\n    return;                     /* no compensation */\n\n  /* monotonic clock may doesn't include deep sleep time */\n  /* the goal is to compensate that time by looking at the real time */\n\n  /* initial call: initialize */\n  if (last_now_monotonic.tv_sec == 0) {\n    _osip_gettimeofday_realtime (&last_now_real, NULL);\n    osip_gettimeofday (&last_now_monotonic, NULL);\n    last_now_monotonic.tv_sec -= offset.tv_sec;\n\n    return;\n  }\n\n  diff_monotonic.tv_sec = now_monotonic.tv_sec - last_now_monotonic.tv_sec;\n  diff_real.tv_sec = now_real.tv_sec - last_now_real.tv_sec;\n\n  if (diff_real.tv_sec < 5)\n    return;                     /* skip any \"back in time\" operation or small interval */\n  if (diff_real.tv_sec > 3600)\n    return;\n  if (diff_real.tv_sec < diff_monotonic.tv_sec + 2)\n    return;                     /* only large gap needs to be taken into accounts for this program... */\n\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"adjusting exosip monotonic time (%i)!\\n\", diff_real.tv_sec - diff_monotonic.tv_sec));\n  offset.tv_sec += diff_real.tv_sec - diff_monotonic.tv_sec;\n\n  /* reset for later use */\n  _osip_gettimeofday_realtime (&last_now_real, NULL);\n  osip_gettimeofday (&last_now_monotonic, NULL);\n  last_now_monotonic.tv_sec -= offset.tv_sec;\n}",
      "lines": 51,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "osip_getsystemtime": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "time_t\nosip_getsystemtime (time_t * t)\n{\n  struct timeval now_monotonic;\n\n#ifdef ANDROID\n  osip_compensatetime ();\n#endif\n\n  osip_gettimeofday (&now_monotonic, NULL);\n  if (t != NULL) {\n    *t = now_monotonic.tv_sec;\n  }\n\n  return now_monotonic.tv_sec;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "time_t"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/osip_transaction.c": {
    "__osip_transaction_set_topvia": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static int\n__osip_transaction_set_topvia (osip_transaction_t * transaction, osip_via_t * topvia)\n{\n  int i;\n\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  i = osip_via_clone (topvia, &(transaction->topvia));\n  if (i == 0)\n    return OSIP_SUCCESS;\n  transaction->topvia = NULL;\n  return i;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__osip_transaction_set_from": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\n__osip_transaction_set_from (osip_transaction_t * transaction, osip_from_t * from)\n{\n  int i;\n\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  i = osip_from_clone (from, &(transaction->from));\n  if (i == 0)\n    return OSIP_SUCCESS;\n  transaction->from = NULL;\n  return i;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__osip_transaction_set_to": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\n__osip_transaction_set_to (osip_transaction_t * transaction, osip_to_t * to)\n{\n  int i;\n\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  i = osip_to_clone (to, &(transaction->to));\n  if (i == 0)\n    return OSIP_SUCCESS;\n  transaction->to = NULL;\n  return i;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__osip_transaction_set_call_id": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static int\n__osip_transaction_set_call_id (osip_transaction_t * transaction, osip_call_id_t * call_id)\n{\n  int i;\n\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  i = osip_call_id_clone (call_id, &(transaction->callid));\n  if (i == 0)\n    return OSIP_SUCCESS;\n  transaction->callid = NULL;\n  return i;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__osip_transaction_set_cseq": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static int\n__osip_transaction_set_cseq (osip_transaction_t * transaction, osip_cseq_t * cseq)\n{\n  int i;\n\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  i = osip_cseq_clone (cseq, &(transaction->cseq));\n  if (i == 0)\n    return OSIP_SUCCESS;\n  transaction->cseq = NULL;\n  return i;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "osip_transaction_init": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "int\nosip_transaction_init (osip_transaction_t ** transaction, osip_fsm_type_t ctx_type, osip_t * osip, osip_message_t * request)\n{\n  osip_via_t *topvia;\n\n  int i;\n\n  *transaction = NULL;\n  if (request == NULL)\n    return OSIP_BADPARAMETER;\n  if (request->call_id == NULL)\n    return OSIP_BADPARAMETER;\n  if (request->call_id->number == NULL)\n    return OSIP_BADPARAMETER;\n\n  *transaction = (osip_transaction_t *) osip_malloc (sizeof (osip_transaction_t));\n  if (*transaction == NULL)\n    return OSIP_NOMEM;\n\n  memset (*transaction, 0, sizeof (osip_transaction_t));\n\n  (*transaction)->birth_time = osip_getsystemtime (NULL);\n\n  osip_id_mutex_lock (osip);\n  (*transaction)->transactionid = osip->transactionid++;\n  osip_id_mutex_unlock (osip);\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"allocating transaction resource %i %s\\n\", (*transaction)->transactionid, request->call_id->number));\n\n  /* those lines must be called before \"osip_transaction_free\" */\n  (*transaction)->ctx_type = ctx_type;\n  (*transaction)->ict_context = NULL;\n  (*transaction)->ist_context = NULL;\n  (*transaction)->nict_context = NULL;\n  (*transaction)->nist_context = NULL;\n  (*transaction)->config = osip;\n\n  topvia = osip_list_get (&request->vias, 0);\n  if (topvia == NULL) {\n    osip_transaction_free (*transaction);\n    *transaction = NULL;\n    return OSIP_SYNTAXERROR;\n  }\n  i = __osip_transaction_set_topvia (*transaction, topvia);\n  if (i != 0) {\n    osip_transaction_free (*transaction);\n    *transaction = NULL;\n    return i;\n  }\n\n  /* In some situation, some of those informtions might\n     be useless. Mostly, I prefer to keep them in all case\n     for backward compatibility. */\n  i = __osip_transaction_set_from (*transaction, request->from);\n  if (i != 0) {\n    osip_transaction_free (*transaction);\n    *transaction = NULL;\n    return i;\n  }\n  i = __osip_transaction_set_to (*transaction, request->to);\n  if (i != 0) {\n    osip_transaction_free (*transaction);\n    *transaction = NULL;\n    return i;\n  }\n  i = __osip_transaction_set_call_id (*transaction, request->call_id);\n  if (i != 0) {\n    osip_transaction_free (*transaction);\n    *transaction = NULL;\n    return i;\n  }\n  i = __osip_transaction_set_cseq (*transaction, request->cseq);\n  if (i != 0) {\n    osip_transaction_free (*transaction);\n    *transaction = NULL;\n    return i;\n  }\n  /* RACE conditions can happen for server transactions */\n  /* (*transaction)->orig_request = request; */\n  (*transaction)->orig_request = NULL;\n\n  (*transaction)->transactionff = (osip_fifo_t *) osip_malloc (sizeof (osip_fifo_t));\n  if ((*transaction)->transactionff == NULL) {\n    osip_transaction_free (*transaction);\n    *transaction = NULL;\n    return OSIP_NOMEM;\n  }\n  osip_fifo_init ((*transaction)->transactionff);\n\n  if (ctx_type == ICT) {\n    (*transaction)->state = ICT_PRE_CALLING;\n    i = __osip_ict_init (&((*transaction)->ict_context), osip, request);\n    if (i != 0) {\n      osip_transaction_free (*transaction);\n      *transaction = NULL;\n      return i;\n    }\n    __osip_add_ict (osip, *transaction);\n  }\n  else if (ctx_type == IST) {\n    (*transaction)->state = IST_PRE_PROCEEDING;\n    i = __osip_ist_init (&((*transaction)->ist_context), osip, request);\n    if (i != 0) {\n      osip_transaction_free (*transaction);\n      *transaction = NULL;\n      return i;\n    }\n    __osip_add_ist (osip, *transaction);\n  }\n  else if (ctx_type == NICT) {\n    (*transaction)->state = NICT_PRE_TRYING;\n    i = __osip_nict_init (&((*transaction)->nict_context), osip, request);\n    if (i != 0) {\n      osip_transaction_free (*transaction);\n      *transaction = NULL;\n      return i;\n    }\n    __osip_add_nict (osip, *transaction);\n  }\n  else {\n    (*transaction)->state = NIST_PRE_TRYING;\n    i = __osip_nist_init (&((*transaction)->nist_context), osip, request);\n    if (i != 0) {\n      osip_transaction_free (*transaction);\n      *transaction = NULL;\n      return i;\n    }\n    __osip_add_nist (osip, *transaction);\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 130,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_free": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "int\nosip_transaction_free (osip_transaction_t * transaction)\n{\n  int i;\n\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  i = osip_remove_transaction (transaction->config, transaction);\n\n  if (i != 0) {                 /* yet removed ??? */\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO4, NULL, \"transaction already removed from list %i!\\n\", transaction->transactionid));\n  }\n\n  return osip_transaction_free2 (transaction);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_free2": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "int\nosip_transaction_free2 (osip_transaction_t * transaction)\n{\n  osip_event_t *evt;\n\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  if (transaction->orig_request != NULL && transaction->orig_request->call_id != NULL && transaction->orig_request->call_id->number != NULL) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO2, NULL, \"free transaction resource %i %s\\n\", transaction->transactionid, transaction->orig_request->call_id->number));\n  }\n  if (transaction->ctx_type == ICT) {\n    __osip_ict_free (transaction->ict_context);\n  }\n  else if (transaction->ctx_type == IST) {\n    __osip_ist_free (transaction->ist_context);\n  }\n  else if (transaction->ctx_type == NICT) {\n    __osip_nict_free (transaction->nict_context);\n  }\n  else {\n    __osip_nist_free (transaction->nist_context);\n  }\n\n  /* empty the fifo */\n  if (transaction->transactionff != NULL) {\n    evt = osip_fifo_tryget (transaction->transactionff);\n    while (evt != NULL) {\n      osip_message_free (evt->sip);\n      osip_free (evt);\n      evt = osip_fifo_tryget (transaction->transactionff);\n    }\n    osip_fifo_free (transaction->transactionff);\n  }\n\n  osip_message_free (transaction->orig_request);\n  osip_message_free (transaction->last_response);\n  osip_message_free (transaction->ack);\n\n  osip_via_free (transaction->topvia);\n  osip_from_free (transaction->from);\n  osip_to_free (transaction->to);\n  osip_call_id_free (transaction->callid);\n  osip_cseq_free (transaction->cseq);\n\n  osip_free (transaction);\n  return OSIP_SUCCESS;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_add_event": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "int\nosip_transaction_add_event (osip_transaction_t * transaction, osip_event_t * evt)\n{\n  if (evt == NULL)\n    return OSIP_BADPARAMETER;\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  evt->transactionid = transaction->transactionid;\n  osip_fifo_add (transaction->transactionff, evt);\n  return OSIP_SUCCESS;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_execute": {
      "start_point": [
        332,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "int\nosip_transaction_execute (osip_transaction_t * transaction, osip_event_t * evt)\n{\n  osip_statemachine_t *statemachine;\n\n  /* to kill the process, simply send this type of event. */\n  if (EVT_IS_KILL_TRANSACTION (evt)) {\n    /* MAJOR CHANGE!\n       TRANSACTION MUST NOW BE RELEASED BY END-USER:\n       So Any usefull data can be save and re-used */\n    /* osip_transaction_free(transaction);\n       osip_free(transaction); */\n    osip_free (evt);\n    return OSIP_SUCCESS;\n  }\n\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO4, NULL, \"sipevent tr->transactionid: %i\\n\", transaction->transactionid));\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO4, NULL, \"sipevent tr->state: %i\\n\", transaction->state));\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO4, NULL, \"sipevent evt->type: %i\\n\", evt->type));\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO4, NULL, \"sipevent evt->sip: %x\\n\", evt->sip));\n\n  if (transaction->ctx_type == ICT)\n    statemachine = &ict_fsm;\n  else if (transaction->ctx_type == IST)\n    statemachine = &ist_fsm;\n  else if (transaction->ctx_type == NICT)\n    statemachine = &nict_fsm;\n  else\n    statemachine = &nist_fsm;\n\n  if (0 != fsm_callmethod (evt->type, transaction->state, statemachine, evt, transaction)) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO3, NULL, \"USELESS event!\\n\"));\n    /* message is useless. */\n    if (EVT_IS_MSG (evt)) {\n      if (evt->sip != NULL) {\n        osip_message_free (evt->sip);\n      }\n    }\n  }\n  else {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO4, NULL, \"sipevent evt: method called!\\n\"));\n  }\n  osip_free (evt);              /* this is the ONLY place for freeing event!! */\n  return 1;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_get_destination": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "int\nosip_transaction_get_destination (osip_transaction_t * transaction, char **ip, int *port)\n{\n  *ip = NULL;\n  *port = 0;\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  if (transaction->ict_context != NULL) {\n    *ip = transaction->ict_context->destination;\n    *port = transaction->ict_context->port;\n    return OSIP_SUCCESS;\n  }\n  else if (transaction->nict_context != NULL) {\n    *ip = transaction->nict_context->destination;\n    *port = transaction->nict_context->port;\n    return OSIP_SUCCESS;\n  }\n  return OSIP_UNDEFINED_ERROR;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_set_srv_record": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "int\nosip_transaction_set_srv_record (osip_transaction_t * transaction, osip_srv_record_t * record)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  memcpy (&transaction->record, record, sizeof (osip_srv_record_t));\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_set_naptr_record": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "int\nosip_transaction_set_naptr_record (osip_transaction_t * transaction, osip_naptr_t * record)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  transaction->naptr_record = record;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_set_your_instance": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "int\nosip_transaction_set_your_instance (osip_transaction_t * transaction, void *ptr)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  transaction->reserved1 = ptr;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_set_reserved1": {
      "start_point": [
        425,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "int\nosip_transaction_set_reserved1 (osip_transaction_t * transaction, void *ptr)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  transaction->reserved1 = ptr;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_set_reserved2": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "int\nosip_transaction_set_reserved2 (osip_transaction_t * transaction, void *ptr)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  transaction->reserved2 = ptr;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_set_reserved3": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "int\nosip_transaction_set_reserved3 (osip_transaction_t * transaction, void *ptr)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  transaction->reserved3 = ptr;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_set_reserved4": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "int\nosip_transaction_set_reserved4 (osip_transaction_t * transaction, void *ptr)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  transaction->reserved4 = ptr;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_set_reserved5": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        468,
        1
      ],
      "content": "int\nosip_transaction_set_reserved5 (osip_transaction_t * transaction, void *ptr)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  transaction->reserved5 = ptr;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_set_reserved6": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        477,
        1
      ],
      "content": "int\nosip_transaction_set_reserved6 (osip_transaction_t * transaction, void *ptr)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  transaction->reserved6 = ptr;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_get_your_instance": {
      "start_point": [
        480,
        0
      ],
      "end_point": [
        486,
        1
      ],
      "content": "void *\nosip_transaction_get_your_instance (osip_transaction_t * transaction)\n{\n  if (transaction == NULL)\n    return NULL;\n  return transaction->reserved1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void",
        "*\nosip_transaction_get_your_instance (osip_transaction_t * transaction)",
        "*"
      ]
    },
    "osip_transaction_get_reserved1": {
      "start_point": [
        488,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "void *\nosip_transaction_get_reserved1 (osip_transaction_t * transaction)\n{\n  if (transaction == NULL)\n    return NULL;\n  return transaction->reserved1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void",
        "*\nosip_transaction_get_reserved1 (osip_transaction_t * transaction)",
        "*"
      ]
    },
    "osip_transaction_get_reserved2": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "void *\nosip_transaction_get_reserved2 (osip_transaction_t * transaction)\n{\n  if (transaction == NULL)\n    return NULL;\n  return transaction->reserved2;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void",
        "*\nosip_transaction_get_reserved2 (osip_transaction_t * transaction)",
        "*"
      ]
    },
    "osip_transaction_get_reserved3": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "void *\nosip_transaction_get_reserved3 (osip_transaction_t * transaction)\n{\n  if (transaction == NULL)\n    return NULL;\n  return transaction->reserved3;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void",
        "*\nosip_transaction_get_reserved3 (osip_transaction_t * transaction)",
        "*"
      ]
    },
    "osip_transaction_get_reserved4": {
      "start_point": [
        512,
        0
      ],
      "end_point": [
        518,
        1
      ],
      "content": "void *\nosip_transaction_get_reserved4 (osip_transaction_t * transaction)\n{\n  if (transaction == NULL)\n    return NULL;\n  return transaction->reserved4;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void",
        "*\nosip_transaction_get_reserved4 (osip_transaction_t * transaction)",
        "*"
      ]
    },
    "osip_transaction_get_reserved5": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        526,
        1
      ],
      "content": "void *\nosip_transaction_get_reserved5 (osip_transaction_t * transaction)\n{\n  if (transaction == NULL)\n    return NULL;\n  return transaction->reserved5;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void",
        "*\nosip_transaction_get_reserved5 (osip_transaction_t * transaction)",
        "*"
      ]
    },
    "osip_transaction_get_reserved6": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        534,
        1
      ],
      "content": "void *\nosip_transaction_get_reserved6 (osip_transaction_t * transaction)\n{\n  if (transaction == NULL)\n    return NULL;\n  return transaction->reserved6;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void",
        "*\nosip_transaction_get_reserved6 (osip_transaction_t * transaction)",
        "*"
      ]
    },
    "__osip_transaction_set_state": {
      "start_point": [
        537,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "int\n__osip_transaction_set_state (osip_transaction_t * transaction, state_t state)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  transaction->state = state;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_set_in_socket": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        553,
        1
      ],
      "content": "int\nosip_transaction_set_in_socket (osip_transaction_t * transaction, int sock)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  transaction->in_socket = sock;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_transaction_set_out_socket": {
      "start_point": [
        555,
        0
      ],
      "end_point": [
        562,
        1
      ],
      "content": "int\nosip_transaction_set_out_socket (osip_transaction_t * transaction, int sock)\n{\n  if (transaction == NULL)\n    return OSIP_BADPARAMETER;\n  transaction->out_socket = sock;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "__osip_transaction_matching_response_osip_to_xict_17_1_3": {
      "start_point": [
        564,
        0
      ],
      "end_point": [
        648,
        1
      ],
      "content": "int\n__osip_transaction_matching_response_osip_to_xict_17_1_3 (osip_transaction_t * tr, osip_message_t * response)\n{\n  osip_generic_param_t *b_request;\n  osip_generic_param_t *b_response;\n  osip_via_t *topvia_response;\n\n  /* some checks to avoid crashing on bad requests */\n  if (tr == NULL || (tr->ict_context == NULL && tr->nict_context == NULL) ||\n      /* only ict and nict can match a response */\n      response == NULL || response->cseq == NULL || response->cseq->method == NULL)\n    return OSIP_BADPARAMETER;\n\n  topvia_response = osip_list_get (&response->vias, 0);\n  if (topvia_response == NULL) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Remote UA is not compliant: missing a Via header!\\n\"));\n    return OSIP_SYNTAXERROR;\n  }\n  osip_via_param_get_byname (tr->topvia, \"branch\", &b_request);\n  if (b_request == NULL) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_BUG, NULL, \"You created a transaction without any branch! THIS IS NOT ALLOWED\\n\"));\n    return OSIP_SYNTAXERROR;\n  }\n  osip_via_param_get_byname (topvia_response, \"branch\", &b_response);\n  if (b_response == NULL) {\n#ifdef FWDSUPPORT\n    /* the from tag (unique) */\n    if (from_tag_match (tr->from, response->from) != 0)\n      return OSIP_UNDEFINED_ERROR;\n    /* the Cseq field */\n    if (cseq_match (tr->cseq, response->cseq) != 0)\n      return OSIP_UNDEFINED_ERROR;\n    /* the To field */\n    if (response->to->url->username == NULL && tr->from->url->username != NULL)\n      return OSIP_UNDEFINED_ERROR;\n    if (response->to->url->username != NULL && tr->from->url->username == NULL)\n      return OSIP_UNDEFINED_ERROR;\n    if (response->to->url->username != NULL && tr->from->url->username != NULL) {\n      if (strcmp (response->to->url->host, tr->from->url->host) || strcmp (response->to->url->username, tr->from->url->username))\n        return OSIP_UNDEFINED_ERROR;\n    }\n    else {\n      if (strcmp (response->to->url->host, tr->from->url->host))\n        return OSIP_UNDEFINED_ERROR;\n    }\n\n    /* the Call-ID field */\n    if (call_id_match (tr->callid, response->call_id) != 0)\n      return OSIP_UNDEFINED_ERROR;\n    return OSIP_SUCCESS;\n#else\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_BUG, NULL, \"Remote UA is not compliant: missing a branch parameter in  Via header!\\n\"));\n    return OSIP_SYNTAXERROR;\n#endif\n  }\n\n  if ((b_request->gvalue == NULL)\n      || (b_response->gvalue == NULL)) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_BUG, NULL, \"Remote UA is not compliant: missing a branch parameter in  Via header!\\n\"));\n    return OSIP_SYNTAXERROR;\n  }\n\n  /*\n     A response matches a client transaction under two\n     conditions:\n\n     1.   If the response has the same value of the branch parameter\n     in the top Via header field as the branch parameter in the\n     top Via header field of the request that created the\n     transaction.\n   */\n  if (0 != strcmp (b_request->gvalue, b_response->gvalue))\n    return OSIP_UNDEFINED_ERROR;\n  /*  \n     2.   If the method parameter in the CSeq header field matches\n     the method of the request that created the transaction. The\n     method is needed since a CANCEL request constitutes a\n     different transaction, but shares the same value of the\n     branch parameter.\n     AMD NOTE: cseq->method is ALWAYS the same than the METHOD of the request.\n   */\n  if (0 == strcmp (response->cseq->method, tr->cseq->method))   /* general case */\n    return OSIP_SUCCESS;\n  return OSIP_UNDEFINED_ERROR;\n}",
      "lines": 85,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "__osip_transaction_matching_request_osip_to_xist_17_2_3": {
      "start_point": [
        650,
        0
      ],
      "end_point": [
        776,
        1
      ],
      "content": "int\n__osip_transaction_matching_request_osip_to_xist_17_2_3 (osip_transaction_t * tr, osip_message_t * request)\n{\n  osip_generic_param_t *b_origrequest;\n  osip_generic_param_t *b_request;\n  osip_via_t *topvia_request;\n  size_t length_br;\n  size_t length_br2;\n\n  /* some checks to avoid crashing on bad requests */\n  if (tr == NULL || (tr->ist_context == NULL && tr->nist_context == NULL) ||\n      /* only ist and nist can match a request */\n      request == NULL || request->cseq == NULL || request->cseq->method == NULL)\n    return OSIP_BADPARAMETER;\n\n  topvia_request = osip_list_get (&request->vias, 0);\n  if (topvia_request == NULL) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Remote UA is not compliant: missing a Via header!\\n\"));\n    return OSIP_SYNTAXERROR;\n  }\n  osip_via_param_get_byname (topvia_request, \"branch\", &b_request);\n  osip_via_param_get_byname (tr->topvia, \"branch\", &b_origrequest);\n\n  if ((b_origrequest == NULL && b_request != NULL) || (b_origrequest != NULL && b_request == NULL))\n    return OSIP_SYNTAXERROR;    /* one request is compliant, the other one is not... */\n\n  /* Section 17.2.3 Matching Requests to Server Transactions:\n     \"The branch parameter in the topmost Via header field of the request\n     is examined. If it is present and begins with the magic cookie\n     \"z9hG4bK\", the request was generated by a client transaction\n     compliant to this specification.\"\n   */\n\n  if (b_origrequest != NULL && b_request != NULL)\n    /* case where both request contains a branch */\n  {\n    if (!b_origrequest->gvalue)\n      return OSIP_UNDEFINED_ERROR;\n    if (!b_request->gvalue)\n      return OSIP_UNDEFINED_ERROR;\n\n    length_br = strlen (b_origrequest->gvalue);\n    length_br2 = strlen (b_request->gvalue);\n    if (length_br != length_br2)\n      return OSIP_UNDEFINED_ERROR;\n\n    /* can't be the same */\n    if (0 == strncmp (b_origrequest->gvalue, \"z9hG4bK\", 7)\n        && 0 == strncmp (b_request->gvalue, \"z9hG4bK\", 7)) {\n      /* both request comes from a compliant UA */\n      /* The request matches a transaction if the branch parameter\n         in the request is equal to the one in the top Via header\n         field of the request that created the transaction, the\n         sent-by value in the top Via of the request is equal to\n         the one in the request that created the transaction, and in\n         the case of a CANCEL request, the method of the request\n         that created the transaction was also CANCEL.\n       */\n      if (0 != strcmp (b_origrequest->gvalue, b_request->gvalue))\n        return OSIP_UNDEFINED_ERROR;    /* branch param does not match */\n      {\n        /* check the sent-by values */\n        char *b_port = via_get_port (topvia_request);\n        char *b_origport = via_get_port (tr->topvia);\n        char *b_host = via_get_host (topvia_request);\n        char *b_orighost = via_get_host (tr->topvia);\n\n        if ((b_host == NULL || b_orighost == NULL))\n          return OSIP_UNDEFINED_ERROR;\n        if (0 != strcmp (b_orighost, b_host))\n          return OSIP_UNDEFINED_ERROR;\n\n        if (b_port != NULL && b_origport == NULL && 0 != strcmp (b_port, \"5060\"))\n          return OSIP_UNDEFINED_ERROR;\n        else if (b_origport != NULL && b_port == NULL && 0 != strcmp (b_origport, \"5060\"))\n          return OSIP_UNDEFINED_ERROR;\n        else if (b_origport != NULL && b_port != NULL && 0 != strcmp (b_origport, b_port))\n          return OSIP_UNDEFINED_ERROR;\n      }\n#ifdef AC_BUG\n      /* audiocodes bug (MP108-fxs-SIP-4-0-282-380) */\n      if (0 != osip_from_tag_match (tr->from, request->from))\n        return OSIP_UNDEFINED_ERROR;\n#endif\n      if (                      /* MSG_IS_CANCEL(request)&& <<-- BUG from the spec?\n                                   I always check the CSeq */\n           (!(0 == strcmp (tr->cseq->method, \"INVITE\") && 0 == strcmp (request->cseq->method, \"ACK\")))\n           && 0 != strcmp (tr->cseq->method, request->cseq->method))\n        return OSIP_UNDEFINED_ERROR;\n      return OSIP_SUCCESS;\n    }\n  }\n\n  /* Back to the old backward compatibilty mechanism for matching requests */\n  if (0 != osip_call_id_match (tr->callid, request->call_id))\n    return OSIP_UNDEFINED_ERROR;\n  if (MSG_IS_ACK (request)) {\n    osip_generic_param_t *tag_from1;\n    osip_generic_param_t *tag_from2;\n\n    osip_from_param_get_byname (tr->to, \"tag\", &tag_from1);\n    osip_from_param_get_byname (request->to, \"tag\", &tag_from2);\n    if (tag_from1 == NULL && tag_from2 != NULL) {       /* do not check it as it can be a new tag when the final\n                                                           answer has a tag while an INVITE doesn't have one */\n    }\n    else if (tag_from1 != NULL && tag_from2 == NULL) {\n      return OSIP_UNDEFINED_ERROR;\n    }\n    else {\n      if (0 != osip_to_tag_match (tr->to, request->to))\n        return OSIP_UNDEFINED_ERROR;\n    }\n  }\n  else {\n    if (tr->orig_request == NULL || tr->orig_request->to == NULL)\n      return OSIP_UNDEFINED_ERROR;\n    if (0 != osip_to_tag_match (tr->orig_request->to, request->to))\n      return OSIP_UNDEFINED_ERROR;\n  }\n  if (0 != osip_from_tag_match (tr->from, request->from))\n    return OSIP_UNDEFINED_ERROR;\n  if (0 != osip_cseq_match (tr->cseq, request->cseq))\n    return OSIP_UNDEFINED_ERROR;\n  if (0 != osip_via_match (tr->topvia, topvia_request))\n    return OSIP_UNDEFINED_ERROR;\n  return OSIP_SUCCESS;\n}",
      "lines": 127,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "__osip_transaction_need_timer_x_event": {
      "start_point": [
        778,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "osip_event_t *\n__osip_transaction_need_timer_x_event (void *xixt, struct timeval * timer, int cond_state, int transactionid, int TIMER_VAL)\n{\n  struct timeval now;\n\n  osip_gettimeofday (&now, NULL);\n\n  if (xixt == NULL)\n    return NULL;\n  if (cond_state) {\n    if (timer->tv_sec == -1)\n      return NULL;\n    if (osip_timercmp (&now, timer, >))\n      return __osip_event_new (TIMER_VAL, transactionid);\n  }\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "osip_event_t",
        "*\n__osip_transaction_need_timer_x_event (void *xixt, struct timeval * timer, int cond_state, int transactionid, int TIMER_VAL)",
        "*"
      ]
    },
    "__osip_transaction_snd_xxx": {
      "start_point": [
        796,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "int\n__osip_transaction_snd_xxx (osip_transaction_t * ist, osip_message_t * msg)\n{\n  osip_t *osip = (osip_t *) ist->config;\n  osip_via_t *via;\n  char *host;\n  int port;\n  osip_generic_param_t *maddr;\n  osip_generic_param_t *received;\n  osip_generic_param_t *rport;\n\n  via = (osip_via_t *) osip_list_get (&msg->vias, 0);\n  if (!via)\n    return OSIP_SYNTAXERROR;\n\n  osip_via_param_get_byname (via, \"maddr\", &maddr);\n  osip_via_param_get_byname (via, \"received\", &received);\n  osip_via_param_get_byname (via, \"rport\", &rport);\n  /* 1: user should not use the provided information\n     (host and port) if they are using a reliable\n     transport. Instead, they should use the already\n     open socket attached to this transaction. */\n  /* 2: check maddr and multicast usage */\n  if (maddr != NULL)\n    host = maddr->gvalue;\n  /* we should check if this is a multicast address and use\n     set the \"ttl\" in this case. (this must be done in the\n     UDP message (not at the SIP layer) */\n  else if (received != NULL)\n    host = received->gvalue;\n  else\n    host = via->host;\n\n  if (rport == NULL || rport->gvalue == NULL) {\n    if (via->port != NULL)\n      port = osip_atoi (via->port);\n    else\n      port = 5060;\n  }\n  else\n    port = osip_atoi (rport->gvalue);\n\n  return osip->cb_send_message (ist, msg, host, port, ist->out_socket);\n\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/port_condv.c": {
    "osip_cond_init": [
      {
        "start_point": [
          41,
          0
        ],
        "end_point": [
          52,
          1
        ],
        "content": "struct osip_cond *\nosip_cond_init ()\n{\n  osip_cond_t *cond = (osip_cond_t *) osip_malloc (sizeof (osip_cond_t));\n\n  if (cond && (pthread_cond_init (&cond->cv, NULL) == 0)) {\n    return (struct osip_cond *) (cond);\n  }\n  osip_free (cond);\n\n  return NULL;\n}",
        "lines": 12,
        "depth": 12,
        "decorators": [
          "struct osip_cond",
          "struct",
          "osip_cond",
          "*\nosip_cond_init ()",
          "*"
        ]
      },
      {
        "start_point": [
          104,
          0
        ],
        "end_point": [
          116,
          1
        ],
        "content": "struct osip_cond *\nosip_cond_init ()\n{\n  osip_cond_t *cond = (osip_cond_t *) osip_malloc (sizeof (osip_cond_t));\n\n  if (cond && (cond->mut = osip_mutex_init ()) != NULL) {\n    cond->sem = osip_sem_init (0);      /* initially locked */\n    return (struct osip_cond *) (cond);\n  }\n  osip_free (cond);\n\n  return NULL;\n}",
        "lines": 13,
        "depth": 11,
        "decorators": [
          "struct osip_cond",
          "struct",
          "osip_cond",
          "*\nosip_cond_init ()",
          "*"
        ]
      },
      {
        "start_point": [
          265,
          0
        ],
        "end_point": [
          276,
          1
        ],
        "content": "struct osip_cond *\nosip_cond_init ()\n{\n  osip_cond_t *cond = (osip_cond_t *) osip_malloc (sizeof (osip_cond_t));\n\n  if ((cond->sem = osip_sem_init (0)) != NULL) {\n    return (struct osip_cond *) (cond);\n  }\n  osip_free (cond);\n\n  return NULL;\n}",
        "lines": 12,
        "depth": 10,
        "decorators": [
          "struct osip_cond",
          "struct",
          "osip_cond",
          "*\nosip_cond_init ()",
          "*"
        ]
      }
    ],
    "osip_cond_destroy": [
      {
        "start_point": [
          54,
          0
        ],
        "end_point": [
          64,
          1
        ],
        "content": "int\nosip_cond_destroy (struct osip_cond *_cond)\n{\n  int ret;\n\n  if (!_cond)\n    return OSIP_BADPARAMETER;\n  ret = pthread_cond_destroy (&_cond->cv);\n  osip_free (_cond);\n  return ret;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          118,
          0
        ],
        "end_point": [
          134,
          1
        ],
        "content": "int\nosip_cond_destroy (struct osip_cond *_cond)\n{\n  if (!_cond)\n    return OSIP_SUCCESS;\n  if (_cond->sem == NULL)\n    return OSIP_SUCCESS;\n\n  osip_sem_destroy (_cond->sem);\n\n  if (_cond->mut == NULL)\n    return OSIP_SUCCESS;\n\n  osip_mutex_destroy (_cond->mut);\n  osip_free (_cond);\n  return (0);\n}",
        "lines": 17,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          278,
          0
        ],
        "end_point": [
          287,
          1
        ],
        "content": "int\nosip_cond_destroy (struct osip_cond *_cond)\n{\n  if (_cond->sem == NULL)\n    return OSIP_SUCCESS;\n\n  osip_sem_destroy (_cond->sem);\n  osip_free (_cond);\n  return (0);\n}",
        "lines": 10,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_cond_signal": [
      {
        "start_point": [
          66,
          0
        ],
        "end_point": [
          72,
          1
        ],
        "content": "int\nosip_cond_signal (struct osip_cond *_cond)\n{\n  if (!_cond)\n    return OSIP_BADPARAMETER;\n  return pthread_cond_signal (&_cond->cv);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          136,
          0
        ],
        "end_point": [
          142,
          1
        ],
        "content": "int\nosip_cond_signal (struct osip_cond *_cond)\n{\n  if (!_cond)\n    return OSIP_BADPARAMETER;\n  return osip_sem_post (_cond->sem);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          289,
          0
        ],
        "end_point": [
          293,
          1
        ],
        "content": "int\nosip_cond_signal (struct osip_cond *_cond)\n{\n  return osip_sem_post (_cond->sem);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_cond_wait": [
      {
        "start_point": [
          75,
          0
        ],
        "end_point": [
          81,
          1
        ],
        "content": "int\nosip_cond_wait (struct osip_cond *_cond, struct osip_mutex *_mut)\n{\n  if (!_cond)\n    return OSIP_BADPARAMETER;\n  return pthread_cond_wait (&_cond->cv, (pthread_mutex_t *) _mut);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          145,
          0
        ],
        "end_point": [
          175,
          1
        ],
        "content": "int\nosip_cond_wait (struct osip_cond *_cond, struct osip_mutex *_mut)\n{\n  int ret1 = 0, ret2 = 0, ret3 = 0;\n  int i;\n\n  if (!_cond)\n    return OSIP_BADPARAMETER;\n\n  i = osip_mutex_lock (_cond->mut);\n  if (i != 0)\n    return i;\n\n  i = osip_mutex_unlock (_mut);\n  if (i != 0)\n    return i;\n\n  ret1 = osip_sem_wait (_cond->sem);\n\n  ret2 = osip_mutex_lock (_mut);\n\n  ret3 = osip_mutex_unlock (_cond->mut);\n\n  if (ret1)\n    return ret1;\n  if (ret2)\n    return ret2;\n  if (ret3)\n    return ret3;\n  return OSIP_SUCCESS;\n}",
        "lines": 31,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          336,
          0
        ],
        "end_point": [
          340,
          1
        ],
        "content": "int\nosip_cond_wait (struct osip_cond *_cond, struct osip_mutex *_mut)\n{\n  return _cond_wait (_cond, _mut, WAIT_FOREVER);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_cond_timedwait": [
      {
        "start_point": [
          84,
          0
        ],
        "end_point": [
          90,
          1
        ],
        "content": "int\nosip_cond_timedwait (struct osip_cond *_cond, struct osip_mutex *_mut, const struct timespec *abstime)\n{\n  if (!_cond)\n    return OSIP_BADPARAMETER;\n  return pthread_cond_timedwait (&_cond->cv, (pthread_mutex_t *) _mut, (const struct timespec *) abstime);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          210,
          0
        ],
        "end_point": [
          257,
          1
        ],
        "content": "int\nosip_cond_timedwait (struct osip_cond *_cond, struct osip_mutex *_mut, const struct timespec *abstime)\n{\n  DWORD dwRet;\n  struct timespec now;\n  int timeout_ms;\n  HANDLE sem;\n  int i;\n\n  if (!_cond)\n    return OSIP_BADPARAMETER;\n\n  sem = *((HANDLE *) _cond->sem);\n\n  if (sem == NULL)\n    return OSIP_UNDEFINED_ERROR;\n\n  if (abstime == NULL)\n    return OSIP_BADPARAMETER;\n\n  __osip_clock_gettime (OSIP_CLOCK_REALTIME, &now);\n\n  timeout_ms = _delta_time (&now, abstime);\n  if (timeout_ms <= 0)\n    return 1;                   /* ETIMEDOUT; */\n\n  i = osip_mutex_unlock (_mut);\n  if (i != 0)\n    return i;\n\n  dwRet = WaitForSingleObjectEx (sem, timeout_ms, FALSE);\n\n  i = osip_mutex_lock (_mut);\n  if (i != 0)\n    return i;\n\n  switch (dwRet) {\n  case WAIT_OBJECT_0:\n    return OSIP_SUCCESS;\n    break;\n  case WAIT_TIMEOUT:\n    return 1;                   /* ETIMEDOUT; */\n    break;\n  default:\n    return OSIP_UNDEFINED_ERROR;\n    break;\n  }\n}",
        "lines": 48,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          342,
          0
        ],
        "end_point": [
          375,
          1
        ],
        "content": "int\nosip_cond_timedwait (struct osip_cond *_cond, struct osip_mutex *_mut, const struct timespec *abstime)\n{\n  int rate = sysClkRateGet ();\n  struct timespec now;\n  long sec, nsec;\n  int ticks;\n  SEM_ID sem;\n\n  if (_cond == NULL)\n    return OSIP_BADPARAMETER;\n\n  sem = ((osip_sem_t *) _cond->sem)->semId;\n\n  if (sem == NULL)\n    return OSIP_UNDEFINED_ERROR;\n\n  if (abstime == NULL)\n    return OSIP_BADPARAMETER;\n  clock_gettime (CLOCK_REALTIME, &now);\n\n  sec = abstime->tv_sec - now.tv_sec;\n  nsec = abstime->tv_nsec - now.tv_nsec;\n\n  while ((sec > 0) && (nsec < 0)) {\n    --sec;\n    nsec += 1000000000;\n  }\n  if (nsec < 0)\n    return 1;                   /*ETIMEDOUT; */\n  ticks = (sec * rate) + (nsec / 1000 * rate / 1000000);\n\n  return _cond_wait (_cond, _mut, ticks);\n}",
        "lines": 34,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "__osip_clock_gettime": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "int\n__osip_clock_gettime (unsigned int clock_id, struct timespec *tp)\n{\n  struct _timeb time_val;\n\n  if (clock_id != OSIP_CLOCK_REALTIME)\n    return OSIP_BADPARAMETER;\n\n  if (tp == NULL)\n    return OSIP_BADPARAMETER;\n\n  _ftime (&time_val);\n  tp->tv_sec = (long) time_val.time;\n  tp->tv_nsec = time_val.millitm * 1000000;\n  return OSIP_SUCCESS;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "_delta_time": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "static int\n_delta_time (const struct timespec *start, const struct timespec *end)\n{\n  int difx;\n\n  if (start == NULL || end == NULL)\n    return OSIP_SUCCESS;\n\n  difx = ((end->tv_sec - start->tv_sec) * 1000) + ((end->tv_nsec - start->tv_nsec) / 1000000);\n\n  return difx;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_cond_wait": {
      "start_point": [
        295,
        8
      ],
      "end_point": [
        334,
        1
      ],
      "content": "int\n_cond_wait (struct osip_cond *_cond, struct osip_mutex *_mut, int ticks)\n{\n  int ret;\n\n  if (_cond == NULL)\n    return OSIP_BADPARAMETER;\n\n  ret = osip_mutex_unlock (_mut);\n  if (ret != 0) {\n    return ret;\n  }\n\n  ret = semTake (((osip_sem_t *) _cond->sem)->semId, ticks);\n  if (ret != OK) {\n    switch (errno) {\n    case S_objLib_OBJ_ID_ERROR:\n      /* fall through */\n    case S_objLib_OBJ_UNAVAILABLE:\n      /* fall through */\n#if 0\n    case S_intLib_NOT_ISR_CALLABLE:\n#endif\n      ret = OSIP_UNDEFINED_ERROR;\n      break;\n    case S_objLib_OBJ_TIMEOUT:\n      ret = 1;\n      break;\n    default:                   /* vxworks has bugs */\n      ret = 1;\n      break;\n    }\n  }\n\n  i = osip_mutex_lock (_mut);\n  if (i != 0) {\n    ret = i;\n  }\n  return ret;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/port_fifo.c": {
    "osip_fifo_init": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\nosip_fifo_init (osip_fifo_t * ff)\n{\n#ifndef OSIP_MONOTHREAD\n  ff->qislocked = osip_mutex_init ();\n  /*INIT SEMA TO BLOCK ON GET() WHEN QUEUE IS EMPTY */\n  ff->qisempty = osip_sem_init (0);\n#endif\n  osip_list_init (&ff->queue);\n  /* ff->nb_elt = 0; */\n  ff->state = osip_empty;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_fifo_add": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nosip_fifo_add (osip_fifo_t * ff, void *el)\n{\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (ff->qislocked);\n#endif\n\n  osip_list_add (&ff->queue, el, -1);   /* insert at end of queue */\n  ff->state = osip_ok;\n\n#ifndef OSIP_MONOTHREAD\n  osip_sem_post (ff->qisempty);\n  osip_mutex_unlock (ff->qislocked);\n#endif\n  return OSIP_SUCCESS;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_fifo_insert": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nosip_fifo_insert (osip_fifo_t * ff, void *el)\n{\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (ff->qislocked);\n#endif\n\n  osip_list_add (&ff->queue, el, 0);    /* insert at end of queue */\n  ff->state = osip_ok;\n\n#ifndef OSIP_MONOTHREAD\n  osip_sem_post (ff->qisempty);\n  osip_mutex_unlock (ff->qislocked);\n#endif\n  return OSIP_SUCCESS;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_fifo_size": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nosip_fifo_size (osip_fifo_t * ff)\n{\n  int i;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_lock (ff->qislocked);\n#endif\n\n  i = osip_list_size (&ff->queue);\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (ff->qislocked);\n#endif\n  return i;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_fifo_get": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "void *\nosip_fifo_get (osip_fifo_t * ff)\n{\n  void *el = NULL;\n\n#ifndef OSIP_MONOTHREAD\n  int i = osip_sem_wait (ff->qisempty);\n\n  if (i != 0)\n    return NULL;\n  osip_mutex_lock (ff->qislocked);\n#endif\n\n  if (ff->state != osip_empty) {\n    el = osip_list_get (&ff->queue, 0);\n    osip_list_remove (&ff->queue, 0);\n    /* ff->nb_elt--; */\n  }\n  else {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"no element in fifo.\\n\"));\n#ifndef OSIP_MONOTHREAD\n    osip_mutex_unlock (ff->qislocked);\n#endif\n    return OSIP_SUCCESS;        /* pile vide */\n  }\n  /* if (ff->nb_elt <= 0) */\n  if (osip_list_size (&ff->queue) <= 0)\n    ff->state = osip_empty;\n  else\n    ff->state = osip_ok;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (ff->qislocked);\n#endif\n  return el;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "void",
        "*\nosip_fifo_get (osip_fifo_t * ff)",
        "*"
      ]
    },
    "osip_fifo_tryget": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\nosip_fifo_tryget (osip_fifo_t * ff)\n{\n  void *el = NULL;\n\n#ifndef OSIP_MONOTHREAD\n  if (0 != osip_sem_trywait (ff->qisempty)) {   /* no elements... */\n    return NULL;\n  }\n  osip_mutex_lock (ff->qislocked);\n#else\n  if (ff->state == osip_empty)\n    return NULL;\n#endif\n\n  if (ff->state != osip_empty) {\n    el = osip_list_get (&ff->queue, 0);\n    osip_list_remove (&ff->queue, 0);\n    /* ff->nb_elt--; */\n  }\n#ifndef OSIP_MONOTHREAD\n  else {                        /* this case MUST never happen... */\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO4, NULL, \"no element in fifo.\\n\"));\n    osip_mutex_unlock (ff->qislocked);\n    return OSIP_SUCCESS;\n  }\n#endif\n\n  /* if (ff->nb_elt <= 0) */\n  if (osip_list_size (&ff->queue) <= 0)\n    ff->state = osip_empty;\n  else\n    ff->state = osip_ok;\n\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_unlock (ff->qislocked);\n#endif\n  return el;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void",
        "*\nosip_fifo_tryget (osip_fifo_t * ff)",
        "*"
      ]
    },
    "osip_fifo_free": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\nosip_fifo_free (osip_fifo_t * ff)\n{\n  if (ff == NULL)\n    return;\n#ifndef OSIP_MONOTHREAD\n  osip_mutex_destroy (ff->qislocked);\n  /* seems that pthread_mutex_destroy does not free space by itself */\n  osip_sem_destroy (ff->qisempty);\n#endif\n  osip_free (ff);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osip2/port_sema.c": {
    "osip_mutex_init": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          47,
          1
        ],
        "content": "struct osip_mutex *\nosip_mutex_init ()\n{\n  osip_mutex_t *mut = (osip_mutex_t *) osip_malloc (sizeof (osip_mutex_t));\n\n  if (mut == NULL)\n    return NULL;\n  pthread_mutex_init (mut, NULL);\n  return (struct osip_mutex *) mut;\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "struct osip_mutex",
          "struct",
          "osip_mutex",
          "*\nosip_mutex_init ()",
          "*"
        ]
      },
      {
        "start_point": [
          392,
          0
        ],
        "end_point": [
          396,
          1
        ],
        "content": "struct osip_mutex *\nosip_mutex_init ()\n{\n  return (struct osip_mutex *) semMCreate (SEM_Q_FIFO | SEM_DELETE_SAFE);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "struct osip_mutex",
          "struct",
          "osip_mutex",
          "*\nosip_mutex_init ()",
          "*"
        ]
      },
      {
        "start_point": [
          493,
          0
        ],
        "end_point": [
          510,
          1
        ],
        "content": "struct osip_mutex *\nosip_mutex_init ()\n{\n  osip_mutex_t *mut = (osip_mutex_t *) osip_malloc (sizeof (osip_mutex_t));\n\n  if (mut == NULL)\n    return NULL;\n#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)\n  if (InitializeCriticalSectionEx (&mut->h, OSIP_CRITICALSECTION_SPIN, CRITICAL_SECTION_NO_DEBUG_INFO) != 0) {\n    return (struct osip_mutex *) (mut);\n  }\n#else\n  if (InitializeCriticalSectionAndSpinCount (&mut->h, OSIP_CRITICALSECTION_SPIN) != 0)\n    return (struct osip_mutex *) (mut);\n#endif\n  osip_free (mut);\n  return (NULL);\n}",
        "lines": 18,
        "depth": 12,
        "decorators": [
          "struct osip_mutex",
          "struct",
          "osip_mutex",
          "*\nosip_mutex_init ()",
          "*"
        ]
      },
      {
        "start_point": [
          547,
          0
        ],
        "end_point": [
          558,
          1
        ],
        "content": "struct osip_mutex *\nosip_mutex_init ()\n{\n  osip_mutex_t *mut = (osip_mutex_t *) osip_malloc (sizeof (osip_mutex_t));\n\n  if (mut == NULL)\n    return NULL;\n  if ((mut->h = CreateMutex (NULL, FALSE, NULL)) != NULL)\n    return (struct osip_mutex *) (mut);\n  osip_free (mut);\n  return (NULL);\n}",
        "lines": 12,
        "depth": 10,
        "decorators": [
          "struct osip_mutex",
          "struct",
          "osip_mutex",
          "*\nosip_mutex_init ()",
          "*"
        ]
      },
      {
        "start_point": [
          668,
          0
        ],
        "end_point": [
          677,
          1
        ],
        "content": "struct osip_mutex *\nosip_mutex_init ()\n{\n  osip_mutex_t *mut = (osip_mutex_t *) osip_malloc (sizeof (osip_mutex_t));\n\n  if (sm_create (\"mut\", 1, 0, &mut->id) == 0)\n    return (struct osip_mutex *) (mut);\n  osip_free (mut);\n  return (NULL);\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "struct osip_mutex",
          "struct",
          "osip_mutex",
          "*\nosip_mutex_init ()",
          "*"
        ]
      },
      {
        "start_point": [
          777,
          0
        ],
        "end_point": [
          790,
          1
        ],
        "content": "struct osip_mutex *\nosip_mutex_init ()\n{\n  rtems_status_code status;\n  osip_mutex_t *mut = (osip_mutex_t *) osip_malloc (sizeof (osip_mutex_t));\n\n  status = rtems_semaphore_create (rtems_build_name ('s', 'i', 'p', 'M'), 1,    /* Count */\n                                   RTEMS_SIMPLE_BINARY_SEMAPHORE, 0, &mut->id);\n  if (status == RTEMS_SUCCESSFUL) {\n    return (struct osip_mutex *) (mut);\n  }\n  osip_free (mut);\n  return (NULL);\n}",
        "lines": 14,
        "depth": 10,
        "decorators": [
          "struct osip_mutex",
          "struct",
          "osip_mutex",
          "*\nosip_mutex_init ()",
          "*"
        ]
      }
    ],
    "osip_mutex_destroy": [
      {
        "start_point": [
          49,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "void\nosip_mutex_destroy (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return;\n  pthread_mutex_destroy (mut);\n  osip_free (mut);\n}",
        "lines": 10,
        "depth": 8,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          398,
          0
        ],
        "end_point": [
          406,
          1
        ],
        "content": "void\nosip_mutex_destroy (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return;\n  semDelete (mut);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          512,
          0
        ],
        "end_point": [
          521,
          1
        ],
        "content": "void\nosip_mutex_destroy (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return;\n  DeleteCriticalSection (&mut->h);\n  osip_free (mut);\n}",
        "lines": 10,
        "depth": 8,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          560,
          0
        ],
        "end_point": [
          569,
          1
        ],
        "content": "void\nosip_mutex_destroy (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return;\n  CloseHandle (mut->h);\n  osip_free (mut);\n}",
        "lines": 10,
        "depth": 8,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          679,
          0
        ],
        "end_point": [
          688,
          1
        ],
        "content": "void\nosip_mutex_destroy (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut) {\n    sm_delete (mut->id);\n    osip_free (mut);\n  }\n}",
        "lines": 10,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          792,
          0
        ],
        "end_point": [
          801,
          1
        ],
        "content": "void\nosip_mutex_destroy (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut != NULL) {\n    rtems_semaphore_delete (mut->id);\n    osip_free (mut);\n  }\n}",
        "lines": 10,
        "depth": 9,
        "decorators": [
          "void"
        ]
      }
    ],
    "osip_mutex_lock": [
      {
        "start_point": [
          60,
          0
        ],
        "end_point": [
          68,
          1
        ],
        "content": "int\nosip_mutex_lock (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return OSIP_BADPARAMETER;\n  return pthread_mutex_lock (mut);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          408,
          0
        ],
        "end_point": [
          416,
          1
        ],
        "content": "int\nosip_mutex_lock (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return OSIP_BADPARAMETER;\n  return semTake (mut, WAIT_FOREVER);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          523,
          0
        ],
        "end_point": [
          533,
          1
        ],
        "content": "int\nosip_mutex_lock (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return OSIP_BADPARAMETER;\n  EnterCriticalSection (&mut->h);\n\n  return (0);\n}",
        "lines": 11,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          571,
          0
        ],
        "end_point": [
          582,
          1
        ],
        "content": "int\nosip_mutex_lock (struct osip_mutex *_mut)\n{\n  DWORD err;\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return OSIP_BADPARAMETER;\n  if ((err = WaitForSingleObject (mut->h, INFINITE)) == WAIT_OBJECT_0)\n    return (0);\n  return (-1);\n}",
        "lines": 12,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          690,
          0
        ],
        "end_point": [
          700,
          1
        ],
        "content": "int\nosip_mutex_lock (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut) {\n    if (sm_p (mut->id, SM_WAIT, 0) != 0)\n      return OSIP_UNDEFINED_ERROR;\n  }\n  return (0);\n}",
        "lines": 11,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          803,
          0
        ],
        "end_point": [
          816,
          1
        ],
        "content": "int\nosip_mutex_lock (struct osip_mutex *_mut)\n{\n  rtems_status_code status;\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut != NULL) {\n    status = rtems_semaphore_obtain (mut->id, RTEMS_WAIT, RTEMS_NO_TIMEOUT);\n    if (status != RTEMS_SUCCESSFUL) {\n      return OSIP_UNDEFINED_ERROR;\n    }\n  }\n  return OSIP_SUCCESS;\n}",
        "lines": 14,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_mutex_unlock": [
      {
        "start_point": [
          70,
          0
        ],
        "end_point": [
          78,
          1
        ],
        "content": "int\nosip_mutex_unlock (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return OSIP_BADPARAMETER;\n  return pthread_mutex_unlock (mut);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          418,
          0
        ],
        "end_point": [
          426,
          1
        ],
        "content": "int\nosip_mutex_unlock (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return OSIP_BADPARAMETER;\n  return semGive (mut);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          535,
          0
        ],
        "end_point": [
          544,
          1
        ],
        "content": "int\nosip_mutex_unlock (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return OSIP_BADPARAMETER;\n  LeaveCriticalSection (&mut->h);\n  return (0);\n}",
        "lines": 10,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          584,
          0
        ],
        "end_point": [
          593,
          1
        ],
        "content": "int\nosip_mutex_unlock (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut == NULL)\n    return OSIP_BADPARAMETER;\n  ReleaseMutex (mut->h);\n  return (0);\n}",
        "lines": 10,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          702,
          0
        ],
        "end_point": [
          712,
          1
        ],
        "content": "int\nosip_mutex_unlock (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut) {\n    sm_v (mut->id);\n  }\n\n  return (0);\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          818,
          0
        ],
        "end_point": [
          828,
          1
        ],
        "content": "int\nosip_mutex_unlock (struct osip_mutex *_mut)\n{\n  osip_mutex_t *mut = (osip_mutex_t *) _mut;\n\n  if (mut != NULL) {\n    (void) rtems_semaphore_release (mut->id);\n  }\n\n  return (0);\n}",
        "lines": 11,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_sem_init": [
      {
        "start_point": [
          85,
          0
        ],
        "end_point": [
          99,
          1
        ],
        "content": "struct osip_sem *\nosip_sem_init (unsigned int value)\n{\n  osip_sem_t *sem = (osip_sem_t *) osip_malloc (sizeof (osip_sem_t));\n\n  if (sem == NULL)\n    return NULL;\n\n  sem->_sem_counter = 0;\n  sem->_sem_mutex = osip_mutex_init ();\n  if (sem->_sem_mutex != NULL)\n    return (struct osip_sem *) sem;\n  osip_free (sem);\n  return NULL;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "struct osip_sem",
          "struct",
          "osip_sem",
          "*\nosip_sem_init (unsigned int value)",
          "*"
        ]
      },
      {
        "start_point": [
          168,
          0
        ],
        "end_point": [
          180,
          1
        ],
        "content": "struct osip_sem *\nosip_sem_init (unsigned int value)\n{\n  osip_sem_t *sem = (osip_sem_t *) osip_malloc (sizeof (osip_sem_t));\n\n  if (sem == NULL)\n    return NULL;\n\n  if (sem_init (sem, 0, value) == 0)\n    return (struct osip_sem *) sem;\n  osip_free (sem);\n  return NULL;\n}",
        "lines": 13,
        "depth": 10,
        "decorators": [
          "struct osip_sem",
          "struct",
          "osip_sem",
          "*\nosip_sem_init (unsigned int value)",
          "*"
        ]
      },
      {
        "start_point": [
          225,
          0
        ],
        "end_point": [
          240,
          1
        ],
        "content": "struct osip_sem *\nosip_sem_init (unsigned int value)\n{\n  task_t task = mach_task_self ();\n  int policy = SYNC_POLICY_FIFO;\n  osip_sem_t *sem = (osip_sem_t *) osip_malloc (sizeof (osip_sem_t));\n\n  if (sem == NULL)\n    return NULL;\n\n  if (semaphore_create (task, &sem->semid, policy, value) == KERN_SUCCESS)\n    return (struct osip_sem *) sem;\n\n  osip_free (sem);\n  return NULL;\n}",
        "lines": 16,
        "depth": 10,
        "decorators": [
          "struct osip_sem",
          "struct",
          "osip_sem",
          "*\nosip_sem_init (unsigned int value)",
          "*"
        ]
      },
      {
        "start_point": [
          304,
          0
        ],
        "end_point": [
          328,
          1
        ],
        "content": "struct osip_sem *\nosip_sem_init (unsigned int value)\n{\n  union semun val;\n  int i;\n  osip_sem_t *sem = (osip_sem_t *) osip_malloc (sizeof (osip_sem_t));\n\n  if (sem == NULL)\n    return NULL;\n\n  sem->semid = semget (IPC_PRIVATE, 1, IPC_CREAT | SEM_PERM);\n  if (sem->semid == -1) {\n    perror (\"semget error\");\n    osip_free (sem);\n    return NULL;\n  }\n  val.val = (int) value;\n  i = semctl (sem->semid, 0, SETVAL, val);\n  if (i != 0) {\n    perror (\"semctl error\");\n    osip_free (sem);\n    return NULL;\n  }\n  return (struct osip_sem *) sem;\n}",
        "lines": 25,
        "depth": 10,
        "decorators": [
          "struct osip_sem",
          "struct",
          "osip_sem",
          "*\nosip_sem_init (unsigned int value)",
          "*"
        ]
      },
      {
        "start_point": [
          428,
          0
        ],
        "end_point": [
          442,
          1
        ],
        "content": "struct osip_sem *\nosip_sem_init (unsigned int value)\n{\n  SEM_ID initsem;\n  osip_sem_t *x;\n\n  x = (osip_sem_t *) osip_malloc (sizeof (osip_sem_t));\n  if (x == NULL)\n    return NULL;\n  initsem = semCCreate (SEM_Q_FIFO, value);\n  x->semId = initsem;\n  x->refCnt = value;\n  x->sem_name = NULL;\n  return (struct osip_sem *) x;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "struct osip_sem",
          "struct",
          "osip_sem",
          "*\nosip_sem_init (unsigned int value)",
          "*"
        ]
      },
      {
        "start_point": [
          596,
          0
        ],
        "end_point": [
          613,
          1
        ],
        "content": "struct osip_sem *\nosip_sem_init (unsigned int value)\n{\n  osip_sem_t *sem = (osip_sem_t *) osip_malloc (sizeof (osip_sem_t));\n\n  if (sem == NULL)\n    return NULL;\n\n#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)\n  if ((sem->h = CreateSemaphoreExW (NULL, value, LONG_MAX, NULL, 0, (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | SEMAPHORE_MODIFY_STATE))) != NULL)\n    return (struct osip_sem *) (sem);\n#else\n  if ((sem->h = CreateSemaphore (NULL, value, LONG_MAX, NULL)) != NULL)\n    return (struct osip_sem *) (sem);\n#endif\n  osip_free (sem);\n  return (NULL);\n}",
        "lines": 18,
        "depth": 14,
        "decorators": [
          "struct osip_sem",
          "struct",
          "osip_sem",
          "*\nosip_sem_init (unsigned int value)",
          "*"
        ]
      },
      {
        "start_point": [
          714,
          0
        ],
        "end_point": [
          723,
          1
        ],
        "content": "struct osip_sem *\nosip_sem_init (unsigned int value)\n{\n  osip_sem_t *sem = (osip_sem_t *) osip_malloc (sizeof (osip_sem_t));\n\n  if (sm_create (\"sem\", value, 0, &sem->id) == 0)\n    return (struct osip_sem *) (sem);\n  osip_free (sem);\n  return (NULL);\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "struct osip_sem",
          "struct",
          "osip_sem",
          "*\nosip_sem_init (unsigned int value)",
          "*"
        ]
      },
      {
        "start_point": [
          830,
          0
        ],
        "end_point": [
          844,
          1
        ],
        "content": "struct osip_sem *\nosip_sem_init (unsigned int value)\n{\n  rtems_status_code status;\n\n  osip_sem_t *sem = (osip_sem_t *) osip_malloc (sizeof (osip_sem_t));\n\n  status = rtems_semaphore_create (rtems_build_name ('s', 'i', 'p', 'S'), value, RTEMS_COUNTING_SEMAPHORE, 0, &sem->id);\n\n  if (status == RTEMS_SUCCESSFUL) {\n    return (struct osip_sem *) (sem);\n  }\n  osip_free (sem);\n  return (NULL);\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "struct osip_sem",
          "struct",
          "osip_sem",
          "*\nosip_sem_init (unsigned int value)",
          "*"
        ]
      }
    ],
    "osip_sem_destroy": [
      {
        "start_point": [
          101,
          0
        ],
        "end_point": [
          111,
          1
        ],
        "content": "int\nosip_sem_destroy (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_SUCCESS;\n  osip_mutex_destroy (sem->_sem_mutex);\n  osip_free (sem);\n  return OSIP_SUCCESS;\n}",
        "lines": 11,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          182,
          0
        ],
        "end_point": [
          192,
          1
        ],
        "content": "int\nosip_sem_destroy (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_SUCCESS;\n  sem_destroy (sem);\n  osip_free (sem);\n  return OSIP_SUCCESS;\n}",
        "lines": 11,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          242,
          0
        ],
        "end_point": [
          257,
          1
        ],
        "content": "int\nosip_sem_destroy (struct osip_sem *_sem)\n{\n  task_t task = mach_task_self ();\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_SUCCESS;\n  if (semaphore_destroy (task, sem->semid) == KERN_SUCCESS) {\n    osip_free (sem);\n    return OSIP_SUCCESS;\n  }\n\n  osip_free (sem);\n  return OSIP_SUCCESS;\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          330,
          0
        ],
        "end_point": [
          342,
          1
        ],
        "content": "int\nosip_sem_destroy (struct osip_sem *_sem)\n{\n  union semun val;\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_SUCCESS;\n  val.val = 0;\n  semctl (sem->semid, 0, IPC_RMID, val);\n  osip_free (sem);\n  return OSIP_SUCCESS;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          444,
          0
        ],
        "end_point": [
          454,
          1
        ],
        "content": "int\nosip_sem_destroy (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_SUCCESS;\n  semDelete (sem->semId);\n  osip_free (sem);\n  return OSIP_SUCCESS;\n}",
        "lines": 11,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          615,
          0
        ],
        "end_point": [
          625,
          1
        ],
        "content": "int\nosip_sem_destroy (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_SUCCESS;\n  CloseHandle (sem->h);\n  osip_free (sem);\n  return (0);\n}",
        "lines": 11,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          725,
          0
        ],
        "end_point": [
          735,
          1
        ],
        "content": "int\nosip_sem_destroy (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_SUCCESS;\n  sm_delete (sem->id);\n  osip_free (sem);\n  return (0);\n}",
        "lines": 11,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          846,
          0
        ],
        "end_point": [
          857,
          1
        ],
        "content": "int\nosip_sem_destroy (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL) {\n    return OSIP_SUCCESS;\n  }\n  rtems_semaphore_delete (sem->id);\n  osip_free (sem);\n  return (0);\n}",
        "lines": 12,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_sem_post": [
      {
        "start_point": [
          113,
          0
        ],
        "end_point": [
          124,
          1
        ],
        "content": "int\nosip_sem_post (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  osip_mutex_lock (sem->_sem_mutex);\n  sem->_sem_counter++;\n  osip_mutex_unlock (sem->_sem_mutex);\n  return OSIP_SUCCESS;\n}",
        "lines": 12,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          194,
          0
        ],
        "end_point": [
          202,
          1
        ],
        "content": "int\nosip_sem_post (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  return sem_post (sem);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          259,
          0
        ],
        "end_point": [
          270,
          1
        ],
        "content": "int\nosip_sem_post (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  if (semaphore_signal (sem->semid) == KERN_SUCCESS)\n    return OSIP_SUCCESS;\n\n  return OSIP_UNDEFINED_ERROR;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          344,
          0
        ],
        "end_point": [
          356,
          1
        ],
        "content": "int\nosip_sem_post (struct osip_sem *_sem)\n{\n  struct sembuf sb;\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  sb.sem_num = 0;\n  sb.sem_op = 1;\n  sb.sem_flg = 0;\n  return semop (sem->semid, &sb, 1);\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          456,
          0
        ],
        "end_point": [
          464,
          1
        ],
        "content": "int\nosip_sem_post (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  return semGive (sem->semId);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          627,
          0
        ],
        "end_point": [
          636,
          1
        ],
        "content": "int\nosip_sem_post (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  ReleaseSemaphore (sem->h, 1, NULL);\n  return (0);\n}",
        "lines": 10,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          737,
          0
        ],
        "end_point": [
          745,
          1
        ],
        "content": "int\nosip_sem_post (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  return (sm_v (sem->id));\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          859,
          0
        ],
        "end_point": [
          868,
          1
        ],
        "content": "int\nosip_sem_post (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL) {\n    return OSIP_UNDEFINED_ERROR;\n  }\n  return rtems_semaphore_release (sem->id);\n}",
        "lines": 10,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_sem_wait": [
      {
        "start_point": [
          126,
          0
        ],
        "end_point": [
          146,
          1
        ],
        "content": "int\nosip_sem_wait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n\n  /* poor emulation... */\n  while (1) {\n    osip_mutex_lock (sem->_sem_mutex);\n    if (sem->_sem_counter > 0) {\n      sem->_sem_counter--;\n      osip_mutex_unlock (sem->_sem_mutex);\n      return OSIP_SUCCESS;\n    }\n    osip_mutex_unlock (sem->_sem_mutex);\n    osip_usleep (1000);\n  }\n  return OSIP_UNDEFINED_ERROR;\n}",
        "lines": 21,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          204,
          0
        ],
        "end_point": [
          212,
          1
        ],
        "content": "int\nosip_sem_wait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  return sem_wait (sem);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          272,
          0
        ],
        "end_point": [
          283,
          1
        ],
        "content": "int\nosip_sem_wait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  if (semaphore_wait (sem->semid) == KERN_SUCCESS)\n    return OSIP_SUCCESS;\n\n  return OSIP_UNDEFINED_ERROR;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          358,
          0
        ],
        "end_point": [
          370,
          1
        ],
        "content": "int\nosip_sem_wait (struct osip_sem *_sem)\n{\n  struct sembuf sb;\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  sb.sem_num = 0;\n  sb.sem_op = -1;\n  sb.sem_flg = 0;\n  return semop (sem->semid, &sb, 1);\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          466,
          0
        ],
        "end_point": [
          474,
          1
        ],
        "content": "int\nosip_sem_wait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  return semTake (sem->semId, WAIT_FOREVER);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          638,
          0
        ],
        "end_point": [
          651,
          1
        ],
        "content": "int\nosip_sem_wait (struct osip_sem *_sem)\n{\n  DWORD err;\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  if ((err = WaitForSingleObjectEx (sem->h, INFINITE, FALSE)) == WAIT_OBJECT_0)\n    return (0);\n  if (err == WAIT_TIMEOUT)\n    return (-1);\n  return (-1);\n}",
        "lines": 14,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          747,
          0
        ],
        "end_point": [
          757,
          1
        ],
        "content": "int\nosip_sem_wait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  if (sm_p (sem->id, SM_WAIT, 0) != 0)\n    return (-1);\n  return (0);\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          870,
          0
        ],
        "end_point": [
          882,
          1
        ],
        "content": "int\nosip_sem_wait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL) {\n    return OSIP_BADPARAMETER;\n  }\n  if (rtems_semaphore_obtain (sem->id, RTEMS_WAIT, RTEMS_NO_TIMEOUT) != RTEMS_SUCCESSFUL) {\n    return OSIP_UNDEFINED_ERROR;\n  }\n  return (0);\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_sem_trywait": [
      {
        "start_point": [
          148,
          0
        ],
        "end_point": [
          163,
          1
        ],
        "content": "int\nosip_sem_trywait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  osip_mutex_lock (sem->_sem_mutex);\n  if (sem->_sem_counter > 0) {\n    sem->_sem_counter--;\n    osip_mutex_unlock (sem->_sem_mutex);\n    return OSIP_SUCCESS;\n  }\n  osip_mutex_unlock (sem->_sem_mutex);\n  return OSIP_UNDEFINED_ERROR;\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          214,
          0
        ],
        "end_point": [
          222,
          1
        ],
        "content": "int\nosip_sem_trywait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  return sem_trywait (sem);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          285,
          0
        ],
        "end_point": [
          297,
          1
        ],
        "content": "int\nosip_sem_trywait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  mach_timespec_t wait_time = { 0, 0 };\n  if (semaphore_timedwait (sem->semid, wait_time) == KERN_SUCCESS)\n    return OSIP_SUCCESS;\n\n  return OSIP_UNDEFINED_ERROR;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          372,
          0
        ],
        "end_point": [
          384,
          1
        ],
        "content": "int\nosip_sem_trywait (struct osip_sem *_sem)\n{\n  struct sembuf sb;\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  sb.sem_num = 0;\n  sb.sem_op = -1;\n  sb.sem_flg = IPC_NOWAIT;\n  return semop (sem->semid, &sb, 1);\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          476,
          0
        ],
        "end_point": [
          484,
          1
        ],
        "content": "int\nosip_sem_trywait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  return semTake (sem->semId, NO_WAIT);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          653,
          0
        ],
        "end_point": [
          664,
          1
        ],
        "content": "int\nosip_sem_trywait (struct osip_sem *_sem)\n{\n  DWORD err;\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  if ((err = WaitForSingleObjectEx (sem->h, 0, FALSE)) == WAIT_OBJECT_0)\n    return (0);\n  return (-1);\n}",
        "lines": 12,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          759,
          0
        ],
        "end_point": [
          769,
          1
        ],
        "content": "int\nosip_sem_trywait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL)\n    return OSIP_BADPARAMETER;\n  if (sm_p (sem->id, SM_NOWAIT, 0) != 0)\n    return OSIP_UNDEFINED_ERROR;\n  return (0);\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          884,
          0
        ],
        "end_point": [
          896,
          1
        ],
        "content": "int\nosip_sem_trywait (struct osip_sem *_sem)\n{\n  osip_sem_t *sem = (osip_sem_t *) _sem;\n\n  if (sem == NULL) {\n    return OSIP_BADPARAMETER;\n  }\n  if (rtems_semaphore_obtain (sem->id, RTEMS_NO_WAIT, 0) != RTEMS_SUCCESSFUL) {\n    return OSIP_UNDEFINED_ERROR;\n  }\n  return (0);\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "osip/libosip2-5.0.0/src/osip2/port_thread.c": {
    "osip_thread_create": [
      {
        "start_point": [
          45,
          0
        ],
        "end_point": [
          61,
          1
        ],
        "content": "struct osip_thread *\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)\n{\n  int i;\n  osip_thread_t *thread = (osip_thread_t *) osip_malloc (sizeof (osip_thread_t));\n\n  if (thread == NULL)\n    return NULL;\n\n  i = pthread_create (thread, NULL, func, (void *) arg);\n  if (i != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Error while creating a new thread\\n\"));\n    osip_free (thread);\n    return NULL;\n  }\n  return (struct osip_thread *) thread;\n}",
        "lines": 17,
        "depth": 11,
        "decorators": [
          "struct osip_thread",
          "struct",
          "osip_thread",
          "*\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)",
          "*"
        ]
      },
      {
        "start_point": [
          97,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "struct osip_thread *\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)\n{\n  osip_thread_t *thread = (osip_thread_t *) osip_malloc (sizeof (osip_thread_t));\n\n  if (thread == NULL)\n    return NULL;\n  thread->h = new std::thread (func, arg);\n  if (thread->h == 0) {\n    osip_free (thread);\n    return NULL;\n  }\n  return (struct osip_thread *) thread;\n}",
        "lines": 14,
        "depth": 11,
        "decorators": [
          "struct osip_thread",
          "struct",
          "osip_thread",
          "*\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)",
          "*"
        ]
      },
      {
        "start_point": [
          141,
          0
        ],
        "end_point": [
          156,
          1
        ],
        "content": "struct osip_thread *\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)\n{\n  osip_thread_t *thread = (osip_thread_t *) osip_malloc (sizeof (osip_thread_t));\n\n  if (thread == NULL)\n    return NULL;\n  thread->h = (HANDLE) _beginthreadex (NULL,    /* default security attr */\n                                       0,       /* use default one */\n                                       (unsigned (__stdcall *) (void *)) func, arg, 0, &(thread->id));\n  if (thread->h == 0) {\n    osip_free (thread);\n    return NULL;\n  }\n  return (struct osip_thread *) thread;\n}",
        "lines": 16,
        "depth": 15,
        "decorators": [
          "struct osip_thread",
          "struct",
          "osip_thread",
          "*\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)",
          "*"
        ]
      },
      {
        "start_point": [
          197,
          0
        ],
        "end_point": [
          215,
          1
        ],
        "content": "struct osip_thread *\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)\n{\n  osip_thread_t *thread = (osip_thread_t *) osip_malloc (sizeof (osip_thread_t));\n\n  if (thread == NULL)\n    return (NULL);\n  if (t_create (\"sip\", 150, stacksize, 0, 0, &thread->tid) != 0) {\n    osip_free (thread);\n    return (NULL);\n  }\n\n  if (t_start (thread->tid, T_PREEMPT | T_ISR, func, 0) != 0) {\n    osip_free (thread);\n    return (NULL);\n  }\n\n  return (struct osip_thread *) thread;\n}",
        "lines": 19,
        "depth": 11,
        "decorators": [
          "struct osip_thread",
          "struct",
          "osip_thread",
          "*\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)",
          "*"
        ]
      },
      {
        "start_point": [
          250,
          0
        ],
        "end_point": [
          261,
          1
        ],
        "content": "struct osip_thread *\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)\n{\n  osip_thread_t *thread = (osip_thread_t *) osip_malloc (sizeof (osip_thread_t));\n\n  if (thread == NULL)\n    return NULL;\n  thread->id = taskSpawn (NULL, 5, 0, stacksize, (FUNCPTR) func, (int) arg, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  if (thread->id < 0)\n    osip_free (thread);\n  return (struct osip_thread *) thread;\n}",
        "lines": 12,
        "depth": 11,
        "decorators": [
          "struct osip_thread",
          "struct",
          "osip_thread",
          "*\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)",
          "*"
        ]
      },
      {
        "start_point": [
          294,
          0
        ],
        "end_point": [
          315,
          1
        ],
        "content": "struct osip_thread *\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)\n{\n  rtems_status_code status;\n  osip_thread_t *thread = (osip_thread_t *) osip_malloc (sizeof (osip_thread_t));\n\n  if (thread == NULL)\n    return NULL;\n\n  status = rtems_task_create (rtems_build_name ('S', 'I', 'P', 'T'), 100, stacksize, RTEMS_DEFAULT_MODES, RTEMS_DEFAULT_ATTRIBUTES, &thread->tid);\n\n  if (status == RTEMS_SUCCESSFUL) {\n    status = rtems_task_start (thread->tid, (rtems_task_entry) func, (rtems_task_argument) arg);\n  }\n\n  if (status != RTEMS_SUCCESSFUL) {\n    osip_free (thread);\n    thread = NULL;\n  }\n\n  return (struct osip_thread *) thread;\n}",
        "lines": 22,
        "depth": 11,
        "decorators": [
          "struct osip_thread",
          "struct",
          "osip_thread",
          "*\nosip_thread_create (int stacksize, void *(*func) (void *), void *arg)",
          "*"
        ]
      }
    ],
    "osip_thread_set_priority": [
      {
        "start_point": [
          63,
          0
        ],
        "end_point": [
          67,
          1
        ],
        "content": "int\nosip_thread_set_priority (struct osip_thread *thread, int priority)\n{\n  return OSIP_SUCCESS;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          133,
          0
        ],
        "end_point": [
          137,
          1
        ],
        "content": "int\nosip_thread_set_priority (struct osip_thread *thread, int priority)\n{\n  return OSIP_SUCCESS;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          185,
          0
        ],
        "end_point": [
          189,
          1
        ],
        "content": "int\nosip_thread_set_priority (struct osip_thread *thread, int priority)\n{\n  return OSIP_SUCCESS;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          217,
          0
        ],
        "end_point": [
          227,
          1
        ],
        "content": "int\nosip_thread_set_priority (struct osip_thread *_thread, int priority)\n{\n  unsigned long oldprio;\n  osip_thread_t *thread = (osip_thread_t *) _thread;\n\n  if (thread == NULL)\n    return OSIP_BADPARAMETER;\n  t_set_pri (thread->tid, priority, &oldprio);\n  return OSIP_SUCCESS;\n}",
        "lines": 11,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          263,
          0
        ],
        "end_point": [
          272,
          1
        ],
        "content": "int\nosip_thread_set_priority (struct osip_thread *_thread, int priority)\n{\n  osip_thread_t *thread = (osip_thread_t *) _thread;\n\n  if (thread == NULL)\n    return OSIP_BADPARAMETER;\n  taskPrioritySet (thread->id, 1);\n  return OSIP_SUCCESS;\n}",
        "lines": 10,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          317,
          0
        ],
        "end_point": [
          328,
          1
        ],
        "content": "int\nosip_thread_set_priority (struct osip_thread *_thread, int priority)\n{\n  osip_thread_t *thread = (osip_thread_t *) _thread;\n\n  rtems_task_priority old;\n\n  if (thread != NULL) {\n    return rtems_task_set_priority (thread->tid, priority, &old);\n  }\n  return OSIP_SUCCESS;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_thread_join": [
      {
        "start_point": [
          69,
          0
        ],
        "end_point": [
          77,
          1
        ],
        "content": "int\nosip_thread_join (struct osip_thread *_thread)\n{\n  osip_thread_t *thread = (osip_thread_t *) _thread;\n\n  if (thread == NULL)\n    return OSIP_BADPARAMETER;\n  return pthread_join (*thread, NULL);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          112,
          0
        ],
        "end_point": [
          126,
          1
        ],
        "content": "int\nosip_thread_join (struct osip_thread *_thread)\n{\n  osip_thread_t *thread = (osip_thread_t *) _thread;\n\n  std::thread * th;\n  if (thread == NULL)\n    return OSIP_BADPARAMETER;\n  th = (std::thread *) thread->h;\n  th->join ();\n  delete th;\n\n  thread->h = NULL;\n  return (0);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          158,
          0
        ],
        "end_point": [
          176,
          1
        ],
        "content": "int\nosip_thread_join (struct osip_thread *_thread)\n{\n  int i;\n  osip_thread_t *thread = (osip_thread_t *) _thread;\n\n  if (thread == NULL)\n    return OSIP_BADPARAMETER;\n  i = WaitForSingleObject (thread->h, INFINITE);\n  if (i == WAIT_OBJECT_0) {\n    /* fprintf (stdout, \"thread joined!\\n\"); */\n  }\n  else {\n    /* fprintf (stdout, \"ERROR!! thread joined ERROR!!\\n\"); */\n    return OSIP_UNDEFINED_ERROR;\n  }\n  CloseHandle (thread->h);\n  return (0);\n}",
        "lines": 19,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          229,
          0
        ],
        "end_point": [
          239,
          1
        ],
        "content": "int\nosip_thread_join (struct osip_thread *_thread)\n{\n  osip_thread_t *thread = (osip_thread_t *) _thread;\n\n  if (thread == NULL)\n    return OSIP_BADPARAMETER;\n  t_delete (thread->tid);\n\n  return (0);\n}",
        "lines": 11,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          274,
          0
        ],
        "end_point": [
          282,
          1
        ],
        "content": "int\nosip_thread_join (struct osip_thread *_thread)\n{\n  osip_thread_t *thread = (osip_thread_t *) _thread;\n\n  if (thread == NULL)\n    return OSIP_BADPARAMETER;\n  return taskDelete (thread->id);\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          331,
          0
        ],
        "end_point": [
          340,
          1
        ],
        "content": "int\nosip_thread_join (struct osip_thread *_thread)\n{\n  osip_thread_t *thread = (osip_thread_t *) _thread;\n\n  if (thread == NULL) {\n    return OSIP_BADPARAMETER;\n  }\n  return rtems_task_delete (thread->tid);\n}",
        "lines": 10,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_thread_exit": [
      {
        "start_point": [
          79,
          0
        ],
        "end_point": [
          85,
          1
        ],
        "content": "void\nosip_thread_exit ()\n{\n#if !defined(__arc__)\n  pthread_exit (NULL);\n#endif\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          128,
          0
        ],
        "end_point": [
          131,
          1
        ],
        "content": "void\nosip_thread_exit ()\n{\n}",
        "lines": 4,
        "depth": 4,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          178,
          0
        ],
        "end_point": [
          183,
          1
        ],
        "content": "void\nosip_thread_exit ()\n{\n  /* ExitThread(0); */\n  _endthreadex (0);\n}",
        "lines": 6,
        "depth": 6,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          241,
          0
        ],
        "end_point": [
          245,
          1
        ],
        "content": "void\nosip_thread_exit ()\n{\n  t_delete (0);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          284,
          0
        ],
        "end_point": [
          288,
          1
        ],
        "content": "void\nosip_thread_exit ()\n{\n  /*?? */\n}",
        "lines": 5,
        "depth": 4,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          342,
          0
        ],
        "end_point": [
          346,
          1
        ],
        "content": "void\nosip_thread_exit ()\n{\n  rtems_task_delete (RTEMS_SELF);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "osip/libosip2-5.0.0/src/osip2/xixt.h": {},
  "osip/libosip2-5.0.0/src/osipparser2/osip_accept.c": {
    "osip_message_set_accept": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nosip_message_set_accept (osip_message_t * sip, const char *hvalue)\n{\n  osip_accept_t *accept;\n  int i;\n\n  i = accept_init (&accept);\n  if (i != 0)\n    return i;\n  i = osip_accept_parse (accept, hvalue);\n  if (i != 0) {\n    osip_accept_free (accept);\n    return i;\n  }\n  sip->message_property = 2;\n\n  osip_list_add (&sip->accepts, accept, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_accept": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\nosip_message_get_accept (const osip_message_t * sip, int pos, osip_accept_t ** dest)\n{\n  osip_accept_t *accept;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->accepts) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  accept = (osip_accept_t *) osip_list_get (&sip->accepts, pos);\n  *dest = accept;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_accept_to_str": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\nosip_accept_to_str (const osip_accept_t * accept, char **dest)\n{\n  char *buf;\n  char *tmp;\n  size_t len = 0;\n\n  *dest = NULL;\n  if (accept == NULL)\n    return OSIP_BADPARAMETER;\n\n  if (accept->type != NULL)\n    len += strlen (accept->type);\n\n  if (accept->subtype != NULL)\n    len += strlen (accept->subtype);\n\n  if (len == 0) {\n    /* Empty header ! */\n    buf = (char *) osip_malloc (2);\n    if (buf == NULL)\n      return OSIP_NOMEM;\n    buf[0] = ' ';\n    buf[1] = '\\0';\n    *dest = buf;\n    return OSIP_SUCCESS;\n  }\n\n  /* try to guess a long enough length */\n  len += 4                      /* for '/', ' ', ';' and '\\0' */\n    + 10 * osip_list_size (&accept->gen_params);\n\n  buf = (char *) osip_malloc (len);\n  if (buf == NULL)\n    return OSIP_NOMEM;\n  tmp = buf;\n\n  sprintf (tmp, \"%s/%s\", accept->type, accept->subtype);\n\n  tmp = tmp + strlen (tmp);\n  {\n    osip_list_iterator_t it;\n    osip_generic_param_t *u_param = (osip_generic_param_t*) osip_list_get_first(&accept->gen_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n      size_t tmp_len;\n      if (u_param->gvalue == NULL) {\n        osip_free (buf);\n        return OSIP_SYNTAXERROR;\n      }\n      tmp_len = strlen (buf) + 4 + strlen (u_param->gname)\n        + strlen (u_param->gvalue) + 1;\n      if (len < tmp_len) {\n        buf = osip_realloc (buf, tmp_len);\n        len = tmp_len;\n        tmp = buf + strlen (buf);\n      }\n      snprintf (tmp, len - (tmp - buf), \"; %s=%s\", u_param->gname, u_param->gvalue);\n      tmp = tmp + strlen (tmp);\n      u_param = (osip_generic_param_t *) osip_list_get_next(&it);\n    }\n  }\n  *dest = buf;\n  return OSIP_SUCCESS;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_accept_encoding.c": {
    "osip_message_set_accept_encoding": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nosip_message_set_accept_encoding (osip_message_t * sip, const char *hvalue)\n{\n  osip_accept_encoding_t *accept_encoding;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_accept_encoding_init (&accept_encoding);\n  if (i != 0)\n    return i;\n  i = osip_accept_encoding_parse (accept_encoding, hvalue);\n  if (i != 0) {\n    osip_accept_encoding_free (accept_encoding);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->accept_encodings, accept_encoding, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_accept_encoding": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nosip_message_get_accept_encoding (const osip_message_t * sip, int pos, osip_accept_encoding_t ** dest)\n{\n  osip_accept_encoding_t *accept_encoding;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->accept_encodings) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  accept_encoding = (osip_accept_encoding_t *) osip_list_get (&sip->accept_encodings, pos);\n  *dest = accept_encoding;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_accept_encoding_init": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nosip_accept_encoding_init (osip_accept_encoding_t ** accept_encoding)\n{\n  *accept_encoding = (osip_accept_encoding_t *) osip_malloc (sizeof (osip_accept_encoding_t));\n  if (*accept_encoding == NULL)\n    return OSIP_NOMEM;\n  (*accept_encoding)->element = NULL;\n\n  osip_list_init (&(*accept_encoding)->gen_params);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_accept_encoding_parse": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nosip_accept_encoding_parse (osip_accept_encoding_t * accept_encoding, const char *hvalue)\n{\n  int i;\n  const char *osip_accept_encoding_params;\n\n  osip_accept_encoding_params = strchr (hvalue, ';');\n\n  if (osip_accept_encoding_params != NULL) {\n    i = __osip_generic_param_parseall (&accept_encoding->gen_params, osip_accept_encoding_params);\n    if (i != 0)\n      return i;\n  }\n  else\n    osip_accept_encoding_params = hvalue + strlen (hvalue);\n\n  if (osip_accept_encoding_params - hvalue + 1 < 2)\n    return OSIP_SYNTAXERROR;\n  accept_encoding->element = (char *) osip_malloc (osip_accept_encoding_params - hvalue + 1);\n  if (accept_encoding->element == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (accept_encoding->element, hvalue, osip_accept_encoding_params - hvalue);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_accept_encoding_to_str": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\nosip_accept_encoding_to_str (const osip_accept_encoding_t * accept_encoding, char **dest)\n{\n  char *buf;\n  char *tmp;\n  size_t len;\n\n  *dest = NULL;\n  if ((accept_encoding == NULL) || (accept_encoding->element == NULL))\n    return OSIP_BADPARAMETER;\n\n  len = strlen (accept_encoding->element) + 2;\n  buf = (char *) osip_malloc (len);\n  if (buf == NULL)\n    return OSIP_NOMEM;\n\n  sprintf (buf, \"%s\", accept_encoding->element);\n  {\n    size_t plen;\n    osip_list_iterator_t it;\n    osip_generic_param_t *u_param = (osip_generic_param_t*) osip_list_get_first(&accept_encoding->gen_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n      if (u_param->gvalue == NULL)\n        plen = strlen (u_param->gname) + 2;\n      else\n        plen = strlen (u_param->gname) + strlen (u_param->gvalue) + 3;\n      len = len + plen;\n      buf = (char *) osip_realloc (buf, len);\n      tmp = buf;\n      tmp = tmp + strlen (tmp);\n      if (u_param->gvalue == NULL)\n        snprintf (tmp, len - (tmp - buf), \";%s\", u_param->gname);\n      else\n        snprintf (tmp, len - (tmp - buf), \";%s=%s\", u_param->gname, u_param->gvalue);\n      u_param = (osip_generic_param_t *) osip_list_get_next(&it);\n    }\n  }\n  *dest = buf;\n  return OSIP_SUCCESS;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_accept_encoding_free": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "void\nosip_accept_encoding_free (osip_accept_encoding_t * accept_encoding)\n{\n  if (accept_encoding == NULL)\n    return;\n  osip_free (accept_encoding->element);\n\n  osip_generic_param_freelist (&accept_encoding->gen_params);\n\n  accept_encoding->element = NULL;\n  osip_free (accept_encoding);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_accept_encoding_clone": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "int\nosip_accept_encoding_clone (const osip_accept_encoding_t * ctt, osip_accept_encoding_t ** dest)\n{\n  int i;\n  osip_accept_encoding_t *ct;\n\n  *dest = NULL;\n  if (ctt == NULL)\n    return OSIP_BADPARAMETER;\n  if (ctt->element == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_accept_encoding_init (&ct);\n  if (i != 0)                   /* allocation failed */\n    return i;\n  ct->element = osip_strdup (ctt->element);\n  if (ct->element == NULL) {\n    osip_accept_encoding_free (ct);\n    return OSIP_NOMEM;\n  }\n  {\n    osip_generic_param_t *dest_param;\n    osip_list_iterator_t it;\n    osip_generic_param_t *u_param = (osip_generic_param_t*) osip_list_get_first(&ctt->gen_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n      i = osip_generic_param_clone (u_param, &dest_param);\n      if (i != 0) {\n        osip_accept_encoding_free (ct);\n        return i;\n      }\n      osip_list_add (&ct->gen_params, dest_param, -1);\n      u_param = (osip_generic_param_t *) osip_list_get_next(&it);\n    }\n  }\n  *dest = ct;\n  return OSIP_SUCCESS;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_accept_encoding_get_element": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "char *\nosip_accept_encoding_get_element (const osip_accept_encoding_t * ae)\n{\n  return ae->element;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_accept_encoding_get_element (const osip_accept_encoding_t * ae)",
        "*"
      ]
    },
    "osip_accept_encoding_set_element": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "void\nosip_accept_encoding_set_element (osip_accept_encoding_t * ae, char *element)\n{\n  ae->element = element;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_accept_language.c": {
    "osip_message_set_accept_language": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nosip_message_set_accept_language (osip_message_t * sip, const char *hvalue)\n{\n  osip_accept_language_t *accept_language;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_accept_language_init (&accept_language);\n  if (i != 0)\n    return i;\n  i = osip_accept_language_parse (accept_language, hvalue);\n  if (i != 0) {\n    osip_accept_language_free (accept_language);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->accept_languages, accept_language, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_accept_language": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nosip_message_get_accept_language (const osip_message_t * sip, int pos, osip_accept_language_t ** dest)\n{\n  osip_accept_language_t *accept_language;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->accept_languages) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  accept_language = (osip_accept_language_t *) osip_list_get (&sip->accept_languages, pos);\n  *dest = accept_language;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_alert_info.c": {
    "osip_message_set_alert_info": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nosip_message_set_alert_info (osip_message_t * sip, const char *hvalue)\n{\n  osip_alert_info_t *alert_info;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_alert_info_init (&alert_info);\n  if (i != 0)\n    return i;\n  i = osip_alert_info_parse (alert_info, hvalue);\n  if (i != 0) {\n    osip_alert_info_free (alert_info);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->alert_infos, alert_info, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_alert_info": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nosip_message_get_alert_info (const osip_message_t * sip, int pos, osip_alert_info_t ** dest)\n{\n  osip_alert_info_t *alert_info;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->alert_infos) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  alert_info = (osip_alert_info_t *) osip_list_get (&sip->alert_infos, pos);\n  *dest = alert_info;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_allow.c": {
    "osip_message_set_allow": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nosip_message_set_allow (osip_message_t * sip, const char *hvalue)\n{\n  osip_allow_t *allow;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_allow_init (&allow);\n  if (i != 0)\n    return i;\n  i = osip_allow_parse (allow, hvalue);\n  if (i != 0) {\n    osip_allow_free (allow);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->allows, allow, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_allow": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nosip_message_get_allow (const osip_message_t * sip, int pos, osip_allow_t ** dest)\n{\n  osip_allow_t *allow;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->allows) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  allow = (osip_allow_t *) osip_list_get (&sip->allows, pos);\n  *dest = allow;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_authentication_info.c": {
    "osip_authentication_info_init": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nosip_authentication_info_init (osip_authentication_info_t ** dest)\n{\n  *dest = (osip_authentication_info_t *)\n    osip_malloc (sizeof (osip_authentication_info_t));\n  if (*dest == NULL)\n    return OSIP_NOMEM;\n  memset (*dest, 0, sizeof (osip_authentication_info_t));\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_authentication_info": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nosip_message_set_authentication_info (osip_message_t * sip, const char *hvalue)\n{\n  osip_authentication_info_t *authentication_info;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  if (sip == NULL)\n    return OSIP_BADPARAMETER;\n  i = osip_authentication_info_init (&authentication_info);\n  if (i != 0)\n    return i;\n  i = osip_authentication_info_parse (authentication_info, hvalue);\n  if (i != 0) {\n    osip_authentication_info_free (authentication_info);\n    return i;\n  }\n  sip->message_property = 2;\n\n  osip_list_add (&sip->authentication_infos, authentication_info, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_authentication_info_parse": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "int\nosip_authentication_info_parse (osip_authentication_info_t * ainfo, const char *hvalue)\n{\n\tconst char *space, *hack;\n  const char *next = NULL;\n  int i;\n\n  space = strchr (hvalue, ' ');\n  hack = strchr( hvalue, '=');\n  if(space && hack && hack > space) {\n\t  ainfo->auth_type = (char *) osip_malloc (space - hvalue + 1);\n\t  if (ainfo->auth_type==NULL)\n\t\t  return OSIP_NOMEM;\n\t  osip_strncpy (ainfo->auth_type, hvalue, space - hvalue);\n  }\n  else\n    space = hvalue;\n\n  for (;;) {\n    int parse_ok = 0;\n\n    i = __osip_quoted_string_set (\"nextnonce\", space, &(ainfo->nextnonce), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"cnonce\", space, &(ainfo->cnonce), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"rspauth\", space, &(ainfo->rspauth), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_token_set (\"nc\", space, &(ainfo->nonce_count), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_token_set (\"qop\", space, &(ainfo->qop_options), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"snum\", space, &(ainfo->snum), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"srand\", space, &(ainfo->srand), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"targetname\", space, &(ainfo->targetname), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"realm\", space, &(ainfo->realm), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"opaque\", space, &(ainfo->opaque), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    if (0 == parse_ok) {\n      const char *quote1, *quote2, *tmp;\n\n      /* CAUTION */\n      /* parameter not understood!!! I'm too lazy to handle IT */\n      /* let's simply bypass it */\n      if (strlen (space) < 1)\n        return OSIP_SUCCESS;\n      tmp = strchr (space + 1, ',');\n      if (tmp == NULL)          /* it was the last header */\n        return OSIP_SUCCESS;\n      quote1 = __osip_quote_find (space);\n      if ((quote1 != NULL) && (quote1 < tmp)) { /* this may be a quoted string! */\n        quote2 = __osip_quote_find (quote1 + 1);\n        if (quote2 == NULL)\n          return OSIP_SYNTAXERROR;      /* bad header format... */\n        if (tmp < quote2)       /* the comma is inside the quotes! */\n          space = strchr (quote2, ',');\n        else\n          space = tmp;\n        if (space == NULL)      /* it was the last header */\n          return OSIP_SUCCESS;\n      }\n      else\n        space = tmp;\n      /* continue parsing... */\n    }\n  }\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 141,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_authentication_info": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "int\nosip_message_get_authentication_info (const osip_message_t * sip, int pos, osip_authentication_info_t ** dest)\n{\n  osip_authentication_info_t *authentication_info;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->authentication_infos) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n\n  authentication_info = (osip_authentication_info_t *) osip_list_get (&sip->authentication_infos, pos);\n\n  *dest = authentication_info;\n  return pos;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_authentication_info_get_auth_type": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "char *\nosip_authentication_info_get_auth_type (osip_authentication_info_t *authentication_info)\n{\n  return authentication_info->auth_type;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authentication_info_get_auth_type (osip_authentication_info_t *authentication_info)",
        "*"
      ]
    },
    "osip_authentication_info_set_auth_type": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "void\nosip_authentication_info_set_auth_type (osip_authentication_info_t *authentication_info, char *auth_type)\n{\n  authentication_info->auth_type = (char *) auth_type;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_get_nextnonce": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "char *\nosip_authentication_info_get_nextnonce (osip_authentication_info_t * authentication_info)\n{\n  return authentication_info->nextnonce;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authentication_info_get_nextnonce (osip_authentication_info_t * authentication_info)",
        "*"
      ]
    },
    "osip_authentication_info_set_nextnonce": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "void\nosip_authentication_info_set_nextnonce (osip_authentication_info_t * authentication_info, char *nextnonce)\n{\n  authentication_info->nextnonce = (char *) nextnonce;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_get_cnonce": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "char *\nosip_authentication_info_get_cnonce (osip_authentication_info_t * authentication_info)\n{\n  return authentication_info->cnonce;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authentication_info_get_cnonce (osip_authentication_info_t * authentication_info)",
        "*"
      ]
    },
    "osip_authentication_info_set_cnonce": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "void\nosip_authentication_info_set_cnonce (osip_authentication_info_t * authentication_info, char *cnonce)\n{\n  authentication_info->cnonce = (char *) cnonce;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_get_rspauth": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "char *\nosip_authentication_info_get_rspauth (osip_authentication_info_t * authentication_info)\n{\n  return authentication_info->rspauth;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authentication_info_get_rspauth (osip_authentication_info_t * authentication_info)",
        "*"
      ]
    },
    "osip_authentication_info_set_rspauth": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void\nosip_authentication_info_set_rspauth (osip_authentication_info_t * authentication_info, char *rspauth)\n{\n  authentication_info->rspauth = (char *) rspauth;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_get_nonce_count": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "char *\nosip_authentication_info_get_nonce_count (osip_authentication_info_t * authentication_info)\n{\n  return authentication_info->nonce_count;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authentication_info_get_nonce_count (osip_authentication_info_t * authentication_info)",
        "*"
      ]
    },
    "osip_authentication_info_set_nonce_count": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "void\nosip_authentication_info_set_nonce_count (osip_authentication_info_t * authentication_info, char *nonce_count)\n{\n  authentication_info->nonce_count = (char *) nonce_count;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_get_qop_options": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "char *\nosip_authentication_info_get_qop_options (osip_authentication_info_t * authentication_info)\n{\n  return authentication_info->qop_options;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authentication_info_get_qop_options (osip_authentication_info_t * authentication_info)",
        "*"
      ]
    },
    "osip_authentication_info_set_qop_options": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "void\nosip_authentication_info_set_qop_options (osip_authentication_info_t * authentication_info, char *qop_options)\n{\n  authentication_info->qop_options = (char *) qop_options;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_get_snum": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "char *\nosip_authentication_info_get_snum (osip_authentication_info_t *\n\t\t\t\t   authentication_info)\n{\n  return authentication_info->snum;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authentication_info_get_snum (osip_authentication_info_t *\n\t\t\t\t   authentication_info)",
        "*"
      ]
    },
    "osip_authentication_info_set_snum": {
      "start_point": [
        315,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "void\nosip_authentication_info_set_snum (osip_authentication_info_t *\n\t\t\t\t   authentication_info, char *snum)\n{\n  authentication_info->snum = (char *) snum;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_get_srand": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "char *\nosip_authentication_info_get_srand (osip_authentication_info_t *\n\t\t\t\t   authentication_info)\n{\n  return authentication_info->srand;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authentication_info_get_srand (osip_authentication_info_t *\n\t\t\t\t   authentication_info)",
        "*"
      ]
    },
    "osip_authentication_info_set_srand": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "void\nosip_authentication_info_set_srand (osip_authentication_info_t *\n\t\t\t\t   authentication_info, char *srand)\n{\n  authentication_info->srand = (char *) srand;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_get_targetname": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "char *\nosip_authentication_info_get_targetname (osip_authentication_info_t *\n\t\t\t\t   authentication_info)\n{\n  return authentication_info->targetname;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authentication_info_get_targetname (osip_authentication_info_t *\n\t\t\t\t   authentication_info)",
        "*"
      ]
    },
    "osip_authentication_info_set_targetname": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        348,
        1
      ],
      "content": "void\nosip_authentication_info_set_targetname (osip_authentication_info_t *\n\t\t\t\t   authentication_info, char *targetname)\n{\n  authentication_info->targetname = (char *) targetname;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_get_realm": {
      "start_point": [
        350,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "char *\nosip_authentication_info_get_realm (osip_authentication_info_t *\n\t\t\t\t   authentication_info)\n{\n  return authentication_info->realm;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authentication_info_get_realm (osip_authentication_info_t *\n\t\t\t\t   authentication_info)",
        "*"
      ]
    },
    "osip_authentication_info_set_realm": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "void\nosip_authentication_info_set_realm (osip_authentication_info_t *\n\t\t\t\t   authentication_info, char *realm)\n{\n  authentication_info->realm = (char *) realm;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_get_opaque": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "char *\nosip_authentication_info_get_opaque (osip_authentication_info_t *\n\t\t\t\t   authentication_info)\n{\n  return authentication_info->opaque;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authentication_info_get_opaque (osip_authentication_info_t *\n\t\t\t\t   authentication_info)",
        "*"
      ]
    },
    "osip_authentication_info_set_opaque": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "void\nosip_authentication_info_set_opaque (osip_authentication_info_t *\n\t\t\t\t   authentication_info, char *opaque)\n{\n  authentication_info->opaque = (char *) opaque;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_to_str": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        504,
        1
      ],
      "content": "int\nosip_authentication_info_to_str (const osip_authentication_info_t * ainfo, char **dest)\n{\n  size_t len;\n  char *tmp, *start;\n\n  *dest = NULL;\n  if (ainfo == NULL)\n    return OSIP_BADPARAMETER;\n\n  len = 0;\n  if (ainfo->auth_type != NULL)\n    len = len + strlen (ainfo->auth_type) + 1;\n  if (ainfo->nextnonce != NULL)\n    len = len + strlen (ainfo->nextnonce) + 11;\n  if (ainfo->rspauth != NULL)\n    len = len + strlen (ainfo->rspauth) + 10;\n  if (ainfo->cnonce != NULL)\n    len = len + strlen (ainfo->cnonce) + 9;\n  if (ainfo->nonce_count != NULL)\n    len = len + strlen (ainfo->nonce_count) + 5;\n  if (ainfo->qop_options != NULL)\n    len = len + strlen (ainfo->qop_options) + 6;\n  if (ainfo->snum != NULL)\n    len = len + strlen (ainfo->snum) + 7;\n  if (ainfo->srand != NULL)\n    len = len + strlen (ainfo->srand) + 8;\n  if (ainfo->targetname != NULL)\n    len = len + strlen (ainfo->targetname) + 13;\n  if (ainfo->realm != NULL)\n    len = len + strlen (ainfo->realm) + 8;\n  if (ainfo->opaque != NULL)\n    len = len + strlen (ainfo->opaque) + 8;\n\n  if (len == 0)\n    return OSIP_BADPARAMETER;\n\n  tmp = (char *) osip_malloc (len);\n  if (tmp == NULL)\n    return OSIP_NOMEM;\n  *dest = tmp;\n\n  start = tmp;\n  if (ainfo->auth_type != NULL) {\n    tmp = osip_str_append (tmp, ainfo->auth_type);\n    tmp = osip_str_append (tmp, \" \");\n    start = tmp;\n  }\n\n  if (ainfo->qop_options != NULL) {\n    if (tmp != start) {\n      tmp = osip_strn_append (tmp, \", \", 2);\n    }\n    tmp = osip_strn_append (tmp, \"qop=\", 4);\n    tmp = osip_str_append (tmp, ainfo->qop_options);\n  }\n  if (ainfo->nextnonce != NULL) {\n    if (tmp != start) {\n      tmp = osip_strn_append (tmp, \", \", 2);\n    }\n    tmp = osip_strn_append (tmp, \"nextnonce=\", 10);\n    tmp = osip_str_append (tmp, ainfo->nextnonce);\n  }\n  if (ainfo->rspauth != NULL) {\n    if (tmp != start) {\n      tmp = osip_strn_append (tmp, \", \", 2);\n    }\n    tmp = osip_strn_append (tmp, \"rspauth=\", 8);\n    tmp = osip_str_append (tmp, ainfo->rspauth);\n  }\n  if (ainfo->cnonce != NULL) {\n    if (tmp != start) {\n      tmp = osip_strn_append (tmp, \", \", 2);\n    }\n    tmp = osip_strn_append (tmp, \"cnonce=\", 7);\n    tmp = osip_str_append (tmp, ainfo->cnonce);\n  }\n  if (ainfo->nonce_count != NULL) {\n    if (tmp != start) {\n      tmp = osip_strn_append (tmp, \", \", 2);\n    }\n    tmp = osip_strn_append (tmp, \"nc=\", 3);\n    tmp = osip_str_append (tmp, ainfo->nonce_count);\n  }\n\n\n  if (ainfo->snum != NULL) {\n    if (tmp != start) {\n      tmp = osip_strn_append (tmp, \", \", 2);\n    }\n    tmp = osip_strn_append (tmp, \"snum=\", 5);\n    tmp = osip_str_append (tmp, ainfo->snum);\n  }\n  if (ainfo->srand != NULL) {\n    if (tmp != start) {\n      tmp = osip_strn_append (tmp, \", \", 2);\n    }\n    tmp = osip_strn_append (tmp, \"srand=\", 6);\n    tmp = osip_str_append (tmp, ainfo->srand);\n    }\n  if (ainfo->targetname != NULL) {\n    if (tmp != start) {\n      tmp = osip_strn_append (tmp, \", \", 2);\n    }\n    tmp = osip_strn_append (tmp, \"targetname=\", 11);\n    tmp = osip_str_append (tmp, ainfo->targetname);\n  }\n  if (ainfo->realm != NULL) {\n    if (tmp != start) {\n      tmp = osip_strn_append (tmp, \", \", 2);\n    }\n    tmp = osip_strn_append (tmp, \"realm=\", 6);\n    tmp = osip_str_append (tmp, ainfo->realm);\n  }\n  if (ainfo->opaque != NULL) {\n    if (tmp != start) {\n      tmp = osip_strn_append (tmp, \", \", 2);\n    }\n    tmp = osip_strn_append (tmp, \"opaque=\", 7);\n    tmp = osip_str_append (tmp, ainfo->opaque);\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 123,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_authentication_info_free": {
      "start_point": [
        508,
        0
      ],
      "end_point": [
        526,
        1
      ],
      "content": "void\nosip_authentication_info_free (osip_authentication_info_t * authentication_info)\n{\n  if (authentication_info == NULL)\n    return;\n\n  osip_free (authentication_info->auth_type);\n  osip_free (authentication_info->nextnonce);\n  osip_free (authentication_info->rspauth);\n  osip_free (authentication_info->cnonce);\n  osip_free (authentication_info->nonce_count);\n  osip_free (authentication_info->qop_options);\n  osip_free (authentication_info->snum);\n  osip_free (authentication_info->srand);\n  osip_free (authentication_info->targetname);\n  osip_free (authentication_info->realm);\n  osip_free (authentication_info->opaque);\n  osip_free (authentication_info);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "osip_authentication_info_clone": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        566,
        1
      ],
      "content": "int\nosip_authentication_info_clone (const osip_authentication_info_t * ainfo, osip_authentication_info_t ** dest)\n{\n  int i;\n  osip_authentication_info_t *wa;\n\n  *dest = NULL;\n  if (ainfo == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_authentication_info_init (&wa);\n  if (i != 0)                   /* allocation failed */\n    return i;\n  if (ainfo->auth_type != NULL)\n    wa->auth_type = osip_strdup (ainfo->auth_type);\n  if (ainfo->nextnonce != NULL)\n    wa->nextnonce = osip_strdup (ainfo->nextnonce);\n  if (ainfo->cnonce != NULL)\n    wa->cnonce = osip_strdup (ainfo->cnonce);\n  if (ainfo->rspauth != NULL)\n    wa->rspauth = osip_strdup (ainfo->rspauth);\n  if (ainfo->nonce_count != NULL)\n    wa->nonce_count = osip_strdup (ainfo->nonce_count);\n  if (ainfo->qop_options != NULL)\n    wa->qop_options = osip_strdup (ainfo->qop_options);\n  if (ainfo->snum != NULL)\n    wa->snum = osip_strdup (ainfo->snum);\n  if (ainfo->srand != NULL)\n    wa->srand = osip_strdup (ainfo->srand);\n  if (ainfo->targetname != NULL)\n    wa->targetname = osip_strdup (ainfo->targetname);\n  if (ainfo->realm != NULL)\n    wa->realm = osip_strdup (ainfo->realm);\n  if (ainfo->opaque != NULL)\n    wa->opaque = osip_strdup (ainfo->opaque);\n\n  *dest = wa;\n  return OSIP_SUCCESS;\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_authorization.c": {
    "osip_authorization_init": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nosip_authorization_init (osip_authorization_t ** dest)\n{\n  *dest = (osip_authorization_t *) osip_malloc (sizeof (osip_authorization_t));\n  if (*dest == NULL)\n    return OSIP_NOMEM;\n  memset (*dest, 0, sizeof (osip_authorization_t));\n  return OSIP_SUCCESS;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_authorization": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nosip_message_set_authorization (osip_message_t * sip, const char *hvalue)\n{\n  osip_authorization_t *authorization;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  if (sip == NULL)\n    return OSIP_BADPARAMETER;\n  i = osip_authorization_init (&authorization);\n  if (i != 0)\n    return i;\n  i = osip_authorization_parse (authorization, hvalue);\n  if (i != 0) {\n    osip_authorization_free (authorization);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->authorizations, authorization, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_authorization_parse": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "int\nosip_authorization_parse (osip_authorization_t * auth, const char *hvalue)\n{\n  const char *space;\n  const char *next = NULL;\n  int i;\n\n  space = strchr (hvalue, ' '); /* SEARCH FOR SPACE */\n  if (space == NULL)\n    return OSIP_SYNTAXERROR;\n\n  if (space - hvalue < 1)\n    return OSIP_SYNTAXERROR;\n  auth->auth_type = (char *) osip_malloc (space - hvalue + 1);\n  if (auth->auth_type == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (auth->auth_type, hvalue, space - hvalue);\n\n  for (;;) {\n    int parse_ok = 0;\n\n    i = __osip_quoted_string_set (\"username\", space, &(auth->username), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"realm\", space, &(auth->realm), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"nonce\", space, &(auth->nonce), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"uri\", space, &(auth->uri), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"response\", space, &(auth->response), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"digest\", space, &(auth->digest), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_token_set (\"algorithm\", space, &(auth->algorithm), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"cnonce\", space, &(auth->cnonce), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"opaque\", space, &(auth->opaque), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_token_set (\"qop\", space, &(auth->message_qop), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_token_set (\"nc\", space, &(auth->nonce_count), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_token_set (\"version\", space, &(auth->version), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space) {\n        space = next;\n        parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"targetname\", space, &(auth->targetname), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space) {\n        space = next;\n        parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"gssapi-data\", space, &(auth->gssapi_data), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space) {\n        space = next;\n        parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"crand\", space, &(auth->crand), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space) {\n        space = next;\n        parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"cnum\", space, &(auth->cnum), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space) {\n        space = next;\n        parse_ok++;\n    }\n    /* nothing was recognized:\n       here, we should handle a list of unknown tokens where:\n       token1 = ( token2 | quoted_text ) */\n    /* TODO */\n\n    if (0 == parse_ok) {\n      const char *quote1, *quote2, *tmp;\n\n      /* CAUTION */\n      /* parameter not understood!!! I'm too lazy to handle IT */\n      /* let's simply bypass it */\n      if (strlen (space) < 1)\n        return OSIP_SUCCESS;\n      tmp = strchr (space + 1, ',');\n      if (tmp == NULL)          /* it was the last header */\n        return OSIP_SUCCESS;\n      quote1 = __osip_quote_find (space);\n      if ((quote1 != NULL) && (quote1 < tmp)) { /* this may be a quoted string! */\n        quote2 = __osip_quote_find (quote1 + 1);\n        if (quote2 == NULL)\n          return OSIP_SYNTAXERROR;      /* bad header format... */\n        if (tmp < quote2)       /* the comma is inside the quotes! */\n          space = strchr (quote2, ',');\n        else\n          space = tmp;\n        if (space == NULL)      /* it was the last header */\n          return OSIP_SUCCESS;\n      }\n      else\n        space = tmp;\n      /* continue parsing... */\n    }\n  }\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 200,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_authorization": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "int\nosip_message_get_authorization (const osip_message_t * sip, int pos, osip_authorization_t ** dest)\n{\n  osip_authorization_t *authorization;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->authorizations) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  authorization = (osip_authorization_t *) osip_list_get (&sip->authorizations, pos);\n  *dest = authorization;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_authorization_get_auth_type": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "char *\nosip_authorization_get_auth_type (const osip_authorization_t * authorization)\n{\n  return authorization->auth_type;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_auth_type (const osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_auth_type": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "void\nosip_authorization_set_auth_type (osip_authorization_t * authorization, char *auth_type)\n{\n  authorization->auth_type = (char *) auth_type;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_username": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "char *\nosip_authorization_get_username (osip_authorization_t * authorization)\n{\n  return authorization->username;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_username (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_username": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "void\nosip_authorization_set_username (osip_authorization_t * authorization, char *username)\n{\n  authorization->username = (char *) username;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_realm": {
      "start_point": [
        315,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "char *\nosip_authorization_get_realm (osip_authorization_t * authorization)\n{\n  return authorization->realm;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_realm (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_realm": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "void\nosip_authorization_set_realm (osip_authorization_t * authorization, char *realm)\n{\n  authorization->realm = (char *) realm;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_nonce": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "char *\nosip_authorization_get_nonce (osip_authorization_t * authorization)\n{\n  return authorization->nonce;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_nonce (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_nonce": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "void\nosip_authorization_set_nonce (osip_authorization_t * authorization, char *nonce)\n{\n  authorization->nonce = (char *) nonce;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_uri": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "char *\nosip_authorization_get_uri (osip_authorization_t * authorization)\n{\n  return authorization->uri;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_uri (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_uri": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "void\nosip_authorization_set_uri (osip_authorization_t * authorization, char *uri)\n{\n  authorization->uri = (char *) uri;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_response": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "char *\nosip_authorization_get_response (osip_authorization_t * authorization)\n{\n  return authorization->response;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_response (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_response": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "void\nosip_authorization_set_response (osip_authorization_t * authorization, char *response)\n{\n  authorization->response = (char *) response;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_digest": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "char *\nosip_authorization_get_digest (osip_authorization_t * authorization)\n{\n  return authorization->digest;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_digest (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_digest": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "void\nosip_authorization_set_digest (osip_authorization_t * authorization, char *digest)\n{\n  authorization->digest = (char *) digest;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_algorithm": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "char *\nosip_authorization_get_algorithm (osip_authorization_t * authorization)\n{\n  return authorization->algorithm;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_algorithm (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_algorithm": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "void\nosip_authorization_set_algorithm (osip_authorization_t * authorization, char *algorithm)\n{\n  authorization->algorithm = (char *) algorithm;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_cnonce": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        391,
        1
      ],
      "content": "char *\nosip_authorization_get_cnonce (osip_authorization_t * authorization)\n{\n  return authorization->cnonce;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_cnonce (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_cnonce": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\nosip_authorization_set_cnonce (osip_authorization_t * authorization, char *cnonce)\n{\n  authorization->cnonce = (char *) cnonce;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_opaque": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "char *\nosip_authorization_get_opaque (osip_authorization_t * authorization)\n{\n  return authorization->opaque;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_opaque (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_opaque": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "void\nosip_authorization_set_opaque (osip_authorization_t * authorization, char *opaque)\n{\n  authorization->opaque = (char *) opaque;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_message_qop": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "char *\nosip_authorization_get_message_qop (osip_authorization_t * authorization)\n{\n  return authorization->message_qop;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_message_qop (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_message_qop": {
      "start_point": [
        417,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "void\nosip_authorization_set_message_qop (osip_authorization_t * authorization, char *message_qop)\n{\n  authorization->message_qop = (char *) message_qop;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_nonce_count": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "char *\nosip_authorization_get_nonce_count (osip_authorization_t * authorization)\n{\n  return authorization->nonce_count;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_nonce_count (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_nonce_count": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "void\nosip_authorization_set_nonce_count (osip_authorization_t * authorization, char *nonce_count)\n{\n  authorization->nonce_count = (char *) nonce_count;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_version": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "char *\nosip_authorization_get_version (osip_authorization_t * authorization)\n{\n  return authorization->version;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_version (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_version": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        446,
        1
      ],
      "content": "void\nosip_authorization_set_version (osip_authorization_t * authorization,\n\t\t\t\tchar *version)\n{\n  authorization->version = (char *) version;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_targetname": {
      "start_point": [
        448,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "char *\nosip_authorization_get_targetname (osip_authorization_t * authorization)\n{\n  return authorization->targetname;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_targetname (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_targetname": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "void\nosip_authorization_set_targetname (osip_authorization_t * authorization,\n\t\t\t\t   char *targetname)\n{\n  authorization->targetname = (char *) targetname;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_gssapi_data": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "char *\nosip_authorization_get_gssapi_data (osip_authorization_t * authorization)\n{\n  return authorization->gssapi_data;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_gssapi_data (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_gssapi_data": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "void\nosip_authorization_set_gssapi_data (osip_authorization_t * authorization,\n                                    char *gssapi_data)\n{\n  authorization->gssapi_data = (char *) gssapi_data;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_crand": {
      "start_point": [
        474,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "char *\nosip_authorization_get_crand (osip_authorization_t * authorization)\n{\n  return authorization->crand;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_crand (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_crand": {
      "start_point": [
        480,
        0
      ],
      "end_point": [
        485,
        1
      ],
      "content": "void\nosip_authorization_set_crand (osip_authorization_t * authorization,\n\t\t\t      char *crand)\n{\n  authorization->crand = (char *) crand;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_get_cnum": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "char *\nosip_authorization_get_cnum (osip_authorization_t * authorization)\n{\n  return authorization->cnum;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_authorization_get_cnum (osip_authorization_t * authorization)",
        "*"
      ]
    },
    "osip_authorization_set_cnum": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        498,
        1
      ],
      "content": "void\nosip_authorization_set_cnum (osip_authorization_t * authorization,\n\t\t\t     char *cnum)\n{\n  authorization->cnum = (char *) cnum;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_to_str": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        689,
        1
      ],
      "content": "int\nosip_authorization_to_str (const osip_authorization_t * auth, char **dest)\n{\n  size_t len;\n  char *tmp;\n  int first = 1;\n\n  *dest = NULL;\n  /* DO NOT REALLY KNOW THE LIST OF MANDATORY PARAMETER: Please HELP! */\n#if 0\n  if ((auth == NULL) || (auth->auth_type == NULL) || (auth->realm == NULL)\n      || (auth->nonce == NULL))\n    return OSIP_BADPARAMETER;\n#else\n  /* IMS requirement: send authorization like in:\n     Digest uri=\"sip:sip.antisip.com\", username=\"joe\", response=\"\"\n   */\n  if ((auth == NULL) || (auth->auth_type == NULL))\n    return OSIP_BADPARAMETER;\n#endif\n\n  len = strlen (auth->auth_type) + 1;\n  if (auth->username != NULL)\n    len = len + 10 + strlen (auth->username);\n  if (auth->realm != NULL)\n    len = len + 8 + strlen (auth->realm);\n  if (auth->nonce != NULL)\n    len = len + 8 + strlen (auth->nonce);\n  if (auth->uri != NULL)\n    len = len + 6 + strlen (auth->uri);\n  if (auth->response != NULL)\n    len = len + 11 + strlen (auth->response);\n  len = len + 2;\n  if (auth->digest != NULL)\n    len = len + strlen (auth->digest) + 9;\n  if (auth->algorithm != NULL)\n    len = len + strlen (auth->algorithm) + 12;\n  if (auth->cnonce != NULL)\n    len = len + strlen (auth->cnonce) + 9;\n  if (auth->opaque != NULL)\n    len = len + 9 + strlen (auth->opaque);\n  if (auth->nonce_count != NULL)\n    len = len + strlen (auth->nonce_count) + 5;\n  if (auth->message_qop != NULL)\n    len = len + strlen (auth->message_qop) + 6;\n  if (auth->version != NULL)\n    len = len + strlen (auth->version) + 10;\n  if (auth->targetname != NULL)\n    len = len + strlen (auth->targetname) + 13;\n  if (auth->gssapi_data != NULL)\n    len = len + strlen (auth->gssapi_data) + 14;\n  if (auth->crand != NULL)\n    len = len + strlen (auth->crand) + 8;\n  if (auth->cnum != NULL)\n    len = len + strlen (auth->cnum) + 7;\n\n  tmp = (char *) osip_malloc (len);\n  if (tmp == NULL)\n    return OSIP_NOMEM;\n  *dest = tmp;\n\n  tmp = osip_str_append (tmp, auth->auth_type);\n\n  if (auth->username != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" username=\", 10);\n    /* !! username-value must be a quoted string !! */\n    tmp = osip_str_append (tmp, auth->username);\n  }\n\n  if (auth->realm != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" realm=\", 7);\n    /* !! realm-value must be a quoted string !! */\n    tmp = osip_str_append (tmp, auth->realm);\n  }\n  if (auth->nonce != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" nonce=\", 7);\n    /* !! nonce-value must be a quoted string !! */\n    tmp = osip_str_append (tmp, auth->nonce);\n  }\n\n  if (auth->uri != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" uri=\", 5);\n    /* !! domain-value must be a list of URI in a quoted string !! */\n    tmp = osip_str_append (tmp, auth->uri);\n  }\n  if (auth->response != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" response=\", 10);\n    /* !! domain-value must be a list of URI in a quoted string !! */\n    tmp = osip_str_append (tmp, auth->response);\n  }\n\n  if (auth->digest != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" digest=\", 8);\n    /* !! domain-value must be a list of URI in a quoted string !! */\n    tmp = osip_str_append (tmp, auth->digest);\n  }\n  if (auth->algorithm != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" algorithm=\", 11);\n    tmp = osip_str_append (tmp, auth->algorithm);\n  }\n  if (auth->cnonce != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" cnonce=\", 8);\n    tmp = osip_str_append (tmp, auth->cnonce);\n  }\n  if (auth->opaque != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" opaque=\", 8);\n    tmp = osip_str_append (tmp, auth->opaque);\n  }\n  if (auth->message_qop != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" qop=\", 5);\n    tmp = osip_str_append (tmp, auth->message_qop);\n  }\n  if (auth->nonce_count != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" nc=\", 4);\n    tmp = osip_str_append (tmp, auth->nonce_count);\n  }\n  if (auth->version != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" version=\", 9);\n    tmp = osip_str_append (tmp, auth->version);\n  }\n  if (auth->targetname != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" targetname=\", 12);\n    tmp = osip_str_append (tmp, auth->targetname);\n  }\n  if (auth->gssapi_data != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" gssapi-data=\", 13);\n    tmp = osip_str_append (tmp, auth->gssapi_data);\n  }\n  if (auth->crand != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" crand=\", 7);\n    tmp = osip_str_append (tmp, auth->crand);\n  }\n  if (auth->cnum != NULL) {\n    if(!first)\n      tmp = osip_strn_append (tmp, \",\", 1);\n    first = 0;\n    tmp = osip_strn_append (tmp, \" cnum=\", 6);\n    tmp = osip_str_append (tmp, auth->cnum);\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 186,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_authorization_free": {
      "start_point": [
        693,
        0
      ],
      "end_point": [
        716,
        1
      ],
      "content": "void\nosip_authorization_free (osip_authorization_t * authorization)\n{\n  if (authorization == NULL)\n    return;\n  osip_free (authorization->auth_type);\n  osip_free (authorization->username);\n  osip_free (authorization->realm);\n  osip_free (authorization->nonce);\n  osip_free (authorization->uri);\n  osip_free (authorization->response);\n  osip_free (authorization->digest);\n  osip_free (authorization->algorithm);\n  osip_free (authorization->cnonce);\n  osip_free (authorization->opaque);\n  osip_free (authorization->message_qop);\n  osip_free (authorization->nonce_count);\n  osip_free (authorization->version);\n  osip_free (authorization->targetname);\n  osip_free (authorization->gssapi_data);\n  osip_free (authorization->crand);\n  osip_free (authorization->cnum);\n  osip_free (authorization);\n}",
      "lines": 24,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "osip_authorization_clone": {
      "start_point": [
        718,
        0
      ],
      "end_point": [
        863,
        1
      ],
      "content": "int\nosip_authorization_clone (const osip_authorization_t * auth, osip_authorization_t ** dest)\n{\n  int i;\n  osip_authorization_t *au;\n\n  *dest = NULL;\n  if (auth == NULL)\n    return OSIP_BADPARAMETER;\n  /* to be removed?\n     if (auth->auth_type==NULL) return -1;\n     if (auth->username==NULL) return -1;\n     if (auth->realm==NULL) return -1;\n     if (auth->nonce==NULL) return -1;\n     if (auth->uri==NULL) return -1;\n     if (auth->response==NULL) return -1;\n     if (auth->opaque==NULL) return -1;\n   */\n\n  i = osip_authorization_init (&au);\n  if (i != 0)                   /* allocation failed */\n    return i;\n  if (auth->auth_type != NULL) {\n    au->auth_type = osip_strdup (auth->auth_type);\n    if (au->auth_type == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->username != NULL) {\n    au->username = osip_strdup (auth->username);\n    if (au->username == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->realm != NULL) {\n    au->realm = osip_strdup (auth->realm);\n    if (auth->realm == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->nonce != NULL) {\n    au->nonce = osip_strdup (auth->nonce);\n    if (auth->nonce == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->uri != NULL) {\n    au->uri = osip_strdup (auth->uri);\n    if (au->uri == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->response != NULL) {\n    au->response = osip_strdup (auth->response);\n    if (auth->response == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->digest != NULL) {\n    au->digest = osip_strdup (auth->digest);\n    if (au->digest == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->algorithm != NULL) {\n    au->algorithm = osip_strdup (auth->algorithm);\n    if (auth->algorithm == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->cnonce != NULL) {\n    au->cnonce = osip_strdup (auth->cnonce);\n    if (au->cnonce == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->opaque != NULL) {\n    au->opaque = osip_strdup (auth->opaque);\n    if (auth->opaque == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->message_qop != NULL) {\n    au->message_qop = osip_strdup (auth->message_qop);\n    if (auth->message_qop == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->nonce_count != NULL) {\n    au->nonce_count = osip_strdup (auth->nonce_count);\n    if (auth->nonce_count == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n\n  if (auth->version != NULL) {\n    au->version = osip_strdup (auth->version);\n    if (auth->version == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->targetname != NULL) {\n    au->targetname = osip_strdup (auth->targetname);\n    if (auth->targetname == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->gssapi_data != NULL) {\n    au->gssapi_data = osip_strdup (auth->gssapi_data);\n    if (auth->gssapi_data == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->crand != NULL) {\n    au->crand = osip_strdup (auth->crand);\n    if (auth->crand == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n  if (auth->cnum != NULL) {\n    au->cnum = osip_strdup (auth->cnum);\n    if (auth->cnum == NULL) {\n      osip_authorization_free (au);\n      return OSIP_NOMEM;\n    }\n  }\n\n  *dest = au;\n  return OSIP_SUCCESS;\n}",
      "lines": 146,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_body.c": {
    "osip_body_init": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nosip_body_init (osip_body_t ** body)\n{\n  *body = (osip_body_t *) osip_malloc (sizeof (osip_body_t));\n  if (*body == NULL)\n    return OSIP_NOMEM;\n  (*body)->body = NULL;\n  (*body)->content_type = NULL;\n  (*body)->length = 0;\n\n  (*body)->headers = (osip_list_t *) osip_malloc (sizeof (osip_list_t));\n  if ((*body)->headers == NULL) {\n    osip_free (*body);\n    *body = NULL;\n    return OSIP_NOMEM;\n  }\n  osip_list_init ((*body)->headers);\n  return OSIP_SUCCESS;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_body": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nosip_message_set_body (osip_message_t * sip, const char *buf, size_t length)\n{\n  osip_body_t *body;\n  int i;\n\n  i = osip_body_init (&body);\n  if (i != 0)\n    return i;\n  i = osip_body_parse (body, buf, length);\n  if (i != 0) {\n    osip_body_free (body);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->bodies, body, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_body_clone": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int\nosip_body_clone (const osip_body_t * body, osip_body_t ** dest)\n{\n  int i;\n  osip_body_t *copy;\n\n  if (body == NULL || body->length <= 0)\n    return OSIP_BADPARAMETER;\n\n  i = osip_body_init (&copy);\n  if (i != 0)\n    return i;\n\n\n  copy->body = (char *) osip_malloc (body->length + 2);\n  if (copy->body == NULL) {\n    osip_body_free (copy);\n    return OSIP_NOMEM;\n  }\n  copy->length = body->length;\n  memcpy (copy->body, body->body, body->length);\n  copy->body[body->length] = '\\0';\n\n  if (body->content_type != NULL) {\n    i = osip_content_type_clone (body->content_type, &(copy->content_type));\n    if (i != 0) {\n      osip_body_free (copy);\n      return i;\n    }\n  }\n\n  i = osip_list_clone (body->headers, copy->headers, (int (*)(void *, void **)) &osip_header_clone);\n  if (i != 0) {\n    osip_body_free (copy);\n    return i;\n  }\n\n  *dest = copy;\n  return OSIP_SUCCESS;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_body": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "int\nosip_message_get_body (const osip_message_t * sip, int pos, osip_body_t ** dest)\n{\n  osip_body_t *body;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->bodies) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  body = (osip_body_t *) osip_list_get (&sip->bodies, pos);\n  *dest = body;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_body_set_contenttype": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "int\nosip_body_set_contenttype (osip_body_t * body, const char *hvalue)\n{\n  int i;\n\n  if (body == NULL)\n    return OSIP_BADPARAMETER;\n  if (hvalue == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_content_type_init (&(body->content_type));\n  if (i != 0)\n    return i;\n  i = osip_content_type_parse (body->content_type, hvalue);\n  if (i != 0) {\n    osip_content_type_free (body->content_type);\n    body->content_type = NULL;\n    return i;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_body_set_header": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int\nosip_body_set_header (osip_body_t * body, const char *hname, const char *hvalue)\n{\n  osip_header_t *h;\n  int i;\n\n  if (body == NULL)\n    return OSIP_BADPARAMETER;\n  if (hname == NULL)\n    return OSIP_BADPARAMETER;\n  if (hvalue == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_header_init (&h);\n  if (i != 0)\n    return i;\n\n  h->hname = osip_strdup (hname);\n  if (h->hname == NULL) {\n    osip_header_free (h);\n    return OSIP_NOMEM;\n  }\n  h->hvalue = osip_strdup (hvalue);\n  if (h->hvalue == NULL) {\n    osip_header_free (h);\n    return OSIP_NOMEM;\n  }\n\n  osip_list_add (body->headers, h, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_body_mime": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "int\nosip_message_set_body_mime (osip_message_t * sip, const char *buf, size_t length)\n{\n  osip_body_t *body;\n  int i;\n\n  if (sip == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_body_init (&body);\n  if (i != 0)\n    return i;\n  i = osip_body_parse_mime (body, buf, length);\n  if (i != 0) {\n    osip_body_free (body);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->bodies, body, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_body_parse_header": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static int\nosip_body_parse_header (osip_body_t * body, const char *start_of_osip_body_header, const char **next_body)\n{\n  const char *start_of_line;\n  const char *end_of_line;\n  const char *colon_index;\n  char *hname;\n  char *hvalue;\n  int i;\n\n  *next_body = NULL;\n  start_of_line = start_of_osip_body_header;\n  for (;;) {\n    i = __osip_find_next_crlf (start_of_line, &end_of_line);\n    if (i == -2) {\n    }\n    else if (i != 0)\n      return i;                 /* error case: no end of body found */\n\n    /* find the header name */\n    colon_index = strchr (start_of_line, ':');\n    if (colon_index == NULL)\n      return OSIP_SYNTAXERROR;  /* this is also an error case */\n\n    if (colon_index - start_of_line + 1 < 2)\n      return OSIP_SYNTAXERROR;\n    hname = (char *) osip_malloc (colon_index - start_of_line + 1);\n    if (hname == NULL)\n      return OSIP_NOMEM;\n    osip_clrncpy (hname, start_of_line, colon_index - start_of_line);\n\n    if ((end_of_line - 2) - colon_index < 2) {\n      osip_free (hname);\n      return OSIP_SYNTAXERROR;\n    }\n    hvalue = (char *) osip_malloc ((end_of_line - 2) - colon_index);\n    if (hvalue == NULL) {\n      osip_free (hname);\n      return OSIP_NOMEM;\n    }\n    osip_clrncpy (hvalue, colon_index + 1, (end_of_line - 2) - colon_index - 1);\n\n    /* really store the header in the sip structure */\n    if (osip_strncasecmp (hname, \"content-type\", 12) == 0)\n      i = osip_body_set_contenttype (body, hvalue);\n    else\n      i = osip_body_set_header (body, hname, hvalue);\n    osip_free (hname);\n    osip_free (hvalue);\n    if (i != 0)\n      return i;\n\n    if (strncmp (end_of_line, CRLF, 2) == 0 || strncmp (end_of_line, \"\\n\", 1) == 0 || strncmp (end_of_line, \"\\r\", 1) == 0) {\n      *next_body = end_of_line;\n      return OSIP_SUCCESS;\n    }\n    start_of_line = end_of_line;\n  }\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "osip_body_parse": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "int\nosip_body_parse (osip_body_t * body, const char *start_of_body, size_t length)\n{\n  if (body == NULL)\n    return OSIP_BADPARAMETER;\n  if (start_of_body == NULL)\n    return OSIP_BADPARAMETER;\n  if (body->headers == NULL)\n    return OSIP_BADPARAMETER;\n\n  body->body = (char *) osip_malloc (length + 1);\n  if (body->body == NULL)\n    return OSIP_NOMEM;\n  memcpy (body->body, start_of_body, length);\n  body->body[length] = '\\0';\n  body->length = length;\n  return OSIP_SUCCESS;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_body_parse_mime": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "int\nosip_body_parse_mime (osip_body_t * body, const char *start_of_body, size_t length)\n{\n  const char *end_of_osip_body_header;\n  const char *start_of_osip_body_header;\n  int i;\n\n  if (body == NULL)\n    return OSIP_BADPARAMETER;\n  if (start_of_body == NULL)\n    return OSIP_BADPARAMETER;\n  if (body->headers == NULL)\n    return OSIP_BADPARAMETER;\n\n  start_of_osip_body_header = start_of_body;\n\n  i = osip_body_parse_header (body, start_of_osip_body_header, &end_of_osip_body_header);\n  if (i != 0)\n    return i;\n\n  start_of_osip_body_header = end_of_osip_body_header;\n  /* set the real start of body */\n  if (strncmp (start_of_osip_body_header, CRLF, 2) == 0)\n    start_of_osip_body_header = start_of_osip_body_header + 2;\n  else {\n    if ((strncmp (start_of_osip_body_header, \"\\n\", 1) == 0)\n        || (strncmp (start_of_osip_body_header, \"\\r\", 1) == 0))\n      start_of_osip_body_header = start_of_osip_body_header + 1;\n    else\n      return OSIP_SYNTAXERROR;  /* message does not end with CRLFCRLF, CRCR or LFLF */\n  }\n\n  end_of_osip_body_header = start_of_body + length;\n  if (end_of_osip_body_header - start_of_osip_body_header <= 0)\n    return OSIP_SYNTAXERROR;\n  body->body = (char *) osip_malloc (end_of_osip_body_header - start_of_osip_body_header + 1);\n  if (body->body == NULL)\n    return OSIP_NOMEM;\n  memcpy (body->body, start_of_osip_body_header, end_of_osip_body_header - start_of_osip_body_header);\n  body->length = end_of_osip_body_header - start_of_osip_body_header;\n\n  body->body[body->length] = '\\0';\n\n  return OSIP_SUCCESS;\n\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_body_to_str": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "int\nosip_body_to_str (const osip_body_t * body, char **dest, size_t * str_length)\n{\n  char *tmp_body;\n  char *tmp;\n  char *ptr;\n  int i;\n  size_t length;\n\n  if (dest)\n    *dest = NULL;\n  if (str_length)\n    *str_length = 0;\n  if (body == NULL)\n    return OSIP_BADPARAMETER;\n  if (body->body == NULL)\n    return OSIP_BADPARAMETER;\n  if (body->headers == NULL)\n    return OSIP_BADPARAMETER;\n  if (body->length <= 0)\n    return OSIP_BADPARAMETER;\n\n  length = 15 + body->length + (osip_list_size (body->headers) * 40);\n  tmp_body = (char *) osip_malloc (length);\n  if (tmp_body == NULL)\n    return OSIP_NOMEM;\n  ptr = tmp_body;               /* save the initial address of the string */\n\n  if (body->content_type != NULL) {\n    tmp_body = osip_strn_append (tmp_body, \"content-type: \", 14);\n    i = osip_content_type_to_str (body->content_type, &tmp);\n    if (i != 0) {\n      osip_free (ptr);\n      return i;\n    }\n    if (length < tmp_body - ptr + strlen (tmp) + 4) {\n      size_t len;\n\n      len = tmp_body - ptr;\n      length = length + strlen (tmp) + 4;\n      ptr = osip_realloc (ptr, length);\n      tmp_body = ptr + len;\n    }\n\n    tmp_body = osip_str_append (tmp_body, tmp);\n    osip_free (tmp);\n    tmp_body = osip_strn_append (tmp_body, CRLF, 2);\n  }\n\n  {\n    osip_list_iterator_t it;\n    osip_header_t *header = (osip_header_t *) osip_list_get_first(body->headers, &it);  \n    while (header != OSIP_SUCCESS) {\n      i = osip_header_to_str (header, &tmp);\n      if (i != 0) {\n\tosip_free (ptr);\n\treturn i;\n      }\n      if (length < tmp_body - ptr + strlen (tmp) + 4) {\n\tsize_t len;\n\t\n\tlen = tmp_body - ptr;\n\tlength = length + strlen (tmp) + 4;\n\tptr = osip_realloc (ptr, length);\n\ttmp_body = ptr + len;\n      }\n      tmp_body = osip_str_append (tmp_body, tmp);\n      osip_free (tmp);\n      tmp_body = osip_strn_append (tmp_body, CRLF, 2);\n      header = (osip_header_t *) osip_list_get_next(&it);\n    }\n  }\n  \n  if ((osip_list_size (body->headers) > 0) || (body->content_type != NULL)) {\n    if (length < tmp_body - ptr + 3) {\n      size_t len;\n\n      len = tmp_body - ptr;\n      length = length + 3 + body->length; /* add body->length, to avoid calling realloc often */\n      ptr = osip_realloc (ptr, length);\n      tmp_body = ptr + len;\n    }\n    tmp_body = osip_strn_append (tmp_body, CRLF, 2);\n  }\n  if (length < tmp_body - ptr + body->length + 4) {\n    size_t len;\n\n    len = tmp_body - ptr;\n    length = length + body->length + 4;\n    ptr = osip_realloc (ptr, length);\n    tmp_body = ptr + len;\n  }\n  memcpy (tmp_body, body->body, body->length);\n  tmp_body = tmp_body + body->length;\n\n  /* end of this body */\n  if (str_length != NULL)\n    *str_length = tmp_body - ptr;\n  *dest = ptr;\n  return OSIP_SUCCESS;\n\n}",
      "lines": 102,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_body_free": {
      "start_point": [
        449,
        0
      ],
      "end_point": [
        462,
        1
      ],
      "content": "void\nosip_body_free (osip_body_t * body)\n{\n  if (body == NULL)\n    return;\n  osip_free (body->body);\n  if (body->content_type != NULL) {\n    osip_content_type_free (body->content_type);\n  }\n\n  osip_list_special_free (body->headers, (void (*)(void *)) &osip_header_free);\n  osip_free (body->headers);\n  osip_free (body);\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_call_id.c": {
    "osip_message_set_call_id": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nosip_message_set_call_id (osip_message_t * sip, const char *hvalue)\n{\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  if (sip->call_id != NULL)\n    return OSIP_SYNTAXERROR;\n  i = osip_call_id_init (&(sip->call_id));\n  if (i != 0)\n    return i;\n  sip->message_property = 2;\n  i = osip_call_id_parse (sip->call_id, hvalue);\n  if (i != 0) {\n    osip_call_id_free (sip->call_id);\n    sip->call_id = NULL;\n    return i;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_call_id": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "osip_call_id_t *\nosip_message_get_call_id (const osip_message_t * sip)\n{\n  return sip->call_id;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "osip_call_id_t",
        "*\nosip_message_get_call_id (const osip_message_t * sip)",
        "*"
      ]
    },
    "osip_call_id_init": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nosip_call_id_init (osip_call_id_t ** callid)\n{\n  *callid = (osip_call_id_t *) osip_malloc (sizeof (osip_call_id_t));\n  if (*callid == NULL)\n    return OSIP_NOMEM;\n  (*callid)->number = NULL;\n  (*callid)->host = NULL;\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_call_id_free": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\nosip_call_id_free (osip_call_id_t * callid)\n{\n  if (callid == NULL)\n    return;\n  osip_free (callid->number);\n  osip_free (callid->host);\n\n  callid->number = NULL;\n  callid->host = NULL;\n\n  osip_free (callid);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "osip_call_id_parse": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nosip_call_id_parse (osip_call_id_t * callid, const char *hvalue)\n{\n  const char *host;\n  const char *end;\n\n  callid->number = NULL;\n  callid->host = NULL;\n\n  host = strchr (hvalue, '@');  /* SEARCH FOR '@' */\n  end = hvalue + strlen (hvalue);\n\n  if (host == NULL)\n    host = end;\n  else {\n    if (end - host + 1 < 2)\n      return OSIP_SYNTAXERROR;\n    callid->host = (char *) osip_malloc (end - host);\n    if (callid->host == NULL)\n      return OSIP_NOMEM;\n    osip_clrncpy (callid->host, host + 1, end - host - 1);\n  }\n  if (host - hvalue + 1 < 2)\n    return OSIP_SYNTAXERROR;\n  callid->number = (char *) osip_malloc (host - hvalue + 1);\n  if (callid->number == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (callid->number, hvalue, host - hvalue);\n\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_call_id_to_str": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "int\nosip_call_id_to_str (const osip_call_id_t * callid, char **dest)\n{\n  *dest = NULL;\n  if ((callid == NULL) || (callid->number == NULL))\n    return OSIP_BADPARAMETER;\n\n  if (callid->host == NULL) {\n    *dest = (char *) osip_malloc (strlen (callid->number) + 1);\n    if (*dest == NULL)\n      return OSIP_NOMEM;\n    sprintf (*dest, \"%s\", callid->number);\n  }\n  else {\n    *dest = (char *) osip_malloc (strlen (callid->number) + strlen (callid->host) + 2);\n    if (*dest == NULL)\n      return OSIP_NOMEM;\n    sprintf (*dest, \"%s@%s\", callid->number, callid->host);\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "osip_call_id_get_number": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "char *\nosip_call_id_get_number (osip_call_id_t * callid)\n{\n  if (callid == NULL)\n    return NULL;\n  return callid->number;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_call_id_get_number (osip_call_id_t * callid)",
        "*"
      ]
    },
    "osip_call_id_get_host": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "char *\nosip_call_id_get_host (osip_call_id_t * callid)\n{\n  if (callid == NULL)\n    return NULL;\n  return callid->host;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_call_id_get_host (osip_call_id_t * callid)",
        "*"
      ]
    },
    "osip_call_id_set_number": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\nosip_call_id_set_number (osip_call_id_t * callid, char *number)\n{\n  callid->number = number;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_call_id_set_host": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "void\nosip_call_id_set_host (osip_call_id_t * callid, char *host)\n{\n  callid->host = host;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_call_id_clone": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "int\nosip_call_id_clone (const osip_call_id_t * callid, osip_call_id_t ** dest)\n{\n  int i;\n  osip_call_id_t *ci;\n\n  *dest = NULL;\n  if (callid == NULL)\n    return OSIP_BADPARAMETER;\n  if (callid->number == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_call_id_init (&ci);\n  if (i != 0)                   /* allocation failed */\n    return i;\n  ci->number = osip_strdup (callid->number);\n  if (callid->host != NULL)\n    ci->host = osip_strdup (callid->host);\n\n  *dest = ci;\n  return OSIP_SUCCESS;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_call_id_match": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "int\nosip_call_id_match (osip_call_id_t * callid1, osip_call_id_t * callid2)\n{\n\n  if (callid1 == NULL || callid2 == NULL)\n    return OSIP_BADPARAMETER;\n  if (callid1->number == NULL || callid2->number == NULL)\n    return OSIP_BADPARAMETER;\n\n  if (0 != strcmp (callid1->number, callid2->number))\n    return OSIP_UNDEFINED_ERROR;\n\n  if ((callid1->host == NULL) && (callid2->host == NULL))\n    return OSIP_SUCCESS;\n  if ((callid1->host == NULL) && (callid2->host != NULL))\n    return OSIP_UNDEFINED_ERROR;\n  if ((callid1->host != NULL) && (callid2->host == NULL))\n    return OSIP_UNDEFINED_ERROR;\n  if (0 != strcmp (callid1->host, callid2->host))\n    return OSIP_UNDEFINED_ERROR;\n\n  return OSIP_SUCCESS;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_call_info.c": {
    "osip_message_set_call_info": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nosip_message_set_call_info (osip_message_t * sip, const char *hvalue)\n{\n  osip_call_info_t *call_info;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_call_info_init (&call_info);\n  if (i != 0)\n    return i;\n  i = osip_call_info_parse (call_info, hvalue);\n  if (i != 0) {                 /* allocation failed */\n    osip_call_info_free (call_info);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->call_infos, call_info, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_call_info": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nosip_message_get_call_info (const osip_message_t * sip, int pos, osip_call_info_t ** dest)\n{\n  osip_call_info_t *call_info;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->call_infos) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  call_info = (osip_call_info_t *) osip_list_get (&sip->call_infos, pos);\n  *dest = call_info;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_call_info_init": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nosip_call_info_init (osip_call_info_t ** call_info)\n{\n  *call_info = (osip_call_info_t *) osip_malloc (sizeof (osip_call_info_t));\n  if (*call_info == NULL)\n    return OSIP_NOMEM;\n\n  (*call_info)->element = NULL;\n\n  osip_list_init (&(*call_info)->gen_params);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_call_info_parse": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\nosip_call_info_parse (osip_call_info_t * call_info, const char *hvalue)\n{\n  const char *osip_call_info_params;\n  int i;\n\n  osip_call_info_params = strchr (hvalue, '<');\n  if (osip_call_info_params == NULL)\n    return OSIP_SYNTAXERROR;\n\n  osip_call_info_params = strchr (osip_call_info_params + 1, '>');\n  if (osip_call_info_params == NULL)\n    return OSIP_SYNTAXERROR;\n\n  osip_call_info_params = strchr (osip_call_info_params + 1, ';');\n\n  if (osip_call_info_params != NULL) {\n    i = __osip_generic_param_parseall (&call_info->gen_params, osip_call_info_params);\n    if (i != 0)\n      return i;\n  }\n  else\n    osip_call_info_params = hvalue + strlen (hvalue);\n\n  if (osip_call_info_params - hvalue + 1 < 2)\n    return OSIP_SYNTAXERROR;\n  call_info->element = (char *) osip_malloc (osip_call_info_params - hvalue + 1);\n  if (call_info->element == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (call_info->element, hvalue, osip_call_info_params - hvalue);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_call_info_to_str": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nosip_call_info_to_str (const osip_call_info_t * call_info, char **dest)\n{\n  char *buf;\n  char *tmp;\n  size_t len;\n  size_t plen;\n\n  *dest = NULL;\n  if ((call_info == NULL) || (call_info->element == NULL))\n    return OSIP_BADPARAMETER;\n\n  len = strlen (call_info->element) + 2;\n  buf = (char *) osip_malloc (len);\n  if (buf == NULL)\n    return OSIP_NOMEM;\n  *dest = buf;\n\n  sprintf (buf, \"%s\", call_info->element);\n\n  {\n    osip_list_iterator_t it;\n    osip_generic_param_t *u_param = (osip_generic_param_t*) osip_list_get_first(&call_info->gen_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n      if (u_param->gvalue == NULL)\n        plen = strlen (u_param->gname) + 2;\n      else\n        plen = strlen (u_param->gname) + strlen (u_param->gvalue) + 3;\n      len = len + plen;\n      buf = (char *) osip_realloc (buf, len);\n      tmp = buf;\n      tmp = tmp + strlen (tmp);\n      if (u_param->gvalue == NULL)\n        sprintf (tmp, \";%s\", u_param->gname);\n      else\n        sprintf (tmp, \";%s=%s\", u_param->gname, u_param->gvalue);\n      u_param = (osip_generic_param_t *) osip_list_get_next(&it);\n    }\n  }\n  *dest = buf;\n  return OSIP_SUCCESS;\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_call_info_free": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void\nosip_call_info_free (osip_call_info_t * call_info)\n{\n  if (call_info == NULL)\n    return;\n  osip_free (call_info->element);\n\n  osip_generic_param_freelist (&call_info->gen_params);\n\n  call_info->element = NULL;\n\n  osip_free (call_info);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_call_info_clone": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "int\nosip_call_info_clone (const osip_call_info_t * ctt, osip_call_info_t ** dest)\n{\n  int i;\n  osip_call_info_t *ct;\n\n  *dest = NULL;\n  if (ctt == NULL)\n    return OSIP_BADPARAMETER;\n  if (ctt->element == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_call_info_init (&ct);\n  if (i != 0)                   /* allocation failed */\n    return i;\n  ct->element = osip_strdup (ctt->element);\n  if (ct->element == NULL) {\n    osip_call_info_free (ct);\n    return OSIP_NOMEM;\n  }\n\n  i = osip_list_clone (&ctt->gen_params, &ct->gen_params, (int (*)(void *, void **)) &osip_generic_param_clone);\n  if (i != 0) {\n    osip_call_info_free (ct);\n    return i;\n  }\n  *dest = ct;\n  return OSIP_SUCCESS;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_call_info_get_uri": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "char *\nosip_call_info_get_uri (osip_call_info_t * ae)\n{\n  return ae->element;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_call_info_get_uri (osip_call_info_t * ae)",
        "*"
      ]
    },
    "osip_call_info_set_uri": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "void\nosip_call_info_set_uri (osip_call_info_t * ae, char *uri)\n{\n  ae->element = uri;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_contact.c": {
    "osip_message_set_contact": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nosip_message_set_contact (osip_message_t * sip, const char *hvalue)\n{\n  int i;\n  osip_contact_t *contact;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_contact_init (&contact);\n  if (i != 0)\n    return i;\n  i = osip_contact_parse (contact, hvalue);\n  if (i != 0) {\n    osip_contact_free (contact);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->contacts, contact, -1);\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_contact_parse": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nosip_contact_parse (osip_contact_t * contact, const char *hvalue)\n{\n  if (contact == NULL)\n    return OSIP_BADPARAMETER;\n  if (strncmp (hvalue, \"*\", 1) == 0) {\n    contact->displayname = osip_strdup (hvalue);\n    if (contact->displayname == NULL) {\n      return OSIP_NOMEM;\n    }\n    return OSIP_SUCCESS;\n  }\n  return osip_from_parse ((osip_from_t *) contact, hvalue);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_contact_init": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\nosip_contact_init (osip_contact_t ** contact)\n{\n  return osip_from_init ((osip_from_t **) contact);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_contact": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nosip_message_get_contact (const osip_message_t * sip, int pos, osip_contact_t ** dest)\n{\n  *dest = NULL;\n  if (sip == NULL)\n    return OSIP_BADPARAMETER;\n  if (osip_list_size (&sip->contacts) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  *dest = (osip_contact_t *) osip_list_get (&sip->contacts, pos);\n  return pos;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_contact_to_str": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nosip_contact_to_str (const osip_contact_t * contact, char **dest)\n{\n  if (contact == NULL)\n    return OSIP_BADPARAMETER;\n  if (contact->displayname != NULL) {\n    if (strncmp (contact->displayname, \"*\", 1) == 0) {\n      *dest = osip_strdup (\"*\");\n      if (*dest == NULL)\n        return OSIP_NOMEM;\n      return OSIP_SUCCESS;\n    }\n  }\n  return osip_from_to_str ((osip_from_t *) contact, dest);\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_contact_free": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\nosip_contact_free (osip_contact_t * contact)\n{\n  osip_from_free ((osip_from_t *) contact);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "osip_contact_clone": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\nosip_contact_clone (const osip_contact_t * contact, osip_contact_t ** dest)\n{\n  return osip_from_clone ((osip_from_t *) contact, (osip_from_t **) dest);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_content_disposition.c": {
    "osip_content_disposition_parse": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nosip_content_disposition_parse (osip_content_disposition_t * cd, const char *hvalue)\n{\n  const char *cd_params;\n  int i;\n\n  cd_params = strchr (hvalue, ';');\n\n  if (cd_params != NULL) {\n    i = __osip_generic_param_parseall (&cd->gen_params, cd_params);\n    if (i != 0)\n      return i;\n  }\n  else\n    cd_params = hvalue + strlen (hvalue);\n\n  if (cd_params - hvalue + 1 < 2)\n    return OSIP_SYNTAXERROR;\n  cd->element = (char *) osip_malloc (cd_params - hvalue + 1);\n  if (cd->element == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (cd->element, hvalue, cd_params - hvalue);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_content_encoding.c": {
    "osip_message_set_content_encoding": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nosip_message_set_content_encoding (osip_message_t * sip, const char *hvalue)\n{\n  osip_content_encoding_t *content_encoding;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_content_encoding_init (&content_encoding);\n  if (i != 0)\n    return i;\n  i = osip_content_encoding_parse (content_encoding, hvalue);\n  if (i != 0) {\n    osip_content_encoding_free (content_encoding);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->content_encodings, content_encoding, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_content_encoding": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nosip_message_get_content_encoding (const osip_message_t * sip, int pos, osip_content_encoding_t ** dest)\n{\n  osip_content_encoding_t *ce;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->content_encodings) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  ce = (osip_content_encoding_t *) osip_list_get (&sip->content_encodings, pos);\n  *dest = ce;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_content_length.c": {
    "osip_content_length_init": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nosip_content_length_init (osip_content_length_t ** cl)\n{\n  *cl = (osip_content_length_t *) osip_malloc (sizeof (osip_content_length_t));\n  if (*cl == NULL)\n    return OSIP_NOMEM;\n  (*cl)->value = NULL;\n  return OSIP_SUCCESS;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_content_length": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nosip_message_set_content_length (osip_message_t * sip, const char *hvalue)\n{\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  if (sip->content_length != NULL)\n    return OSIP_SYNTAXERROR;\n  i = osip_content_length_init (&(sip->content_length));\n  if (i != 0)\n    return i;\n  sip->message_property = 2;\n  i = osip_content_length_parse (sip->content_length, hvalue);\n  if (i != 0) {\n    osip_content_length_free (sip->content_length);\n    sip->content_length = NULL;\n    return i;\n  }\n\n  return OSIP_SUCCESS;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_content_length_parse": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nosip_content_length_parse (osip_content_length_t * content_length, const char *hvalue)\n{\n  size_t len;\n\n  if (hvalue == NULL)\n    return OSIP_BADPARAMETER;\n  len = strlen (hvalue);\n  if (len + 1 < 2)\n    return OSIP_SYNTAXERROR;\n  content_length->value = (char *) osip_malloc (len + 1);\n  if (content_length->value == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (content_length->value, hvalue, len);\n  return OSIP_SUCCESS;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_content_length": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "osip_content_length_t *\nosip_message_get_content_length (const osip_message_t * sip)\n{\n  return sip->content_length;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "osip_content_length_t",
        "*\nosip_message_get_content_length (const osip_message_t * sip)",
        "*"
      ]
    },
    "osip_content_length_to_str": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nosip_content_length_to_str (const osip_content_length_t * cl, char **dest)\n{\n  if (cl == NULL)\n    return OSIP_BADPARAMETER;\n  *dest = osip_strdup (cl->value);\n  if (*dest == NULL)\n    return OSIP_NOMEM;\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_content_length_free": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void\nosip_content_length_free (osip_content_length_t * content_length)\n{\n  if (content_length == NULL)\n    return;\n  osip_free (content_length->value);\n  osip_free (content_length);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "osip_content_length_clone": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\nosip_content_length_clone (const osip_content_length_t * ctl, osip_content_length_t ** dest)\n{\n  int i;\n  osip_content_length_t *cl;\n\n  *dest = NULL;\n  if (ctl == NULL)\n    return OSIP_BADPARAMETER;\n  /*\n     empty headers are allowed:\n     if (ctl->value==NULL) return -1;\n   */\n  i = osip_content_length_init (&cl);\n  if (i != 0)                   /* allocation failed */\n    return i;\n  if (ctl->value != NULL) {\n    cl->value = osip_strdup (ctl->value);\n    if (cl->value == NULL) {\n      osip_content_length_free (cl);\n      return OSIP_NOMEM;\n    }\n  }\n\n  *dest = cl;\n  return OSIP_SUCCESS;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_content_type.c": {
    "osip_content_type_init": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nosip_content_type_init (osip_content_type_t ** content_type)\n{\n  *content_type = (osip_content_type_t *) osip_malloc (sizeof (osip_content_type_t));\n  if (*content_type == NULL)\n    return OSIP_NOMEM;\n\n  (*content_type)->type = NULL;\n  (*content_type)->subtype = NULL;\n\n  osip_list_init (&(*content_type)->gen_params);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_content_type": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nosip_message_set_content_type (osip_message_t * sip, const char *hvalue)\n{\n  int i;\n\n  if (sip->content_type != NULL)\n    return OSIP_BADPARAMETER;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_content_type_init (&(sip->content_type));\n  if (i != 0)\n    return i;\n  sip->message_property = 2;\n  i = osip_content_type_parse (sip->content_type, hvalue);\n  if (i != 0) {\n    osip_content_type_free (sip->content_type);\n    sip->content_type = NULL;\n    return i;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_content_type": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "osip_content_type_t *\nosip_message_get_content_type (const osip_message_t * sip)\n{\n  return sip->content_type;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "osip_content_type_t",
        "*\nosip_message_get_content_type (const osip_message_t * sip)",
        "*"
      ]
    },
    "osip_content_type_parse": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "int\nosip_content_type_parse (osip_content_type_t * content_type, const char *hvalue)\n{\n  char *subtype;\n  char *osip_content_type_params;\n  int i;\n\n  /* How to parse:\n\n     we'll place the pointers:\n     subtype              =>  beginning of subtype\n     osip_content_type_params  =>  beginning of params\n\n     examples:\n\n     application/multipart ; boundary=\n     ^          ^\n   */\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;        /* It's valid to add empty Accept header! */\n\n  subtype = strchr (hvalue, '/');\n  osip_content_type_params = strchr (hvalue, ';');\n\n  if (subtype == NULL)\n    return OSIP_SYNTAXERROR;    /* do we really mind such an error */\n\n  if (osip_content_type_params != NULL) {\n    i = __osip_generic_param_parseall (&content_type->gen_params, osip_content_type_params);\n    if (i != 0)\n      return i;\n  }\n  else\n    osip_content_type_params = subtype + strlen (subtype);\n\n  if (subtype - hvalue + 1 < 2)\n    return OSIP_SYNTAXERROR;\n  content_type->type = (char *) osip_malloc (subtype - hvalue + 1);\n  if (content_type->type == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (content_type->type, hvalue, subtype - hvalue);\n\n  if (osip_content_type_params - subtype < 2)\n    return OSIP_SYNTAXERROR;\n  content_type->subtype = (char *) osip_malloc (osip_content_type_params - subtype);\n  if (content_type->subtype == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (content_type->subtype, subtype + 1, osip_content_type_params - subtype - 1);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 51,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_content_type_to_str": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int\nosip_content_type_to_str (const osip_content_type_t * content_type, char **dest)\n{\n  char *buf;\n  char *tmp;\n  size_t len;\n\n  *dest = NULL;\n  if ((content_type == NULL) || (content_type->type == NULL)\n      || (content_type->subtype == NULL))\n    return OSIP_BADPARAMETER;\n\n  /* try to guess a long enough length */\n  len = strlen (content_type->type) + strlen (content_type->subtype) + 4        /* for '/', ' ', ';' and '\\0' */\n    + 10 * osip_list_size (&content_type->gen_params);\n\n  buf = (char *) osip_malloc (len);\n  if (buf == NULL)\n    return OSIP_NOMEM;\n  tmp = buf;\n\n  sprintf (tmp, \"%s/%s\", content_type->type, content_type->subtype);\n\n  tmp = tmp + strlen (tmp);\n  {\n    osip_list_iterator_t it;\n    osip_generic_param_t *u_param = (osip_generic_param_t*) osip_list_get_first(&content_type->gen_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n      size_t tmp_len;\n      if (u_param->gvalue == NULL) {\n        osip_free (buf);\n        return OSIP_SYNTAXERROR;\n      }\n      tmp_len = strlen (buf) + 4 + strlen (u_param->gname)\n        + strlen (u_param->gvalue) + 1;\n      if (len < tmp_len) {\n        buf = osip_realloc (buf, tmp_len);\n        len = tmp_len;\n        tmp = buf + strlen (buf);\n      }\n      snprintf (tmp, len - (tmp - buf), \"; %s=%s\", u_param->gname, u_param->gvalue);\n      tmp = tmp + strlen (tmp);\n      u_param = (osip_generic_param_t *) osip_list_get_next(&it);\n    }\n  }\n  *dest = buf;\n  return OSIP_SUCCESS;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_content_type_free": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "void\nosip_content_type_free (osip_content_type_t * content_type)\n{\n  if (content_type == NULL)\n    return;\n  osip_free (content_type->type);\n  osip_free (content_type->subtype);\n\n  osip_generic_param_freelist (&content_type->gen_params);\n\n  content_type->type = NULL;\n  content_type->subtype = NULL;\n\n  osip_free (content_type);\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_content_type_clone": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "int\nosip_content_type_clone (const osip_content_type_t * ctt, osip_content_type_t ** dest)\n{\n  int i;\n  osip_content_type_t *ct;\n\n  *dest = NULL;\n  if (ctt == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_content_type_init (&ct);\n  if (i != 0)                   /* allocation failed */\n    return i;\n  if (ctt->type != NULL)\n    ct->type = osip_strdup (ctt->type);\n  if (ctt->subtype != NULL)\n    ct->subtype = osip_strdup (ctt->subtype);\n\n  {\n    osip_generic_param_t *dest_param;\n    osip_list_iterator_t it;\n    osip_generic_param_t *u_param = (osip_generic_param_t*) osip_list_get_first(&ctt->gen_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n      i = osip_generic_param_clone (u_param, &dest_param);\n      if (i != 0) {\n        osip_content_type_free (ct);\n        return i;\n      }\n      osip_list_add (&ct->gen_params, dest_param, -1);\n      u_param = (osip_generic_param_t *) osip_list_get_next(&it);\n    }\n  }\n  *dest = ct;\n  return OSIP_SUCCESS;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_cseq.c": {
    "osip_cseq_init": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nosip_cseq_init (osip_cseq_t ** cseq)\n{\n  *cseq = (osip_cseq_t *) osip_malloc (sizeof (osip_cseq_t));\n  if (*cseq == NULL)\n    return OSIP_NOMEM;\n  (*cseq)->method = NULL;\n  (*cseq)->number = NULL;\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_cseq": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nosip_message_set_cseq (osip_message_t * sip, const char *hvalue)\n{\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  if (sip->cseq != NULL)\n    return OSIP_BADPARAMETER;\n  i = osip_cseq_init (&(sip->cseq));\n  if (i != 0)\n    return i;\n  sip->message_property = 2;\n  i = osip_cseq_parse (sip->cseq, hvalue);\n  if (i != 0) {\n    osip_cseq_free (sip->cseq);\n    sip->cseq = NULL;\n    return i;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_cseq_parse": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\nosip_cseq_parse (osip_cseq_t * cseq, const char *hvalue)\n{\n  char *method = NULL;\n  const char *end = NULL;\n\n  if (cseq == NULL || hvalue == NULL)\n    return OSIP_BADPARAMETER;\n\n  cseq->number = NULL;\n  cseq->method = NULL;\n\n  method = strchr (hvalue, ' ');        /* SEARCH FOR SPACE */\n  if (method == NULL)\n    return OSIP_SYNTAXERROR;\n\n  end = hvalue + strlen (hvalue);\n\n  if (method - hvalue + 1 < 2)\n    return OSIP_SYNTAXERROR;\n  cseq->number = (char *) osip_malloc (method - hvalue + 1);\n  if (cseq->number == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (cseq->number, hvalue, method - hvalue);\n\n  if (end - method + 1 < 2)\n    return OSIP_SYNTAXERROR;\n  cseq->method = (char *) osip_malloc (end - method + 1);\n  if (cseq->method == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (cseq->method, method + 1, end - method);\n\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_cseq": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "osip_cseq_t *\nosip_message_get_cseq (const osip_message_t * sip)\n{\n  return sip->cseq;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "osip_cseq_t",
        "*\nosip_message_get_cseq (const osip_message_t * sip)",
        "*"
      ]
    },
    "osip_cseq_get_number": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "char *\nosip_cseq_get_number (osip_cseq_t * cseq)\n{\n  return cseq->number;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_cseq_get_number (osip_cseq_t * cseq)",
        "*"
      ]
    },
    "osip_cseq_get_method": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "char *\nosip_cseq_get_method (osip_cseq_t * cseq)\n{\n  return cseq->method;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_cseq_get_method (osip_cseq_t * cseq)",
        "*"
      ]
    },
    "osip_cseq_set_number": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\nosip_cseq_set_number (osip_cseq_t * cseq, char *number)\n{\n  cseq->number = (char *) number;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_cseq_set_method": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\nosip_cseq_set_method (osip_cseq_t * cseq, char *method)\n{\n  cseq->method = (char *) method;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_cseq_to_str": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "int\nosip_cseq_to_str (const osip_cseq_t * cseq, char **dest)\n{\n  size_t len;\n\n  *dest = NULL;\n  if ((cseq == NULL) || (cseq->number == NULL) || (cseq->method == NULL))\n    return OSIP_BADPARAMETER;\n  len = strlen (cseq->method) + strlen (cseq->number) + 2;\n  *dest = (char *) osip_malloc (len);\n  if (*dest == NULL)\n    return OSIP_NOMEM;\n  snprintf (*dest, len, \"%s %s\", cseq->number, cseq->method);\n  return OSIP_SUCCESS;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_cseq_free": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\nosip_cseq_free (osip_cseq_t * cseq)\n{\n  if (cseq == NULL)\n    return;\n  osip_free (cseq->method);\n  osip_free (cseq->number);\n  osip_free (cseq);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "osip_cseq_clone": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "int\nosip_cseq_clone (const osip_cseq_t * cseq, osip_cseq_t ** dest)\n{\n  int i;\n  osip_cseq_t *cs;\n\n  *dest = NULL;\n  if (cseq == NULL)\n    return OSIP_BADPARAMETER;\n  if (cseq->method == NULL)\n    return OSIP_BADPARAMETER;\n  if (cseq->number == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_cseq_init (&cs);\n  if (i != 0) {\n    osip_cseq_free (cs);\n    return i;\n  }\n  cs->method = osip_strdup (cseq->method);\n  cs->number = osip_strdup (cseq->number);\n\n  *dest = cs;\n  return OSIP_SUCCESS;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_cseq_match": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nosip_cseq_match (osip_cseq_t * cseq1, osip_cseq_t * cseq2)\n{\n  if (cseq1 == NULL || cseq2 == NULL)\n    return OSIP_BADPARAMETER;\n  if (cseq1->number == NULL || cseq2->number == NULL || cseq1->method == NULL || cseq2->method == NULL)\n    return OSIP_BADPARAMETER;\n\n  if (0 == strcmp (cseq1->number, cseq2->number)) {\n    if (0 == strcmp (cseq2->method, \"INVITE\")\n        || 0 == strcmp (cseq2->method, \"ACK\")) {\n      if (0 == strcmp (cseq1->method, \"INVITE\") || 0 == strcmp (cseq1->method, \"ACK\"))\n        return OSIP_SUCCESS;\n    }\n    else {\n      if (0 == strcmp (cseq1->method, cseq2->method))\n        return OSIP_SUCCESS;\n    }\n  }\n  return OSIP_UNDEFINED_ERROR;\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_error_info.c": {
    "osip_message_set_error_info": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nosip_message_set_error_info (osip_message_t * sip, const char *hvalue)\n{\n  osip_error_info_t *error_info;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_error_info_init (&error_info);\n  if (i != 0)\n    return i;\n  i = osip_error_info_parse (error_info, hvalue);\n  if (i != 0) {\n    osip_error_info_free (error_info);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->error_infos, error_info, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_error_info": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nosip_message_get_error_info (const osip_message_t * sip, int pos, osip_error_info_t ** dest)\n{\n  osip_error_info_t *error_info;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->error_infos) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  error_info = (osip_error_info_t *) osip_list_get (&sip->error_infos, pos);\n  *dest = error_info;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_from.c": {
    "osip_message_set_from": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nosip_message_set_from (osip_message_t * sip, const char *hvalue)\n{\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  if (sip->from != NULL)\n    return OSIP_SYNTAXERROR;\n  i = osip_from_init (&(sip->from));\n  if (i != 0)\n    return i;\n  sip->message_property = 2;\n  i = osip_from_parse (sip->from, hvalue);\n  if (i != 0) {\n    osip_from_free (sip->from);\n    sip->from = NULL;\n    return i;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_from": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "osip_from_t *\nosip_message_get_from (const osip_message_t * sip)\n{\n  return sip->from;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "osip_from_t",
        "*\nosip_message_get_from (const osip_message_t * sip)",
        "*"
      ]
    },
    "osip_from_init": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nosip_from_init (osip_from_t ** from)\n{\n  *from = (osip_from_t *) osip_malloc (sizeof (osip_from_t));\n  if (*from == NULL)\n    return OSIP_NOMEM;\n  (*from)->displayname = NULL;\n  (*from)->url = NULL;\n\n  osip_list_init (&(*from)->gen_params);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_from_free": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nosip_from_free (osip_from_t * from)\n{\n  if (from == NULL)\n    return;\n  if (from->url != NULL) {\n    osip_uri_free (from->url);\n  }\n  osip_free (from->displayname);\n\n  osip_generic_param_freelist (&from->gen_params);\n\n  osip_free (from);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "osip_from_parse": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\nosip_from_parse (osip_from_t * from, const char *hvalue)\n{\n  const char *displayname=NULL;\n  const char *url=NULL;\n  const char *url_end=NULL;\n  const char *gen_params;\n  const char *ptr;\n  int i;\n\n  if (from == NULL || hvalue == NULL)\n    return OSIP_BADPARAMETER;\n  /* How to parse:\n\n     we'll place the pointers:\n     displayname  =>  beginning of displayname\n     url          =>  beginning of url\n     url_end      =>  end       of url\n     gen_params  =>  beginning of params\n\n     examples:\n\n     jack <sip:amoizard@antisip.com>;tag=34erZ\n     ^     ^                ^ ^\n\n     sip:amoizard@antisip.com;tag=34erZ\n     ^                ^^      \n   */\n  /* search for first char */\n  ptr = hvalue;\n  while (ptr[0]!='\\0') {\n    if (ptr[0]==' ') {\n      ptr++;\n      continue;\n    }\n    if (ptr[0]=='\"') {\n      displayname = ptr;\n      break;\n    }\n    break;\n  }\n\n  if (ptr[0]=='\\0')\n    return OSIP_SUCCESS; /* empty header allowed? */\n\n  if (displayname!=NULL) {\n    /* displayname IS A quoted-string (not a '*token') */\n    const char *second = NULL;\n\n    /* search for quotes */\n    second = __osip_quote_find (displayname + 1);\n    if (second == NULL)\n      return OSIP_SYNTAXERROR;        /* missing quote */\n\n    if (second - displayname + 2 >= 2) {\n      from->displayname = (char *) osip_malloc (second - displayname + 2);\n      if (from->displayname == NULL)\n        return OSIP_NOMEM;\n      osip_strncpy (from->displayname, displayname, second - displayname + 1);\n      /* osip_clrspace(from->displayname); *//*should we do that? */\n\n      /* special case: \"<sip:joe@big.org>\" <sip:joe@really.big.com> */\n    }                         /* else displayname is empty? */\n\n    ptr=second+1;\n    while (ptr[0]!='\\0') {\n      if (ptr[0]==' ') {\n        ptr++;\n        continue;\n      }\n      if (ptr[0]=='<') {\n        url = ptr;\n        break;\n      }\n      break;\n    }\n\n    if (url == NULL)\n      return OSIP_SYNTAXERROR;        /* '<' MUST exist */\n    if (ptr[1] == '\\0')\n      return OSIP_SYNTAXERROR;        /* '<' MUST contain something */\n  } else {\n    /* 1*(alphanum / \"-\" / \".\" / \"!\" / \"%\" / \"*\" / \"_\" / \"+\" / \"`\" / \"'\" / \"~\" ) */\n    /* search for URL -> continue until non allowed element is found */\n    const char *beg=ptr;\n    while (ptr[0]!='\\0') {\n      if (ptr[0]==' ') {\n        ptr++;\n        continue;\n      }\n      if (ptr[0] >= 'a' && ptr[0] <= 'z') {\n        ptr++;\n        continue;\n      }\n      if (ptr[0] >= 'A' && ptr[0] <= 'Z') {\n        ptr++;\n        continue;\n      }\n      if (ptr[0] >= '0' && ptr[0] <= '9') {\n        ptr++;\n        continue;\n      }\n      if (ptr[0]=='-' || ptr[0]=='.' || ptr[0]=='!' || ptr[0]=='%' || ptr[0]=='*' || ptr[0]=='_' || ptr[0]=='+' || ptr[0]=='`' || ptr[0]=='\\'' || ptr[0]=='~') {\n        ptr++;\n        continue;\n      }\n      url = ptr;\n      break;\n    }\n\n    if (ptr[0]=='\\0' || url==NULL)\n      return OSIP_SYNTAXERROR; /* not special char found? broken header? */\n\n    if (ptr[0]=='<') {\n      /* \"<\" found for URI */\n      if (ptr[1] == '\\0')\n        return OSIP_SYNTAXERROR;        /* '<' MUST contain something */\n\n      if (url - beg>0) {\n        from->displayname = (char *) osip_malloc (url - beg + 1);\n        if (from->displayname == NULL)\n          return OSIP_NOMEM;\n        osip_clrncpy (from->displayname, hvalue, url - beg);\n      }\n\n    } else if (ptr[0]==':') {\n      /* this was a scheme for a URL? */\n      url=beg;\n    } else {\n      /* this is some non URL header? */\n      url=beg;\n    }\n  }\n\n  /* define url_end and gen_params for name-addr */\n  if (url[0]=='<') {\n    url++;\n    ptr=url;\n    /* first occurence of \">\" is the end of url */\n    url_end = strchr (ptr, '>');\n    if (url_end==NULL)\n      return OSIP_SYNTAXERROR;\n    url_end--;\n    gen_params = strchr (url_end, ';');\n  }\n\n  /* define url_end and gen_params for addr-spec */\n  if (url_end==NULL) {\n    /* rfc3261 // 20.10 Contact:\n    Even if the \"display-name\" is empty, the \"name-addr\" form MUST be\n    used if the \"addr-spec\" contains a comma, semicolon, or question\n    mark.  There may or may not be LWS between the display-name and the\n    \"<\". \n    Conclusion: there is no semicolon (in username) before the semicolon generic param delimiter... */\n    gen_params = strchr (url, ';');\n    if (gen_params != NULL)\n      url_end = gen_params - 1;\n    else\n      url_end = url + strlen (url);\n  }\n\n  if (gen_params != NULL) {     /* now we are sure a param exist */\n    i = __osip_generic_param_parseall (&from->gen_params, gen_params);\n    if (i != 0) {\n      return i;\n    }\n  }\n\n  /* set the url */\n  {\n    char *tmp;\n\n    if (url_end - url + 2 < 7)\n      return OSIP_SYNTAXERROR;\n    i = osip_uri_init (&(from->url));\n    if (i != 0)\n      return i;\n    tmp = (char *) osip_malloc (url_end - url + 2);\n    if (tmp == NULL)\n      return OSIP_NOMEM;\n    osip_strncpy (tmp, url, url_end - url + 1);\n    i = osip_uri_parse (from->url, tmp);\n    osip_free (tmp);\n    if (i != 0)\n      return i;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 188,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "osip_from_to_str": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "int\nosip_from_to_str (const osip_from_t * from, char **dest)\n{\n  char *url;\n  char *buf;\n  int i;\n  size_t len;\n\n  *dest = NULL;\n  if ((from == NULL) || (from->url == NULL))\n    return OSIP_BADPARAMETER;\n\n  i = osip_uri_to_str (from->url, &url);\n  if (i != 0)\n    return i;\n\n  if (from->displayname == NULL)\n    len = strlen (url) + 5;\n  else\n    len = strlen (url) + strlen (from->displayname) + 5;\n\n  buf = (char *) osip_malloc (len);\n  if (buf == NULL) {\n    osip_free (url);\n    return OSIP_NOMEM;\n  }\n\n  if (from->displayname != NULL)\n    sprintf (buf, \"%s <%s>\", from->displayname, url);\n  else\n    /* from rfc2543bis-04: for authentication related issue!\n       \"The To and From header fields always include the < and >\n       delimiters even if the display-name is empty.\" */\n    sprintf (buf, \"<%s>\", url);\n  osip_free (url);\n\n  {\n    size_t plen;\n    char *tmp;\n    osip_list_iterator_t it;\n    osip_generic_param_t *u_param = (osip_generic_param_t*) osip_list_get_first(&from->gen_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n      if (u_param->gvalue == NULL)\n        plen = strlen (u_param->gname) + 2;\n      else\n        plen = strlen (u_param->gname) + strlen (u_param->gvalue) + 3;\n      len = len + plen;\n      buf = (char *) osip_realloc (buf, len);\n      tmp = buf;\n      tmp = tmp + strlen (tmp);\n      if (u_param->gvalue == NULL)\n        snprintf (tmp, len - (tmp - buf), \";%s\", u_param->gname);\n      else\n        snprintf (tmp, len - (tmp - buf), \";%s=%s\", u_param->gname, u_param->gvalue);\n      u_param = (osip_generic_param_t *) osip_list_get_next(&it);\n    }\n  }\n  *dest = buf;\n  return OSIP_SUCCESS;\n}",
      "lines": 60,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_from_get_displayname": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "char *\nosip_from_get_displayname (osip_from_t * from)\n{\n  if (from == NULL)\n    return NULL;\n  return from->displayname;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_from_get_displayname (osip_from_t * from)",
        "*"
      ]
    },
    "osip_from_set_displayname": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "void\nosip_from_set_displayname (osip_from_t * from, char *displayname)\n{\n  from->displayname = displayname;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_from_get_url": {
      "start_point": [
        368,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "osip_uri_t *\nosip_from_get_url (osip_from_t * from)\n{\n  if (from == NULL)\n    return NULL;\n  return from->url;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "osip_uri_t",
        "*\nosip_from_get_url (osip_from_t * from)",
        "*"
      ]
    },
    "osip_from_set_url": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "void\nosip_from_set_url (osip_from_t * from, osip_uri_t * url)\n{\n  from->url = url;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_from_param_get": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "int\nosip_from_param_get (osip_from_t * from, int pos, osip_generic_param_t ** fparam)\n{\n  *fparam = NULL;\n  if (from == NULL)\n    return OSIP_BADPARAMETER;\n  if (osip_list_size (&from->gen_params) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  *fparam = (osip_generic_param_t *) osip_list_get (&from->gen_params, pos);\n  return pos;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_from_clone": {
      "start_point": [
        394,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "int\nosip_from_clone (const osip_from_t * from, osip_from_t ** dest)\n{\n  int i;\n  osip_from_t *fr;\n\n  *dest = NULL;\n  if (from == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_from_init (&fr);\n  if (i != 0)                   /* allocation failed */\n    return i;\n  if (from->displayname != NULL) {\n    fr->displayname = osip_strdup (from->displayname);\n    if (fr->displayname == NULL) {\n      osip_from_free (fr);\n      return OSIP_NOMEM;\n    }\n  }\n\n  if (from->url != NULL) {\n    i = osip_uri_clone (from->url, &(fr->url));\n    if (i != 0) {\n      osip_from_free (fr);\n      return i;\n    }\n  }\n\n  i = osip_list_clone (&from->gen_params, &fr->gen_params, (int (*)(void *, void **)) &osip_generic_param_clone);\n  if (i != 0) {\n    osip_from_free (fr);\n    return i;\n  }\n  *dest = fr;\n  return OSIP_SUCCESS;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_from_compare": {
      "start_point": [
        432,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "int\nosip_from_compare (osip_from_t * from1, osip_from_t * from2)\n{\n  char *tag1;\n  char *tag2;\n\n  if (from1 == NULL || from2 == NULL)\n    return OSIP_BADPARAMETER;\n  if (from1->url == NULL || from2->url == NULL)\n    return OSIP_BADPARAMETER;\n\n  /* we could have a sip or sips url, but if string!=NULL,\n     host part will be NULL. */\n  if (from1->url->host == NULL && from2->url->host == NULL) {\n    if (from1->url->string == NULL || from2->url->string == NULL)\n      return OSIP_UNDEFINED_ERROR;\n    if (0 == strcmp (from1->url->string, from2->url->string))\n      return OSIP_SUCCESS;\n  }\n  if (from1->url->host == NULL || from2->url->host == NULL)\n    return OSIP_UNDEFINED_ERROR;\n\n  /* compare url including tag */\n  if (0 != strcmp (from1->url->host, from2->url->host))\n    return OSIP_UNDEFINED_ERROR;\n  if (from1->url->username != NULL && from2->url->username != NULL)\n    if (0 != strcmp (from1->url->username, from2->url->username))\n      return OSIP_UNDEFINED_ERROR;\n\n  tag1 = NULL;\n  tag2 = NULL;\n  {\n    osip_list_iterator_t it;\n    osip_generic_param_t *u_param = (osip_generic_param_t*) osip_list_get_first(&from1->gen_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n      if (0 == strncmp (u_param->gname, \"tag\", 3)) {\n        tag1 = u_param->gvalue;\n        break;\n      }\n      u_param = (osip_generic_param_t *) osip_list_get_next(&it);\n    }\n  }\n  {\n    osip_list_iterator_t it;\n    osip_generic_param_t *u_param = (osip_generic_param_t*) osip_list_get_first(&from2->gen_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n      if (0 == strncmp (u_param->gname, \"tag\", 3)) {\n        tag2 = u_param->gvalue;\n        break;\n      }\n      u_param = (osip_generic_param_t *) osip_list_get_next(&it);\n    }\n  }\n\n  /* sounds like a BUG!\n     if tag2 exists and tag1 does not, then it will\n     return OSIP_SUCCESS;\n     in the first request, (INVITE) the To field does not\n     contain any tag. The response contains one! and the\n     response must match the request....\n   */\n  /* so we test the tags only when both exist! */\n  if (tag1 != NULL && tag2 != NULL)\n    if (0 != strcmp (tag1, tag2))\n      return OSIP_UNDEFINED_ERROR;\n\n  /* We could return a special case, when */\n  /* only one tag exists?? */\n\n  return OSIP_SUCCESS;          /* return code changed to 0 from release 0.6.1 */\n}",
      "lines": 71,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "__osip_generic_param_parseall": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        649,
        1
      ],
      "content": "int\n__osip_generic_param_parseall (osip_list_t * gen_params, const char *params)\n{\n  int i;\n  char *pname;\n  char *pvalue;\n\n  const char *comma;\n  const char *equal;\n  const char *startquote;\n  const char *endquote;\n\n  /* find '=' wich is the separator for one param */\n  /* find ';' wich is the separator for multiple params */\n\n  equal = next_separator (params + 1, '=', ';');\n  comma = strchr (params + 1, ';');\n\n  /* If comma points after value start quote, move it to after end quote */\n  if (equal != NULL) {\n    const char *tmp;\n    startquote=NULL;\n    for (tmp=equal+1;tmp[0]==' ';tmp++) {\n    }\n    if (tmp[0]=='\"')\n      startquote = tmp;\n    if (startquote != NULL && comma > startquote) {\n      comma = NULL;\n      endquote = __osip_quote_find(startquote + 1);\n      if (endquote)\n        comma = strchr(endquote, ';');\n    }\n  }\n\n  while (comma != NULL) {\n\n    if (equal == NULL) {\n      equal = comma;\n      pvalue = NULL;\n    }\n    else {\n      const char *tmp;\n\n      /* check for NULL param with an '=' character */\n      tmp = equal + 1;\n      for (; *tmp == '\\t' || *tmp == ' '; tmp++) {\n      }\n      pvalue = NULL;\n      if (*tmp != ',' && *tmp != '\\0') {\n        if (comma - equal < 2)\n          return OSIP_SYNTAXERROR;\n        pvalue = (char *) osip_malloc (comma - equal);\n        if (pvalue == NULL)\n          return OSIP_NOMEM;\n        osip_strncpy (pvalue, equal + 1, comma - equal - 1);\n      }\n    }\n\n    if (equal - params < 2) {\n      osip_free (pvalue);\n      return OSIP_SYNTAXERROR;\n    }\n    pname = (char *) osip_malloc (equal - params);\n    if (pname == NULL) {\n      osip_free (pvalue);\n      return OSIP_NOMEM;\n    }\n    osip_strncpy (pname, params + 1, equal - params - 1);\n\n    i = osip_generic_param_add (gen_params, pname, pvalue);\n    if (i != OSIP_SUCCESS) {\n      osip_free (pname);\n      osip_free (pvalue);\n      return OSIP_NOMEM;\n    }\n\n    params = comma;\n    equal = next_separator (params + 1, '=', ';');\n    comma = strchr (params + 1, ';');\n\n    /* If comma points after value start quote, move it to after end quote */\n    if (equal != NULL) {\n      const char *tmp;\n      startquote=NULL;\n      for (tmp=equal+1;tmp[0]==' ';tmp++) {\n      }\n      if (tmp[0]=='\"')\n        startquote = tmp;\n      if (startquote != NULL && comma > startquote) {\n        comma = NULL;\n        endquote = __osip_quote_find(startquote + 1);\n        if (endquote)\n          comma = strchr(endquote, ';');\n      }\n    }\n  }\n\n  /* this is the last header (comma==NULL) */\n  comma = params + strlen (params);\n\n  if (equal == NULL) {\n    equal = comma;              /* at the end */\n    pvalue = NULL;\n    if (equal - params < 2) {\n      osip_free (pvalue);\n      return OSIP_SUCCESS;      /* empty comma? */\n    }\n  }\n  else {\n    const char *tmp;\n\n    /* check for NULL param with an '=' character */\n    tmp = equal + 1;\n    for (; *tmp == '\\t' || *tmp == ' '; tmp++) {\n    }\n    pvalue = NULL;\n    if (*tmp != ',' && *tmp != '\\0') {\n      if (comma - equal < 2)\n        return OSIP_SYNTAXERROR;\n      pvalue = (char *) osip_malloc (comma - equal);\n      if (pvalue == NULL)\n        return OSIP_NOMEM;\n      osip_strncpy (pvalue, equal + 1, comma - equal - 1);\n    }\n  }\n\n  if (equal - params < 2) {\n    osip_free (pvalue);\n    return OSIP_SYNTAXERROR;\n  }\n  pname = (char *) osip_malloc (equal - params);\n  if (pname == NULL) {\n    osip_free (pvalue);\n    return OSIP_NOMEM;\n  }\n  osip_strncpy (pname, params + 1, equal - params - 1);\n\n  i = osip_generic_param_add (gen_params, pname, pvalue);\n  if (i != OSIP_SUCCESS) {\n    osip_free (pname);\n    osip_free (pvalue);\n    return OSIP_NOMEM;\n  }\n\n  return OSIP_SUCCESS;\n}",
      "lines": 146,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "osip_generic_param_set_value": {
      "start_point": [
        652,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "void\nosip_generic_param_set_value (osip_generic_param_t * fparam, char *value)\n{\n  fparam->gvalue = value;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_generic_param_get_name": {
      "start_point": [
        658,
        0
      ],
      "end_point": [
        664,
        1
      ],
      "content": "char *\nosip_generic_param_get_name (const osip_generic_param_t * fparam)\n{\n  if (fparam == NULL)\n    return NULL;\n  return fparam->gname;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_generic_param_get_name (const osip_generic_param_t * fparam)",
        "*"
      ]
    },
    "osip_generic_param_set_name": {
      "start_point": [
        666,
        0
      ],
      "end_point": [
        670,
        1
      ],
      "content": "void\nosip_generic_param_set_name (osip_generic_param_t * fparam, char *name)\n{\n  fparam->gname = name;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_generic_param_get_value": {
      "start_point": [
        672,
        0
      ],
      "end_point": [
        680,
        1
      ],
      "content": "char *\nosip_generic_param_get_value (const osip_generic_param_t * fparam)\n{\n  if (fparam == NULL)\n    return NULL;\n  if (fparam->gname == NULL)\n    return NULL;                /* name is mandatory */\n  return fparam->gvalue;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_generic_param_get_value (const osip_generic_param_t * fparam)",
        "*"
      ]
    },
    "osip_from_tag_match": {
      "start_point": [
        682,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "int\nosip_from_tag_match (osip_from_t * from1, osip_from_t * from2)\n{\n  osip_generic_param_t *tag_from1;\n  osip_generic_param_t *tag_from2;\n\n  if (from1 == NULL || from2 == NULL)\n    return OSIP_BADPARAMETER;\n\n  osip_from_param_get_byname (from1, \"tag\", &tag_from1);\n  osip_from_param_get_byname (from2, \"tag\", &tag_from2);\n  if (tag_from1 == NULL && tag_from2 == NULL)\n    return OSIP_SUCCESS;\n  if ((tag_from1 != NULL && tag_from2 == NULL)\n      || (tag_from1 == NULL && tag_from2 != NULL))\n    return OSIP_UNDEFINED_ERROR;\n  if (tag_from1->gvalue == NULL || tag_from2->gvalue == NULL)\n    return OSIP_UNDEFINED_ERROR;\n  if (0 != strcmp (tag_from1->gvalue, tag_from2->gvalue))\n    return OSIP_UNDEFINED_ERROR;\n  return OSIP_SUCCESS;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_header.c": {
    "osip_message_set_header": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nosip_message_set_header (osip_message_t * sip, const char *hname, const char *hvalue)\n{\n  osip_header_t *h;\n  int i;\n\n  if (sip == NULL || hname == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_header_init (&h);\n  if (i != 0)\n    return i;\n\n  h->hname = (char *) osip_malloc (strlen (hname) + 1);\n\n  if (h->hname == NULL) {\n    osip_header_free (h);\n    return OSIP_NOMEM;\n  }\n  osip_clrncpy (h->hname, hname, strlen (hname));\n\n  if (hvalue != NULL) {         /* some headers can be null (\"subject:\") */\n    h->hvalue = (char *) osip_malloc (strlen (hvalue) + 1);\n    if (h->hvalue == NULL) {\n      osip_header_free (h);\n      return OSIP_NOMEM;\n    }\n    osip_clrncpy (h->hvalue, hvalue, strlen (hvalue));\n  }\n  else\n    h->hvalue = NULL;\n  sip->message_property = 2;\n  osip_list_add (&sip->headers, h, -1);\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_message_replace_header": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nosip_message_replace_header (osip_message_t * sip, const char *hname, const char *hvalue)\n{\n  osip_header_t *h, *oldh;\n  int i, oldpos = -1;\n\n  if (sip == NULL || hname == NULL)\n    return OSIP_BADPARAMETER;\n\n  oldpos = osip_message_header_get_byname (sip, hname, 0, &oldh);\n\n  i = osip_header_init (&h);\n  if (i != 0)\n    return i;\n\n  h->hname = (char *) osip_malloc (strlen (hname) + 1);\n\n  if (h->hname == NULL) {\n    osip_header_free (h);\n    return OSIP_NOMEM;\n  }\n  osip_clrncpy (h->hname, hname, strlen (hname));\n\n  if (hvalue != NULL) {         /* some headers can be null (\"subject:\") */\n    h->hvalue = (char *) osip_malloc (strlen (hvalue) + 1);\n    if (h->hvalue == NULL) {\n      osip_header_free (h);\n      return OSIP_NOMEM;\n    }\n    osip_clrncpy (h->hvalue, hvalue, strlen (hvalue));\n  }\n  else\n    h->hvalue = NULL;\n\n  if (oldpos != -1) {\n    osip_list_remove (&sip->headers, oldpos);\n    osip_header_free (oldh);\n  }\n\n  sip->message_property = 2;\n  osip_list_add (&sip->headers, h, -1);\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_topheader": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "int\nosip_message_set_topheader (osip_message_t * sip, const char *hname, const char *hvalue)\n{\n  osip_header_t *h;\n  int i;\n\n  if (sip == NULL || hname == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_header_init (&h);\n  if (i != 0)\n    return i;\n\n  h->hname = (char *) osip_malloc (strlen (hname) + 1);\n\n  if (h->hname == NULL) {\n    osip_header_free (h);\n    return OSIP_NOMEM;\n  }\n  osip_clrncpy (h->hname, hname, strlen (hname));\n\n  if (hvalue != NULL) {         /* some headers can be null (\"subject:\") */\n    h->hvalue = (char *) osip_malloc (strlen (hvalue) + 1);\n    if (h->hvalue == NULL) {\n      osip_header_free (h);\n      return OSIP_NOMEM;\n    }\n    osip_clrncpy (h->hvalue, hvalue, strlen (hvalue));\n  }\n  else\n    h->hvalue = NULL;\n  sip->message_property = 2;\n  osip_list_add (&sip->headers, h, 0);\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_header": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\nosip_message_get_header (const osip_message_t * sip, int pos, osip_header_t ** dest)\n{\n  *dest = NULL;\n  if (osip_list_size (&sip->headers) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* NULL */\n  *dest = (osip_header_t *) osip_list_get (&sip->headers, pos);\n  return pos;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_header_get_byname": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "int\nosip_message_header_get_byname (const osip_message_t * sip, const char *hname, int pos, osip_header_t ** dest)\n{\n  int i;\n  osip_header_t *tmp;\n\n  *dest = NULL;\n  i = pos;\n  if (osip_list_size (&sip->headers) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* NULL */\n  while (osip_list_size (&sip->headers) > i) {\n    tmp = (osip_header_t *) osip_list_get (&sip->headers, i);\n    if (osip_strcasecmp (tmp->hname, hname) == 0) {\n      *dest = tmp;\n      return i;\n    }\n    i++;\n  }\n  return OSIP_UNDEFINED_ERROR;  /* not found */\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_header_init": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "int\nosip_header_init (osip_header_t ** header)\n{\n  *header = (osip_header_t *) osip_malloc (sizeof (osip_header_t));\n  if (*header == NULL)\n    return OSIP_NOMEM;\n  (*header)->hname = NULL;\n  (*header)->hvalue = NULL;\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_header_free": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "void\nosip_header_free (osip_header_t * header)\n{\n  if (header == NULL)\n    return;\n  osip_free (header->hname);\n  osip_free (header->hvalue);\n  header->hname = NULL;\n  header->hvalue = NULL;\n\n  osip_free (header);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "osip_header_to_str": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "int\nosip_header_to_str (const osip_header_t * header, char **dest)\n{\n  size_t len, hlen;\n\n  *dest = NULL;\n  if ((header == NULL) || (header->hname == NULL))\n    return OSIP_BADPARAMETER;\n\n  len = 0;\n  hlen = strlen (header->hname);\n  if (header->hvalue != NULL)\n    len = strlen (header->hvalue);\n\n  *dest = (char *) osip_malloc (hlen + len + 3);\n  if (*dest == NULL)\n    return OSIP_NOMEM;\n\n  if (header->hvalue != NULL)\n    snprintf (*dest, hlen + len + 3, \"%s: %s\", header->hname, header->hvalue);\n  else\n    snprintf (*dest, hlen + len + 3, \"%s: \", header->hname);\n\n  if (*dest[0] >= 'a' && *dest[0] <= 'z')\n    *dest[0] = (*dest[0] - 32);\n  return OSIP_SUCCESS;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_header_get_name": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "char *\nosip_header_get_name (const osip_header_t * header)\n{\n  if (header == NULL)\n    return NULL;\n  return header->hname;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_header_get_name (const osip_header_t * header)",
        "*"
      ]
    },
    "osip_header_set_name": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "void\nosip_header_set_name (osip_header_t * header, char *name)\n{\n  header->hname = name;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_header_get_value": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "char *\nosip_header_get_value (const osip_header_t * header)\n{\n  if (header == NULL)\n    return NULL;\n  return header->hvalue;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_header_get_value (const osip_header_t * header)",
        "*"
      ]
    },
    "osip_header_set_value": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "void\nosip_header_set_value (osip_header_t * header, char *value)\n{\n  header->hvalue = value;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_header_clone": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "int\nosip_header_clone (const osip_header_t * header, osip_header_t ** dest)\n{\n  int i;\n  osip_header_t *he;\n\n  *dest = NULL;\n  if (header == NULL)\n    return OSIP_BADPARAMETER;\n  if (header->hname == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_header_init (&he);\n  if (i != 0)\n    return i;\n  he->hname = osip_strdup (header->hname);\n\n  if (he->hname == NULL) {\n    osip_header_free (he);\n    return OSIP_NOMEM;\n  }\n  if (header->hvalue != NULL) {\n    he->hvalue = osip_strdup (header->hvalue);\n    if (he->hvalue == NULL) {\n      osip_header_free (he);\n      return OSIP_NOMEM;\n    }\n  }\n\n  *dest = he;\n  return OSIP_SUCCESS;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_list.c": {
    "osip_list_init": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nosip_list_init (osip_list_t * li)\n{\n  if (li == NULL)\n    return OSIP_BADPARAMETER;\n  memset (li, 0, sizeof (osip_list_t));\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_list_clone": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nosip_list_clone (const osip_list_t * src, osip_list_t * dst, int (*clone_func) (void *, void **))\n{\n  void *data;\n  void *data2;\n  int i;\n  osip_list_iterator_t iterator;\n\n  for (data = osip_list_get_first ((osip_list_t *) src, &iterator); osip_list_iterator_has_elem (iterator); data = osip_list_get_next (&iterator)) {\n    i = clone_func (data, &data2);\n    if (i != 0)\n      return i;\n    osip_list_add (dst, data2, -1);\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_list_special_free": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "void\nosip_list_special_free (osip_list_t * li, void (*free_func) (void *))\n{\n  void *element;\n\n  if (li == NULL)\n    return;\n  while (!osip_list_eol (li, 0)) {\n    element = (void *) osip_list_get (li, 0);\n    osip_list_remove (li, 0);\n    if (free_func != NULL)\n      free_func (element);\n  }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "osip_list_ofchar_free": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\nosip_list_ofchar_free (osip_list_t * li)\n{\n  char *chain;\n\n  if (li == NULL)\n    return;\n  while (!osip_list_eol (li, 0)) {\n    chain = (char *) osip_list_get (li, 0);\n    osip_list_remove (li, 0);\n    osip_free (chain);\n  }\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "osip_list_size": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nosip_list_size (const osip_list_t * li)\n{\n  if (li == NULL)\n    return OSIP_BADPARAMETER;\n\n  return li->nb_elt;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_list_eol": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\nosip_list_eol (const osip_list_t * li, int i)\n{\n  if (li == NULL)\n    return OSIP_BADPARAMETER;\n  if (i < li->nb_elt)\n    return OSIP_SUCCESS;        /* not end of list */\n  return 1;                     /* end of list */\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "osip_list_add": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nosip_list_add (osip_list_t * li, void *el, int pos)\n{\n  __node_t *ntmp;\n  int i = 0;\n\n  if (li == NULL)\n    return OSIP_BADPARAMETER;\n\n  if (li->nb_elt == 0) {\n\n    li->node = (__node_t *) osip_malloc (sizeof (__node_t));\n    if (li->node == NULL)\n      return OSIP_NOMEM;\n    li->node->element = el;\n    li->node->next = NULL;\n    li->nb_elt++;\n    return li->nb_elt;\n  }\n\n  if (pos == -1 || pos >= li->nb_elt) { /* insert at the end  */\n    pos = li->nb_elt;\n  }\n\n  ntmp = li->node;              /* exist because nb_elt>0  */\n\n  if (pos == 0) {               /* pos = 0 insert before first elt  */\n    li->node = (__node_t *) osip_malloc (sizeof (__node_t));\n    if (li->node == NULL) {\n      /* leave the list unchanged */\n      li->node = ntmp;\n      return OSIP_NOMEM;\n    }\n    li->node->element = el;\n    li->node->next = ntmp;\n    li->nb_elt++;\n    return li->nb_elt;\n  }\n\n\n  while (pos > i + 1) {\n    i++;\n    /* when pos>i next node exist  */\n    ntmp = ntmp->next;\n  }\n\n  /* if pos==nb_elt next node does not exist  */\n  if (pos == li->nb_elt) {\n    ntmp->next = osip_malloc (sizeof (__node_t));\n    if (ntmp->next == NULL)\n      return OSIP_NOMEM;        /* leave the list unchanged */\n    ntmp = ntmp->next;\n    ntmp->element = el;\n    ntmp->next = NULL;\n    li->nb_elt++;\n    return li->nb_elt;\n  }\n\n  /* here pos==i so next node is where we want to insert new node */\n  {\n    __node_t *nextnode = ntmp->next;\n\n    ntmp->next = osip_malloc (sizeof (__node_t));\n    if (ntmp->next == NULL) {\n      /* leave the list unchanged */\n      ntmp->next = nextnode;\n      return OSIP_NOMEM;\n    }\n    ntmp = ntmp->next;\n    ntmp->element = el;\n    ntmp->next = nextnode;\n    li->nb_elt++;\n  }\n  return li->nb_elt;\n}",
      "lines": 75,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_list_get": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "void *\nosip_list_get (const osip_list_t * li, int pos)\n{\n  __node_t *ntmp;\n  int i = 0;\n\n  if (li == NULL)\n    return NULL;\n\n  if (pos < 0 || pos >= li->nb_elt)\n    /* element does not exist */\n    return NULL;\n\n\n  ntmp = li->node;              /* exist because nb_elt>0 */\n\n  while (pos > i) {\n    i++;\n    ntmp = ntmp->next;\n  }\n  return ntmp->element;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void",
        "*\nosip_list_get (const osip_list_t * li, int pos)",
        "*"
      ]
    },
    "osip_list_get_first": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "void *\nosip_list_get_first (const osip_list_t * li, osip_list_iterator_t * iterator)\n{\n  if (li==NULL || 0 >= li->nb_elt) {\n    iterator->actual = 0;\n    return OSIP_SUCCESS;\n  }\n\n  iterator->actual = li->node;\n  iterator->prev = (__node_t**)&li->node;\n  iterator->li = (osip_list_t*)li;\n  iterator->pos = 0;\n\n  return li->node->element;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void",
        "*\nosip_list_get_first (const osip_list_t * li, osip_list_iterator_t * iterator)",
        "*"
      ]
    },
    "osip_list_get_next": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "void *\nosip_list_get_next (osip_list_iterator_t * iterator)\n{\n  if (iterator->actual == NULL) {\n    return OSIP_SUCCESS;\n  }\n\n  iterator->prev = &(iterator->actual->next);\n  iterator->actual = iterator->actual->next;\n  ++(iterator->pos);\n\n  if (osip_list_iterator_has_elem (*iterator)) {\n    return iterator->actual->element;\n  }\n\n  iterator->actual = 0;\n  return OSIP_SUCCESS;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void",
        "*\nosip_list_get_next (osip_list_iterator_t * iterator)",
        "*"
      ]
    },
    "osip_list_iterator_remove": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "void *\nosip_list_iterator_remove (osip_list_iterator_t * iterator)\n{\n  if (osip_list_iterator_has_elem (*iterator)) {\n    --(iterator->li->nb_elt);\n\n    *(iterator->prev) = iterator->actual->next;\n\n    osip_free (iterator->actual);\n    iterator->actual = *(iterator->prev);\n  }\n\n  if (osip_list_iterator_has_elem (*iterator)) {\n    return iterator->actual->element;\n  }\n\n  return OSIP_SUCCESS;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void",
        "*\nosip_list_iterator_remove (osip_list_iterator_t * iterator)",
        "*"
      ]
    },
    "osip_list_remove": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "int\nosip_list_remove (osip_list_t * li, int pos)\n{\n\n  __node_t *ntmp;\n  int i = 0;\n\n  if (li == NULL)\n    return OSIP_BADPARAMETER;\n\n  if (pos < 0 || pos >= li->nb_elt)\n    /* element does not exist */\n    return OSIP_UNDEFINED_ERROR;\n\n  ntmp = li->node;              /* exist because nb_elt>0 */\n\n  if (pos == 0) {               /* special case  */\n    li->node = ntmp->next;\n    li->nb_elt--;\n    osip_free (ntmp);\n    return li->nb_elt;\n  }\n\n  while (pos > i + 1) {\n    i++;\n    ntmp = ntmp->next;\n  }\n\n  /* insert new node */\n  {\n    __node_t *remnode;\n\n    remnode = ntmp->next;\n    ntmp->next = (ntmp->next)->next;\n    osip_free (remnode);\n    li->nb_elt--;\n  }\n  return li->nb_elt;\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_md5c.c": {
    "osip_MD5Init": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void\nosip_MD5Init (osip_MD5_CTX * context    /* context */\n  )\n{\n  context->count[0] = context->count[1] = 0;\n  /* Load magic initialization constants.\n   */\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xefcdab89;\n  context->state[2] = 0x98badcfe;\n  context->state[3] = 0x10325476;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_MD5Update": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\nosip_MD5Update (osip_MD5_CTX * context, /* context */\n                unsigned char *input,   /* input block */\n                unsigned int inputLen   /* length of input block */\n  )\n{\n  unsigned int i, index, partLen;\n\n  /* Compute number of bytes mod 64 */\n  index = (unsigned int) ((context->count[0] >> 3) & 0x3F);\n\n  /* Update number of bits */\n  if ((context->count[0] += ((UINT4) inputLen << 3)) < ((UINT4) inputLen << 3))\n    context->count[1]++;\n  context->count[1] += ((UINT4) inputLen >> 29);\n\n  partLen = 64 - index;\n\n  /* Transform as many times as possible.\n   */\n  if (inputLen >= partLen) {\n    osip_MD5_memcpy ((POINTER) & context->buffer[index], (POINTER) input, partLen);\n    osip_MD5Transform (context->state, context->buffer);\n\n    for (i = partLen; i + 63 < inputLen; i += 64)\n      osip_MD5Transform (context->state, &input[i]);\n\n    index = 0;\n  }\n  else\n    i = 0;\n\n  /* Buffer remaining input */\n  osip_MD5_memcpy ((POINTER) & context->buffer[index], (POINTER) & input[i], inputLen - i);\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "osip_MD5Final": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "void\nosip_MD5Final (unsigned char digest[16],        /* message digest */\n               osip_MD5_CTX * context   /* context */\n  )\n{\n  unsigned char bits[8];\n  unsigned int index, padLen;\n\n  /* Save number of bits */\n  osip_Encode (bits, context->count, 8);\n\n  /* Pad out to 56 mod 64.\n   */\n  index = (unsigned int) ((context->count[0] >> 3) & 0x3f);\n  padLen = (index < 56) ? (56 - index) : (120 - index);\n  osip_MD5Update (context, PADDING, padLen);\n\n  /* Append length (before padding) */\n  osip_MD5Update (context, bits, 8);\n\n  /* Store state in digest */\n  osip_Encode (digest, context->state, 16);\n\n  /* Zeroize sensitive information.\n   */\n  osip_MD5_memset ((POINTER) context, 0, sizeof (*context));\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "osip_MD5Transform": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static void\nosip_MD5Transform (UINT4 state[4], unsigned char block[64])\n{\n  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];\n\n  osip_Decode (x, block, 64);\n\n  /* Round 1 */\n  FF (a, b, c, d, x[0], S11, 0xd76aa478);       /* 1 */\n  FF (d, a, b, c, x[1], S12, 0xe8c7b756);       /* 2 */\n  FF (c, d, a, b, x[2], S13, 0x242070db);       /* 3 */\n  FF (b, c, d, a, x[3], S14, 0xc1bdceee);       /* 4 */\n  FF (a, b, c, d, x[4], S11, 0xf57c0faf);       /* 5 */\n  FF (d, a, b, c, x[5], S12, 0x4787c62a);       /* 6 */\n  FF (c, d, a, b, x[6], S13, 0xa8304613);       /* 7 */\n  FF (b, c, d, a, x[7], S14, 0xfd469501);       /* 8 */\n  FF (a, b, c, d, x[8], S11, 0x698098d8);       /* 9 */\n  FF (d, a, b, c, x[9], S12, 0x8b44f7af);       /* 10 */\n  FF (c, d, a, b, x[10], S13, 0xffff5bb1);      /* 11 */\n  FF (b, c, d, a, x[11], S14, 0x895cd7be);      /* 12 */\n  FF (a, b, c, d, x[12], S11, 0x6b901122);      /* 13 */\n  FF (d, a, b, c, x[13], S12, 0xfd987193);      /* 14 */\n  FF (c, d, a, b, x[14], S13, 0xa679438e);      /* 15 */\n  FF (b, c, d, a, x[15], S14, 0x49b40821);      /* 16 */\n\n  /* Round 2 */\n  GG (a, b, c, d, x[1], S21, 0xf61e2562);       /* 17 */\n  GG (d, a, b, c, x[6], S22, 0xc040b340);       /* 18 */\n  GG (c, d, a, b, x[11], S23, 0x265e5a51);      /* 19 */\n  GG (b, c, d, a, x[0], S24, 0xe9b6c7aa);       /* 20 */\n  GG (a, b, c, d, x[5], S21, 0xd62f105d);       /* 21 */\n  GG (d, a, b, c, x[10], S22, 0x2441453);       /* 22 */\n  GG (c, d, a, b, x[15], S23, 0xd8a1e681);      /* 23 */\n  GG (b, c, d, a, x[4], S24, 0xe7d3fbc8);       /* 24 */\n  GG (a, b, c, d, x[9], S21, 0x21e1cde6);       /* 25 */\n  GG (d, a, b, c, x[14], S22, 0xc33707d6);      /* 26 */\n  GG (c, d, a, b, x[3], S23, 0xf4d50d87);       /* 27 */\n  GG (b, c, d, a, x[8], S24, 0x455a14ed);       /* 28 */\n  GG (a, b, c, d, x[13], S21, 0xa9e3e905);      /* 29 */\n  GG (d, a, b, c, x[2], S22, 0xfcefa3f8);       /* 30 */\n  GG (c, d, a, b, x[7], S23, 0x676f02d9);       /* 31 */\n  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a);      /* 32 */\n\n  /* Round 3 */\n  HH (a, b, c, d, x[5], S31, 0xfffa3942);       /* 33 */\n  HH (d, a, b, c, x[8], S32, 0x8771f681);       /* 34 */\n  HH (c, d, a, b, x[11], S33, 0x6d9d6122);      /* 35 */\n  HH (b, c, d, a, x[14], S34, 0xfde5380c);      /* 36 */\n  HH (a, b, c, d, x[1], S31, 0xa4beea44);       /* 37 */\n  HH (d, a, b, c, x[4], S32, 0x4bdecfa9);       /* 38 */\n  HH (c, d, a, b, x[7], S33, 0xf6bb4b60);       /* 39 */\n  HH (b, c, d, a, x[10], S34, 0xbebfbc70);      /* 40 */\n  HH (a, b, c, d, x[13], S31, 0x289b7ec6);      /* 41 */\n  HH (d, a, b, c, x[0], S32, 0xeaa127fa);       /* 42 */\n  HH (c, d, a, b, x[3], S33, 0xd4ef3085);       /* 43 */\n  HH (b, c, d, a, x[6], S34, 0x4881d05);        /* 44 */\n  HH (a, b, c, d, x[9], S31, 0xd9d4d039);       /* 45 */\n  HH (d, a, b, c, x[12], S32, 0xe6db99e5);      /* 46 */\n  HH (c, d, a, b, x[15], S33, 0x1fa27cf8);      /* 47 */\n  HH (b, c, d, a, x[2], S34, 0xc4ac5665);       /* 48 */\n\n  /* Round 4 */\n  II (a, b, c, d, x[0], S41, 0xf4292244);       /* 49 */\n  II (d, a, b, c, x[7], S42, 0x432aff97);       /* 50 */\n  II (c, d, a, b, x[14], S43, 0xab9423a7);      /* 51 */\n  II (b, c, d, a, x[5], S44, 0xfc93a039);       /* 52 */\n  II (a, b, c, d, x[12], S41, 0x655b59c3);      /* 53 */\n  II (d, a, b, c, x[3], S42, 0x8f0ccc92);       /* 54 */\n  II (c, d, a, b, x[10], S43, 0xffeff47d);      /* 55 */\n  II (b, c, d, a, x[1], S44, 0x85845dd1);       /* 56 */\n  II (a, b, c, d, x[8], S41, 0x6fa87e4f);       /* 57 */\n  II (d, a, b, c, x[15], S42, 0xfe2ce6e0);      /* 58 */\n  II (c, d, a, b, x[6], S43, 0xa3014314);       /* 59 */\n  II (b, c, d, a, x[13], S44, 0x4e0811a1);      /* 60 */\n  II (a, b, c, d, x[4], S41, 0xf7537e82);       /* 61 */\n  II (d, a, b, c, x[11], S42, 0xbd3af235);      /* 62 */\n  II (c, d, a, b, x[2], S43, 0x2ad7d2bb);       /* 63 */\n  II (b, c, d, a, x[9], S44, 0xeb86d391);       /* 64 */\n\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n\n  /* Zeroize sensitive information.\n   */\n  osip_MD5_memset ((POINTER) x, 0, sizeof (x));\n}",
      "lines": 88,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "osip_Encode": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static void\nosip_Encode (unsigned char *output, UINT4 * input, unsigned int len)\n{\n  unsigned int i, j;\n\n  for (i = 0, j = 0; j < len; i++, j += 4) {\n    output[j] = (unsigned char) (input[i] & 0xff);\n    output[j + 1] = (unsigned char) ((input[i] >> 8) & 0xff);\n    output[j + 2] = (unsigned char) ((input[i] >> 16) & 0xff);\n    output[j + 3] = (unsigned char) ((input[i] >> 24) & 0xff);\n  }\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "osip_Decode": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "static void\nosip_Decode (UINT4 * output, unsigned char *input, unsigned int len)\n{\n  unsigned int i, j;\n\n  for (i = 0, j = 0; j < len; i++, j += 4)\n    output[i] = ((UINT4) input[j]) | (((UINT4) input[j + 1]) << 8) | (((UINT4) input[j + 2]) << 16) | (((UINT4) input[j + 3]) << 24);\n}",
      "lines": 8,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "osip_MD5_memcpy": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "static void\nosip_MD5_memcpy (POINTER output, POINTER input, unsigned int len)\n{\n  unsigned int i;\n\n  for (i = 0; i < len; i++)\n    output[i] = input[i];\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "osip_MD5_memset": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "static void\nosip_MD5_memset (POINTER output, int value, unsigned int len)\n{\n  unsigned int i;\n\n  for (i = 0; i < len; i++)\n    ((char *) output)[i] = (char) value;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_message.c": {
    "osip_message_init": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nosip_message_init (osip_message_t ** sip)\n{\n  *sip = (osip_message_t *) osip_malloc (sizeof (osip_message_t));\n  if (*sip == NULL)\n    return OSIP_NOMEM;\n  memset (*sip, 0, sizeof (osip_message_t));\n\n#ifndef MINISIZE\n  osip_list_init (&(*sip)->accepts);\n  osip_list_init (&(*sip)->accept_encodings);\n\n  osip_list_init (&(*sip)->accept_languages);\n  osip_list_init (&(*sip)->alert_infos);\n  osip_list_init (&(*sip)->allows);\n  osip_list_init (&(*sip)->authentication_infos);\n#endif\n  osip_list_init (&(*sip)->authorizations);\n  (*sip)->call_id = NULL;\n  osip_list_init (&(*sip)->call_infos);\n  osip_list_init (&(*sip)->contacts);\n\n#ifndef MINISIZE\n  osip_list_init (&(*sip)->content_encodings);\n#endif\n  (*sip)->content_length = NULL;\n  (*sip)->content_type = NULL;\n  (*sip)->cseq = NULL;\n#ifndef MINISIZE\n  osip_list_init (&(*sip)->error_infos);\n#endif\n  (*sip)->from = NULL;\n  (*sip)->mime_version = NULL;\n  osip_list_init (&(*sip)->proxy_authenticates);\n#ifndef MINISIZE\n  osip_list_init (&(*sip)->proxy_authentication_infos);\n#endif\n  osip_list_init (&(*sip)->proxy_authorizations);\n  osip_list_init (&(*sip)->record_routes);\n  osip_list_init (&(*sip)->routes);\n  (*sip)->to = NULL;\n  osip_list_init (&(*sip)->vias);\n  osip_list_init (&(*sip)->www_authenticates);\n\n  osip_list_init (&(*sip)->bodies);\n\n  osip_list_init (&(*sip)->headers);\n\n  (*sip)->message_property = 3;\n  (*sip)->message = NULL;       /* buffer to avoid calling osip_message_to_str many times (for retransmission) */\n  (*sip)->message_length = 0;\n\n  (*sip)->application_data = NULL;\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 55,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_reason_phrase": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\nosip_message_set_reason_phrase (osip_message_t * sip, char *reason)\n{\n  sip->reason_phrase = reason;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_message_set_status_code": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nosip_message_set_status_code (osip_message_t * sip, int status_code)\n{\n  sip->status_code = status_code;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_message_set_method": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "void\nosip_message_set_method (osip_message_t * sip, char *sip_method)\n{\n  sip->sip_method = sip_method;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_message_set_version": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "void\nosip_message_set_version (osip_message_t * sip, char *sip_version)\n{\n  sip->sip_version = sip_version;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_message_set_uri": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void\nosip_message_set_uri (osip_message_t * sip, osip_uri_t * url)\n{\n  sip->req_uri = url;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_message_free": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "void\nosip_message_free (osip_message_t * sip)\n{\n  if (sip == NULL)\n    return;\n\n  osip_free (sip->sip_method);\n  osip_free (sip->sip_version);\n  if (sip->req_uri != NULL)\n    osip_uri_free (sip->req_uri);\n  osip_free (sip->reason_phrase);\n\n#ifndef MINISIZE\n  osip_list_special_free (&sip->accepts, (void (*)(void *)) &osip_accept_free);\n#endif\n  osip_list_special_free (&sip->authorizations, (void (*)(void *)) &osip_authorization_free);\n  if (sip->call_id != NULL)\n    osip_call_id_free (sip->call_id);\n#ifndef MINISIZE\n  osip_list_special_free (&sip->accept_encodings, (void (*)(void *)) &osip_accept_encoding_free);\n  osip_list_special_free (&sip->accept_languages, (void (*)(void *)) &osip_accept_language_free);\n  osip_list_special_free (&sip->alert_infos, (void (*)(void *)) &osip_alert_info_free);\n  osip_list_special_free (&sip->allows, (void (*)(void *)) &osip_allow_free);\n  osip_list_special_free (&sip->authentication_infos, (void (*)(void *)) &osip_authentication_info_free);\n  osip_list_special_free (&sip->content_encodings, (void (*)(void *)) &osip_content_encoding_free);\n  osip_list_special_free (&sip->error_infos, (void (*)(void *)) &osip_error_info_free);\n  osip_list_special_free (&sip->proxy_authentication_infos, (void (*)(void *))\n                          &osip_proxy_authentication_info_free);\n#endif\n  osip_list_special_free (&sip->call_infos, (void (*)(void *)) &osip_call_info_free);\n  osip_list_special_free (&sip->contacts, (void (*)(void *)) &osip_contact_free);\n  if (sip->content_length != NULL)\n    osip_content_length_free (sip->content_length);\n  if (sip->content_type != NULL)\n    osip_content_type_free (sip->content_type);\n  if (sip->cseq != NULL)\n    osip_cseq_free (sip->cseq);\n  if (sip->from != NULL)\n    osip_from_free (sip->from);\n  if (sip->mime_version != NULL)\n    osip_mime_version_free (sip->mime_version);\n  osip_list_special_free (&sip->proxy_authenticates, (void (*)(void *)) &osip_proxy_authenticate_free);\n  osip_list_special_free (&sip->proxy_authorizations, (void (*)(void *)) &osip_proxy_authorization_free);\n  osip_list_special_free (&sip->record_routes, (void (*)(void *)) &osip_record_route_free);\n  osip_list_special_free (&sip->routes, (void (*)(void *)) &osip_route_free);\n  if (sip->to != NULL)\n    osip_to_free (sip->to);\n  osip_list_special_free (&sip->vias, (void (*)(void *)) &osip_via_free);\n  osip_list_special_free (&sip->www_authenticates, (void (*)(void *)) &osip_www_authenticate_free);\n  osip_list_special_free (&sip->headers, (void (*)(void *)) &osip_header_free);\n  osip_list_special_free (&sip->bodies, (void (*)(void *)) &osip_body_free);\n  osip_free (sip->message);\n  osip_free (sip);\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "osip_message_clone": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "int\nosip_message_clone (const osip_message_t * sip, osip_message_t ** dest)\n{\n  osip_message_t *copy;\n  int i;\n\n  *dest = NULL;\n  if (sip == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_message_init (&copy);\n  if (i != 0)\n    return i;\n\n  copy->sip_method = osip_strdup (sip->sip_method);\n  if (sip->sip_method != NULL && copy->sip_method == NULL) {\n    osip_message_free (copy);\n    return OSIP_NOMEM;\n  }\n  copy->sip_version = osip_strdup (sip->sip_version);\n  if (sip->sip_version != NULL && copy->sip_version == NULL) {\n    osip_message_free (copy);\n    return OSIP_NOMEM;\n  }\n  copy->status_code = sip->status_code;\n  copy->reason_phrase = osip_strdup (sip->reason_phrase);\n  if (sip->reason_phrase != NULL && copy->reason_phrase == NULL) {\n    osip_message_free (copy);\n    return OSIP_NOMEM;\n  }\n  if (sip->req_uri != NULL) {\n    i = osip_uri_clone (sip->req_uri, &(copy->req_uri));\n    if (i != 0) {\n      osip_message_free (copy);\n      return i;\n    }\n  }\n#ifndef MINISIZE\n  i = osip_list_clone(&sip->accepts, &copy->accepts, (int (*)(void *, void **)) &osip_accept_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone(&sip->accept_encodings, &copy->accept_encodings, (int (*)(void *, void **)) &osip_accept_encoding_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone(&sip->accept_languages, &copy->accept_languages, (int (*)(void *, void **)) &osip_accept_language_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone(&sip->alert_infos, &copy->alert_infos, (int (*)(void *, void **)) &osip_alert_info_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone(&sip->allows, &copy->allows, (int (*)(void *, void **)) &osip_allow_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone(&sip->authentication_infos, &copy->authentication_infos, (int (*)(void *, void **)) &osip_authentication_info_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone(&sip->content_encodings, &copy->content_encodings, (int (*)(void *, void **)) &osip_content_encoding_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone(&sip->error_infos, &copy->error_infos, (int (*)(void *, void **)) &osip_error_info_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone(&sip->proxy_authentication_infos, &copy->proxy_authentication_infos, (int (*)(void *, void **)) &osip_proxy_authentication_info_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n#endif\n  i = osip_list_clone(&sip->call_infos, &copy->call_infos, (int (*)(void *, void **)) &osip_call_info_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone (&sip->authorizations, &copy->authorizations, (int (*)(void *, void **)) &osip_authorization_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  if (sip->call_id != NULL) {\n    i = osip_call_id_clone (sip->call_id, &(copy->call_id));\n    if (i != 0) {\n      osip_message_free (copy);\n      return i;\n    }\n  }\n  i = osip_list_clone (&sip->contacts, &copy->contacts, (int (*)(void *, void **)) &osip_contact_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  if (sip->content_length != NULL) {\n    i = osip_content_length_clone (sip->content_length, &(copy->content_length));\n    if (i != 0) {\n      osip_message_free (copy);\n      return i;\n    }\n  }\n  if (sip->content_type != NULL) {\n    i = osip_content_type_clone (sip->content_type, &(copy->content_type));\n    if (i != 0) {\n      osip_message_free (copy);\n      return i;\n    }\n  }\n  if (sip->cseq != NULL) {\n    i = osip_cseq_clone (sip->cseq, &(copy->cseq));\n    if (i != 0) {\n      osip_message_free (copy);\n      return i;\n    }\n  }\n  if (sip->from != NULL) {\n    i = osip_from_clone (sip->from, &(copy->from));\n    if (i != 0) {\n      osip_message_free (copy);\n      return i;\n    }\n  }\n  if (sip->mime_version != NULL) {\n    i = osip_mime_version_clone (sip->mime_version, &(copy->mime_version));\n    if (i != 0) {\n      osip_message_free (copy);\n      return i;\n    }\n  }\n  i = osip_list_clone (&sip->proxy_authenticates, &copy->proxy_authenticates, (int (*)(void *, void **)) &osip_proxy_authenticate_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone (&sip->proxy_authorizations, &copy->proxy_authorizations, (int (*)(void *, void **))\n                       &osip_proxy_authorization_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone (&sip->record_routes, &copy->record_routes, (int (*)(void *, void **)) &osip_record_route_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone (&sip->routes, &copy->routes, (int (*)(void *, void **)) &osip_route_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  if (sip->to != NULL) {\n    i = osip_to_clone (sip->to, &(copy->to));\n    if (i != 0) {\n      osip_message_free (copy);\n      return i;\n    }\n  }\n  i = osip_list_clone (&sip->vias, &copy->vias, (int (*)(void *, void **)) &osip_via_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone (&sip->www_authenticates, &copy->www_authenticates, (int (*)(void *, void **)) &osip_www_authenticate_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone (&sip->headers, &copy->headers, (int (*)(void *, void **)) &osip_header_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n  i = osip_list_clone (&sip->bodies, &copy->bodies, (int (*)(void *, void **)) &osip_body_clone);\n  if (i != 0) {\n    osip_message_free (copy);\n    return i;\n  }\n\n  copy->message_length = sip->message_length;\n  copy->message = osip_strdup (sip->message);\n  if (copy->message == NULL && sip->message != NULL) {\n    osip_message_free (copy);\n    return OSIP_NOMEM;\n  }\n  copy->message_property = sip->message_property;\n  copy->application_data = sip->application_data;\n\n  *dest = copy;\n  return OSIP_SUCCESS;\n}",
      "lines": 202,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_knownheaderlist": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "int\nosip_message_get_knownheaderlist (osip_list_t * header_list, int pos, void **dest)\n{\n  *dest = NULL;\n  if (osip_list_size (header_list) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  *dest = (void *) osip_list_get (header_list, pos);\n  return pos;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_message_parse.c": {
    "__osip_message_startline_parsereq": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static int\n__osip_message_startline_parsereq (osip_message_t * dest, const char *buf, const char **headers)\n{\n  const char *p1;\n  const char *p2;\n  char *requesturi;\n  int i;\n\n  dest->sip_method = NULL;\n  dest->status_code = 0;\n  dest->reason_phrase = NULL;\n\n  *headers = buf;\n\n  /* The first token is the method name: */\n  p2 = strchr (buf, ' ');\n  if (p2 == NULL)\n    return OSIP_SYNTAXERROR;\n  if (*(p2 + 1) == '\\0' || *(p2 + 2) == '\\0')\n    return OSIP_SYNTAXERROR;\n  if (p2 - buf == 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"No space allowed here\\n\"));\n    return OSIP_SYNTAXERROR;\n  }\n  dest->sip_method = (char *) osip_malloc (p2 - buf + 1);\n  if (dest->sip_method == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (dest->sip_method, buf, p2 - buf);\n\n  /* The second token is a sip-url or a uri: */\n  p1 = strchr (p2 + 2, ' ');    /* no space allowed inside sip-url */\n  if (p1 == NULL) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Uncompliant request-uri\\n\"));\n    osip_free (dest->sip_method);\n    dest->sip_method = NULL;\n    return OSIP_SYNTAXERROR;\n  }\n  if (p1 - p2 < 2) {\n    osip_free (dest->sip_method);\n    dest->sip_method = NULL;\n    return OSIP_SYNTAXERROR;\n  }\n\n  requesturi = (char *) osip_malloc (p1 - p2);\n  if (requesturi == NULL) {\n    osip_free (dest->sip_method);\n    dest->sip_method = NULL;\n    return OSIP_NOMEM;\n  }\n  osip_clrncpy (requesturi, p2 + 1, (p1 - p2 - 1));\n\n  i = osip_uri_init (&(dest->req_uri));\n  if (i != 0) {\n    osip_free (requesturi);\n    requesturi = NULL;\n    osip_free (dest->sip_method);\n    dest->sip_method = NULL;\n    return OSIP_NOMEM;\n  }\n  i = osip_uri_parse (dest->req_uri, requesturi);\n  osip_free (requesturi);\n  if (i != 0) {\n    osip_free (dest->sip_method);\n    dest->sip_method = NULL;\n    osip_uri_free (dest->req_uri);\n    dest->req_uri = NULL;\n    return OSIP_SYNTAXERROR;\n  }\n\n  /* find the the version and the beginning of headers */\n  {\n    const char *hp = p1;\n\n    hp++;                       /* skip space */\n    if (*hp == '\\0' || *(hp + 1) == '\\0' || *(hp + 2) == '\\0' || *(hp + 3) == '\\0' || *(hp + 4) == '\\0' || *(hp + 5) == '\\0' || *(hp + 6) == '\\0') {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Uncomplete request line\\n\"));\n      osip_free (dest->sip_method);\n      dest->sip_method = NULL;\n      osip_uri_free (dest->req_uri);\n      dest->req_uri = NULL;\n      return OSIP_SYNTAXERROR;\n    }\n    if (((hp[0] != 'S') && (hp[0] != 's')) || ((hp[1] != 'I') && (hp[1] != 'i')) || ((hp[2] != 'P') && (hp[2] != 'p')) || (hp[3] != '/')) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"No crlf found/No SIP/2.0 found\\n\"));\n      osip_free (dest->sip_method);\n      dest->sip_method = NULL;\n      osip_uri_free (dest->req_uri);\n      dest->req_uri = NULL;\n      return OSIP_SYNTAXERROR;\n    }\n    hp = hp + 4;                /* SIP/ */\n\n    while ((*hp != '\\r') && (*hp != '\\n')) {\n      if (*hp) {\n        if ((*hp >= '0') && (*hp <= '9'))\n          hp++;\n        else if (*hp == '.')\n          hp++;\n        else {\n          OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"incorrect sip version string\\n\"));\n          osip_free (dest->sip_method);\n          dest->sip_method = NULL;\n          osip_uri_free (dest->req_uri);\n          dest->req_uri = NULL;\n          return OSIP_SYNTAXERROR;\n        }\n      }\n      else {\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"No crlf found\\n\"));\n        osip_free (dest->sip_method);\n        dest->sip_method = NULL;\n        osip_uri_free (dest->req_uri);\n        dest->req_uri = NULL;\n        return OSIP_SYNTAXERROR;\n      }\n    }\n    if (hp - p1 < 2) {\n      osip_free (dest->sip_method);\n      dest->sip_method = NULL;\n      osip_uri_free (dest->req_uri);\n      dest->req_uri = NULL;\n      return OSIP_SYNTAXERROR;\n    }\n\n    dest->sip_version = (char *) osip_malloc (hp - p1);\n    if (dest->sip_version == NULL) {\n      osip_free (dest->sip_method);\n      dest->sip_method = NULL;\n      osip_uri_free (dest->req_uri);\n      dest->req_uri = NULL;\n      return OSIP_NOMEM;\n    }\n\n    osip_strncpy (dest->sip_version, p1 + 1, (hp - p1 - 1));\n\n    if (0 != osip_strcasecmp (dest->sip_version, \"SIP/2.0\")) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Wrong version number\\n\"));\n    }\n\n    hp++;\n    if ((*hp) && ('\\r' == hp[-1]) && ('\\n' == hp[0]))\n      hp++;\n    (*headers) = hp;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 146,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__osip_message_startline_parseresp": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static int\n__osip_message_startline_parseresp (osip_message_t * dest, const char *buf, const char **headers)\n{\n  const char *statuscode;\n  const char *reasonphrase;\n\n  dest->req_uri = NULL;\n  dest->sip_method = NULL;\n\n  *headers = buf;\n\n  statuscode = strchr (buf, ' ');       /* search for first SPACE */\n  if (statuscode == NULL)\n    return OSIP_SYNTAXERROR;\n  dest->sip_version = (char *) osip_malloc (statuscode - (*headers) + 1);\n  if (dest->sip_version == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (dest->sip_version, *headers, statuscode - (*headers));\n\n  reasonphrase = strchr (statuscode + 1, ' ');\n  if (reasonphrase == NULL) {\n    osip_free (dest->sip_version);\n    dest->sip_version = NULL;\n    return OSIP_SYNTAXERROR;\n  }\n  /* dest->status_code = (char *) osip_malloc (reasonphrase - statuscode); */\n  /* osip_strncpy (dest->status_code, statuscode + 1, reasonphrase - statuscode - 1); */\n  if (sscanf (statuscode + 1, \"%d\", &dest->status_code) != 1) {\n    /* Non-numeric status code */\n    return OSIP_SYNTAXERROR;\n  }\n\n  if (dest->status_code == 0)\n    return OSIP_SYNTAXERROR;\n\n  {\n    const char *hp = reasonphrase;\n\n    while ((*hp != '\\r') && (*hp != '\\n')) {\n      if (*hp)\n        hp++;\n      else {\n        OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"No crlf found\\n\"));\n        return OSIP_SYNTAXERROR;\n      }\n    }\n    dest->reason_phrase = (char *) osip_malloc (hp - reasonphrase);\n    if (dest->reason_phrase == NULL) {\n      osip_free (dest->sip_version);\n      dest->sip_version = NULL;\n      return OSIP_NOMEM;\n    }\n\n    osip_strncpy (dest->reason_phrase, reasonphrase + 1, hp - reasonphrase - 1);\n\n    hp++;\n    if ((*hp) && ('\\r' == hp[-1]) && ('\\n' == hp[0]))\n      hp++;\n    (*headers) = hp;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__osip_message_startline_parse": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static int\n__osip_message_startline_parse (osip_message_t * dest, const char *buf, const char **headers)\n{\n\n  if (0 == strncmp ((const char *) buf, (const char *) \"SIP/\", 4))\n    return __osip_message_startline_parseresp (dest, buf, headers);\n  else\n    return __osip_message_startline_parsereq (dest, buf, headers);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__osip_find_next_occurence": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "int\n__osip_find_next_occurence (const char *str, const char *buf, const char **index_of_str, const char *end_of_buf)\n{\n  int i;\n\n  *index_of_str = NULL;         /* AMD fix */\n  if ((NULL == str) || (NULL == buf))\n    return OSIP_BADPARAMETER;\n  /* TODO? we may prefer strcasestr instead of strstr? */\n  for (i = 0; i < 1000; i++) {\n    *index_of_str = strstr (buf, str);\n    if (NULL == (*index_of_str)) {\n      /* if '\\0' (when binary data is used) is located before the separator,\n         then we have to continue searching */\n      const char *ptr = buf + strlen (buf);\n\n      if (end_of_buf - ptr > 0) {\n        buf = ptr + 1;\n        continue;\n      }\n      return OSIP_SYNTAXERROR;\n    }\n    return OSIP_SUCCESS;\n  }\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_BUG, NULL, \"This was probably an infinite loop?\\n\"));\n  return OSIP_SYNTAXERROR;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_util_replace_all_lws": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "static void\nosip_util_replace_all_lws (char *sip_message)\n{\n  /* const char *end_of_message; */\n  char *tmp;\n\n  if (sip_message == NULL)\n    return;\n\n  /* end_of_message = sip_message + strlen (sip_message); */\n\n  tmp = sip_message;\n  for (; tmp[0] != '\\0'; tmp++) {\n    if (('\\0' == tmp[0])\n        || ('\\0' == tmp[1]) || ('\\0' == tmp[2]) || ('\\0' == tmp[3]))\n      return;\n\n    if ((('\\r' == tmp[0]) && ('\\n' == tmp[1])\n         && ('\\r' == tmp[2]) && ('\\n' == tmp[3]))\n        || (('\\r' == tmp[0]) && ('\\r' == tmp[1]))\n        || (('\\n' == tmp[0]) && ('\\n' == tmp[1])))\n      return;                   /* end of message */\n\n    if ((('\\r' == tmp[0]) && ('\\n' == tmp[1])\n         && ((' ' == tmp[2]) || ('\\t' == tmp[2])))\n        || (('\\r' == tmp[0])\n            && ((' ' == tmp[1]) || ('\\t' == tmp[1])))\n        || (('\\n' == tmp[0]) && ((' ' == tmp[1]) || ('\\t' == tmp[1])))) {\n      /* replace line end and TAB symbols by SP */\n      tmp[0] = ' ';\n      tmp[1] = ' ';\n      tmp = tmp + 2;\n      /* replace all following TAB symbols */\n      for (; ('\\t' == tmp[0] || ' ' == tmp[0]);) {\n        tmp[0] = ' ';\n        tmp++;\n      }\n    }\n  }\n}",
      "lines": 40,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__osip_find_next_crlf": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "int\n__osip_find_next_crlf (const char *start_of_header, const char **end_of_header)\n{\n  const char *soh = start_of_header;\n\n  *end_of_header = NULL;        /* AMD fix */\n\n  while (('\\r' != *soh) && ('\\n' != *soh)) {\n    if (*soh)\n      soh++;\n    else {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Final CRLF is missing\\n\"));\n      return OSIP_SYNTAXERROR;\n    }\n  }\n\n  if (('\\r' == soh[0]) && ('\\n' == soh[1]))\n    /* case 1: CRLF is the separator\n       case 2 or 3: CR or LF is the separator */\n    soh = soh + 1;\n\n\n  /* VERIFY if TMP is the end of header or LWS.            */\n  /* LWS are extra SP, HT, CR and LF contained in headers. */\n  if ((' ' == soh[1]) || ('\\t' == soh[1])) {\n    /* From now on, incoming message that potentially\n       contains LWS must be processed with\n       -> void osip_util_replace_all_lws(char *)\n       This is because the parser methods does not\n       support detection of LWS inside. */\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_BUG, NULL, \"Message that contains LWS must be processed with osip_util_replace_all_lws(char *tmp) before being parsed.\\n\"));\n    return -2;\n  }\n\n  *end_of_header = soh + 1;\n  return OSIP_SUCCESS;\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "__osip_find_next_crlfcrlf": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "int\n__osip_find_next_crlfcrlf (const char *start_of_part, const char **end_of_part)\n{\n  const char *start_of_line;\n  const char *end_of_line;\n  int i;\n\n  start_of_line = start_of_part;\n\n  for (;;) {\n    i = __osip_find_next_crlf (start_of_line, &end_of_line);\n    if (i == -2) {\n    }\n    else if (i != 0) {          /* error case??? no end of mesage found */\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Final CRLF is missing\\n\"));\n      return i;\n    }\n    if ('\\0' == end_of_line[0]) {       /* error case??? no end of message found */\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Final CRLF is missing\\n\"));\n      return OSIP_SYNTAXERROR;\n    }\n    else if ('\\r' == end_of_line[0]) {\n      if ('\\n' == end_of_line[1])\n        end_of_line++;\n      *end_of_part = end_of_line + 1;\n      return OSIP_SUCCESS;\n    }\n    else if ('\\n' == end_of_line[0]) {\n      *end_of_part = end_of_line + 1;\n      return OSIP_SUCCESS;\n    }\n    start_of_line = end_of_line;\n  }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set__header": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "static int\nosip_message_set__header (osip_message_t * sip, const char *hname, const char *hvalue)\n{\n  int my_index;\n\n  if (hname == NULL)\n    return OSIP_SYNTAXERROR;\n\n  /* some headers are analysed completely      */\n  /* this method is used for selective parsing */\n  my_index = __osip_message_is_known_header (hname);\n  if (my_index >= 0) {          /* ok */\n    int ret;\n\n    ret = __osip_message_call_method (my_index, sip, hvalue);\n    if (ret != 0)\n      return ret;\n    return OSIP_SUCCESS;\n  }\n  /* unknownheader */\n  if (osip_message_set_header (sip, hname, hvalue) != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"Could not set unknown header\\n\"));\n    return OSIP_SUCCESS;\n  }\n\n  return OSIP_SUCCESS;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "osip_message_set_multiple_header": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        569,
        1
      ],
      "content": "int\nosip_message_set_multiple_header (osip_message_t * sip, char *hname, char *hvalue)\n{\n  int i;\n  char *ptr, *p;                /* current location of the search */\n  char *comma;                  /* This is the separator we are elooking for */\n  char *beg;                    /* beg of a header */\n  char *end;                    /* end of a header */\n  int inquotes, inuri;          /* state for inside/outside of double-qoutes or URI */\n  size_t hname_len;\n\n  /* Find header based upon lowercase comparison */\n  osip_tolower (hname);\n\n  if (hvalue == NULL) {\n    i = osip_message_set__header (sip, hname, hvalue);\n    if (i != 0)\n      return i;\n    return OSIP_SUCCESS;\n  }\n\n  ptr = hvalue;\n  comma = strchr (ptr, ',');\n\n  hname_len = strlen (hname);\n\n  if (comma == NULL || (hname_len == 4 && strncmp (hname, \"date\", 4) == 0)\n      || (hname_len == 1 && strncmp (hname, \"t\", 1) == 0)\n      || (hname_len == 2 && strncmp (hname, \"to\", 2) == 0)\n      || (hname_len == 1 && strncmp (hname, \"f\", 1) == 0)\n      || (hname_len == 4 && strncmp (hname, \"from\", 4) == 0)\n      || (hname_len == 1 && strncmp (hname, \"i\", 1) == 0)\n      || (hname_len == 7 && strncmp (hname, \"call-id\", 7) == 0)\n      || (hname_len == 4 && strncmp (hname, \"cseq\", 4) == 0)\n      || (hname_len == 1 && strncmp (hname, \"s\", 1) == 0)\n      || (hname_len == 7 && strncmp (hname, \"subject\", 7) == 0)\n      || (hname_len == 7 && strncmp (hname, \"expires\", 7) == 0)\n      || (hname_len == 6 && strncmp (hname, \"server\", 6) == 0)\n      || (hname_len == 10 && strncmp (hname, \"user-agent\", 10) == 0)\n      || (hname_len == 16 && strncmp (hname, \"www-authenticate\", 16) == 0)\n      || (hname_len == 19 && strncmp (hname, \"authentication-info\", 19) == 0)\n      || (hname_len == 18 && strncmp (hname, \"proxy-authenticate\", 18) == 0)\n      || (hname_len == 19 && strncmp (hname, \"proxy-authorization\", 19) == 0)\n      || (hname_len == 25 && strncmp (hname, \"proxy-authentication-info\", 25) == 0)\n      || (hname_len == 12 && strncmp (hname, \"organization\", 12) == 0)\n      || (hname_len == 13 && strncmp (hname, \"authorization\", 13) == 0)\n      || (hname_len == 1 && strncmp (hname, \"r\", 1) == 0) /* refer-to */\n      || (hname_len == 8 && strncmp (hname, \"refer-to\", 8) == 0)\n      || (hname_len == 1 && strncmp (hname, \"b\", 1) == 0) /* referred-by */\n      || (hname_len == 11 && strncmp (hname, \"referred-by\", 11) == 0))\n    /* there is no multiple header! likely      */\n    /* to happen most of the time...            */\n    /* or hname is a TEXT-UTF8-TRIM and may     */\n    /* contain a comma. this is not a separator */\n    /* THIS DOES NOT WORK FOR UNKNOWN HEADER!!!! */\n  {\n    i = osip_message_set__header (sip, hname, hvalue);\n    if (i != 0)\n      return i;\n    return OSIP_SUCCESS;\n  }\n\n  beg = hvalue;\n  inquotes = 0;\n  inuri = 0;\n  /* Seach for a comma that is not within quotes or a URI */\n  for (;; ptr++)\n  {\n    switch (*ptr)\n    {\n    case '\"':\n      /* Check that the '\"' is not escaped */\n      for (i = 0, p = ptr; p >= beg && *p == '\\\\'; p--, i++);\n      if (i % 2 == 0)\n        inquotes = !inquotes; /* the '\"' was not escaped */\n      break;\n\n    case '<':\n      if (!inquotes)\n      {\n        if (!inuri)\n        {\n          if((osip_strncasecmp(ptr+1, \"sip:\", 4) == 0\n              || osip_strncasecmp(ptr+1, \"sips:\", 5) == 0\n              || osip_strncasecmp(ptr+1, \"http:\", 5) == 0\n              || osip_strncasecmp(ptr+1, \"https:\", 6) == 0\n              || osip_strncasecmp(ptr+1, \"tel:\", 4) == 0)\n              && strchr(ptr, '>'))\n            inuri = 1;\n        }\n\t/*\n\t  else {\n\t  if we found such sequence: \"<sip:\" \"<sip:\" \">\"\n\t  It might be a valid header containing data and not URIs.\n\t  Thus, we ignore inuri\n\t  }\n\t*/\n      }\n      break;\n\n    case '>':\n      if (!inquotes)\n      {\n        if (inuri)\n          inuri = 0;\n      }\n      break;\n\n    case '\\0':\n      /* we discard any validation we tried: no valid uri detected */\n      inquotes=0;\n      inuri=0;\n    case ',':\n      if (!inquotes && !inuri)\n      {\n        char *avalue;\n\n        if (beg[0] == '\\0')\n          return OSIP_SUCCESS; /* empty header */\n\n        end = ptr;\n        if (end - beg + 1 < 2)\n\t  {\n\t    beg=end+1;\n\t    break; /* skip empty header */\n\t  }\n        avalue = (char *) osip_malloc (end - beg + 1);\n        if (avalue==NULL)\n          return OSIP_NOMEM;\n        osip_clrncpy (avalue, beg, end - beg);\n        /* really store the header in the sip structure */\n        i = osip_message_set__header (sip, hname, avalue);\n        osip_free (avalue);\n        if (i != 0)\n          return i;\n        beg = end + 1;\n      }\n      if (*ptr == '\\0')\n        return OSIP_SUCCESS;\n      break;\n\n    default:\n      break;\n    }\n  }\n}",
      "lines": 146,
      "depth": 35,
      "decorators": [
        "int"
      ]
    },
    "msg_headers_parse": {
      "start_point": [
        572,
        0
      ],
      "end_point": [
        663,
        1
      ],
      "content": "static int\nmsg_headers_parse (osip_message_t * sip, const char *start_of_header, const char **body)\n{\n  const char *colon_index;      /* index of ':' */\n  char *hname;\n  char *hvalue;\n  const char *end_of_header;\n  int i;\n\n  for (;;) {\n    if (start_of_header[0] == '\\0') {   /* final CRLF is missing */\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO1, NULL, \"SIP message does not end with CRLFCRLF\\n\"));\n      return OSIP_SUCCESS;\n    }\n\n    i = __osip_find_next_crlf (start_of_header, &end_of_header);\n    if (i == -2) {\n    }\n    else if (i != 0) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"End of header Not found\\n\"));\n      return i;                 /* this is an error case!     */\n    }\n\n    /* the list of headers MUST always end with  */\n    /* CRLFCRLF (also CRCR and LFLF are allowed) */\n    if ((start_of_header[0] == '\\r') || (start_of_header[0] == '\\n')) {\n      *body = start_of_header;\n      return OSIP_SUCCESS;      /* end of header found        */\n    }\n\n    /* find the header name */\n    colon_index = strchr (start_of_header, ':');\n    if (colon_index == NULL) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"End of header Not found\\n\"));\n      return OSIP_SYNTAXERROR;  /* this is also an error case */\n    }\n    if (colon_index - start_of_header + 1 < 2)\n      return OSIP_SYNTAXERROR;\n    if (end_of_header <= colon_index) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Malformed message\\n\"));\n      return OSIP_SYNTAXERROR;\n    }\n    hname = (char *) osip_malloc (colon_index - start_of_header + 1);\n    if (hname == NULL)\n      return OSIP_NOMEM;\n    osip_clrncpy (hname, start_of_header, colon_index - start_of_header);\n\n    {\n      const char *end;\n\n      /* END of header is (end_of_header-2) if header separation is CRLF */\n      /* END of header is (end_of_header-1) if header separation is CR or LF */\n      if ((end_of_header[-2] == '\\r') || (end_of_header[-2] == '\\n'))\n        end = end_of_header - 2;\n      else\n        end = end_of_header - 1;\n      if ((end) - colon_index < 2)\n        hvalue = NULL;          /* some headers (subject) can be empty */\n      else {\n        hvalue = (char *) osip_malloc ((end) - colon_index + 1);\n        if (hvalue == NULL) {\n          osip_free (hname);\n          return OSIP_NOMEM;\n        }\n        osip_clrncpy (hvalue, colon_index + 1, (end) - colon_index - 1);\n      }\n    }\n\n    /* hvalue MAY contains multiple value. In this case, they   */\n    /* are separated by commas. But, a comma may be part of a   */\n    /* quoted-string (\"here, and there\" is an example where the */\n    /* comma is not a separator!) */\n    i = osip_message_set_multiple_header (sip, hname, hvalue);\n\n    osip_free (hname);\n    if (hvalue != NULL)\n      osip_free (hvalue);\n    if (i != 0) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"End of header Not found\\n\"));\n      return OSIP_SYNTAXERROR;\n    }\n\n    /* continue on the next header */\n    start_of_header = end_of_header;\n  }\n\n/* Unreachable code\n OSIP_TRACE (osip_trace\n\t      (__FILE__, __LINE__, OSIP_BUG, NULL,\n\t       \"This code cannot be reached\\n\")); */\n  return OSIP_SYNTAXERROR;\n}",
      "lines": 92,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "msg_osip_body_parse": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        819,
        1
      ],
      "content": "static int\nmsg_osip_body_parse (osip_message_t * sip, const char *start_of_buf, const char **next_body, size_t length)\n{\n  const char *start_of_body;\n  const char *end_of_body;\n  const char *end_of_buf;\n  char *tmp;\n  int i;\n\n  char *sep_boundary;\n  size_t len_sep_boundary;\n  osip_generic_param_t *ct_param;\n\n  if (sip->content_type == NULL || sip->content_type->type == NULL || sip->content_type->subtype == NULL)\n    return OSIP_SUCCESS;        /* no body is attached */\n\n  if (0 != osip_strcasecmp (sip->content_type->type, \"multipart\")) {\n    size_t osip_body_len;\n\n    if (start_of_buf[0] == '\\0')\n      return OSIP_SYNTAXERROR;  /* final CRLF is missing */\n    /* get rid of the first CRLF */\n    if ('\\r' == start_of_buf[0]) {\n      if ('\\n' == start_of_buf[1])\n        start_of_body = start_of_buf + 2;\n      else\n        start_of_body = start_of_buf + 1;\n    }\n    else if ('\\n' == start_of_buf[0])\n      start_of_body = start_of_buf + 1;\n    else\n      return OSIP_SYNTAXERROR;  /* message does not end with CRLFCRLF, CRCR or LFLF */\n\n    /* update length (without CRLFCRLF */\n    length = length - (start_of_body - start_of_buf);   /* fixed 24 08 2004 */\n    if (length <= 0)\n      return OSIP_SYNTAXERROR;\n\n    if (sip->content_length != NULL)\n      osip_body_len = osip_atoi (sip->content_length->value);\n    else {\n      /* if content_length does not exist, set it. */\n      char tmp[16];\n      osip_body_len = length;\n      sprintf (tmp, \"%i\", (int) osip_body_len);\n      i = osip_message_set_content_length (sip, tmp);\n      if (i != 0)\n\treturn i;\n    }\n\n    if (length < osip_body_len) {\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Message was not receieved enterely. length=%i osip_body_len=%i\\n\", (int) length, (int) osip_body_len));\n      return OSIP_SYNTAXERROR;\n    }\n\n    end_of_body = start_of_body + osip_body_len;\n    tmp = osip_malloc (end_of_body - start_of_body + 2);\n    if (tmp == NULL)\n      return OSIP_NOMEM;\n    memcpy (tmp, start_of_body, end_of_body - start_of_body);\n    tmp[end_of_body - start_of_body] = '\\0';\n\n    i = osip_message_set_body (sip, tmp, end_of_body - start_of_body);\n    osip_free (tmp);\n    if (i != 0)\n      return i;\n    return OSIP_SUCCESS;\n  }\n\n  /* find the boundary */\n  i = osip_generic_param_get_byname (&sip->content_type->gen_params, \"boundary\", &ct_param);\n  if (i != 0)\n    return i;\n\n  if (ct_param == NULL)\n    return OSIP_SYNTAXERROR;\n  if (ct_param->gvalue == NULL)\n    return OSIP_SYNTAXERROR;    /* No boundary but multiple headers??? */\n\n  {\n    const char *boundary_prefix = \"\\n--\";\n\n    size_t len = strlen (ct_param->gvalue);\n\n    sep_boundary = (char *) osip_malloc (len + 4);\n    if (sep_boundary == NULL)\n      return OSIP_NOMEM;\n    strcpy (sep_boundary, boundary_prefix);\n    if (ct_param->gvalue[0] == '\"' && ct_param->gvalue[len - 1] == '\"')\n      strncat (sep_boundary, ct_param->gvalue + 1, len - 2);\n    else\n      strncat (sep_boundary, ct_param->gvalue, len);\n  }\n\n  len_sep_boundary = strlen (sep_boundary);\n\n  *next_body = NULL;\n  start_of_body = start_of_buf;\n\n  end_of_buf = start_of_buf + length;\n\n  for (;;) {\n    size_t body_len = 0;\n\n    i = __osip_find_next_occurence (sep_boundary, start_of_body, &start_of_body, end_of_buf);\n    if (i != 0) {\n      osip_free (sep_boundary);\n      return i;\n    }\n\n    i = __osip_find_next_occurence (sep_boundary, start_of_body + len_sep_boundary, &end_of_body, end_of_buf);\n    if (i != 0) {\n      osip_free (sep_boundary);\n      return i;\n    }\n\n    /* this is the real beginning of body */\n    start_of_body = start_of_body + len_sep_boundary + 1;\n    if ('\\n' == start_of_body[0] || '\\r' == start_of_body[0])\n      start_of_body++;\n\n    body_len = end_of_body - start_of_body;\n\n    /* Skip CR before end boundary. */\n    if (*(end_of_body - 1) == '\\r')\n      body_len--;\n\n    tmp = osip_malloc (body_len + 2);\n    if (tmp == NULL) {\n      osip_free (sep_boundary);\n      return OSIP_NOMEM;\n    }\n    memcpy (tmp, start_of_body, body_len);\n    tmp[body_len] = '\\0';\n\n    i = osip_message_set_body_mime (sip, tmp, body_len);\n    osip_free (tmp);\n    if (i != 0) {\n      osip_free (sep_boundary);\n      return i;\n    }\n\n    if (strncmp (end_of_body + len_sep_boundary, \"--\", 2) == 0) {       /* end of all bodies */\n      *next_body = end_of_body;\n      osip_free (sep_boundary);\n      return OSIP_SUCCESS;\n    }\n\n    /* continue on the next body */\n    start_of_body = end_of_body;\n  }\n  /* Unreachable code */\n  /* osip_free (sep_boundary); */\n  return OSIP_SYNTAXERROR;\n}",
      "lines": 155,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_osip_message_parse": {
      "start_point": [
        822,
        0
      ],
      "end_point": [
        891,
        1
      ],
      "content": "static int\n_osip_message_parse (osip_message_t * sip, const char *buf, size_t length, int sipfrag)\n{\n  int i;\n  const char *next_header_index;\n  char *tmp;\n  char *beg;\n\n  tmp = osip_malloc (length + 2);\n  if (tmp == NULL) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Could not allocate memory.\\n\"));\n    return OSIP_NOMEM;\n  }\n  beg = tmp;\n  memcpy (tmp, buf, length);    /* may contain binary data */\n  tmp[length] = '\\0';\n  /* skip initial \\r\\n */\n  while (tmp[0] == '\\r' || tmp[0] == '\\n')\n    tmp++;\n  osip_util_replace_all_lws (tmp);\n  /* parse request or status line */\n  i = __osip_message_startline_parse (sip, tmp, &next_header_index);\n  if (i != 0 && !sipfrag) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"Could not parse start line of message.\\n\"));\n    osip_free (beg);\n    return i;\n  }\n  tmp = (char *) next_header_index;\n\n  /* parse headers */\n  i = msg_headers_parse (sip, tmp, &next_header_index);\n  if (i != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"error in msg_headers_parse()\\n\"));\n    osip_free (beg);\n    return i;\n  }\n  tmp = (char *) next_header_index;\n\n  if (sip->content_length != NULL && sip->content_length->value == NULL) {\n    /* empty content_length header */\n    osip_content_length_free(sip->content_length);\n    sip->content_length=NULL;\n  }\n\n  if (sip->content_length != NULL && sip->content_length->value != NULL && atoi(sip->content_length->value) >0) {\n    /* body exist */\n  } else if (sip->content_length == NULL && '\\r' == next_header_index[0] && '\\n' == next_header_index[1] && length - (tmp - beg) - (2) >0) {\n    /* body exist */\n  } else if (sip->content_length == NULL && '\\n' == next_header_index[0] && length - (tmp - beg) - (1) >0) {\n    /* body exist */\n  } else {\n    if (sip->content_length == NULL)\n      osip_message_set_content_length (sip, \"0\");\n    osip_free (beg);\n    return OSIP_SUCCESS;        /* no body found */\n  }\n\n  i = msg_osip_body_parse (sip, tmp, &next_header_index, length - (tmp - beg));\n  osip_free (beg);\n  if (i != 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"error in msg_osip_body_parse()\\n\"));\n    return i;\n  }\n\n  /* this is mandatory in the oSIP stack */\n  if (sip->content_length == NULL)\n    osip_message_set_content_length (sip, \"0\");\n\n  return OSIP_SUCCESS;\n}",
      "lines": 70,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "osip_message_parse": {
      "start_point": [
        893,
        0
      ],
      "end_point": [
        897,
        1
      ],
      "content": "int\nosip_message_parse (osip_message_t * sip, const char *buf, size_t length)\n{\n  return _osip_message_parse (sip, buf, length, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_message_parse_sipfrag": {
      "start_point": [
        899,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "int\nosip_message_parse_sipfrag (osip_message_t * sip, const char *buf, size_t length)\n{\n  return _osip_message_parse (sip, buf, length, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_message_fix_last_via_header": {
      "start_point": [
        908,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "int\nosip_message_fix_last_via_header (osip_message_t * request, const char *ip_addr, int port)\n{\n  osip_generic_param_t *rport;\n  osip_via_t *via;\n\n  /* get Top most Via header: */\n  if (request == NULL)\n    return OSIP_BADPARAMETER;\n  if (MSG_IS_RESPONSE (request))\n    return OSIP_SUCCESS;        /* Don't fix Via header */\n\n  via = osip_list_get (&request->vias, 0);\n  if (via == NULL || via->host == NULL)\n    /* Hey, we could build it? */\n    return OSIP_BADPARAMETER;\n\n  osip_via_param_get_byname (via, \"rport\", &rport);\n  if (rport != NULL) {\n    if (rport->gvalue == NULL) {\n      rport->gvalue = (char *) osip_malloc (9);\n      if (rport->gvalue == NULL)\n        return OSIP_NOMEM;\n#if !defined __PALMOS__ && (defined WIN32 || defined _WIN32_WCE)\n      _snprintf (rport->gvalue, 8, \"%i\", port);\n#else\n      snprintf (rport->gvalue, 8, \"%i\", port);\n#endif\n    }                           /* else bug? */\n  }\n\n  /* only add the received parameter if the 'sent-by' value does not contains\n     this ip address */\n  if (0 == strcmp (via->host, ip_addr)) /* don't need the received parameter */\n    return OSIP_SUCCESS;\n  osip_via_set_received (via, osip_strdup (ip_addr));\n  return OSIP_SUCCESS;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_reason": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        1064,
        1
      ],
      "content": "const char *\nosip_message_get_reason (int replycode)\n{\n  struct code_to_reason {\n    int code;\n    const char *reason;\n  };\n\n  static const struct code_to_reason reasons1xx[] = {\n    {100, \"Trying\"},\n    {180, \"Ringing\"},\n    {181, \"Call Is Being Forwarded\"},\n    {182, \"Queued\"},\n    {183, \"Session Progress\"},\n  };\n  static const struct code_to_reason reasons2xx[] = {\n    {200, \"OK\"},\n    {202, \"Accepted\"},\n  };\n  static const struct code_to_reason reasons3xx[] = {\n    {300, \"Multiple Choices\"},\n    {301, \"Moved Permanently\"},\n    {302, \"Moved Temporarily\"},\n    {305, \"Use Proxy\"},\n    {380, \"Alternative Service\"},\n  };\n  static const struct code_to_reason reasons4xx[] = {\n    {400, \"Bad Request\"},\n    {401, \"Unauthorized\"},\n    {402, \"Payment Required\"},\n    {403, \"Forbidden\"},\n    {404, \"Not Found\"},\n    {405, \"Method Not Allowed\"},\n    {406, \"Not Acceptable\"},\n    {407, \"Proxy Authentication Required\"},\n    {408, \"Request Timeout\"},\n    {409, \"Conflict\"},\n    {410, \"Gone\"},\n    {411, \"Length Required\"},\n    {412, \"Conditional Request Failed\"},\n    {413, \"Request Entity Too Large\"},\n    {414, \"Request-URI Too Long\"},\n    {415, \"Unsupported Media Type\"},\n    {416, \"Unsupported URI Scheme\"},\n    {417, \"Unknown Resource-Priority\"},\n    {420, \"Bad Extension\"},\n    {421, \"Extension Required\"},\n    {422, \"Session Interval Too Small\"},\n    {423, \"Interval Too Brief\"},\n    {469, \"Bad Info Package\"},\n    {480, \"Temporarily Unavailable\"},\n    {481, \"Call/Transaction Does Not Exist\"},\n    {482, \"Loop Detected\"},\n    {483, \"Too Many Hops\"},\n    {484, \"Address Incomplete\"},\n    {485, \"Ambiguous\"},\n    {486, \"Busy Here\"},\n    {487, \"Request Terminated\"},\n    {488, \"Not Acceptable Here\"},\n    {489, \"Bad Event\"},\n    {491, \"Request Pending\"},\n    {493, \"Undecipherable\"},\n  };\n  static const struct code_to_reason reasons5xx[] = {\n    {500, \"Server Internal Error\"},\n    {501, \"Not Implemented\"},\n    {502, \"Bad Gateway\"},\n    {503, \"Service Unavailable\"},\n    {504, \"Server Time-out\"},\n    {505, \"Version Not Supported\"},\n    {513, \"Message Too Large\"},\n  };\n  static const struct code_to_reason reasons6xx[] = {\n    {600, \"Busy Everywhere\"},\n    {603, \"Decline\"},\n    {604, \"Does Not Exist Anywhere\"},\n    {606, \"Not Acceptable\"},\n    {687, \"Dialog Terminated\"}\n  };\n  const struct code_to_reason *reasons;\n  int len, i;\n\n  switch (replycode / 100) {\n  case 1:\n    reasons = reasons1xx;\n    len = sizeof (reasons1xx) / sizeof (*reasons);\n    break;\n  case 2:\n    reasons = reasons2xx;\n    len = sizeof (reasons2xx) / sizeof (*reasons);\n    break;\n  case 3:\n    reasons = reasons3xx;\n    len = sizeof (reasons3xx) / sizeof (*reasons);\n    break;\n  case 4:\n    reasons = reasons4xx;\n    len = sizeof (reasons4xx) / sizeof (*reasons);\n    break;\n  case 5:\n    reasons = reasons5xx;\n    len = sizeof (reasons5xx) / sizeof (*reasons);\n    break;\n  case 6:\n    reasons = reasons6xx;\n    len = sizeof (reasons6xx) / sizeof (*reasons);\n    break;\n  default:\n    return NULL;\n  }\n\n  for (i = 0; i < len; i++)\n    if (reasons[i].code == replycode)\n      return reasons[i].reason;\n\n  /* Not found. */\n  return NULL;\n}",
      "lines": 118,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nosip_message_get_reason (int replycode)",
        "*"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_message_to_str.c": {
    "__osip_message_startline_to_strreq": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static int\n__osip_message_startline_to_strreq (osip_message_t * sip, char **dest)\n{\n  const char *sip_version;\n  char *tmp;\n  char *rquri;\n  int i;\n\n  *dest = NULL;\n  if ((sip == NULL) || (sip->req_uri == NULL) || (sip->sip_method == NULL))\n    return OSIP_BADPARAMETER;\n\n  i = osip_uri_to_str (sip->req_uri, &rquri);\n  if (i != 0)\n    return i;\n\n  if (sip->sip_version == NULL)\n    sip_version = osip_protocol_version;\n  else\n    sip_version = sip->sip_version;\n\n  *dest = (char *) osip_malloc (strlen (sip->sip_method)\n                                + strlen (rquri) + strlen (sip_version) + 3);\n  if (*dest == NULL) {\n    osip_free (rquri);\n    return OSIP_NOMEM;\n  }\n  tmp = *dest;\n\n  tmp = osip_str_append (tmp, sip->sip_method);\n  *tmp = ' ';\n  tmp++;\n  tmp = osip_str_append (tmp, rquri);\n  *tmp = ' ';\n  tmp++;\n  strcpy (tmp, sip_version);\n\n  osip_free (rquri);\n  return OSIP_SUCCESS;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__osip_message_startline_to_strresp": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\n__osip_message_startline_to_strresp (osip_message_t * sip, char **dest)\n{\n  char *tmp;\n  const char *sip_version;\n  char status_code[5];\n\n  *dest = NULL;\n  if ((sip == NULL) || (sip->reason_phrase == NULL)\n      || (sip->status_code < 100) || (sip->status_code > 699))\n    return OSIP_BADPARAMETER;\n\n  if (sip->sip_version == NULL)\n    sip_version = osip_protocol_version;\n  else\n    sip_version = sip->sip_version;\n\n  sprintf (status_code, \"%u\", sip->status_code);\n\n  *dest = (char *) osip_malloc (strlen (sip_version)\n                                + 3 + strlen (sip->reason_phrase) + 4);\n  if (*dest == NULL)\n    return OSIP_NOMEM;\n  tmp = *dest;\n\n  tmp = osip_str_append (tmp, sip_version);\n  *tmp = ' ';\n  tmp++;\n\n  tmp = osip_strn_append (tmp, status_code, 3);\n  *tmp = ' ';\n  tmp++;\n  strcpy (tmp, sip->reason_phrase);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__osip_message_startline_to_str": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static int\n__osip_message_startline_to_str (osip_message_t * sip, char **dest)\n{\n\n  if (sip->sip_method != NULL)\n    return __osip_message_startline_to_strreq (sip, dest);\n  if (sip->status_code != 0)\n    return __osip_message_startline_to_strresp (sip, dest);\n\n  OSIP_TRACE (osip_trace (__FILE__, __LINE__, TRACE_LEVEL1, NULL, \"ERROR method has no value or status code is 0!\\n\"));\n  return OSIP_BADPARAMETER;     /* should never come here */\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "osip_message_get_reason_phrase": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "char *\nosip_message_get_reason_phrase (const osip_message_t * sip)\n{\n  return sip->reason_phrase;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_message_get_reason_phrase (const osip_message_t * sip)",
        "*"
      ]
    },
    "osip_message_get_status_code": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nosip_message_get_status_code (const osip_message_t * sip)\n{\n  return sip->status_code;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_method": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "char *\nosip_message_get_method (const osip_message_t * sip)\n{\n  return sip->sip_method;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_message_get_method (const osip_message_t * sip)",
        "*"
      ]
    },
    "osip_message_get_version": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "char *\nosip_message_get_version (const osip_message_t * sip)\n{\n  return sip->sip_version;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_message_get_version (const osip_message_t * sip)",
        "*"
      ]
    },
    "osip_message_get_uri": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "osip_uri_t *\nosip_message_get_uri (const osip_message_t * sip)\n{\n  return sip->req_uri;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "osip_uri_t",
        "*\nosip_message_get_uri (const osip_message_t * sip)",
        "*"
      ]
    },
    "strcat_simple_header": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static int\nstrcat_simple_header (char **_string, size_t * malloc_size, char **_message, void *ptr_header, char *header_name, size_t size_of_header, int (*xxx_to_str) (void *, char **), char **next)\n{\n  char *string;\n  char *message;\n  char *tmp;\n  int i;\n\n  string = *_string;\n  message = *_message;\n\n  if (ptr_header != NULL) {\n    if (*malloc_size < message - string + 100 + size_of_header)\n      /* take some memory avoid to osip_realloc too much often */\n    {                           /* should not happen often */\n      size_t size = message - string;\n\n      *malloc_size = message - string + size_of_header + 100;\n      string = osip_realloc (string, *malloc_size);\n      if (string == NULL) {\n        osip_free (*_string);   /* pointer for string */\n        *_string = NULL;\n        *_message = NULL;\n        return OSIP_NOMEM;\n      }\n      *_string = string;\n      message = string + size;\n    }\n    message = osip_strn_append (message, header_name, size_of_header);\n\n    i = xxx_to_str (ptr_header, &tmp);\n    if (i != 0) {\n      *_string = string;\n      *_message = message;\n      *next = NULL;\n      return i;\n    }\n    if (*malloc_size < message - string + strlen (tmp) + 100) {\n      size_t size = message - string;\n\n      *malloc_size = message - string + strlen (tmp) + 100;\n      string = osip_realloc (string, *malloc_size);\n      if (string == NULL) {\n        osip_free (*_string);   /* pointer for string */\n        *_string = NULL;\n        *_message = NULL;\n        return OSIP_NOMEM;\n      }\n      *_string = string;\n      message = string + size;\n    }\n\n    message = osip_str_append (message, tmp);\n    osip_free (tmp);\n    message = osip_strn_append (message, CRLF, 2);\n  }\n  *_string = string;\n  *_message = message;\n  *next = message;\n  return OSIP_SUCCESS;\n}",
      "lines": 61,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "strcat_headers_one_per_line": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "static int\nstrcat_headers_one_per_line (char **_string, size_t * malloc_size, char **_message, osip_list_t * headers, char *header, size_t size_of_header, int (*xxx_to_str) (void *, char **), char **next)\n{\n  char *string;\n  char *message;\n  char *tmp;\n  int i;\n  osip_list_iterator_t it;\n  void *elt = osip_list_get_first(headers, &it);\n\n  string = *_string;\n  message = *_message;\n\n  while (elt != OSIP_SUCCESS) {\n\n    if (*malloc_size < message - string + 100 + size_of_header)\n      /* take some memory avoid to osip_realloc too much often */\n    {                           /* should not happen often */\n      size_t size = message - string;\n\n      *malloc_size = message - string + size_of_header + 100;\n      string = osip_realloc (string, *malloc_size);\n      if (string == NULL) {\n        osip_free (*_string);   /* pointer for string */\n        *_string = NULL;\n        *_message = NULL;\n        return OSIP_NOMEM;\n      }\n      *_string = string;\n      message = string + size;\n    }\n    osip_strncpy (message, header, size_of_header);\n    i = xxx_to_str (elt, &tmp);\n    if (i != 0) {\n      *_string = string;\n      *_message = message;\n      *next = NULL;\n      return i;\n    }\n    message = message + strlen (message);\n\n    if (*malloc_size < message - string + strlen (tmp) + 100) {\n      size_t size = message - string;\n\n      *malloc_size = message - string + strlen (tmp) + 100;\n      string = osip_realloc (string, *malloc_size);\n      if (string == NULL) {\n        osip_free (*_string);   /* pointer for string */\n        *_string = NULL;\n        *_message = NULL;\n        return OSIP_NOMEM;\n      }\n      *_string = string;\n      message = string + size;\n    }\n    message = osip_str_append (message, tmp);\n    osip_free (tmp);\n    message = osip_strn_append (message, CRLF, 2);\n    elt = osip_list_get_next(&it);\n  }\n  *_string = string;\n  *_message = message;\n  *next = message;\n  return OSIP_SUCCESS;\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "osip_message_get__property": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "int\nosip_message_get__property (const osip_message_t * sip)\n{\n  if (sip == NULL)\n    return OSIP_BADPARAMETER;\n  return sip->message_property;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "osip_message_force_update": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "int\nosip_message_force_update (osip_message_t * sip)\n{\n  if (sip == NULL)\n    return OSIP_BADPARAMETER;\n  sip->message_property = 2;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "_osip_message_realloc": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "static int\n_osip_message_realloc (char **message, char **dest, size_t needed, size_t * malloc_size)\n{\n  size_t size = *message - *dest;\n\n  if (*malloc_size < (size_t) (size + needed + 100)) {\n    *malloc_size = size + needed + 100;\n    *dest = osip_realloc (*dest, *malloc_size);\n    if (*dest == NULL)\n      return OSIP_NOMEM;\n    *message = *dest + size;\n  }\n\n  return OSIP_SUCCESS;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "osip_message_to_str": {
      "start_point": [
        710,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "int\nosip_message_to_str (osip_message_t * sip, char **dest, size_t * message_length)\n{\n  return _osip_message_to_str (sip, dest, message_length, 0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "osip_message_to_str_sipfrag": {
      "start_point": [
        716,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "int\nosip_message_to_str_sipfrag (osip_message_t * sip, char **dest, size_t * message_length)\n{\n  return _osip_message_to_str (sip, dest, message_length, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_mime_version.c": {
    "osip_message_set_mime_version": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nosip_message_set_mime_version (osip_message_t * sip, const char *hvalue)\n{\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  if (sip->mime_version != NULL)\n    return OSIP_SYNTAXERROR;\n  i = osip_mime_version_init (&(sip->mime_version));\n  if (i != 0)\n    return i;\n  sip->message_property = 2;\n  i = osip_mime_version_parse (sip->mime_version, hvalue);\n  if (i != 0) {\n    osip_mime_version_free (sip->mime_version);\n    sip->mime_version = NULL;\n    return i;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_mime_version": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "osip_mime_version_t *\nosip_message_get_mime_version (const osip_message_t * sip)\n{\n  return sip->mime_version;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "osip_mime_version_t",
        "*\nosip_message_get_mime_version (const osip_message_t * sip)",
        "*"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_parser_cfg.c": {
    "parser_init": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "int\nparser_init (void)\n{\n  int i = 0;\n\n#ifndef MINISIZE\n  pconfig[i].hname = ACCEPT;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_accept);\n  pconfig[i].hname = ACCEPT_ENCODING;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_accept_encoding);\n  pconfig[i].hname = ACCEPT_LANGUAGE;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_accept_language);\n  pconfig[i].hname = ALERT_INFO;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_alert_info);\n  pconfig[i].hname = ALLOW;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_allow);\n  pconfig[i].hname = AUTHENTICATION_INFO;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_authentication_info);\n#endif\n  pconfig[i].hname = AUTHORIZATION;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_authorization);\n  pconfig[i].hname = CONTENT_TYPE_SHORT;        /* \"l\" */\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_content_type);\n  pconfig[i].hname = CALL_ID;\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_call_id);\n#ifndef MINISIZE\n  pconfig[i].hname = CALL_INFO;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_call_info);\n#endif\n  pconfig[i].hname = CONTACT;\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_contact);\n#ifndef MINISIZE\n  pconfig[i].hname = CONTENT_ENCODING;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_content_encoding);\n#endif\n  pconfig[i].hname = CONTENT_LENGTH;\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_content_length);\n  pconfig[i].hname = CONTENT_TYPE;\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_content_type);\n  pconfig[i].hname = CSEQ;\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_cseq);\n#ifndef MINISIZE\n  pconfig[i].hname = CONTENT_ENCODING_SHORT;    /* \"e\" */\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_content_encoding);\n  pconfig[i].hname = ERROR_INFO;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_error_info);\n#endif\n  pconfig[i].hname = FROM_SHORT;        /* \"f\" */\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_from);\n  pconfig[i].hname = FROM;\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_from);\n  pconfig[i].hname = CALL_ID_SHORT;     /* \"i\" */\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_call_id);\n  pconfig[i].hname = CONTENT_LENGTH_SHORT;      /* \"l\" */\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_content_length);\n  pconfig[i].hname = CONTACT_SHORT;     /* \"m\" */\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_contact);\n  pconfig[i].hname = MIME_VERSION;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_mime_version);\n  pconfig[i].hname = PROXY_AUTHENTICATE;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_proxy_authenticate);\n#ifndef MINISIZE\n  pconfig[i].hname = PROXY_AUTHENTICATION_INFO;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_proxy_authentication_info);\n#endif\n  pconfig[i].hname = PROXY_AUTHORIZATION;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_proxy_authorization);\n  pconfig[i].hname = RECORD_ROUTE;\n  pconfig[i].ignored_when_invalid = 1;  /* best effort - but should be 0 */\n  pconfig[i++].setheader = (&osip_message_set_record_route);\n  pconfig[i].hname = ROUTE;\n  pconfig[i].ignored_when_invalid = 1;  /* best effort - but should be 0 */\n  pconfig[i++].setheader = (&osip_message_set_route);\n  pconfig[i].hname = TO_SHORT;\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_to);\n  pconfig[i].hname = TO;\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_to);\n  pconfig[i].hname = VIA_SHORT;\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_via);\n  pconfig[i].hname = VIA;\n  pconfig[i].ignored_when_invalid = 0;\n  pconfig[i++].setheader = (&osip_message_set_via);\n  pconfig[i].hname = WWW_AUTHENTICATE;\n  pconfig[i].ignored_when_invalid = 1;\n  pconfig[i++].setheader = (&osip_message_set_www_authenticate);\n\n  /* build up hash table for fast header lookup */\n\n  /* initialize the table */\n  for (i = 0; i < HASH_TABLE_SIZE; i++) {\n    hdr_ref_table[i] = -1;      /* -1 -> no entry */\n  }\n\n  for (i = 0; i < NUMBER_OF_HEADERS; i++) {\n    unsigned long hash;\n\n    /* calculate hash value using lower case */\n    /* Fixed: do not lower constant... osip_tolower( pconfig[i].hname ); */\n    hash = osip_hash (pconfig[i].hname);\n    hash = hash % HASH_TABLE_SIZE;\n\n    if (hdr_ref_table[hash] == -1) {\n      /* store reference(index) to pconfig table */\n      hdr_ref_table[hash] = i;\n    }\n    else {\n      /* oops, conflict!-> change the hash table or use another hash function size */\n\n      OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_ERROR, NULL, \"conflict with current hashtable size\\n\"));\n      return OSIP_UNDEFINED_ERROR;\n    }\n  }\n\n  return OSIP_SUCCESS;\n}",
      "lines": 144,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "__osip_message_is_known_header": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "int\n__osip_message_is_known_header (const char *hname)\n{\n  unsigned long hash;\n  int result = -1;\n\n  int index;\n\n  hash = osip_hash (hname);\n  hash = hash % HASH_TABLE_SIZE;\n  index = hdr_ref_table[hash];\n\n  if ((index != -1) && (0 == strcmp (pconfig[index].hname, hname))) {\n    result = index;\n  }\n\n  return result;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "__osip_message_call_method": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "int\n__osip_message_call_method (int i, osip_message_t * dest, const char *hvalue)\n{\n  int err;\n\n  err = pconfig[i].setheader (dest, hvalue);\n  if (err < 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL, \"Could not set header: %s: %s\\n\", pconfig[i].hname, hvalue));\n  }\n  if (pconfig[i].ignored_when_invalid == 1)\n    return OSIP_SUCCESS;\n  return err;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_port.c": {
    "osip_strerror": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "const char *\nosip_strerror (int err)\n{\n  if (err > 0)\n    return osip_error_table[0];\n  if (err > -60)\n    return osip_error_table[-err];\n  return osip_error_table[59];\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nosip_strerror (int err)",
        "*"
      ]
    },
    "osip_fallback_random_number": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static unsigned int\nosip_fallback_random_number ()\n#endif\n{\n  if (!random_seed_set) {\n    unsigned int ticks;\n\n#ifdef __PALMOS__\n#\tif __PALMOS__ < 0x06000000\n    SysRandom ((Int32) TimGetTicks ());\n#\telse\n    struct timeval tv;\n\n    gettimeofday (&tv, NULL);\n    srand (tv.tv_usec);\n    ticks = tv.tv_sec + tv.tv_usec;\n#\tendif\n#elif defined(WIN32)\n    LARGE_INTEGER lCount;\n\n    QueryPerformanceCounter (&lCount);\n    ticks = lCount.LowPart + lCount.HighPart;\n#elif defined(_WIN32_WCE)\n    ticks = GetTickCount ();\n#elif defined(__PSOS__)\n#elif defined(__rtems__)\n    rtems_clock_get (RTEMS_CLOCK_GET_TICKS_SINCE_BOOT, &ticks);\n#elif defined(__VXWORKS_OS__)\n    struct timespec tp;\n\n    clock_gettime (CLOCK_REALTIME, &tp);\n    ticks = tp.tv_sec + tp.tv_nsec;\n#else\n    struct timeval tv;\n    int fd;\n\n    gettimeofday (&tv, NULL);\n    ticks = (unsigned int) (tv.tv_sec + tv.tv_usec);\n    fd = open (\"/dev/urandom\", O_RDONLY);\n    if (fd > 0) {\n      unsigned int r;\n      int i;\n\n      for (i = 0; i < 512; i++) {\n        read (fd, &r, sizeof (r));\n        ticks += r;\n      }\n      close (fd);\n    }\n#endif\n\n#ifdef HAVE_LRAND48\n    srand48 (ticks);\n#else\n    srand (ticks);\n#endif\n    random_seed_set = 1;\n  }\n#ifdef HAVE_LRAND48\n  {\n    int val = (int) lrand48 ();\n\n    if (val == 0) {\n      unsigned int ticks;\n      struct timeval tv;\n\n      gettimeofday (&tv, NULL);\n      ticks = (unsigned int) (tv.tv_sec + tv.tv_usec);\n      srand48 (ticks);\n      return (unsigned int) lrand48 ();\n    }\n\n    return val;\n  }\n#else\n  return rand ();\n#endif\n}",
      "lines": 78,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "osip_build_random_number": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "unsigned int\nosip_build_random_number ()\n{\n  HCRYPTPROV crypto;\n  BOOL err;\n  unsigned int num;\n\n  if (!random_seed_set) {\n    unsigned int ticks;\n    LARGE_INTEGER lCount;\n\n    QueryPerformanceCounter (&lCount);\n    ticks = lCount.LowPart + lCount.HighPart;\n    srand (ticks);\n    random_seed_set = 1;\n  }\n  err = CryptAcquireContext (&crypto, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);\n  if (err) {\n    err = CryptGenRandom (crypto, sizeof (num), (BYTE *) & num);\n    CryptReleaseContext (crypto, 0);\n  }\n  if (!err) {\n    num = osip_fallback_random_number ();\n  }\n  return num;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "osip_strncpy": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "char *\nosip_strncpy (char *dest, const char *src, size_t length)\n{\n  strncpy (dest, src, length);\n  dest[length] = '\\0';\n  return dest;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_strncpy (char *dest, const char *src, size_t length)",
        "*"
      ]
    },
    "osip_strdup": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "char *\nosip_strdup (const char *ch)\n{\n  char *copy;\n  size_t length;\n\n  if (ch == NULL)\n    return NULL;\n  length = strlen (ch);\n  copy = (char *) osip_malloc (length + 1);\n  if (copy == NULL)\n    return NULL;\n  osip_strncpy (copy, ch, length);\n  return copy;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "char",
        "*\nosip_strdup (const char *ch)",
        "*"
      ]
    },
    "osip_atoi": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "int\nosip_atoi (const char *number)\n{\n#if defined(__linux) || defined(HAVE_STRTOL)\n  int i;\n\n  if (number == NULL)\n    return OSIP_UNDEFINED_ERROR;\n  i = strtol (number, (char **) NULL, 10);\n  if (i == LONG_MIN || i == LONG_MAX)\n    return OSIP_UNDEFINED_ERROR;\n  return i;\n#endif\n\n  return atoi (number);\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_usleep": {
      "start_point": [
        388,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "void\nosip_usleep (int useconds)\n{\n#if defined(__PALMOS__) && (__PALMOS__ >= 0x06000000)\n  /* This bit will work for the Protein API, but not the Palm 68K API */\n  nsecs_t nanoseconds = useconds * 1000;\n\n  SysThreadDelay (nanoseconds, P_ABSOLUTE_TIMEOUT);\n#elif defined(__PALMOS__) && (__PALMOS__ < 0x06000000)\n  UInt32 stoptime = TimGetTicks () + (useconds / 1000000) * SysTicksPerSecond ();\n\n  while (stoptime > TimGetTicks ())\n    /* I wish there was some type of yield function here */\n    ;\n#elif defined(HAVE_WINDOWSPHONE_API)\n  struct timeval delay;\n  int sec;\n\n  sec = (int) useconds / 1000000;\n  if (sec > 0) {\n    delay.tv_sec = sec;\n    delay.tv_usec = 0;\n  }\n  else {\n    delay.tv_sec = 0;\n    delay.tv_usec = useconds;\n  }\n  select (0, 0, 0, 0, &delay);\n#elif defined(HAVE_WINAPPSTORE_API)\n  TODO\n#elif defined(WIN32)\n  Sleep (useconds / 1000);\n#elif defined(__rtems__)\n  rtems_task_wake_after (RTEMS_MICROSECONDS_TO_TICKS (useconds));\n#elif defined(__arc__)\n  struct timespec req;\n  struct timespec rem;\n\n  req.tv_sec = (int) useconds / 1000000;\n  req.tv_nsec = (int) (useconds % 1000000) * 1000;\n  nanosleep (&req, &rem);\n#else\n  struct timeval delay;\n  int sec;\n\n  sec = (int) useconds / 1000000;\n  if (sec > 0) {\n    delay.tv_sec = sec;\n    delay.tv_usec = 0;\n  }\n  else {\n    delay.tv_sec = 0;\n    delay.tv_usec = useconds;\n  }\n  select (0, 0, 0, 0, &delay);\n#endif\n}",
      "lines": 57,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "osip_strdup_without_quote": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        462,
        1
      ],
      "content": "char *\nosip_strdup_without_quote (const char *ch)\n{\n  char *copy = (char *) osip_malloc (strlen (ch) + 1);\n\n  if (copy == NULL)\n    return NULL;\n\n  /* remove leading and trailing \" */\n  if ((*ch == '\\\"')) {\n    osip_strncpy (copy, ch + 1, strlen (ch + 1));\n    osip_strncpy (copy + strlen (copy) - 1, \"\\0\", 1);\n  }\n  else\n    osip_strncpy (copy, ch, strlen (ch));\n  return copy;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "char",
        "*\nosip_strdup_without_quote (const char *ch)",
        "*"
      ]
    },
    "osip_tolower": {
      "start_point": [
        464,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "int\nosip_tolower (char *word)\n{\n#if defined(HAVE_CTYPE_H) && !defined (_WIN32_WCE)\n\n  for (; *word; word++)\n    *word = (char) tolower (*word);\n#else\n  size_t i;\n  size_t len = strlen (word);\n\n  for (i = 0; i <= len - 1; i++) {\n    if ('A' <= word[i] && word[i] <= 'Z')\n      word[i] = word[i] + 32;\n  }\n#endif\n  return OSIP_SUCCESS;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_strcasecmp": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "int\nosip_strcasecmp (const char *s1, const char *s2)\n{\n#if defined(__VXWORKS_OS__) || defined( __PSOS__)\n  while ((*s1 != '\\0') && (tolower (*s1) == tolower (*s2))) {\n    s1++;\n    s2++;\n  }\n  return (tolower (*s1) - tolower (*s2));\n#elif defined(__PALMOS__) && (__PALMOS__ < 0x06000000)\n  return StrCaselessCompare (s1, s2);\n#elif defined(__PALMOS__) || (!defined WIN32 && !defined _WIN32_WCE)\n  return strcasecmp (s1, s2);\n#else\n  return _stricmp (s1, s2);\n#endif\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_strncasecmp": {
      "start_point": [
        502,
        0
      ],
      "end_point": [
        523,
        1
      ],
      "content": "int\nosip_strncasecmp (const char *s1, const char *s2, size_t len)\n{\n#if defined(__VXWORKS_OS__) || defined( __PSOS__)\n  if (len == 0)\n    return OSIP_SUCCESS;\n  while ((len > 0) && (tolower (*s1) == tolower (*s2))) {\n    len--;\n    if ((len == 0) || (*s1 == '\\0') || (*s2 == '\\0'))\n      break;\n    s1++;\n    s2++;\n  }\n  return tolower (*s1) - tolower (*s2);\n#elif defined(__PALMOS__) && (__PALMOS__ < 0x06000000)\n  return StrNCaselessCompare (s1, s2, len);\n#elif defined(__PALMOS__) || (!defined WIN32 && !defined _WIN32_WCE)\n  return strncasecmp (s1, s2, len);\n#else\n  return _strnicmp (s1, s2, len);\n#endif\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_strcasestr": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "char *\nosip_strcasestr (const char *haystack, const char *needle)\n{\n  char c, sc;\n  size_t len;\n\n  if ((c = *needle++) != 0) {\n    c = tolower ((unsigned char) c);\n    len = strlen (needle);\n    do {\n      do {\n        if ((sc = *haystack++) == 0)\n          return (NULL);\n      } while ((char) tolower ((unsigned char) sc) != c);\n    } while (osip_strncasecmp (haystack, needle, len) != 0);\n    haystack--;\n  }\n  return (char *) haystack;\n}",
      "lines": 19,
      "depth": 16,
      "decorators": [
        "char",
        "*\nosip_strcasestr (const char *haystack, const char *needle)",
        "*"
      ]
    },
    "osip_clrspace": {
      "start_point": [
        548,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "int\nosip_clrspace (char *word)\n{\n  char *pbeg;\n  char *pend;\n  size_t len;\n\n  if (word == NULL)\n    return OSIP_UNDEFINED_ERROR;\n  if (*word == '\\0')\n    return OSIP_SUCCESS;\n  len = strlen (word);\n\n  pbeg = word;\n  while ((' ' == *pbeg) || ('\\r' == *pbeg) || ('\\n' == *pbeg) || ('\\t' == *pbeg))\n    pbeg++;\n\n  pend = word + len - 1;\n  while ((' ' == *pend) || ('\\r' == *pend) || ('\\n' == *pend) || ('\\t' == *pend)) {\n    pend--;\n    if (pend < pbeg) {\n      *word = '\\0';\n      return OSIP_SUCCESS;\n    }\n  }\n\n  /* Add terminating NULL only if we've cleared room for it */\n  if (pend + 1 <= word + (len - 1))\n    pend[1] = '\\0';\n\n  if (pbeg != word)\n    memmove (word, pbeg, pend - pbeg + 2);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "__osip_set_next_token": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "int\n__osip_set_next_token (char **dest, char *buf, int end_separator, char **next)\n{\n  char *sep;                    /* separator */\n\n  *next = NULL;\n\n  sep = buf;\n  while ((*sep != end_separator) && (*sep != '\\0') && (*sep != '\\r')\n         && (*sep != '\\n'))\n    sep++;\n  if ((*sep == '\\r') || (*sep == '\\n')) {       /* we should continue normally only if this is the separator asked! */\n    if (*sep != end_separator)\n      return OSIP_UNDEFINED_ERROR;\n  }\n  if (*sep == '\\0')\n    return OSIP_UNDEFINED_ERROR;        /* value must not end with this separator! */\n  if (sep == buf)\n    return OSIP_UNDEFINED_ERROR;        /* empty value (or several space!) */\n\n  *dest = osip_malloc (sep - (buf) + 1);\n  if (*dest == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (*dest, buf, sep - buf);\n\n  *next = sep + 1;              /* return the position right after the separator */\n  return OSIP_SUCCESS;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "__osip_set_next_token_better": {
      "start_point": [
        628,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "int\n__osip_set_next_token_better (char **dest, char *buf, int end_separator, int *forbidden_tab[], int size_tab, char **next)\n{\n  char *sep;                    /* separator */\n\n  *next = NULL;\n\n  sep = buf;\n  while ((*sep != end_separator) && (*sep != '\\0') && (*sep != '\\r')\n         && (*sep != '\\n'))\n    sep++;\n  if ((*sep == '\\r') && (*sep == '\\n')) {       /* we should continue normally only if this is the separator asked! */\n    if (*sep != end_separator)\n      return OSIP_UNDEFINED_ERROR;\n  }\n  if (*sep == '\\0')\n    return OSIP_UNDEFINED_ERROR;        /* value must not end with this separator! */\n  if (sep == buf)\n    return OSIP_UNDEFINED_ERROR;        /* empty value (or several space!) */\n\n  *dest = osip_malloc (sep - (buf) + 1);\n  if (*dest == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (*dest, buf, sep - buf);\n\n  *next = sep + 1;              /* return the position right after the separator */\n  return 1;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "__osip_quote_find": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        718,
        1
      ],
      "content": "const char *\n__osip_quote_find (const char *qstring)\n{\n  const char *quote;\n\n  quote = strchr (qstring, '\"');\n  if (quote == qstring)         /* the first char matches and is not escaped... */\n    return quote;\n\n  if (quote == NULL)\n    return NULL;                /* no quote at all... */\n\n  /* this is now the nasty cases where '\"' is escaped\n     '\" jonathan ros \\\\\\\"\"'\n     |                  |\n     '\" jonathan ros \\\\\"'\n     |                |\n     '\" jonathan ros \\\"\"'\n     |                |\n     we must count the number of preceeding '\\' */\n  {\n    int i = 1;\n\n    for (;;) {\n      if (0 == strncmp (quote - i, \"\\\\\", 1))\n        i++;\n      else {\n        if (i % 2 == 1)         /* the '\"' was not escaped */\n          return quote;\n\n        /* else continue with the next '\"' */\n        quote = strchr (quote + 1, '\"');\n        if (quote == NULL)\n          return NULL;\n        i = 1;\n      }\n      if (quote - i == qstring - 1)\n        /* example: \"\\\"john\"  */\n        /* example: \"\\\\\"jack\" */\n      {\n        /* special case where the string start with '\\' */\n        if (*qstring == '\\\\')\n          i++;                  /* an escape char was not counted */\n        if (i % 2 == 0)         /* the '\"' was not escaped */\n          return quote;\n        else {                  /* else continue with the next '\"' */\n          qstring = quote + 1;  /* reset qstring because\n                                   (*quote+1) may be also == to '\\\\' */\n          quote = strchr (quote + 1, '\"');\n          if (quote == NULL)\n            return NULL;\n          i = 1;\n        }\n\n      }\n    }\n    return NULL;\n  }\n}",
      "lines": 59,
      "depth": 15,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n__osip_quote_find (const char *qstring)",
        "*"
      ]
    },
    "osip_enquote": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        750,
        1
      ],
      "content": "char *\nosip_enquote (const char *s)\n{\n  char *rtn;\n  char *t;\n\n  t = rtn = osip_malloc (strlen (s) * 2 + 3);\n  if (rtn == NULL)\n    return NULL;\n  *t++ = '\"';\n  for (; *s != '\\0'; s++) {\n    switch (*s) {\n    case '\"':\n    case '\\\\':\n    case 0x7f:\n      *t++ = '\\\\';\n      *t++ = *s;\n      break;\n    case '\\n':\n    case '\\r':\n      *t++ = ' ';\n      break;\n    default:\n      *t++ = *s;\n      break;\n    }\n  }\n  *t++ = '\"';\n  *t++ = '\\0';\n  return rtn;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "char",
        "*\nosip_enquote (const char *s)",
        "*"
      ]
    },
    "osip_dequote": {
      "start_point": [
        752,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "void\nosip_dequote (char *s)\n{\n  size_t len;\n\n  if (*s == '\\0')\n    return;\n  if (*s != '\"')\n    return;\n  len = strlen (s);\n  memmove (s, s + 1, len--);\n  if (len > 0 && s[len - 1] == '\"')\n    s[--len] = '\\0';\n  for (; *s != '\\0'; s++, len--) {\n    if (*s == '\\\\')\n      memmove (s, s + 1, len--);\n  }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "osip_trace_initialize_func": [
      {
        "start_point": [
          779,
          0
        ],
        "end_point": [
          782,
          1
        ],
        "content": "void\nosip_trace_initialize_func (osip_trace_level_t level, osip_trace_func_t * func)\n{\n}",
        "lines": 4,
        "depth": 6,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          873,
          0
        ],
        "end_point": [
          888,
          1
        ],
        "content": "void\nosip_trace_initialize_func (osip_trace_level_t level, osip_trace_func_t * func)\n{\n  int i = 0;\n\n  trace_func = func;\n\n  /* enable all lower levels */\n  while (i < END_TRACE_LEVEL) {\n    if (i < level)\n      tracing_table[i] = LOG_TRUE;\n    else\n      tracing_table[i] = LOG_FALSE;\n    i++;\n  }\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "void"
        ]
      }
    ],
    "osip_trace_initialize_syslog": [
      {
        "start_point": [
          784,
          0
        ],
        "end_point": [
          787,
          1
        ],
        "content": "void\nosip_trace_initialize_syslog (osip_trace_level_t level, char *ident)\n{\n}",
        "lines": 4,
        "depth": 6,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          840,
          0
        ],
        "end_point": [
          857,
          1
        ],
        "content": "void\nosip_trace_initialize_syslog (osip_trace_level_t level, char *ident)\n{\n  osip_trace_level_t i = TRACE_LEVEL0;\n\n#if defined (HAVE_SYSLOG_H) && !defined(__arc__)\n  openlog (ident, LOG_CONS | LOG_PID, LOG_DAEMON);\n  use_syslog = 1;\n#endif\n  /* enable all lower levels */\n  while (i < END_TRACE_LEVEL) {\n    if (i < level)\n      tracing_table[i] = LOG_TRUE;\n    else\n      tracing_table[i] = LOG_FALSE;\n    i++;\n  }\n}",
        "lines": 18,
        "depth": 9,
        "decorators": [
          "void"
        ]
      }
    ],
    "osip_trace_initialize": [
      {
        "start_point": [
          789,
          0
        ],
        "end_point": [
          793,
          1
        ],
        "content": "int\nosip_trace_initialize (osip_trace_level_t level, FILE * file)\n{\n  return OSIP_UNDEFINED_ERROR;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          815,
          0
        ],
        "end_point": [
          838,
          1
        ],
        "content": "int\nosip_trace_initialize (osip_trace_level_t level, FILE * file)\n{\n  osip_trace_level_t i = TRACE_LEVEL0;\n\n  /* enable trace in log file by default */\n  logfile = NULL;\n  if (file != NULL)\n    logfile = file;\n#ifndef SYSTEM_LOGGER_ENABLED\n  else\n    logfile = stdout;\n#endif\n\n  /* enable all lower levels */\n  while (i < END_TRACE_LEVEL) {\n    if (i < level)\n      tracing_table[i] = LOG_TRUE;\n    else\n      tracing_table[i] = LOG_FALSE;\n    i++;\n  }\n  return 0;\n}",
        "lines": 24,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_trace_enable_level": [
      {
        "start_point": [
          795,
          0
        ],
        "end_point": [
          798,
          1
        ],
        "content": "void\nosip_trace_enable_level (osip_trace_level_t level)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          891,
          0
        ],
        "end_point": [
          895,
          1
        ],
        "content": "void\nosip_trace_enable_level (osip_trace_level_t level)\n{\n  tracing_table[level] = LOG_TRUE;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "void"
        ]
      }
    ],
    "osip_trace_disable_level": [
      {
        "start_point": [
          800,
          0
        ],
        "end_point": [
          803,
          1
        ],
        "content": "void\nosip_trace_disable_level (osip_trace_level_t level)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          898,
          0
        ],
        "end_point": [
          902,
          1
        ],
        "content": "void\nosip_trace_disable_level (osip_trace_level_t level)\n{\n  tracing_table[level] = LOG_FALSE;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "void"
        ]
      }
    ],
    "osip_is_trace_level_activate": [
      {
        "start_point": [
          805,
          0
        ],
        "end_point": [
          809,
          1
        ],
        "content": "int\nosip_is_trace_level_activate (osip_trace_level_t level)\n{\n  return LOG_FALSE;\n}",
        "lines": 5,
        "depth": 5,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          905,
          0
        ],
        "end_point": [
          909,
          1
        ],
        "content": "int\nosip_is_trace_level_activate (osip_trace_level_t level)\n{\n  return tracing_table[level];\n}",
        "lines": 5,
        "depth": 5,
        "decorators": [
          "int"
        ]
      }
    ],
    "osip_trace_enable_until_level": {
      "start_point": [
        859,
        0
      ],
      "end_point": [
        871,
        1
      ],
      "content": "void\nosip_trace_enable_until_level (osip_trace_level_t level)\n{\n  int i = 0;\n\n  while (i < END_TRACE_LEVEL) {\n    if (i < level)\n      tracing_table[i] = LOG_TRUE;\n    else\n      tracing_table[i] = LOG_FALSE;\n    i++;\n  }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "__osip_port_gettimeofday": {
      "start_point": [
        917,
        0
      ],
      "end_point": [
        926,
        1
      ],
      "content": "int\n__osip_port_gettimeofday (struct timeval *tp, void *tz)\n{\n  struct _timeb timebuffer;\n\n  _ftime (&timebuffer);\n  tp->tv_sec = (long) timebuffer.time;\n  tp->tv_usec = timebuffer.millitm * 1000;\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_trace": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        1180,
        1
      ],
      "content": "int\nosip_trace (char *filename_long, int li, osip_trace_level_t level, FILE * f, char *chfr, ...)\n{\n#ifdef ENABLE_TRACE\n  va_list ap;\n  int relative_time = 0;\n\n  char *fi = NULL;\n\n#if (defined(WIN32)  && !defined(_WIN32_WCE)) || defined(__linux) || defined(__APPLE__)\n  static struct timeval start = { 0, 0 };\n  struct timeval now;\n\n  if (start.tv_sec == 0 && start.tv_usec == 0) {\n    __osip_port_gettimeofday (&start, NULL);\n  }\n  __osip_port_gettimeofday (&now, NULL);\n\n  relative_time = (int)(1000 * (now.tv_sec - start.tv_sec));\n  if (now.tv_usec - start.tv_usec > 0)\n    relative_time = relative_time + ((now.tv_usec - start.tv_usec) / 1000);\n  else\n    relative_time = relative_time - ((start.tv_usec - now.tv_usec) / 1000);\n#endif\n\n  if (filename_long != NULL) {\n    fi = strrchr (filename_long, '/');\n    if (fi == NULL)\n      fi = strrchr (filename_long, '\\\\');\n    if (fi != NULL)\n      fi++;\n    if (fi == NULL)\n      fi = filename_long;\n  }\n\n#if !defined(WIN32) && !defined(SYSTEM_LOGGER_ENABLED)\n  if (logfile == NULL && use_syslog == 0 && trace_func == NULL) {       /* user did not initialize logger.. */\n    return 1;\n  }\n#endif\n\n  if (tracing_table[level] == LOG_FALSE)\n    return OSIP_SUCCESS;\n\n  if (f == NULL && trace_func == NULL)\n    f = logfile;\n\n  VA_START (ap, chfr);\n\n#if  defined(__VXWORKS_OS__) || defined(__rtems__)\n  /* vxworks can't have a local file */\n  f = stdout;\n#endif\n\n  if (0) {\n  }\n#ifdef ANDROID\n  else if (trace_func == 0) {\n    int lev;\n\n    switch (level) {\n    case OSIP_INFO3:\n      lev = ANDROID_LOG_DEBUG;\n      break;\n    case OSIP_INFO4:\n      lev = ANDROID_LOG_DEBUG;\n      break;\n    case OSIP_INFO2:\n      lev = ANDROID_LOG_INFO;\n      break;\n    case OSIP_INFO1:\n      lev = ANDROID_LOG_INFO;\n      break;\n    case OSIP_WARNING:\n      lev = ANDROID_LOG_WARN;\n      break;\n    case OSIP_ERROR:\n      lev = ANDROID_LOG_ERROR;\n      break;\n    case OSIP_BUG:\n      lev = ANDROID_LOG_FATAL;\n      break;\n    case OSIP_FATAL:\n      lev = ANDROID_LOG_FATAL;\n      break;\n    default:\n      lev = ANDROID_LOG_DEFAULT;\n      break;\n    }\n    __android_log_vprint (lev, \"osip2\", chfr, ap);\n  }\n#elif defined(__APPLE__)  && defined(__OBJC__)\n  else if (trace_func == 0) {\n    char buffer[MAX_LENGTH_TR];\n    int in = 0;\n\n    memset (buffer, 0, sizeof (buffer));\n    if (level == OSIP_FATAL)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| FATAL | <%s: %i> \", fi, li);\n    else if (level == OSIP_BUG)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"|  BUG  | <%s: %i> \", fi, li);\n    else if (level == OSIP_ERROR)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| ERROR | <%s: %i> \", fi, li);\n    else if (level == OSIP_WARNING)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"|WARNING| <%s: %i> \", fi, li);\n    else if (level == OSIP_INFO1)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO1 | <%s: %i> \", fi, li);\n    else if (level == OSIP_INFO2)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO2 | <%s: %i> \", fi, li);\n    else if (level == OSIP_INFO3)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO3 | <%s: %i> \", fi, li);\n    else if (level == OSIP_INFO4)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO4 | <%s: %i> \", fi, li);\n\n    vsnprintf (buffer + in, MAX_LENGTH_TR - 1 - in, chfr, ap);\n    NSLog (@\"%s\", buffer);\n  }\n#endif\n  else if (f && use_syslog == 0) {\n    if (level == OSIP_FATAL)\n      fprintf (f, \"| FATAL | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_BUG)\n      fprintf (f, \"|  BUG  | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_ERROR)\n      fprintf (f, \"| ERROR | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_WARNING)\n      fprintf (f, \"|WARNING| %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_INFO1)\n      fprintf (f, \"| INFO1 | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_INFO2)\n      fprintf (f, \"| INFO2 | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_INFO3)\n      fprintf (f, \"| INFO3 | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_INFO4)\n      fprintf (f, \"| INFO4 | %i <%s: %i> \", relative_time, fi, li);\n\n    vfprintf (f, chfr, ap);\n\n    fflush (f);\n  }\n  else if (trace_func) {\n    trace_func (fi, li, level, chfr, ap);\n  }\n\n#if defined (HAVE_SYSLOG_H) && !defined(__arc__)\n  else if (use_syslog == 1) {\n    char buffer[MAX_LENGTH_TR];\n    int in = 0;\n\n    memset (buffer, 0, sizeof (buffer));\n    if (level == OSIP_FATAL)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| FATAL | <%s: %i> \", fi, li);\n    else if (level == OSIP_BUG)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"|  BUG  | <%s: %i> \", fi, li);\n    else if (level == OSIP_ERROR)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| ERROR | <%s: %i> \", fi, li);\n    else if (level == OSIP_WARNING)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"|WARNING| <%s: %i> \", fi, li);\n    else if (level == OSIP_INFO1)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO1 | <%s: %i> \", fi, li);\n    else if (level == OSIP_INFO2)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO2 | <%s: %i> \", fi, li);\n    else if (level == OSIP_INFO3)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO3 | <%s: %i> \", fi, li);\n    else if (level == OSIP_INFO4)\n      in = snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO4 | <%s: %i> \", fi, li);\n\n    vsnprintf (buffer + in, MAX_LENGTH_TR - 1 - in, chfr, ap);\n    if (level == OSIP_FATAL)\n      syslog (LOG_ERR, \"%s\", buffer);\n    else if (level == OSIP_BUG)\n      syslog (LOG_ERR, \"%s\", buffer);\n    else if (level == OSIP_ERROR)\n      syslog (LOG_ERR, \"%s\", buffer);\n    else if (level == OSIP_WARNING)\n      syslog (LOG_WARNING, \"%s\", buffer);\n    else if (level == OSIP_INFO1)\n      syslog (LOG_INFO, \"%s\", buffer);\n    else if (level == OSIP_INFO2)\n      syslog (LOG_INFO, \"%s\", buffer);\n    else if (level == OSIP_INFO3)\n      syslog (LOG_DEBUG, \"%s\", buffer);\n    else if (level == OSIP_INFO4)\n      syslog (LOG_DEBUG, \"%s\", buffer);\n  }\n#endif\n#ifdef SYSTEM_LOGGER_ENABLED\n  else {\n    char buffer[MAX_LENGTH_TR];\n    int in = 0;\n\n#ifdef DISPLAY_TIME\n    int relative_time;\n#endif\n\n    memset (buffer, 0, sizeof (buffer));\n    if (level == OSIP_FATAL)\n      in = _snprintf (buffer, MAX_LENGTH_TR - 1, \"| FATAL | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_BUG)\n      in = _snprintf (buffer, MAX_LENGTH_TR - 1, \"|  BUG  | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_ERROR)\n      in = _snprintf (buffer, MAX_LENGTH_TR - 1, \"| ERROR | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_WARNING)\n      in = _snprintf (buffer, MAX_LENGTH_TR - 1, \"|WARNING| %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_INFO1)\n      in = _snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO1 | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_INFO2)\n      in = _snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO2 | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_INFO3)\n      in = _snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO3 | %i <%s: %i> \", relative_time, fi, li);\n    else if (level == OSIP_INFO4)\n      in = _snprintf (buffer, MAX_LENGTH_TR - 1, \"| INFO4 | %i <%s: %i> \", relative_time, fi, li);\n\n    _vsnprintf (buffer + in, MAX_LENGTH_TR - 1 - in, chfr, ap);\n#ifdef UNICODE\n    {\n      WCHAR wUnicode[MAX_LENGTH_TR * 2];\n      int size;\n\n      size = MultiByteToWideChar (CP_UTF8, 0, buffer, -1, wUnicode, MAX_LENGTH_TR * 2);\n      wUnicode[size - 2] = '\\n';\n      wUnicode[size - 1] = '\\0';\n      OutputDebugString (wUnicode);\n    }\n#else\n    OutputDebugString (buffer);\n#endif\n  }\n#endif\n\n  va_end (ap);\n#endif\n  return OSIP_SUCCESS;\n}",
      "lines": 234,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "osip_malloc": {
      "start_point": [
        1187,
        0
      ],
      "end_point": [
        1195,
        1
      ],
      "content": "void *\nosip_malloc (size_t size)\n{\n  void *ptr = malloc (size);\n\n  if (ptr != NULL)\n    memset (ptr, 0, size);\n  return ptr;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void",
        "*\nosip_malloc (size_t size)",
        "*"
      ]
    },
    "osip_realloc": {
      "start_point": [
        1198,
        0
      ],
      "end_point": [
        1202,
        1
      ],
      "content": "void *\nosip_realloc (void *ptr, size_t size)\n{\n  return realloc (ptr, size);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nosip_realloc (void *ptr, size_t size)",
        "*"
      ]
    },
    "osip_free": {
      "start_point": [
        1205,
        0
      ],
      "end_point": [
        1211,
        1
      ],
      "content": "void\nosip_free (void *ptr)\n{\n  if (ptr == NULL)\n    return;\n  free (ptr);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_set_allocators": {
      "start_point": [
        1216,
        0
      ],
      "end_point": [
        1222,
        1
      ],
      "content": "void\nosip_set_allocators (osip_malloc_func_t * malloc_func, osip_realloc_func_t * realloc_func, osip_free_func_t * free_func)\n{\n  osip_malloc_func = malloc_func;\n  osip_realloc_func = realloc_func;\n  osip_free_func = free_func;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "_cb_snprintf": {
      "start_point": [
        1237,
        0
      ],
      "end_point": [
        1254,
        1
      ],
      "content": "STATUS\n_cb_snprintf (char *buffer, int nc, int arg)\n{\n  _context *ctx = (_context *) arg;\n\n  if (ctx->max - ctx->len - nc < 1) {   /* retain 1 pos for terminating \\0 */\n    nc = ctx->max - ctx->len - 1;\n  }\n\n  if (nc > 0) {\n    memcpy (ctx->str + ctx->len, buffer, nc);\n    ctx->len += nc;\n  }\n\n  ctx->str[ctx->len] = '\\0';\n\n  return OK;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "STATUS"
      ]
    },
    "osip_vsnprintf": {
      "start_point": [
        1257,
        0
      ],
      "end_point": [
        1271,
        1
      ],
      "content": "int\nosip_vsnprintf (char *buf, int max, const char *fmt, va_list ap)\n{\n  _context ctx;\n\n  ctx.str = buf;\n  ctx.max = max;\n  ctx.len = 0;\n\n  if (fioFormatV (fmt, ap, _cb_snprintf, (int) &ctx) != OK) {\n    return OSIP_UNDEFINED_ERROR;\n  }\n\n  return ctx.len;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_snprintf": [
      {
        "start_point": [
          1273,
          0
        ],
        "end_point": [
          1283,
          1
        ],
        "content": "int\nosip_snprintf (char *buf, int max, const char *fmt, ...)\n{\n  int retval;\n  va_list ap;\n\n  va_start (ap, fmt);\n  retval = osip_vsnprintf (buf, max, fmt, ap);\n  va_end (ap);\n  return retval;\n}",
        "lines": 11,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          1290,
          0
        ],
        "end_point": [
          1306,
          1
        ],
        "content": "int\nosip_snprintf (char *buf, int max, const char *fmt, ...)\n{\n  static char buffer[1024];\n  int retval;\n  va_list ap;\n\n  buffer[0] = '\\n';\n  va_start (ap, fmt);\n  vsprintf (&(buffer[strlen (buffer)]), fmt, ap);\n  va_end (ap);\n  retval = strlen (buffer);\n  memmove (buf, buffer, max);\n  if (retval > max)\n    return OSIP_UNDEFINED_ERROR;\n  return retval;\n}",
        "lines": 17,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "_osip_malloc": [
      {
        "start_point": [
          1319,
          0
        ],
        "end_point": [
          1339,
          1
        ],
        "content": "void *\n_osip_malloc (size_t size, char *file, unsigned short line)\n{\n  void *mem;\n\n  mem = osip_malloc_func (size + 20);\n  if (mem != NULL) {\n    char *s;\n\n    memcpy (mem, &line, 2);\n    for (s = file + strlen (file); s != file; s--) {\n      if (*s == '\\\\' || *s == '/') {\n        s++;\n        break;\n      }\n    }\n    strncpy ((char *) mem + 2, s, 18);\n    return (void *) ((char *) mem + 20);\n  }\n  return NULL;\n}",
        "lines": 21,
        "depth": 12,
        "decorators": [
          "void",
          "*\n_osip_malloc (size_t size, char *file, unsigned short line)",
          "*"
        ]
      },
      {
        "start_point": [
          1384,
          0
        ],
        "end_point": [
          1388,
          1
        ],
        "content": "void *\n_osip_malloc (size_t size, char *file, unsigned short line)\n{\n  return _malloc_dbg (size, _NORMAL_BLOCK, file, line);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "void",
          "*\n_osip_malloc (size_t size, char *file, unsigned short line)",
          "*"
        ]
      }
    ],
    "_osip_free": [
      {
        "start_point": [
          1341,
          0
        ],
        "end_point": [
          1347,
          1
        ],
        "content": "void\n_osip_free (void *ptr)\n{\n  if (ptr != NULL) {\n    osip_free_func ((char *) ptr - 20);\n  }\n}",
        "lines": 7,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1390,
          0
        ],
        "end_point": [
          1394,
          1
        ],
        "content": "void\n_osip_free (void *ptr)\n{\n  _free_dbg (ptr, _NORMAL_BLOCK);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "void"
        ]
      }
    ],
    "_osip_realloc": [
      {
        "start_point": [
          1349,
          0
        ],
        "end_point": [
          1370,
          1
        ],
        "content": "void *\n_osip_realloc (void *ptr, size_t size, char *file, unsigned short line)\n{\n  void *mem;\n\n  mem = osip_realloc_func ((char *) ptr - 20, size + 20);\n  if (mem != NULL) {\n    char *s;\n\n    memcpy (mem, &line, 2);\n\n    for (s = file + strlen (file); s != file; s--) {\n      if (*s == '\\\\' || *s == '/') {\n        s++;\n        break;\n      }\n    }\n    strncpy ((char *) mem + 2, s, 18);\n    return (char *) mem + 20;\n  }\n  return NULL;\n}",
        "lines": 22,
        "depth": 12,
        "decorators": [
          "void",
          "*\n_osip_realloc (void *ptr, size_t size, char *file, unsigned short line)",
          "*"
        ]
      },
      {
        "start_point": [
          1396,
          0
        ],
        "end_point": [
          1400,
          1
        ],
        "content": "void *\n_osip_realloc (void *ptr, size_t size, char *file, unsigned short line)\n{\n  return _realloc_dbg (ptr, size, _NORMAL_BLOCK, file, line);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "void",
          "*\n_osip_realloc (void *ptr, size_t size, char *file, unsigned short line)",
          "*"
        ]
      }
    ],
    "osip_hash": {
      "start_point": [
        1405,
        0
      ],
      "end_point": [
        1415,
        1
      ],
      "content": "unsigned long\nosip_hash (const char *str)\n{\n  unsigned int hash = 5381;\n  int c;\n\n  while ((c = *str++))\n    hash = ((hash << 5) + hash) + c;\n\n  return hash & 0xFFFFFFFFu;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "osip_str_append": {
      "start_point": [
        1430,
        0
      ],
      "end_point": [
        1440,
        1
      ],
      "content": "char *\nosip_str_append (char *dst, const char *src)\n{\n  while (*src != '\\0') {\n    *dst = *src;\n    src++;\n    dst++;\n  }\n  *dst = '\\0';\n  return dst;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "char",
        "*\nosip_str_append (char *dst, const char *src)",
        "*"
      ]
    },
    "osip_strn_append": {
      "start_point": [
        1444,
        0
      ],
      "end_point": [
        1451,
        1
      ],
      "content": "char *\nosip_strn_append (char *dst, const char *src, size_t len)\n{\n  memmove ((void *) dst, (void *) src, len);\n  dst += len;\n  *dst = '\\0';\n  return dst;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "char",
        "*\nosip_strn_append (char *dst, const char *src, size_t len)",
        "*"
      ]
    },
    "osip_clrncpy": [
      {
        "start_point": [
          1459,
          0
        ],
        "end_point": [
          1514,
          1
        ],
        "content": "char *\nosip_clrncpy (char *dst, const char *src, size_t len)\n{\n  const char *pbeg;\n  const char *pend;\n  char *p;\n  size_t spaceless_length;\n\n  if (src == NULL || len == 0) {\n    *dst = '\\0';\n    return NULL;\n  }\n\n  /* find the start of relevant text */\n  pbeg = src;\n  while ((' ' == *pbeg) || ('\\r' == *pbeg) || ('\\n' == *pbeg) || ('\\t' == *pbeg))\n    pbeg++;\n\n\n  /* find the end of relevant text */\n  pend = src + len - 1;\n  while ((' ' == *pend) || ('\\r' == *pend) || ('\\n' == *pend) || ('\\t' == *pend)) {\n    pend--;\n    if (pend < pbeg) {\n      *dst = '\\0';\n      return dst;\n    }\n  }\n\n  /* if pend == pbeg there is only one char to copy */\n  spaceless_length = pend - pbeg + 1;   /* excluding any '\\0' */\n  memmove (dst, pbeg, spaceless_length);\n  p = dst + spaceless_length;\n\n#if defined(__GNUC__)\n  /* terminate the string and pad dest with zeros until len.\n     99% of the time (SPACELESS_LENGTH == LEN) or\n     (SPACELESS_LENGHT + 1 == LEN). We handle these cases efficiently.  */\n  *p = '\\0';\n  if (__builtin_expect (++spaceless_length < len, 0)) {\n    do\n      *++p = '\\0';\n    while (++spaceless_length < len);\n  }\n#else\n  /* terminate the string and pad dest with zeros until len */\n  do {\n    *p = '\\0';\n    p++;\n    spaceless_length++;\n  }\n  while (spaceless_length < len);\n#endif\n\n  return dst;\n}",
        "lines": 56,
        "depth": 11,
        "decorators": [
          "char",
          "*\nosip_clrncpy (char *dst, const char *src, size_t len)",
          "*"
        ]
      },
      {
        "start_point": [
          1518,
          0
        ],
        "end_point": [
          1524,
          1
        ],
        "content": "char *\nosip_clrncpy (char *dst, const char *src, size_t len)\n{\n  osip_strncpy (dst, src, len);\n  osip_clrspace (dst);\n  return dst;\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "char",
          "*\nosip_clrncpy (char *dst, const char *src, size_t len)",
          "*"
        ]
      }
    ]
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_proxy_authenticate.c": {
    "osip_message_set_proxy_authenticate": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nosip_message_set_proxy_authenticate (osip_message_t * sip, const char *hvalue)\n{\n  osip_proxy_authenticate_t *proxy_authenticate;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_proxy_authenticate_init (&(proxy_authenticate));\n  if (i != 0)\n    return i;\n  i = osip_proxy_authenticate_parse (proxy_authenticate, hvalue);\n  if (i != 0) {\n    osip_proxy_authenticate_free (proxy_authenticate);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->proxy_authenticates, proxy_authenticate, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_proxy_authenticate": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nosip_message_get_proxy_authenticate (const osip_message_t * sip, int pos, osip_proxy_authenticate_t ** dest)\n{\n  osip_proxy_authenticate_t *proxy_authenticate;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->proxy_authenticates) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n\n  proxy_authenticate = (osip_proxy_authenticate_t *)\n    osip_list_get (&sip->proxy_authenticates, pos);\n\n  *dest = proxy_authenticate;\n  return pos;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_proxy_authentication_info.c": {
    "osip_message_set_proxy_authentication_info": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nosip_message_set_proxy_authentication_info (osip_message_t * sip, const char *hvalue)\n{\n  osip_proxy_authentication_info_t *proxy_authentication_info;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_proxy_authentication_info_init (&(proxy_authentication_info));\n  if (i != 0)\n    return i;\n  i = osip_proxy_authentication_info_parse (proxy_authentication_info, hvalue);\n  if (i != 0) {\n    osip_proxy_authentication_info_free (proxy_authentication_info);\n    return i;\n  }\n  sip->message_property = 2;\n\n  osip_list_add (&sip->proxy_authentication_infos, proxy_authentication_info, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_proxy_authentication_info": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nosip_message_get_proxy_authentication_info (const osip_message_t * sip, int pos, osip_proxy_authentication_info_t ** dest)\n{\n  osip_proxy_authentication_info_t *proxy_authentication_info;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->proxy_authentication_infos) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n\n  proxy_authentication_info = (osip_proxy_authentication_info_t *)\n    osip_list_get (&sip->proxy_authentication_infos, pos);\n\n  *dest = proxy_authentication_info;\n  return pos;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_proxy_authorization.c": {
    "osip_message_set_proxy_authorization": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nosip_message_set_proxy_authorization (osip_message_t * sip, const char *hvalue)\n{\n  osip_proxy_authorization_t *proxy_authorization;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_proxy_authorization_init (&proxy_authorization);\n  if (i != 0)\n    return i;\n  i = osip_proxy_authorization_parse (proxy_authorization, hvalue);\n  if (i != 0) {\n    osip_proxy_authorization_free (proxy_authorization);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->proxy_authorizations, proxy_authorization, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_proxy_authorization": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nosip_message_get_proxy_authorization (const osip_message_t * sip, int pos, osip_proxy_authorization_t ** dest)\n{\n  osip_proxy_authorization_t *proxy_authorization;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->proxy_authorizations) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  proxy_authorization = (osip_proxy_authorization_t *) osip_list_get (&sip->proxy_authorizations, pos);\n  *dest = proxy_authorization;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_record_route.c": {
    "osip_record_route_init": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\nosip_record_route_init (osip_record_route_t ** record_route)\n{\n  return osip_from_init ((osip_from_t **) record_route);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_record_route": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nosip_message_set_record_route (osip_message_t * sip, const char *hvalue)\n{\n  osip_record_route_t *record_route;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_record_route_init (&record_route);\n  if (i != 0)\n    return i;\n  i = osip_record_route_parse (record_route, hvalue);\n  if (i != 0) {\n    osip_record_route_free (record_route);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->record_routes, record_route, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_record_route": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nosip_message_get_record_route (const osip_message_t * sip, int pos, osip_record_route_t ** dest)\n{\n  osip_record_route_t *record_route;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->record_routes) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  record_route = (osip_record_route_t *) osip_list_get (&sip->record_routes, pos);\n  *dest = record_route;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_record_route_parse": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nosip_record_route_parse (osip_record_route_t * record_route, const char *hvalue)\n{\n  return osip_from_parse ((osip_from_t *) record_route, hvalue);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_record_route_to_str": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "int\nosip_record_route_to_str (const osip_record_route_t * record_route, char **dest)\n{\n  char *url;\n  char *buf;\n  int i;\n  size_t len;\n\n  *dest = NULL;\n  if ((record_route == NULL) || (record_route->url == NULL))\n    return OSIP_BADPARAMETER;\n\n  i = osip_uri_to_str (record_route->url, &url);\n  if (i != 0)\n    return i;\n\n  if (record_route->displayname == NULL)\n    len = strlen (url) + 5;\n  else\n    len = strlen (url) + strlen (record_route->displayname) + 5;\n\n  buf = (char *) osip_malloc (len);\n  if (buf == NULL) {\n    osip_free (url);\n    return OSIP_NOMEM;\n  }\n\n  /* route and record-route always use brackets */\n  if (record_route->displayname != NULL)\n    sprintf (buf, \"%s <%s>\", record_route->displayname, url);\n  else\n    sprintf (buf, \"<%s>\", url);\n  osip_free (url);\n\n  {\n    size_t plen;\n    char *tmp;\n    osip_list_iterator_t it;\n    osip_generic_param_t *u_param = (osip_generic_param_t*) osip_list_get_first(&record_route->gen_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n      if (u_param->gvalue == NULL)\n        plen = strlen (u_param->gname) + 2;\n      else\n        plen = strlen (u_param->gname) + strlen (u_param->gvalue) + 3;\n      len = len + plen;\n      buf = (char *) osip_realloc (buf, len);\n      tmp = buf;\n      tmp = tmp + strlen (tmp);\n      if (u_param->gvalue == NULL)\n        snprintf (tmp, len - (tmp - buf), \";%s\", u_param->gname);\n      else\n        snprintf (tmp, len - (tmp - buf), \";%s=%s\", u_param->gname, u_param->gvalue);\n      u_param = (osip_generic_param_t *) osip_list_get_next(&it);\n    }\n  }\n  *dest = buf;\n  return OSIP_SUCCESS;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_record_route_free": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\nosip_record_route_free (osip_record_route_t * record_route)\n{\n  osip_from_free ((osip_from_t *) record_route);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_route.c": {
    "osip_route_init": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\nosip_route_init (osip_route_t ** route)\n{\n  return osip_from_init ((osip_from_t **) route);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_route": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nosip_message_set_route (osip_message_t * sip, const char *hvalue)\n{\n  osip_route_t *route;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n#ifdef __VXWORKS_OS__\n  i = osip_route_init2 (&route);\n#else\n  i = osip_route_init (&route);\n#endif\n  if (i != 0)\n    return i;\n  i = osip_route_parse (route, hvalue);\n  if (i != 0) {\n    osip_route_free (route);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->routes, route, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_route": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nosip_message_get_route (const osip_message_t * sip, int pos, osip_route_t ** dest)\n{\n  osip_route_t *route;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->routes) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n  route = (osip_route_t *) osip_list_get (&sip->routes, pos);\n  *dest = route;\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_route_parse": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nosip_route_parse (osip_route_t * route, const char *hvalue)\n{\n  return osip_from_parse ((osip_from_t *) route, hvalue);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_route_to_str": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nosip_route_to_str (const osip_route_t * route, char **dest)\n{\n  /* we can't use osip_from_to_str(): route and record_route */\n  /* always use brackets. */\n  return osip_record_route_to_str ((osip_record_route_t *) route, dest);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_route_free": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void\nosip_route_free (osip_route_t * route)\n{\n  osip_from_free ((osip_from_t *) route);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_to.c": {
    "osip_to_init": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nosip_to_init (osip_to_t ** to)\n{\n  return osip_from_init ((osip_from_t **) to);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_to": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nosip_message_set_to (osip_message_t * sip, const char *hvalue)\n{\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  if (sip->to != NULL)\n    return OSIP_SYNTAXERROR;\n  i = osip_to_init (&(sip->to));\n  if (i != 0)\n    return i;\n  sip->message_property = 2;\n  i = osip_to_parse (sip->to, hvalue);\n  if (i != 0) {\n    osip_to_free (sip->to);\n    sip->to = NULL;\n    return i;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_to": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "osip_to_t *\nosip_message_get_to (const osip_message_t * sip)\n{\n  return sip->to;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "osip_to_t",
        "*\nosip_message_get_to (const osip_message_t * sip)",
        "*"
      ]
    },
    "osip_to_parse": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nosip_to_parse (osip_to_t * to, const char *hvalue)\n{\n  return osip_from_parse ((osip_from_t *) to, hvalue);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_to_to_str": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nosip_to_to_str (const osip_to_t * to, char **dest)\n{\n  return osip_from_to_str ((osip_from_t *) to, dest);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "osip_to_free": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nosip_to_free (osip_to_t * to)\n{\n  osip_from_free ((osip_from_t *) to);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "osip_to_clone": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int\nosip_to_clone (const osip_to_t * to, osip_to_t ** dest)\n{\n  return osip_from_clone ((osip_from_t *) to, (osip_from_t **) dest);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_to_tag_match": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "int\nosip_to_tag_match (osip_to_t * to1, osip_to_t * to2)\n{\n  return osip_from_tag_match ((osip_from_t *) to1, (osip_from_t *) to2);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_uri.c": {
    "osip_uri_init": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nosip_uri_init (osip_uri_t ** url)\n{\n  *url = (osip_uri_t *) osip_malloc (sizeof (osip_uri_t));\n  if (*url == NULL)\n    return OSIP_NOMEM;\n  (*url)->scheme = NULL;\n  (*url)->username = NULL;\n  (*url)->password = NULL;\n  (*url)->host = NULL;\n  (*url)->port = NULL;\n\n  osip_list_init (&(*url)->url_params);\n\n  osip_list_init (&(*url)->url_headers);\n\n  (*url)->string = NULL;\n  return OSIP_SUCCESS;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "next_separator": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "const char *\nnext_separator (const char *ch, int separator_osip_to_find, int before_separator)\n{\n  const char *ind;\n  const char *tmp;\n\n  ind = strchr (ch, separator_osip_to_find);\n  if (ind == NULL)\n    return NULL;\n\n  tmp = NULL;\n  if (before_separator != 0)\n    tmp = strchr (ch, before_separator);\n\n  if (tmp != NULL) {\n    if (ind < tmp)\n      return ind;\n  }\n  else\n    return ind;\n\n  return NULL;\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nnext_separator (const char *ch, int separator_osip_to_find, int before_separator)",
        "*"
      ]
    },
    "osip_uri_parse": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "int\nosip_uri_parse (osip_uri_t * url, const char *buf)\n{\n  const char *username;\n  const char *password;\n  const char *host;\n  const char *port;\n  const char *params;\n  const char *headers;\n  const char *tmp;\n  int i;\n  \n  /* basic tests */\n  if (buf == NULL || buf[0] == '\\0')\n    return OSIP_BADPARAMETER;\n\n  tmp = strchr (buf, ':');\n  if (tmp == NULL)\n    return OSIP_SYNTAXERROR;\n\n  if (tmp - buf < 2)\n    return OSIP_SYNTAXERROR;\n\n  i=0;\n  while (buf+i<tmp) {\n    if (!osip_is_alpha(buf[i]))\n      return OSIP_SYNTAXERROR;\n    i++;\n  }\n  \n  url->scheme = (char *) osip_malloc (tmp - buf + 1);\n  if (url->scheme == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (url->scheme, buf, tmp - buf);\n\n  if (strchr (url->scheme, ' ') != NULL) {\n    return OSIP_SYNTAXERROR;\n  }\n\n  if (strlen (url->scheme) < 3 || (0 != osip_strncasecmp (url->scheme, \"sip\", 3)\n                                   && 0 != osip_strncasecmp (url->scheme, \"sips\", 4))) {        /* Is not a sipurl ! */\n    size_t i = strlen (tmp + 1);\n\n    if (i < 2)\n      return OSIP_SYNTAXERROR;\n    url->string = (char *) osip_malloc (i + 1);\n    if (url->string == NULL)\n      return OSIP_NOMEM;\n    osip_strncpy (url->string, tmp + 1, i);\n    return OSIP_SUCCESS;\n  }\n\n  /*  law number 1:\n     if ('?' exists && is_located_after '@')\n     or   if ('?' exists && '@' is not there -no username-)\n     =====>  HEADER_PARAM EXIST\n     =====>  start at index(?)\n     =====>  end at the end of url\n   */\n\n  /* find the beginning of host */\n  username = strchr (buf, ':');\n  /* if ':' does not exist, the url is not valid */\n  if (username == NULL)\n    return OSIP_SYNTAXERROR;\n\n  host = strchr (buf, '@');\n\n  if (host == NULL)\n    host = username;\n  else if (username[1] == '@')  /* username is empty */\n    host = username + 1;\n  else\n    /* username exists */\n  {\n    password = next_separator (username + 1, ':', '@');\n    if (password == NULL)\n      password = host;\n    else\n      /* password exists */\n    {\n      if (host - password < 2)\n        return OSIP_SYNTAXERROR;\n      url->password = (char *) osip_malloc (host - password);\n      if (url->password == NULL)\n        return OSIP_NOMEM;\n      osip_strncpy (url->password, password + 1, host - password - 1);\n      __osip_uri_unescape (url->password);\n    }\n    if (password - username < 2)\n      return OSIP_SYNTAXERROR;\n    {\n      url->username = (char *) osip_malloc (password - username);\n      if (url->username == NULL)\n        return OSIP_NOMEM;\n      osip_strncpy (url->username, username + 1, password - username - 1);\n      __osip_uri_unescape (url->username);\n    }\n  }\n\n\n  /* search for header after host */\n  headers = strchr (host, '?');\n\n  if (headers == NULL)\n    headers = buf + strlen (buf);\n  else\n    /* headers exist */\n    osip_uri_parse_headers (url, headers);\n\n\n  /* search for params after host */\n  params = strchr (host, ';');  /* search for params after host */\n  if (params == NULL)\n    params = headers;\n  else\n    /* params exist */\n  {\n    char *tmpbuf;\n\n    if (headers - params + 1 < 2)\n      return OSIP_SYNTAXERROR;\n    tmpbuf = osip_malloc (headers - params + 1);\n    if (tmpbuf == NULL)\n      return OSIP_NOMEM;\n    tmpbuf = osip_strncpy (tmpbuf, params, headers - params);\n    osip_uri_parse_params (url, tmpbuf);\n    osip_free (tmpbuf);\n  }\n\n  port = params - 1;\n  while (port > host && *port != ']' && *port != ':')\n    port--;\n  if (*port == ':') {\n    if (host == port)\n      port = params;\n    else {\n      if ((params - port < 2) || (params - port > 8))\n        return OSIP_SYNTAXERROR;        /* error cases */\n      url->port = (char *) osip_malloc (params - port);\n      if (url->port == NULL)\n        return OSIP_NOMEM;\n      osip_clrncpy (url->port, port + 1, params - port - 1);\n    }\n  }\n  else\n    port = params;\n  /* adjust port for ipv6 address */\n  tmp = port;\n  while (tmp > host && *tmp != ']')\n    tmp--;\n  if (*tmp == ']') {\n    port = tmp;\n    while (host < port && *host != '[')\n      host++;\n    if (host >= port)\n      return OSIP_SYNTAXERROR;\n  }\n\n  if (port - host < 2)\n    return OSIP_SYNTAXERROR;\n  url->host = (char *) osip_malloc (port - host);\n  if (url->host == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (url->host, host + 1, port - host - 1);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 168,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_uri_set_scheme": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "void\nosip_uri_set_scheme (osip_uri_t * url, char *scheme)\n{\n  if (url == NULL)\n    return;\n  url->scheme = scheme;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_uri_get_scheme": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "char *\nosip_uri_get_scheme (osip_uri_t * url)\n{\n  if (url == NULL)\n    return NULL;\n  return url->scheme;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_uri_get_scheme (osip_uri_t * url)",
        "*"
      ]
    },
    "osip_uri_set_username": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "void\nosip_uri_set_username (osip_uri_t * url, char *username)\n{\n  if (url == NULL)\n    return;\n  url->username = username;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_uri_get_username": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "char *\nosip_uri_get_username (osip_uri_t * url)\n{\n  if (url == NULL)\n    return NULL;\n  return url->username;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_uri_get_username (osip_uri_t * url)",
        "*"
      ]
    },
    "osip_uri_set_password": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "void\nosip_uri_set_password (osip_uri_t * url, char *password)\n{\n  if (url == NULL)\n    return;\n  url->password = password;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_uri_get_password": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "char *\nosip_uri_get_password (osip_uri_t * url)\n{\n  if (url == NULL)\n    return NULL;\n  return url->password;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_uri_get_password (osip_uri_t * url)",
        "*"
      ]
    },
    "osip_uri_set_host": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "void\nosip_uri_set_host (osip_uri_t * url, char *host)\n{\n  if (url == NULL)\n    return;\n  url->host = host;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_uri_get_host": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "char *\nosip_uri_get_host (osip_uri_t * url)\n{\n  if (url == NULL)\n    return NULL;\n  return url->host;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_uri_get_host (osip_uri_t * url)",
        "*"
      ]
    },
    "osip_uri_set_port": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "void\nosip_uri_set_port (osip_uri_t * url, char *port)\n{\n  if (url == NULL)\n    return;\n  url->port = port;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "osip_uri_get_port": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "char *\nosip_uri_get_port (osip_uri_t * url)\n{\n  if (url == NULL)\n    return NULL;\n  return url->port;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_uri_get_port (osip_uri_t * url)",
        "*"
      ]
    },
    "osip_uri_parse_headers": {
      "start_point": [
        350,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "int\nosip_uri_parse_headers (osip_uri_t * url, const char *headers)\n{\n  int i;\n  const char *_and;\n  const char *equal;\n\n  /* find '=' wich is the separator for one header */\n  /* find ';' wich is the separator for multiple headers */\n\n  equal = strchr (headers, '=');\n  _and = strchr (headers + 1, '&');\n\n  if (equal == NULL)            /* each header MUST have a value */\n    return OSIP_SYNTAXERROR;\n\n  do {\n    char *hname;\n    char *hvalue;\n\n    hname = (char *) osip_malloc (equal - headers);\n    if (hname == NULL)\n      return OSIP_NOMEM;\n    osip_strncpy (hname, headers + 1, equal - headers - 1);\n    __osip_uri_unescape (hname);\n\n    if (_and != NULL) {\n      if (_and - equal < 2) {\n        osip_free (hname);\n        return OSIP_SYNTAXERROR;\n      }\n      hvalue = (char *) osip_malloc (_and - equal);\n      if (hvalue == NULL) {\n        osip_free (hname);\n        return OSIP_NOMEM;\n      }\n      osip_strncpy (hvalue, equal + 1, _and - equal - 1);\n      __osip_uri_unescape (hvalue);\n    }\n    else {                      /* this is for the last header (no _and...) */\n      if (headers + strlen (headers) - equal + 1 < 2) {\n        osip_free (hname);\n        return OSIP_SYNTAXERROR;\n      }\n      hvalue = (char *) osip_malloc (headers + strlen (headers) - equal + 1);\n      if (hvalue == NULL) {\n        osip_free (hname);\n        return OSIP_NOMEM;\n      }\n      osip_strncpy (hvalue, equal + 1, headers + strlen (headers) - equal);\n      __osip_uri_unescape (hvalue);\n    }\n\n    i = osip_uri_uheader_add (url, hname, hvalue);\n    if (i != OSIP_SUCCESS) {\n      osip_free (hname);\n      osip_free (hvalue);\n      return i;\n    }\n\n    if (_and == NULL)            /* we just set the last header */\n      equal = NULL;\n    else {                      /* continue on next header */\n\n      headers = _and;\n      equal = strchr (headers, '=');\n      _and = strchr (headers + 1, '&');\n      if (equal == NULL)        /* each header MUST have a value */\n        return OSIP_SYNTAXERROR;\n    }\n  }\n  while (equal != NULL);\n  return OSIP_SUCCESS;\n}",
      "lines": 74,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "osip_uri_parse_params": {
      "start_point": [
        425,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "int\nosip_uri_parse_params (osip_uri_t * url, const char *params)\n{\n  int i;\n  char *pname;\n  char *pvalue;\n\n  const char *comma;\n  const char *equal;\n\n  /* find '=' wich is the separator for one param */\n  /* find ';' wich is the separator for multiple params */\n\n  equal = next_separator (params + 1, '=', ';');\n  comma = strchr (params + 1, ';');\n\n  while (comma != NULL) {\n    if (equal == NULL) {\n      equal = comma;\n      pvalue = NULL;\n    }\n    else {\n      if (comma - equal < 2)\n        return OSIP_SYNTAXERROR;\n      pvalue = (char *) osip_malloc (comma - equal);\n      if (pvalue == NULL)\n        return OSIP_NOMEM;\n      osip_strncpy (pvalue, equal + 1, comma - equal - 1);\n      __osip_uri_unescape (pvalue);\n    }\n\n    if (equal - params < 2) {\n      osip_free (pvalue);\n      return OSIP_SYNTAXERROR;\n    }\n    pname = (char *) osip_malloc (equal - params);\n    if (pname == NULL) {\n      osip_free (pvalue);\n      return OSIP_NOMEM;\n    }\n    osip_strncpy (pname, params + 1, equal - params - 1);\n    __osip_uri_unescape (pname);\n\n    i = osip_uri_uparam_add (url, pname, pvalue);\n    if (i != OSIP_SUCCESS) {\n      osip_free (pname);\n      osip_free (pvalue);\n      return OSIP_NOMEM;\n    }\n\n    params = comma;\n    equal = next_separator (params + 1, '=', ';');\n    comma = strchr (params + 1, ';');\n  }\n\n  /* this is the last header (comma==NULL) */\n  comma = params + strlen (params);\n\n  if (equal == NULL) {\n    equal = comma;              /* at the end */\n    pvalue = NULL;\n  }\n  else {\n    if (comma - equal < 2)\n      return OSIP_SYNTAXERROR;\n    pvalue = (char *) osip_malloc (comma - equal);\n    if (pvalue == NULL)\n      return OSIP_NOMEM;\n    osip_strncpy (pvalue, equal + 1, comma - equal - 1);\n    __osip_uri_unescape (pvalue);\n  }\n\n  if (equal - params < 2) {\n    osip_free (pvalue);\n    return OSIP_SYNTAXERROR;\n  }\n  pname = (char *) osip_malloc (equal - params);\n  if (pname == NULL) {\n    osip_free (pvalue);\n    return OSIP_NOMEM;\n  }\n  osip_strncpy (pname, params + 1, equal - params - 1);\n  __osip_uri_unescape (pname);\n\n  i = osip_uri_uparam_add (url, pname, pvalue);\n  if (i != OSIP_SUCCESS) {\n    osip_free (pname);\n    osip_free (pvalue);\n    return OSIP_NOMEM;\n  }\n\n  return OSIP_SUCCESS;\n}",
      "lines": 93,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_uri_to_str": {
      "start_point": [
        519,
        0
      ],
      "end_point": [
        708,
        1
      ],
      "content": "int\nosip_uri_to_str (const osip_uri_t * url, char **dest)\n{\n  char *buf;\n  size_t len;\n  size_t plen;\n  char *tmp;\n  const char *scheme;\n\n  *dest = NULL;\n  if (url == NULL)\n    return OSIP_BADPARAMETER;\n  if (url->host == NULL && url->string == NULL)\n    return OSIP_BADPARAMETER;\n  if (url->scheme == NULL && url->string != NULL)\n    return OSIP_BADPARAMETER;\n  if (url->string == NULL && url->scheme == NULL)\n    scheme = \"sip\";             /* default is sipurl */\n  else\n    scheme = url->scheme;\n\n  if (url->string != NULL) {\n    buf = (char *) osip_malloc (strlen (scheme) + strlen (url->string) + 3);\n    if (buf == NULL)\n      return OSIP_NOMEM;\n    *dest = buf;\n    sprintf (buf, \"%s:\", scheme);\n    buf = buf + strlen (scheme) + 1;\n    sprintf (buf, \"%s\", url->string);\n    return OSIP_SUCCESS;\n  }\n\n  len = strlen (scheme) + 1 + strlen (url->host) + 5;\n  if (url->username != NULL)\n    len = len + (strlen (url->username) * 3) + 1;       /* count escaped char */\n  if (url->password != NULL)\n    len = len + (strlen (url->password) * 3) + 1;\n  if (url->port != NULL)\n    len = len + strlen (url->port) + 3;\n\n  buf = (char *) osip_malloc (len);\n  if (buf == NULL)\n    return OSIP_NOMEM;\n  tmp = buf;\n\n  sprintf (tmp, \"%s:\", scheme);\n  tmp = tmp + strlen (tmp);\n\n  if (url->username != NULL) {\n    char *tmp2 = __osip_uri_escape_userinfo (url->username);\n\n    if (tmp2 == NULL) {\n      osip_free (buf);\n      return OSIP_NOMEM;\n    }\n\n    sprintf (tmp, \"%s\", tmp2);\n    osip_free (tmp2);\n    tmp = tmp + strlen (tmp);\n  }\n  if ((url->password != NULL) && (url->username != NULL)) {     /* be sure that when a password is given, a username is also given */\n    char *tmp2 = __osip_uri_escape_password (url->password);\n\n    if (tmp2 == NULL) {\n      osip_free (buf);\n      return OSIP_NOMEM;\n    }\n\n    sprintf (tmp, \":%s\", tmp2);\n    osip_free (tmp2);\n    tmp = tmp + strlen (tmp);\n  }\n  if (url->username != NULL) {  /* we add a '@' only when username is present... */\n    sprintf (tmp, \"@\");\n    tmp++;\n  }\n  if (strchr (url->host, ':') != NULL) {\n    sprintf (tmp, \"[%s]\", url->host);\n    tmp = tmp + strlen (tmp);\n  }\n  else {\n    sprintf (tmp, \"%s\", url->host);\n    tmp = tmp + strlen (tmp);\n  }\n  if (url->port != NULL) {\n    sprintf (tmp, \":%s\", url->port);\n    tmp = tmp + strlen (tmp);\n  }\n\n  {\n    osip_list_iterator_t it;\n    osip_uri_param_t *u_param = (osip_uri_param_t*) osip_list_get_first(&url->url_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n\n      char *tmp1;\n      char *tmp2 = NULL;\n      char *previous_buf;\n\n      if (osip_strcasecmp(u_param->gname, \"x-obr\")==0 || osip_strcasecmp(u_param->gname, \"x-obp\")==0) {\n        /* x-obr and x-obp are internal params used by exosip: they must not appear in messages */\n        u_param = (osip_uri_param_t *) osip_list_get_next(&it);\n        continue;\n      }\n\n      tmp1 = __osip_uri_escape_uri_param (u_param->gname);\n      if (tmp1 == NULL) {\n        osip_free (buf);\n        return OSIP_SYNTAXERROR;\n      }\n      if (u_param->gvalue == NULL)\n        plen = strlen (tmp1) + 2;\n      else {\n        tmp2 = __osip_uri_escape_uri_param (u_param->gvalue);\n        if (tmp2 == NULL) {\n          osip_free (tmp1);\n          osip_free (buf);\n          return OSIP_SYNTAXERROR;\n        }\n        plen = strlen (tmp1) + strlen (tmp2) + 3;\n      }\n      len = len + plen;\n      previous_buf = buf;\n      buf = (char *) osip_realloc (buf, len);\n      if (buf == NULL) {\n        osip_free (previous_buf);\n        osip_free (tmp1);\n        osip_free (tmp2);\n        return OSIP_NOMEM;\n      }\n      tmp = buf;\n      tmp = tmp + strlen (tmp);\n      if (u_param->gvalue == NULL)\n        sprintf (tmp, \";%s\", tmp1);\n      else {\n        sprintf (tmp, \";%s=%s\", tmp1, tmp2);\n        osip_free (tmp2);\n      }\n      osip_free (tmp1);\n      u_param = (osip_uri_param_t *) osip_list_get_next(&it);\n    }\n  }\n\n  {\n    osip_list_iterator_t it;\n    osip_uri_header_t *u_header = (osip_uri_header_t*) osip_list_get_first(&url->url_headers, &it);\n    while (u_header != OSIP_SUCCESS) {\n      char *tmp1;\n      char *tmp2;\n      char *previous_buf;\n\n      tmp1 = __osip_uri_escape_header_param (u_header->gname);\n\n      if (tmp1 == NULL) {\n        osip_free (buf);\n        return OSIP_SYNTAXERROR;\n      }\n\n      tmp2 = __osip_uri_escape_header_param (u_header->gvalue);\n\n      if (tmp2 == NULL) {\n        osip_free (tmp1);\n        osip_free (buf);\n        return OSIP_SYNTAXERROR;\n      }\n      plen = strlen (tmp1) + strlen (tmp2) + 4;\n\n      len = len + plen;\n      previous_buf = buf;\n      buf = (char *) osip_realloc (buf, len);\n      if (buf == NULL) {\n        osip_free (previous_buf);\n        osip_free (tmp1);\n        osip_free (tmp2);\n        return OSIP_NOMEM;\n      }\n      tmp = buf;\n      tmp = tmp + strlen (tmp);\n      if (it.pos == 0)\n        snprintf (tmp, len - (tmp - buf), \"?%s=%s\", tmp1, tmp2);\n      else\n        snprintf (tmp, len - (tmp - buf), \"&%s=%s\", tmp1, tmp2);\n      osip_free (tmp1);\n      osip_free (tmp2);\n      u_header = (osip_uri_header_t *) osip_list_get_next(&it);\n    }\n  }\n\n  *dest = buf;\n  return OSIP_SUCCESS;\n}",
      "lines": 190,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "osip_uri_free": {
      "start_point": [
        711,
        0
      ],
      "end_point": [
        737,
        1
      ],
      "content": "void\nosip_uri_free (osip_uri_t * url)\n{\n  if (url == NULL)\n    return;\n  osip_free (url->scheme);\n  osip_free (url->username);\n  osip_free (url->password);\n  osip_free (url->host);\n  osip_free (url->port);\n\n  osip_uri_param_freelist (&url->url_params);\n\n  {\n    osip_uri_header_t *u_header;\n\n    while (!osip_list_eol (&url->url_headers, 0)) {\n      u_header = (osip_uri_header_t *) osip_list_get (&url->url_headers, 0);\n      osip_list_remove (&url->url_headers, 0);\n      osip_uri_header_free (u_header);\n    }\n  }\n\n  osip_free (url->string);\n\n  osip_free (url);\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "osip_uri_clone": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "int\nosip_uri_clone (const osip_uri_t * url, osip_uri_t ** dest)\n{\n  int i;\n  osip_uri_t *ur;\n\n  *dest = NULL;\n  if (url == NULL)\n    return OSIP_BADPARAMETER;\n  if (url->host == NULL && url->string == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_uri_init (&ur);\n  if (i != 0)                   /* allocation failed */\n    return i;\n  if (url->scheme != NULL)\n    ur->scheme = osip_strdup (url->scheme);\n  if (url->username != NULL)\n    ur->username = osip_strdup (url->username);\n  if (url->password != NULL)\n    ur->password = osip_strdup (url->password);\n  if (url->host != NULL)\n    ur->host = osip_strdup (url->host);\n  if (url->port != NULL)\n    ur->port = osip_strdup (url->port);\n  if (url->string != NULL)\n    ur->string = osip_strdup (url->string);\n\n  i = osip_list_clone (&url->url_params, &ur->url_params, (int (*)(void *, void **)) &osip_uri_param_clone);\n  if (i != 0) {\n    osip_uri_free (ur);\n    return i;\n  }\n  i = osip_list_clone (&url->url_headers, &ur->url_headers, (int (*)(void *, void **)) &osip_uri_param_clone);\n  if (i != 0) {\n    osip_uri_free (ur);\n    return i;\n  }\n  *dest = ur;\n  return OSIP_SUCCESS;\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_uri_param_init": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        790,
        1
      ],
      "content": "int\nosip_uri_param_init (osip_uri_param_t ** url_param)\n{\n  *url_param = (osip_uri_param_t *) osip_malloc (sizeof (osip_uri_param_t));\n  if (*url_param == NULL)\n    return OSIP_NOMEM;\n  (*url_param)->gname = NULL;\n  (*url_param)->gvalue = NULL;\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_uri_param_free": {
      "start_point": [
        792,
        0
      ],
      "end_point": [
        798,
        1
      ],
      "content": "void\nosip_uri_param_free (osip_uri_param_t * url_param)\n{\n  osip_free (url_param->gname);\n  osip_free (url_param->gvalue);\n  osip_free (url_param);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "osip_uri_param_set": {
      "start_point": [
        800,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "int\nosip_uri_param_set (osip_uri_param_t * url_param, char *pname, char *pvalue)\n{\n  url_param->gname = pname;\n  /* not needed for url, but for all other generic params */\n  osip_clrspace (url_param->gname);\n  url_param->gvalue = pvalue;\n  if (url_param->gvalue != NULL)\n    osip_clrspace (url_param->gvalue);\n  return OSIP_SUCCESS;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_uri_param_add": {
      "start_point": [
        812,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "int\nosip_uri_param_add (osip_list_t * url_params, char *pname, char *pvalue)\n{\n  int i;\n  osip_uri_param_t *url_param;\n\n  i = osip_uri_param_init (&url_param);\n  if (i != 0)\n    return i;\n  i = osip_uri_param_set (url_param, pname, pvalue);\n  if (i != 0) {\n    osip_uri_param_free (url_param);\n    return i;\n  }\n  osip_list_add (url_params, url_param, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_uri_param_freelist": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "void\nosip_uri_param_freelist (osip_list_t * params)\n{\n  osip_uri_param_t *u_param;\n\n  while (!osip_list_eol (params, 0)) {\n    u_param = (osip_uri_param_t *) osip_list_get (params, 0);\n    osip_list_remove (params, 0);\n    osip_uri_param_free (u_param);\n  }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "osip_uri_param_get_byname": {
      "start_point": [
        842,
        0
      ],
      "end_point": [
        868,
        1
      ],
      "content": "int\nosip_uri_param_get_byname (osip_list_t * params, char *pname, osip_uri_param_t ** url_param)\n{\n  size_t pname_len;\n  osip_uri_param_t *u_param;\n  osip_list_iterator_t it;\n    \n  *url_param = NULL;\n  if (pname == NULL)\n    return OSIP_BADPARAMETER;\n  pname_len = strlen (pname);\n  if (pname_len <= 0)\n    return OSIP_BADPARAMETER;\n\n  u_param = (osip_uri_param_t*) osip_list_get_first(params, &it);\n  while (u_param != OSIP_SUCCESS) {\n    size_t len;\n\n    len = strlen (u_param->gname);\n    if (pname_len == len && osip_strncasecmp (u_param->gname, pname, strlen (pname)) == 0) {\n      *url_param = u_param;\n      return OSIP_SUCCESS;\n    }\n    u_param = (osip_uri_param_t *) osip_list_get_next(&it);\n  }\n  return OSIP_UNDEFINED_ERROR;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "osip_uri_param_clone": {
      "start_point": [
        870,
        0
      ],
      "end_point": [
        892,
        1
      ],
      "content": "int\nosip_uri_param_clone (const osip_uri_param_t * uparam, osip_uri_param_t ** dest)\n{\n  int i;\n  osip_uri_param_t *up;\n\n  *dest = NULL;\n  if (uparam == NULL)\n    return OSIP_BADPARAMETER;\n  if (uparam->gname == NULL)\n    return OSIP_BADPARAMETER;   /* name is mandatory */\n\n  i = osip_uri_param_init (&up);\n  if (i != 0)                   /* allocation failed */\n    return i;\n  up->gname = osip_strdup (uparam->gname);\n  if (uparam->gvalue != NULL)\n    up->gvalue = osip_strdup (uparam->gvalue);\n  else\n    up->gvalue = NULL;\n  *dest = up;\n  return OSIP_SUCCESS;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "__osip_uri_escape_nonascii_and_nondef": {
      "start_point": [
        909,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "char *\n__osip_uri_escape_nonascii_and_nondef (const char *string, const char *def)\n{\n  size_t alloc = strlen (string) + 1;\n  size_t length;\n  char *ns = (char *) osip_malloc (alloc);\n  unsigned char in;\n  size_t newlen = alloc;\n  int index = 0;\n  const char *tmp;\n  int i;\n\n  if (ns == NULL)\n    return NULL;\n\n  length = alloc - 1;\n  while (length--) {\n    in = *string;\n\n    i = 0;\n    tmp = NULL;\n    if (osip_is_alphanum (in))\n      tmp = string;\n    else {\n      for (; def[i] != '\\0' && def[i] != in; i++) {\n      }\n      if (def[i] != '\\0')\n        tmp = string;\n    }\n    if (tmp == NULL) {\n      /* encode it */\n      newlen += 2;              /* the size grows with two, since this'll become a %XX */\n      if (newlen > alloc) {\n        char *previous_ns;\n\n        alloc *= 2;\n        previous_ns = ns;\n        ns = osip_realloc (ns, alloc);\n        if (!ns) {\n          osip_free (previous_ns);\n          return NULL;\n        }\n      }\n      sprintf (&ns[index], \"%%%02X\", in);\n      index += 3;\n    }\n    else {\n      /* just copy this */\n      ns[index++] = in;\n    }\n    string++;\n  }\n  ns[index] = 0;                /* terminate it */\n  return ns;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "char",
        "*\n__osip_uri_escape_nonascii_and_nondef (const char *string, const char *def)",
        "*"
      ]
    },
    "__osip_uri_escape_userinfo": {
      "start_point": [
        967,
        0
      ],
      "end_point": [
        971,
        1
      ],
      "content": "char *\n__osip_uri_escape_userinfo (const char *string)\n{\n  return __osip_uri_escape_nonascii_and_nondef (string, userinfo_def);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__osip_uri_escape_userinfo (const char *string)",
        "*"
      ]
    },
    "__osip_uri_escape_password": {
      "start_point": [
        975,
        0
      ],
      "end_point": [
        979,
        1
      ],
      "content": "char *\n__osip_uri_escape_password (const char *string)\n{\n  return __osip_uri_escape_nonascii_and_nondef (string, password_def);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__osip_uri_escape_password (const char *string)",
        "*"
      ]
    },
    "__osip_uri_escape_uri_param": {
      "start_point": [
        982,
        0
      ],
      "end_point": [
        986,
        1
      ],
      "content": "char *\n__osip_uri_escape_uri_param (char *string)\n{\n  return __osip_uri_escape_nonascii_and_nondef (string, uri_param_def);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__osip_uri_escape_uri_param (char *string)",
        "*"
      ]
    },
    "__osip_uri_escape_header_param": {
      "start_point": [
        989,
        0
      ],
      "end_point": [
        993,
        1
      ],
      "content": "char *\n__osip_uri_escape_header_param (char *string)\n{\n  return __osip_uri_escape_nonascii_and_nondef (string, header_param_def);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__osip_uri_escape_header_param (char *string)",
        "*"
      ]
    },
    "__osip_uri_unescape": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        1029,
        1
      ],
      "content": "void\n__osip_uri_unescape (char *string)\n{\n  size_t alloc = strlen (string) + 1;\n  unsigned char in;\n  int index = 0;\n  unsigned int hex;\n  char *ptr;\n\n  ptr = string;\n  while (--alloc > 0) {\n    in = *ptr;\n    if ('%' == in) {\n      /* encoded part */\n      if (alloc > 2 && sscanf (ptr + 1, \"%02X\", &hex) == 1) {\n        in = (unsigned char) hex;\n        if (*(ptr + 2) && ((*(ptr + 2) >= '0' && *(ptr + 2) <= '9') || (*(ptr + 2) >= 'a' && *(ptr + 2) <= 'f') || (*(ptr + 2) >= 'A' && *(ptr + 2) <= 'F'))) {\n          alloc -= 2;\n          ptr += 2;\n        }\n        else {\n          alloc -= 1;\n          ptr += 1;\n        }\n      }\n      else {\n        break;\n      }\n    }\n\n    string[index++] = in;\n    ptr++;\n  }\n  string[index] = 0;            /* terminate it */\n}",
      "lines": 35,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "osip_uri_to_str_canonical": {
      "start_point": [
        1034,
        0
      ],
      "end_point": [
        1053,
        1
      ],
      "content": "int\nosip_uri_to_str_canonical (const osip_uri_t * url, char **dest)\n{\n  int result;\n\n  *dest = NULL;\n  result = osip_uri_to_str (url, dest);\n  if (result == 0) {\n    /*\n       tmp = strchr(*dest, \";\");\n       if (tmp !=NULL) {\n       buf=strndup(*dest, tmp-(*dest));\n       osip_free(*dest);\n       *dest=buf;\n       }\n     */\n    __osip_uri_unescape (*dest);\n  }\n  return result;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_via.c": {
    "osip_message_set_via": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nosip_message_set_via (osip_message_t * sip, const char *hvalue)\n{\n  osip_via_t *via;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  i = osip_via_init (&via);\n  if (i != 0)\n    return i;\n  i = osip_via_parse (via, hvalue);\n  if (i != 0) {\n    osip_via_free (via);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->vias, via, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_append_via": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nosip_message_append_via (osip_message_t * sip, const char *hvalue)\n{\n  osip_via_t *via;\n  int i;\n\n  i = osip_via_init (&via);\n  if (i != 0)\n    return i;\n  i = osip_via_parse (via, hvalue);\n  if (i != 0) {\n    osip_via_free (via);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->vias, via, 0);\n  return OSIP_SUCCESS;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_via": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\nosip_message_get_via (const osip_message_t * sip, int pos, osip_via_t ** dest)\n{\n  *dest = NULL;\n  if (sip == NULL)\n    return OSIP_BADPARAMETER;\n  if (osip_list_size (&sip->vias) <= pos)\n    return OSIP_UNDEFINED_ERROR;\n  *dest = (osip_via_t *) osip_list_get (&sip->vias, pos);\n\n  return pos;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_via_init": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\nosip_via_init (osip_via_t ** via)\n{\n  *via = (osip_via_t *) osip_malloc (sizeof (osip_via_t));\n  if (*via == NULL)\n    return OSIP_NOMEM;\n\n  memset (*via, 0, sizeof (osip_via_t));\n\n  osip_list_init (&(*via)->via_params);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_via_free": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\nosip_via_free (osip_via_t * via)\n{\n  if (via == NULL)\n    return;\n  osip_free (via->version);\n  osip_free (via->protocol);\n  osip_free (via->host);\n  osip_free (via->port);\n  osip_free (via->comment);\n  osip_generic_param_freelist (&via->via_params);\n\n  osip_free (via);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_via_parse": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "int\nosip_via_parse (osip_via_t * via, const char *hvalue)\n{\n  const char *version;\n  const char *protocol;\n  const char *host;\n  const char *ipv6host;\n  const char *port;\n  const char *via_params;\n  const char *comment;\n  int i;\n\n  if (hvalue == NULL)\n    return OSIP_BADPARAMETER;\n\n  version = strchr (hvalue, '/');\n  if (version == NULL)\n    return OSIP_SYNTAXERROR;\n\n  protocol = strchr (version + 1, '/');\n  if (protocol == NULL)\n    return OSIP_SYNTAXERROR;\n\n  /* set the version */\n  if (protocol - version < 2)\n    return OSIP_SYNTAXERROR;\n  via->version = (char *) osip_malloc (protocol - version);\n  if (via->version == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (via->version, version + 1, protocol - version - 1);\n\n  /* Here: we avoid matching an additionnal space */\n  host = strchr (protocol + 1, ' ');\n  if (host == NULL)\n    return OSIP_SYNTAXERROR;    /* fixed in 0.8.4 */\n  if (host == protocol + 1) {   /* there are extra SPACE characters */\n    while (0 == strncmp (host, \" \", 1)) {\n      host++;\n      if (strlen (host) == 1)\n        return OSIP_SYNTAXERROR;        /* via is malformed */\n    }\n    /* here, we match the real space located after the protocol name */\n    host = strchr (host + 1, ' ');\n    if (host == NULL)\n      return OSIP_SYNTAXERROR;  /* fixed in 0.8.4 */\n  }\n\n  /* set the protocol */\n  if (host - protocol < 2)\n    return OSIP_SYNTAXERROR;\n  via->protocol = (char *) osip_malloc (host - protocol);\n  if (via->protocol == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (via->protocol, protocol + 1, host - protocol - 1);\n\n  /* comments in Via are not allowed any more in the latest draft (09) */\n  comment = strchr (host, '(');\n\n  if (comment != NULL) {\n    char *end_comment;\n\n    end_comment = strchr (host, ')');\n    if (end_comment == NULL)\n      return OSIP_SYNTAXERROR;  /* if '(' exist ')' MUST exist */\n    if (end_comment - comment < 2)\n      return OSIP_SYNTAXERROR;\n    via->comment = (char *) osip_malloc (end_comment - comment);\n    if (via->comment == NULL)\n      return OSIP_NOMEM;\n    osip_strncpy (via->comment, comment + 1, end_comment - comment - 1);\n    comment--;\n  }\n  else\n    comment = host + strlen (host);\n\n  via_params = strchr (host, ';');\n\n  if ((via_params != NULL) && (via_params < comment))\n    /* via params exist */\n  {\n    char *tmp;\n\n    if (comment - via_params + 1 < 2)\n      return OSIP_SYNTAXERROR;\n    tmp = (char *) osip_malloc (comment - via_params + 1);\n    if (tmp == NULL)\n      return OSIP_NOMEM;\n    osip_strncpy (tmp, via_params, comment - via_params);\n    i = __osip_generic_param_parseall (&via->via_params, tmp);\n    if (i != 0) {\n      osip_free (tmp);\n      return i;\n    }\n\n    osip_free (tmp);\n  }\n\n  if (via_params == NULL)\n    via_params = comment;\n\n  /* add ipv6 support (0.8.4) */\n  /* Via: SIP/2.0/UDP [mlke::zeezf:ezfz:zef:zefzf]:port;.... */\n  ipv6host = strchr (host, '[');\n  if (ipv6host != NULL && ipv6host < via_params) {\n    port = strchr (ipv6host, ']');\n    if (port == NULL || port > via_params)\n      return OSIP_SYNTAXERROR;\n\n    if (port - ipv6host < 2)\n      return OSIP_SYNTAXERROR;\n    via->host = (char *) osip_malloc (port - ipv6host);\n    if (via->host == NULL)\n      return OSIP_NOMEM;\n    osip_clrncpy (via->host, ipv6host + 1, port - ipv6host - 1);\n\n    port = strchr (port, ':');\n  }\n  else {\n    port = strchr (host, ':');\n    ipv6host = NULL;\n  }\n\n  if ((port != NULL) && (port < via_params)) {\n    if (via_params - port < 2)\n      return OSIP_SYNTAXERROR;\n    via->port = (char *) osip_malloc (via_params - port);\n    if (via->port == NULL)\n      return OSIP_NOMEM;\n    osip_clrncpy (via->port, port + 1, via_params - port - 1);\n    if(osip_atoi(via->port) < 0)\n      return OSIP_SYNTAXERROR;\n  }\n  else\n    port = via_params;\n\n  /* host is already set in the case of ipv6 */\n  if (ipv6host != NULL)\n    return OSIP_SUCCESS;\n\n  if (port - host < 2)\n    return OSIP_SYNTAXERROR;\n  via->host = (char *) osip_malloc (port - host);\n  if (via->host == NULL)\n    return OSIP_NOMEM;\n  osip_clrncpy (via->host, host + 1, port - host - 1);\n\n  return OSIP_SUCCESS;\n}",
      "lines": 148,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "osip_via_to_str": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "int\nosip_via_to_str (const osip_via_t * via, char **dest)\n{\n  char *buf;\n  size_t len;\n  size_t plen;\n  char *tmp;\n\n  *dest = NULL;\n  if ((via == NULL) || (via->host == NULL)\n      || (via->version == NULL) || (via->protocol == NULL))\n    return OSIP_BADPARAMETER;\n\n  len = strlen (via->version) + 1 + strlen (via->protocol) + 1 + 3 + 2; /* sip/xxx/xxx */\n  len = len + strlen (via->host) + 3 + 1;\n  if (via->port != NULL)\n    len = len + strlen (via->port) + 2;\n\n  buf = (char *) osip_malloc (len);\n  if (buf == NULL)\n    return OSIP_NOMEM;\n\n  if (strchr (via->host, ':') != NULL) {\n    if (via->port == NULL)\n      sprintf (buf, \"SIP/%s/%s [%s]\", via->version, via->protocol, via->host);\n    else\n      sprintf (buf, \"SIP/%s/%s [%s]:%s\", via->version, via->protocol, via->host, via->port);\n  }\n  else {\n    if (via->port == NULL)\n      sprintf (buf, \"SIP/%s/%s %s\", via->version, via->protocol, via->host);\n    else\n      sprintf (buf, \"SIP/%s/%s %s:%s\", via->version, via->protocol, via->host, via->port);\n  }\n\n\n\n  {\n    osip_list_iterator_t it;\n    osip_generic_param_t *u_param = (osip_generic_param_t*) osip_list_get_first(&via->via_params, &it);\n    while (u_param != OSIP_SUCCESS) {\n      if (u_param->gvalue == NULL)\n        plen = strlen (u_param->gname) + 2;\n      else\n        plen = strlen (u_param->gname) + strlen (u_param->gvalue) + 3;\n      len = len + plen;\n      buf = (char *) osip_realloc (buf, len);\n      tmp = buf;\n      tmp = tmp + strlen (tmp);\n      if (u_param->gvalue == NULL)\n        sprintf (tmp, \";%s\", u_param->gname);\n      else\n        sprintf (tmp, \";%s=%s\", u_param->gname, u_param->gvalue);\n      u_param = (osip_generic_param_t *) osip_list_get_next(&it);\n    }\n  }\n\n  if (via->comment != NULL) {\n    len = len + strlen (via->comment) + 4;\n    buf = (char *) osip_realloc (buf, len);\n    tmp = buf;\n    tmp = tmp + strlen (tmp);\n    snprintf (tmp, len - (tmp - buf), \" (%s)\", via->comment);\n  }\n  *dest = buf;\n  return OSIP_SUCCESS;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "via_set_version": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "void\nvia_set_version (osip_via_t * via, char *version)\n{\n  via->version = version;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "via_get_version": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "char *\nvia_get_version (osip_via_t * via)\n{\n  if (via == NULL)\n    return NULL;\n  return via->version;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nvia_get_version (osip_via_t * via)",
        "*"
      ]
    },
    "via_set_protocol": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "void\nvia_set_protocol (osip_via_t * via, char *protocol)\n{\n  via->protocol = protocol;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "via_get_protocol": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "char *\nvia_get_protocol (osip_via_t * via)\n{\n  if (via == NULL)\n    return NULL;\n  return via->protocol;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nvia_get_protocol (osip_via_t * via)",
        "*"
      ]
    },
    "via_set_host": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "void\nvia_set_host (osip_via_t * via, char *host)\n{\n  via->host = host;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "via_get_host": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "char *\nvia_get_host (osip_via_t * via)\n{\n  if (via == NULL)\n    return NULL;\n  return via->host;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nvia_get_host (osip_via_t * via)",
        "*"
      ]
    },
    "via_set_port": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        391,
        1
      ],
      "content": "void\nvia_set_port (osip_via_t * via, char *port)\n{\n  via->port = port;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "via_get_port": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "char *\nvia_get_port (osip_via_t * via)\n{\n  if (via == NULL)\n    return NULL;\n  return via->port;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nvia_get_port (osip_via_t * via)",
        "*"
      ]
    },
    "via_set_comment": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "void\nvia_set_comment (osip_via_t * via, char *comment)\n{\n  via->comment = comment;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "via_get_comment": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "char *\nvia_get_comment (osip_via_t * via)\n{\n  if (via == NULL)\n    return NULL;\n  return via->comment;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nvia_get_comment (osip_via_t * via)",
        "*"
      ]
    },
    "osip_via_clone": {
      "start_point": [
        415,
        0
      ],
      "end_point": [
        471,
        1
      ],
      "content": "int\nosip_via_clone (const osip_via_t * via, osip_via_t ** dest)\n{\n  int i;\n  osip_via_t *vi;\n\n  *dest = NULL;\n  if (via == NULL)\n    return OSIP_BADPARAMETER;\n  if (via->version == NULL)\n    return OSIP_BADPARAMETER;\n  if (via->protocol == NULL)\n    return OSIP_BADPARAMETER;\n  if (via->host == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_via_init (&vi);\n  if (i != 0)\n    return i;\n  vi->version = osip_strdup (via->version);\n  if (vi->version == NULL && via->version != NULL) {\n    osip_via_free (vi);\n    return OSIP_NOMEM;\n  }\n  vi->protocol = osip_strdup (via->protocol);\n  if (vi->protocol == NULL && via->protocol != NULL) {\n    osip_via_free (vi);\n    return OSIP_NOMEM;\n  }\n  vi->host = osip_strdup (via->host);\n  if (vi->host == NULL && via->host != NULL) {\n    osip_via_free (vi);\n    return OSIP_NOMEM;\n  }\n  if (via->port != NULL) {\n    vi->port = osip_strdup (via->port);\n    if (vi->port == NULL) {\n      osip_via_free (vi);\n      return OSIP_NOMEM;\n    }\n  }\n  if (via->comment != NULL) {\n    vi->comment = osip_strdup (via->comment);\n    if (vi->comment == NULL) {\n      osip_via_free (vi);\n      return OSIP_NOMEM;\n    }\n  }\n\n  i = osip_list_clone (&via->via_params, &vi->via_params, (int (*)(void *, void **)) &osip_generic_param_clone);\n  if (i != 0) {\n    osip_via_free (vi);\n    return i;\n  }\n  *dest = vi;\n  return OSIP_SUCCESS;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "osip_via_match": {
      "start_point": [
        473,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "int\nosip_via_match (osip_via_t * via1, osip_via_t * via2)\n{\n  /* Can I really compare it this way??\n     There exist matching rules for via header, but this method\n     should only be used to detect retransmissions so the result should\n     be exactly equivalent. (This may not be true if the retransmission\n     traverse a different set of proxy...  */\n  char *_via1;\n  char *_via2;\n  int i;\n\n  if (via1 == NULL || via2 == NULL)\n    return OSIP_BADPARAMETER;\n  i = osip_via_to_str (via1, &_via1);\n  if (i != 0)\n    return i;\n  i = osip_via_to_str (via2, &_via2);\n  if (i != 0) {\n    osip_free (_via1);\n    return i;\n  }\n\n  i = strcmp (_via1, _via2);\n  osip_free (_via1);\n  osip_free (_via2);\n  if (i != 0)\n    return OSIP_UNDEFINED_ERROR;\n  return OSIP_SUCCESS;\n}",
      "lines": 30,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/osip_www_authenticate.c": {
    "osip_www_authenticate_init": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nosip_www_authenticate_init (osip_www_authenticate_t ** dest)\n{\n  *dest = (osip_www_authenticate_t *) osip_malloc (sizeof (osip_www_authenticate_t));\n  if (*dest == NULL)\n    return OSIP_NOMEM;\n  memset (*dest, 0, sizeof (osip_www_authenticate_t));\n  return OSIP_SUCCESS;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_message_set_www_authenticate": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nosip_message_set_www_authenticate (osip_message_t * sip, const char *hvalue)\n{\n  osip_www_authenticate_t *www_authenticate;\n  int i;\n\n  if (hvalue == NULL || hvalue[0] == '\\0')\n    return OSIP_SUCCESS;\n\n  if (sip == NULL)\n    return OSIP_BADPARAMETER;\n  i = osip_www_authenticate_init (&www_authenticate);\n  if (i != 0)\n    return i;\n  i = osip_www_authenticate_parse (www_authenticate, hvalue);\n  if (i != 0) {\n    osip_www_authenticate_free (www_authenticate);\n    return i;\n  }\n  sip->message_property = 2;\n  osip_list_add (&sip->www_authenticates, www_authenticate, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "__osip_quoted_string_set": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\n__osip_quoted_string_set (const char *name, const char *str, char **result, const char **next)\n{\n  *next = str;\n  if (*result != NULL)\n    return OSIP_SUCCESS;        /* already parsed */\n  *next = NULL;\n  while ((' ' == *str) || ('\\t' == *str) || (',' == *str))\n    if (*str)\n      str++;\n    else\n      return OSIP_SYNTAXERROR;  /* bad header format */\n\n  if (osip_strncasecmp (name, str, strlen (name)) == 0) {\n    const char *quote1;\n    const char *quote2;\n    const char *tmp;\n    const char *hack = strchr (str, '=');\n\n    if (hack == NULL)\n      return OSIP_SYNTAXERROR;\n\n    while (' ' == *(hack - 1))  /* get rid of extra spaces */\n      hack--;\n    if ((size_t) (hack - str) != strlen (name)) {\n      *next = str;\n      return OSIP_SUCCESS;\n    }\n\n    quote1 = __osip_quote_find (str);\n    if (quote1 == NULL)\n      return OSIP_SYNTAXERROR;  /* bad header format... */\n    quote2 = __osip_quote_find (quote1 + 1);\n    if (quote2 == NULL)\n      return OSIP_SYNTAXERROR;  /* bad header format... */\n    if (quote2 - quote1 == 1) {\n      /* this is a special case! The quote contains nothing! */\n      /* example:   Digest opaque=\"\",cnonce=\"\"               */\n      /* in this case, we just forget the parameter... this  */\n      /* this should prevent from user manipulating empty    */\n      /* strings */\n      tmp = quote2 + 1;         /* next element start here */\n      for (; *tmp == ' ' || *tmp == '\\t'; tmp++) {\n      }\n      for (; *tmp == '\\n' || *tmp == '\\r'; tmp++) {\n      }                         /* skip LWS */\n      *next = NULL;\n      if (*tmp == '\\0')         /* end of header detected */\n        return OSIP_SUCCESS;\n      if (*tmp != '\\t' && *tmp != ' ')\n        /* LWS here ? */\n        *next = tmp;\n      else {                    /* it is: skip it... */\n        for (; *tmp == ' ' || *tmp == '\\t'; tmp++) {\n        }\n        if (*tmp == '\\0')       /* end of header detected */\n          return OSIP_SUCCESS;\n        *next = tmp;\n      }\n      return OSIP_SUCCESS;\n    }\n    *result = (char *) osip_malloc (quote2 - quote1 + 3);\n    if (*result == NULL)\n      return OSIP_NOMEM;\n    osip_strncpy (*result, quote1, quote2 - quote1 + 1);\n    tmp = quote2 + 1;           /* next element start here */\n    for (; *tmp == ' ' || *tmp == '\\t'; tmp++) {\n    }\n    for (; *tmp == '\\n' || *tmp == '\\r'; tmp++) {\n    }                           /* skip LWS */\n    *next = NULL;\n    if (*tmp == '\\0')           /* end of header detected */\n      return OSIP_SUCCESS;\n    if (*tmp != '\\t' && *tmp != ' ')\n      /* LWS here ? */\n      *next = tmp;\n    else {                      /* it is: skip it... */\n      for (; *tmp == ' ' || *tmp == '\\t'; tmp++) {\n      }\n      if (*tmp == '\\0')         /* end of header detected */\n        return OSIP_SUCCESS;\n      *next = tmp;\n    }\n  }\n  else\n    *next = str;                /* wrong header asked! */\n  return OSIP_SUCCESS;\n}",
      "lines": 88,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "__osip_token_set": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\n__osip_token_set (const char *name, const char *str, char **result, const char **next)\n{\n  const char *beg;\n  const char *tmp;\n\n  *next = str;\n  if (*result != NULL)\n    return OSIP_SUCCESS;        /* already parsed */\n  *next = NULL;\n\n  beg = strchr (str, '=');\n  if (beg == NULL)\n    return OSIP_SYNTAXERROR;    /* bad header format... */\n\n  if (strlen (str) < 6)\n    return OSIP_SUCCESS;        /* end of header... */\n\n  while ((' ' == *str) || ('\\t' == *str) || (',' == *str))\n    if (*str)\n      str++;\n    else\n      return OSIP_SYNTAXERROR;  /* bad header format */\n\n  if (osip_strncasecmp (name, str, strlen (name)) == 0) {\n    const char *end;\n\n    end = strchr (str, ',');\n    if (end == NULL)\n      end = str + strlen (str); /* This is the end of the header */\n\n    if (end - beg < 2)\n      return OSIP_SYNTAXERROR;\n    *result = (char *) osip_malloc (end - beg);\n    if (*result == NULL)\n      return OSIP_NOMEM;\n    osip_clrncpy (*result, beg + 1, end - beg - 1);\n\n    /* make sure the element does not contain more parameter */\n    tmp = (*end) ? (end + 1) : end;\n    for (; *tmp == ' ' || *tmp == '\\t'; tmp++) {\n    }\n    for (; *tmp == '\\n' || *tmp == '\\r'; tmp++) {\n    }                           /* skip LWS */\n    *next = NULL;\n    if (*tmp == '\\0')           /* end of header detected */\n      return OSIP_SUCCESS;\n    if (*tmp != '\\t' && *tmp != ' ')\n      /* LWS here ? */\n      *next = tmp;\n    else {                      /* it is: skip it... */\n      for (; *tmp == ' ' || *tmp == '\\t'; tmp++) {\n      }\n      if (*tmp == '\\0')         /* end of header detected */\n        return OSIP_SUCCESS;\n      *next = tmp;\n    }\n  }\n  else\n    *next = str;                /* next element start here */\n  return OSIP_SUCCESS;\n}",
      "lines": 62,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_www_authenticate_parse": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "int\nosip_www_authenticate_parse (osip_www_authenticate_t * wwwa, const char *hvalue)\n{\n  const char *space;\n  const char *next = NULL;\n  int i;\n\n  space = strchr (hvalue, ' '); /* SEARCH FOR SPACE */\n  if (space == NULL)\n    return OSIP_SYNTAXERROR;\n\n  if (space - hvalue + 1 < 2)\n    return OSIP_SYNTAXERROR;\n  wwwa->auth_type = (char *) osip_malloc (space - hvalue + 1);\n  if (wwwa->auth_type == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (wwwa->auth_type, hvalue, space - hvalue);\n\n  for (;;) {\n    int parse_ok = 0;\n\n    i = __osip_quoted_string_set (\"realm\", space, &(wwwa->realm), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"domain\", space, &(wwwa->domain), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"nonce\", space, &(wwwa->nonce), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"opaque\", space, &(wwwa->opaque), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_token_set (\"stale\", space, &(wwwa->stale), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_token_set (\"algorithm\", space, &(wwwa->algorithm), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_quoted_string_set (\"qop\", space, &(wwwa->qop_options), &next);\n    if (i != 0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;      /* end of header detected! */\n    else if (next != space) {\n      space = next;\n      parse_ok++;\n    }\n    i = __osip_token_set (\"version\", space, &(wwwa->version), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space)\n      {\n        space = next;\n        parse_ok++;\n      }\n       i = __osip_quoted_string_set (\"targetname\", space, &(wwwa->targetname), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space)\n      {\n        space = next;\n        parse_ok++;\n      }\n       i = __osip_quoted_string_set (\"gssapi-data\", space, &(wwwa->gssapi_data), &next);\n    if (i!=0)\n      return i;\n    if (next == NULL)\n      return OSIP_SUCCESS;               /* end of header detected! */\n    else if (next != space)\n      {\n        space = next;\n        parse_ok++;\n      }\n    if (0 == parse_ok) {\n      const char *quote1, *quote2, *tmp;\n\n      /* CAUTION */\n      /* parameter not understood!!! I'm too lazy to handle IT */\n      /* let's simply bypass it */\n      if (strlen (space) < 1)\n        return OSIP_SUCCESS;\n      tmp = strchr (space + 1, ',');\n      if (tmp == NULL)          /* it was the last header */\n        return OSIP_SUCCESS;\n      quote1 = __osip_quote_find (space);\n      if ((quote1 != NULL) && (quote1 < tmp)) { /* this may be a quoted string! */\n        quote2 = __osip_quote_find (quote1 + 1);\n        if (quote2 == NULL)\n          return OSIP_SYNTAXERROR;      /* bad header format... */\n        if (tmp < quote2)       /* the comma is inside the quotes! */\n          space = strchr (quote2, ',');\n        else\n          space = tmp;\n        if (space == NULL)      /* it was the last header */\n          return OSIP_SUCCESS;\n      }\n      else\n        space = tmp;\n      /* continue parsing... */\n    }\n  }\n  return OSIP_SUCCESS;          /* ok */\n}",
      "lines": 144,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "osip_message_get_www_authenticate": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "int\nosip_message_get_www_authenticate (const osip_message_t * sip, int pos, osip_www_authenticate_t ** dest)\n{\n  osip_www_authenticate_t *www_authenticate;\n\n  *dest = NULL;\n  if (osip_list_size (&sip->www_authenticates) <= pos)\n    return OSIP_UNDEFINED_ERROR;        /* does not exist */\n\n  www_authenticate = (osip_www_authenticate_t *) osip_list_get (&sip->www_authenticates, pos);\n\n  *dest = www_authenticate;\n  return pos;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "osip_www_authenticate_get_auth_type": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "char *\nosip_www_authenticate_get_auth_type (osip_www_authenticate_t * www_authenticate)\n{\n  return www_authenticate->auth_type;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_www_authenticate_get_auth_type (osip_www_authenticate_t * www_authenticate)",
        "*"
      ]
    },
    "osip_www_authenticate_set_auth_type": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "void\nosip_www_authenticate_set_auth_type (osip_www_authenticate_t * www_authenticate, char *auth_type)\n{\n  www_authenticate->auth_type = (char *) auth_type;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_get_realm": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "char *\nosip_www_authenticate_get_realm (osip_www_authenticate_t * www_authenticate)\n{\n  return www_authenticate->realm;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_www_authenticate_get_realm (osip_www_authenticate_t * www_authenticate)",
        "*"
      ]
    },
    "osip_www_authenticate_set_realm": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "void\nosip_www_authenticate_set_realm (osip_www_authenticate_t * www_authenticate, char *realm)\n{\n  www_authenticate->realm = (char *) realm;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_get_domain": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "char *\nosip_www_authenticate_get_domain (osip_www_authenticate_t * www_authenticate)\n{\n  return www_authenticate->domain;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_www_authenticate_get_domain (osip_www_authenticate_t * www_authenticate)",
        "*"
      ]
    },
    "osip_www_authenticate_set_domain": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "void\nosip_www_authenticate_set_domain (osip_www_authenticate_t * www_authenticate, char *domain)\n{\n  www_authenticate->domain = (char *) domain;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_get_nonce": {
      "start_point": [
        425,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "char *\nosip_www_authenticate_get_nonce (osip_www_authenticate_t * www_authenticate)\n{\n  return www_authenticate->nonce;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_www_authenticate_get_nonce (osip_www_authenticate_t * www_authenticate)",
        "*"
      ]
    },
    "osip_www_authenticate_set_nonce": {
      "start_point": [
        431,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "void\nosip_www_authenticate_set_nonce (osip_www_authenticate_t * www_authenticate, char *nonce)\n{\n  www_authenticate->nonce = (char *) nonce;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_get_stale": {
      "start_point": [
        437,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "char *\nosip_www_authenticate_get_stale (osip_www_authenticate_t * www_authenticate)\n{\n  return www_authenticate->stale;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_www_authenticate_get_stale (osip_www_authenticate_t * www_authenticate)",
        "*"
      ]
    },
    "osip_www_authenticate_set_stale": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        447,
        1
      ],
      "content": "void\nosip_www_authenticate_set_stale (osip_www_authenticate_t * www_authenticate, char *stale)\n{\n  www_authenticate->stale = (char *) stale;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_get_opaque": {
      "start_point": [
        449,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "char *\nosip_www_authenticate_get_opaque (osip_www_authenticate_t * www_authenticate)\n{\n  return www_authenticate->opaque;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_www_authenticate_get_opaque (osip_www_authenticate_t * www_authenticate)",
        "*"
      ]
    },
    "osip_www_authenticate_set_opaque": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "void\nosip_www_authenticate_set_opaque (osip_www_authenticate_t * www_authenticate, char *opaque)\n{\n  www_authenticate->opaque = (char *) opaque;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_get_algorithm": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "char *\nosip_www_authenticate_get_algorithm (osip_www_authenticate_t * www_authenticate)\n{\n  return www_authenticate->algorithm;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_www_authenticate_get_algorithm (osip_www_authenticate_t * www_authenticate)",
        "*"
      ]
    },
    "osip_www_authenticate_set_algorithm": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        471,
        1
      ],
      "content": "void\nosip_www_authenticate_set_algorithm (osip_www_authenticate_t * www_authenticate, char *algorithm)\n{\n  www_authenticate->algorithm = (char *) algorithm;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_get_qop_options": {
      "start_point": [
        473,
        0
      ],
      "end_point": [
        477,
        1
      ],
      "content": "char *\nosip_www_authenticate_get_qop_options (osip_www_authenticate_t * www_authenticate)\n{\n  return www_authenticate->qop_options;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_www_authenticate_get_qop_options (osip_www_authenticate_t * www_authenticate)",
        "*"
      ]
    },
    "osip_www_authenticate_set_qop_options": {
      "start_point": [
        479,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "void\nosip_www_authenticate_set_qop_options (osip_www_authenticate_t * www_authenticate, char *qop_options)\n{\n  www_authenticate->qop_options = (char *) qop_options;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_get_version": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "char *\nosip_www_authenticate_get_version (osip_www_authenticate_t * www_authenticate)\n{\n  return www_authenticate->version;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_www_authenticate_get_version (osip_www_authenticate_t * www_authenticate)",
        "*"
      ]
    },
    "osip_www_authenticate_set_version": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        496,
        1
      ],
      "content": "void\nosip_www_authenticate_set_version (osip_www_authenticate_t *\n\t\t\t\t   www_authenticate, char *version)\n{\n  www_authenticate->version = (char *) version;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_get_targetname": {
      "start_point": [
        498,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "char *\nosip_www_authenticate_get_targetname (osip_www_authenticate_t * www_authenticate)\n{\n  return www_authenticate->targetname;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_www_authenticate_get_targetname (osip_www_authenticate_t * www_authenticate)",
        "*"
      ]
    },
    "osip_www_authenticate_set_targetname": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        509,
        1
      ],
      "content": "void\nosip_www_authenticate_set_targetname (osip_www_authenticate_t *\n\t\t\t\t      www_authenticate, char *targetname)\n{\n  www_authenticate->targetname = (char *) targetname;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_get_gssapi_data": {
      "start_point": [
        511,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "char *\nosip_www_authenticate_get_gssapi_data (osip_www_authenticate_t * www_authenticate)\n{\n  return www_authenticate->gssapi_data;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nosip_www_authenticate_get_gssapi_data (osip_www_authenticate_t * www_authenticate)",
        "*"
      ]
    },
    "osip_www_authenticate_set_gssapi_data": {
      "start_point": [
        517,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "void\nosip_www_authenticate_set_gssapi_data (osip_www_authenticate_t *\n                                       www_authenticate, char *gssapi_data)\n{\n  www_authenticate->gssapi_data = (char *) gssapi_data;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_to_str": {
      "start_point": [
        529,
        0
      ],
      "end_point": [
        618,
        1
      ],
      "content": "int\nosip_www_authenticate_to_str (const osip_www_authenticate_t * wwwa, char **dest)\n{\n  size_t len;\n  char *tmp;\n\n  *dest = NULL;\n  if ((wwwa == NULL) || (wwwa->auth_type == NULL))\n    return OSIP_BADPARAMETER;\n\n  len = strlen (wwwa->auth_type) + 1;\n\n  if (wwwa->realm != NULL)\n    len = len + strlen (wwwa->realm) + 7;\n  if (wwwa->nonce != NULL)\n    len = len + strlen (wwwa->nonce) + 8;\n  len = len + 2;\n  if (wwwa->domain != NULL)\n    len = len + strlen (wwwa->domain) + 9;\n  if (wwwa->opaque != NULL)\n    len = len + strlen (wwwa->opaque) + 9;\n  if (wwwa->stale != NULL)\n    len = len + strlen (wwwa->stale) + 8;\n  if (wwwa->algorithm != NULL)\n    len = len + strlen (wwwa->algorithm) + 12;\n  if (wwwa->qop_options != NULL)\n    len = len + strlen (wwwa->qop_options) + 6;\n  if (wwwa->version != NULL)\n    len = len + strlen (wwwa->version) + 10;\n  if (wwwa->targetname != NULL)\n    len = len + strlen (wwwa->targetname) + 13;\n  if (wwwa->gssapi_data != NULL)\n    len = len + strlen (wwwa->gssapi_data) + 14;\n\n  tmp = (char *) osip_malloc (len);\n  if (tmp == NULL)\n    return OSIP_NOMEM;\n  *dest = tmp;\n\n  tmp = osip_str_append (tmp, wwwa->auth_type);\n\n  if (wwwa->realm != NULL) {\n    tmp = osip_strn_append (tmp, \" realm=\", 7);\n    tmp = osip_str_append (tmp, wwwa->realm);\n  }\n  if (wwwa->domain != NULL) {\n    tmp = osip_strn_append (tmp, \", domain=\", 9);\n    tmp = osip_str_append (tmp, wwwa->domain);\n  }\n  if (wwwa->nonce != NULL) {\n    tmp = osip_strn_append (tmp, \", nonce=\", 8);\n    tmp = osip_str_append (tmp, wwwa->nonce);\n  }\n  if (wwwa->opaque != NULL) {\n    tmp = osip_strn_append (tmp, \", opaque=\", 9);\n    tmp = osip_str_append (tmp, wwwa->opaque);\n  }\n  if (wwwa->stale != NULL) {\n    tmp = osip_strn_append (tmp, \", stale=\", 8);\n    tmp = osip_str_append (tmp, wwwa->stale);\n  }\n  if (wwwa->algorithm != NULL) {\n    tmp = osip_strn_append (tmp, \", algorithm=\", 12);\n    tmp = osip_str_append (tmp, wwwa->algorithm);\n  }\n  if (wwwa->qop_options != NULL) {\n    tmp = osip_strn_append (tmp, \", qop=\", 6);\n    tmp = osip_str_append (tmp, wwwa->qop_options);\n  }\n  if (wwwa->version != NULL) {\n      tmp = osip_strn_append (tmp, \", version=\", 10);\n      tmp = osip_str_append (tmp, wwwa->version);\n  }\n  if (wwwa->targetname != NULL) {\n      tmp = osip_strn_append (tmp, \", targetname=\", 13);\n      tmp = osip_str_append (tmp, wwwa->targetname);\n  }\n  if (wwwa->gssapi_data != NULL) {\n      tmp = osip_strn_append (tmp, \", gssapi-data=\", 14);\n      tmp = osip_str_append (tmp, wwwa->gssapi_data);\n  }\n  if (wwwa->realm == NULL) {\n    /* remove comma */\n    len = strlen (wwwa->auth_type);\n    if ((*dest)[len] == ',')\n      (*dest)[len] = ' ';\n  }\n\n  return OSIP_SUCCESS;\n}",
      "lines": 90,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "osip_www_authenticate_free": {
      "start_point": [
        622,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "void\nosip_www_authenticate_free (osip_www_authenticate_t * www_authenticate)\n{\n  if (www_authenticate == NULL)\n    return;\n\n  osip_free (www_authenticate->auth_type);\n  osip_free (www_authenticate->realm);\n  osip_free (www_authenticate->domain);\n  osip_free (www_authenticate->nonce);\n  osip_free (www_authenticate->opaque);\n  osip_free (www_authenticate->stale);\n  osip_free (www_authenticate->algorithm);\n  osip_free (www_authenticate->qop_options);\n  osip_free (www_authenticate->version);\n  osip_free (www_authenticate->targetname);\n  osip_free (www_authenticate->gssapi_data);\n\n  osip_free (www_authenticate);\n}",
      "lines": 20,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "osip_www_authenticate_clone": {
      "start_point": [
        643,
        0
      ],
      "end_point": [
        729,
        1
      ],
      "content": "int\nosip_www_authenticate_clone (const osip_www_authenticate_t * wwwa, osip_www_authenticate_t ** dest)\n{\n  int i;\n  osip_www_authenticate_t *wa;\n\n  *dest = NULL;\n  if (wwwa == NULL)\n    return OSIP_BADPARAMETER;\n  if (wwwa->auth_type == NULL)\n    return OSIP_BADPARAMETER;\n\n  i = osip_www_authenticate_init (&wa);\n  if (i != 0)                   /* allocation failed */\n    return i;\n  wa->auth_type = osip_strdup (wwwa->auth_type);\n  if (wa->auth_type == NULL && wwwa->auth_type != NULL) {\n    osip_www_authenticate_free (wa);\n    return OSIP_NOMEM;\n  }\n  if (wwwa->realm != NULL)\n    wa->realm = osip_strdup (wwwa->realm);\n  if (wa->realm == NULL && wwwa->realm != NULL) {\n    osip_www_authenticate_free (wa);\n    return OSIP_NOMEM;\n  }\n  if (wwwa->domain != NULL)\n    wa->domain = osip_strdup (wwwa->domain);\n  if (wa->domain == NULL && wwwa->domain != NULL) {\n    osip_www_authenticate_free (wa);\n    return OSIP_NOMEM;\n  }\n  if (wwwa->nonce != NULL)\n    wa->nonce = osip_strdup (wwwa->nonce);\n  if (wa->nonce == NULL && wwwa->nonce != NULL) {\n    osip_www_authenticate_free (wa);\n    return OSIP_NOMEM;\n  }\n  if (wwwa->opaque != NULL)\n    wa->opaque = osip_strdup (wwwa->opaque);\n  if (wa->opaque == NULL && wwwa->opaque != NULL) {\n    osip_www_authenticate_free (wa);\n    return OSIP_NOMEM;\n  }\n  if (wwwa->stale != NULL)\n    wa->stale = osip_strdup (wwwa->stale);\n  if (wa->stale == NULL && wwwa->stale != NULL) {\n    osip_www_authenticate_free (wa);\n    return OSIP_NOMEM;\n  }\n  if (wwwa->algorithm != NULL)\n    wa->algorithm = osip_strdup (wwwa->algorithm);\n  if (wa->algorithm == NULL && wwwa->algorithm != NULL) {\n    osip_www_authenticate_free (wa);\n    return OSIP_NOMEM;\n  }\n  if (wwwa->qop_options != NULL)\n    wa->qop_options = osip_strdup (wwwa->qop_options);\n  if (wa->qop_options == NULL && wwwa->qop_options != NULL) {\n    osip_www_authenticate_free (wa);\n    return OSIP_NOMEM;\n  }\n  if (wwwa->version != NULL)\n    wa->version = osip_strdup (wwwa->version);\n  if (wa->version==NULL && wwwa->version!=NULL)\n  {\n\t  osip_www_authenticate_free (wa);\n\t  return OSIP_NOMEM;\n  }\n  if (wwwa->targetname != NULL)\n    wa->targetname = osip_strdup (wwwa->targetname);\n  if (wa->targetname==NULL && wwwa->targetname!=NULL)\n  {\n\t  osip_www_authenticate_free (wa);\n\t  return OSIP_NOMEM;\n  }\n  if (wwwa->gssapi_data != NULL)\n    wa->gssapi_data = osip_strdup (wwwa->gssapi_data);\n  if (wa->gssapi_data==NULL && wwwa->gssapi_data!=NULL)\n  {\n\t  osip_www_authenticate_free (wa);\n\t  return OSIP_NOMEM;\n  }\n\n  *dest = wa;\n  return OSIP_SUCCESS;\n}",
      "lines": 87,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/parser.h": {},
  "osip/libosip2-5.0.0/src/osipparser2/sdp_accessor.c": {
    "sdp_message_v_version_set": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nsdp_message_v_version_set (sdp_message_t * sdp, char *v_version)\n{\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  sdp->v_version = v_version;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_v_version_get": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "char *\nsdp_message_v_version_get (sdp_message_t * sdp)\n{\n  if (sdp == NULL)\n    return NULL;\n  return sdp->v_version;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_v_version_get (sdp_message_t * sdp)",
        "*"
      ]
    },
    "sdp_message_o_origin_set": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nsdp_message_o_origin_set (sdp_message_t * sdp, char *username, char *sess_id, char *sess_version, char *nettype, char *addrtype, char *addr)\n{\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  sdp->o_username = username;\n  sdp->o_sess_id = sess_id;\n  sdp->o_sess_version = sess_version;\n  sdp->o_nettype = nettype;\n  sdp->o_addrtype = addrtype;\n  sdp->o_addr = addr;\n  return OSIP_SUCCESS;\n}",
      "lines": 13,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_o_username_get": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "char *\nsdp_message_o_username_get (sdp_message_t * sdp)\n{\n  if (sdp == NULL)\n    return NULL;\n  return sdp->o_username;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_o_username_get (sdp_message_t * sdp)",
        "*"
      ]
    },
    "sdp_message_o_sess_id_get": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "char *\nsdp_message_o_sess_id_get (sdp_message_t * sdp)\n{\n  if (sdp == NULL)\n    return NULL;\n  return sdp->o_sess_id;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_o_sess_id_get (sdp_message_t * sdp)",
        "*"
      ]
    },
    "sdp_message_o_sess_version_get": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "char *\nsdp_message_o_sess_version_get (sdp_message_t * sdp)\n{\n  if (sdp == NULL)\n    return NULL;\n  return sdp->o_sess_version;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_o_sess_version_get (sdp_message_t * sdp)",
        "*"
      ]
    },
    "sdp_message_o_nettype_get": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "char *\nsdp_message_o_nettype_get (sdp_message_t * sdp)\n{\n  if (sdp == NULL)\n    return NULL;\n  return sdp->o_nettype;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_o_nettype_get (sdp_message_t * sdp)",
        "*"
      ]
    },
    "sdp_message_o_addrtype_get": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "char *\nsdp_message_o_addrtype_get (sdp_message_t * sdp)\n{\n  if (sdp == NULL)\n    return NULL;\n  return sdp->o_addrtype;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_o_addrtype_get (sdp_message_t * sdp)",
        "*"
      ]
    },
    "sdp_message_o_addr_get": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "char *\nsdp_message_o_addr_get (sdp_message_t * sdp)\n{\n  if (sdp == NULL)\n    return NULL;\n  return sdp->o_addr;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_o_addr_get (sdp_message_t * sdp)",
        "*"
      ]
    },
    "sdp_message_s_name_set": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "int\nsdp_message_s_name_set (sdp_message_t * sdp, char *name)\n{\n  if (sdp == NULL)\n    return -1;\n  sdp->s_name = name;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_s_name_get": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "char *\nsdp_message_s_name_get (sdp_message_t * sdp)\n{\n  if (sdp == NULL)\n    return NULL;\n  return sdp->s_name;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_s_name_get (sdp_message_t * sdp)",
        "*"
      ]
    },
    "sdp_message_i_info_set": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nsdp_message_i_info_set (sdp_message_t * sdp, int pos_media, char *info)\n{\n  sdp_media_t *med;\n\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  if (pos_media == -1) {\n    sdp->i_info = info;\n    return OSIP_SUCCESS;\n  }\n  med = osip_list_get (&sdp->m_medias, pos_media);\n  if (med == NULL)\n    return OSIP_UNDEFINED_ERROR;\n  med->i_info = info;\n  return OSIP_SUCCESS;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_i_info_get": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "char *\nsdp_message_i_info_get (sdp_message_t * sdp, int pos_media)\n{\n  sdp_media_t *med;\n\n  if (sdp == NULL)\n    return NULL;\n  if (pos_media == -1) {\n    return sdp->i_info;\n  }\n  med = osip_list_get (&sdp->m_medias, pos_media);\n  if (med == NULL)\n    return NULL;\n  return med->i_info;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsdp_message_i_info_get (sdp_message_t * sdp, int pos_media)",
        "*"
      ]
    },
    "sdp_message_u_uri_set": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "int\nsdp_message_u_uri_set (sdp_message_t * sdp, char *uri)\n{\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  sdp->u_uri = uri;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_u_uri_get": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "char *\nsdp_message_u_uri_get (sdp_message_t * sdp)\n{\n  if (sdp == NULL)\n    return NULL;\n  return sdp->u_uri;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_u_uri_get (sdp_message_t * sdp)",
        "*"
      ]
    },
    "sdp_message_e_email_add": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "int\nsdp_message_e_email_add (sdp_message_t * sdp, char *email)\n{\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  osip_list_add (&sdp->e_emails, email, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_e_email_get": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "char *\nsdp_message_e_email_get (sdp_message_t * sdp, int pos)\n{\n  if (sdp == NULL)\n    return NULL;\n  if (osip_list_size (&sdp->e_emails) > pos)\n    return (char *) osip_list_get (&sdp->e_emails, pos);\n  return NULL;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "char",
        "*\nsdp_message_e_email_get (sdp_message_t * sdp, int pos)",
        "*"
      ]
    },
    "sdp_message_p_phone_add": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "int\nsdp_message_p_phone_add (sdp_message_t * sdp, char *phone)\n{\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  osip_list_add (&sdp->p_phones, phone, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_p_phone_get": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "char *\nsdp_message_p_phone_get (sdp_message_t * sdp, int pos)\n{\n  if (sdp == NULL)\n    return NULL;\n  if (osip_list_size (&sdp->p_phones) > pos)\n    return (char *) osip_list_get (&sdp->p_phones, pos);\n  return NULL;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "char",
        "*\nsdp_message_p_phone_get (sdp_message_t * sdp, int pos)",
        "*"
      ]
    },
    "sdp_message_c_connection_add": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "int\nsdp_message_c_connection_add (sdp_message_t * sdp, int pos_media, char *nettype, char *addrtype, char *addr, char *addr_multicast_ttl, char *addr_multicast_int)\n{\n  int i;\n  sdp_media_t *med;\n  sdp_connection_t *conn;\n\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  if ((pos_media != -1) && (osip_list_size (&sdp->m_medias) < pos_media + 1))\n    return -1;\n  i = sdp_connection_init (&conn);\n  if (i != 0)\n    return i;\n  conn->c_nettype = nettype;\n  conn->c_addrtype = addrtype;\n  conn->c_addr = addr;\n  conn->c_addr_multicast_ttl = addr_multicast_ttl;\n  conn->c_addr_multicast_int = addr_multicast_int;\n  if (pos_media == -1) {\n    sdp->c_connection = conn;\n    return OSIP_SUCCESS;\n  }\n  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);\n  osip_list_add (&med->c_connections, conn, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_connection_get": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "sdp_connection_t *\nsdp_message_connection_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_media_t *med;\n\n  if (sdp == NULL)\n    return NULL;\n  if (pos_media == -1)          /* pos is useless in this case: 1 global \"c=\" is allowed */\n    return sdp->c_connection;\n  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);\n  if (med == NULL)\n    return NULL;\n  return (sdp_connection_t *) osip_list_get (&med->c_connections, pos);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "sdp_connection_t",
        "*\nsdp_message_connection_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_c_nettype_get": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "char *\nsdp_message_c_nettype_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_connection_t *conn = sdp_message_connection_get (sdp, pos_media, pos);\n\n  if (conn == NULL)\n    return NULL;\n  return conn->c_nettype;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_c_nettype_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_c_addrtype_get": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "char *\nsdp_message_c_addrtype_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_connection_t *conn = sdp_message_connection_get (sdp, pos_media, pos);\n\n  if (conn == NULL)\n    return NULL;\n  return conn->c_addrtype;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_c_addrtype_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_c_addr_get": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "char *\nsdp_message_c_addr_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_connection_t *conn = sdp_message_connection_get (sdp, pos_media, pos);\n\n  if (conn == NULL)\n    return NULL;\n  return conn->c_addr;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_c_addr_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_c_addr_multicast_ttl_get": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "char *\nsdp_message_c_addr_multicast_ttl_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_connection_t *conn = sdp_message_connection_get (sdp, pos_media, pos);\n\n  if (conn == NULL)\n    return NULL;\n  return conn->c_addr_multicast_ttl;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_c_addr_multicast_ttl_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_c_addr_multicast_int_get": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "char *\nsdp_message_c_addr_multicast_int_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_connection_t *conn = sdp_message_connection_get (sdp, pos_media, pos);\n\n  if (conn == NULL)\n    return NULL;\n  return conn->c_addr_multicast_int;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_c_addr_multicast_int_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_b_bandwidth_add": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "int\nsdp_message_b_bandwidth_add (sdp_message_t * sdp, int pos_media, char *bwtype, char *bandwidth)\n{\n  int i;\n  sdp_media_t *med;\n  sdp_bandwidth_t *band;\n\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  if ((pos_media != -1) && (osip_list_size (&sdp->m_medias) < pos_media + 1))\n    return OSIP_UNDEFINED_ERROR;\n  i = sdp_bandwidth_init (&band);\n  if (i != 0)\n    return i;\n  band->b_bwtype = bwtype;\n  band->b_bandwidth = bandwidth;\n  if (pos_media == -1) {\n    osip_list_add (&sdp->b_bandwidths, band, -1);\n    return OSIP_SUCCESS;\n  }\n  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);\n  osip_list_add (&med->b_bandwidths, band, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_bandwidth_get": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "sdp_bandwidth_t *\nsdp_message_bandwidth_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_media_t *med;\n\n  if (sdp == NULL)\n    return NULL;\n  if (pos_media == -1)\n    return (sdp_bandwidth_t *) osip_list_get (&sdp->b_bandwidths, pos);\n  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);\n  if (med == NULL)\n    return NULL;\n  return (sdp_bandwidth_t *) osip_list_get (&med->b_bandwidths, pos);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "sdp_bandwidth_t",
        "*\nsdp_message_bandwidth_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_b_bwtype_get": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "char *\nsdp_message_b_bwtype_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_bandwidth_t *band = sdp_message_bandwidth_get (sdp, pos_media, pos);\n\n  if (band == NULL)\n    return NULL;\n  return band->b_bwtype;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_b_bwtype_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_b_bandwidth_get": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "char *\nsdp_message_b_bandwidth_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_bandwidth_t *band = sdp_message_bandwidth_get (sdp, pos_media, pos);\n\n  if (band == NULL)\n    return NULL;\n  return band->b_bandwidth;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_b_bandwidth_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_t_time_descr_add": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "int\nsdp_message_t_time_descr_add (sdp_message_t * sdp, char *start, char *stop)\n{\n  int i;\n  sdp_time_descr_t *td;\n\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  i = sdp_time_descr_init (&td);\n  if (i != 0)\n    return i;\n  td->t_start_time = start;\n  td->t_stop_time = stop;\n  osip_list_add (&sdp->t_descrs, td, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_t_start_time_get": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "char *\nsdp_message_t_start_time_get (sdp_message_t * sdp, int pos_td)\n{\n  sdp_time_descr_t *td;\n\n  if (sdp == NULL)\n    return NULL;\n  td = (sdp_time_descr_t *) osip_list_get (&sdp->t_descrs, pos_td);\n  if (td == NULL)\n    return NULL;\n  return td->t_start_time;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "char",
        "*\nsdp_message_t_start_time_get (sdp_message_t * sdp, int pos_td)",
        "*"
      ]
    },
    "sdp_message_t_stop_time_get": {
      "start_point": [
        394,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "char *\nsdp_message_t_stop_time_get (sdp_message_t * sdp, int pos_td)\n{\n  sdp_time_descr_t *td;\n\n  if (sdp == NULL)\n    return NULL;\n  td = (sdp_time_descr_t *) osip_list_get (&sdp->t_descrs, pos_td);\n  if (td == NULL)\n    return NULL;\n  return td->t_stop_time;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "char",
        "*\nsdp_message_t_stop_time_get (sdp_message_t * sdp, int pos_td)",
        "*"
      ]
    },
    "sdp_message_r_repeat_add": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "int\nsdp_message_r_repeat_add (sdp_message_t * sdp, int pos_time_descr, char *field)\n{\n  sdp_time_descr_t *td;\n\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  td = (sdp_time_descr_t *) osip_list_get (&sdp->t_descrs, pos_time_descr);\n  if (td == NULL)\n    return OSIP_UNDEFINED_ERROR;\n  osip_list_add (&td->r_repeats, field, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_r_repeat_get": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "char *\nsdp_message_r_repeat_get (sdp_message_t * sdp, int pos_time_descr, int pos_repeat)\n{\n  sdp_time_descr_t *td;\n\n  if (sdp == NULL)\n    return NULL;\n  td = (sdp_time_descr_t *) osip_list_get (&sdp->t_descrs, pos_time_descr);\n  if (td == NULL)\n    return NULL;\n  return (char *) osip_list_get (&td->r_repeats, pos_repeat);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "char",
        "*\nsdp_message_r_repeat_get (sdp_message_t * sdp, int pos_time_descr, int pos_repeat)",
        "*"
      ]
    },
    "sdp_message_z_adjustments_set": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "int\nsdp_message_z_adjustments_set (sdp_message_t * sdp, char *field)\n{\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  sdp->z_adjustments = field;\n  return OSIP_SUCCESS;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_z_adjustments_get": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "char *\nsdp_message_z_adjustments_get (sdp_message_t * sdp)\n{\n  if (sdp == NULL)\n    return NULL;\n  return sdp->z_adjustments;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_z_adjustments_get (sdp_message_t * sdp)",
        "*"
      ]
    },
    "sdp_message_k_key_set": {
      "start_point": [
        451,
        0
      ],
      "end_point": [
        474,
        1
      ],
      "content": "int\nsdp_message_k_key_set (sdp_message_t * sdp, int pos_media, char *keytype, char *keydata)\n{\n  sdp_key_t *key;\n  sdp_media_t *med;\n  int i;\n\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  if ((pos_media != -1) && (osip_list_size (&sdp->m_medias) < pos_media + 1))\n    return OSIP_UNDEFINED_ERROR;\n  i = sdp_key_init (&key);\n  if (i != 0)\n    return i;\n  key->k_keytype = keytype;\n  key->k_keydata = keydata;\n  if (pos_media == -1) {\n    sdp->k_key = key;\n    return OSIP_SUCCESS;\n  }\n  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);\n  med->k_key = key;\n  return OSIP_SUCCESS;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_k_keytype_get": {
      "start_point": [
        476,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "char *\nsdp_message_k_keytype_get (sdp_message_t * sdp, int pos_media)\n{\n  sdp_media_t *med;\n\n  if (sdp == NULL)\n    return NULL;\n  if (pos_media == -1) {\n    if (sdp->k_key == NULL)\n      return NULL;\n    return sdp->k_key->k_keytype;\n  }\n  if ((pos_media != -1) && (osip_list_size (&sdp->m_medias) < pos_media + 1))\n    return NULL;\n  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);\n  if (med->k_key == NULL)\n    return NULL;\n  return med->k_key->k_keytype;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "char",
        "*\nsdp_message_k_keytype_get (sdp_message_t * sdp, int pos_media)",
        "*"
      ]
    },
    "sdp_message_k_keydata_get": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "char *\nsdp_message_k_keydata_get (sdp_message_t * sdp, int pos_media)\n{\n  sdp_media_t *med;\n\n  if (sdp == NULL)\n    return NULL;\n  if (pos_media == -1) {\n    if (sdp->k_key == NULL)\n      return NULL;\n    return sdp->k_key->k_keydata;\n  }\n  if ((pos_media != -1) && (osip_list_size (&sdp->m_medias) < pos_media + 1))\n    return NULL;\n  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);\n  if (med->k_key == NULL)\n    return NULL;\n  return med->k_key->k_keydata;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "char",
        "*\nsdp_message_k_keydata_get (sdp_message_t * sdp, int pos_media)",
        "*"
      ]
    },
    "sdp_message_a_attribute_add": {
      "start_point": [
        516,
        0
      ],
      "end_point": [
        539,
        1
      ],
      "content": "int\nsdp_message_a_attribute_add (sdp_message_t * sdp, int pos_media, char *att_field, char *att_value)\n{\n  int i;\n  sdp_media_t *med;\n  sdp_attribute_t *attr;\n\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  if ((pos_media != -1) && (osip_list_size (&sdp->m_medias) < pos_media + 1))\n    return OSIP_UNDEFINED_ERROR;\n  i = sdp_attribute_init (&attr);\n  if (i != 0)\n    return i;\n  attr->a_att_field = att_field;\n  attr->a_att_value = att_value;\n  if (pos_media == -1) {\n    osip_list_add (&sdp->a_attributes, attr, -1);\n    return OSIP_SUCCESS;\n  }\n  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);\n  osip_list_add (&med->a_attributes, attr, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_a_attribute_del": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "int\nsdp_message_a_attribute_del (sdp_message_t * sdp, int pos_media, char *att_field)\n{\n  int i;\n  sdp_media_t *med;\n  sdp_attribute_t *attr;\n\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  if ((pos_media != -1) && (osip_list_size (&sdp->m_medias) < pos_media + 1))\n    return OSIP_UNDEFINED_ERROR;\n  if (pos_media == -1) {\n    for (i = 0; i < osip_list_size (&sdp->a_attributes);) {\n      attr = osip_list_get (&sdp->a_attributes, i);\n      if (strcmp (attr->a_att_field, att_field) == 0) {\n        osip_list_remove (&sdp->a_attributes, i);\n        sdp_attribute_free (attr);\n      }\n      else\n        i++;\n    }\n    return OSIP_SUCCESS;\n  }\n  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);\n  if (med == NULL)\n    return OSIP_UNDEFINED_ERROR;\n  for (i = 0; i < osip_list_size (&med->a_attributes);) {\n    attr = osip_list_get (&med->a_attributes, i);\n    if (strcmp (attr->a_att_field, att_field) == 0) {\n      osip_list_remove (&med->a_attributes, i);\n      sdp_attribute_free (attr);\n    }\n    else\n      i++;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_a_attribute_del_at_index": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        627,
        1
      ],
      "content": "int\nsdp_message_a_attribute_del_at_index (sdp_message_t * sdp, int pos_media, char *att_field, int pos_attr)\n{\n  int i;\n  sdp_media_t *med;\n  sdp_attribute_t *attr;\n\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  if ((pos_media != -1) && (osip_list_size (&sdp->m_medias) < pos_media + 1))\n    return OSIP_UNDEFINED_ERROR;\n  if (pos_media == -1) {\n    if (pos_attr == -1) {\n      for (i = 0; i < osip_list_size (&sdp->a_attributes);) {\n        attr = osip_list_get (&sdp->a_attributes, i);\n        if (strcmp (attr->a_att_field, att_field) == 0) {\n          osip_list_remove (&sdp->a_attributes, i);\n          sdp_attribute_free (attr);\n        }\n        else\n          i++;\n      }\n    }\n    else if ((attr = osip_list_get (&sdp->a_attributes, pos_attr)) != NULL) {\n      osip_list_remove (&sdp->a_attributes, pos_attr);\n      sdp_attribute_free (attr);\n    }\n    return OSIP_SUCCESS;\n  }\n  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);\n  if (med == NULL)\n    return OSIP_UNDEFINED_ERROR;\n  for (i = 0; i < osip_list_size (&med->a_attributes);) {\n    if (pos_attr == -1) {\n      attr = osip_list_get (&med->a_attributes, i);\n      if (strcmp (attr->a_att_field, att_field) == 0) {\n        osip_list_remove (&med->a_attributes, i);\n        sdp_attribute_free (attr);\n      }\n      else\n        i++;\n    }\n    else if ((attr = osip_list_get (&med->a_attributes, pos_attr)) != NULL) {\n      osip_list_remove (&med->a_attributes, pos_attr);\n      sdp_attribute_free (attr);\n    }\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 49,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_attribute_get": {
      "start_point": [
        630,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "sdp_attribute_t *\nsdp_message_attribute_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_media_t *med;\n\n  if (sdp == NULL)\n    return NULL;\n  if (pos_media == -1)\n    return (sdp_attribute_t *) osip_list_get (&sdp->a_attributes, pos);\n  med = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos_media);\n  if (med == NULL)\n    return NULL;\n  return (sdp_attribute_t *) osip_list_get (&med->a_attributes, pos);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "sdp_attribute_t",
        "*\nsdp_message_attribute_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_a_att_field_get": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        653,
        1
      ],
      "content": "char *\nsdp_message_a_att_field_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_attribute_t *attr = sdp_message_attribute_get (sdp, pos_media, pos);\n\n  if (attr == NULL)\n    return NULL;\n  return attr->a_att_field;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_a_att_field_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_a_att_value_get": {
      "start_point": [
        655,
        0
      ],
      "end_point": [
        663,
        1
      ],
      "content": "char *\nsdp_message_a_att_value_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_attribute_t *attr = sdp_message_attribute_get (sdp, pos_media, pos);\n\n  if (attr == NULL)\n    return NULL;\n  return attr->a_att_value;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nsdp_message_a_att_value_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_endof_media": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        675,
        1
      ],
      "content": "int\nsdp_message_endof_media (sdp_message_t * sdp, int i)\n{\n  if (sdp == NULL)\n    return OSIP_BADPARAMETER;\n  if (i == -1)\n    return OSIP_SUCCESS;\n  if (!osip_list_eol (&sdp->m_medias, i))\n    return OSIP_SUCCESS;        /* not end of list */\n  return OSIP_UNDEFINED_ERROR;  /* end of list */\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_m_media_add": {
      "start_point": [
        677,
        0
      ],
      "end_point": [
        692,
        1
      ],
      "content": "int\nsdp_message_m_media_add (sdp_message_t * sdp, char *media, char *port, char *number_of_port, char *proto)\n{\n  int i;\n  sdp_media_t *med;\n\n  i = sdp_media_init (&med);\n  if (i != 0)\n    return i;\n  med->m_media = media;\n  med->m_port = port;\n  med->m_number_of_port = number_of_port;\n  med->m_proto = proto;\n  osip_list_add (&sdp->m_medias, med, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_m_media_get": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        702,
        1
      ],
      "content": "char *\nsdp_message_m_media_get (sdp_message_t * sdp, int pos_media)\n{\n  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);\n\n  if (med == NULL)\n    return NULL;\n  return med->m_media;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsdp_message_m_media_get (sdp_message_t * sdp, int pos_media)",
        "*"
      ]
    },
    "sdp_message_m_port_get": {
      "start_point": [
        704,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "char *\nsdp_message_m_port_get (sdp_message_t * sdp, int pos_media)\n{\n  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);\n\n  if (med == NULL)\n    return NULL;\n  return med->m_port;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsdp_message_m_port_get (sdp_message_t * sdp, int pos_media)",
        "*"
      ]
    },
    "sdp_message_m_number_of_port_get": {
      "start_point": [
        714,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "char *\nsdp_message_m_number_of_port_get (sdp_message_t * sdp, int pos_media)\n{\n  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);\n\n  if (med == NULL)\n    return NULL;\n  return med->m_number_of_port;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsdp_message_m_number_of_port_get (sdp_message_t * sdp, int pos_media)",
        "*"
      ]
    },
    "sdp_message_m_port_set": {
      "start_point": [
        724,
        0
      ],
      "end_point": [
        735,
        1
      ],
      "content": "int\nsdp_message_m_port_set (sdp_message_t * sdp, int pos_media, char *port)\n{\n  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);\n\n  if (med == NULL)\n    return OSIP_BADPARAMETER;\n  if (med->m_port)\n    osip_free (med->m_port);\n  med->m_port = port;\n  return OSIP_SUCCESS;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_m_proto_get": {
      "start_point": [
        737,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "char *\nsdp_message_m_proto_get (sdp_message_t * sdp, int pos_media)\n{\n  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);\n\n  if (med == NULL)\n    return NULL;\n  return med->m_proto;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsdp_message_m_proto_get (sdp_message_t * sdp, int pos_media)",
        "*"
      ]
    },
    "sdp_message_m_payload_add": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        756,
        1
      ],
      "content": "int\nsdp_message_m_payload_add (sdp_message_t * sdp, int pos_media, char *payload)\n{\n  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);\n\n  if (med == NULL)\n    return OSIP_BADPARAMETER;\n  osip_list_add (&med->m_payloads, payload, -1);\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_m_payload_get": {
      "start_point": [
        758,
        0
      ],
      "end_point": [
        766,
        1
      ],
      "content": "char *\nsdp_message_m_payload_get (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);\n\n  if (med == NULL)\n    return NULL;\n  return (char *) osip_list_get (&med->m_payloads, pos);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsdp_message_m_payload_get (sdp_message_t * sdp, int pos_media, int pos)",
        "*"
      ]
    },
    "sdp_message_m_payload_del": {
      "start_point": [
        768,
        0
      ],
      "end_point": [
        781,
        1
      ],
      "content": "int\nsdp_message_m_payload_del (sdp_message_t * sdp, int pos_media, int pos)\n{\n  sdp_media_t *med = osip_list_get (&sdp->m_medias, pos_media);\n  char *payload;\n\n  if (med == NULL)\n    return OSIP_BADPARAMETER;\n  if ((payload = osip_list_get (&med->m_payloads, pos)) == NULL)\n    return OSIP_UNDEFINED_ERROR;\n  osip_list_remove (&med->m_payloads, pos);\n  osip_free (payload);\n  return OSIP_SUCCESS;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/osipparser2/sdp_message.c": {
    "sdp_bandwidth_init": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nsdp_bandwidth_init (sdp_bandwidth_t ** b)\n{\n  *b = (sdp_bandwidth_t *) osip_malloc (sizeof (sdp_bandwidth_t));\n  if (*b == NULL)\n    return OSIP_NOMEM;\n  (*b)->b_bwtype = NULL;\n  (*b)->b_bandwidth = NULL;\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sdp_bandwidth_free": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\nsdp_bandwidth_free (sdp_bandwidth_t * b)\n{\n  if (b == NULL)\n    return;\n  osip_free (b->b_bwtype);\n  osip_free (b->b_bandwidth);\n  osip_free (b);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sdp_time_descr_init": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nsdp_time_descr_init (sdp_time_descr_t ** td)\n{\n  *td = (sdp_time_descr_t *) osip_malloc (sizeof (sdp_time_descr_t));\n  if (*td == NULL)\n    return OSIP_NOMEM;\n  (*td)->t_start_time = NULL;\n  (*td)->t_stop_time = NULL;\n  osip_list_init (&(*td)->r_repeats);\n  return OSIP_SUCCESS;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sdp_time_descr_free": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\nsdp_time_descr_free (sdp_time_descr_t * td)\n{\n  if (td == NULL)\n    return;\n  osip_free (td->t_start_time);\n  osip_free (td->t_stop_time);\n  osip_list_ofchar_free (&td->r_repeats);\n  osip_free (td);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sdp_key_init": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nsdp_key_init (sdp_key_t ** key)\n{\n  *key = (sdp_key_t *) osip_malloc (sizeof (sdp_key_t));\n  if (*key == NULL)\n    return OSIP_NOMEM;\n  (*key)->k_keytype = NULL;\n  (*key)->k_keydata = NULL;\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sdp_key_free": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void\nsdp_key_free (sdp_key_t * key)\n{\n  if (key == NULL)\n    return;\n  osip_free (key->k_keytype);\n  osip_free (key->k_keydata);\n  osip_free (key);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sdp_attribute_init": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\nsdp_attribute_init (sdp_attribute_t ** attribute)\n{\n  *attribute = (sdp_attribute_t *) osip_malloc (sizeof (sdp_attribute_t));\n  if (*attribute == NULL)\n    return OSIP_NOMEM;\n  (*attribute)->a_att_field = NULL;\n  (*attribute)->a_att_value = NULL;\n  return OSIP_SUCCESS;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sdp_attribute_free": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "void\nsdp_attribute_free (sdp_attribute_t * attribute)\n{\n  if (attribute == NULL)\n    return;\n  osip_free (attribute->a_att_field);\n  osip_free (attribute->a_att_value);\n  osip_free (attribute);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sdp_connection_init": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nsdp_connection_init (sdp_connection_t ** connection)\n{\n  *connection = (sdp_connection_t *) osip_malloc (sizeof (sdp_connection_t));\n  if (*connection == NULL)\n    return OSIP_NOMEM;\n  (*connection)->c_nettype = NULL;\n  (*connection)->c_addrtype = NULL;\n  (*connection)->c_addr = NULL;\n  (*connection)->c_addr_multicast_ttl = NULL;\n  (*connection)->c_addr_multicast_int = NULL;\n  return OSIP_SUCCESS;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sdp_connection_free": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\nsdp_connection_free (sdp_connection_t * connection)\n{\n  if (connection == NULL)\n    return;\n  osip_free (connection->c_nettype);\n  osip_free (connection->c_addrtype);\n  osip_free (connection->c_addr);\n  osip_free (connection->c_addr_multicast_ttl);\n  osip_free (connection->c_addr_multicast_int);\n  osip_free (connection);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sdp_media_init": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "int\nsdp_media_init (sdp_media_t ** media)\n{\n  int i;\n\n  *media = (sdp_media_t *) osip_malloc (sizeof (sdp_media_t));\n  if (*media == NULL)\n    return OSIP_NOMEM;\n  (*media)->m_media = NULL;\n  (*media)->m_port = NULL;\n  (*media)->m_number_of_port = NULL;\n  (*media)->m_proto = NULL;\n  i = osip_list_init (&(*media)->m_payloads);\n  if (i != 0) {\n    osip_free (*media);\n    *media = NULL;\n    return OSIP_NOMEM;\n  }\n  (*media)->i_info = NULL;\n  i = osip_list_init (&(*media)->c_connections);\n  if (i != 0) {\n    osip_list_ofchar_free (&(*media)->m_payloads);\n    osip_free (*media);\n    *media = NULL;\n    return OSIP_NOMEM;\n  }\n  i = osip_list_init (&(*media)->b_bandwidths);\n  if (i != 0) {\n    osip_list_ofchar_free (&(*media)->m_payloads);\n    osip_list_special_free (&(*media)->c_connections, (void (*)(void *)) &sdp_connection_free);\n    osip_free (*media);\n    *media = NULL;\n    return OSIP_NOMEM;\n  }\n  i = osip_list_init (&(*media)->a_attributes);\n  if (i != 0) {\n    osip_list_ofchar_free (&(*media)->m_payloads);\n    osip_list_special_free (&(*media)->c_connections, (void (*)(void *)) &sdp_connection_free);\n    osip_list_special_free (&(*media)->b_bandwidths, (void (*)(void *)) &sdp_bandwidth_free);\n    osip_free (*media);\n    *media = NULL;\n    return OSIP_NOMEM;\n  }\n  (*media)->k_key = NULL;\n  return OSIP_SUCCESS;\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "sdp_media_free": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "void\nsdp_media_free (sdp_media_t * media)\n{\n  if (media == NULL)\n    return;\n  osip_free (media->m_media);\n  osip_free (media->m_port);\n  osip_free (media->m_number_of_port);\n  osip_free (media->m_proto);\n  osip_list_ofchar_free (&media->m_payloads);\n  osip_free (media->i_info);\n  osip_list_special_free (&media->c_connections, (void (*)(void *)) &sdp_connection_free);\n  osip_list_special_free (&media->b_bandwidths, (void (*)(void *)) &sdp_bandwidth_free);\n  osip_list_special_free (&media->a_attributes, (void (*)(void *)) &sdp_attribute_free);\n  sdp_key_free (media->k_key);\n  osip_free (media);\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "sdp_message_init": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "int\nsdp_message_init (sdp_message_t ** sdp)\n{\n  int i;\n\n  (*sdp) = (sdp_message_t *) osip_malloc (sizeof (sdp_message_t));\n  if (*sdp == NULL)\n    return OSIP_NOMEM;\n\n  (*sdp)->v_version = NULL;\n  (*sdp)->o_username = NULL;\n  (*sdp)->o_sess_id = NULL;\n  (*sdp)->o_sess_version = NULL;\n  (*sdp)->o_nettype = NULL;\n  (*sdp)->o_addrtype = NULL;\n  (*sdp)->o_addr = NULL;\n  (*sdp)->s_name = NULL;\n  (*sdp)->i_info = NULL;\n  (*sdp)->u_uri = NULL;\n\n  i = osip_list_init (&(*sdp)->e_emails);\n  if (i != 0) {\n    osip_list_ofchar_free (&(*sdp)->e_emails);\n    osip_free (*sdp);\n    *sdp = NULL;\n    return OSIP_NOMEM;\n  }\n\n  i = osip_list_init (&(*sdp)->p_phones);\n  if (i != 0) {\n    osip_list_ofchar_free (&(*sdp)->e_emails);\n    osip_free (*sdp);\n    *sdp = NULL;\n    return OSIP_NOMEM;\n  }\n\n  (*sdp)->c_connection = NULL;\n\n  i = osip_list_init (&(*sdp)->b_bandwidths);\n  if (i != 0) {\n    osip_list_ofchar_free (&(*sdp)->e_emails);\n    osip_list_ofchar_free (&(*sdp)->p_phones);\n    osip_free (*sdp);\n    *sdp = NULL;\n    return OSIP_NOMEM;\n  }\n\n  i = osip_list_init (&(*sdp)->t_descrs);\n  if (i != 0) {\n    osip_list_ofchar_free (&(*sdp)->e_emails);\n    osip_list_ofchar_free (&(*sdp)->p_phones);\n    osip_list_special_free (&(*sdp)->b_bandwidths, (void (*)(void *)) &sdp_bandwidth_free);\n    osip_free (*sdp);\n    *sdp = NULL;\n    return OSIP_NOMEM;\n  }\n\n  (*sdp)->z_adjustments = NULL;\n  (*sdp)->k_key = NULL;\n\n  i = osip_list_init (&(*sdp)->a_attributes);\n  if (i != 0) {\n    osip_list_ofchar_free (&(*sdp)->e_emails);\n    osip_list_ofchar_free (&(*sdp)->p_phones);\n    osip_list_special_free (&(*sdp)->b_bandwidths, (void (*)(void *)) &sdp_bandwidth_free);\n    osip_list_special_free (&(*sdp)->t_descrs, (void (*)(void *)) &sdp_time_descr_free);\n    osip_free (*sdp);\n    *sdp = NULL;\n    return OSIP_NOMEM;\n  }\n\n  i = osip_list_init (&(*sdp)->m_medias);\n  if (i != 0) {\n    osip_list_ofchar_free (&(*sdp)->e_emails);\n    osip_list_ofchar_free (&(*sdp)->p_phones);\n    osip_list_special_free (&(*sdp)->b_bandwidths, (void (*)(void *)) &sdp_bandwidth_free);\n    osip_list_special_free (&(*sdp)->t_descrs, (void (*)(void *)) &sdp_time_descr_free);\n    osip_list_special_free (&(*sdp)->a_attributes, (void (*)(void *)) &sdp_attribute_free);\n    osip_free (*sdp);\n    *sdp = NULL;\n    return OSIP_NOMEM;\n  }\n  return OSIP_SUCCESS;\n}",
      "lines": 84,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "__osip_sdp_append_string": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "static char *\n__osip_sdp_append_string (char **string, int *size, char *cur, char *string_osip_to_append)\n{\n  int length = (int) strlen (string_osip_to_append);\n\n  if (cur - (*string) + length +1 > *size) {\n    int length2;\n    length2 = (int) (cur - *string);\n    (*string) = osip_realloc ((*string), *size + length + 500);\n    *size = *size + length + 500; /* optimize: avoid too much realloc */\n    cur = (*string) + length2;  /* the initial allocation may have changed! */\n  }\n  osip_strncpy (cur, string_osip_to_append, length);\n  return cur + strlen (cur);\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\n__osip_sdp_append_string (char **string, int *size, char *cur, char *string_osip_to_append)",
        "*"
      ]
    },
    "sdp_message_parse_v": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "static int\nsdp_message_parse_v (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  if (equal == buf)\n    return ERR_DISCARD;\n\n  /* check if header is \"v\" */\n  if (equal[-1] != 'v')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /*v=\\r ?? bad header */\n  sdp->v_version = osip_malloc (crlf - (equal + 1) + 1);\n  if (sdp->v_version == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (sdp->v_version, equal + 1, crlf - (equal + 1));\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_o": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        468,
        1
      ],
      "content": "static int\nsdp_message_parse_o (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  char *tmp;\n  char *tmp_next;\n  int i;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"o\" */\n  if (equal[-1] != 'o')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* o=\\r ?? bad header */\n\n  tmp = equal + 1;\n  /* o=username sess-id sess-version nettype addrtype addr */\n\n  /* useranme can contain any char (ascii) except \"space\" and CRLF */\n#ifdef FIREFLY_BUG_SUPPORT\n  if (tmp[0] == ' ') {\n    sdp->o_username = osip_strdup (\"firefly\");\n    tmp++;\n  }\n  else {\n    i = __osip_set_next_token (&(sdp->o_username), tmp, ' ', &tmp_next);\n    if (i != 0)\n      return -1;\n    tmp = tmp_next;\n  }\n#else\n  i = __osip_set_next_token (&(sdp->o_username), tmp, ' ', &tmp_next);\n  if (i != 0)\n    return -1;\n  tmp = tmp_next;\n#endif\n\n  /* sess_id contains only numeric characters */\n  i = __osip_set_next_token (&(sdp->o_sess_id), tmp, ' ', &tmp_next);\n  if (i != 0)\n    return -1;\n  tmp = tmp_next;\n\n  /* sess_id contains only numeric characters */\n  i = __osip_set_next_token (&(sdp->o_sess_version), tmp, ' ', &tmp_next);\n  if (i != 0)\n    return -1;\n  tmp = tmp_next;\n\n  /* nettype is \"IN\" but will surely be extented!!! assume it's some alpha-char */\n  i = __osip_set_next_token (&(sdp->o_nettype), tmp, ' ', &tmp_next);\n  if (i != 0)\n    return -1;\n  tmp = tmp_next;\n\n  /* addrtype  is \"IP4\" or \"IP6\" but will surely be extented!!! */\n  i = __osip_set_next_token (&(sdp->o_addrtype), tmp, ' ', &tmp_next);\n  if (i != 0)\n    return -1;\n  tmp = tmp_next;\n\n  /* addr  is \"IP4\" or \"IP6\" but will surely be extented!!! */\n  i = __osip_set_next_token (&(sdp->o_addr), tmp, '\\r', &tmp_next);\n  if (i != 0) {                 /* could it be \"\\n\" only??? rfc says to accept CR or LF instead of CRLF */\n    i = __osip_set_next_token (&(sdp->o_addr), tmp, '\\n', &tmp_next);\n    if (i != 0)\n      return -1;\n  }\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 90,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_s": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "static int\nsdp_message_parse_s (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"s\" */\n  if (equal[-1] != 's')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n#ifdef FIREFLY_BUG_SUPPORT\n  if (crlf == equal + 1) {\n    sdp->s_name = osip_strdup (\" \");\n    if (crlf[1] == '\\n')\n      *next = crlf + 2;\n    else\n      *next = crlf + 1;\n    return WF;                  /* o=\\r ?? bad header */\n  }\n#else\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* o=\\r ?? bad header */\n#endif\n\n  /* s=text */\n\n  /* text is interpreted as ISO-10646 UTF8! */\n  /* using ISO 8859-1 requires \"a=charset:ISO-8859-1 */\n  sdp->s_name = osip_malloc (crlf - (equal + 1) + 1);\n  if (sdp->s_name == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (sdp->s_name, equal + 1, crlf - (equal + 1));\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 53,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_i": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        580,
        1
      ],
      "content": "static int\nsdp_message_parse_i (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  int i;\n  char *i_info;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"i\" */\n  if (equal[-1] != 'i')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* o=\\r ?? bad header */\n\n  /* s=text */\n\n  /* text is interpreted as ISO-10646 UTF8! */\n  /* using ISO 8859-1 requires \"a=charset:ISO-8859-1 */\n  i_info = osip_malloc (crlf - (equal + 1) + 1);\n  if (i_info == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (i_info, equal + 1, crlf - (equal + 1));\n\n  /* add the bandwidth at the correct place:\n     if there is no media line yet, then the \"b=\" is the\n     global one.\n   */\n  i = osip_list_size (&sdp->m_medias);\n  if (i == 0)\n    sdp->i_info = i_info;\n  else {\n    sdp_media_t *last_sdp_media = (sdp_media_t *) osip_list_get (&sdp->m_medias, i - 1);\n\n    last_sdp_media->i_info = i_info;\n  }\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_u": {
      "start_point": [
        582,
        0
      ],
      "end_point": [
        621,
        1
      ],
      "content": "static int\nsdp_message_parse_u (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"u\" */\n  if (equal[-1] != 'u')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* u=\\r ?? bad header */\n\n  /* u=uri */\n  /* we assume this is a URI */\n  sdp->u_uri = osip_malloc (crlf - (equal + 1) + 1);\n  if (sdp->u_uri == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (sdp->u_uri, equal + 1, crlf - (equal + 1));\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_e": {
      "start_point": [
        623,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "static int\nsdp_message_parse_e (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  char *e_email;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"e\" */\n  if (equal[-1] != 'e')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* e=\\r ?? bad header */\n\n  /* e=email */\n  /* we assume this is an EMAIL-ADDRESS */\n  e_email = osip_malloc (crlf - (equal + 1) + 1);\n  if (e_email == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (e_email, equal + 1, crlf - (equal + 1));\n\n  osip_list_add (&sdp->e_emails, e_email, -1);\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_p": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        709,
        1
      ],
      "content": "static int\nsdp_message_parse_p (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  char *p_phone;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"p\" */\n  if (equal[-1] != 'p')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* p=\\r ?? bad header */\n\n  /* e=email */\n  /* we assume this is an EMAIL-ADDRESS */\n  p_phone = osip_malloc (crlf - (equal + 1) + 1);\n  if (p_phone == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (p_phone, equal + 1, crlf - (equal + 1));\n\n  osip_list_add (&sdp->p_phones, p_phone, -1);\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_c": {
      "start_point": [
        711,
        0
      ],
      "end_point": [
        837,
        1
      ],
      "content": "static int\nsdp_message_parse_c (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  char *tmp;\n  char *tmp_next;\n  sdp_connection_t *c_header;\n  int i;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"c\" */\n  if (equal[-1] != 'c')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* c=\\r ?? bad header */\n\n  tmp = equal + 1;\n  i = sdp_connection_init (&c_header);\n  if (i != 0)\n    return ERR_ERROR;\n  /* c=nettype addrtype (multicastaddr | addr) */\n\n  /* nettype is \"IN\" and will be extended */\n  i = __osip_set_next_token (&(c_header->c_nettype), tmp, ' ', &tmp_next);\n  if (i != 0) {\n    sdp_connection_free (c_header);\n    return -1;\n  }\n  tmp = tmp_next;\n\n  /* nettype is \"IP4\" or \"IP6\" and will be extended */\n  i = __osip_set_next_token (&(c_header->c_addrtype), tmp, ' ', &tmp_next);\n  if (i != 0) {\n    sdp_connection_free (c_header);\n    return -1;\n  }\n  tmp = tmp_next;\n\n  /* there we have a multicast or unicast address */\n  /* multicast can be ip/ttl [/integer] */\n  /* unicast is FQDN or ip (no ttl, no integer) */\n\n  /* is MULTICAST? */\n  {\n    char *slash = strchr (tmp, '/');\n\n    if (slash != NULL && slash < crlf) {        /* it's a multicast address! */\n      i = __osip_set_next_token (&(c_header->c_addr), tmp, '/', &tmp_next);\n      if (i != 0) {\n        sdp_connection_free (c_header);\n        return -1;\n      }\n      tmp = tmp_next;\n      slash = strchr (slash + 1, '/');\n      if (slash != NULL && slash < crlf) {      /* optionnal integer is there! */\n        i = __osip_set_next_token (&(c_header->c_addr_multicast_ttl), tmp, '/', &tmp_next);\n        if (i != 0) {\n          sdp_connection_free (c_header);\n          return -1;\n        }\n        tmp = tmp_next;\n        i = __osip_set_next_token (&(c_header->c_addr_multicast_int), tmp, '\\r', &tmp_next);\n        if (i != 0) {\n          i = __osip_set_next_token (&(c_header->c_addr_multicast_int), tmp, '\\n', &tmp_next);\n          if (i != 0) {\n            sdp_connection_free (c_header);\n            return -1;\n          }\n        }\n      }\n      else {\n        i = __osip_set_next_token (&(c_header->c_addr_multicast_ttl), tmp, '\\r', &tmp_next);\n        if (i != 0) {\n          i = __osip_set_next_token (&(c_header->c_addr_multicast_ttl), tmp, '\\n', &tmp_next);\n          if (i != 0) {\n            sdp_connection_free (c_header);\n            return -1;\n          }\n        }\n      }\n    }\n    else {\n      /* in this case, we have a unicast address */\n      i = __osip_set_next_token (&(c_header->c_addr), tmp, '\\r', &tmp_next);\n      if (i != 0) {\n        i = __osip_set_next_token (&(c_header->c_addr), tmp, '\\n', &tmp_next);\n        if (i != 0) {\n          sdp_connection_free (c_header);\n          return -1;\n        }\n      }\n    }\n  }\n\n  /* add the connection at the correct place:\n     if there is no media line yet, then the \"c=\" is the\n     global one.\n   */\n  i = osip_list_size (&sdp->m_medias);\n  if (i == 0)\n    sdp->c_connection = c_header;\n  else {\n    sdp_media_t *last_sdp_media = (sdp_media_t *) osip_list_get (&sdp->m_medias, i - 1);\n\n    osip_list_add (&last_sdp_media->c_connections, c_header, -1);\n  }\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 127,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_b": {
      "start_point": [
        839,
        0
      ],
      "end_point": [
        911,
        1
      ],
      "content": "static int\nsdp_message_parse_b (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  char *tmp;\n  char *tmp_next;\n  int i;\n  sdp_bandwidth_t *b_header;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"b\" */\n  if (equal[-1] != 'b')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* b=\\r ?? bad header */\n\n  tmp = equal + 1;\n  /* b = bwtype: bandwidth */\n  i = sdp_bandwidth_init (&b_header);\n  if (i != 0)\n    return ERR_ERROR;\n\n  /* bwtype is alpha-numeric */\n  i = __osip_set_next_token (&(b_header->b_bwtype), tmp, ':', &tmp_next);\n  if (i != 0) {\n    sdp_bandwidth_free (b_header);\n    return -1;\n  }\n  tmp = tmp_next;\n\n  i = __osip_set_next_token (&(b_header->b_bandwidth), tmp, '\\r', &tmp_next);\n  if (i != 0) {\n    i = __osip_set_next_token (&(b_header->b_bandwidth), tmp, '\\n', &tmp_next);\n    if (i != 0) {\n      sdp_bandwidth_free (b_header);\n      return -1;\n    }\n  }\n\n  /* add the bandwidth at the correct place:\n     if there is no media line yet, then the \"b=\" is the\n     global one.\n   */\n  i = osip_list_size (&sdp->m_medias);\n  if (i == 0)\n    osip_list_add (&sdp->b_bandwidths, b_header, -1);\n  else {\n    sdp_media_t *last_sdp_media = (sdp_media_t *) osip_list_get (&sdp->m_medias, i - 1);\n\n    osip_list_add (&last_sdp_media->b_bandwidths, b_header, -1);\n  }\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 73,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_t": {
      "start_point": [
        913,
        0
      ],
      "end_point": [
        974,
        1
      ],
      "content": "static int\nsdp_message_parse_t (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  char *tmp;\n  char *tmp_next;\n  int i;\n  sdp_time_descr_t *t_header;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"t\" */\n  if (equal[-1] != 't')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* t=\\r ?? bad header */\n\n  tmp = equal + 1;\n  /* t = start_time stop_time */\n  i = sdp_time_descr_init (&t_header);\n  if (i != 0)\n    return ERR_ERROR;\n\n  i = __osip_set_next_token (&(t_header->t_start_time), tmp, ' ', &tmp_next);\n  if (i != 0) {\n    sdp_time_descr_free (t_header);\n    return -1;\n  }\n  tmp = tmp_next;\n\n  i = __osip_set_next_token (&(t_header->t_stop_time), tmp, '\\r', &tmp_next);\n  if (i != 0) {\n    i = __osip_set_next_token (&(t_header->t_stop_time), tmp, '\\n', &tmp_next);\n    if (i != 0) {\n      sdp_time_descr_free (t_header);\n      return -1;\n    }\n  }\n\n  /* add the new time_description header */\n  osip_list_add (&sdp->t_descrs, t_header, -1);\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_r": {
      "start_point": [
        976,
        0
      ],
      "end_point": [
        1025,
        1
      ],
      "content": "static int\nsdp_message_parse_r (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  int index;\n  char *r_header;\n  sdp_time_descr_t *t_descr;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"r\" */\n  if (equal[-1] != 'r')\n    return ERR_DISCARD;\n\n  index = osip_list_size (&sdp->t_descrs);\n  if (index == 0)\n    return ERR_ERROR;           /* r field can't come alone! */\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* r=\\r ?? bad header */\n\n  /* r=far too complexe and somewhat useless... I don't parse it! */\n  r_header = osip_malloc (crlf - (equal + 1) + 1);\n  if (r_header == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (r_header, equal + 1, crlf - (equal + 1));\n\n  /* r field carry information for the last \"t\" field */\n  t_descr = (sdp_time_descr_t *) osip_list_get (&sdp->t_descrs, index - 1);\n  osip_list_add (&t_descr->r_repeats, r_header, -1);\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_z": {
      "start_point": [
        1027,
        0
      ],
      "end_point": [
        1068,
        1
      ],
      "content": "static int\nsdp_message_parse_z (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  char *z_header;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"z\" */\n  if (equal[-1] != 'z')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* z=\\r ?? bad header */\n\n  /* z=somewhat useless... I don't parse it! */\n  z_header = osip_malloc (crlf - (equal + 1) + 1);\n  if (z_header == NULL)\n    return OSIP_NOMEM;\n  osip_strncpy (z_header, equal + 1, crlf - (equal + 1));\n\n  sdp->z_adjustments = z_header;\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_k": {
      "start_point": [
        1070,
        0
      ],
      "end_point": [
        1158,
        1
      ],
      "content": "static int\nsdp_message_parse_k (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  int i;\n  char *colon;\n  sdp_key_t *k_header;\n  char *tmp;\n  char *tmp_next;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"k\" */\n  if (equal[-1] != 'k')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* k=\\r ?? bad header */\n\n  tmp = equal + 1;\n\n  i = sdp_key_init (&k_header);\n  if (i != 0)\n    return ERR_ERROR;\n  /* k=key-type[:key-data] */\n\n  /* is there any key-data? */\n  colon = strchr (equal + 1, ':');\n  if ((colon != NULL) && (colon < crlf)) {\n    /* att-field is alpha-numeric */\n    i = __osip_set_next_token (&(k_header->k_keytype), tmp, ':', &tmp_next);\n    if (i != 0) {\n      sdp_key_free (k_header);\n      return -1;\n    }\n    tmp = tmp_next;\n\n    i = __osip_set_next_token (&(k_header->k_keydata), tmp, '\\r', &tmp_next);\n    if (i != 0) {\n      i = __osip_set_next_token (&(k_header->k_keydata), tmp, '\\n', &tmp_next);\n      if (i != 0) {\n        sdp_key_free (k_header);\n        return -1;\n      }\n    }\n  }\n  else {\n    i = __osip_set_next_token (&(k_header->k_keytype), tmp, '\\r', &tmp_next);\n    if (i != 0) {\n      i = __osip_set_next_token (&(k_header->k_keytype), tmp, '\\n', &tmp_next);\n      if (i != 0) {\n        sdp_key_free (k_header);\n        return -1;\n      }\n    }\n  }\n\n  /* add the key at the correct place:\n     if there is no media line yet, then the \"k=\" is the\n     global one.\n   */\n  i = osip_list_size (&sdp->m_medias);\n  if (i == 0)\n    sdp->k_key = k_header;\n  else {\n    sdp_media_t *last_sdp_media = (sdp_media_t *) osip_list_get (&sdp->m_medias, i - 1);\n\n    last_sdp_media->k_key = k_header;\n  }\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 89,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_a": {
      "start_point": [
        1160,
        0
      ],
      "end_point": [
        1249,
        1
      ],
      "content": "static int\nsdp_message_parse_a (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  char *tmp;\n  char *tmp_next;\n  int i;\n  sdp_attribute_t *a_attribute;\n  char *colon;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"a\" */\n  if (equal[-1] != 'a')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* a=\\r ?? bad header */\n\n  tmp = equal + 1;\n\n  i = sdp_attribute_init (&a_attribute);\n  if (i != 0)\n    return ERR_ERROR;\n\n  /* a=att-field[:att-value] */\n\n  /* is there any att-value? */\n  colon = strchr (equal + 1, ':');\n  if ((colon != NULL) && (colon < crlf)) {\n    /* att-field is alpha-numeric */\n    i = __osip_set_next_token (&(a_attribute->a_att_field), tmp, ':', &tmp_next);\n    if (i != 0) {\n      sdp_attribute_free (a_attribute);\n      return -1;\n    }\n    tmp = tmp_next;\n\n    i = __osip_set_next_token (&(a_attribute->a_att_value), tmp, '\\r', &tmp_next);\n    if (i != 0) {\n      i = __osip_set_next_token (&(a_attribute->a_att_value), tmp, '\\n', &tmp_next);\n      if (i != 0) {\n        sdp_attribute_free (a_attribute);\n        return -1;\n      }\n    }\n  }\n  else {\n    i = __osip_set_next_token (&(a_attribute->a_att_field), tmp, '\\r', &tmp_next);\n    if (i != 0) {\n      i = __osip_set_next_token (&(a_attribute->a_att_field), tmp, '\\n', &tmp_next);\n      if (i != 0) {\n        sdp_attribute_free (a_attribute);\n        return -1;\n      }\n    }\n  }\n\n  /* add the attribute at the correct place:\n     if there is no media line yet, then the \"a=\" is the\n     global one.\n   */\n  i = osip_list_size (&sdp->m_medias);\n  if (i == 0)\n    osip_list_add (&sdp->a_attributes, a_attribute, -1);\n  else {\n    sdp_media_t *last_sdp_media = (sdp_media_t *) osip_list_get (&sdp->m_medias, i - 1);\n\n    osip_list_add (&last_sdp_media->a_attributes, a_attribute, -1);\n  }\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 90,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse_m": {
      "start_point": [
        1251,
        0
      ],
      "end_point": [
        1392,
        1
      ],
      "content": "static int\nsdp_message_parse_m (sdp_message_t * sdp, char *buf, char **next)\n{\n  char *equal;\n  char *crlf;\n  char *tmp;\n  char *tmp_next;\n  int i;\n  sdp_media_t *m_header;\n  char *slash;\n  char *space;\n\n  *next = buf;\n\n  equal = buf;\n  while ((*equal != '=') && (*equal != '\\0'))\n    equal++;\n  if (*equal == '\\0')\n    return ERR_ERROR;\n\n  /* check if header is \"m\" */\n  if (equal[-1] != 'm')\n    return ERR_DISCARD;\n\n  crlf = equal + 1;\n\n  while ((*crlf != '\\r') && (*crlf != '\\n') && (*crlf != '\\0'))\n    crlf++;\n  if (*crlf == '\\0')\n    return ERR_ERROR;\n  if (crlf == equal + 1)\n    return ERR_ERROR;           /* a=\\r ?? bad header */\n\n  tmp = equal + 1;\n\n  i = sdp_media_init (&m_header);\n  if (i != 0)\n    return ERR_ERROR;\n\n  /* m=media port [\"/\"integer] proto *(payload_number) */\n\n  /* media is \"audio\" \"video\" \"application\" \"data\" or other... */\n  i = __osip_set_next_token (&(m_header->m_media), tmp, ' ', &tmp_next);\n  if (i != 0) {\n    sdp_media_free (m_header);\n    return -1;\n  }\n  tmp = tmp_next;\n\n  slash = strchr (tmp, '/');\n  space = strchr (tmp, ' ');\n  if (space == NULL) {          /* not possible! */\n    sdp_media_free (m_header);\n    return ERR_ERROR;\n  }\n  if ((slash != NULL) && (slash < space)) {     /* a number of port is specified! */\n    i = __osip_set_next_token (&(m_header->m_port), tmp, '/', &tmp_next);\n    if (i != 0) {\n      sdp_media_free (m_header);\n      return -1;\n    }\n    tmp = tmp_next;\n\n    i = __osip_set_next_token (&(m_header->m_number_of_port), tmp, ' ', &tmp_next);\n    if (i != 0) {\n      sdp_media_free (m_header);\n      return -1;\n    }\n    tmp = tmp_next;\n  }\n  else {\n    i = __osip_set_next_token (&(m_header->m_port), tmp, ' ', &tmp_next);\n    if (i != 0) {\n      sdp_media_free (m_header);\n      return -1;\n    }\n    tmp = tmp_next;\n  }\n\n  i = __osip_set_next_token (&(m_header->m_proto), tmp, ' ', &tmp_next);\n  if (i != 0) {\n    /* a few stack don't add SPACE after m_proto when rejecting all payloads */\n    i = __osip_set_next_token (&(m_header->m_proto), tmp, '\\r', &tmp_next);\n    if (i != 0) {\n      i = __osip_set_next_token (&(m_header->m_proto), tmp, '\\n', &tmp_next);\n      if (i != 0) {\n        sdp_media_free (m_header);\n        return -1;\n      }\n    }\n  }\n  tmp = tmp_next;\n\n  {\n    char *str;\n    int more_space_before_crlf;\n\n    space = strchr (tmp + 1, ' ');\n    if (space == NULL)\n      more_space_before_crlf = 1;\n    else if ((space != NULL) && (space > crlf))\n      more_space_before_crlf = 1;\n    else\n      more_space_before_crlf = 0;\n    while (more_space_before_crlf == 0) {\n      i = __osip_set_next_token (&str, tmp, ' ', &tmp_next);\n      if (i != 0) {\n        sdp_media_free (m_header);\n        return -1;\n      }\n      tmp = tmp_next;\n      osip_list_add (&m_header->m_payloads, str, -1);\n\n      space = strchr (tmp + 1, ' ');\n      if (space == NULL)\n        more_space_before_crlf = 1;\n      else if ((space != NULL) && (space > crlf))\n        more_space_before_crlf = 1;\n      else\n        more_space_before_crlf = 0;\n    }\n    if (tmp_next < crlf) {      /* tmp_next is still less than clrf: no space */\n      i = __osip_set_next_token (&str, tmp, '\\r', &tmp_next);\n      if (i != 0) {\n        i = __osip_set_next_token (&str, tmp, '\\n', &tmp_next);\n        if (i != 0) {\n          sdp_media_free (m_header);\n          return -1;\n        }\n      }\n      osip_list_add (&m_header->m_payloads, str, -1);\n    }\n  }\n\n  osip_list_add (&sdp->m_medias, m_header, -1);\n\n  if (crlf[1] == '\\n')\n    *next = crlf + 2;\n  else\n    *next = crlf + 1;\n  return WF;\n}",
      "lines": 142,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_parse": {
      "start_point": [
        1395,
        0
      ],
      "end_point": [
        1635,
        1
      ],
      "content": "int\nsdp_message_parse (sdp_message_t * sdp, const char *buf)\n{\n\n  /* In SDP, headers must be in the right order */\n  /* This is a simple example\n     v=0\n     o=user1 53655765 2353687637 IN IP4 128.3.4.5\n     s=Mbone Audio\n     i=Discussion of Mbone Engineering Issues\n     e=mbone@somewhere.com\n     c=IN IP4 224.2.0.1/127\n     t=0 0\n     m=audio 3456 RTP/AVP 0\n     a=rtpmap:0 PCMU/8000\n   */\n\n  char *next_buf;\n  char *ptr;\n  int i;\n\n  ptr = (char *) buf;\n  /* mandatory */\n  i = sdp_message_parse_v (sdp, ptr, &next_buf);\n  if (i == -1)                  /* header is bad */\n    return -1;\n  else if (0 == i)              /* header is not \"v\" */\n    return -1;\n  ptr = next_buf;\n\n  /* adtech phone use the wrong ordering and place \"s\" before \"o\" */\n  i = sdp_message_parse_s (sdp, ptr, &next_buf);\n  if (i == -1)                  /* header is bad */\n    return -1;\n  /* else if (0==i) header is not \"s\" */\n  /* else ADTECH PHONE DETECTED */\n\n  ptr = next_buf;\n\n\n\n  i = sdp_message_parse_o (sdp, ptr, &next_buf);\n  if (i == -1)                  /* header is bad */\n    return -1;\n  else if (0 == i)              /* header is not \"o\" */\n    return -1;\n  ptr = next_buf;\n\n  i = sdp_message_parse_s (sdp, ptr, &next_buf);\n  if (i == -1)                  /* header is bad */\n    return -1;\n  else if (0 == i) {            /* header is not \"s\" */\n    /* return -1; */\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO4, NULL, \"The \\\"s\\\" parameter is mandatory, but this packet does not contain any! - anyway, we don't mind about it.\\n\"));\n  }\n  ptr = next_buf;\n\n  i = sdp_message_parse_i (sdp, ptr, &next_buf);\n  if (i == -1)                  /* header is bad */\n    return -1;\n  ptr = next_buf;\n\n  i = sdp_message_parse_u (sdp, ptr, &next_buf);\n  if (i == -1)                  /* header is bad */\n    return -1;\n  ptr = next_buf;\n\n  i = 1;\n  while (i == 1) {\n    i = sdp_message_parse_e (sdp, ptr, &next_buf);\n    if (i == -1)                /* header is bad */\n      return -1;\n    ptr = next_buf;\n  }\n  i = 1;\n  while (i == 1) {\n    i = sdp_message_parse_p (sdp, ptr, &next_buf);\n    if (i == -1)                /* header is bad */\n      return -1;\n    ptr = next_buf;\n  }\n\n  /* rfc2327: there should be at least of email or phone number! */\n  if (osip_list_size (&sdp->e_emails) == 0 && osip_list_size (&sdp->p_phones) == 0) {\n    OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_INFO4, NULL, \"The rfc2327 says there should be at least an email or a phone header!- anyway, we don't mind about it.\\n\"));\n  }\n\n  i = sdp_message_parse_c (sdp, ptr, &next_buf);\n  if (i == -1)                  /* header is bad */\n    return -1;\n  ptr = next_buf;\n\n  i = 1;\n  while (i == 1) {\n    i = sdp_message_parse_b (sdp, ptr, &next_buf);\n    if (i == -1)                /* header is bad */\n      return -1;\n    ptr = next_buf;\n  }\n\n  /* 1 or more \"t\" header + 0 or more \"r\" header for each \"t\" header */\n  i = sdp_message_parse_t (sdp, ptr, &next_buf);\n  if (i == -1)                  /* header is bad */\n    return -1;\n  else if (i == ERR_DISCARD)\n    return -1;                  /* t is mandatory */\n  ptr = next_buf;\n\n  if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n    return OSIP_SUCCESS;\n\n  i = 1;\n  while (i == 1) {              /* is a \"r\" header */\n    i = sdp_message_parse_r (sdp, ptr, &next_buf);\n    if (i == -1)                /* header is bad */\n      return -1;\n    ptr = next_buf;\n    if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n      return OSIP_SUCCESS;\n\n  }\n\n\n  {\n    int more_t_header = 1;\n\n    i = sdp_message_parse_t (sdp, ptr, &next_buf);\n    if (i == -1)                /* header is bad */\n      return -1;\n    ptr = next_buf;\n\n    if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n      return OSIP_SUCCESS;\n\n    while (more_t_header == 1) {\n      i = 1;\n      while (i == 1) {          /* is a \"r\" header */\n        i = sdp_message_parse_r (sdp, ptr, &next_buf);\n        if (i == -1)            /* header is bad */\n          return -1;\n        ptr = next_buf;\n        if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n          return OSIP_SUCCESS;\n      }\n\n      i = sdp_message_parse_t (sdp, ptr, &next_buf);\n      if (i == -1)              /* header is bad */\n        return -1;\n      else if (i == ERR_DISCARD)\n        more_t_header = 0;\n      else\n        more_t_header = 1;      /* no more \"t\" headers */\n      ptr = next_buf;\n      if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n        return OSIP_SUCCESS;\n    }\n  }\n\n  i = sdp_message_parse_z (sdp, ptr, &next_buf);\n  if (i == -1)                  /* header is bad */\n    return -1;\n  ptr = next_buf;\n  if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n    return OSIP_SUCCESS;\n\n  i = sdp_message_parse_k (sdp, ptr, &next_buf);\n  if (i == -1)                  /* header is bad */\n    return -1;\n  ptr = next_buf;\n  if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n    return OSIP_SUCCESS;\n\n  /* 0 or more \"a\" header */\n  i = 1;\n  while (i == 1) {              /* no more \"a\" header */\n    i = sdp_message_parse_a (sdp, ptr, &next_buf);\n    if (i == -1)                /* header is bad */\n      return -1;\n    ptr = next_buf;\n    if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n      return OSIP_SUCCESS;\n  }\n  /* 0 or more media headers */\n  {\n    int more_m_header = 1;\n\n    while (more_m_header == 1) {\n      more_m_header = sdp_message_parse_m (sdp, ptr, &next_buf);\n      if (more_m_header == -1)  /* header is bad */\n        return -1;\n      ptr = next_buf;\n      if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n        return OSIP_SUCCESS;\n\n      i = sdp_message_parse_i (sdp, ptr, &next_buf);\n      if (i == -1)              /* header is bad */\n        return -1;\n      ptr = next_buf;\n      if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n        return OSIP_SUCCESS;\n\n      i = 1;\n      while (i == 1) {\n        i = sdp_message_parse_c (sdp, ptr, &next_buf);\n        if (i == -1)            /* header is bad */\n          return -1;\n        ptr = next_buf;\n        if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n          return OSIP_SUCCESS;\n      }\n\n      i = 1;\n      while (i == 1) {\n        i = sdp_message_parse_b (sdp, ptr, &next_buf);\n        if (i == -1)            /* header is bad */\n          return -1;\n        ptr = next_buf;\n        if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n          return OSIP_SUCCESS;\n      }\n      i = sdp_message_parse_k (sdp, ptr, &next_buf);\n      if (i == -1)              /* header is bad */\n        return -1;\n      ptr = next_buf;\n      if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n        return OSIP_SUCCESS;\n      /* 0 or more a headers */\n      i = 1;\n      while (i == 1) {\n        i = sdp_message_parse_a (sdp, ptr, &next_buf);\n        if (i == -1)            /* header is bad */\n          return -1;\n        ptr = next_buf;\n        if (*ptr == '\\0' || (*ptr == '\\r') || (*ptr == '\\n'))\n          return OSIP_SUCCESS;\n      }\n    }\n  }\n\n  return OSIP_SUCCESS;\n}",
      "lines": 241,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "sdp_append_connection": {
      "start_point": [
        1637,
        0
      ],
      "end_point": [
        1664,
        1
      ],
      "content": "static int\nsdp_append_connection (char **string, int *size, char *tmp, sdp_connection_t * conn, char **next_tmp)\n{\n  if (conn->c_nettype == NULL)\n    return -1;\n  if (conn->c_addrtype == NULL)\n    return -1;\n  if (conn->c_addr == NULL)\n    return -1;\n\n  tmp = __osip_sdp_append_string (string, size, tmp, \"c=\");\n  tmp = __osip_sdp_append_string (string, size, tmp, conn->c_nettype);\n  tmp = __osip_sdp_append_string (string, size, tmp, \" \");\n  tmp = __osip_sdp_append_string (string, size, tmp, conn->c_addrtype);\n  tmp = __osip_sdp_append_string (string, size, tmp, \" \");\n  tmp = __osip_sdp_append_string (string, size, tmp, conn->c_addr);\n  if (conn->c_addr_multicast_ttl != NULL) {\n    tmp = __osip_sdp_append_string (string, size, tmp, \"/\");\n    tmp = __osip_sdp_append_string (string, size, tmp, conn->c_addr_multicast_ttl);\n  }\n  if (conn->c_addr_multicast_int != NULL) {\n    tmp = __osip_sdp_append_string (string, size, tmp, \"/\");\n    tmp = __osip_sdp_append_string (string, size, tmp, conn->c_addr_multicast_int);\n  }\n  tmp = __osip_sdp_append_string (string, size, tmp, CRLF);\n  *next_tmp = tmp;\n  return OSIP_SUCCESS;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_append_bandwidth": {
      "start_point": [
        1666,
        0
      ],
      "end_point": [
        1682,
        1
      ],
      "content": "static int\nsdp_append_bandwidth (char **string, int *size, char *tmp, sdp_bandwidth_t * bandwidth, char **next_tmp)\n{\n  if (bandwidth->b_bwtype == NULL)\n    return -1;\n  if (bandwidth->b_bandwidth == NULL)\n    return -1;\n\n  tmp = __osip_sdp_append_string (string, size, tmp, \"b=\");\n  tmp = __osip_sdp_append_string (string, size, tmp, bandwidth->b_bwtype);\n  tmp = __osip_sdp_append_string (string, size, tmp, \":\");\n  tmp = __osip_sdp_append_string (string, size, tmp, bandwidth->b_bandwidth);\n  tmp = __osip_sdp_append_string (string, size, tmp, CRLF);\n\n  *next_tmp = tmp;\n  return OSIP_SUCCESS;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_append_time_descr": {
      "start_point": [
        1684,
        0
      ],
      "end_point": [
        1714,
        1
      ],
      "content": "static int\nsdp_append_time_descr (char **string, int *size, char *tmp, sdp_time_descr_t * time_descr, char **next_tmp)\n{\n  int pos;\n\n  if (time_descr->t_start_time == NULL)\n    return -1;\n  if (time_descr->t_stop_time == NULL)\n    return -1;\n\n\n  tmp = __osip_sdp_append_string (string, size, tmp, \"t=\");\n  tmp = __osip_sdp_append_string (string, size, tmp, time_descr->t_start_time);\n  tmp = __osip_sdp_append_string (string, size, tmp, \" \");\n  tmp = __osip_sdp_append_string (string, size, tmp, time_descr->t_stop_time);\n\n  tmp = __osip_sdp_append_string (string, size, tmp, CRLF);\n\n  pos = 0;\n  while (!osip_list_eol (&time_descr->r_repeats, pos)) {\n    char *str = (char *) osip_list_get (&time_descr->r_repeats, pos);\n\n    tmp = __osip_sdp_append_string (string, size, tmp, \"r=\");\n    tmp = __osip_sdp_append_string (string, size, tmp, str);\n    tmp = __osip_sdp_append_string (string, size, tmp, CRLF);\n    pos++;\n  }\n\n  *next_tmp = tmp;\n  return OSIP_SUCCESS;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_append_key": {
      "start_point": [
        1716,
        0
      ],
      "end_point": [
        1731,
        1
      ],
      "content": "static int\nsdp_append_key (char **string, int *size, char *tmp, sdp_key_t * key, char **next_tmp)\n{\n  if (key->k_keytype == NULL)\n    return -1;\n\n  tmp = __osip_sdp_append_string (string, size, tmp, \"k=\");\n  tmp = __osip_sdp_append_string (string, size, tmp, key->k_keytype);\n  if (key->k_keydata != NULL) {\n    tmp = __osip_sdp_append_string (string, size, tmp, \":\");\n    tmp = __osip_sdp_append_string (string, size, tmp, key->k_keydata);\n  }\n  tmp = __osip_sdp_append_string (string, size, tmp, CRLF);\n  *next_tmp = tmp;\n  return OSIP_SUCCESS;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_append_attribute": {
      "start_point": [
        1733,
        0
      ],
      "end_point": [
        1749,
        1
      ],
      "content": "static int\nsdp_append_attribute (char **string, int *size, char *tmp, sdp_attribute_t * attribute, char **next_tmp)\n{\n  if (attribute->a_att_field == NULL)\n    return -1;\n\n  tmp = __osip_sdp_append_string (string, size, tmp, \"a=\");\n  tmp = __osip_sdp_append_string (string, size, tmp, attribute->a_att_field);\n  if (attribute->a_att_value != NULL) {\n    tmp = __osip_sdp_append_string (string, size, tmp, \":\");\n    tmp = __osip_sdp_append_string (string, size, tmp, attribute->a_att_value);\n  }\n  tmp = __osip_sdp_append_string (string, size, tmp, CRLF);\n\n  *next_tmp = tmp;\n  return OSIP_SUCCESS;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_append_media": {
      "start_point": [
        1752,
        0
      ],
      "end_point": [
        1841,
        1
      ],
      "content": "static int\nsdp_append_media (char **string, int *size, char *tmp, sdp_media_t * media, char **next_tmp)\n{\n  int pos;\n\n  if (media->m_media == NULL)\n    return -1;\n  if (media->m_port == NULL)\n    return -1;\n  if (media->m_proto == NULL)\n    return -1;\n\n  tmp = __osip_sdp_append_string (string, size, tmp, \"m=\");\n  tmp = __osip_sdp_append_string (string, size, tmp, media->m_media);\n  tmp = __osip_sdp_append_string (string, size, tmp, \" \");\n  tmp = __osip_sdp_append_string (string, size, tmp, media->m_port);\n  if (media->m_number_of_port != NULL) {\n    tmp = __osip_sdp_append_string (string, size, tmp, \"/\");\n    tmp = __osip_sdp_append_string (string, size, tmp, media->m_number_of_port);\n  }\n  tmp = __osip_sdp_append_string (string, size, tmp, \" \");\n  tmp = __osip_sdp_append_string (string, size, tmp, media->m_proto);\n  pos = 0;\n  while (!osip_list_eol (&media->m_payloads, pos)) {\n    char *str = (char *) osip_list_get (&media->m_payloads, pos);\n\n    tmp = __osip_sdp_append_string (string, size, tmp, \" \");\n    tmp = __osip_sdp_append_string (string, size, tmp, str);\n    pos++;\n  }\n  tmp = __osip_sdp_append_string (string, size, tmp, CRLF);\n\n  if (media->i_info != NULL) {\n    tmp = __osip_sdp_append_string (string, size, tmp, \"i=\");\n    tmp = __osip_sdp_append_string (string, size, tmp, media->i_info);\n    tmp = __osip_sdp_append_string (string, size, tmp, CRLF);\n  }\n\n  pos = 0;\n  while (!osip_list_eol (&media->c_connections, pos)) {\n    sdp_connection_t *conn = (sdp_connection_t *) osip_list_get (&media->c_connections, pos);\n    char *next_tmp2;\n    int i;\n\n    i = sdp_append_connection (string, size, tmp, conn, &next_tmp2);\n    if (i != 0)\n      return -1;\n    tmp = next_tmp2;\n    pos++;\n  }\n\n  pos = 0;\n  while (!osip_list_eol (&media->b_bandwidths, pos)) {\n    sdp_bandwidth_t *band = (sdp_bandwidth_t *) osip_list_get (&media->b_bandwidths, pos);\n    char *next_tmp2;\n    int i;\n\n    i = sdp_append_bandwidth (string, size, tmp, band, &next_tmp2);\n    if (i != 0)\n      return -1;\n    tmp = next_tmp2;\n    pos++;\n  }\n\n  if (media->k_key != NULL) {\n    char *next_tmp2;\n    int i;\n\n    i = sdp_append_key (string, size, tmp, media->k_key, &next_tmp2);\n    if (i != 0)\n      return -1;\n    tmp = next_tmp2;\n  }\n\n  pos = 0;\n  while (!osip_list_eol (&media->a_attributes, pos)) {\n    sdp_attribute_t *attr = (sdp_attribute_t *) osip_list_get (&media->a_attributes, pos);\n    char *next_tmp2;\n    int i;\n\n    i = sdp_append_attribute (string, size, tmp, attr, &next_tmp2);\n    if (i != 0)\n      return -1;\n    tmp = next_tmp2;\n    pos++;\n  }\n\n  *next_tmp = tmp;\n  return OSIP_SUCCESS;\n}",
      "lines": 90,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sdp_message_to_str": {
      "start_point": [
        1843,
        0
      ],
      "end_point": [
        2009,
        1
      ],
      "content": "int\nsdp_message_to_str (sdp_message_t * sdp, char **dest)\n{\n  int size;\n  int pos;\n  char *tmp;\n  char *string;\n\n  *dest = NULL;\n  if (!sdp || sdp->v_version == NULL)\n    return -1;\n  if (sdp->o_username == NULL || sdp->o_sess_id == NULL || sdp->o_sess_version == NULL || sdp->o_nettype == NULL || sdp->o_addrtype == NULL || sdp->o_addr == NULL)\n    return -1;\n\n  /* RFC says \"s=\" is mandatory... rfc2543 (SIP) recommends to\n     accept SDP datas without s_name... as some buggy implementations\n     often forget it...\n   */\n  /* if (sdp->s_name == NULL)\n     return -1; */\n\n  size = BODY_MESSAGE_MAX_SIZE;\n  tmp = (char *) osip_malloc (size);\n  if (tmp == NULL)\n    return OSIP_NOMEM;\n  string = tmp;\n\n  tmp = __osip_sdp_append_string (&string, &size, tmp, \"v=\");\n  tmp = __osip_sdp_append_string (&string, &size, tmp, sdp->v_version);\n  tmp = __osip_sdp_append_string (&string, &size, tmp, CRLF);\n  tmp = __osip_sdp_append_string (&string, &size, tmp, \"o=\");\n  tmp = __osip_sdp_append_string (&string, &size, tmp, sdp->o_username);\n  tmp = __osip_sdp_append_string (&string, &size, tmp, \" \");\n  tmp = __osip_sdp_append_string (&string, &size, tmp, sdp->o_sess_id);\n  tmp = __osip_sdp_append_string (&string, &size, tmp, \" \");\n  tmp = __osip_sdp_append_string (&string, &size, tmp, sdp->o_sess_version);\n  tmp = __osip_sdp_append_string (&string, &size, tmp, \" \");\n  tmp = __osip_sdp_append_string (&string, &size, tmp, sdp->o_nettype);\n  tmp = __osip_sdp_append_string (&string, &size, tmp, \" \");\n  tmp = __osip_sdp_append_string (&string, &size, tmp, sdp->o_addrtype);\n  tmp = __osip_sdp_append_string (&string, &size, tmp, \" \");\n  tmp = __osip_sdp_append_string (&string, &size, tmp, sdp->o_addr);\n  tmp = __osip_sdp_append_string (&string, &size, tmp, CRLF);\n  if (sdp->s_name != NULL) {\n    tmp = __osip_sdp_append_string (&string, &size, tmp, \"s=\");\n    tmp = __osip_sdp_append_string (&string, &size, tmp, sdp->s_name);\n    tmp = __osip_sdp_append_string (&string, &size, tmp, CRLF);\n  }\n  if (sdp->i_info != NULL) {\n    tmp = __osip_sdp_append_string (&string, &size, tmp, \"i=\");\n    tmp = __osip_sdp_append_string (&string, &size, tmp, sdp->i_info);\n    tmp = __osip_sdp_append_string (&string, &size, tmp, CRLF);\n  }\n  if (sdp->u_uri != NULL) {\n    tmp = __osip_sdp_append_string (&string, &size, tmp, \"u=\");\n    tmp = __osip_sdp_append_string (&string, &size, tmp, sdp->u_uri);\n    tmp = __osip_sdp_append_string (&string, &size, tmp, CRLF);\n  }\n  pos = 0;\n  while (!osip_list_eol (&sdp->e_emails, pos)) {\n    char *email = (char *) osip_list_get (&sdp->e_emails, pos);\n\n    tmp = __osip_sdp_append_string (&string, &size, tmp, \"e=\");\n    tmp = __osip_sdp_append_string (&string, &size, tmp, email);\n    tmp = __osip_sdp_append_string (&string, &size, tmp, CRLF);\n    pos++;\n  }\n  pos = 0;\n  while (!osip_list_eol (&sdp->p_phones, pos)) {\n    char *phone = (char *) osip_list_get (&sdp->p_phones, pos);\n\n    tmp = __osip_sdp_append_string (&string, &size, tmp, \"p=\");\n    tmp = __osip_sdp_append_string (&string, &size, tmp, phone);\n    tmp = __osip_sdp_append_string (&string, &size, tmp, CRLF);\n    pos++;\n  }\n  if (sdp->c_connection != NULL) {\n    char *next_tmp;\n    int i;\n\n    i = sdp_append_connection (&string, &size, tmp, sdp->c_connection, &next_tmp);\n    if (i != 0) {\n      osip_free (string);\n      return -1;\n    }\n    tmp = next_tmp;\n  }\n  pos = 0;\n  while (!osip_list_eol (&sdp->b_bandwidths, pos)) {\n    sdp_bandwidth_t *header = (sdp_bandwidth_t *) osip_list_get (&sdp->b_bandwidths, pos);\n    char *next_tmp;\n    int i;\n\n    i = sdp_append_bandwidth (&string, &size, tmp, header, &next_tmp);\n    if (i != 0) {\n      osip_free (string);\n      return -1;\n    }\n    tmp = next_tmp;\n    pos++;\n  }\n\n  pos = 0;\n  while (!osip_list_eol (&sdp->t_descrs, pos)) {\n    sdp_time_descr_t *header = (sdp_time_descr_t *) osip_list_get (&sdp->t_descrs, pos);\n    char *next_tmp;\n    int i;\n\n    i = sdp_append_time_descr (&string, &size, tmp, header, &next_tmp);\n    if (i != 0) {\n      osip_free (string);\n      return -1;\n    }\n    tmp = next_tmp;\n    pos++;\n  }\n\n  if (sdp->z_adjustments != NULL) {\n    tmp = __osip_sdp_append_string (&string, &size, tmp, \"z=\");\n    tmp = __osip_sdp_append_string (&string, &size, tmp, sdp->z_adjustments);\n    tmp = __osip_sdp_append_string (&string, &size, tmp, CRLF);\n  }\n\n  if (sdp->k_key != NULL) {\n    char *next_tmp;\n    int i;\n\n    i = sdp_append_key (&string, &size, tmp, sdp->k_key, &next_tmp);\n    if (i != 0) {\n      osip_free (string);\n      return -1;\n    }\n    tmp = next_tmp;\n  }\n\n  pos = 0;\n  while (!osip_list_eol (&sdp->a_attributes, pos)) {\n    sdp_attribute_t *header = (sdp_attribute_t *) osip_list_get (&sdp->a_attributes, pos);\n    char *next_tmp;\n    int i;\n\n    i = sdp_append_attribute (&string, &size, tmp, header, &next_tmp);\n    if (i != 0) {\n      osip_free (string);\n      return -1;\n    }\n    tmp = next_tmp;\n    pos++;\n  }\n\n  pos = 0;\n  while (!osip_list_eol (&sdp->m_medias, pos)) {\n    sdp_media_t *header = (sdp_media_t *) osip_list_get (&sdp->m_medias, pos);\n    char *next_tmp;\n    int i;\n\n    i = sdp_append_media (&string, &size, tmp, header, &next_tmp);\n    if (i != 0) {\n      osip_free (string);\n      return -1;\n    }\n    tmp = next_tmp;\n    pos++;\n  }\n  *dest = string;\n  return OSIP_SUCCESS;\n}",
      "lines": 167,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "sdp_message_free": {
      "start_point": [
        2011,
        0
      ],
      "end_point": [
        2045,
        1
      ],
      "content": "void\nsdp_message_free (sdp_message_t * sdp)\n{\n  if (sdp == NULL)\n    return;\n  osip_free (sdp->v_version);\n  osip_free (sdp->o_username);\n  osip_free (sdp->o_sess_id);\n  osip_free (sdp->o_sess_version);\n  osip_free (sdp->o_nettype);\n  osip_free (sdp->o_addrtype);\n  osip_free (sdp->o_addr);\n  osip_free (sdp->s_name);\n  osip_free (sdp->i_info);\n  osip_free (sdp->u_uri);\n\n  osip_list_ofchar_free (&sdp->e_emails);\n\n  osip_list_ofchar_free (&sdp->p_phones);\n\n  sdp_connection_free (sdp->c_connection);\n\n  osip_list_special_free (&sdp->b_bandwidths, (void (*)(void *)) &sdp_bandwidth_free);\n\n  osip_list_special_free (&sdp->t_descrs, (void (*)(void *)) &sdp_time_descr_free);\n\n  osip_free (sdp->z_adjustments);\n  sdp_key_free (sdp->k_key);\n\n  osip_list_special_free (&sdp->a_attributes, (void (*)(void *)) &sdp_attribute_free);\n\n  osip_list_special_free (&sdp->m_medias, (void (*)(void *)) &sdp_media_free);\n\n  osip_free (sdp);\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "sdp_message_clone": {
      "start_point": [
        2047,
        0
      ],
      "end_point": [
        2071,
        1
      ],
      "content": "int\nsdp_message_clone (sdp_message_t * sdp, sdp_message_t ** dest)\n{\n  int i;\n  char *body;\n\n  i = sdp_message_init (dest);\n  if (i != 0)\n    return -1;\n\n  i = sdp_message_to_str (sdp, &body);\n  if (i != 0)\n    goto error_sc1;\n\n  i = sdp_message_parse (*dest, body);\n  osip_free (body);\n  if (i != 0)\n    goto error_sc1;\n\n  return OSIP_SUCCESS;\n\nerror_sc1:\n  sdp_message_free (*dest);\n  return -1;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/test/tcallid.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  FILE *callids_file;\n\n\n  osip_call_id_t *callid;\n  char *a_callid;\n  char *dest;\n  char *res;\n\n  callids_file = fopen (argv[1], \"r\");\n  if (callids_file == NULL) {\n    fprintf (stdout, \"Failed to open %s file.\\nUsage: tcallid callids.txt\\n\", argv[1]);\n    exit (0);\n  }\n\n  a_callid = (char *) osip_malloc (200);\n  res = fgets (a_callid, 200, callids_file);    /* lines are under 200 */\n  while (res != NULL) {\n\n    int errcode;\n\n    /* remove the last '\\n' before parsing */\n    strncpy (a_callid + strlen (a_callid) - 1, \"\\0\", 1);\n\n    if (0 != strncmp (a_callid, \"#\", 1)) {\n      /* allocate & init callid */\n      osip_call_id_init (&callid);\n      printf (\"=================================================\\n\");\n      printf (\"CALLID TO PARSE: |%s|\\n\", a_callid);\n      errcode = osip_call_id_parse (callid, a_callid);\n      if (errcode != -1) {\n        if (osip_call_id_to_str (callid, &dest) != -1) {\n          printf (\"result:        |%s|\\n\", dest);\n          osip_free (dest);\n        }\n      }\n      else\n        printf (\"Bad callid format: %s\\n\", a_callid);\n      osip_call_id_free (callid);\n      printf (\"=================================================\\n\");\n    }\n    res = fgets (a_callid, 200, callids_file);  /* lines are under 200 */\n  }\n  osip_free (a_callid);\n  return 0;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/test/tcontact.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  FILE *contacts_file;\n\n\n  osip_contact_t *contact;\n  char *a_contact;\n  char *dest;\n  char *res;\n\n  contacts_file = fopen (argv[1], \"r\");\n  if (contacts_file == NULL) {\n    fprintf (stdout, \"Failed to open %s file.\\nUsage: tcontact contacts.txt\\n\", argv[1]);\n    exit (0);\n  }\n\n  a_contact = (char *) osip_malloc (500);\n  res = fgets (a_contact, 500, contacts_file);  /* lines are under 200 */\n  while (res != NULL) {\n\n    int errcode;\n\n    /* remove the last '\\n' before parsing */\n    strncpy (a_contact + strlen (a_contact) - 1, \"\\0\", 1);\n\n    if (0 != strncmp (a_contact, \"#\", 1)) {\n      /* allocate & init contact */\n      osip_contact_init (&contact);\n      printf (\"=================================================\\n\");\n      printf (\"CONTACT TO PARSE: |%s|\\n\", a_contact);\n      errcode = osip_contact_parse (contact, a_contact);\n      if (errcode != -1) {\n        if (osip_contact_to_str (contact, &dest) != -1) {\n          printf (\"result:           |%s|\\n\", dest);\n\n\t  {\n\t    int pos = 0;\n\t    osip_generic_param_t *u_param;\n\t    while (!osip_list_eol (&contact->gen_params, pos)) {\n\t      u_param = (osip_generic_param_t *) osip_list_get (&contact->gen_params, pos);\n\t      \n\t      if (u_param->gvalue == NULL)\n\t\tprintf (\"result:       ;%s\\n\", u_param->gname);\n\t      else\n\t\tprintf (\"result:       ;%s=%s\\n\", u_param->gname, u_param->gvalue);\n\t      pos++;\n\t    }\n\t  }\n\n          osip_free (dest);\n        }\n      }\n      else\n        printf (\"Bad contact format: %s\\n\", a_contact);\n      osip_contact_free (contact);\n      printf (\"=================================================\\n\");\n    }\n    res = fgets (a_contact, 500, contacts_file);        /* lines are under 200 */\n  }\n  osip_free (a_contact);\n  return 0;\n}",
      "lines": 63,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/test/tcontentt.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  FILE *content_types_file;\n\n\n  osip_content_type_t *content_type;\n  char *a_content_type;\n  char *dest;\n  char *res;\n\n  content_types_file = fopen (argv[1], \"r\");\n  if (content_types_file == NULL) {\n    fprintf (stdout, \"Failed to open %s file.\\nUsage: tcontent_type content_types.txt\\n\", argv[1]);\n    exit (0);\n  }\n\n  a_content_type = (char *) osip_malloc (200);\n  res = fgets (a_content_type, 200, content_types_file);        /* lines are under 200 */\n  while (res != NULL) {\n\n    int errcode;\n\n    /* remove the last '\\n' before parsing */\n    strncpy (a_content_type + strlen (a_content_type) - 1, \"\\0\", 1);\n\n    if (0 != strncmp (a_content_type, \"#\", 1)) {\n      /* allocate & init content_type */\n      osip_content_type_init (&content_type);\n      printf (\"=================================================\\n\");\n      printf (\"CONTENT_TYPE TO PARSE: |%s|\\n\", a_content_type);\n      errcode = osip_content_type_parse (content_type, a_content_type);\n      if (errcode != -1) {\n        if (osip_content_type_to_str (content_type, &dest) != -1) {\n          printf (\"result:                |%s|\\n\", dest);\n          osip_free (dest);\n        }\n      }\n      else\n        printf (\"Bad content_type format: %s\\n\", a_content_type);\n      osip_content_type_free (content_type);\n      printf (\"=================================================\\n\");\n    }\n    res = fgets (a_content_type, 200, content_types_file);      /* lines are under 200 */\n  }\n  osip_free (a_content_type);\n  return 0;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/test/tfrom.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  FILE *froms_file;\n\n\n  osip_from_t *from;\n  char *a_from;\n  char *dest;\n  char *res;\n\n  froms_file = fopen (argv[1], \"r\");\n  if (froms_file == NULL) {\n    fprintf (stdout, \"Failed to open %s file.\\nUsage: tfrom froms.txt\\n\", argv[1]);\n    exit (0);\n  }\n\n  a_from = (char *) osip_malloc (200);\n  res = fgets (a_from, 200, froms_file);        /* lines are under 200 */\n  while (res != NULL) {\n\n    int errcode;\n\n    /* remove the last '\\n' before parsing */\n    strncpy (a_from + strlen (a_from) - 1, \"\\0\", 1);\n\n    if (0 != strncmp (a_from, \"#\", 1)) {\n      /* allocate & init from */\n      osip_from_init (&from);\n      printf (\"=================================================\\n\");\n      printf (\"FROM TO PARSE: |%s|\\n\", a_from);\n      errcode = osip_from_parse (from, a_from);\n      if (errcode != -1) {\n        if (osip_from_to_str (from, &dest) != -1) {\n          printf (\"result:        |%s|\\n\", dest);\n          osip_free (dest);\n        }\n      }\n      else\n        printf (\"Bad from format: %s\\n\", a_from);\n      osip_from_free (from);\n      printf (\"=================================================\\n\");\n    }\n    res = fgets (a_from, 200, froms_file);      /* lines are under 200 */\n  }\n  osip_free (a_from);\n  return 0;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/test/torture.c": {
    "usage": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static void\nusage ()\n{\n  fprintf (stderr, \"Usage: ./torture_test torture_file [-v (verbose)] [-c (clone)] [-p (performance: loop 100.000]\\n\");\n  exit (1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_binary": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static int\nread_binary (char **msg, int *len, FILE * torture_file)\n{\n  *msg = (char *) osip_malloc (100000); /* msg are under 100000 */\n\n  *len = fread (*msg, 1, 100000, torture_file);\n  return ferror (torture_file) ? -1 : 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int success = 1;\n  int loop = 1;\n  int verbose = 0;              /* 1: verbose, 0 (or nothing: not verbose) */\n  int clone = 0;                /* 1: verbose, 0 (or nothing: not verbose) */\n  FILE *torture_file;\n  char *msg;\n  char *ptr;\n  int pos;\n  int len;\n  int expected_error=OSIP_SUCCESS;\n  \n  for (pos = 2; pos < argc; pos++) {\n    if (0 == strncmp (argv[pos], \"-v\", 2))\n      verbose = 1;\n    else if (0 == strncmp (argv[pos], \"-c\", 2))\n      clone = 1;\n    else if (0 == strncmp (argv[pos], \"-p\", 2))\n      loop = 100000;\n    else\n      usage ();\n  }\n\n  if (argc < 2) {\n    usage ();\n  }\n\n  torture_file = fopen (argv[1], \"r\");\n  if (torture_file == NULL) {\n    usage ();\n  }\n\n  /* initialize parser */\n  parser_init ();\n\n  if (read_binary (&msg, &len, torture_file) < 0) {\n    fprintf (stdout, \"test %s : ============================ FAILED (cannot read file)\\n\", argv[1]);\n    return -999;\n  }\n  \n  ptr=msg;\n  if (osip_strncasecmp(msg, \"expected_error:\", strlen(\"expected_error:\"))==0) {\n    ptr+=strlen(\"expected_error:\");\n    expected_error=atoi(ptr);\n    while (*ptr!='\\r' && *ptr!='\\n')\n      ptr++;\n    while (*ptr=='\\r' || *ptr=='\\n')\n      ptr++;\n  }\n  success = test_message (ptr, len, verbose, clone, loop);\n  if (verbose) {\n    fprintf (stdout, \"test %s : ============================ \\n\", argv[1]);\n    fwrite (msg, 1, len, stdout);\n  }\n  if (success==expected_error)\n    fprintf (stdout, \"test %s : ============================ OK (error_code=%i)\\n\", argv[1], expected_error);\n  else\n    fprintf (stdout, \"test %s : ============================ FAILED (expected=%i error_code=%i)\\n\", argv[1], expected_error, success);\n\n  osip_free (msg);\n  fclose (torture_file);\n#ifdef __linux\n  if (success!=expected_error)\n    exit (EXIT_FAILURE);\n  else\n    exit (EXIT_SUCCESS);\n#endif\n  return success;\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "test_message": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "int\ntest_message (char *msg, size_t len, int verbose, int clone, int perf)\n{\n  osip_message_t *sip;\n  int err=0;\n  char *result;\n  \n  int j = perf;\n  \n  if (verbose)\n    fprintf (stdout, \"Trying %i sequentials calls to osip_message_init(), osip_message_parse() and osip_message_free()\\n\", j);\n  while (j != 0) {\n    j--;\n    osip_message_init (&sip);\n    err = osip_message_parse (sip, msg, len);\n      if (err != 0) {\n\tif (verbose)\n\t  fprintf (stdout, \"ERROR: failed while parsing!\\n\");\n        osip_message_free (sip);\n        return err;\n      }\n      osip_message_free (sip);\n  }\n  \n  osip_message_init (&sip);\n  err = osip_message_parse (sip, msg, len);\n  if (err != 0) {\n    if (verbose)\n      fprintf (stdout, \"ERROR: failed while parsing!\\n\");\n    osip_message_free (sip);\n    return err;\n  }\n  else {\n    size_t length;\n    \n#if 0\n    sdp_message_t *sdp;\n    osip_body_t *oldbody;\n    int pos;\n    \n    pos = 0;\n    while (!osip_list_eol (&sip->bodies, pos)) {\n      oldbody = (osip_body_t *) osip_list_get (&sip->bodies, pos);\n      pos++;\n      sdp_message_init (&sdp);\n      err = sdp_message_parse (sdp, oldbody->body);\n      sdp_message_free (sdp);\n      sdp = NULL;\n      if (err != 0) {\n\tif (verbose)\n\t  fprintf (stdout, \"ERROR: Bad SDP!\\n\");\n\tbreak;\n      }\n      else if (verbose)\n\tfprintf (stdout, \"SUCCESS: Correct SDP!\\n\");\n    }\n#endif\n    \n    osip_message_force_update (sip);\n    err = osip_message_to_str (sip, &result, &length);\n    if (err != OSIP_SUCCESS) {\n      if (verbose)\n\tfprintf (stdout, \"ERROR: failed while printing message!\\n\");\n      osip_message_free (sip);\n      return err;\n    }\n    else {\n      if (verbose)\n\tfwrite (result, 1, length, stdout);\n      if (clone) {\n\tint j = perf;\n\t\n\tif (verbose)\n\t  fprintf (stdout, \"Trying %i sequentials calls to osip_message_clone() and osip_message_free()\\n\", j);\n\twhile (j != 0) {\n\t  osip_message_t *copy;\n\t  \n\t  j--;\n\t  err = osip_message_clone (sip, &copy);\n\t  if (err != OSIP_SUCCESS) {\n\t    if (verbose)\n\t      fprintf (stdout, \"ERROR: failed while creating copy of message!\\n\");\n\t    break;\n\t  }\n\t  else {\n\t    char *tmp;\n\t    size_t length;\n\t    \n\t    osip_message_force_update (copy);\n\t    err = osip_message_to_str (copy, &tmp, &length);\n\t    if (err != OSIP_SUCCESS) {\n\t      if (verbose)\n\t\tfprintf (stdout, \"ERROR: failed while printing message!\\n\");\n\t    }\n\t    else {\n\t      if (0 == strcmp (result, tmp)) {\n\t\tif (verbose)\n\t\t  printf (\"The osip_message_clone method works perfectly\\n\");\n\t      }\n\t      else {\n\t\tprintf (\"ERROR: The osip_message_clone method DOES NOT works\\n\");\n\t\terr=-1;\n\t\tif (verbose) {\n\t\t  printf (\"Here is the copy: \\n\");\n\t\t  fwrite (tmp, 1, length, stdout);\n\t\t  printf (\"\\n\");\n\t\t}\n\t      }\n\t      osip_free (tmp);\n\t    }\n\t    osip_message_free (copy);\n\t  }\n\t}\n\tif (verbose)\n\t  fprintf (stdout, \"sequentials calls: done\\n\");\n      }\n      osip_free (result);\n    }\n    osip_message_free (sip);\n  }\n\n  return err;\n}",
      "lines": 123,
      "depth": 23,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/test/trecordr.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  FILE *record_routes_file;\n\n\n  osip_record_route_t *record_route;\n  char *a_record_route;\n  char *dest;\n  char *res;\n\n  record_routes_file = fopen (argv[1], \"r\");\n  if (record_routes_file == NULL) {\n    fprintf (stdout, \"Failed to open %s file.\\nUsage: trecord_route record_routes.txt\\n\", argv[1]);\n    exit (0);\n  }\n\n  a_record_route = (char *) osip_malloc (200);\n  res = fgets (a_record_route, 200, record_routes_file);        /* lines are under 200 */\n  while (res != NULL) {\n\n    int errcode;\n\n    /* remove the last '\\n' before parsing */\n    strncpy (a_record_route + strlen (a_record_route) - 1, \"\\0\", 1);\n\n    if (0 != strncmp (a_record_route, \"#\", 1)) {\n      /* allocate & init record_route */\n      osip_record_route_init (&record_route);\n      printf (\"=================================================\\n\");\n      printf (\"RECORD_ROUTE TO PARSE: |%s|\\n\", a_record_route);\n      errcode = osip_record_route_parse (record_route, a_record_route);\n      if (errcode != -1) {\n        if (osip_record_route_to_str (record_route, &dest) != -1) {\n          printf (\"result:                |%s|\\n\", dest);\n          osip_free (dest);\n        }\n      }\n      else\n        printf (\"Bad record_route format: %s\\n\", a_record_route);\n      osip_record_route_free (record_route);\n      printf (\"=================================================\\n\");\n    }\n    res = fgets (a_record_route, 200, record_routes_file);      /* lines are under 200 */\n  }\n  osip_free (a_record_route);\n  return 0;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/test/troute.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  FILE *routes_file;\n\n\n  osip_route_t *route;\n  char *a_route;\n  char *dest;\n  char *res;\n\n  routes_file = fopen (argv[1], \"r\");\n  if (routes_file == NULL) {\n    fprintf (stdout, \"Failed to open %s file.\\nUsage: troute routes.txt\\n\", argv[1]);\n    exit (0);\n  }\n\n  a_route = (char *) osip_malloc (200);\n  res = fgets (a_route, 200, routes_file);      /* lines are under 200 */\n  while (res != NULL) {\n\n    int errcode;\n\n    /* remove the last '\\n' before parsing */\n    strncpy (a_route + strlen (a_route) - 1, \"\\0\", 1);\n\n    if (0 != strncmp (a_route, \"#\", 1)) {\n      /* allocate & init route */\n      osip_route_init (&route);\n      printf (\"=================================================\\n\");\n      printf (\"ROUTE TO PARSE: |%s|\\n\", a_route);\n      errcode = osip_route_parse (route, a_route);\n      if (errcode != -1) {\n        if (osip_route_to_str (route, &dest) != -1) {\n          printf (\"result:         |%s|\\n\", dest);\n          osip_free (dest);\n        }\n      }\n      else\n        printf (\"Bad route format: %s\\n\", a_route);\n      osip_route_free (route);\n      printf (\"=================================================\\n\");\n    }\n    res = fgets (a_route, 200, routes_file);    /* lines are under 200 */\n  }\n  osip_free (a_route);\n  return 0;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/test/tto.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  FILE *tos_file;\n\n\n  osip_to_t *to;\n  char *a_to;\n  char *dest;\n  char *res;\n\n  tos_file = fopen (argv[1], \"r\");\n  if (tos_file == NULL) {\n    fprintf (stdout, \"Failed to open %s file.\\nUsage: tto tos.txt\\n\", argv[1]);\n    exit (0);\n  }\n\n  a_to = (char *) osip_malloc (200);\n  res = fgets (a_to, 200, tos_file);    /* lines are under 200 */\n  while (res != NULL) {\n\n    int errcode;\n\n    /* remove the last '\\n' before parsing */\n    strncpy (a_to + strlen (a_to) - 1, \"\\0\", 1);\n\n    if (0 != strncmp (a_to, \"#\", 1)) {\n      /* allocate & init to */\n      osip_to_init (&to);\n      printf (\"=================================================\\n\");\n      printf (\"TO TO PARSE: |%s|\\n\", a_to);\n      errcode = osip_to_parse (to, a_to);\n      if (errcode != -1) {\n        if (osip_to_to_str (to, &dest) != -1) {\n          printf (\"result:      |%s|\\n\", dest);\n          osip_free (dest);\n        }\n      }\n      else\n        printf (\"Bad to format: %s\\n\", a_to);\n      osip_to_free (to);\n      printf (\"=================================================\\n\");\n    }\n    res = fgets (a_to, 200, tos_file);  /* lines are under 200 */\n  }\n  osip_free (a_to);\n  return 0;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/test/turls.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  FILE *urls_file;\n\n\n  osip_uri_t *url;\n  char *a_url;\n  char *dest;\n  char *res;\n\n  urls_file = fopen (argv[1], \"r\");\n  if (urls_file == NULL) {\n    fprintf (stdout, \"Failed to open %s file.\\nUsage: turls urls.txt\\n\", argv[1]);\n    exit (0);\n  }\n\n  a_url = (char *) osip_malloc (200);\n  res = fgets (a_url, 200, urls_file);  /* lines are under 200 */\n  while (res != NULL) {\n    int errcode;\n\n    /* remove the last '\\n' before parsing */\n    osip_strncpy (a_url + strlen (a_url) - 1, \"\\0\", 1);\n\n    if (0 != strncmp (a_url, \"#\", 1)) {\n      /* allocate & init url */\n      osip_uri_init (&url);\n      printf (\"=================================================\\n\");\n      printf (\"URL TO PARSE: |%s|\\n\", a_url);\n      errcode = osip_uri_parse (url, a_url);\n      if (errcode != -1) {\n        if (osip_uri_to_str (url, &dest) != -1) {\n          printf (\"result:       |%s|\\n\", dest);\n          osip_uri_test_accessor_api (url);\n          osip_free (dest);\n        }\n      }\n      else\n        printf (\"Bad url format: %s\\n\", a_url);\n      osip_uri_free (url);\n      printf (\"=================================================\\n\");\n    }\n    res = fgets (a_url, 200, urls_file);        /* lines are under 200 */\n  }\n  osip_free (a_url);\n  return 0;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "osip_uri_test_accessor_api": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\nosip_uri_test_accessor_api (osip_uri_t * url)\n{\n  if (url->scheme != NULL)\n    fprintf (stdout, \"%s:\", url->scheme);\n  if (url->string != NULL) {\n    fprintf (stdout, \"|%s\", url->string);\n    fprintf (stdout, \"\\n\");\n    return 0;\n  }\n  if (url->username != NULL)\n    fprintf (stdout, \"%s|\", url->username);\n\n  if ((url->password != NULL) && (url->username != NULL))\n    fprintf (stdout, \":%s|\", url->password);\n  if (url->username != NULL)\n    fprintf (stdout, \"@|\");\n  if (url->host != NULL) {\n    if (strchr (url->host, ':') != NULL)\n      fprintf (stdout, \"[%s]|\", url->host);\n    else\n      fprintf (stdout, \"%s|\", url->host);\n  }\n  if (url->port != NULL)\n    fprintf (stdout, \":%s|\", url->port);\n\n  fprintf (stdout, \"\\nuri-params\\n\");\n\n  {\n    int pos = 0;\n    osip_uri_param_t *u_param;\n\n    while (!osip_list_eol (&url->url_params, pos)) {\n      u_param = (osip_uri_param_t *) osip_list_get (&url->url_params, pos);\n      if (u_param->gvalue != NULL)\n        fprintf (stdout, \";%s|=|%s|\", u_param->gname, u_param->gvalue);\n      else\n        fprintf (stdout, \";%s|\", u_param->gname);\n      pos++;\n    }\n  }\n\n  fprintf (stdout, \"\\nheaders\\n\");\n\n  {\n    int pos = 0;\n    osip_uri_header_t *u_header;\n\n    while (!osip_list_eol (&url->url_headers, pos)) {\n      u_header = (osip_uri_header_t *) osip_list_get (&url->url_headers, pos);\n      if (pos == 0)\n        fprintf (stdout, \"?%s|=|%s|\", u_header->gname, u_header->gvalue);\n      else\n        fprintf (stdout, \"&%s|=|%s|\", u_header->gname, u_header->gvalue);\n      pos++;\n    }\n  }\n  fprintf (stdout, \"\\n\");\n  return 0;\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/test/tvia.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  FILE *vias_file;\n\n\n  osip_via_t *via;\n  char *a_via;\n  char *dest;\n  char *res;\n\n  vias_file = fopen (argv[1], \"r\");\n  if (vias_file == NULL) {\n    fprintf (stdout, \"Failed to open %s file.\\nUsage: tvia vias.txt\\n\", argv[1]);\n    exit (0);\n  }\n\n  a_via = (char *) osip_malloc (200);\n  res = fgets (a_via, 200, vias_file);  /* lines are under 200 */\n  while (res != NULL) {\n\n    int errcode;\n\n    /* remove the last '\\n' before parsing */\n    osip_strncpy (a_via + strlen (a_via) - 1, \"\\0\", 1);\n\n    if (0 != strncmp (a_via, \"#\", 1)) {\n      /* allocate & init via */\n      osip_via_init (&via);\n      printf (\"=================================================\\n\");\n      printf (\"VIA TO PARSE: |%s|\\n\", a_via);\n      errcode = osip_via_parse (via, a_via);\n      if (errcode != -1) {\n        if (osip_via_to_str (via, &dest) != -1) {\n          printf (\"result:       |%s|\\n\", dest);\n          osip_free (dest);\n        }\n      }\n      else\n        printf (\"Bad via format: %s\\n\", a_via);\n      osip_via_free (via);\n      printf (\"=================================================\\n\");\n    }\n    res = fgets (a_via, 200, vias_file);        /* lines are under 200 */\n  }\n  osip_free (a_via);\n\n  return 0;\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "osip/libosip2-5.0.0/src/test/twwwa.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  FILE *wwwauthenticates_file;\n\n\n  osip_www_authenticate_t *wwwauthenticate;\n  char *a_wwwauthenticate;\n  char *dest;\n  char *res;\n\n  wwwauthenticates_file = fopen (argv[1], \"r\");\n  if (wwwauthenticates_file == NULL) {\n    fprintf (stdout, \"Failed to open %s file.\\nUsage: twwwauthenticate wwwauthenticates.txt\\n\", argv[1]);\n    exit (0);\n  }\n\n  a_wwwauthenticate = (char *) osip_malloc (200);\n  res = fgets (a_wwwauthenticate, 200, wwwauthenticates_file);  /* lines are under 200 */\n  while (res != NULL) {\n\n    int errcode;\n\n    /* remove the last '\\n' before parsing */\n    strncpy (a_wwwauthenticate + strlen (a_wwwauthenticate) - 1, \"\\0\", 1);\n\n    if (0 != strncmp (a_wwwauthenticate, \"#\", 1)) {\n      /* allocate & init wwwauthenticate */\n      osip_www_authenticate_init (&wwwauthenticate);\n      printf (\"=================================================\\n\");\n      printf (\"WWWAUTHENTICATE TO PARSE: |%s|\\n\", a_wwwauthenticate);\n      errcode = osip_www_authenticate_parse (wwwauthenticate, a_wwwauthenticate);\n      if (errcode != -1) {\n        if (osip_www_authenticate_to_str (wwwauthenticate, &dest) != -1) {\n          printf (\"result:                   |%s|\\n\", dest);\n          osip_free (dest);\n        }\n      }\n      else\n        printf (\"Bad wwwauthenticate format: %s\\n\", a_wwwauthenticate);\n      osip_www_authenticate_free (wwwauthenticate);\n      printf (\"=================================================\\n\");\n    }\n    res = fgets (a_wwwauthenticate, 200, wwwauthenticates_file);        /* lines are under 200 */\n  }\n  osip_free (a_wwwauthenticate);\n  return 0;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  }
}