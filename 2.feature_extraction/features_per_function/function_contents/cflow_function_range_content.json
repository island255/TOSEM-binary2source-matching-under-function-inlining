{
  "cflow/cflow-1.5/build-aux/snippet/arg-nonnull.h": {},
  "cflow/cflow-1.5/build-aux/snippet/c++defs.h": {},
  "cflow/cflow-1.5/build-aux/snippet/warn-on-use.h": {},
  "cflow/cflow-1.5/build-aux/snippet/_Noreturn.h": {},
  "cflow/cflow-1.5/doc/ack.c": {
    "ack": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        12,
        1
      ],
      "content": "u_long\nack (u_long a, u_long b) \n{\n  if (a == 0)\n    return b + 1;\n  if (b == 0)\n    return ack (a - 1, 1);\n  return ack (a - 1, ack (a, b - 1));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "u_long"
      ]
    }
  },
  "cflow/cflow-1.5/doc/d.c": {
    "isdir": {
      "start_point": [
        10,
        0
      ],
      "end_point": [
        21,
        1
      ],
      "content": "static int\nisdir (char *name)\n{\n  struct stat st;\n  \n  if (stat (name, &st))\n    {\n      perror (name);\n      return 0;\n    }\n  return S_ISDIR (st.st_mode);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ignorent": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nignorent (char *name)\n{\n  char **p;\n  for (p = ignored_names; *p; p++)\n    if (strcmp (name, *p) == 0)\n      return 1;\n  return 0;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "printdir": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\nprintdir (int level, char *name)\n{\n  DIR *dir;\n  struct dirent *ent;\n  char cwd[512];\n\n  if (!getcwd(cwd, sizeof cwd)) \n    {\n      perror (\"cannot save cwd\\n\");\n      _exit (1);\n    }\n  chdir (name);\n  dir = opendir (\".\");\n  if (!dir)\n    {\n      perror (name);\n      _exit (1);\n    }\n  \n  while ((ent = readdir (dir)))\n    {\n      printf (\"%*.*s%s\", level, level, \"\", ent->d_name);\n      if (ignorent (ent->d_name))\n        printf (\"\\n\");\n      else if (isdir (ent->d_name))\n        {\n          printf (\"/\");\n          if (level + 1 == max_level)\n            putchar ('\\n');\n          else\n            {\n              printf (\" contains:\\n\");\n              printdir (level + 1, ent->d_name);\n            }\n        }\n      else\n        printf (\"\\n\");\n    }\n  closedir (dir);\n  chdir (cwd);\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  if (argc < 2)\n    {\n      fprintf (stderr, \"usage: d [-MAX] DIR [DIR...]\\n\");\n      return 1;\n    }\n\n  if (argv[1][0] == '-')\n    {\n      if (!(argv[1][1] == '-' && argv[1][2] == 0))\n        max_level = atoi (&argv[1][1]);\n      --argc;\n      ++argv;\n    }\n  \n  while (--argc)\n    printdir (0, *++argv);\n  \n  return 1;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/doc/foo.c": {
    "main": {
      "start_point": [
        1,
        0
      ],
      "end_point": [
        7,
        1
      ],
      "content": "int\nmain()\n{\n    f();\n    g();\n    f();\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "f": {
      "start_point": [
        9,
        0
      ],
      "end_point": [
        13,
        1
      ],
      "content": "int\nf()\n{\n    i = h();\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/doc/wc.c": {
    "error_print": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void\nerror_print (int perr, char *fmt, va_list ap)\n{\n  vfprintf (stderr, fmt, ap);\n  if (perr)\n    perror (\" \");\n  else\n    fprintf (stderr, \"\\n\");\n  exit (1);  \n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "errf": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void\nerrf (char *fmt, ...)\n{\n  va_list ap;\n  \n  va_start (ap, fmt);\n  error_print (0, fmt, ap);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "perrf": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static void\nperrf (char *fmt, ...)\n{\n  va_list ap;\n  \n  va_start (ap, fmt);\n  error_print (1, fmt, ap);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "report": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nreport (char *file, count_t ccount, count_t wcount, count_t lcount)\n{\n  printf (\"%6lu %6lu %6lu %s\\n\", lcount, wcount, ccount, file);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "isword": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nisword (unsigned char c)\n{\n  return isalpha (c);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getword": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\ngetword (FILE *fp)\n{\n  int c;\n  int word = 0;\n  \n  if (feof (fp))\n    return 0;\n      \n  while ((c = getc (fp)) != EOF)\n    {\n      if (isword (c))\n        {\n          wcount++;\n          break;\n        }\n      COUNT (c);\n    }\n\n  for (; c != EOF; c = getc (fp))\n    {\n      COUNT (c);\n      if (!isword (c))\n        break;\n    }\n\n  return c != EOF;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "counter": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\ncounter (char *file)\n{\n  FILE *fp = fopen (file, \"r\");\n  \n  if (!fp)\n    perrf (\"cannot open file `%s'\", file);\n\n  ccount = wcount = lcount = 0;\n  while (getword (fp))\n    ;\n  fclose (fp);\n\n  report (file, ccount, wcount, lcount);\n  total_ccount += ccount;\n  total_wcount += wcount;\n  total_lcount += lcount;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n  \n  if (argc < 2)\n    errf (\"usage: wc FILE [FILE...]\");\n  \n  for (i = 1; i < argc; i++)\n    counter (argv[i]);\n  \n  if (argc > 2)\n    report (\"total\", total_ccount, total_wcount, total_lcount);\n  return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/doc/whoami.c": {
    "who_am_i": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        22,
        1
      ],
      "content": "int\nwho_am_i (void)\n{\n  struct passwd *pw;\n  char *user = NULL;\n\n  pw = getpwuid (geteuid ());\n  if (pw)\n    user = pw->pw_name;\n  else if ((user = getenv (\"USER\")) == NULL)\n    {\n      fprintf (stderr, \"I don't know!\\n\");\n      return 1;\n    }\n  printf (\"%s\\n\", user);\n  return 0;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  if (argc > 1)\n    {\n      fprintf (stderr, \"usage: whoami\\n\");\n      return 1;\n    }\n  return who_am_i ();\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int\nfind_stack_direction (int *addr, int depth)\n{\n  int dir, dummy = 0;\n  if (! addr)\n    addr = &dummy;\n  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;\n  dir = depth ? find_stack_direction (addr, depth - 1) : 0;\n  return dir + dummy;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloca": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "void *\nalloca (size_t size)\n{\n  auto char probe;              /* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)           /* Unknown growth direction.  */\n    STACK_DIR = find_stack_direction (NULL, (size & 1) + 20);\n#  endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently.  */\n\n  {\n    register header *hp;        /* Traverses linked list.  */\n\n#  ifdef emacs\n    BLOCK_INPUT;\n#  endif\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n          || (STACK_DIR < 0 && hp->h.deep < depth))\n        {\n          register header *np = hp->h.next;\n\n          free (hp);            /* Collect garbage.  */\n\n          hp = np;              /* -> next header.  */\n        }\n      else\n        break;                  /* Rest are not deeper.  */\n\n    last_alloca_header = hp;    /* -> last valid storage.  */\n\n#  ifdef emacs\n    UNBLOCK_INPUT;\n#  endif\n  }\n\n  if (size == 0)\n    return NULL;                /* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    /* Address of header.  */\n    register header *new;\n\n    size_t combined_size = sizeof (header) + size;\n    if (combined_size < sizeof (header))\n      memory_full ();\n\n    new = malloc (combined_size);\n\n    if (! new)\n      memory_full ();\n\n    new->h.next = last_alloca_header;\n    new->h.deep = depth;\n\n    last_alloca_header = new;\n\n    /* User storage begins just after header.  */\n\n    return (void *) (new + 1);\n  }\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "void",
        "*\nalloca (size_t size)",
        "*"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          330,
          0
        ],
        "end_point": [
          395,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n                                    + status.current_size\n                                    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n        abort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n        break;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n        abort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          404,
          0
        ],
        "end_point": [
          473,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#    endif\n      if (pseg == 0)\n        break;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#    endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "cflow/cflow-1.5/gnu/alloca.in.h": {},
  "cflow/cflow-1.5/gnu/argp-ba.c": {},
  "cflow/cflow-1.5/gnu/argp-eexst.c": {},
  "cflow/cflow-1.5/gnu/argp-fmtstream.c": {
    "__argp_make_fmtstream": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "argp_fmtstream_t\n__argp_make_fmtstream (FILE *stream,\n                       size_t lmargin, size_t rmargin, ssize_t wmargin)\n{\n  argp_fmtstream_t fs;\n\n  fs = (struct argp_fmtstream *) malloc (sizeof (struct argp_fmtstream));\n  if (fs != NULL)\n    {\n      fs->stream = stream;\n\n      fs->lmargin = lmargin;\n      fs->rmargin = rmargin;\n      fs->wmargin = wmargin;\n      fs->point_col = 0;\n      fs->point_offs = 0;\n\n      fs->buf = (char *) malloc (INIT_BUF_SIZE);\n      if (! fs->buf)\n        {\n          free (fs);\n          fs = 0;\n        }\n      else\n        {\n          fs->p = fs->buf;\n          fs->end = fs->buf + INIT_BUF_SIZE;\n        }\n    }\n\n  return fs;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "argp_fmtstream_t"
      ]
    },
    "__argp_fmtstream_free": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\n__argp_fmtstream_free (argp_fmtstream_t fs)\n{\n  __argp_fmtstream_update (fs);\n  if (fs->p > fs->buf)\n    {\n#ifdef USE_IN_LIBIO\n      __fxprintf (fs->stream, \"%.*s\", (int) (fs->p - fs->buf), fs->buf);\n#else\n      fwrite_unlocked (fs->buf, 1, fs->p - fs->buf, fs->stream);\n#endif\n    }\n  free (fs->buf);\n  free (fs);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "__argp_fmtstream_update": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "void\n__argp_fmtstream_update (argp_fmtstream_t fs)\n{\n  char *buf, *nl;\n  size_t len;\n\n  /* Scan the buffer for newlines.  */\n  buf = fs->buf + fs->point_offs;\n  while (buf < fs->p)\n    {\n      size_t r;\n\n      if (fs->point_col == 0 && fs->lmargin != 0)\n        {\n          /* We are starting a new line.  Print spaces to the left margin.  */\n          const size_t pad = fs->lmargin;\n          if (fs->p + pad < fs->end)\n            {\n              /* We can fit in them in the buffer by moving the\n                 buffer text up and filling in the beginning.  */\n              memmove (buf + pad, buf, fs->p - buf);\n              fs->p += pad; /* Compensate for bigger buffer. */\n              memset (buf, ' ', pad); /* Fill in the spaces.  */\n              buf += pad; /* Don't bother searching them.  */\n            }\n          else\n            {\n              /* No buffer space for spaces.  Must flush.  */\n              size_t i;\n              for (i = 0; i < pad; i++)\n                {\n#ifdef USE_IN_LIBIO\n                  if (_IO_fwide (fs->stream, 0) > 0)\n                    putwc_unlocked (L' ', fs->stream);\n                  else\n#endif\n                    putc_unlocked (' ', fs->stream);\n                }\n            }\n          fs->point_col = pad;\n        }\n\n      len = fs->p - buf;\n      nl = memchr (buf, '\\n', len);\n\n      if (fs->point_col < 0)\n        fs->point_col = 0;\n\n      if (!nl)\n        {\n          /* The buffer ends in a partial line.  */\n\n          if (fs->point_col + len < fs->rmargin)\n            {\n              /* The remaining buffer text is a partial line and fits\n                 within the maximum line width.  Advance point for the\n                 characters to be written and stop scanning.  */\n              fs->point_col += len;\n              break;\n            }\n          else\n            /* Set the end-of-line pointer for the code below to\n               the end of the buffer.  */\n            nl = fs->p;\n        }\n      else if (fs->point_col + (nl - buf) < (ssize_t) fs->rmargin)\n        {\n          /* The buffer contains a full line that fits within the maximum\n             line width.  Reset point and scan the next line.  */\n          fs->point_col = 0;\n          buf = nl + 1;\n          continue;\n        }\n\n      /* This line is too long.  */\n      r = fs->rmargin - 1;\n\n      if (fs->wmargin < 0)\n        {\n          /* Truncate the line by overwriting the excess with the\n             newline and anything after it in the buffer.  */\n          if (nl < fs->p)\n            {\n              memmove (buf + (r - fs->point_col), nl, fs->p - nl);\n              fs->p -= buf + (r - fs->point_col) - nl;\n              /* Reset point for the next line and start scanning it.  */\n              fs->point_col = 0;\n              buf += r + 1; /* Skip full line plus \\n. */\n            }\n          else\n            {\n              /* The buffer ends with a partial line that is beyond the\n                 maximum line width.  Advance point for the characters\n                 written, and discard those past the max from the buffer.  */\n              fs->point_col += len;\n              fs->p -= fs->point_col - r;\n              break;\n            }\n        }\n      else\n        {\n          /* Do word wrap.  Go to the column just past the maximum line\n             width and scan back for the beginning of the word there.\n             Then insert a line break.  */\n\n          char *p, *nextline;\n          int i;\n\n          p = buf + (r + 1 - fs->point_col);\n          while (p >= buf && !isblank ((unsigned char) *p))\n            --p;\n          nextline = p + 1;     /* This will begin the next line.  */\n\n          if (nextline > buf)\n            {\n              /* Swallow separating blanks.  */\n              if (p >= buf)\n                do\n                  --p;\n                while (p >= buf && isblank ((unsigned char) *p));\n              nl = p + 1;       /* The newline will replace the first blank. */\n            }\n          else\n            {\n              /* A single word that is greater than the maximum line width.\n                 Oh well.  Put it on an overlong line by itself.  */\n              p = buf + (r + 1 - fs->point_col);\n              /* Find the end of the long word.  */\n              if (p < nl)\n                do\n                  ++p;\n                while (p < nl && !isblank ((unsigned char) *p));\n              if (p == nl)\n                {\n                  /* It already ends a line.  No fussing required.  */\n                  fs->point_col = 0;\n                  buf = nl + 1;\n                  continue;\n                }\n              /* We will move the newline to replace the first blank.  */\n              nl = p;\n              /* Swallow separating blanks.  */\n              do\n                ++p;\n              while (isblank ((unsigned char) *p));\n              /* The next line will start here.  */\n              nextline = p;\n            }\n\n          /* Note: There are a bunch of tests below for\n             NEXTLINE == BUF + LEN + 1; this case is where NL happens to fall\n             at the end of the buffer, and NEXTLINE is in fact empty (and so\n             we need not be careful to maintain its contents).  */\n\n          if ((nextline == buf + len + 1\n               ? fs->end - nl < fs->wmargin + 1\n               : nextline - (nl + 1) < fs->wmargin)\n              && fs->p > nextline)\n            {\n              /* The margin needs more blanks than we removed.  */\n              if (fs->end - fs->p > fs->wmargin + 1)\n                /* Make some space for them.  */\n                {\n                  size_t mv = fs->p - nextline;\n                  memmove (nl + 1 + fs->wmargin, nextline, mv);\n                  nextline = nl + 1 + fs->wmargin;\n                  len = nextline + mv - buf;\n                  *nl++ = '\\n';\n                }\n              else\n                /* Output the first line so we can use the space.  */\n                {\n#ifdef _LIBC\n                  __fxprintf (fs->stream, \"%.*s\\n\",\n                              (int) (nl - fs->buf), fs->buf);\n#else\n                  if (nl > fs->buf)\n                    fwrite_unlocked (fs->buf, 1, nl - fs->buf, fs->stream);\n                  putc_unlocked ('\\n', fs->stream);\n#endif\n\n                  len += buf - fs->buf;\n                  nl = buf = fs->buf;\n                }\n            }\n          else\n            /* We can fit the newline and blanks in before\n               the next word.  */\n            *nl++ = '\\n';\n\n          if (nextline - nl >= fs->wmargin\n              || (nextline == buf + len + 1 && fs->end - nextline >= fs->wmargin))\n            /* Add blanks up to the wrap margin column.  */\n            for (i = 0; i < fs->wmargin; ++i)\n              *nl++ = ' ';\n          else\n            for (i = 0; i < fs->wmargin; ++i)\n#ifdef USE_IN_LIBIO\n              if (_IO_fwide (fs->stream, 0) > 0)\n                putwc_unlocked (L' ', fs->stream);\n              else\n#endif\n                putc_unlocked (' ', fs->stream);\n\n          /* Copy the tail of the original buffer into the current buffer\n             position.  */\n          if (nl < nextline)\n            memmove (nl, nextline, buf + len - nextline);\n          len -= nextline - buf;\n\n          /* Continue the scan on the remaining lines in the buffer.  */\n          buf = nl;\n\n          /* Restore bufp to include all the remaining text.  */\n          fs->p = nl + len;\n\n          /* Reset the counter of what has been output this line.  If wmargin\n             is 0, we want to avoid the lmargin getting added, so we set\n             point_col to a magic value of -1 in that case.  */\n          fs->point_col = fs->wmargin ? fs->wmargin : -1;\n        }\n    }\n\n  /* Remember that we've scanned as far as the end of the buffer.  */\n  fs->point_offs = fs->p - fs->buf;\n}",
      "lines": 226,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "__argp_fmtstream_ensure": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "int\n__argp_fmtstream_ensure (struct argp_fmtstream *fs, size_t amount)\n{\n  if ((size_t) (fs->end - fs->p) < amount)\n    {\n      ssize_t wrote;\n\n      /* Flush FS's buffer.  */\n      __argp_fmtstream_update (fs);\n\n#ifdef _LIBC\n      __fxprintf (fs->stream, \"%.*s\", (int) (fs->p - fs->buf), fs->buf);\n      wrote = fs->p - fs->buf;\n#else\n      wrote = fwrite_unlocked (fs->buf, 1, fs->p - fs->buf, fs->stream);\n#endif\n      if (wrote == fs->p - fs->buf)\n        {\n          fs->p = fs->buf;\n          fs->point_offs = 0;\n        }\n      else\n        {\n          fs->p -= wrote;\n          fs->point_offs -= wrote;\n          memmove (fs->buf, fs->buf + wrote, fs->p - fs->buf);\n          return 0;\n        }\n\n      if ((size_t) (fs->end - fs->buf) < amount)\n        /* Gotta grow the buffer.  */\n        {\n          size_t old_size = fs->end - fs->buf;\n          size_t new_size = old_size + amount;\n          char *new_buf;\n\n          if (new_size < old_size || ! (new_buf = realloc (fs->buf, new_size)))\n            {\n              __set_errno (ENOMEM);\n              return 0;\n            }\n\n          fs->buf = new_buf;\n          fs->end = new_buf + new_size;\n          fs->p = fs->buf;\n        }\n    }\n\n  return 1;\n}",
      "lines": 50,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "__argp_fmtstream_printf": {
      "start_point": [
        402,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "ssize_t\n__argp_fmtstream_printf (struct argp_fmtstream *fs, const char *fmt, ...)\n{\n  int out;\n  size_t avail;\n  size_t size_guess = PRINTF_SIZE_GUESS; /* How much space to reserve. */\n\n  do\n    {\n      va_list args;\n\n      if (! __argp_fmtstream_ensure (fs, size_guess))\n        return -1;\n\n      va_start (args, fmt);\n      avail = fs->end - fs->p;\n      out = __vsnprintf (fs->p, avail, fmt, args);\n      va_end (args);\n      if ((size_t) out >= avail)\n        size_guess = out + 1;\n    }\n  while ((size_t) out >= avail);\n\n  fs->p += out;\n\n  return out;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/argp-fmtstream.h": {
    "__argp_fmtstream_write": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_write (argp_fmtstream_t __fs,\n                        const char *__str, size_t __len)\n{\n  if (__fs->p + __len <= __fs->end || __argp_fmtstream_ensure (__fs, __len))\n    {\n      memcpy (__fs->p, __str, __len);\n      __fs->p += __len;\n      return __len;\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_puts": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "ARGP_FS_EI int\n__argp_fmtstream_puts (argp_fmtstream_t __fs, const char *__str)\n{\n  size_t __len = strlen (__str);\n  if (__len)\n    {\n      size_t __wrote = __argp_fmtstream_write (__fs, __str, __len);\n      return __wrote == __len ? 0 : -1;\n    }\n  else\n    return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "int",
        "int"
      ]
    },
    "__argp_fmtstream_putc": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "ARGP_FS_EI int\n__argp_fmtstream_putc (argp_fmtstream_t __fs, int __ch)\n{\n  if (__fs->p < __fs->end || __argp_fmtstream_ensure (__fs, 1))\n    return *__fs->p++ = __ch;\n  else\n    return EOF;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "int",
        "int"
      ]
    },
    "__argp_fmtstream_set_lmargin": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_lmargin (argp_fmtstream_t __fs, size_t __lmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->lmargin;\n  __fs->lmargin = __lmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_set_rmargin": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_rmargin (argp_fmtstream_t __fs, size_t __rmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->rmargin;\n  __fs->rmargin = __rmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_set_wmargin": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_wmargin (argp_fmtstream_t __fs, size_t __wmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->wmargin;\n  __fs->wmargin = __wmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_point": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_point (argp_fmtstream_t __fs)\n{\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  return __fs->point_col >= 0 ? __fs->point_col : 0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/argp-fs-xinl.c": {},
  "cflow/cflow-1.5/gnu/argp-help.c": {
    "validate_uparams": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static void\nvalidate_uparams (const struct argp_state *state, struct uparams *upptr)\n{\n  const struct uparam_name *up;\n\n  for (up = uparam_names; up->name; up++)\n    {\n      if (up->is_bool\n          || up->uparams_offs == offsetof (struct uparams, rmargin))\n        continue;\n      if (*(int *)((char *)upptr + up->uparams_offs) >= upptr->rmargin)\n        {\n          __argp_failure (state, 0, 0,\n                          dgettext (state->root_argp->argp_domain,\n                                    \"\\\nARGP_HELP_FMT: %s value is less than or equal to %s\"),\n                          \"rmargin\", up->name);\n          return;\n        }\n    }\n  uparams = *upptr;\n  uparams.valid = 1;\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fill_in_uparams": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static void\nfill_in_uparams (const struct argp_state *state)\n{\n  const char *var = getenv (\"ARGP_HELP_FMT\");\n  struct uparams new_params = uparams;\n\n#define SKIPWS(p) do { while (isspace ((unsigned char) *p)) p++; } while (0);\n\n  if (var)\n    {\n      /* Parse var. */\n      while (*var)\n        {\n          SKIPWS (var);\n\n          if (isalpha ((unsigned char) *var))\n            {\n              size_t var_len;\n              const struct uparam_name *un;\n              int unspec = 0, val = 0;\n              const char *arg = var;\n\n              while (isalnum ((unsigned char) *arg) || *arg == '-' || *arg == '_')\n                arg++;\n              var_len = arg - var;\n\n              SKIPWS (arg);\n\n              if (*arg == '\\0' || *arg == ',')\n                unspec = 1;\n              else if (*arg == '=')\n                {\n                  arg++;\n                  SKIPWS (arg);\n                }\n\n              if (unspec)\n                {\n                  if (var[0] == 'n' && var[1] == 'o' && var[2] == '-')\n                    {\n                      val = 0;\n                      var += 3;\n                      var_len -= 3;\n                    }\n                  else\n                    val = 1;\n                }\n              else if (isdigit ((unsigned char) *arg))\n                {\n                  val = atoi (arg);\n                  while (isdigit ((unsigned char) *arg))\n                    arg++;\n                  SKIPWS (arg);\n                }\n\n              for (un = uparam_names; un->name; un++)\n                if (strlen (un->name) == var_len\n                    && strncmp (var, un->name, var_len) == 0)\n                  {\n                    if (unspec && !un->is_bool)\n                      __argp_failure (state, 0, 0,\n                                      dgettext (state->root_argp->argp_domain,\n                                                \"\\\n%.*s: ARGP_HELP_FMT parameter requires a value\"),\n                                      (int) var_len, var);\n                    else if (val < 0)\n                      __argp_failure (state, 0, 0,\n                                      dgettext (state->root_argp->argp_domain,\n                                                \"\\\n%.*s: ARGP_HELP_FMT parameter must be positive\"),\n                                      (int) var_len, var);\n                    else\n                      *(int *)((char *)&new_params + un->uparams_offs) = val;\n                    break;\n                  }\n              if (! un->name)\n                __argp_failure (state, 0, 0,\n                                dgettext (state->root_argp->argp_domain, \"\\\n%.*s: Unknown ARGP_HELP_FMT parameter\"),\n                                (int) var_len, var);\n\n              var = arg;\n              if (*var == ',')\n                var++;\n            }\n          else if (*var)\n            {\n              __argp_failure (state, 0, 0,\n                              dgettext (state->root_argp->argp_domain,\n                                        \"Garbage in ARGP_HELP_FMT: %s\"), var);\n              break;\n            }\n        }\n      validate_uparams (state, &new_params);\n    }\n}",
      "lines": 96,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_char": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        350,
        1
      ],
      "content": "static int\nfind_char (char ch, char *beg, char *end)\n{\n  while (beg < end)\n    if (*beg == ch)\n      return 1;\n    else\n      beg++;\n  return 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "make_hol": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "static struct hol *\nmake_hol (const struct argp *argp, struct hol_cluster *cluster)\n{\n  char *so;\n  const struct argp_option *o;\n  const struct argp_option *opts = argp->options;\n  struct hol_entry *entry;\n  unsigned num_short_options = 0;\n  struct hol *hol = malloc (sizeof (struct hol));\n\n  assert (hol);\n\n  hol->num_entries = 0;\n  hol->clusters = 0;\n\n  if (opts)\n    {\n      int cur_group = 0;\n\n      /* The first option must not be an alias.  */\n      assert (! oalias (opts));\n\n      /* Calculate the space needed.  */\n      for (o = opts; ! oend (o); o++)\n        {\n          if (! oalias (o))\n            hol->num_entries++;\n          if (oshort (o))\n            num_short_options++;        /* This is an upper bound.  */\n        }\n\n      hol->entries = malloc (sizeof (struct hol_entry) * hol->num_entries);\n      hol->short_options = malloc (num_short_options + 1);\n\n      assert (hol->entries && hol->short_options);\n      if (SIZE_MAX <= UINT_MAX)\n        assert (hol->num_entries <= SIZE_MAX / sizeof (struct hol_entry));\n\n      /* Fill in the entries.  */\n      so = hol->short_options;\n      for (o = opts, entry = hol->entries; ! oend (o); entry++)\n        {\n          entry->opt = o;\n          entry->num = 0;\n          entry->short_options = so;\n          entry->group = cur_group =\n            o->group\n            ? o->group\n            : ((!o->name && !o->key)\n               ? cur_group + 1\n               : cur_group);\n          entry->cluster = cluster;\n          entry->argp = argp;\n\n          do\n            {\n              entry->num++;\n              if (oshort (o) && ! find_char (o->key, hol->short_options, so))\n                /* O has a valid short option which hasn't already been used.*/\n                *so++ = o->key;\n              o++;\n            }\n          while (! oend (o) && oalias (o));\n        }\n      *so = '\\0';               /* null terminated so we can find the length */\n    }\n\n  return hol;\n}",
      "lines": 69,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "struct hol",
        "struct",
        "hol",
        "*\nmake_hol (const struct argp *argp, struct hol_cluster *cluster)",
        "*"
      ]
    },
    "hol_add_cluster": {
      "start_point": [
        506,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "static struct hol_cluster *\nhol_add_cluster (struct hol *hol, int group, const char *header, int index,\n                 struct hol_cluster *parent, const struct argp *argp)\n{\n  struct hol_cluster *cl = malloc (sizeof (struct hol_cluster));\n  if (cl)\n    {\n      cl->group = group;\n      cl->header = header;\n\n      cl->index = index;\n      cl->parent = parent;\n      cl->argp = argp;\n      cl->depth = parent ? parent->depth + 1 : 0;\n\n      cl->next = hol->clusters;\n      hol->clusters = cl;\n    }\n  return cl;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct hol_cluster",
        "struct",
        "hol_cluster",
        "*\nhol_add_cluster (struct hol *hol, int group, const char *header, int index,\n                 struct hol_cluster *parent, const struct argp *argp)",
        "*"
      ]
    },
    "hol_free": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "static void\nhol_free (struct hol *hol)\n{\n  struct hol_cluster *cl = hol->clusters;\n\n  while (cl)\n    {\n      struct hol_cluster *next = cl->next;\n      free (cl);\n      cl = next;\n    }\n\n  if (hol->num_entries > 0)\n    {\n      free (hol->entries);\n      free (hol->short_options);\n    }\n\n  free (hol);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_entry_short_iterate": {
      "start_point": [
        549,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "static int\nhol_entry_short_iterate (const struct hol_entry *entry,\n                         int (*func)(const struct argp_option *opt,\n                                     const struct argp_option *real,\n                                     const char *domain, void *cookie),\n                         const char *domain, void *cookie)\n{\n  unsigned nopts;\n  int val = 0;\n  const struct argp_option *opt, *real = entry->opt;\n  char *so = entry->short_options;\n\n  for (opt = real, nopts = entry->num; nopts > 0 && !val; opt++, nopts--)\n    if (oshort (opt) && *so == opt->key)\n      {\n        if (!oalias (opt))\n          real = opt;\n        if (ovisible (opt))\n          val = (*func)(opt, real, domain, cookie);\n        so++;\n      }\n\n  return val;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "always_inline": {
      "start_point": [
        582,
        30
      ],
      "end_point": [
        598,
        1
      ],
      "content": "char *domain, void *cookie)\n{\n  unsigned nopts;\n  int val = 0;\n  const struct argp_option *opt, *real = entry->opt;\n\n  for (opt = real, nopts = entry->num; nopts > 0 && !val; opt++, nopts--)\n    if (opt->name)\n      {\n        if (!oalias (opt))\n          real = opt;\n        if (ovisible (opt))\n          val = (*func)(opt, real, domain, cookie);\n      }\n\n  return val;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": null
    },
    "until_short": {
      "start_point": [
        601,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "static int\nuntil_short (const struct argp_option *opt, const struct argp_option *real,\n             const char *domain, void *cookie)\n{\n  return oshort (opt) ? opt->key : 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_first_short": {
      "start_point": [
        609,
        0
      ],
      "end_point": [
        614,
        1
      ],
      "content": "static char\nhol_entry_first_short (const struct hol_entry *entry)\n{\n  return hol_entry_short_iterate (entry, until_short,\n                                  entry->argp->argp_domain, 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "hol_entry_first_long": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "static const char *\nhol_entry_first_long (const struct hol_entry *entry)\n{\n  const struct argp_option *opt;\n  unsigned num;\n  for (opt = entry->opt, num = entry->num; num > 0; opt++, num--)\n    if (opt->name && ovisible (opt))\n      return opt->name;\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nhol_entry_first_long (const struct hol_entry *entry)",
        "*"
      ]
    },
    "hol_find_entry": {
      "start_point": [
        630,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "static struct hol_entry *\nhol_find_entry (struct hol *hol, const char *name)\n{\n  struct hol_entry *entry = hol->entries;\n  unsigned num_entries = hol->num_entries;\n\n  while (num_entries-- > 0)\n    {\n      const struct argp_option *opt = entry->opt;\n      unsigned num_opts = entry->num;\n\n      while (num_opts-- > 0)\n        if (opt->name && ovisible (opt) && strcmp (opt->name, name) == 0)\n          return entry;\n        else\n          opt++;\n\n      entry++;\n    }\n\n  return 0;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct hol_entry",
        "struct",
        "hol_entry",
        "*\nhol_find_entry (struct hol *hol, const char *name)",
        "*"
      ]
    },
    "hol_set_group": {
      "start_point": [
        655,
        0
      ],
      "end_point": [
        661,
        1
      ],
      "content": "static void\nhol_set_group (struct hol *hol, const char *name, int group)\n{\n  struct hol_entry *entry = hol_find_entry (hol, name);\n  if (entry)\n    entry->group = group;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "group_cmp": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        674,
        1
      ],
      "content": "static int\ngroup_cmp (int group1, int group2, int eq)\n{\n  if (group1 == group2)\n    return eq;\n  else if ((group1 < 0 && group2 < 0) || (group1 >= 0 && group2 >= 0))\n    return group1 - group2;\n  else\n    return group2 - group1;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_cluster_cmp": {
      "start_point": [
        678,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "static int\nhol_cluster_cmp (const struct hol_cluster *cl1, const struct hol_cluster *cl2)\n{\n  /* If one cluster is deeper than the other, use its ancestor at the same\n     level, so that finding the common ancestor is straightforward.\n\n     clN->depth > 0 means that clN->parent != NULL (see hol_add_cluster) */\n  while (cl1->depth > cl2->depth)\n    cl1 = cl1->parent;\n  while (cl2->depth > cl1->depth)\n    cl2 = cl2->parent;\n\n  /* Now reduce both clusters to their ancestors at the point where both have\n     a common parent; these can be directly compared.  */\n  while (cl1->parent != cl2->parent)\n    cl1 = cl1->parent, cl2 = cl2->parent;\n\n  return group_cmp (cl1->group, cl2->group, cl2->index - cl1->index);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_cluster_base": {
      "start_point": [
        700,
        0
      ],
      "end_point": [
        706,
        1
      ],
      "content": "static struct hol_cluster *\nhol_cluster_base (struct hol_cluster *cl)\n{\n  while (cl->parent)\n    cl = cl->parent;\n  return cl;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct hol_cluster",
        "struct",
        "hol_cluster",
        "*\nhol_cluster_base (struct hol_cluster *cl)",
        "*"
      ]
    },
    "hol_cluster_is_child": {
      "start_point": [
        709,
        0
      ],
      "end_point": [
        716,
        1
      ],
      "content": "static int\nhol_cluster_is_child (const struct hol_cluster *cl1,\n                      const struct hol_cluster *cl2)\n{\n  while (cl1 && cl1 != cl2)\n    cl1 = cl1->parent;\n  return cl1 == cl2;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "canon_doc_option": {
      "start_point": [
        721,
        0
      ],
      "end_point": [
        740,
        1
      ],
      "content": "static int\ncanon_doc_option (const char **name)\n{\n  int non_opt;\n\n  if (!*name)\n    non_opt = 1;\n  else\n    {\n      /* Skip initial whitespace.  */\n      while (isspace ((unsigned char) **name))\n        (*name)++;\n      /* Decide whether this looks like an option (leading '-') or not.  */\n      non_opt = (**name != '-');\n      /* Skip until part of name used for sorting.  */\n      while (**name && !isalnum ((unsigned char) **name))\n        (*name)++;\n    }\n  return non_opt;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_cmp": {
      "start_point": [
        746,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "static int\nhol_entry_cmp (const struct hol_entry *entry1,\n               const struct hol_entry *entry2)\n{\n  /* The group numbers by which the entries should be ordered; if either is\n     in a cluster, then this is just the group within the cluster.  */\n  int group1 = entry1->group, group2 = entry2->group;\n  int rc;\n\n  if (entry1->cluster != entry2->cluster)\n    {\n      /* The entries are not within the same cluster, so we can't compare them\n         directly, we have to use the appropriate clustering level too.  */\n      if (! entry1->cluster)\n        /* ENTRY1 is at the \"base level\", not in a cluster, so we have to\n           compare it's group number with that of the base cluster in which\n           ENTRY2 resides.  Note that if they're in the same group, the\n           clustered option always comes laster.  */\n        return group_cmp (group1, hol_cluster_base (entry2->cluster)->group, -1);\n      else if (! entry2->cluster)\n        /* Likewise, but ENTRY2's not in a cluster.  */\n        return group_cmp (hol_cluster_base (entry1->cluster)->group, group2, 1);\n      else\n        /* Both entries are in clusters, we can just compare the clusters.  */\n        return (rc = hol_cluster_cmp (entry1->cluster, entry2->cluster)) ?\n               rc : HOL_ENTRY_PTRCMP (entry1, entry2);\n    }\n  else if (group1 == group2)\n    /* The entries are both in the same cluster and group, so compare them\n       alphabetically.  */\n    {\n      int short1 = hol_entry_first_short (entry1);\n      int short2 = hol_entry_first_short (entry2);\n      int doc1 = odoc (entry1->opt);\n      int doc2 = odoc (entry2->opt);\n      const char *long1 = hol_entry_first_long (entry1);\n      const char *long2 = hol_entry_first_long (entry2);\n\n      if (doc1)\n        doc1 = canon_doc_option (&long1);\n      if (doc2)\n        doc2 = canon_doc_option (&long2);\n\n      if (doc1 != doc2)\n        /* \"documentation\" options always follow normal options (or\n           documentation options that *look* like normal options).  */\n        return doc1 - doc2;\n      else if (!short1 && !short2 && long1 && long2)\n        /* Only long options.  */\n        return (rc = __strcasecmp (long1, long2)) ?\n               rc : HOL_ENTRY_PTRCMP (entry1, entry2);\n      else\n        /* Compare short/short, long/short, short/long, using the first\n           character of long options.  Entries without *any* valid\n           options (such as options with OPTION_HIDDEN set) will be put\n           first, but as they're not displayed, it doesn't matter where\n           they are.  */\n        {\n          unsigned char first1 = short1 ? short1 : long1 ? *long1 : 0;\n          unsigned char first2 = short2 ? short2 : long2 ? *long2 : 0;\n          /* Use tolower, not _tolower, since only the former is\n             guaranteed to work on something already lower case.  */\n          int lower_cmp = tolower (first1) - tolower (first2);\n          /* Compare ignoring case, except when the options are both the\n             same letter, in which case lower-case always comes first.  */\n          return lower_cmp ? lower_cmp :\n                 (rc = first2 - first1) ?\n                 rc : HOL_ENTRY_PTRCMP (entry1, entry2);\n        }\n    }\n  else\n    /* Within the same cluster, but not the same group, so just compare\n       groups.  */\n    return group_cmp (group1, group2, HOL_ENTRY_PTRCMP (entry1, entry2));\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_qcmp": {
      "start_point": [
        823,
        0
      ],
      "end_point": [
        827,
        1
      ],
      "content": "static int\nhol_entry_qcmp (const void *entry1_v, const void *entry2_v)\n{\n  return hol_entry_cmp (entry1_v, entry2_v);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_sort": {
      "start_point": [
        832,
        0
      ],
      "end_point": [
        844,
        1
      ],
      "content": "static void\nhol_sort (struct hol *hol)\n{\n  if (hol->num_entries > 0)\n    {\n      unsigned i;\n      struct hol_entry *e;\n      for (i = 0, e = hol->entries; i < hol->num_entries; i++, e++)\n        e->ord = i;\n      qsort (hol->entries, hol->num_entries, sizeof (struct hol_entry),\n             hol_entry_qcmp);\n    }\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_append": {
      "start_point": [
        848,
        0
      ],
      "end_point": [
        938,
        1
      ],
      "content": "static void\nhol_append (struct hol *hol, struct hol *more)\n{\n  struct hol_cluster **cl_end = &hol->clusters;\n\n  /* Steal MORE's cluster list, and add it to the end of HOL's.  */\n  while (*cl_end)\n    cl_end = &(*cl_end)->next;\n  *cl_end = more->clusters;\n  more->clusters = 0;\n\n  /* Merge entries.  */\n  if (more->num_entries > 0)\n    {\n      if (hol->num_entries == 0)\n        {\n          hol->num_entries = more->num_entries;\n          hol->entries = more->entries;\n          hol->short_options = more->short_options;\n          more->num_entries = 0;        /* Mark MORE's fields as invalid.  */\n        }\n      else\n        /* Append the entries in MORE to those in HOL, taking care to only add\n           non-shadowed SHORT_OPTIONS values.  */\n        {\n          unsigned left;\n          char *so, *more_so;\n          struct hol_entry *e;\n          unsigned num_entries = hol->num_entries + more->num_entries;\n          struct hol_entry *entries =\n            malloc (num_entries * sizeof (struct hol_entry));\n          unsigned hol_so_len = strlen (hol->short_options);\n          char *short_options =\n            malloc (hol_so_len + strlen (more->short_options) + 1);\n\n          assert (entries && short_options);\n          if (SIZE_MAX <= UINT_MAX)\n            assert (num_entries <= SIZE_MAX / sizeof (struct hol_entry));\n\n          __mempcpy (__mempcpy (entries, hol->entries,\n                                hol->num_entries * sizeof (struct hol_entry)),\n                     more->entries,\n                     more->num_entries * sizeof (struct hol_entry));\n\n          __mempcpy (short_options, hol->short_options, hol_so_len);\n\n          /* Fix up the short options pointers from HOL.  */\n          for (e = entries, left = hol->num_entries; left > 0; e++, left--)\n            e->short_options =\n              short_options + (e->short_options - hol->short_options);\n\n          /* Now add the short options from MORE, fixing up its entries\n             too.  */\n          so = short_options + hol_so_len;\n          more_so = more->short_options;\n          for (left = more->num_entries; left > 0; e++, left--)\n            {\n              int opts_left;\n              const struct argp_option *opt;\n\n              e->short_options = so;\n\n              for (opts_left = e->num, opt = e->opt; opts_left; opt++, opts_left--)\n                {\n                  int ch = *more_so;\n                  if (oshort (opt) && ch == opt->key)\n                    /* The next short option in MORE_SO, CH, is from OPT.  */\n                    {\n                      if (! find_char (ch, short_options,\n                                       short_options + hol_so_len))\n                        /* The short option CH isn't shadowed by HOL's options,\n                           so add it to the sum.  */\n                        *so++ = ch;\n                      more_so++;\n                    }\n                }\n            }\n\n          *so = '\\0';\n\n          free (hol->entries);\n          free (hol->short_options);\n\n          hol->entries = entries;\n          hol->num_entries = num_entries;\n          hol->short_options = short_options;\n        }\n    }\n\n  hol_free (more);\n}",
      "lines": 91,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "indent_to": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "static void\nindent_to (argp_fmtstream_t stream, unsigned col)\n{\n  int needed = col - __argp_fmtstream_point (stream);\n  while (needed-- > 0)\n    __argp_fmtstream_putc (stream, ' ');\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "space": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        959,
        1
      ],
      "content": "static void\nspace (argp_fmtstream_t stream, size_t ensure)\n{\n  if (__argp_fmtstream_point (stream) + ensure\n      >= __argp_fmtstream_rmargin (stream))\n    __argp_fmtstream_putc (stream, '\\n');\n  else\n    __argp_fmtstream_putc (stream, ' ');\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "arg": {
      "start_point": [
        964,
        0
      ],
      "end_point": [
        977,
        1
      ],
      "content": "static void\narg (const struct argp_option *real, const char *req_fmt, const char *opt_fmt,\n     const char *domain, argp_fmtstream_t stream)\n{\n  if (real->arg)\n    {\n      if (real->flags & OPTION_ARG_OPTIONAL)\n        __argp_fmtstream_printf (stream, opt_fmt,\n                                 dgettext (domain, real->arg));\n      else\n        __argp_fmtstream_printf (stream, req_fmt,\n                                 dgettext (domain, real->arg));\n    }\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "filter_doc": {
      "start_point": [
        1013,
        0
      ],
      "end_point": [
        1026,
        1
      ],
      "content": "static const char *\nfilter_doc (const char *doc, int key, const struct argp *argp,\n            const struct argp_state *state)\n{\n  if (argp->help_filter)\n    /* We must apply a user filter to this output.  */\n    {\n      void *input = __argp_input (argp, state);\n      return (*argp->help_filter) (key, doc, input);\n    }\n  else\n    /* No filter.  */\n    return doc;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nfilter_doc (const char *doc, int key, const struct argp *argp,\n            const struct argp_state *state)",
        "*"
      ]
    },
    "print_header": {
      "start_point": [
        1033,
        0
      ],
      "end_point": [
        1060,
        1
      ],
      "content": "static void\nprint_header (const char *str, const struct argp *argp,\n              struct pentry_state *pest)\n{\n  const char *tstr = dgettext (argp->argp_domain, str);\n  const char *fstr = filter_doc (tstr, ARGP_KEY_HELP_HEADER, argp, pest->state);\n\n  if (fstr)\n    {\n      if (*fstr)\n        {\n          if (pest->hhstate->prev_entry)\n            /* Precede with a blank line.  */\n            __argp_fmtstream_putc (pest->stream, '\\n');\n          indent_to (pest->stream, uparams.header_col);\n          __argp_fmtstream_set_lmargin (pest->stream, uparams.header_col);\n          __argp_fmtstream_set_wmargin (pest->stream, uparams.header_col);\n          __argp_fmtstream_puts (pest->stream, fstr);\n          __argp_fmtstream_set_lmargin (pest->stream, 0);\n          __argp_fmtstream_putc (pest->stream, '\\n');\n        }\n\n      pest->hhstate->sep_groups = 1; /* Separate subsequent groups. */\n    }\n\n  if (fstr != tstr)\n    free ((char *) fstr);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "comma": {
      "start_point": [
        1066,
        0
      ],
      "end_point": [
        1097,
        1
      ],
      "content": "static void\ncomma (unsigned col, struct pentry_state *pest)\n{\n  if (pest->first)\n    {\n      const struct hol_entry *pe = pest->hhstate->prev_entry;\n      const struct hol_cluster *cl = pest->entry->cluster;\n\n      if (pest->hhstate->sep_groups && pe && pest->entry->group != pe->group)\n        __argp_fmtstream_putc (pest->stream, '\\n');\n\n      if (cl && cl->header && *cl->header\n          && (!pe\n              || (pe->cluster != cl\n                  && !hol_cluster_is_child (pe->cluster, cl))))\n        /* If we're changing clusters, then this must be the start of the\n           ENTRY's cluster unless that is an ancestor of the previous one\n           (in which case we had just popped into a sub-cluster for a bit).\n           If so, then print the cluster's header line.  */\n        {\n          int old_wm = __argp_fmtstream_wmargin (pest->stream);\n          print_header (cl->header, cl->argp, pest);\n          __argp_fmtstream_set_wmargin (pest->stream, old_wm);\n        }\n\n      pest->first = 0;\n    }\n  else\n    __argp_fmtstream_puts (pest->stream, \", \");\n\n  indent_to (pest->stream, col);\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_entry_help": {
      "start_point": [
        1100,
        0
      ],
      "end_point": [
        1233,
        1
      ],
      "content": "static void\nhol_entry_help (struct hol_entry *entry, const struct argp_state *state,\n                argp_fmtstream_t stream, struct hol_help_state *hhstate)\n{\n  unsigned num;\n  const struct argp_option *real = entry->opt, *opt;\n  char *so = entry->short_options;\n  int have_long_opt = 0;        /* We have any long options.  */\n  /* Saved margins.  */\n  int old_lm = __argp_fmtstream_set_lmargin (stream, 0);\n  int old_wm = __argp_fmtstream_wmargin (stream);\n  /* PEST is a state block holding some of our variables that we'd like to\n     share with helper functions.  */\n  struct pentry_state pest;\n\n  pest.entry = entry;\n  pest.stream = stream;\n  pest.hhstate = hhstate;\n  pest.first = 1;\n  pest.state = state;\n\n  if (! odoc (real))\n    for (opt = real, num = entry->num; num > 0; opt++, num--)\n      if (opt->name && ovisible (opt))\n        {\n          have_long_opt = 1;\n          break;\n        }\n\n  /* First emit short options.  */\n  __argp_fmtstream_set_wmargin (stream, uparams.short_opt_col); /* For truly bizarre cases. */\n  for (opt = real, num = entry->num; num > 0; opt++, num--)\n    if (oshort (opt) && opt->key == *so)\n      /* OPT has a valid (non shadowed) short option.  */\n      {\n        if (ovisible (opt))\n          {\n            comma (uparams.short_opt_col, &pest);\n            __argp_fmtstream_putc (stream, '-');\n            __argp_fmtstream_putc (stream, *so);\n            if (!have_long_opt || uparams.dup_args)\n              arg (real, \" %s\", \"[%s]\", state->root_argp->argp_domain, stream);\n            else if (real->arg)\n              hhstate->suppressed_dup_arg = 1;\n          }\n        so++;\n      }\n\n  /* Now, long options.  */\n  if (odoc (real))\n    /* A \"documentation\" option.  */\n    {\n      __argp_fmtstream_set_wmargin (stream, uparams.doc_opt_col);\n      for (opt = real, num = entry->num; num > 0; opt++, num--)\n        if (opt->name && *opt->name && ovisible (opt))\n          {\n            comma (uparams.doc_opt_col, &pest);\n            /* Calling dgettext here isn't quite right, since sorting will\n               have been done on the original; but documentation options\n               should be pretty rare anyway...  */\n            __argp_fmtstream_puts (stream,\n                                   onotrans (opt) ?\n                                             opt->name :\n                                   dgettext (state->root_argp->argp_domain,\n                                             opt->name));\n          }\n    }\n  else\n    /* A real long option.  */\n    {\n      int first_long_opt = 1;\n\n      __argp_fmtstream_set_wmargin (stream, uparams.long_opt_col);\n      for (opt = real, num = entry->num; num > 0; opt++, num--)\n        if (opt->name && ovisible (opt))\n          {\n            comma (uparams.long_opt_col, &pest);\n            __argp_fmtstream_printf (stream, \"--%s\", opt->name);\n            if (first_long_opt || uparams.dup_args)\n              arg (real, \"=%s\", \"[=%s]\", state->root_argp->argp_domain,\n                   stream);\n            else if (real->arg)\n              hhstate->suppressed_dup_arg = 1;\n          }\n    }\n\n  /* Next, documentation strings.  */\n  __argp_fmtstream_set_lmargin (stream, 0);\n\n  if (pest.first)\n    {\n      /* Didn't print any switches, what's up?  */\n      if (!oshort (real) && !real->name)\n        /* This is a group header, print it nicely.  */\n        print_header (real->doc, entry->argp, &pest);\n      else\n        /* Just a totally shadowed option or null header; print nothing.  */\n        goto cleanup;           /* Just return, after cleaning up.  */\n    }\n  else\n    {\n      const char *tstr = real->doc ? dgettext (state->root_argp->argp_domain,\n                                               real->doc) : 0;\n      const char *fstr = filter_doc (tstr, real->key, entry->argp, state);\n      if (fstr && *fstr)\n        {\n          unsigned int col = __argp_fmtstream_point (stream);\n\n          __argp_fmtstream_set_lmargin (stream, uparams.opt_doc_col);\n          __argp_fmtstream_set_wmargin (stream, uparams.opt_doc_col);\n\n          if (col > (unsigned int) (uparams.opt_doc_col + 3))\n            __argp_fmtstream_putc (stream, '\\n');\n          else if (col >= (unsigned int) uparams.opt_doc_col)\n            __argp_fmtstream_puts (stream, \"   \");\n          else\n            indent_to (stream, uparams.opt_doc_col);\n\n          __argp_fmtstream_puts (stream, fstr);\n        }\n      if (fstr && fstr != tstr)\n        free ((char *) fstr);\n\n      /* Reset the left margin.  */\n      __argp_fmtstream_set_lmargin (stream, 0);\n      __argp_fmtstream_putc (stream, '\\n');\n    }\n\n  hhstate->prev_entry = entry;\n\ncleanup:\n  __argp_fmtstream_set_lmargin (stream, old_lm);\n  __argp_fmtstream_set_wmargin (stream, old_wm);\n}",
      "lines": 134,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_help": {
      "start_point": [
        1236,
        0
      ],
      "end_point": [
        1263,
        1
      ],
      "content": "static void\nhol_help (struct hol *hol, const struct argp_state *state,\n          argp_fmtstream_t stream)\n{\n  unsigned num;\n  struct hol_entry *entry;\n  struct hol_help_state hhstate = { 0, 0, 0 };\n\n  for (entry = hol->entries, num = hol->num_entries; num > 0; entry++, num--)\n    hol_entry_help (entry, state, stream, &hhstate);\n\n  if (hhstate.suppressed_dup_arg && uparams.dup_args_note)\n    {\n      const char *tstr = dgettext (state->root_argp->argp_domain, \"\\\nMandatory or optional arguments to long options are also mandatory or \\\noptional for any corresponding short options.\");\n      const char *fstr = filter_doc (tstr, ARGP_KEY_HELP_DUP_ARGS_NOTE,\n                                     state ? state->root_argp : 0, state);\n      if (fstr && *fstr)\n        {\n          __argp_fmtstream_putc (stream, '\\n');\n          __argp_fmtstream_puts (stream, fstr);\n          __argp_fmtstream_putc (stream, '\\n');\n        }\n      if (fstr && fstr != tstr)\n        free ((char *) fstr);\n    }\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_argless_short_opt": {
      "start_point": [
        1269,
        0
      ],
      "end_point": [
        1279,
        1
      ],
      "content": "static int\nadd_argless_short_opt (const struct argp_option *opt,\n                       const struct argp_option *real,\n                       const char *domain, void *cookie)\n{\n  char **snao_end = cookie;\n  if (!(opt->arg || real->arg)\n      && !((opt->flags | real->flags) & OPTION_NO_USAGE))\n    *(*snao_end)++ = opt->key;\n  return 0;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage_argful_short_opt": {
      "start_point": [
        1283,
        0
      ],
      "end_point": [
        1311,
        1
      ],
      "content": "static int\nusage_argful_short_opt (const struct argp_option *opt,\n                        const struct argp_option *real,\n                        const char *domain, void *cookie)\n{\n  argp_fmtstream_t stream = cookie;\n  const char *arg = opt->arg;\n  int flags = opt->flags | real->flags;\n\n  if (! arg)\n    arg = real->arg;\n\n  if (arg && !(flags & OPTION_NO_USAGE))\n    {\n      arg = dgettext (domain, arg);\n\n      if (flags & OPTION_ARG_OPTIONAL)\n        __argp_fmtstream_printf (stream, \" [-%c[%s]]\", opt->key, arg);\n      else\n        {\n          /* Manually do line wrapping so that it (probably) won't\n             get wrapped at the embedded space.  */\n          space (stream, 6 + strlen (arg));\n          __argp_fmtstream_printf (stream, \"[-%c %s]\", opt->key, arg);\n        }\n    }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage_long_opt": {
      "start_point": [
        1315,
        0
      ],
      "end_point": [
        1342,
        1
      ],
      "content": "static int\nusage_long_opt (const struct argp_option *opt,\n                const struct argp_option *real,\n                const char *domain, void *cookie)\n{\n  argp_fmtstream_t stream = cookie;\n  const char *arg = opt->arg;\n  int flags = opt->flags | real->flags;\n\n  if (! arg)\n    arg = real->arg;\n\n  if (! (flags & OPTION_NO_USAGE) && !odoc (opt))\n    {\n      if (arg)\n        {\n          arg = dgettext (domain, arg);\n          if (flags & OPTION_ARG_OPTIONAL)\n            __argp_fmtstream_printf (stream, \" [--%s[=%s]]\", opt->name, arg);\n          else\n            __argp_fmtstream_printf (stream, \" [--%s=%s]\", opt->name, arg);\n        }\n      else\n        __argp_fmtstream_printf (stream, \" [--%s]\", opt->name);\n    }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_usage": {
      "start_point": [
        1345,
        0
      ],
      "end_point": [
        1381,
        1
      ],
      "content": "static void\nhol_usage (struct hol *hol, argp_fmtstream_t stream)\n{\n  if (hol->num_entries > 0)\n    {\n      unsigned nentries;\n      struct hol_entry *entry;\n      char *short_no_arg_opts = alloca (strlen (hol->short_options) + 1);\n      char *snao_end = short_no_arg_opts;\n\n      /* First we put a list of short options without arguments.  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_short_iterate (entry, add_argless_short_opt,\n                                 entry->argp->argp_domain, &snao_end);\n      if (snao_end > short_no_arg_opts)\n        {\n          *snao_end++ = 0;\n          __argp_fmtstream_printf (stream, \" [-%s]\", short_no_arg_opts);\n        }\n\n      /* Now a list of short options *with* arguments.  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_short_iterate (entry, usage_argful_short_opt,\n                                 entry->argp->argp_domain, stream);\n\n      /* Finally, a list of long options (whew!).  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_long_iterate (entry, usage_long_opt,\n                                entry->argp->argp_domain, stream);\n    }\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argp_hol": {
      "start_point": [
        1385,
        0
      ],
      "end_point": [
        1404,
        1
      ],
      "content": "static struct hol *\nargp_hol (const struct argp *argp, struct hol_cluster *cluster)\n{\n  const struct argp_child *child = argp->children;\n  struct hol *hol = make_hol (argp, cluster);\n  if (child)\n    while (child->argp)\n      {\n        struct hol_cluster *child_cluster =\n          ((child->group || child->header)\n           /* Put CHILD->argp within its own cluster.  */\n           ? hol_add_cluster (hol, child->group, child->header,\n                              child - argp->children, cluster, argp)\n           /* Just merge it into the parent's cluster.  */\n           : cluster);\n        hol_append (hol, argp_hol (child->argp, child_cluster)) ;\n        child++;\n      }\n  return hol;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "struct hol",
        "struct",
        "hol",
        "*\nargp_hol (const struct argp *argp, struct hol_cluster *cluster)",
        "*"
      ]
    },
    "argp_args_levels": {
      "start_point": [
        1408,
        0
      ],
      "end_point": [
        1422,
        1
      ],
      "content": "static size_t\nargp_args_levels (const struct argp *argp)\n{\n  size_t levels = 0;\n  const struct argp_child *child = argp->children;\n\n  if (argp->args_doc && strchr (argp->args_doc, '\\n'))\n    levels++;\n\n  if (child)\n    while (child->argp)\n      levels += argp_args_levels ((child++)->argp);\n\n  return levels;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "argp_args_usage": {
      "start_point": [
        1429,
        0
      ],
      "end_point": [
        1482,
        1
      ],
      "content": "static int\nargp_args_usage (const struct argp *argp, const struct argp_state *state,\n                 char **levels, int advance, argp_fmtstream_t stream)\n{\n  char *our_level = *levels;\n  int multiple = 0;\n  const struct argp_child *child = argp->children;\n  const char *tdoc = dgettext (argp->argp_domain, argp->args_doc), *nl = 0;\n  const char *fdoc = filter_doc (tdoc, ARGP_KEY_HELP_ARGS_DOC, argp, state);\n\n  if (fdoc)\n    {\n      const char *cp = fdoc;\n      nl = __strchrnul (cp, '\\n');\n      if (*nl != '\\0')\n        /* This is a \"multi-level\" args doc; advance to the correct position\n           as determined by our state in LEVELS, and update LEVELS.  */\n        {\n          int i;\n          multiple = 1;\n          for (i = 0; i < *our_level; i++)\n            cp = nl + 1, nl = __strchrnul (cp, '\\n');\n          (*levels)++;\n        }\n\n      /* Manually do line wrapping so that it (probably) won't get wrapped at\n         any embedded spaces.  */\n      space (stream, 1 + nl - cp);\n\n      __argp_fmtstream_write (stream, cp, nl - cp);\n    }\n  if (fdoc && fdoc != tdoc)\n    free ((char *)fdoc);        /* Free user's modified doc string.  */\n\n  if (child)\n    while (child->argp)\n      advance = !argp_args_usage ((child++)->argp, state, levels, advance, stream);\n\n  if (advance && multiple)\n    {\n      /* Need to increment our level.  */\n      if (*nl)\n        /* There's more we can do here.  */\n        {\n          (*our_level)++;\n          advance = 0;          /* Our parent shouldn't advance also. */\n        }\n      else if (*our_level > 0)\n        /* We had multiple levels, but used them up; reset to zero.  */\n        *our_level = 0;\n    }\n\n  return !advance;\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "argp_doc": {
      "start_point": [
        1491,
        0
      ],
      "end_point": [
        1581,
        1
      ],
      "content": "static int\nargp_doc (const struct argp *argp, const struct argp_state *state,\n          int post, int pre_blank, int first_only,\n          argp_fmtstream_t stream)\n{\n  const char *text;\n  const char *inp_text;\n  size_t inp_text_len = 0;\n  const char *trans_text;\n  void *input = 0;\n  int anything = 0;\n  const struct argp_child *child = argp->children;\n\n  if (argp->doc)\n    {\n      char *vt = strchr (argp->doc, '\\v');\n      if (vt)\n        {\n          if (post)\n            inp_text = vt + 1;\n          else\n            {\n              inp_text_len = vt - argp->doc;\n              inp_text = __strndup (argp->doc, inp_text_len);\n            }\n        }\n      else\n        inp_text = post ? 0 : argp->doc;\n      trans_text = inp_text ? dgettext (argp->argp_domain, inp_text) : NULL;\n    }\n  else\n    trans_text = inp_text = 0;\n\n  if (argp->help_filter)\n    /* We have to filter the doc strings.  */\n    {\n      input = __argp_input (argp, state);\n      text =\n        (*argp->help_filter) (post\n                              ? ARGP_KEY_HELP_POST_DOC\n                              : ARGP_KEY_HELP_PRE_DOC,\n                              trans_text, input);\n    }\n  else\n    text = (const char *) trans_text;\n\n  if (text)\n    {\n      if (pre_blank)\n        __argp_fmtstream_putc (stream, '\\n');\n\n      __argp_fmtstream_puts (stream, text);\n\n      if (__argp_fmtstream_point (stream) > __argp_fmtstream_lmargin (stream))\n        __argp_fmtstream_putc (stream, '\\n');\n\n      anything = 1;\n    }\n\n  if (text && text != trans_text)\n    free ((char *) text);       /* Free TEXT returned from the help filter.  */\n\n  if (inp_text && inp_text_len)\n    free ((char *) inp_text);   /* We copied INP_TEXT, so free it now.  */\n\n  if (post && argp->help_filter)\n    /* Now see if we have to output an ARGP_KEY_HELP_EXTRA text.  */\n    {\n      text = (*argp->help_filter) (ARGP_KEY_HELP_EXTRA, 0, input);\n      if (text)\n        {\n          if (anything || pre_blank)\n            __argp_fmtstream_putc (stream, '\\n');\n          __argp_fmtstream_puts (stream, text);\n          free ((char *) text);\n          if (__argp_fmtstream_point (stream)\n              > __argp_fmtstream_lmargin (stream))\n            __argp_fmtstream_putc (stream, '\\n');\n          anything = 1;\n        }\n    }\n\n  if (child)\n    while (child->argp && !(first_only && anything))\n      anything |=\n        argp_doc ((child++)->argp, state,\n                  post, anything || pre_blank, first_only,\n                  stream);\n\n  return anything;\n}",
      "lines": 91,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_help": {
      "start_point": [
        1587,
        0
      ],
      "end_point": [
        1726,
        1
      ],
      "content": "static void\n_help (const struct argp *argp, const struct argp_state *state, FILE *stream,\n       unsigned flags, char *name)\n{\n  int anything = 0;             /* Whether we've output anything.  */\n  struct hol *hol = 0;\n  argp_fmtstream_t fs;\n\n  if (! stream)\n    return;\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n  __flockfile (stream);\n#endif\n\n  if (! uparams.valid)\n    fill_in_uparams (state);\n\n  fs = __argp_make_fmtstream (stream, 0, uparams.rmargin, 0);\n  if (! fs)\n    {\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n      __funlockfile (stream);\n#endif\n      return;\n    }\n\n  if (flags & (ARGP_HELP_USAGE | ARGP_HELP_SHORT_USAGE | ARGP_HELP_LONG))\n    {\n      hol = argp_hol (argp, 0);\n\n      /* If present, these options always come last.  */\n      hol_set_group (hol, \"help\", -1);\n      hol_set_group (hol, \"version\", -1);\n\n      hol_sort (hol);\n    }\n\n  if (flags & (ARGP_HELP_USAGE | ARGP_HELP_SHORT_USAGE))\n    /* Print a short \"Usage:\" message.  */\n    {\n      int first_pattern = 1, more_patterns;\n      size_t num_pattern_levels = argp_args_levels (argp);\n      char *pattern_levels = alloca (num_pattern_levels);\n\n      memset (pattern_levels, 0, num_pattern_levels);\n\n      do\n        {\n          int old_lm;\n          int old_wm = __argp_fmtstream_set_wmargin (fs, uparams.usage_indent);\n          char *levels = pattern_levels;\n\n          if (first_pattern)\n            __argp_fmtstream_printf (fs, \"%s %s\",\n                                     dgettext (argp->argp_domain, \"Usage:\"),\n                                     name);\n          else\n            __argp_fmtstream_printf (fs, \"%s %s\",\n                                     dgettext (argp->argp_domain, \"  or: \"),\n                                     name);\n\n          /* We set the lmargin as well as the wmargin, because hol_usage\n             manually wraps options with newline to avoid annoying breaks.  */\n          old_lm = __argp_fmtstream_set_lmargin (fs, uparams.usage_indent);\n\n          if (flags & ARGP_HELP_SHORT_USAGE)\n            /* Just show where the options go.  */\n            {\n              if (hol->num_entries > 0)\n                __argp_fmtstream_puts (fs, dgettext (argp->argp_domain,\n                                                     \" [OPTION...]\"));\n            }\n          else\n            /* Actually print the options.  */\n            {\n              hol_usage (hol, fs);\n              flags |= ARGP_HELP_SHORT_USAGE; /* But only do so once.  */\n            }\n\n          more_patterns = argp_args_usage (argp, state, &levels, 1, fs);\n\n          __argp_fmtstream_set_wmargin (fs, old_wm);\n          __argp_fmtstream_set_lmargin (fs, old_lm);\n\n          __argp_fmtstream_putc (fs, '\\n');\n          anything = 1;\n\n          first_pattern = 0;\n        }\n      while (more_patterns);\n    }\n\n  if (flags & ARGP_HELP_PRE_DOC)\n    anything |= argp_doc (argp, state, 0, 0, 1, fs);\n\n  if (flags & ARGP_HELP_SEE)\n    {\n      __argp_fmtstream_printf (fs, dgettext (argp->argp_domain, \"\\\nTry '%s --help' or '%s --usage' for more information.\\n\"),\n                               name, name);\n      anything = 1;\n    }\n\n  if (flags & ARGP_HELP_LONG)\n    /* Print a long, detailed help message.  */\n    {\n      /* Print info about all the options.  */\n      if (hol->num_entries > 0)\n        {\n          if (anything)\n            __argp_fmtstream_putc (fs, '\\n');\n          hol_help (hol, state, fs);\n          anything = 1;\n        }\n    }\n\n  if (flags & ARGP_HELP_POST_DOC)\n    /* Print any documentation strings at the end.  */\n    anything |= argp_doc (argp, state, 1, anything, 0, fs);\n\n  if ((flags & ARGP_HELP_BUG_ADDR) && argp_program_bug_address)\n    {\n      if (anything)\n        __argp_fmtstream_putc (fs, '\\n');\n      __argp_fmtstream_printf (fs, dgettext (argp->argp_domain,\n                                             \"Report bugs to %s.\\n\"),\n                               argp_program_bug_address);\n      anything = 1;\n    }\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n  __funlockfile (stream);\n#endif\n\n  if (hol)\n    hol_free (hol);\n\n  __argp_fmtstream_free (fs);\n}",
      "lines": 140,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__argp_help": {
      "start_point": [
        1730,
        0
      ],
      "end_point": [
        1737,
        1
      ],
      "content": "void __argp_help (const struct argp *argp, FILE *stream,\n                  unsigned flags, char *name)\n{\n  struct argp_state state;\n  memset (&state, 0, sizeof state);\n  state.root_argp = argp;\n  _help (argp, &state, stream, flags, name);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "__argp_short_program_name": {
      "start_point": [
        1743,
        0
      ],
      "end_point": [
        1757,
        1
      ],
      "content": "char *\n__argp_short_program_name (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  return __argp_base_name (program_invocation_name);\n# else\n  /* FIXME: What now? Miles suggests that it is better to use NULL,\n     but currently the value is passed on directly to fputs_unlocked,\n     so that requires more changes. */\n# if __GNUC__\n#  warning No reasonable value to return\n# endif /* __GNUC__ */\n  return \"\";\n# endif\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__argp_short_program_name (void)",
        "*"
      ]
    },
    "__argp_state_help": {
      "start_point": [
        1762,
        0
      ],
      "end_point": [
        1781,
        1
      ],
      "content": "void\n__argp_state_help (const struct argp_state *state, FILE *stream, unsigned flags)\n{\n  if ((!state || ! (state->flags & ARGP_NO_ERRS)) && stream)\n    {\n      if (state && (state->flags & ARGP_LONG_ONLY))\n        flags |= ARGP_HELP_LONG_ONLY;\n\n      _help (state ? state->root_argp : 0, state, stream, flags,\n             state ? state->name : __argp_short_program_name ());\n\n      if (!state || ! (state->flags & ARGP_NO_EXIT))\n        {\n          if (flags & ARGP_HELP_EXIT_ERR)\n            exit (argp_err_exit_status);\n          if (flags & ARGP_HELP_EXIT_OK)\n            exit (0);\n        }\n  }\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "__argp_error": {
      "start_point": [
        1789,
        0
      ],
      "end_point": [
        1843,
        1
      ],
      "content": "void\n__argp_error (const struct argp_state *state, const char *fmt, ...)\n{\n  if (!state || !(state->flags & ARGP_NO_ERRS))\n    {\n      FILE *stream = state ? state->err_stream : stderr;\n\n      if (stream)\n        {\n          va_list ap;\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __flockfile (stream);\n#endif\n\n          va_start (ap, fmt);\n\n#ifdef USE_IN_LIBIO\n          if (_IO_fwide (stream, 0) > 0)\n            {\n              char *buf;\n\n              if (__asprintf (&buf, fmt, ap) < 0)\n                buf = NULL;\n\n              __fwprintf (stream, L\"%s: %s\\n\",\n                          state ? state->name : __argp_short_program_name (),\n                          buf);\n\n              free (buf);\n            }\n          else\n#endif\n            {\n              fputs_unlocked (state\n                              ? state->name : __argp_short_program_name (),\n                              stream);\n              putc_unlocked (':', stream);\n              putc_unlocked (' ', stream);\n\n              vfprintf (stream, fmt, ap);\n\n              putc_unlocked ('\\n', stream);\n            }\n\n          __argp_state_help (state, stream, ARGP_HELP_STD_ERR);\n\n          va_end (ap);\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __funlockfile (stream);\n#endif\n        }\n    }\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "__argp_failure": {
      "start_point": [
        1856,
        0
      ],
      "end_point": [
        1953,
        1
      ],
      "content": "void\n__argp_failure (const struct argp_state *state, int status, int errnum,\n                const char *fmt, ...)\n{\n  if (!state || !(state->flags & ARGP_NO_ERRS))\n    {\n      FILE *stream = state ? state->err_stream : stderr;\n\n      if (stream)\n        {\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __flockfile (stream);\n#endif\n\n#ifdef USE_IN_LIBIO\n          if (_IO_fwide (stream, 0) > 0)\n            __fwprintf (stream, L\"%s\",\n                        state ? state->name : __argp_short_program_name ());\n          else\n#endif\n            fputs_unlocked (state\n                            ? state->name : __argp_short_program_name (),\n                            stream);\n\n          if (fmt)\n            {\n              va_list ap;\n\n              va_start (ap, fmt);\n#ifdef USE_IN_LIBIO\n              if (_IO_fwide (stream, 0) > 0)\n                {\n                  char *buf;\n\n                  if (__asprintf (&buf, fmt, ap) < 0)\n                    buf = NULL;\n\n                  __fwprintf (stream, L\": %s\", buf);\n\n                  free (buf);\n                }\n              else\n#endif\n                {\n                  putc_unlocked (':', stream);\n                  putc_unlocked (' ', stream);\n\n                  vfprintf (stream, fmt, ap);\n                }\n\n              va_end (ap);\n            }\n\n          if (errnum)\n            {\n              char buf[200];\n\n#ifdef USE_IN_LIBIO\n              if (_IO_fwide (stream, 0) > 0)\n                __fwprintf (stream, L\": %s\",\n                            __strerror_r (errnum, buf, sizeof (buf)));\n              else\n#endif\n                {\n                  char const *s = NULL;\n                  putc_unlocked (':', stream);\n                  putc_unlocked (' ', stream);\n#if _LIBC || (HAVE_DECL_STRERROR_R && STRERROR_R_CHAR_P && !defined strerror_r)\n                  s = __strerror_r (errnum, buf, sizeof buf);\n#elif HAVE_DECL_STRERROR_R\n                  if (__strerror_r (errnum, buf, sizeof buf) == 0)\n                    s = buf;\n#endif\n#if !_LIBC\n                  if (! s && ! (s = strerror (errnum)))\n                    s = dgettext (state->root_argp->argp_domain,\n                                  \"Unknown system error\");\n#endif\n                  fputs (s, stream);\n                }\n            }\n\n#ifdef USE_IN_LIBIO\n          if (_IO_fwide (stream, 0) > 0)\n            putwc_unlocked (L'\\n', stream);\n          else\n#endif\n            putc_unlocked ('\\n', stream);\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __funlockfile (stream);\n#endif\n\n          if (status && (!state || !(state->flags & ARGP_NO_EXIT)))\n            exit (status);\n        }\n    }\n}",
      "lines": 98,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/argp-namefrob.h": {},
  "cflow/cflow-1.5/gnu/argp-parse.c": {
    "argp_default_parser": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static error_t\nargp_default_parser (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case '?':\n      __argp_state_help (state, state->out_stream, ARGP_HELP_STD_HELP);\n      break;\n    case OPT_USAGE:\n      __argp_state_help (state, state->out_stream,\n                         ARGP_HELP_USAGE | ARGP_HELP_EXIT_OK);\n      break;\n\n    case OPT_PROGNAME:          /* Set the program name.  */\n#if defined _LIBC || HAVE_DECL_PROGRAM_INVOCATION_NAME\n      program_invocation_name = arg;\n#endif\n      /* [Note that some systems only have PROGRAM_INVOCATION_SHORT_NAME (aka\n         __PROGNAME), in which case, PROGRAM_INVOCATION_NAME is just defined\n         to be that, so we have to be a bit careful here.]  */\n\n      /* Update what we use for messages.  */\n      state->name = __argp_base_name (arg);\n\n#if defined _LIBC || HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n      program_invocation_short_name = state->name;\n#endif\n\n      if ((state->flags & (ARGP_PARSE_ARGV0 | ARGP_NO_ERRS))\n          == ARGP_PARSE_ARGV0)\n        /* Update what getopt uses too.  */\n        state->argv[0] = arg;\n\n      break;\n\n    case OPT_HANG:\n      _argp_hang = atoi (arg ? arg : \"3600\");\n      while (_argp_hang-- > 0)\n        __sleep (1);\n      break;\n\n    default:\n      return EBADKEY;\n    }\n  return 0;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "argp_version_parser": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "static error_t\nargp_version_parser (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case 'V':\n      if (argp_program_version_hook)\n        (*argp_program_version_hook) (state->out_stream, state);\n      else if (argp_program_version)\n        fprintf (state->out_stream, \"%s\\n\", argp_program_version);\n      else\n        __argp_error (state, \"%s\",\n                      dgettext (state->root_argp->argp_domain,\n                                \"(PROGRAM ERROR) No version known!?\"));\n      if (! (state->flags & ARGP_NO_EXIT))\n        exit (0);\n      break;\n    default:\n      return EBADKEY;\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "find_long_option": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "static int\nfind_long_option (struct option *long_options, const char *name)\n{\n  struct option *l = long_options;\n  while (l->name != NULL)\n    if (name != NULL && strcmp (l->name, name) == 0)\n      return l - long_options;\n    else\n      l++;\n  if (name == NULL)\n    return l - long_options;\n  else\n    return -1;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "group_parse": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static error_t\ngroup_parse (struct group *group, struct argp_state *state, int key, char *arg)\n{\n  if (group->parser)\n    {\n      error_t err;\n      state->hook = group->hook;\n      state->input = group->input;\n      state->child_inputs = group->child_inputs;\n      state->arg_num = group->args_processed;\n      err = (*group->parser)(key, arg, state);\n      group->hook = state->hook;\n      return err;\n    }\n  else\n    return EBADKEY;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "convert_options": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "static struct group *\nconvert_options (const struct argp *argp,\n                 struct group *parent, unsigned parent_index,\n                 struct group *group, struct parser_convert_state *cvt)\n{\n  /* REAL is the most recent non-alias value of OPT.  */\n  const struct argp_option *real = argp->options;\n  const struct argp_child *children = argp->children;\n\n  if (real || argp->parser)\n    {\n      const struct argp_option *opt;\n\n      if (real)\n        for (opt = real; !__option_is_end (opt); opt++)\n          {\n            if (! (opt->flags & OPTION_ALIAS))\n              /* OPT isn't an alias, so we can use values from it.  */\n              real = opt;\n\n            if (! (real->flags & OPTION_DOC))\n              /* A real option (not just documentation).  */\n              {\n                if (__option_is_short (opt))\n                  /* OPT can be used as a short option.  */\n                  {\n                    *cvt->short_end++ = opt->key;\n                    if (real->arg)\n                      {\n                        *cvt->short_end++ = ':';\n                        if (real->flags & OPTION_ARG_OPTIONAL)\n                          *cvt->short_end++ = ':';\n                      }\n                    *cvt->short_end = '\\0'; /* keep 0 terminated */\n                  }\n\n                if (opt->name\n                    && find_long_option (cvt->parser->long_opts, opt->name) < 0)\n                  /* OPT can be used as a long option.  */\n                  {\n                    cvt->long_end->name = opt->name;\n                    cvt->long_end->has_arg =\n                      (real->arg\n                       ? (real->flags & OPTION_ARG_OPTIONAL\n                          ? optional_argument\n                          : required_argument)\n                       : no_argument);\n                    cvt->long_end->flag = 0;\n                    /* we add a disambiguating code to all the user's\n                       values (which is removed before we actually call\n                       the function to parse the value); this means that\n                       the user loses use of the high 8 bits in all his\n                       values (the sign of the lower bits is preserved\n                       however)...  */\n                    cvt->long_end->val =\n                      ((opt->key ? opt->key : real->key) & USER_MASK)\n                      + (((group - cvt->parser->groups) + 1) << USER_BITS);\n\n                    /* Keep the LONG_OPTS list terminated.  */\n                    (++cvt->long_end)->name = NULL;\n                  }\n              }\n            }\n\n      group->parser = argp->parser;\n      group->argp = argp;\n      group->short_end = cvt->short_end;\n      group->args_processed = 0;\n      group->parent = parent;\n      group->parent_index = parent_index;\n      group->input = 0;\n      group->hook = 0;\n      group->child_inputs = 0;\n\n      if (children)\n        /* Assign GROUP's CHILD_INPUTS field some space from\n           CVT->child_inputs_end.*/\n        {\n          unsigned num_children = 0;\n          while (children[num_children].argp)\n            num_children++;\n          group->child_inputs = cvt->child_inputs_end;\n          cvt->child_inputs_end += num_children;\n        }\n\n      parent = group++;\n    }\n  else\n    parent = 0;\n\n  if (children)\n    {\n      unsigned index = 0;\n      while (children->argp)\n        group =\n          convert_options (children++->argp, parent, index++, group, cvt);\n    }\n\n  return group;\n}",
      "lines": 100,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "struct group",
        "struct",
        "group",
        "*\nconvert_options (const struct argp *argp,\n                 struct group *parent, unsigned parent_index,\n                 struct group *group, struct parser_convert_state *cvt)",
        "*"
      ]
    },
    "parser_convert": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "static void\nparser_convert (struct parser *parser, const struct argp *argp, int flags)\n{\n  struct parser_convert_state cvt;\n\n  cvt.parser = parser;\n  cvt.short_end = parser->short_opts;\n  cvt.long_end = parser->long_opts;\n  cvt.child_inputs_end = parser->child_inputs;\n\n  if (flags & ARGP_IN_ORDER)\n    *cvt.short_end++ = '-';\n  else if (flags & ARGP_NO_ARGS)\n    *cvt.short_end++ = '+';\n  *cvt.short_end = '\\0';\n\n  cvt.long_end->name = NULL;\n\n  parser->argp = argp;\n\n  if (argp)\n    parser->egroup = convert_options (argp, 0, 0, parser->groups, &cvt);\n  else\n    parser->egroup = parser->groups; /* No parsers at all! */\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "calc_sizes": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "static void\ncalc_sizes (const struct argp *argp,  struct parser_sizes *szs)\n{\n  const struct argp_child *child = argp->children;\n  const struct argp_option *opt = argp->options;\n\n  if (opt || argp->parser)\n    {\n      szs->num_groups++;\n      if (opt)\n        {\n          int num_opts = 0;\n          while (!__option_is_end (opt++))\n            num_opts++;\n          szs->short_len += num_opts * 3; /* opt + up to 2 ':'s */\n          szs->long_len += num_opts;\n        }\n    }\n\n  if (child)\n    while (child->argp)\n      {\n        calc_sizes ((child++)->argp, szs);\n        szs->num_child_inputs++;\n      }\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parser_init": {
      "start_point": [
        458,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "static error_t\nparser_init (struct parser *parser, const struct argp *argp,\n             int argc, char **argv, int flags, void *input)\n{\n  error_t err = 0;\n  struct group *group;\n  struct parser_sizes szs;\n  struct _getopt_data opt_data = _GETOPT_DATA_INITIALIZER;\n  char *storage;\n  size_t glen, gsum;\n  size_t clen, csum;\n  size_t llen, lsum;\n  size_t slen, ssum;\n\n  szs.short_len = (flags & ARGP_NO_ARGS) ? 0 : 1;\n  szs.long_len = 0;\n  szs.num_groups = 0;\n  szs.num_child_inputs = 0;\n\n  if (argp)\n    calc_sizes (argp, &szs);\n\n  /* Lengths of the various bits of storage used by PARSER.  */\n  glen = (szs.num_groups + 1) * sizeof (struct group);\n  clen = szs.num_child_inputs * sizeof (void *);\n  llen = (szs.long_len + 1) * sizeof (struct option);\n  slen = szs.short_len + 1;\n\n  /* Sums of previous lengths, properly aligned.  There's no need to\n     align gsum, since struct group is aligned at least as strictly as\n     void * (since it contains a void * member).  And there's no need\n     to align lsum, since struct option is aligned at least as\n     strictly as char.  */\n  gsum = glen;\n  csum = alignto (gsum + clen, alignof (struct option));\n  lsum = csum + llen;\n  ssum = lsum + slen;\n\n  parser->storage = malloc (ssum);\n  if (! parser->storage)\n    return ENOMEM;\n\n  storage = parser->storage;\n  parser->groups = parser->storage;\n  parser->child_inputs = (void **) (storage + gsum);\n  parser->long_opts = (struct option *) (storage + csum);\n  parser->short_opts = storage + lsum;\n  parser->opt_data = opt_data;\n\n  memset (parser->child_inputs, 0, clen);\n  parser_convert (parser, argp, flags);\n\n  memset (&parser->state, 0, sizeof (struct argp_state));\n  parser->state.root_argp = parser->argp;\n  parser->state.argc = argc;\n  parser->state.argv = argv;\n  parser->state.flags = flags;\n  parser->state.err_stream = stderr;\n  parser->state.out_stream = stdout;\n  parser->state.next = 0;       /* Tell getopt to initialize.  */\n  parser->state.pstate = parser;\n\n  parser->try_getopt = 1;\n\n  /* Call each parser for the first time, giving it a chance to propagate\n     values to child parsers.  */\n  if (parser->groups < parser->egroup)\n    parser->groups->input = input;\n  for (group = parser->groups;\n       group < parser->egroup && (!err || err == EBADKEY);\n       group++)\n    {\n      if (group->parent)\n        /* If a child parser, get the initial input value from the parent. */\n        group->input = group->parent->child_inputs[group->parent_index];\n\n      if (!group->parser\n          && group->argp->children && group->argp->children->argp)\n        /* For the special case where no parsing function is supplied for an\n           argp, propagate its input to its first child, if any (this just\n           makes very simple wrapper argps more convenient).  */\n        group->child_inputs[0] = group->input;\n\n      err = group_parse (group, &parser->state, ARGP_KEY_INIT, 0);\n    }\n  if (err == EBADKEY)\n    err = 0;                    /* Some parser didn't understand.  */\n\n  if (err)\n    return err;\n\n  if (parser->state.flags & ARGP_NO_ERRS)\n    {\n      parser->opt_data.opterr = 0;\n      if (parser->state.flags & ARGP_PARSE_ARGV0)\n        /* getopt always skips ARGV[0], so we have to fake it out.  As long\n           as OPTERR is 0, then it shouldn't actually try to access it.  */\n        parser->state.argv--, parser->state.argc++;\n    }\n  else\n    parser->opt_data.opterr = 1;        /* Print error messages.  */\n\n  if (parser->state.argv == argv && argv[0])\n    /* There's an argv[0]; use it for messages.  */\n    parser->state.name = __argp_base_name (argv[0]);\n  else\n    parser->state.name = __argp_short_program_name ();\n\n  return 0;\n}",
      "lines": 110,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_finalize": {
      "start_point": [
        570,
        0
      ],
      "end_point": [
        659,
        1
      ],
      "content": "static error_t\nparser_finalize (struct parser *parser,\n                 error_t err, int arg_ebadkey, int *end_index)\n{\n  struct group *group;\n\n  if (err == EBADKEY && arg_ebadkey)\n    /* Suppress errors generated by unparsed arguments.  */\n    err = 0;\n\n  if (! err)\n    {\n      if (parser->state.next == parser->state.argc)\n        /* We successfully parsed all arguments!  Call all the parsers again,\n           just a few more times... */\n        {\n          for (group = parser->groups;\n               group < parser->egroup && (!err || err==EBADKEY);\n               group++)\n            if (group->args_processed == 0)\n              err = group_parse (group, &parser->state, ARGP_KEY_NO_ARGS, 0);\n          for (group = parser->egroup - 1;\n               group >= parser->groups && (!err || err==EBADKEY);\n               group--)\n            err = group_parse (group, &parser->state, ARGP_KEY_END, 0);\n\n          if (err == EBADKEY)\n            err = 0;            /* Some parser didn't understand.  */\n\n          /* Tell the user that all arguments are parsed.  */\n          if (end_index)\n            *end_index = parser->state.next;\n        }\n      else if (end_index)\n        /* Return any remaining arguments to the user.  */\n        *end_index = parser->state.next;\n      else\n        /* No way to return the remaining arguments, they must be bogus. */\n        {\n          if (!(parser->state.flags & ARGP_NO_ERRS)\n              && parser->state.err_stream)\n            fprintf (parser->state.err_stream,\n                     dgettext (parser->argp->argp_domain,\n                               \"%s: Too many arguments\\n\"),\n                     parser->state.name);\n          err = EBADKEY;\n        }\n    }\n\n  /* Okay, we're all done, with either an error or success; call the parsers\n     to indicate which one.  */\n\n  if (err)\n    {\n      /* Maybe print an error message.  */\n      if (err == EBADKEY)\n        /* An appropriate message describing what the error was should have\n           been printed earlier.  */\n        __argp_state_help (&parser->state, parser->state.err_stream,\n                           ARGP_HELP_STD_ERR);\n\n      /* Since we didn't exit, give each parser an error indication.  */\n      for (group = parser->groups; group < parser->egroup; group++)\n        group_parse (group, &parser->state, ARGP_KEY_ERROR, 0);\n    }\n  else\n    /* Notify parsers of success, and propagate back values from parsers.  */\n    {\n      /* We pass over the groups in reverse order so that child groups are\n         given a chance to do there processing before passing back a value to\n         the parent.  */\n      for (group = parser->egroup - 1\n           ; group >= parser->groups && (!err || err == EBADKEY)\n           ; group--)\n        err = group_parse (group, &parser->state, ARGP_KEY_SUCCESS, 0);\n      if (err == EBADKEY)\n        err = 0;                /* Some parser didn't understand.  */\n    }\n\n  /* Call parsers once more, to do any final cleanup.  Errors are ignored.  */\n  for (group = parser->egroup - 1; group >= parser->groups; group--)\n    group_parse (group, &parser->state, ARGP_KEY_FINI, 0);\n\n  if (err == EBADKEY)\n    err = EINVAL;\n\n  free (parser->storage);\n\n  return err;\n}",
      "lines": 90,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_arg": {
      "start_point": [
        666,
        0
      ],
      "end_point": [
        713,
        1
      ],
      "content": "static error_t\nparser_parse_arg (struct parser *parser, char *val)\n{\n  /* Save the starting value of NEXT, first adjusting it so that the arg\n     we're parsing is again the front of the arg vector.  */\n  int index = --parser->state.next;\n  error_t err = EBADKEY;\n  struct group *group;\n  int key = 0;                  /* Which of ARGP_KEY_ARG[S] we used.  */\n\n  /* Try to parse the argument in each parser.  */\n  for (group = parser->groups\n       ; group < parser->egroup && err == EBADKEY\n       ; group++)\n    {\n      parser->state.next++;     /* For ARGP_KEY_ARG, consume the arg.  */\n      key = ARGP_KEY_ARG;\n      err = group_parse (group, &parser->state, key, val);\n\n      if (err == EBADKEY)\n        /* This parser doesn't like ARGP_KEY_ARG; try ARGP_KEY_ARGS instead. */\n        {\n          parser->state.next--; /* For ARGP_KEY_ARGS, put back the arg.  */\n          key = ARGP_KEY_ARGS;\n          err = group_parse (group, &parser->state, key, 0);\n        }\n    }\n\n  if (! err)\n    {\n      if (key == ARGP_KEY_ARGS)\n        /* The default for ARGP_KEY_ARGS is to assume that if NEXT isn't\n           changed by the user, *all* arguments should be considered\n           consumed.  */\n        parser->state.next = parser->state.argc;\n\n      if (parser->state.next > index)\n        /* Remember that we successfully processed a non-option\n           argument -- but only if the user hasn't gotten tricky and set\n           the clock back.  */\n        (--group)->args_processed += (parser->state.next - index);\n      else\n        /* The user wants to reparse some args, give getopt another try.  */\n        parser->try_getopt = 1;\n    }\n\n  return err;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_opt": {
      "start_point": [
        717,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "static error_t\nparser_parse_opt (struct parser *parser, int opt, char *val)\n{\n  /* The group key encoded in the high bits; 0 for short opts or\n     group_number + 1 for long opts.  */\n  int group_key = opt >> USER_BITS;\n  error_t err = EBADKEY;\n\n  if (group_key == 0)\n    /* A short option.  By comparing OPT's position in SHORT_OPTS to the\n       various starting positions in each group's SHORT_END field, we can\n       determine which group OPT came from.  */\n    {\n      struct group *group;\n      char *short_index = strchr (parser->short_opts, opt);\n\n      if (short_index)\n        for (group = parser->groups; group < parser->egroup; group++)\n          if (group->short_end > short_index)\n            {\n              err = group_parse (group, &parser->state, opt,\n                                 parser->opt_data.optarg);\n              break;\n            }\n    }\n  else\n    /* A long option.  We use shifts instead of masking for extracting\n       the user value in order to preserve the sign.  */\n    err =\n      group_parse (&parser->groups[group_key - 1], &parser->state,\n                   (opt << GROUP_BITS) >> GROUP_BITS,\n                   parser->opt_data.optarg);\n\n  if (err == EBADKEY)\n    /* At least currently, an option not recognized is an error in the\n       parser, because we pre-compute which parser is supposed to deal\n       with each option.  */\n    {\n      static const char bad_key_err[] =\n        N_(\"(PROGRAM ERROR) Option should have been recognized!?\");\n      if (group_key == 0)\n        __argp_error (&parser->state, \"-%c: %s\", opt,\n                      dgettext (parser->argp->argp_domain, bad_key_err));\n      else\n        {\n          struct option *long_opt = parser->long_opts;\n          while (long_opt->val != opt && long_opt->name)\n            long_opt++;\n          __argp_error (&parser->state, \"--%s: %s\",\n                        long_opt->name ? long_opt->name : \"???\",\n                        dgettext (parser->argp->argp_domain, bad_key_err));\n        }\n    }\n\n  return err;\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_next": {
      "start_point": [
        778,
        0
      ],
      "end_point": [
        863,
        1
      ],
      "content": "static error_t\nparser_parse_next (struct parser *parser, int *arg_ebadkey)\n{\n  int opt;\n  error_t err = 0;\n\n  if (parser->state.quoted && parser->state.next < parser->state.quoted)\n    /* The next argument pointer has been moved to before the quoted\n       region, so pretend we never saw the quoting \"--\", and give getopt\n       another chance.  If the user hasn't removed it, getopt will just\n       process it again.  */\n    parser->state.quoted = 0;\n\n  if (parser->try_getopt && !parser->state.quoted)\n    /* Give getopt a chance to parse this.  */\n    {\n      /* Put it back in OPTIND for getopt.  */\n      parser->opt_data.optind = parser->state.next;\n      /* Distinguish KEY_ERR from a real option.  */\n      parser->opt_data.optopt = KEY_END;\n      if (parser->state.flags & ARGP_LONG_ONLY)\n        opt = _getopt_long_only_r (parser->state.argc, parser->state.argv,\n                                   parser->short_opts, parser->long_opts, 0,\n                                   &parser->opt_data);\n      else\n        opt = _getopt_long_r (parser->state.argc, parser->state.argv,\n                              parser->short_opts, parser->long_opts, 0,\n                              &parser->opt_data);\n      /* And see what getopt did.  */\n      parser->state.next = parser->opt_data.optind;\n\n      if (opt == KEY_END)\n        /* Getopt says there are no more options, so stop using\n           getopt; we'll continue if necessary on our own.  */\n        {\n          parser->try_getopt = 0;\n          if (parser->state.next > 1\n              && strcmp (parser->state.argv[parser->state.next - 1], QUOTE)\n                   == 0)\n            /* Not only is this the end of the options, but it's a\n               \"quoted\" region, which may have args that *look* like\n               options, so we definitely shouldn't try to use getopt past\n               here, whatever happens.  */\n            parser->state.quoted = parser->state.next;\n        }\n      else if (opt == KEY_ERR && parser->opt_data.optopt != KEY_END)\n        /* KEY_ERR can have the same value as a valid user short\n           option, but in the case of a real error, getopt sets OPTOPT\n           to the offending character, which can never be KEY_END.  */\n        {\n          *arg_ebadkey = 0;\n          return EBADKEY;\n        }\n    }\n  else\n    opt = KEY_END;\n\n  if (opt == KEY_END)\n    {\n      /* We're past what getopt considers the options.  */\n      if (parser->state.next >= parser->state.argc\n          || (parser->state.flags & ARGP_NO_ARGS))\n        /* Indicate that we're done.  */\n        {\n          *arg_ebadkey = 1;\n          return EBADKEY;\n        }\n      else\n        /* A non-option arg; simulate what getopt might have done.  */\n        {\n          opt = KEY_ARG;\n          parser->opt_data.optarg = parser->state.argv[parser->state.next++];\n        }\n    }\n\n  if (opt == KEY_ARG)\n    /* A non-option argument; try each parser in turn.  */\n    err = parser_parse_arg (parser, parser->opt_data.optarg);\n  else\n    err = parser_parse_opt (parser, opt, parser->opt_data.optarg);\n\n  if (err == EBADKEY)\n    *arg_ebadkey = (opt == KEY_END || opt == KEY_ARG);\n\n  return err;\n}",
      "lines": 86,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "__argp_parse": {
      "start_point": [
        870,
        0
      ],
      "end_point": [
        930,
        1
      ],
      "content": "error_t\n__argp_parse (const struct argp *argp, int argc, char **argv, unsigned flags,\n              int *end_index, void *input)\n{\n  error_t err;\n  struct parser parser;\n\n  /* If true, then err == EBADKEY is a result of a non-option argument failing\n     to be parsed (which in some cases isn't actually an error).  */\n  int arg_ebadkey = 0;\n\n#ifndef _LIBC\n  if (!(flags & ARGP_PARSE_ARGV0))\n    {\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n      if (!program_invocation_name)\n        program_invocation_name = argv[0];\n#endif\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n      if (!program_invocation_short_name)\n        program_invocation_short_name = __argp_base_name (argv[0]);\n#endif\n    }\n#endif\n\n  if (! (flags & ARGP_NO_HELP))\n    /* Add our own options.  */\n    {\n      struct argp_child *child = alloca (4 * sizeof (struct argp_child));\n      struct argp *top_argp = alloca (sizeof (struct argp));\n\n      /* TOP_ARGP has no options, it just serves to group the user & default\n         argps.  */\n      memset (top_argp, 0, sizeof (*top_argp));\n      top_argp->children = child;\n\n      memset (child, 0, 4 * sizeof (struct argp_child));\n\n      if (argp)\n        (child++)->argp = argp;\n      (child++)->argp = &argp_default_argp;\n      if (argp_program_version || argp_program_version_hook)\n        (child++)->argp = &argp_version_argp;\n      child->argp = 0;\n\n      argp = top_argp;\n    }\n\n  /* Construct a parser for these arguments.  */\n  err = parser_init (&parser, argp, argc, argv, flags, input);\n\n  if (! err)\n    /* Parse! */\n    {\n      while (! err)\n        err = parser_parse_next (&parser, &arg_ebadkey);\n      err = parser_finalize (&parser, err, arg_ebadkey, end_index);\n    }\n\n  return err;\n}",
      "lines": 61,
      "depth": 13,
      "decorators": [
        "error_t"
      ]
    },
    "__argp_input": {
      "start_point": [
        937,
        0
      ],
      "end_point": [
        951,
        1
      ],
      "content": "void *\n__argp_input (const struct argp *argp, const struct argp_state *state)\n{\n  if (state)\n    {\n      struct group *group;\n      struct parser *parser = state->pstate;\n\n      for (group = parser->groups; group < parser->egroup; group++)\n        if (group->argp == argp)\n          return group->input;\n    }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void",
        "*\n__argp_input (const struct argp *argp, const struct argp_state *state)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/argp-pin.c": {},
  "cflow/cflow-1.5/gnu/argp-pv.c": {},
  "cflow/cflow-1.5/gnu/argp-pvh.c": {},
  "cflow/cflow-1.5/gnu/argp-version-etc.c": {
    "version_etc_hook": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "static void\nversion_etc_hook (FILE *stream, struct argp_state *state)\n{\n  version_etc_ar (stream, program_canonical_name, PACKAGE_NAME, VERSION,\n                  program_authors);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argp_version_setup": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\nargp_version_setup (const char *name, const char * const *authors)\n{\n  argp_program_version_hook = version_etc_hook;\n  program_canonical_name = name;\n  program_authors = authors;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/argp-version-etc.h": {},
  "cflow/cflow-1.5/gnu/argp-xinl.c": {},
  "cflow/cflow-1.5/gnu/argp.h": {
    "__argp_usage": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        621,
        1
      ],
      "content": "ARGP_EI void\n__argp_usage (const struct argp_state *__state)\n{\n  __argp_state_help (__state, stderr, ARGP_HELP_STD_USAGE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "ARGP_EI",
        "void",
        "void"
      ]
    },
    "__NTH": [
      {
        "start_point": [
          623,
          0
        ],
        "end_point": [
          633,
          1
        ],
        "content": "ARGP_EI int\n__NTH (__option_is_short (const struct argp_option *__opt))\n{\n  if (__opt->flags & OPTION_DOC)\n    return 0;\n  else\n    {\n      int __key = __opt->key;\n      return __key > 0 && __key <= UCHAR_MAX && isprint (__key);\n    }\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "ARGP_EI",
          "int",
          "int"
        ]
      },
      {
        "start_point": [
          635,
          0
        ],
        "end_point": [
          639,
          1
        ],
        "content": "ARGP_EI int\n__NTH (__option_is_end (const struct argp_option *__opt))\n{\n  return !__opt->key && !__opt->name && !__opt->doc && !__opt->group;\n}",
        "lines": 5,
        "depth": 9,
        "decorators": [
          "ARGP_EI",
          "int",
          "int"
        ]
      }
    ]
  },
  "cflow/cflow-1.5/gnu/asnprintf.c": {
    "asnprintf": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "char",
        "*\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/bitrotate.c": {},
  "cflow/cflow-1.5/gnu/bitrotate.h": {
    "uint64_t": [
      {
        "start_point": [
          39,
          0
        ],
        "end_point": [
          43,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotl64 (uint64_t x, int n)\n{\n  return ((x << n) | (x >> (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          48,
          0
        ],
        "end_point": [
          52,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotr64 (uint64_t x, int n)\n{\n  return ((x >> n) | (x << (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint32_t": [
      {
        "start_point": [
          58,
          0
        ],
        "end_point": [
          62,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotl32 (uint32_t x, int n)\n{\n  return ((x << n) | (x >> (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          67,
          0
        ],
        "end_point": [
          71,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotr32 (uint32_t x, int n)\n{\n  return ((x >> n) | (x << (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "rotl_sz": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotl_sz (size_t x, int n)\n{\n  return ((x << n) | (x >> ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "rotr_sz": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotr_sz (size_t x, int n)\n{\n  return ((x >> n) | (x << ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "uint16_t": [
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          100,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotl16 (uint16_t x, int n)\n{\n  return ((x << n) | (x >> (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          107,
          0
        ],
        "end_point": [
          111,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotr16 (uint16_t x, int n)\n{\n  return ((x >> n) | (x << (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint8_t": [
      {
        "start_point": [
          118,
          0
        ],
        "end_point": [
          122,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotl8 (uint8_t x, int n)\n{\n  return ((x << n) | (x >> (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          129,
          0
        ],
        "end_point": [
          133,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotr8 (uint8_t x, int n)\n{\n  return ((x >> n) | (x << (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ]
  },
  "cflow/cflow-1.5/gnu/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/dirname.h": {},
  "cflow/cflow-1.5/gnu/dosname.h": {},
  "cflow/cflow-1.5/gnu/errno.in.h": {},
  "cflow/cflow-1.5/gnu/error.c": {
    "is_open": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if defined HAVE_STRERROR_R || _LIBC\n  char errbuf[1024];\n# if STRERROR_R_CHAR_P || _LIBC\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        200,
        42
      ],
      "end_point": [
        283,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n# define ALLOCA_LIMIT 2000\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n  va_end (args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 84,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || strcmp (old_file_name, file_name) == 0))\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%d: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%d: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/error.h": {},
  "cflow/cflow-1.5/gnu/exitfail.c": {},
  "cflow/cflow-1.5/gnu/exitfail.h": {},
  "cflow/cflow-1.5/gnu/float+.h": {},
  "cflow/cflow-1.5/gnu/float.c": {},
  "cflow/cflow-1.5/gnu/float.in.h": {},
  "cflow/cflow-1.5/gnu/getopt.c": {
    "exchange": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the '__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             d->__nonoption_flags_max_len),\n                  '\\0', top + 1 - d->__nonoption_flags_max_len);\n          d->__nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct || !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\\0')\n            d->__nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = d->__nonoption_flags_max_len = strlen (orig_str);\n              if (d->__nonoption_flags_max_len < argc)\n                d->__nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (d->__nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                d->__nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\\0', d->__nonoption_flags_max_len - len);\n            }\n        }\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        1126,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n                    const struct option *longopts, int *longind,\n                    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n        d->optind = 1;  /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n                                      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n                      || (d->optind < d->__nonoption_flags_len                \\\n                          && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n        d->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n        d->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__last_nonopt != d->optind)\n            d->__first_nonopt = d->optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (d->optind < argc && NONOPTION_P)\n            d->optind++;\n          d->__last_nonopt = d->optind;\n        }\n\n      /* The special ARGV-element '--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n        {\n          d->optind++;\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__first_nonopt == d->__last_nonopt)\n            d->__first_nonopt = d->optind;\n          d->__last_nonopt = argc;\n\n          d->optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (d->__first_nonopt != d->__last_nonopt)\n            d->optind = d->__first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (d->__ordering == REQUIRE_ORDER)\n            return -1;\n          d->optarg = argv[d->optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n                  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n          || (long_only && (argv[d->optind][2]\n                            || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n        const struct option *p;\n        struct option_list *next;\n      } *ambig_list = NULL;\n      int exact = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, d->__nextchar, namelen))\n          {\n            if (namelen == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              {\n                /* Second or later nonexact match found.  */\n                struct option_list *newp = malloc (sizeof (*newp));\n                newp->p = p;\n                newp->next = ambig_list;\n                ambig_list = newp;\n              }\n          }\n\n      if (ambig_list != NULL && !exact)\n        {\n          if (print_errors)\n            {\n              struct option_list first;\n              first.p = pfound;\n              first.next = ambig_list;\n              ambig_list = &first;\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf = NULL;\n              size_t buflen = 0;\n\n              FILE *fp = open_memstream (&buf, &buflen);\n              if (fp != NULL)\n                {\n                  fprintf (fp,\n                           _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                           argv[0], argv[d->optind]);\n\n                  do\n                    {\n                      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n                      ambig_list = ambig_list->next;\n                    }\n                  while (ambig_list != NULL);\n\n                  fputc_unlocked ('\\n', fp);\n\n                  if (__builtin_expect (fclose (fp) != EOF, 1))\n                    {\n                      _IO_flockfile (stderr);\n\n                      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                      __fxprintf (NULL, \"%s\", buf);\n\n                      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                      _IO_funlockfile (stderr);\n\n                      free (buf);\n                    }\n                }\n#else\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                       argv[0], argv[d->optind]);\n              do\n                {\n                  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n                  ambig_list = ambig_list->next;\n                }\n              while (ambig_list != NULL);\n\n              fputc ('\\n', stderr);\n#endif\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n\n      while (ambig_list != NULL)\n        {\n          struct option_list *pn = ambig_list->next;\n          free (ambig_list);\n          ambig_list = pn;\n        }\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          d->optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                d->optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n                      int n;\n#endif\n\n                      if (argv[d->optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                          argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                          argv[0], argv[d->optind - 1][0],\n                                          pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                   argv[0], argv[d->optind - 1][0],\n                                   pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (n >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#endif\n                    }\n\n                  d->__nextchar += strlen (d->__nextchar);\n\n                  d->optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (d->optind < argc)\n                d->optarg = argv[d->optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n                                      argv[0], pfound->name) >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#else\n                      fprintf (stderr,\n                               _(\"%s: option '--%s' requires an argument\\n\"),\n                               argv[0], pfound->name);\n#endif\n                    }\n                  d->__nextchar += strlen (d->__nextchar);\n                  d->optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n          || strchr (optstring, *d->__nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n              if (argv[d->optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n                                  argv[0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n                           argv[0], d->__nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n                                  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n                           argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (n >= 0)\n                {\n                  _IO_flockfile (stderr);\n\n                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                  __fxprintf (NULL, \"%s\", buf);\n\n                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                  _IO_funlockfile (stderr);\n\n                  free (buf);\n                }\n#endif\n            }\n          d->__nextchar = (char *) \"\";\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n                              argv[0], c);\n#else\n              fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (n >= 0)\n              {\n                _IO_flockfile (stderr);\n\n                int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                __fxprintf (NULL, \"%s\", buf);\n\n                ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                _IO_funlockfile (stderr);\n\n                free (buf);\n              }\n#endif\n          }\n        d->optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        if (longopts == NULL)\n          goto no_longs;\n\n        /* This is an option that requires an argument.  */\n        if (*d->__nextchar != '\\0')\n          {\n            d->optarg = d->__nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            d->optind++;\n          }\n        else if (d->optind == argc)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf,\n                                _(\"%s: option requires an argument -- '%c'\\n\"),\n                                argv[0], c) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr,\n                         _(\"%s: option requires an argument -- '%c'\\n\"),\n                         argv[0], c);\n#endif\n              }\n            d->optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented 'd->optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          d->optarg = argv[d->optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n             nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n            {\n              if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else if (long_only\n                       || pfound->has_arg != p->has_arg\n                       || pfound->flag != p->flag\n                       || pfound->val != p->val)\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                                argv[0], d->optarg) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                         argv[0], d->optarg);\n#endif\n              }\n            d->__nextchar += strlen (d->__nextchar);\n            d->optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  d->optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    d->__nextchar += strlen (d->__nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (d->optind < argc)\n                  d->optarg = argv[d->optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n                    d->__nextchar += strlen (d->__nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar += strlen (d->__nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n\n      no_longs:\n        d->__nextchar = NULL;\n        return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                d->optind++;\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                d->optind++;\n              }\n            else if (d->optind == argc)\n              {\n                if (print_errors)\n                  {\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n                                    argv[0], c) >= 0)\n                      {\n                        _IO_flockfile (stderr);\n\n                        int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                        ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                        __fxprintf (NULL, \"%s\", buf);\n\n                        ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                        _IO_funlockfile (stderr);\n\n                        free (buf);\n                      }\n#else\n                    fprintf (stderr,\n                             _(\"%s: option requires an argument -- '%c'\\n\"),\n                             argv[0], c);\n#endif\n                  }\n                d->optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented 'optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              d->optarg = argv[d->optind++];\n            d->__nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}",
      "lines": 781,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1128,
        0
      ],
      "end_point": [
        1147,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n                  const struct option *longopts, int *longind, int long_only,\n                  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n                               longind, long_only, &getopt_data,\n                               posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1157,
        0
      ],
      "end_point": [
        1164,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, (char **) argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, POSIXLY_CORRECT);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1167,
        0
      ],
      "end_point": [
        1174,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1183,
        0
      ],
      "end_point": [
        1244,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/getopt.in.h": {},
  "cflow/cflow-1.5/gnu/getopt1.c": {
    "getopt_long": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n             const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n                const struct option *long_options, int *opt_index,\n                struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n                  const char *options,\n                  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n                     const struct option *long_options, int *opt_index,\n                     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n        {\"add\", 1, 0, 0},\n        {\"append\", 0, 0, 0},\n        {\"delete\", 1, 0, 0},\n        {\"verbose\", 0, 0, 0},\n        {\"create\", 0, 0, 0},\n        {\"file\", 1, 0, 0},\n        {0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n                       long_options, &option_index);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 0:\n          printf (\"option %s\", long_options[option_index].name);\n          if (optarg)\n            printf (\" with arg %s\", optarg);\n          printf (\"\\n\");\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case 'd':\n          printf (\"option d with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/getopt_int.h": {},
  "cflow/cflow-1.5/gnu/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (translation != msg_ctxt_id)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (!(translation == msg_ctxt_id || translation == msgid_plural))\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/gettimeofday.c": {
    "rpl_localtime": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_tzset": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void\nrpl_tzset (void)\n{\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to tzset.  */\n  struct tm save = *localtime_buffer_addr;\n  tzset ();\n  *localtime_buffer_addr = save;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#if HAVE_GETTIMEOFDAY\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n# endif\n\n# if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#  undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n# else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n# endif\n\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n# endif\n\n  return result;\n\n#else\n\n# if HAVE__FTIME\n\n  struct _timeb timebuf;\n  _ftime (&timebuf);\n  tv->tv_sec = timebuf.time;\n  tv->tv_usec = timebuf.millitm * 1000;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n# endif\n\n  return 0;\n\n#endif\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/hash.c": {
    "hash_get_n_buckets": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "size_t\nhash_get_n_buckets (const Hash_table *table)\n{\n  return table->n_buckets;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_buckets_used": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "size_t\nhash_get_n_buckets_used (const Hash_table *table)\n{\n  return table->n_buckets_used;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_entries": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "size_t\nhash_get_n_entries (const Hash_table *table)\n{\n  return table->n_entries;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_max_bucket_length": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "size_t\nhash_get_max_bucket_length (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t max_bucket_length = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n          size_t bucket_length = 1;\n\n          while (cursor = cursor->next, cursor)\n            bucket_length++;\n\n          if (bucket_length > max_bucket_length)\n            max_bucket_length = bucket_length;\n        }\n    }\n\n  return max_bucket_length;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "hash_table_ok": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "bool\nhash_table_ok (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t n_buckets_used = 0;\n  size_t n_entries = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n\n          /* Count bucket head.  */\n          n_buckets_used++;\n          n_entries++;\n\n          /* Count bucket overflow.  */\n          while (cursor = cursor->next, cursor)\n            n_entries++;\n        }\n    }\n\n  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)\n    return true;\n\n  return false;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "hash_print_statistics": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "void\nhash_print_statistics (const Hash_table *table, FILE *stream)\n{\n  size_t n_entries = hash_get_n_entries (table);\n  size_t n_buckets = hash_get_n_buckets (table);\n  size_t n_buckets_used = hash_get_n_buckets_used (table);\n  size_t max_bucket_length = hash_get_max_bucket_length (table);\n\n  fprintf (stream, \"# entries:         %lu\\n\", (unsigned long int) n_entries);\n  fprintf (stream, \"# buckets:         %lu\\n\", (unsigned long int) n_buckets);\n  fprintf (stream, \"# buckets used:    %lu (%.2f%%)\\n\",\n           (unsigned long int) n_buckets_used,\n           (100.0 * n_buckets_used) / n_buckets);\n  fprintf (stream, \"max bucket length: %lu\\n\",\n           (unsigned long int) max_bucket_length);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "safe_hasher": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "static struct hash_entry *\nsafe_hasher (const Hash_table *table, const void *key)\n{\n  size_t n = table->hasher (key, table->n_buckets);\n  if (! (n < table->n_buckets))\n    abort ();\n  return table->bucket + n;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nsafe_hasher (const Hash_table *table, const void *key)",
        "*"
      ]
    },
    "hash_lookup": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "void *\nhash_lookup (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  if (bucket->data == NULL)\n    return NULL;\n\n  for (cursor = bucket; cursor; cursor = cursor->next)\n    if (entry == cursor->data || table->comparator (entry, cursor->data))\n      return cursor->data;\n\n  return NULL;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_lookup (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_first": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "void *\nhash_get_first (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n\n  if (table->n_entries == 0)\n    return NULL;\n\n  for (bucket = table->bucket; ; bucket++)\n    if (! (bucket < table->bucket_limit))\n      abort ();\n    else if (bucket->data)\n      return bucket->data;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_first (const Hash_table *table)",
        "*"
      ]
    },
    "hash_get_next": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "void *\nhash_get_next (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  /* Find next entry in the same bucket.  */\n  cursor = bucket;\n  do\n    {\n      if (cursor->data == entry && cursor->next)\n        return cursor->next->data;\n      cursor = cursor->next;\n    }\n  while (cursor != NULL);\n\n  /* Find first entry in any subsequent bucket.  */\n  while (++bucket < table->bucket_limit)\n    if (bucket->data)\n      return bucket->data;\n\n  /* None found.  */\n  return NULL;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_next (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_entries": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "size_t\nhash_get_entries (const Hash_table *table, void **buffer,\n                  size_t buffer_size)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (counter >= buffer_size)\n                return counter;\n              buffer[counter++] = cursor->data;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    },
    "hash_do_for_each": {
      "start_point": [
        368,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "size_t\nhash_do_for_each (const Hash_table *table, Hash_processor processor,\n                  void *processor_data)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (! processor (cursor->data, processor_data))\n                return counter;\n              counter++;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "hash_string": [
      {
        "start_point": [
          405,
          0
        ],
        "end_point": [
          419,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n# define HASH_ONE_CHAR(Value, Byte) \\\n  ((Byte) + rotl_sz (Value, 7))\n\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = HASH_ONE_CHAR (value, ch);\n  return value % n_buckets;\n\n# undef HASH_ONE_CHAR\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "size_t"
        ]
      },
      {
        "start_point": [
          428,
          0
        ],
        "end_point": [
          437,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = (value * 31 + ch) % n_buckets;\n  return value;\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "size_t"
        ]
      }
    ],
    "_GL_ATTRIBUTE_CONST": [
      {
        "start_point": [
          444,
          0
        ],
        "end_point": [
          458,
          1
        ],
        "content": "static bool _GL_ATTRIBUTE_CONST\nis_prime (size_t candidate)\n{\n  size_t divisor = 3;\n  size_t square = divisor * divisor;\n\n  while (square < candidate && (candidate % divisor))\n    {\n      divisor++;\n      square += 4 * divisor;\n      divisor++;\n    }\n\n  return (candidate % divisor ? true : false);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          463,
          0
        ],
        "end_point": [
          477,
          1
        ],
        "content": "static size_t _GL_ATTRIBUTE_CONST\nnext_prime (size_t candidate)\n{\n  /* Skip small primes.  */\n  if (candidate < 10)\n    candidate = 10;\n\n  /* Make it definitely odd.  */\n  candidate |= 1;\n\n  while (SIZE_MAX != candidate && !is_prime (candidate))\n    candidate += 2;\n\n  return candidate;\n}",
        "lines": 15,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "size_t"
        ]
      }
    ],
    "hash_reset_tuning": {
      "start_point": [
        479,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "void\nhash_reset_tuning (Hash_tuning *tuning)\n{\n  *tuning = default_tuning;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "raw_hasher": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        496,
        1
      ],
      "content": "static size_t\nraw_hasher (const void *data, size_t n)\n{\n  /* When hashing unique pointers, it is often the case that they were\n     generated by malloc and thus have the property that the low-order\n     bits are 0.  As this tends to give poorer performance with small\n     tables, we rotate the pointer value before performing division,\n     in an attempt to improve hash quality.  */\n  size_t val = rotr_sz ((size_t) data, 3);\n  return val % n;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "raw_comparator": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "static bool\nraw_comparator (const void *a, const void *b)\n{\n  return a == b;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_tuning": {
      "start_point": [
        512,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "static bool\ncheck_tuning (Hash_table *table)\n{\n  const Hash_tuning *tuning = table->tuning;\n  float epsilon;\n  if (tuning == &default_tuning)\n    return true;\n\n  /* Be a bit stricter than mathematics would require, so that\n     rounding errors in size calculations do not cause allocations to\n     fail to grow or shrink as they should.  The smallest allocation\n     is 11 (due to next_prime's algorithm), so an epsilon of 0.1\n     should be good enough.  */\n  epsilon = 0.1f;\n\n  if (epsilon < tuning->growth_threshold\n      && tuning->growth_threshold < 1 - epsilon\n      && 1 + epsilon < tuning->growth_factor\n      && 0 <= tuning->shrink_threshold\n      && tuning->shrink_threshold + epsilon < tuning->shrink_factor\n      && tuning->shrink_factor <= 1\n      && tuning->shrink_threshold + epsilon < tuning->growth_threshold)\n    return true;\n\n  table->tuning = &default_tuning;\n  return false;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "compute_bucket_size": {
      "start_point": [
        544,
        0
      ],
      "end_point": [
        558,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\ncompute_bucket_size (size_t candidate, const Hash_tuning *tuning)\n{\n  if (!tuning->is_n_buckets)\n    {\n      float new_candidate = candidate / tuning->growth_threshold;\n      if (SIZE_MAX <= new_candidate)\n        return 0;\n      candidate = new_candidate;\n    }\n  candidate = next_prime (candidate);\n  if (xalloc_oversized (candidate, sizeof (struct hash_entry *)))\n    return 0;\n  return candidate;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "hash_initialize": {
      "start_point": [
        594,
        0
      ],
      "end_point": [
        647,
        1
      ],
      "content": "Hash_table *\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)\n{\n  Hash_table *table;\n\n  if (hasher == NULL)\n    hasher = raw_hasher;\n  if (comparator == NULL)\n    comparator = raw_comparator;\n\n  table = malloc (sizeof *table);\n  if (table == NULL)\n    return NULL;\n\n  if (!tuning)\n    tuning = &default_tuning;\n  table->tuning = tuning;\n  if (!check_tuning (table))\n    {\n      /* Fail if the tuning options are invalid.  This is the only occasion\n         when the user gets some feedback about it.  Once the table is created,\n         if the user provides invalid tuning options, we silently revert to\n         using the defaults, and ignore further request to change the tuning\n         options.  */\n      goto fail;\n    }\n\n  table->n_buckets = compute_bucket_size (candidate, tuning);\n  if (!table->n_buckets)\n    goto fail;\n\n  table->bucket = calloc (table->n_buckets, sizeof *table->bucket);\n  if (table->bucket == NULL)\n    goto fail;\n  table->bucket_limit = table->bucket + table->n_buckets;\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n\n  table->hasher = hasher;\n  table->comparator = comparator;\n  table->data_freer = data_freer;\n\n  table->free_entry_list = NULL;\n#if USE_OBSTACK\n  obstack_init (&table->entry_stack);\n#endif\n  return table;\n\n fail:\n  free (table);\n  return NULL;\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "Hash_table",
        "*\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)",
        "*"
      ]
    },
    "hash_clear": {
      "start_point": [
        653,
        0
      ],
      "end_point": [
        689,
        1
      ],
      "content": "void\nhash_clear (Hash_table *table)\n{\n  struct hash_entry *bucket;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry *cursor;\n          struct hash_entry *next;\n\n          /* Free the bucket overflow.  */\n          for (cursor = bucket->next; cursor; cursor = next)\n            {\n              if (table->data_freer)\n                table->data_freer (cursor->data);\n              cursor->data = NULL;\n\n              next = cursor->next;\n              /* Relinking is done one entry at a time, as it is to be expected\n                 that overflows are either rare or short.  */\n              cursor->next = table->free_entry_list;\n              table->free_entry_list = cursor;\n            }\n\n          /* Free the bucket head.  */\n          if (table->data_freer)\n            table->data_freer (bucket->data);\n          bucket->data = NULL;\n          bucket->next = NULL;\n        }\n    }\n\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "hash_free": {
      "start_point": [
        696,
        0
      ],
      "end_point": [
        744,
        1
      ],
      "content": "void\nhash_free (Hash_table *table)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n\n  /* Call the user data_freer function.  */\n  if (table->data_freer && table->n_entries)\n    {\n      for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n        {\n          if (bucket->data)\n            {\n              for (cursor = bucket; cursor; cursor = cursor->next)\n                table->data_freer (cursor->data);\n            }\n        }\n    }\n\n#if USE_OBSTACK\n\n  obstack_free (&table->entry_stack, NULL);\n\n#else\n\n  /* Free all bucket overflowed entries.  */\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      for (cursor = bucket->next; cursor; cursor = next)\n        {\n          next = cursor->next;\n          free (cursor);\n        }\n    }\n\n  /* Also reclaim the internal list of previously freed entries.  */\n  for (cursor = table->free_entry_list; cursor; cursor = next)\n    {\n      next = cursor->next;\n      free (cursor);\n    }\n\n#endif\n\n  /* Free the remainder of the hash table structure.  */\n  free (table->bucket);\n  free (table);\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "allocate_entry": {
      "start_point": [
        751,
        0
      ],
      "end_point": [
        771,
        1
      ],
      "content": "static struct hash_entry *\nallocate_entry (Hash_table *table)\n{\n  struct hash_entry *new;\n\n  if (table->free_entry_list)\n    {\n      new = table->free_entry_list;\n      table->free_entry_list = new->next;\n    }\n  else\n    {\n#if USE_OBSTACK\n      new = obstack_alloc (&table->entry_stack, sizeof *new);\n#else\n      new = malloc (sizeof *new);\n#endif\n    }\n\n  return new;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nallocate_entry (Hash_table *table)",
        "*"
      ]
    },
    "free_entry": {
      "start_point": [
        776,
        0
      ],
      "end_point": [
        782,
        1
      ],
      "content": "static void\nfree_entry (Hash_table *table, struct hash_entry *entry)\n{\n  entry->data = NULL;\n  entry->next = table->free_entry_list;\n  table->free_entry_list = entry;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hash_find_entry": {
      "start_point": [
        790,
        0
      ],
      "end_point": [
        852,
        1
      ],
      "content": "static void *\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)\n{\n  struct hash_entry *bucket = safe_hasher (table, entry);\n  struct hash_entry *cursor;\n\n  *bucket_head = bucket;\n\n  /* Test for empty bucket.  */\n  if (bucket->data == NULL)\n    return NULL;\n\n  /* See if the entry is the first in the bucket.  */\n  if (entry == bucket->data || table->comparator (entry, bucket->data))\n    {\n      void *data = bucket->data;\n\n      if (delete)\n        {\n          if (bucket->next)\n            {\n              struct hash_entry *next = bucket->next;\n\n              /* Bump the first overflow entry into the bucket head, then save\n                 the previous first overflow entry for later recycling.  */\n              *bucket = *next;\n              free_entry (table, next);\n            }\n          else\n            {\n              bucket->data = NULL;\n            }\n        }\n\n      return data;\n    }\n\n  /* Scan the bucket overflow.  */\n  for (cursor = bucket; cursor->next; cursor = cursor->next)\n    {\n      if (entry == cursor->next->data\n          || table->comparator (entry, cursor->next->data))\n        {\n          void *data = cursor->next->data;\n\n          if (delete)\n            {\n              struct hash_entry *next = cursor->next;\n\n              /* Unlink the entry to delete, then save the freed entry for later\n                 recycling.  */\n              cursor->next = next->next;\n              free_entry (table, next);\n            }\n\n          return data;\n        }\n    }\n\n  /* No entry found.  */\n  return NULL;\n}",
      "lines": 63,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)",
        "*"
      ]
    },
    "transfer_entries": {
      "start_point": [
        860,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "static bool\ntransfer_entries (Hash_table *dst, Hash_table *src, bool safe)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n  for (bucket = src->bucket; bucket < src->bucket_limit; bucket++)\n    if (bucket->data)\n      {\n        void *data;\n        struct hash_entry *new_bucket;\n\n        /* Within each bucket, transfer overflow entries first and\n           then the bucket head, to minimize memory pressure.  After\n           all, the only time we might allocate is when moving the\n           bucket head, but moving overflow entries first may create\n           free entries that can be recycled by the time we finally\n           get to the bucket head.  */\n        for (cursor = bucket->next; cursor; cursor = next)\n          {\n            data = cursor->data;\n            new_bucket = safe_hasher (dst, data);\n\n            next = cursor->next;\n\n            if (new_bucket->data)\n              {\n                /* Merely relink an existing entry, when moving from a\n                   bucket overflow into a bucket overflow.  */\n                cursor->next = new_bucket->next;\n                new_bucket->next = cursor;\n              }\n            else\n              {\n                /* Free an existing entry, when moving from a bucket\n                   overflow into a bucket header.  */\n                new_bucket->data = data;\n                dst->n_buckets_used++;\n                free_entry (dst, cursor);\n              }\n          }\n        /* Now move the bucket head.  Be sure that if we fail due to\n           allocation failure that the src table is in a consistent\n           state.  */\n        data = bucket->data;\n        bucket->next = NULL;\n        if (safe)\n          continue;\n        new_bucket = safe_hasher (dst, data);\n\n        if (new_bucket->data)\n          {\n            /* Allocate or recycle an entry, when moving from a bucket\n               header into a bucket overflow.  */\n            struct hash_entry *new_entry = allocate_entry (dst);\n\n            if (new_entry == NULL)\n              return false;\n\n            new_entry->data = data;\n            new_entry->next = new_bucket->next;\n            new_bucket->next = new_entry;\n          }\n        else\n          {\n            /* Move from one bucket header to another.  */\n            new_bucket->data = data;\n            dst->n_buckets_used++;\n          }\n        bucket->data = NULL;\n        src->n_buckets_used--;\n      }\n  return true;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "hash_rehash": {
      "start_point": [
        943,
        0
      ],
      "end_point": [
        1020,
        1
      ],
      "content": "bool\nhash_rehash (Hash_table *table, size_t candidate)\n{\n  Hash_table storage;\n  Hash_table *new_table;\n  size_t new_size = compute_bucket_size (candidate, table->tuning);\n\n  if (!new_size)\n    return false;\n  if (new_size == table->n_buckets)\n    return true;\n  new_table = &storage;\n  new_table->bucket = calloc (new_size, sizeof *new_table->bucket);\n  if (new_table->bucket == NULL)\n    return false;\n  new_table->n_buckets = new_size;\n  new_table->bucket_limit = new_table->bucket + new_size;\n  new_table->n_buckets_used = 0;\n  new_table->n_entries = 0;\n  new_table->tuning = table->tuning;\n  new_table->hasher = table->hasher;\n  new_table->comparator = table->comparator;\n  new_table->data_freer = table->data_freer;\n\n  /* In order for the transfer to successfully complete, we need\n     additional overflow entries when distinct buckets in the old\n     table collide into a common bucket in the new table.  The worst\n     case possible is a hasher that gives a good spread with the old\n     size, but returns a constant with the new size; if we were to\n     guarantee table->n_buckets_used-1 free entries in advance, then\n     the transfer would be guaranteed to not allocate memory.\n     However, for large tables, a guarantee of no further allocation\n     introduces a lot of extra memory pressure, all for an unlikely\n     corner case (most rehashes reduce, rather than increase, the\n     number of overflow entries needed).  So, we instead ensure that\n     the transfer process can be reversed if we hit a memory\n     allocation failure mid-transfer.  */\n\n  /* Merely reuse the extra old space into the new table.  */\n#if USE_OBSTACK\n  new_table->entry_stack = table->entry_stack;\n#endif\n  new_table->free_entry_list = table->free_entry_list;\n\n  if (transfer_entries (new_table, table, false))\n    {\n      /* Entries transferred successfully; tie up the loose ends.  */\n      free (table->bucket);\n      table->bucket = new_table->bucket;\n      table->bucket_limit = new_table->bucket_limit;\n      table->n_buckets = new_table->n_buckets;\n      table->n_buckets_used = new_table->n_buckets_used;\n      table->free_entry_list = new_table->free_entry_list;\n      /* table->n_entries and table->entry_stack already hold their value.  */\n      return true;\n    }\n\n  /* We've allocated new_table->bucket (and possibly some entries),\n     exhausted the free list, and moved some but not all entries into\n     new_table.  We must undo the partial move before returning\n     failure.  The only way to get into this situation is if new_table\n     uses fewer buckets than the old table, so we will reclaim some\n     free entries as overflows in the new table are put back into\n     distinct buckets in the old table.\n\n     There are some pathological cases where a single pass through the\n     table requires more intermediate overflow entries than using two\n     passes.  Two passes give worse cache performance and takes\n     longer, but at this point, we're already out of memory, so slow\n     and safe is better than failure.  */\n  table->free_entry_list = new_table->free_entry_list;\n  if (! (transfer_entries (table, new_table, true)\n         && transfer_entries (table, new_table, false)))\n    abort ();\n  /* table->n_entries already holds its value.  */\n  free (new_table->bucket);\n  return false;\n}",
      "lines": 78,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "hash_insert_if_absent": {
      "start_point": [
        1038,
        0
      ],
      "end_point": [
        1118,
        1
      ],
      "content": "int\nhash_insert_if_absent (Hash_table *table, void const *entry,\n                       void const **matched_ent)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  /* The caller cannot insert a NULL entry, since hash_lookup returns NULL\n     to indicate \"not found\", and hash_find_entry uses \"bucket->data == NULL\"\n     to indicate an empty bucket.  */\n  if (! entry)\n    abort ();\n\n  /* If there's a matching entry already in the table, return that.  */\n  if ((data = hash_find_entry (table, entry, &bucket, false)) != NULL)\n    {\n      if (matched_ent)\n        *matched_ent = data;\n      return 0;\n    }\n\n  /* If the growth threshold of the buckets in use has been reached, increase\n     the table size and rehash.  There's no point in checking the number of\n     entries:  if the hashing function is ill-conditioned, rehashing is not\n     likely to improve it.  */\n\n  if (table->n_buckets_used\n      > table->tuning->growth_threshold * table->n_buckets)\n    {\n      /* Check more fully, before starting real work.  If tuning arguments\n         became invalid, the second check will rely on proper defaults.  */\n      check_tuning (table);\n      if (table->n_buckets_used\n          > table->tuning->growth_threshold * table->n_buckets)\n        {\n          const Hash_tuning *tuning = table->tuning;\n          float candidate =\n            (tuning->is_n_buckets\n             ? (table->n_buckets * tuning->growth_factor)\n             : (table->n_buckets * tuning->growth_factor\n                * tuning->growth_threshold));\n\n          if (SIZE_MAX <= candidate)\n            return -1;\n\n          /* If the rehash fails, arrange to return NULL.  */\n          if (!hash_rehash (table, candidate))\n            return -1;\n\n          /* Update the bucket we are interested in.  */\n          if (hash_find_entry (table, entry, &bucket, false) != NULL)\n            abort ();\n        }\n    }\n\n  /* ENTRY is not matched, it should be inserted.  */\n\n  if (bucket->data)\n    {\n      struct hash_entry *new_entry = allocate_entry (table);\n\n      if (new_entry == NULL)\n        return -1;\n\n      /* Add ENTRY in the overflow of the bucket.  */\n\n      new_entry->data = (void *) entry;\n      new_entry->next = bucket->next;\n      bucket->next = new_entry;\n      table->n_entries++;\n      return 1;\n    }\n\n  /* Add ENTRY right in the bucket head.  */\n\n  bucket->data = (void *) entry;\n  table->n_entries++;\n  table->n_buckets_used++;\n\n  return 1;\n}",
      "lines": 81,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "hash_insert0": {
      "start_point": [
        1122,
        0
      ],
      "end_point": [
        1126,
        1
      ],
      "content": "int\nhash_insert0 (Hash_table *table, void const *entry, void const **matched_ent)\n{\n  return hash_insert_if_absent (table, entry, matched_ent);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "hash_insert": {
      "start_point": [
        1134,
        0
      ],
      "end_point": [
        1142,
        1
      ],
      "content": "void *\nhash_insert (Hash_table *table, void const *entry)\n{\n  void const *matched_ent;\n  int err = hash_insert_if_absent (table, entry, &matched_ent);\n  return (err == -1\n          ? NULL\n          : (void *) (err == 0 ? matched_ent : entry));\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_insert (Hash_table *table, void const *entry)",
        "*"
      ]
    },
    "hash_delete": {
      "start_point": [
        1148,
        0
      ],
      "end_point": [
        1206,
        1
      ],
      "content": "void *\nhash_delete (Hash_table *table, const void *entry)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  data = hash_find_entry (table, entry, &bucket, true);\n  if (!data)\n    return NULL;\n\n  table->n_entries--;\n  if (!bucket->data)\n    {\n      table->n_buckets_used--;\n\n      /* If the shrink threshold of the buckets in use has been reached,\n         rehash into a smaller table.  */\n\n      if (table->n_buckets_used\n          < table->tuning->shrink_threshold * table->n_buckets)\n        {\n          /* Check more fully, before starting real work.  If tuning arguments\n             became invalid, the second check will rely on proper defaults.  */\n          check_tuning (table);\n          if (table->n_buckets_used\n              < table->tuning->shrink_threshold * table->n_buckets)\n            {\n              const Hash_tuning *tuning = table->tuning;\n              size_t candidate =\n                (tuning->is_n_buckets\n                 ? table->n_buckets * tuning->shrink_factor\n                 : (table->n_buckets * tuning->shrink_factor\n                    * tuning->growth_threshold));\n\n              if (!hash_rehash (table, candidate))\n                {\n                  /* Failure to allocate memory in an attempt to\n                     shrink the table is not fatal.  But since memory\n                     is low, we can at least be kind and free any\n                     spare entries, rather than keeping them tied up\n                     in the free entry list.  */\n#if ! USE_OBSTACK\n                  struct hash_entry *cursor = table->free_entry_list;\n                  struct hash_entry *next;\n                  while (cursor)\n                    {\n                      next = cursor->next;\n                      free (cursor);\n                      cursor = next;\n                    }\n                  table->free_entry_list = NULL;\n#endif\n                }\n            }\n        }\n    }\n\n  return data;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "void",
        "*\nhash_delete (Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_print": {
      "start_point": [
        1212,
        0
      ],
      "end_point": [
        1232,
        1
      ],
      "content": "void\nhash_print (const Hash_table *table)\n{\n  struct hash_entry *bucket = (struct hash_entry *) table->bucket;\n\n  for ( ; bucket < table->bucket_limit; bucket++)\n    {\n      struct hash_entry *cursor;\n\n      if (bucket)\n        printf (\"%lu:\\n\", (unsigned long int) (bucket - table->bucket));\n\n      for (cursor = bucket; cursor; cursor = cursor->next)\n        {\n          char const *s = cursor->data;\n          /* FIXME */\n          if (s)\n            printf (\"  %s\\n\", s);\n        }\n    }\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/hash.h": {},
  "cflow/cflow-1.5/gnu/intprops.h": {},
  "cflow/cflow-1.5/gnu/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/lstat.c": {
    "orig_lstat": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  size_t len;\n  int lstat_result = orig_lstat (file, sbuf);\n\n  if (lstat_result != 0)\n    return lstat_result;\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  len = strlen (file);\n  if (file[len - 1] != '/' || S_ISDIR (sbuf->st_mode))\n    return 0;\n\n  /* At this point, a trailing slash is only permitted on\n     symlink-to-dir; but it should have found information on the\n     directory, not the symlink.  Call stat() to get info about the\n     link's referent.  Our replacement stat guarantees valid results,\n     even if the symlink is not pointing to a directory.  */\n  if (!S_ISLNK (sbuf->st_mode))\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return stat (file, sbuf);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/memchr.c": {
    "__memchr": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/mempcpy.c": {
    "mempcpy": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "void *\nmempcpy (void *dest, const void *src, size_t n)\n{\n  return (char *) memcpy (dest, src, n) + n;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nmempcpy (void *dest, const void *src, size_t n)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          32,
          0
        ],
        "end_point": [
          39,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          49,
          0
        ],
        "end_point": [
          57,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          98,
          0
        ],
        "end_point": [
          112,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/msvc-inval.h": {},
  "cflow/cflow-1.5/gnu/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/msvc-nothrow.h": {},
  "cflow/cflow-1.5/gnu/obstack.c": {
    "_obstack_begin": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\n_obstack_begin (struct obstack *h,\n                int size, int alignment,\n                void *(*chunkfun) (long),\n                void (*freefun) (void *))\n{\n  register struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n         Use the values for range checking, because if range checking is off,\n         the extra bytes won't be missed terribly, but if range checking is on\n         and we used a larger request, a whole extra 4096 bytes would be\n         allocated.\n\n         These number are irrelevant to the new GNU malloc.  I suspect it is\n         less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n                    + 4 + DEFAULT_ROUNDING - 1)\n                   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;\n  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n  h->use_extra_arg = 0;\n\n  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n                                               alignment - 1);\n  h->chunk_limit = chunk->limit\n    = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
      "lines": 46,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_obstack_begin_1": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "int\n_obstack_begin_1 (struct obstack *h, int size, int alignment,\n                  void *(*chunkfun) (void *, long),\n                  void (*freefun) (void *, void *),\n                  void *arg)\n{\n  register struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n         Use the values for range checking, because if range checking is off,\n         the extra bytes won't be missed terribly, but if range checking is on\n         and we used a larger request, a whole extra 4096 bytes would be\n         allocated.\n\n         These number are irrelevant to the new GNU malloc.  I suspect it is\n         less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n                    + 4 + DEFAULT_ROUNDING - 1)\n                   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;\n  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n  h->extra_arg = arg;\n  h->use_extra_arg = 1;\n\n  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n                                               alignment - 1);\n  h->chunk_limit = chunk->limit\n    = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
      "lines": 47,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_obstack_newchunk": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "void\n_obstack_newchunk (struct obstack *h, int length)\n{\n  register struct _obstack_chunk *old_chunk = h->chunk;\n  register struct _obstack_chunk *new_chunk;\n  register long new_size;\n  register long obj_size = h->next_free - h->object_base;\n  register long i;\n  long already;\n  char *object_base;\n\n  /* Compute size for new chunk.  */\n  new_size = (obj_size + length) + (obj_size >> 3) + h->alignment_mask + 100;\n  if (new_size < h->chunk_size)\n    new_size = h->chunk_size;\n\n  /* Allocate and initialize the new chunk.  */\n  new_chunk = CALL_CHUNKFUN (h, new_size);\n  if (!new_chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->chunk = new_chunk;\n  new_chunk->prev = old_chunk;\n  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n\n  /* Compute an aligned object_base in the new chunk */\n  object_base =\n    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);\n\n  /* Move the existing object to the new chunk.\n     Word at a time is fast and is safe if the object\n     is sufficiently aligned.  */\n  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)\n    {\n      for (i = obj_size / sizeof (COPYING_UNIT) - 1;\n           i >= 0; i--)\n        ((COPYING_UNIT *)object_base)[i]\n          = ((COPYING_UNIT *)h->object_base)[i];\n      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,\n         but that can cross a page boundary on a machine\n         which does not do strict alignment for COPYING_UNITS.  */\n      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);\n    }\n  else\n    already = 0;\n  /* Copy remaining bytes one by one.  */\n  for (i = already; i < obj_size; i++)\n    object_base[i] = h->object_base[i];\n\n  /* If the object just copied was the only data in OLD_CHUNK,\n     free that chunk and remove it from the chain.\n     But not if that chunk might contain an empty object.  */\n  if (! h->maybe_empty_object\n      && (h->object_base\n          == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,\n                          h->alignment_mask)))\n    {\n      new_chunk->prev = old_chunk->prev;\n      CALL_FREEFUN (h, old_chunk);\n    }\n\n  h->object_base = object_base;\n  h->next_free = h->object_base + obj_size;\n  /* The new chunk certainly contains no empty object yet.  */\n  h->maybe_empty_object = 0;\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_obstack_allocated_p": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "int\n_obstack_allocated_p (struct obstack *h, void *obj)\n{\n  register struct _obstack_chunk *lp;   /* below addr of any objects in this chunk */\n  register struct _obstack_chunk *plp;  /* point to previous chunk if any */\n\n  lp = (h)->chunk;\n  /* We use >= rather than > since the object cannot be exactly at\n     the beginning of the chunk but might be an empty object exactly\n     at the end of an adjacent chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      lp = plp;\n    }\n  return lp != 0;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "__obstack_free": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "void\n__obstack_free (struct obstack *h, void *obj)\n{\n  register struct _obstack_chunk *lp;   /* below addr of any objects in this chunk */\n  register struct _obstack_chunk *plp;  /* point to previous chunk if any */\n\n  lp = h->chunk;\n  /* We use >= because there cannot be an object at the beginning of a chunk.\n     But there can be an empty object at that address\n     at the end of another chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      CALL_FREEFUN (h, lp);\n      lp = plp;\n      /* If we switch chunks, we can't tell whether the new current\n         chunk contains an empty object, so assume that it may.  */\n      h->maybe_empty_object = 1;\n    }\n  if (lp)\n    {\n      h->object_base = h->next_free = (char *) (obj);\n      h->chunk_limit = lp->limit;\n      h->chunk = lp;\n    }\n  else if (obj != 0)\n    /* obj is not in any of the chunks! */\n    abort ();\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_obstack_memory_used": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "int\n_obstack_memory_used (struct obstack *h)\n{\n  register struct _obstack_chunk* lp;\n  register int nbytes = 0;\n\n  for (lp = h->chunk; lp != 0; lp = lp->prev)\n    {\n      nbytes += lp->limit - (char *) lp;\n    }\n  return nbytes;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "print_and_abort": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "static _Noreturn void\nprint_and_abort (void)\n{\n  /* Don't change any of these strings.  Yes, it would be possible to add\n     the newline to the string and use fputs or so.  But this must not\n     happen because the \"memory exhausted\" message appears in other places\n     like this and the translation should be reused instead of creating\n     a very similar string which requires a separate translation.  */\n# ifdef _LIBC\n  (void) __fxprintf (NULL, \"%s\\n\", _(\"memory exhausted\"));\n# else\n  fprintf (stderr, \"%s\\n\", _(\"memory exhausted\"));\n# endif\n  exit (obstack_exit_failure);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/obstack.h": {},
  "cflow/cflow-1.5/gnu/pathmax.h": {},
  "cflow/cflow-1.5/gnu/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/printf-args.h": {},
  "cflow/cflow-1.5/gnu/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        633,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On Mac OS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/printf-parse.h": {},
  "cflow/cflow-1.5/gnu/progname.c": {
    "set_program_name": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/progname.h": {},
  "cflow/cflow-1.5/gnu/rawmemchr.c": {
    "rawmemchr": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void *\nrawmemchr (const void *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 is zero is equivalent\n     to testing whether tmp is nonzero.\n\n     This test can read beyond the end of a string, depending on where\n     C_IN is encountered.  However, this is considered safe since the\n     initialization phase ensured that the read will be aligned,\n     therefore, the read will not cross page boundaries and will not\n     cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == c.  On little-endian machines, we\n     could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr != c)\n    char_ptr++;\n  return (void *) char_ptr;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\nrawmemchr (const void *s, int c_in)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/size_max.h": {},
  "cflow/cflow-1.5/gnu/sleep.c": {
    "sleep": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "unsigned int\nsleep (unsigned int seconds)\n{\n  unsigned int remaining;\n\n  /* Sleep for 1 second many times, because\n       1. Sleep is not interruptible by Ctrl-C,\n       2. we want to avoid arithmetic overflow while multiplying with 1000.  */\n  for (remaining = seconds; remaining > 0; remaining--)\n    Sleep (1000);\n\n  return remaining;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "rpl_sleep": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "unsigned int\nrpl_sleep (unsigned int seconds)\n{\n  /* This requires int larger than 16 bits.  */\n  verify (UINT_MAX / 24 / 24 / 60 / 60);\n  const unsigned int limit = 24 * 24 * 60 * 60;\n  while (limit < seconds)\n    {\n      unsigned int result;\n      seconds -= limit;\n      result = sleep (limit);\n      if (result)\n        return seconds + result;\n    }\n  return sleep (seconds);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/snprintf.c": {
    "snprintf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nsnprintf (char *str, size_t size, const char *format, ...)\n{\n  char *output;\n  size_t len;\n  size_t lenbuf = size;\n  va_list args;\n\n  va_start (args, format);\n  output = vasnprintf (str, &lenbuf, format, args);\n  len = lenbuf;\n  va_end (args);\n\n  if (!output)\n    return -1;\n\n  if (output != str)\n    {\n      if (size)\n        {\n          size_t pruned_len = (len < size ? len : size - 1);\n          memcpy (str, output, pruned_len);\n          str[pruned_len] = '\\0';\n        }\n\n      free (output);\n    }\n\n  if (INT_MAX < len)\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/stat.c": {
    "orig_stat": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_stat": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *st)\n{\n  int result = orig_stat (name, st);\n#if REPLACE_FUNC_STAT_FILE\n  /* Solaris 9 mistakenly succeeds when given a non-directory with a\n     trailing slash.  */\n  if (result == 0 && !S_ISDIR (st->st_mode))\n    {\n      size_t len = strlen (name);\n      if (ISSLASH (name[len - 1]))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_FILE */\n#if REPLACE_FUNC_STAT_DIR\n\n  if (result == -1 && errno == ENOENT)\n    {\n      /* Due to mingw's oddities, there are some directories (like\n         c:\\) where stat() only succeeds with a trailing slash, and\n         other directories (like c:\\windows) where stat() only\n         succeeds without a trailing slash.  But we want the two to be\n         synonymous, since chdir() manages either style.  Likewise, Mingw also\n         reports ENOENT for names longer than PATH_MAX, when we want\n         ENAMETOOLONG, and for stat(\"file/\"), when we want ENOTDIR.\n         Fortunately, mingw PATH_MAX is small enough for stack\n         allocation.  */\n      char fixed_name[PATH_MAX + 1] = {0};\n      size_t len = strlen (name);\n      bool check_dir = false;\n      verify (PATH_MAX <= 4096);\n      if (PATH_MAX <= len)\n        errno = ENAMETOOLONG;\n      else if (len)\n        {\n          strcpy (fixed_name, name);\n          if (ISSLASH (fixed_name[len - 1]))\n            {\n              check_dir = true;\n              while (len && ISSLASH (fixed_name[len - 1]))\n                fixed_name[--len] = '\\0';\n              if (!len)\n                fixed_name[0] = '/';\n            }\n          else\n            fixed_name[len++] = '/';\n          result = orig_stat (fixed_name, st);\n          if (result == 0 && check_dir && !S_ISDIR (st->st_mode))\n            {\n              result = -1;\n              errno = ENOTDIR;\n            }\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_DIR */\n  return result;\n}",
      "lines": 60,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/stdalign.in.h": {},
  "cflow/cflow-1.5/gnu/stdarg.in.h": {},
  "cflow/cflow-1.5/gnu/stdbool.in.h": {},
  "cflow/cflow-1.5/gnu/stddef.in.h": {},
  "cflow/cflow-1.5/gnu/stdint.in.h": {},
  "cflow/cflow-1.5/gnu/stdio.in.h": {},
  "cflow/cflow-1.5/gnu/stdlib.in.h": {},
  "cflow/cflow-1.5/gnu/strcasecmp.c": {
    "strcasecmp": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\nstrcasecmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/strchrnul.c": {
    "strchrnul": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "char *\nstrchrnul (const char *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n  if (!c)\n    return rawmemchr (s, 0);\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (!*char_ptr || *char_ptr == c)\n      return (char *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 or\n     longword2 is zero.\n\n     Let's consider longword1.  We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 or longword2 is zero is equivalent\n     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine\n     this into a single test, whether (tmp1 | tmp2) is nonzero.\n\n     This test can read more than one byte beyond the end of a string,\n     depending on where the terminating NUL is encountered.  However,\n     this is considered safe since the initialization phase ensured\n     that the read will be aligned, therefore, the read will not cross\n     page boundaries and will not cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n      longword longword2 = *longword_ptr;\n\n      if (((((longword1 - repeated_one) & ~longword1)\n            | ((longword2 - repeated_one) & ~longword2))\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == 0 or == c.  On little-endian machines,\n     we could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr && (*char_ptr != c))\n    char_ptr++;\n  return (char *) char_ptr;\n}",
      "lines": 120,
      "depth": 16,
      "decorators": [
        "char",
        "*\nstrchrnul (const char *s, int c_in)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/strerror-override.h": {},
  "cflow/cflow-1.5/gnu/strerror.c": {},
  "cflow/cflow-1.5/gnu/string.in.h": {},
  "cflow/cflow-1.5/gnu/strings.in.h": {},
  "cflow/cflow-1.5/gnu/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/strncasecmp.c": {
    "strncasecmp": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\nstrncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/strndup.c": {
    "strndup": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\nstrndup (char const *s, size_t n)\n{\n  size_t len = strnlen (s, n);\n  char *new = malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return memcpy (new, s, len);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrndup (char const *s, size_t n)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/strnlen.c": {
    "strnlen": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "size_t\nstrnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/sysexits.in.h": {},
  "cflow/cflow-1.5/gnu/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        505,
        0
      ],
      "end_point": [
        509,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/sys_time.in.h": {},
  "cflow/cflow-1.5/gnu/sys_types.in.h": {},
  "cflow/cflow-1.5/gnu/time.in.h": {},
  "cflow/cflow-1.5/gnu/unistd.c": {},
  "cflow/cflow-1.5/gnu/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        872,
        0
      ],
      "end_point": [
        876,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and Mac OS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        406,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        415,
        0
      ],
      "end_point": [
        838,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        892,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        900,
        0
      ],
      "end_point": [
        978,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        988,
        0
      ],
      "end_point": [
        1063,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1072,
        0
      ],
      "end_point": [
        1285,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1294,
        0
      ],
      "end_point": [
        1301,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1312,
        0
      ],
      "end_point": [
        1319,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1328,
        0
      ],
      "end_point": [
        1410,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1419,
        0
      ],
      "end_point": [
        1501,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1507,
        0
      ],
      "end_point": [
        1517,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1534,
        0
      ],
      "end_point": [
        1769,
        1
      ],
      "content": "static size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4631,
        16
      ],
      "end_point": [
        5544,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 914,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = (unsigned int) (-arg);",
        "width = (unsigned int) (-arg)",
        "width",
        "=",
        "(unsigned int) (-arg)",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "(-arg)",
        "(",
        "-arg",
        "-",
        "arg",
        ")",
        ";",
        "}",
        "else",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = (unsigned char) *mp++;",
        "*fbp++ = (unsigned char) *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "(unsigned char) *mp++",
        "(",
        "unsigned char",
        "unsigned char",
        "unsigned",
        "char",
        ")",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = (unsigned char) *mp++;",
        "*fbp++ = (unsigned char) *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "(unsigned char) *mp++",
        "(",
        "unsigned char",
        "unsigned char",
        "unsigned",
        "char",
        ")",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "/*FALLTHROUGH*/",
        "# endif",
        "#endif",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "!(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "has_width ? width : 0",
        "has_width",
        "?",
        "width",
        ":",
        "0",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));",
        "errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL))",
        "errno",
        "=",
        "(saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL))",
        "(",
        "saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL)",
        "saved_errno != 0",
        "saved_errno",
        "!=",
        "0",
        "?",
        "saved_errno",
        ":",
        "(dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL)",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        "?",
        "EILSEQ",
        ":",
        "EINVAL",
        ")",
        ")",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "cflow/cflow-1.5/gnu/vasnprintf.h": {},
  "cflow/cflow-1.5/gnu/verify.h": {},
  "cflow/cflow-1.5/gnu/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <http://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/version-etc.h": {},
  "cflow/cflow-1.5/gnu/vsnprintf.c": {
    "vsnprintf": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nvsnprintf (char *str, size_t size, const char *format, va_list args)\n{\n  char *output;\n  size_t len;\n  size_t lenbuf = size;\n\n  output = vasnprintf (str, &lenbuf, format, args);\n  len = lenbuf;\n\n  if (!output)\n    return -1;\n\n  if (output != str)\n    {\n      if (size)\n        {\n          size_t pruned_len = (len < size ? len : size - 1);\n          memcpy (str, output, pruned_len);\n          str[pruned_len] = '\\0';\n        }\n\n      free (output);\n    }\n\n  if (len > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/wchar.in.h": {},
  "cflow/cflow-1.5/gnu/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/xalloc-oversized.h": {},
  "cflow/cflow-1.5/gnu/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          122,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          237,
          29
        ],
        "end_point": [
          241,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          179,
          0
        ],
        "end_point": [
          211,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n    }\n  else\n    {\n      /* Set N = ceil (1.5 * N) so that progress is made if N == 1.\n         Check for overflow, so that N * S stays in size_t range.\n         The check is slightly conservative, but an exact check isn't\n         worth the trouble.  */\n      if ((size_t) -1 / 3 * 2 / s <= n)\n        xalloc_die ();\n      n += (n + 1) / 2;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 33,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          249,
          29
        ],
        "end_point": [
          253,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        231,
        29
      ],
      "end_point": [
        235,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        243,
        29
      ],
      "end_point": [
        247,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        255,
        29
      ],
      "end_point": [
        259,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since some calloc implementations don't have\n     proper overflow checks.  But omit overflow and size-zero tests if\n     HAVE_GNU_CALLOC, since GNU calloc catches overflow and never\n     returns NULL if successful.  */\n  if ((! HAVE_GNU_CALLOC && xalloc_oversized (n, s))\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/gnu/xsize.c": {},
  "cflow/cflow-1.5/gnu/xsize.h": {
    "size_t": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "__pure__": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    }
  },
  "cflow/cflow-1.5/src/c.c": {
    "yy_get_next_buffer": {
      "start_point": [
        1723,
        0
      ],
      "end_point": [
        1856,
        1
      ],
      "content": "static int yy_get_next_buffer (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tyy_size_t num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tyy_size_t new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart(yyin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tyy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 134,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        1863,
        4
      ],
      "end_point": [
        1894,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n/* %% [15.0] code to get the start state into yy_current_state goes here */\n\tyy_current_state = (yy_start);\n\tyy_current_state += YY_AT_BOL();\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n/* %% [16.0] code to find the next state goes here */\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 191 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        1902,
        4
      ],
      "end_point": [
        1927,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister int yy_is_jam;\n    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */\n\tregister char *yy_cp = (yy_c_buf_p);\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 191 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 190);\n\n\t\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yyunput": {
      "start_point": [
        1931,
        4
      ],
      "end_point": [
        1971,
        1
      ],
      "content": "static void yyunput (int c, register char * yy_bp )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister char *yy_cp;\n    \n    yy_cp = (yy_c_buf_p);\n\n\t/* undo effects of setting up yytext */\n\t*yy_cp = (yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister yy_size_t number_to_move = (yy_n_chars) + 2;\n\t\tregister char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n/* %% [18.0] update yylineno here */\n\n\t(yytext_ptr) = yy_bp;\n\t(yy_hold_char) = *yy_cp;\n\t(yy_c_buf_p) = yy_cp;\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyrestart": {
      "start_point": [
        2065,
        4
      ],
      "end_point": [
        2079,
        1
      ],
      "content": "void yyrestart  (FILE * input_file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer(yyin,YY_BUF_SIZE );\n\t}\n\n\tyy_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tyy_load_buffer_state( );\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_switch_to_buffer": {
      "start_point": [
        2086,
        4
      ],
      "end_point": [
        2118,
        1
      ],
      "content": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_load_buffer_state": {
      "start_point": [
        2121,
        0
      ],
      "end_point": [
        2130,
        1
      ],
      "content": "static void yy_load_buffer_state  (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\t(yy_hold_char) = *(yy_c_buf_p);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_create_buffer": {
      "start_point": [
        2139,
        4
      ],
      "end_point": [
        2164,
        1
      ],
      "content": "YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_delete_buffer": {
      "start_point": [
        2171,
        4
      ],
      "end_point": [
        2187,
        1
      ],
      "content": "void yy_delete_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree((void *) b->yy_ch_buf  );\n\n\tyyfree((void *) b  );\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "yy_init_buffer": {
      "start_point": [
        2194,
        4
      ],
      "end_point": [
        2224,
        1
      ],
      "content": "static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\n{\n\tint oerrno = errno;\n    \n\tyy_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n/* %if-c-only */\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\terrno = oerrno;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flush_buffer": {
      "start_point": [
        2231,
        4
      ],
      "end_point": [
        2255,
        1
      ],
      "content": "void yy_flush_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state( );\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yypush_buffer_state": {
      "start_point": [
        2265,
        0
      ],
      "end_point": [
        2292,
        1
      ],
      "content": "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack();\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yypop_buffer_state": {
      "start_point": [
        2301,
        0
      ],
      "end_point": [
        2318,
        1
      ],
      "content": "void yypop_buffer_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yyensure_buffer_stack": {
      "start_point": [
        2326,
        0
      ],
      "end_point": [
        2370,
        1
      ],
      "content": "static void yyensure_buffer_stack (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tyy_size_t num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_scan_buffer": {
      "start_point": [
        2380,
        0
      ],
      "end_point": [
        2407,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_string": {
      "start_point": [
        2419,
        0
      ],
      "end_point": [
        2423,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )\n{\n    \n\treturn yy_scan_bytes(yystr,strlen(yystr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_bytes": {
      "start_point": [
        2434,
        0
      ],
      "end_point": [
        2462,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) yyalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        2470,
        0
      ],
      "end_point": [
        2474,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyget_lineno": {
      "start_point": [
        2505,
        0
      ],
      "end_point": [
        2509,
        1
      ],
      "content": "int yyget_lineno  (void)\n{\n        \n    return yylineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyget_in": {
      "start_point": [
        2514,
        0
      ],
      "end_point": [
        2517,
        1
      ],
      "content": "FILE *yyget_in  (void)\n{\n        return yyin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_in  (void)",
        "*"
      ]
    },
    "yyget_out": {
      "start_point": [
        2522,
        0
      ],
      "end_point": [
        2525,
        1
      ],
      "content": "FILE *yyget_out  (void)\n{\n        return yyout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_out  (void)",
        "*"
      ]
    },
    "yyget_leng": {
      "start_point": [
        2530,
        0
      ],
      "end_point": [
        2533,
        1
      ],
      "content": "yy_size_t yyget_leng  (void)\n{\n        return yyleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "yy_size_t"
      ]
    },
    "yyget_text": {
      "start_point": [
        2539,
        0
      ],
      "end_point": [
        2542,
        1
      ],
      "content": "char *yyget_text  (void)\n{\n        return yytext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*yyget_text  (void)",
        "*"
      ]
    },
    "yyset_lineno": {
      "start_point": [
        2551,
        0
      ],
      "end_point": [
        2555,
        1
      ],
      "content": "void yyset_lineno (int  line_number )\n{\n    \n    yylineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yyset_in": {
      "start_point": [
        2563,
        0
      ],
      "end_point": [
        2566,
        1
      ],
      "content": "void yyset_in (FILE *  in_str )\n{\n        yyin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyset_out": {
      "start_point": [
        2568,
        0
      ],
      "end_point": [
        2571,
        1
      ],
      "content": "void yyset_out (FILE *  out_str )\n{\n        yyout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyget_debug": {
      "start_point": [
        2573,
        0
      ],
      "end_point": [
        2576,
        1
      ],
      "content": "int yyget_debug  (void)\n{\n        return yy_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyset_debug": {
      "start_point": [
        2578,
        0
      ],
      "end_point": [
        2581,
        1
      ],
      "content": "void yyset_debug (int  bdebug )\n{\n        yy_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        2591,
        0
      ],
      "end_point": [
        2617,
        1
      ],
      "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yylex_destroy": {
      "start_point": [
        2622,
        0
      ],
      "end_point": [
        2643,
        1
      ],
      "content": "int yylex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( );\n\n/* %if-reentrant */\n/* %endif */\n    return 0;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        2651,
        0
      ],
      "end_point": [
        2656,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        2660,
        0
      ],
      "end_point": [
        2667,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyalloc": {
      "start_point": [
        2670,
        0
      ],
      "end_point": [
        2673,
        1
      ],
      "content": "void *yyalloc (yy_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*yyalloc (yy_size_t  size )",
        "*"
      ]
    },
    "yyrealloc": {
      "start_point": [
        2675,
        0
      ],
      "end_point": [
        2685,
        1
      ],
      "content": "void *yyrealloc  (void * ptr, yy_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*yyrealloc  (void * ptr, yy_size_t  size )",
        "*"
      ]
    },
    "yyfree": {
      "start_point": [
        2687,
        0
      ],
      "end_point": [
        2690,
        1
      ],
      "content": "void yyfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "init_tokens": {
      "start_point": [
        2739,
        0
      ],
      "end_point": [
        2774,
        1
      ],
      "content": "void\ninit_tokens()\n{\n     int i;\n     Symbol *sp;\n    \n     for (i = 0; i < NUMITEMS(keywords); i++) {\n\t  sp = install(keywords[i], INSTALL_OVERWRITE);\n\t  sp->type = SymToken;\n\t  sp->token_type = WORD;\n     }\n     \n     for (i = 0; i < NUMITEMS(types); i++) {\n\t  sp = install(types[i], INSTALL_OVERWRITE);\n\t  sp->type = SymToken;\n\t  sp->token_type = TYPE;\n\t  sp->source = NULL;\n\t  sp->def_line = -1;\n\t  sp->ref_line = NULL;\n     }\t\n\n     for (i = 0; i < NUMITEMS(qualifiers); i++) {\n\t  sp = install(qualifiers[i], INSTALL_OVERWRITE);\n\t  sp->type = SymToken;\n\t  sp->token_type = QUALIFIER;\n\t  sp->source = NULL;\n\t  sp->def_line = -1;\n\t  sp->ref_line = NULL;\n     }\t\n     sp = install(\"...\", INSTALL_OVERWRITE);\n     sp->type = SymToken;\n     sp->token_type = IDENTIFIER;\n     sp->source = NULL;\n     sp->def_line = -1;\n     sp->ref_line = NULL;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "init_lex": {
      "start_point": [
        2776,
        0
      ],
      "end_point": [
        2782,
        1
      ],
      "content": "void\ninit_lex(int debug_level)\n{\n     yy_flex_debug = debug_level;\n     obstack_init(&string_stk);\n     init_tokens();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "ident": {
      "start_point": [
        2784,
        0
      ],
      "end_point": [
        2806,
        1
      ],
      "content": "int\nident()\n{\n     /* Do not attempt any symbol table lookup if the previous token was\n\tSTRUCT.  This helps properly parse constructs like:\n\n\t  typedef struct foo foo;\n\t  struct foo {\n\t    int dummy;\n\t  };\n     */\n     if (prev_token != STRUCT) {\n          Symbol *sp = lookup(yytext);\n          if (sp && sp->type == SymToken) {\n\t       yylval.str = sp->name;\n\t       return sp->token_type;\n          }\n     }\n     obstack_grow(&string_stk, yytext, yyleng);\n     obstack_1grow(&string_stk, 0);\n     yylval.str = obstack_finish(&string_stk);\n     return IDENTIFIER;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_preprocessor": {
      "start_point": [
        2814,
        0
      ],
      "end_point": [
        2818,
        1
      ],
      "content": "void\nset_preprocessor(const char *arg)\n{\n     pp_bin = arg ? xstrdup(arg) : NULL;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "pp_option": {
      "start_point": [
        2820,
        0
      ],
      "end_point": [
        2831,
        1
      ],
      "content": "void\npp_option(const char *arg)\n{\n     if (!opt_stack) {\n\t  if (!pp_bin)\n\t       pp_bin = CFLOW_PREPROC;\n\t  opt_stack = xmalloc(sizeof *opt_stack);\n\t  obstack_init(opt_stack);\n     }\n     obstack_1grow(opt_stack, ' ');\n     obstack_grow(opt_stack, arg, strlen (arg));\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "pp_finalize": {
      "start_point": [
        2833,
        0
      ],
      "end_point": [
        2846,
        1
      ],
      "content": "void\npp_finalize()\n{\n     char *s = obstack_finish(opt_stack);\n     if (!pp_opts)\n\t  pp_opts = xstrdup(s);\n     else {\n\t  pp_opts = xrealloc(pp_opts, strlen(pp_opts) + strlen(s) + 1);\n\t  strcat(pp_opts, s);\n     }\n     obstack_free(opt_stack, s);\n     free(opt_stack);\n     opt_stack = NULL;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "pp_open": {
      "start_point": [
        2848,
        0
      ],
      "end_point": [
        2873,
        1
      ],
      "content": "FILE *\npp_open(const char *name)\n{\n     FILE *fp;\n     char *s;\n     size_t size;\n     \n     if (opt_stack)\n\t  pp_finalize();\n     size = strlen(pp_bin) + 1 + strlen(name) + 1;\n     if (pp_opts)\n\t  size += strlen(pp_opts);\n     s = xmalloc(size);\n     strcpy(s, pp_bin);\n     if (pp_opts)\n\t  strcat(s, pp_opts);\n     strcat(s, \" \");\n     strcat(s, name);\n     if (debug)\n\t  fprintf(stderr, _(\"Command line: %s\\n\"), s);\n     fp = popen(s, \"r\");\n     if (!fp)\n\t  error(0, errno, _(\"cannot execute `%s'\"), s);\n     free(s);\n     return fp;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "FILE",
        "*\npp_open(const char *name)",
        "*"
      ]
    },
    "pp_close": {
      "start_point": [
        2875,
        0
      ],
      "end_point": [
        2879,
        1
      ],
      "content": "void\npp_close(FILE *fp)\n{\n     pclose(fp);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yywrap": {
      "start_point": [
        2883,
        0
      ],
      "end_point": [
        2898,
        1
      ],
      "content": "int\nyywrap()\n{\n     if (!yyin)\n\t  return 1;\n     if (preprocess_option)\n\t  pp_close(yyin);\n     else\n\t  fclose(yyin);\n     yyin = NULL;\n#ifdef FLEX_SCANNER\n     yy_delete_buffer(YY_CURRENT_BUFFER);\n#endif\n     delete_statics();\n     return 1;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "get_token": {
      "start_point": [
        2902,
        0
      ],
      "end_point": [
        2916,
        1
      ],
      "content": "int\nget_token()\n{\n     int tok;\n\n     if (hit_eof)\n          tok = 0;\n     else {\n          tok = yylex();\n          prev_token = tok;\n          if (!tok)\n               hit_eof = 1;\n     }\n     return tok;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "source": {
      "start_point": [
        2918,
        0
      ],
      "end_point": [
        2943,
        1
      ],
      "content": "int\nsource(char *name)\n{\n     FILE *fp;\n\n     fp = fopen(name, \"r\");\n     if (!fp) {\n\t  error(0, errno, _(\"cannot open `%s'\"), name);\n\t  return 1;\n     }\n     if (preprocess_option) {\n\t  fclose(fp);\n\t  fp = pp_open(name);\n\t  if (!fp)\n\t       return 1;\n     }\n     obstack_grow(&string_stk, name, strlen(name)+1);\n     filename = obstack_finish(&string_stk);\n     canonical_filename = filename;\n     line_num = 1;\n     input_file_count++;\n     hit_eof = 0;\n\n     yyrestart(fp);\n     return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "getnum": {
      "start_point": [
        2945,
        0
      ],
      "end_point": [
        2963,
        1
      ],
      "content": "static int\ngetnum(unsigned  base, int  count)\n{\n     int  c, n;\n     unsigned i;\n\n     for (n = 0; count; count--) {\n\t  if (isdigit(c = input()))\n\t       i = c - '0';\n\t  else\n\t       i = toupper(c) - 'A' + 10;\n\t  if (i > base) {\n\t       unput(c);\n\t       break;\n\t  }\n\t  n = n * base + i;\n     }\n     return n;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "backslash": {
      "start_point": [
        2965,
        0
      ],
      "end_point": [
        2981,
        1
      ],
      "content": "int\nbackslash()\n{                                  \n     int c;\n     \n     switch (c = input()) {                        \n     case 'a':   return '\\a';                  \n     case 'b':   return '\\b';                  \n     case 'f':   return '\\f';                  \n     case 'n':   return '\\n';                  \n     case 'r':   return '\\r';                  \n     case 't':   return '\\t';                  \n     case 'x':   return getnum(16,2);          \n     case '0':   return getnum(8,3);           \n     }                                             \n     return c;                                         \n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "update_loc": {
      "start_point": [
        2983,
        0
      ],
      "end_point": [
        3007,
        1
      ],
      "content": "void\nupdate_loc()\n{\n     char *p;\n     \n     for (p = strchr(yytext, '#')+1; *p && isspace(*p); p++)\n\t  ;\n     if (p[0] == 'l') /* line */\n\t  p += 4;\n\n     line_num = strtoul(p, &p, 10);\n     for ( ; *p && isspace(*p); p++)\n\t  ;\n     if (p[0] == '\"') {\n\t  int n;\n\t  \n\t  for (p++, n = 0; p[n] && p[n] != '\"'; n++)\n\t       ;\n\t  obstack_grow(&string_stk, p, n);\n\t  obstack_1grow(&string_stk, 0);\n\t  filename = obstack_finish(&string_stk);\n     }\n     if (debug > 1)\n\t  fprintf(stderr, _(\"New location: %s:%d\\n\"), filename, line_num);\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/src/c.l": {
    "ident": {
      "start_point": [
        22,
        1
      ],
      "end_point": [
        45,
        2
      ],
      "content": "x comment\n%x string\n%x stringwait\n%x longline\n%{\n     \nstruct obstack string_stk;\n\nint line_num;\nchar *filename;\nchar *canonical_filename; \nYYSTYPE yylval;\nunsigned input_file_count; /* Number of input files, processed by source() */\n \nint ident();\nvoid update_loc();\n#define lex_error(msg) error_at_line(0, 0, filename, line_num, \"%s\", msg)\n\n/* Keep the token returned at the previous call to yylex. This is used\n   as a lexical tie-in to ensure that the next token after STRUCT is\n   IDENTIFIER. See get_token and ident below. */\nstatic int prev_token;\n\n%}",
      "lines": 24,
      "depth": 6,
      "decorators": [
        "x",
        "comment",
        "%x string\n%x stringwait\n%x longline\n%",
        "%",
        "x",
        "string",
        "%",
        "x",
        "stringwait",
        "%",
        "x",
        "longline",
        "%",
        "{\n     \nstruct obstack string_stk;\n\nint line_num;\nchar *filename;\nchar *canonical_filename; \nYYSTYPE yylval;\nunsigned input_file_count; /* Number of input files, processed by source() */\n \nint ident();\nvoid update_loc();\n#define lex_error(msg) error_at_line(0, 0, filename, line_num, \"%s\", msg)\n\n/* Keep the token returned at the previous call to yylex. This is used\n   as a lexical tie-in to ensure that the next token after STRUCT is\n   IDENTIFIER. See get_token and ident below. */\nstatic int prev_token;\n\n%}",
        "{",
        "struct obstack string_stk;",
        "struct obstack",
        "struct",
        "obstack",
        "string_stk",
        ";",
        "int line_num;",
        "int",
        "line_num",
        ";",
        "char *filename;",
        "char",
        "*filename",
        "*",
        "filename",
        ";",
        "char *canonical_filename;",
        "char",
        "*canonical_filename",
        "*",
        "canonical_filename",
        ";",
        "YYSTYPE yylval;",
        "YYSTYPE",
        "yylval",
        ";",
        "unsigned input_file_count;",
        "unsigned",
        "unsigned",
        "input_file_count",
        ";",
        "/* Number of input files, processed by source() */",
        "int ident();",
        "int"
      ]
    },
    "STATIC": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        76,
        59
      ],
      "content": "struct               {yylval.str = \"struct\"; return STRUCT;}\nunion                {yylval.str = \"union\"; return STRUCT;}",
      "lines": 2,
      "depth": 6,
      "decorators": null
    },
    "get_token": {
      "start_point": [
        370,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "int\nget_token()\n{\n     int tok;\n\n     if (hit_eof)\n          tok = 0;\n     else {\n          tok = yylex();\n          prev_token = tok;\n          if (!tok)\n               hit_eof = 1;\n     }\n     return tok;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "source": {
      "start_point": [
        386,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "int\nsource(char *name)\n{\n     FILE *fp;\n\n     fp = fopen(name, \"r\");\n     if (!fp) {\n\t  error(0, errno, _(\"cannot open `%s'\"), name);\n\t  return 1;\n     }\n     if (preprocess_option) {\n\t  fclose(fp);\n\t  fp = pp_open(name);\n\t  if (!fp)\n\t       return 1;\n     }\n     obstack_grow(&string_stk, name, strlen(name)+1);\n     filename = obstack_finish(&string_stk);\n     canonical_filename = filename;\n     line_num = 1;\n     input_file_count++;\n     hit_eof = 0;\n\n     yyrestart(fp);\n     return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "getnum": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "static int\ngetnum(unsigned  base, int  count)\n{\n     int  c, n;\n     unsigned i;\n\n     for (n = 0; count; count--) {\n\t  if (isdigit(c = input()))\n\t       i = c - '0';\n\t  else\n\t       i = toupper(c) - 'A' + 10;\n\t  if (i > base) {\n\t       unput(c);\n\t       break;\n\t  }\n\t  n = n * base + i;\n     }\n     return n;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "backslash": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "int\nbackslash()\n{                                  \n     int c;\n     \n     switch (c = input()) {                        \n     case 'a':   return '\\a';                  \n     case 'b':   return '\\b';                  \n     case 'f':   return '\\f';                  \n     case 'n':   return '\\n';                  \n     case 'r':   return '\\r';                  \n     case 't':   return '\\t';                  \n     case 'x':   return getnum(16,2);          \n     case '0':   return getnum(8,3);           \n     }                                             \n     return c;                                         \n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "update_loc": {
      "start_point": [
        451,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "void\nupdate_loc()\n{\n     char *p;\n     \n     for (p = strchr(yytext, '#')+1; *p && isspace(*p); p++)\n\t  ;\n     if (p[0] == 'l') /* line */\n\t  p += 4;\n\n     line_num = strtoul(p, &p, 10);\n     for ( ; *p && isspace(*p); p++)\n\t  ;\n     if (p[0] == '\"') {\n\t  int n;\n\t  \n\t  for (p++, n = 0; p[n] && p[n] != '\"'; n++)\n\t       ;\n\t  obstack_grow(&string_stk, p, n);\n\t  obstack_1grow(&string_stk, 0);\n\t  filename = obstack_finish(&string_stk);\n     }\n     if (debug > 1)\n\t  fprintf(stderr, _(\"New location: %s:%d\\n\"), filename, line_num);\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/src/cflow.h": {},
  "cflow/cflow-1.5/src/depmap.c": {
    "transitive_closure": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static void\ntransitive_closure(unsigned *R, int n)\n{\n     register size_t rowsize;\n     register unsigned mask;\n     register unsigned *rowj;\n     register unsigned *rp;\n     register unsigned *rend;\n     register unsigned *ccol;\n     \n     unsigned *relend;\n     unsigned *cword;\n     unsigned *rowi;\n     \n     rowsize = WORDSIZE (n) * sizeof (unsigned);\n     relend = (unsigned *) ((char *) R + (n * rowsize));\n     \n     cword = R;\n     mask = 1;\n     rowi = R;\n     while (rowi < relend) {\n\t  ccol = cword;\n\t  rowj = R;\n                \n\t  while (rowj < relend) {\n\t       if (*ccol & mask) {\n\t\t    rp = rowi;\n\t\t    rend = (unsigned *) ((char *) rowj + rowsize);\n                                \n\t\t    while (rowj < rend)\n\t\t\t *rowj++ |= *rp++;\n\t       } else {\n\t\t    rowj = (unsigned *) ((char *) rowj + rowsize);\n\t       }\n\t  \n\t       ccol = (unsigned *) ((char *) ccol + rowsize);\n\t  }\n                \n\t  mask <<= 1;\n\t  if (mask == 0) {\n\t       mask = 1;\n\t       cword++;\n\t  }\n\t  rowi = (unsigned *) ((char *) rowi + rowsize);\n     }\n}",
      "lines": 46,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "depmap_alloc": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "cflow_depmap_t\ndepmap_alloc(size_t count)\n{\n     size_t size = (count + BITS_PER_WORD - 1) / BITS_PER_WORD;\n     cflow_depmap_t dmap = xzalloc(sizeof(*dmap) - 1 \n\t\t\t\t   + count * size * sizeof(unsigned));\n     dmap->nrows  = count;\n     dmap->rowlen = size;\n     return dmap;\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "cflow_depmap_t"
      ]
    },
    "depmap_rowptr": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static unsigned *\ndepmap_rowptr(cflow_depmap_t dmap, size_t row)\n{\n     return dmap->r + dmap->rowlen * row;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned",
        "*\ndepmap_rowptr(cflow_depmap_t dmap, size_t row)",
        "*"
      ]
    },
    "depmap_set": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void\ndepmap_set(cflow_depmap_t dmap, size_t row, size_t col)\n{\n     unsigned *rptr = depmap_rowptr(dmap, row);\n     SETBIT(rptr, col);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "depmap_isset": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "int\ndepmap_isset(cflow_depmap_t dmap, size_t row, size_t col)\n{\n     unsigned *rptr = depmap_rowptr(dmap, row);\n     return BITISSET(rptr, col);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "depmap_tc": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\ndepmap_tc(cflow_depmap_t dmap)\n{\n     transitive_closure(dmap->r, dmap->nrows);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/src/gnu.c": {
    "print_function_name": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\nprint_function_name(Symbol *sym, int has_subtree)\n{\n     fprintf(outfile, \"%s\", sym->name);\n     if (sym->arity >= 0)\n\t  fprintf(outfile, \"()\");\n     if (sym->decl)\n\t  fprintf(outfile, \" <%s at %s:%d>\",\n\t\t  sym->decl,\n\t\t  sym->source,\n\t\t  sym->def_line);\n     if (sym->active) {\n\t  fprintf(outfile, \" (recursive: see %d)\", sym->active-1);\n\t  return;\n     }\n     if (sym->recursive)\n\t  fprintf(outfile, \" (R)\");\n     if (!print_as_tree && has_subtree)\n\t  fprintf(outfile, \":\");\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print_symbol": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\nprint_symbol(FILE *outfile, int line, struct output_symbol *s)\n{\n     int has_subtree = s->direct ? \n \t                  s->sym->callee != NULL :\n\t                  s->sym->caller != NULL;\n     \n     print_level(s->level, s->last);\n     print_function_name(s->sym, has_subtree);\n\t  \n     if (brief_listing) {\n\t  if (s->sym->expand_line) {\n\t       fprintf(outfile, \" [see %d]\", s->sym->expand_line);\n\t       return 1;\n\t  } else if (s->sym->callee)\n\t       s->sym->expand_line = line;\n     }\n     return 0;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gnu_output_handler": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\ngnu_output_handler(cflow_output_command cmd,\n\t\t   FILE *outfile, int line,\n\t\t   void *data, void *handler_data)\n{\n     switch (cmd) {\n     case cflow_output_begin:\n\t  if (emacs_option) {\n\t       fprintf(outfile, \";; This file is generated by %s. -*- cflow -*-\",\n\t\t       PACKAGE_STRING);\n\t       newline();\n\t  }\n\t  break;\n     case cflow_output_init:\n     case cflow_output_end:\n     case cflow_output_separator:\n\t  break;\n     case cflow_output_newline:\n\t  fprintf(outfile, \"\\n\");\n\t  break;\n     case cflow_output_text:\n\t  fprintf(outfile, \"%s\", (char*) data);\n\t  break;\n     case cflow_output_symbol:\n\t  return print_symbol(outfile, line, data);\n     }\n     return 0;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/src/linked-list.c": {
    "deref_linked_list": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        28,
        1
      ],
      "content": "static struct linked_list *\nderef_linked_list (struct linked_list **plist)\n{\n     if (!*plist) {\n\t  struct linked_list *list = xmalloc(sizeof(*list));\n\t  list->free_data = NULL;\n\t  list->head = list->tail = NULL;\n\t  *plist = list;\n     }\n     return *plist;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct linked_list",
        "struct",
        "linked_list",
        "*\nderef_linked_list (struct linked_list **plist)",
        "*"
      ]
    },
    "linked_list_create": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "struct linked_list *\nlinked_list_create(linked_list_free_data_fp fun)\n{\n     struct linked_list *list = xmalloc(sizeof(*list));\n     list->free_data = fun;\n     list->head = list->tail = NULL;\n     return list;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "struct linked_list",
        "struct",
        "linked_list",
        "*\nlinked_list_create(linked_list_free_data_fp fun)",
        "*"
      ]
    },
    "linked_list_append": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\nlinked_list_append(struct linked_list **plist, void *data)\n{\n     struct linked_list *list = deref_linked_list (plist);\n     struct linked_list_entry *entry = xmalloc(sizeof(*entry));\n\n     entry->list = list;\n     entry->data = data;\n     entry->next = NULL;\n     entry->prev = list->tail;\n     if (list->tail)\n\t  list->tail->next = entry;\n     else\n\t  list->head = entry;\n     list->tail = entry;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "linked_list_prepend": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\nlinked_list_prepend(struct linked_list **plist, void *data)\n{\n     struct linked_list *list = deref_linked_list (plist);\n     struct linked_list_entry *entry = xmalloc(sizeof(*entry));\n     \n     entry->list = list;\n     entry->data = data;\n     if (list->head)\n\t  list->head->prev = entry;\n     entry->next = list->head;\n     entry->prev = NULL;\n     list->head = entry;\n     if (!list->tail)\n\t  list->tail = entry;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "linked_list_destroy": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nlinked_list_destroy(struct linked_list **plist)\n{\n     if (plist && *plist) {\n\t  struct linked_list *list = *plist;\n\t  struct linked_list_entry *p;\n\n\t  for (p = list->head; p; ) {\n\t       struct linked_list_entry *next = p->next;\n\t       if (list->free_data)\n\t\t    list->free_data(p->data);\n\t       free(p);\n\t       p = next;\n\t  }\n\t  free(list);\n\t  *plist = NULL;\n     }\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "linked_list_unlink": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\nlinked_list_unlink(struct linked_list *list, struct linked_list_entry *ent)\n{\n     struct linked_list_entry *p;\n\n     if ((p = ent->prev))\n\t  p->next = ent->next;\n     else\n\t  list->head = ent->next;\n\n     if ((p = ent->next))\n\t  p->prev = ent->prev;\n     else\n\t  list->tail = ent->prev;\n     if (list->free_data)\n\t  list->free_data(ent->data);\n     free(ent);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "linked_list_iterate": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "void\nlinked_list_iterate(struct linked_list **plist, \n\t\t    int (*itr) (void *, void *), void *data)\n{\n     struct linked_list *list;\n     struct linked_list_entry *p;\n\n     if (!*plist)\n\t  return;\n     list = *plist;\n     for (p = linked_list_head(list); p; ) {\n\t  struct linked_list_entry *next = p->next;\n\n\t  if (itr(p->data, data))\n\t       linked_list_unlink(list, p);\n\t  p = next;\n     }\n     if (!list->head)\n\t  linked_list_destroy(&list);\n     *plist = list;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "data_in_list": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\ndata_in_list(void *data, struct linked_list *list)\n{\n     struct linked_list_entry *p;\n     \n     for (p = linked_list_head(list); p; p = p->next)\n\t  if (p->data == data)\n\t       return 1;\n     return 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/src/main.c": {
    "find_option_type": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static int\nfind_option_type(struct option_type *optype, const char *str, int len)\n{\n     if (len == 0)\n\t  len = strlen(str);\n     for ( ; optype->str; optype++) {\n\t  if (len >= optype->min_match &&\n\t      memcmp(str, optype->str, len) == 0) {\n\t       return optype->type;\n\t  }\n     }\n     return 0;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "symbol_override": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "static void\nsymbol_override(const char *str)\n{\n     const char *ptr;\n     char *name;\n     Symbol *sp;\n     \n     ptr = strchr(str, ':');\n     if (!ptr)\n\t  error(EX_USAGE, 0, _(\"%s: no symbol type supplied\"), str);\n     else {\n\t  name = strndup(str, ptr - str);\n\t  if (ptr[1] == '=') {\n\t       Symbol *alias = lookup(ptr+2);\n\t       if (!alias) {\n\t\t    alias = install(xstrdup(ptr+2), INSTALL_OVERWRITE);\n\t\t    alias->type = SymToken;\n\t\t    alias->token_type = 0;\n\t\t    alias->source = NULL;\n\t\t    alias->def_line = -1;\n\t\t    alias->ref_line = NULL;\n\t       }\n\t       sp = install(name, INSTALL_OVERWRITE);\n\t       sp->type = SymToken;\n\t       sp->alias = alias;\n\t       sp->flag = symbol_alias;\n\t  } else {\n\t       int type = find_option_type(symbol_optype, ptr+1, 0);\n\t       if (type == 0)\n\t\t    error(EX_USAGE, 0, _(\"unknown symbol type: %s\"), ptr+1);\n\t       sp = install(name, INSTALL_OVERWRITE);\n\t       sp->type = SymToken;\n\t       sp->token_type = type;\n\t  }\n\t  sp->source = NULL;\n\t  sp->def_line = -1;\n\t  sp->ref_line = NULL;\n     }\n}",
      "lines": 39,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_print_option": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "static void\nset_print_option(char *str)\n{\n     int opt;\n     \n     opt = find_option_type(print_optype, str, 0);\n     if (opt == 0) {\n\t  error(EX_USAGE, 0, _(\"unknown print option: %s\"), str);\n\t  return;\n     }\n     print_option |= opt;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "number": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "static int\nnumber(const char **str_ptr, int base, int count)\n{\n     int  c, n;\n     unsigned i;\n     const char *str = *str_ptr;\n     \n     for (n = 0; *str && count; count--) {\n\t  c = *str++;\n\t  if (isdigit(c))\n\t       i = c - '0';\n\t  else\n\t       i = toupper(c) - 'A' + 10;\n\t  if (i > base) {\n\t       break;\n\t  }\n\t  n = n * base + i;\n     }\n     *str_ptr = str - 1;\n     return n;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_level_string": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        446,
        1
      ],
      "content": "static void\nparse_level_string(const char *str, char **return_ptr)\n{\n     static char text[MAXLEVELINDENT];\n     char *p;\n     int i, c, num;\n    \n     p = text;\n     memset(text, ' ', sizeof(text));\n     text[sizeof(text)-1] = 0;\n     \n     while (*str) {\n\t  switch (*str) {\n\t  case '\\\\':\n\t       switch (*++str) {\n\t       case 'a':\n\t\t    *p++ = '\\a';\n\t\t    break;\n\t       case 'b':\n\t\t    *p++ = '\\b';\n\t\t    break;\n\t       case 'e':\n\t\t    *p++ = '\\033';\n\t\t    break;\n\t       case 'f':\n\t\t    *p++ = '\\f';\n\t\t    break;\n\t       case 'n':\n\t\t    *p++ = '\\n';\n\t\t    break;\n\t       case 'r':\n\t\t    *p++ = '\\r';\n\t\t    break;\n\t       case 't':\n\t\t    *p++ = '\\t';\n\t\t    break;\n\t       case 'x':\n\t       case 'X':\n\t\t    ++str;\n\t\t    *p++ = number(&str,16,2);\n\t\t    break;\n\t       case '0':\n\t\t    ++str;\n\t\t    *p++ = number(&str,8,3);\n\t\t    break;\n\t       default:\n\t\t    *p++ = *str;\n\t       }\n\t       ++str;\n\t       break;\n\t  case 'x':\n\t       if (p == text) {\n\t\t    goto copy;\n\t       }\n\t       num = strtol(str+1, (char**)&str, 10);\n\t       c = p[-1];\n\t       for (i = 1; i < num; i++) {\n\t\t    *p++ = c;\n\t\t    if (*p == 0)\n\t\t\t error(EX_USAGE, 0,\n\t\t\t       _(\"level indent string is too long\"));\n\t       }\n\t       break;\n\t  default:\n\t  copy:\n\t       *p++ = *str++;\n\t       if (*p == 0)\n\t\t    error(EX_USAGE, 0, _(\"level indent string is too long\"));\n\t  }\n     }\n     *p = 0;\n     *return_ptr = strdup(text);\n}",
      "lines": 73,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_level_indent": {
      "start_point": [
        448,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "static void\nset_level_indent(const char *str)\n{\n     long n;\n     const char *p;\n     char *q;\n     \n     n = strtol(str, &q, 0);\n     if (*q == 0 && n > 0) {\n\t  char *s = xmalloc(n+1);\n\t  memset(s, ' ', n-1);\n\t  s[n-1] = 0;\n\t  level_indent[0] = level_indent[1] = s;\n\t  return;\n     }\n     \n     p = str;\n     while (*p != '=') {\n\t  if (*p == 0)\n\t       error(EX_USAGE, 0, _(\"level-indent syntax\"));\n\t  p++;\n     }\n     ++p;\n    \n     switch (find_option_type(level_indent_optype, str, p - str - 1)) {\n     case LEVEL_BEGIN:\n\t  parse_level_string(p, &level_begin);\n\t  break;\n     case LEVEL_INDENT0:\n\t  parse_level_string(p, &level_indent[0]);\n\t  break;\n     case LEVEL_INDENT1:\n\t  parse_level_string(p, &level_indent[1]);\n\t  break;\n     case LEVEL_END0:\n\t  parse_level_string(p, &level_end[0]);\n\t  break;\n     case LEVEL_END1:\n\t  parse_level_string(p, &level_end[1]);\n\t  break;\n     default:\n\t  error(EX_USAGE, 0, _(\"unknown level indent option: %s\"), str);\n     }\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_name": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "static void\nadd_name(const char *name)\n{\n     linked_list_append(&arglist, (void*) name);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_preproc_option": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "static void\nadd_preproc_option(int key, const char *arg)\n{\n     char *opt = xmalloc(3 + strlen(arg));\n     sprintf(opt, \"-%c%s\", key, arg);\n     add_name(opt);\n     preprocess_option = 1;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_opt": {
      "start_point": [
        508,
        0
      ],
      "end_point": [
        669,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n     int num;\n     \n     switch (key) {\n     case 'a':\n\t  strict_ansi = 1;\n\t  break;\n     case OPT_NO_ANSI:\n\t  strict_ansi = 0;\n\t  break;\n     case OPT_DEBUG:\n\t  debug = arg ? atoi(arg) : 1;\n\t  break;\n     case 'P':\n\t  set_print_option(arg);\n\t  break;\n     case 'S':\n\t  use_indentation = 1;\n\t  break;\n     case OPT_NO_USE_INDENTATION:\n\t  use_indentation = 0;\n\t  break;\n     case 'T':\n\t  print_as_tree = 1;\n\t  set_level_indent(\"0=  \"); /* two spaces */\n\t  set_level_indent(\"1=| \");\n\t  set_level_indent(\"end0=+-\");\n\t  set_level_indent(\"end1=\\\\\\\\-\");\n\t  break;\n     case OPT_NO_TREE:\n\t  print_as_tree = 0;\n\t  level_indent[0] = level_indent[1] = NULL;\n\t  level_end[0] = level_end[1] = NULL;\n\t  break;\n     case 'b':\n\t  brief_listing = 1;\n\t  break;\n     case OPT_NO_BRIEF:\n\t  brief_listing = 0;\n\t  break;\n     case 'd':\n\t  max_depth = atoi(arg);\n\t  if (max_depth < 0)\n\t       max_depth = 0;\n\t  break;\n     case OPT_DEFINES: /* FIXME: Not used. */\n\t  record_defines = 1;\n\t  break;\n     case OPT_EMACS:\n\t  emacs_option = 1;\n\t  break;\n     case OPT_NO_EMACS:\n\t  emacs_option = 0;\n\t  break;\n     case 'f':\n\t  if (select_output_driver(arg))\n\t       error(EX_USAGE, 0, _(\"%s: No such output driver\"), optarg);\n\t  output_init();\n\t  break;\n     case OPT_LEVEL_INDENT:\n\t  set_level_indent(arg);\n\t  break;\n     case 'i':\n\t  num = 1;\n\t  for (; *arg; arg++) \n\t       switch (*arg) {\n\t       case '-':\n\t       case '^':\n\t\t    num = 0;\n\t\t    break;\n\t       case '+':\n\t\t    num = 1;\n\t\t    break;\n\t       case 'x':\n\t       case '_':\n\t       case 's':\n\t       case 't':\n\t       case 'u':\n\t\t    if (num)\n\t\t\t SYMBOL_INCLUDE(*arg);\n\t\t    else\n\t\t\t SYMBOL_EXCLUDE(*arg);\n\t\t    break;\n\t       default:\n\t\t    error(EX_USAGE, 0, _(\"Unknown symbol class: %c\"), *arg);\n\t       }\n\t  break;\n     case OPT_OMIT_ARGUMENTS:\n\t  omit_arguments_option = 1;\n\t  break;\n     case OPT_NO_OMIT_ARGUMENTS:\n\t  omit_arguments_option = 0;\n\t  break;\n     case OPT_OMIT_SYMBOL_NAMES:\n\t  omit_symbol_names_option = 1;\n\t  break;\n     case OPT_NO_OMIT_SYMBOL_NAMES:\n\t  omit_symbol_names_option = 0;\n\t  break;\n     case 'l':\n\t  print_levels = 1;\n\t  break;\n     case OPT_NO_PRINT_LEVEL:\n\t  print_levels = 0;\n\t  break;\n     case 'm':\n\t  start_name = strdup(arg);\n\t  break;\n     case 'n':\n\t  print_line_numbers = 1;\n\t  break;\n     case OPT_NO_NUMBER:\n\t  print_line_numbers = 0;\n\t  break;\n     case 'o':\n\t  outname = strdup(arg);\n\t  break;\n     case 'p':\n\t  num = atoi(arg);\n\t  if (num > 0)\n\t       token_stack_length = num;\n\t  break;\n     case 'r':\n\t  reverse_tree = 1;\n\t  break;\n     case OPT_NO_REVERSE:\n\t  reverse_tree = 0;\n\t  break;\n     case 's':\n\t  symbol_override(arg);\n\t  break;\n     case 'v':\n\t  verbose = 1;\n\t  break;\n     case OPT_NO_VERBOSE:\n\t  verbose = 0;\n\t  break;\n     case 'x':\n\t  print_option = PRINT_XREF;\n\t  break;\n     case OPT_PREPROCESS:\n\t  preprocess_option = 1;\n\t  set_preprocessor(arg ? arg : CFLOW_PREPROC);\n\t  break;\n     case OPT_NO_PREPROCESS:\n\t  preprocess_option = 0;\n\t  break;\n     case ARGP_KEY_ARG:\n\t  add_name(arg);\n\t  break;\n     case 'I':\n     case 'D':\n     case 'U':\n\t  add_preproc_option(key, arg);\n\t  break;\n     default:\n\t  return ARGP_ERR_UNKNOWN;\n     }\n     return 0;\n}",
      "lines": 162,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "globals_only": {
      "start_point": [
        681,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "int\nglobals_only()\n{\n     return !(symbol_map & SM_STATIC);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "include_symbol": {
      "start_point": [
        687,
        0
      ],
      "end_point": [
        716,
        1
      ],
      "content": "int\ninclude_symbol(Symbol *sym)\n{\n     int type = 0;\n     \n     if (!sym)\n\t  return 0;\n     \n     if (sym->type == SymIdentifier) {\n\t  if (sym->name[0] == '_' && !(symbol_map & SM_UNDERSCORE))\n\t       return 0;\n\n\t  if (sym->storage == StaticStorage)\n\t       type |= SM_STATIC;\n\t  if (sym->arity == -1 && sym->storage != AutoStorage)\n\t       type |= SM_DATA;\n\t  else if (sym->arity >= 0)\n\t       type |= SM_FUNCTIONS;\n\n\t  if (!sym->source)\n\t       type |= SM_UNDEFINED;\n\t  \n     } else if (sym->type == SymToken) {\n\t  if (sym->token_type == TYPE && sym->source)\n\t       type |= SM_TYPEDEF;\n\t  else\n\t       return 0;\n     }\n     return (symbol_map & type) == type;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "xalloc_die": {
      "start_point": [
        718,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "void\nxalloc_die(void)\n{\n     error(EX_FATAL, ENOMEM, _(\"Exiting\"));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "init": {
      "start_point": [
        724,
        0
      ],
      "end_point": [
        738,
        1
      ],
      "content": "void\ninit()\n{\n     if (level_indent[0] == NULL) \n\t  level_indent[0] = \"    \"; /* 4 spaces */\n     if (level_indent[1] == NULL)\n\t  level_indent[1] = level_indent[0];\n     if (level_end[0] == NULL)\n\t  level_end[0] = \"\";\n     if (level_end[1] == NULL)\n\t  level_end[1] = \"\";\n     \n     init_lex(debug > 2);\n     init_parse();\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        746,
        0
      ],
      "end_point": [
        809,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n     int index;\n     int status = EX_OK;\n     \n     set_program_name(argv[0]);\n     argp_version_setup(\"cflow\", program_authors);\n     \n     setlocale(LC_ALL, \"\");\n     bindtextdomain(PACKAGE, LOCALEDIR);\n     textdomain(PACKAGE);\n     \n     register_output(\"gnu\", gnu_output_handler, NULL);\n     register_output(\"posix\", posix_output_handler, NULL);\n\n     symbol_map = SM_FUNCTIONS|SM_STATIC|SM_UNDEFINED;\n\n     if (getenv(\"POSIXLY_CORRECT\")) {\n\t  if (select_output_driver(\"posix\")) {\n\t       error(0, 0, _(\"INTERNAL ERROR: %s: No such output driver\"),\n\t\t     \"posix\");\n\t       abort();\n\t  }\n\t  output_init();\n     }\n     \n     sourcerc(&argc, &argv);\n     if (argp_parse(&argp, argc, argv, ARGP_IN_ORDER, &index, NULL))\n\t  exit(EX_USAGE);\n\n     if (print_option == 0)\n\t  print_option = PRINT_TREE;\n\n     init();\n\n     if (arglist) {\n\t  struct linked_list_entry *p;\n\n\t  for (p = arglist->head; p; p = p->next) {\n\t       char *s = (char*)p->data;\n\t       if (s[0] == '-')\n\t\t    pp_option(s);\n\t       else if (source(s) == 0)\n\t\t    yyparse();\n\t  }\n     }\n     \n     argc -= index;\n     argv += index;\n\n     while (argc--) {\n\t  if (source(*argv++) == 0)\n\t       yyparse();\n\t  else\n\t       status = EX_SOFT;\n     }\n\n     if (input_file_count == 0)\n\t     error(EX_USAGE, 0, _(\"no input files\"));\n\n     output();\n     return status;\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/src/output.c": {
    "set_level_mark": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static void\nset_level_mark(int lev, int mark)\n{\n     if (lev >= level_mark_size) {\n\t  level_mark_size += level_mark_incr;\n\t  level_mark = xrealloc(level_mark, level_mark_size);\n     }\n     level_mark[lev] = mark;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_level": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\nprint_level(int lev, int last)\n{\n     int i;\n\n     if (print_line_numbers) \n\t  fprintf(outfile, \"%5d \", out_line);\n     if (print_levels)\n\t  fprintf(outfile, \"{%4d} \", lev);\n     fprintf(outfile, \"%s\", level_begin);\n     for (i = 0; i < lev; i++) \n\t  fprintf(outfile, \"%s\", level_indent[ level_mark[i] ]);\n     fprintf(outfile, \"%s\", level_end[last]);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "register_output": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nregister_output(const char *name,\n\t\tint (*handler) (cflow_output_command cmd,\n\t\t\t\tFILE *outfile, int line,\n\t\t\t\tvoid *data, void *handler_data),\n\t\tvoid *handler_data)\n{\n     if (driver_max == MAX_OUTPUT_DRIVERS-1)\n\t  abort ();\n     output_driver[driver_max].name = strdup(name);\n     output_driver[driver_max].handler = handler;\n     output_driver[driver_max].handler_data = handler_data;\n     return driver_max++;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "select_output_driver": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nselect_output_driver(const char *name)\n{\n     int i;\n     for (i = 0; i < driver_max; i++)\n\t  if (strcmp(output_driver[i].name, name) == 0) {\n\t       driver_index = i;\n\t       return 0;\n\t  }\n     return -1;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "output_init": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\noutput_init()\n{\n     output_driver[driver_index].handler(cflow_output_init,\n\t\t\t\t\t NULL, 0,\n\t\t\t\t\t NULL,\n\t\t\t\t         output_driver[driver_index].handler_data);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "newline": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\nnewline()\n{\n     output_driver[driver_index].handler(cflow_output_newline,\n\t\t\t\t\t outfile, out_line,\n\t\t\t\t\t NULL,\n\t\t\t\t         output_driver[driver_index].handler_data);\n     out_line++;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "begin": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static void\nbegin()\n{\n     output_driver[driver_index].handler(cflow_output_begin,\n\t\t\t\t\t outfile, out_line,\n\t\t\t\t\t NULL,\n\t\t\t\t\t output_driver[driver_index].handler_data);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "end": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static void\nend()\n{\n     output_driver[driver_index].handler(cflow_output_end,\n\t\t\t\t\t outfile, out_line,\n\t\t\t\t\t NULL,\n\t\t\t\t\t output_driver[driver_index].handler_data);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "separator": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static void\nseparator()\n{\n     output_driver[driver_index].handler(cflow_output_separator,\n\t\t\t\t\t outfile, out_line,\n\t\t\t\t\t NULL,\n\t\t\t\t\t output_driver[driver_index].handler_data);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_text": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static void\nprint_text(char *buf)\n{\n     output_driver[driver_index].handler(cflow_output_text,\n\t\t\t\t\t outfile, out_line,\n\t\t\t\t\t buf,\n\t\t\t\t\t output_driver[driver_index].handler_data);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_symbol": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static int\nprint_symbol (int direct, int level, int last, Symbol *sym)\n{\n     struct output_symbol output_symbol;\n\n     output_symbol.direct = direct;\n     output_symbol.level = level;\n     output_symbol.last = last;\n     output_symbol.sym = sym;\n\n     return output_driver[driver_index].handler(cflow_output_symbol,\n\t\t\t\t\t\toutfile, out_line,\n\t\t\t\t\t\t&output_symbol,\n\t\t\t\t\t\toutput_driver[driver_index].handler_data);\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "compare": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static int\ncompare(const void *ap, const void *bp)\n{\n     Symbol * const *a = ap;\n     Symbol * const *b = bp;\n     return strcmp((*a)->name, (*b)->name);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_var": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "static int\nis_var(Symbol *symp)\n{\n     if (include_symbol(symp)) {\n\t  if (symp->type == SymIdentifier) \n\t       return symp->storage == ExternStorage ||\n\t \t      symp->storage == StaticStorage;\n\t  else\n\t       return 1;\n     }\n     return 0;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "symbol_is_function": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "int\nsymbol_is_function(Symbol *symp)\n{\n     return symp->type == SymIdentifier && symp->arity >= 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "clear_active": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "static void\nclear_active(Symbol *sym)\n{\n     sym->active = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_refs": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "void\nprint_refs(char *name, struct linked_list *reflist)\n{\n     Ref *refptr;\n     struct linked_list_entry *p;\n\n     for (p = linked_list_head(reflist); p; p = p->next) {\n\t  refptr = (Ref*)p->data;\n\t  fprintf(outfile, \"%s   %s:%d\\n\",\n\t\t  name,\n\t\t  refptr->source,\n\t\t  refptr->line);\n     }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print_function": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static void\nprint_function(Symbol *symp)\n{\n     if (symp->source) {\n\t  fprintf(outfile, \"%s * %s:%d %s\\n\",\n\t\t  symp->name,\n\t\t  symp->source,\n\t\t  symp->def_line,\n\t\t  symp->decl);\n     }\n     print_refs(symp->name, symp->ref_line);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_type": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static void\nprint_type(Symbol *symp)\n{\n     if (symp->source)\n\t  fprintf(outfile, \"%s t %s:%d\\n\",\n\t\t  symp->name,\n\t\t  symp->source,\n\t\t  symp->def_line);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xref_output": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "void\nxref_output()\n{\n     Symbol **symbols, *symp;\n     size_t i, num;\n     \n     num = collect_symbols(&symbols, is_var, 0);\n     qsort(symbols, num, sizeof(*symbols), compare);\n     \n     /* produce xref output */\n     for (i = 0; i < num; i++) {\n\t  symp = symbols[i];\n\t  switch (symp->type) {\n\t  case SymIdentifier:\n\t       print_function(symp);\n\t       break;\n\t  case SymToken:\n\t       print_type(symp);\n\t       break;\n\t  case SymUndefined:\n\t       break;\n\t  }\n     }\n     free(symbols);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "set_active": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static void\nset_active(Symbol *sym)\n{\n     sym->active = out_line;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_printable": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static int\nis_printable(struct linked_list_entry *p)\n{\n     return p != NULL && include_symbol((Symbol*)p->data);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_last": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "static int\nis_last(struct linked_list_entry *p)\n{\n     while ((p = p->next))\n\t  if (is_printable(p))\n\t       return 0;\n     return 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "direct_tree": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "static void\ndirect_tree(int lev, int last, Symbol *sym)\n{\n     struct linked_list_entry *p;\n     int rc;\n     \n     if (sym->type == SymUndefined\n\t || (max_depth && lev >= max_depth)\n\t || !include_symbol(sym))\n\t  return;\n\n     rc = print_symbol(1, lev, last, sym);\n     newline();\n     if (rc || sym->active)\n\t  return;\n     set_active(sym);\n     for (p = linked_list_head(sym->callee); p; p = p->next) {\n\t  set_level_mark(lev+1, !is_last(p));\n\t  direct_tree(lev+1, is_last(p), (Symbol*)p->data);\n     }\n     clear_active(sym);\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "inverted_tree": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static void\ninverted_tree(int lev, int last, Symbol *sym)\n{\n     struct linked_list_entry *p;\n     int rc;\n     \n     if (sym->type == SymUndefined\n\t || (max_depth && lev >= max_depth)\n\t || !include_symbol(sym))\n\t  return;\n     rc = print_symbol(0, lev, last, sym);\n     newline();\n     if (rc || sym->active)\n\t  return;\n     set_active(sym);\n     for (p = linked_list_head(sym->caller); p; p = p->next) {\n\t  set_level_mark(lev+1, !is_last(p));\n\t  inverted_tree(lev+1, is_last(p), (Symbol*)p->data);\n     }\n     clear_active(sym);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tree_output": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "static void\ntree_output()\n{\n     Symbol **symbols, *main_sym;\n     size_t i, num;\n     cflow_depmap_t depmap;\n     \n     /* Collect functions and assign them ordinal numbers */\n     num = collect_functions(&symbols);\n     for (i = 0; i < num; i++)\n\t  symbols[i]->ord = i;\n     \n     /* Create a dependency matrix */\n     depmap = depmap_alloc(num);\n     for (i = 0; i < num; i++) {\n\t  if (symbols[i]->callee) {\n\t       struct linked_list_entry *p;\n\t       \n\t       for (p = linked_list_head(symbols[i]->callee); p;\n\t\t    p = p->next) {\n\t\t    Symbol *s = (Symbol*) p->data;\n\t\t    if (symbol_is_function(s))\n\t\t\t depmap_set(depmap, i, ((Symbol*)p->data)->ord);\n\t       }\t\t    \n\t  }\n     }\n     \n     depmap_tc(depmap);\n\n     /* Mark recursive calls */\n     for (i = 0; i < num; i++)\n\t  if (depmap_isset(depmap, i, i))\n\t       symbols[i]->recursive = 1;\n     free(depmap);\n     free(symbols);\n     \n     /* Collect and sort all symbols */\n     num = collect_symbols(&symbols, is_var, 0);\n     qsort(symbols, num, sizeof(*symbols), compare);\n\t       \n     /* Produce output */\n     begin();\n    \n     if (reverse_tree) {\n\t  for (i = 0; i < num; i++) {\n\t       inverted_tree(0, 0, symbols[i]);\n\t       separator();\n\t  }\n     } else {\n\t  main_sym = lookup(start_name);\n\t  if (main_sym) {\n\t       direct_tree(0, 0, main_sym);\n\t       separator();\n\t  } else {\n\t       for (i = 0; i < num; i++) {\n\t\t    if (symbols[i]->callee == NULL)\n\t\t\t continue;\n\t\t    direct_tree(0, 0, symbols[i]);\n\t\t    separator();\n\t       }\n\t  }\n     }\n     \n     end();\n     \n     free(symbols);\n}",
      "lines": 67,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "void\noutput()\n{\n     if (strcmp(outname, \"-\") == 0) {\n\t  outfile = stdout;\n     } else {\n\t  outfile = fopen(outname, \"w\");\n\t  if (!outfile)\n\t       error(EX_FATAL, errno, _(\"cannot open file `%s'\"), outname);\n     } \n     \n     set_level_mark(0, 0);\n     if (print_option & PRINT_XREF) {\n\t  xref_output();\n     }\n     if (print_option & PRINT_TREE) {\n\t  tree_output();\n     }\n     fclose(outfile);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/src/parser.c": {
    "print_token": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static void\nprint_token(TOKSTK *tokptr)\n{\n     switch (tokptr->type) {\n     case IDENTIFIER:\n     case TYPE:\n     case WORD:\n     case MODIFIER:\n     case STRUCT:\n     case PARM_WRAPPER:\n     case QUALIFIER:\n     case OP:\n\t  fprintf(stderr, \"`%s'\", tokptr->token);\n\t  break;\n     case LBRACE0:\n     case LBRACE:\n\t  fprintf(stderr, \"`{'\");\n\t  break;\n     case RBRACE0:\n     case RBRACE:\n\t  fprintf(stderr, \"`}'\");\n\t  break;\n     case EXTERN:\n\t  fprintf(stderr, \"`extern'\");\n\t  break;\n     case STATIC:\n\t  fprintf(stderr, \"`static'\");\n\t  break;\n     case TYPEDEF:\n\t  fprintf(stderr, \"`typedef'\");\n\t  break;\n     case STRING:\n\t  fprintf(stderr, \"\\\"%s\\\"\", tokptr->token);\n\t  break;\n     default:\n\t  fprintf(stderr, \"`%c'\", tokptr->type);\n     }\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "token_type_str": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static char *\ntoken_type_str(int t)\n{\n     static char buf[80];\n     switch (t) {\n     case 0:\n\t  return \"EOF\";\n     case WORD:\n\t  return \"WORD\";\n     case LBRACE0:\n\t  return \"'{'\";\n     case RBRACE0:\n\t  return \"'}'\";\n     case IDENTIFIER:\n\t  return \"IDENTIFIER\";\n     case EXTERN:\n\t  return \"EXTERN\";\n     case STATIC:\n\t  return \"STATIC\";\n     case TYPEDEF:\n\t  return \"TYPEDEF\";\n     case STRUCT:\n\t  return \"STRUCT\";\n     case MODIFIER:\n\t  return \"MODIFIER\";\n     case OP:\n\t  return \"OP\";\n     case UNION:\n\t  return \"UNION\";\n     case ENUM:\n\t  return \"ENUM\";\n     case LBRACE:\n\t  return \"' {'\";\n     case RBRACE:\n\t  return \"' }'\";\n     case MEMBER_OF:\n\t  return \"MEMBER_OF\";\n     case TYPE:\n\t  return \"TYPE\";\n     case STRING:\n\t  return \"STRING\";\n     case PARM_WRAPPER:\n\t  return \"PARM_WRAPPER\";\n     case QUALIFIER:\n\t  return \"QUALIFIER\";\n     }\t  \n     if (isprint(t))\n\t  snprintf(buf, sizeof(buf), \"'%c'(%d)\", t, t);\n     else\n\t  snprintf(buf, sizeof(buf), \"%d\", t);\n     return buf;\n}",
      "lines": 52,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ntoken_type_str(int t)",
        "*"
      ]
    },
    "dbgtok": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static void\ndbgtok(TOKSTK *t, int delim)\n{\n     if (delim)\n\t  fputc(delim, stderr);\n     fprintf(stderr, \"{ %s \", token_type_str(t->type));\n     if (t->type)\n\t  fprintf(stderr, \", %s, %d \", t->token ? t->token : \"NULL\", t->line);\n     fputc('}', stderr);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "debugtoken": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void\ndebugtoken(TOKSTK *t, char *fmt, ...)\n{\n     if (debug > 1) {\n\t  va_list ap;\n\t  int i;\n\t  \n\t  if (fmt) {\n\t       va_start(ap, fmt);\n\t       vfprintf(stderr, fmt, ap);\n\t       va_end(ap);\n\t       fprintf(stderr, \": \");\n\t  }\n\t  if (t) {\n\t       dbgtok(t, 0);\n\t       fprintf(stderr, \"; \");\n\t  }\n\t  fprintf(stderr, \"%d: {\", curs);\n\t  for (i = curs; i < tos; i++)\n\t       dbgtok(token_stack + i, i == curs ? 0 : ',');\n\t  fprintf(stderr, \"}\\n\");\n     }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "file_error": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "static void\nfile_error(char *msg, TOKSTK *tokptr)\n{\n    fprintf(stderr, \"%s:%d: %s\", filename, tok.line, msg);\n    if (tokptr) {\n\tfprintf(stderr, _(\" near \"));\n\tprint_token(tokptr);\n    }\n    fprintf(stderr, \"\\n\");\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mark": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "void\nmark(Stackpos pos)\n{\n     pos[0] = curs;\n     if (debug > 1)\n\t  fprintf(stderr, \"marking stack at %d\\n\", curs);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "restore": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "void\nrestore(Stackpos pos)\n{\n     curs = pos[0];\n     if (curs) {\n\t  tok = token_stack[curs-1];\n\t  debugtoken(&tok, \"restored stack\");\n     }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "tokdel": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "void\ntokdel(int beg, int end)\n{\n     if (end >= beg) {\n\t  if (end < tos)\n\t       memmove(token_stack + beg, token_stack + end + 1,\n\t\t       (end - beg + 1) * sizeof(token_stack[0]));\n\t  tos -= (end - beg + 1);\n     }\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "tokins": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\ntokins(int pos, int type, int line, char *token)\n{\n     if (++tos == token_stack_length) {\n\t  token_stack_length += token_stack_increase;\n\t  token_stack = xrealloc(token_stack,\n\t\t\t\t token_stack_length*sizeof(*token_stack));\n     }\n     memmove(token_stack + pos + 1, token_stack + pos,\n\t     (tos - pos - 1) * sizeof(token_stack[0]));\n     token_stack[pos].type = type;\n     token_stack[pos].token = token;\n     token_stack[pos].line = line;\n     debugtoken(&token_stack[pos], \"insert at %d\", pos);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "tokpush": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "void\ntokpush(int type, int line, char *token)\n{\n     token_stack[tos].type = type;\n     token_stack[tos].token = token;\n     token_stack[tos].line = line;\n     if (++tos == token_stack_length) {\n\t  token_stack_length += token_stack_increase;\n\t  token_stack = xrealloc(token_stack,\n\t\t\t\t token_stack_length*sizeof(*token_stack));\n     }\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "cleanup_stack": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "void\ncleanup_stack()\n{\n     int delta = tos - curs;\n\n     if (delta > 0) \n\t  memmove(token_stack, token_stack+curs, delta*sizeof(token_stack[0]));\n     else if (delta < 0) /* Invalid input */\n\t  delta = 0;\n     tos = delta;\n     curs = 0;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "clearstack": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "void\nclearstack()\n{\n     tos = curs = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "nexttoken": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\nnexttoken()\n{\n     int type;\n     \n     if (curs == tos) {\n\t  type = get_token();\n\t  tokpush(type, line_num, yylval.str);\n\t  yylval.str = NULL;\n     }\n     tok = token_stack[curs];\n     curs++;\n     debugtoken(&tok, \"next token\");\n     return tok.type;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "putback": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "int\nputback()\n{\n     if (curs == 0) {\n\t  error(0, 0, _(\"INTERNAL ERROR: cannot return token to stream\"));\n\t  abort();\n     }\n     curs--;\n     if (curs > 0) {\n\t  tok = token_stack[curs-1];\n     } else\n\t  tok.type = 0;\n     debugtoken(&tok, \"putback\");\n     return tok.type;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "init_parse": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "void\ninit_parse()\n{\n     obstack_init(&text_stk);\n     token_stack = xmalloc(token_stack_length*sizeof(*token_stack));\n     clearstack();\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "save_token": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "void\nsave_token(TOKSTK *tokptr)\n{\n     int len;\n    \n     switch (tokptr->type) {\n     case IDENTIFIER:\n     case TYPE:\n     case STRUCT:\n     case PARM_WRAPPER:\n     case WORD:\n     case QUALIFIER:\n\t  if (need_space) \n\t       obstack_1grow(&text_stk, ' ');\n\t  len = strlen(tokptr->token);\n\t  obstack_grow(&text_stk, tokptr->token, len);\n\t  need_space = 1;\n\t  break;\n     case MODIFIER:\n\t  if (need_space) \n\t       obstack_1grow(&text_stk, ' ');\n\t  if (tokptr->token[0] == '*') \n\t       need_space = 0;\n\t  else\n\t       need_space = 1;\n\t  len = strlen(tokptr->token);\n\t  obstack_grow(&text_stk, tokptr->token, len);\n\t  break;\n     case EXTERN: /* storage class specifiers are already taken care of */\n     case STATIC:\n\t  break;\n     case ',':\n\t  obstack_1grow(&text_stk, ',');\n\t  need_space = 1;\n\t  break;\n     case '(':\n\t  if (need_space) \n\t       obstack_1grow(&text_stk, ' ');\n\t  obstack_1grow(&text_stk, tokptr->type);\n\t  need_space = 0;\n\t  break;\n     case ')':\n\t  obstack_1grow(&text_stk, tokptr->type);\n\t  need_space = 1;\n\t  break;\n     case '[':\n     case ']':\n\t  obstack_1grow(&text_stk, tokptr->type);\n\t  need_space = 0;\n\t  break;\n     case OP:\n\t  obstack_1grow(&text_stk, ' ');\n\t  obstack_grow(&text_stk, tokptr->token, strlen(tokptr->token));\n\t  need_space = 1;\n\t  break;\n     default:\n\t  if (verbose)\n\t       file_error(_(\"unrecognized definition\"), tokptr);\n     }\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "save_stack": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "void\nsave_stack()\n{\n     mark(start_pos);\n     save_end = curs - 1;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "undo_save_stack": {
      "start_point": [
        402,
        0
      ],
      "end_point": [
        406,
        1
      ],
      "content": "void\nundo_save_stack()\n{\n     save_end = -1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "finish_save_stack": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "char *\nfinish_save_stack(char *name)\n{\n     int i;\n     int level = 0;\n     int found_ident = !omit_symbol_names_option;\n\n     need_space = 0;\n     for (i = 0; i < save_end ; i++) {\n\t  switch (token_stack[i].type) {\n\t  case '(':\n\t       if (omit_arguments_option) {\n\t\t    if (level == 0) {\n\t\t\t save_token(token_stack+i);\n\t\t    }\n\t\t    level++;\n\t       }\n\t       break;\n\t  case ')':\n\t       if (omit_arguments_option) \n\t\t    level--;\n\t       break;\n\t  case IDENTIFIER:\n\t       if (!found_ident && strcmp (name, token_stack[i].token) == 0) {\n\t\t    need_space = 1;\n\t\t    found_ident = 1;\n\t\t    continue;\n\t       }\n\t  }\n\t  if (level == 0)\n\t       save_token(token_stack+i);\n     }\n     obstack_1grow(&text_stk, 0);\n     return obstack_finish(&text_stk);\n}",
      "lines": 35,
      "depth": 16,
      "decorators": [
        "char",
        "*\nfinish_save_stack(char *name)",
        "*"
      ]
    },
    "skip_to": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        451,
        1
      ],
      "content": "void\nskip_to(int c)\n{\n     while (nexttoken()) {\n\t  if (tok.type == c)\n\t       break;\n     }\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "skip_balanced": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "int\nskip_balanced(int open_tok, int close_tok, int level)\n{\n     if (level == 0) {\n\t  if (nexttoken() != open_tok) {\n\t       return 1;\n\t  }\n\t  level++;\n     }\n     while (nexttoken()) {\n\t  if (tok.type == LBRACE0 && open_tok == '{')\n\t       tok.type = '{';\n\t  else if (tok.type == RBRACE0 && close_tok == '}')\n\t       tok.type = '}';\n\t  \n\t  if (tok.type == open_tok) \n\t       level++;\n\t  else if (tok.type == close_tok) {\n\t       if (--level == 0) {\n\t\t    nexttoken();\n\t\t    return 0;\n\t       }\n\t  } \n     }\n     return -1;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "yyparse": {
      "start_point": [
        480,
        0
      ],
      "end_point": [
        513,
        1
      ],
      "content": "int\nyyparse()\n{\n     Ident identifier;\n\n     level = 0;\n     caller = NULL;\n     clearstack();\n     while (nexttoken()) {\n\t  identifier.storage = ExternStorage;\n\t  switch (tok.type) {\n\t  case 0:\n\t       return 0;\n\t  case QUALIFIER:\n\t       continue;\n\t  case TYPEDEF:\n\t       parse_typedef();\n\t       break;\n\t  case EXTERN:\n\t       identifier.storage = ExplicitExternStorage;\n\t       parse_declaration(&identifier, 0);\n\t       break;\n\t  case STATIC:\n\t       identifier.storage = StaticStorage;\n\t       nexttoken();\n\t       /* FALLTHRU */\n\t  default:\n\t       parse_declaration(&identifier, 0);\n\t       break;\n\t  }\n\t  cleanup_stack();\n     }\n     return 0;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "is_function": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "static int\nis_function()\n{\n     Stackpos sp;\n     int res = 0;\n\n     mark(sp);\n     while (1) {\n\t  switch (tok.type) {\n\t  case QUALIFIER:\n\t  case TYPE:\n\t  case IDENTIFIER:\n\t  case MODIFIER:\n\t  case STATIC:\n\t  case EXTERN:\n\t  case STRUCT:\n\t  case UNION:\n\t  case ENUM:\n\t       nexttoken();\n\t       continue;\n\t  case PARM_WRAPPER:\n\t       if (skip_balanced('(', ')', 0) == -1)\n\t\t    file_error(_(\"unexpected end of file in declaration\"),\n\t\t\t       NULL);\n\t       continue;\n\t  case '(':\n\t       res = nexttoken() != MODIFIER;\n\t       break;\n\t  default:\n\t       break;\n\t  }\n\t  break;\n     }\n     \n     restore(sp);\n     return res;\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_declaration": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "void\nparse_declaration(Ident *ident, int parm)\n{\n     if (is_function()) \n\t  parse_function_declaration(ident, parm);\n     else\n\t  parse_variable_declaration(ident, parm);\n     delete_parms(parm_level);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "expression": {
      "start_point": [
        564,
        0
      ],
      "end_point": [
        624,
        1
      ],
      "content": "void\nexpression()\n{\n     char *name;\n     int line;\n     int parens_lev;\n\n     parens_lev = 0;\n     while (1) {\n\t  switch (tok.type) {\n\t  case ';':\n\t       return;\n\t  case LBRACE:\n\t  case LBRACE0:\n\t  case RBRACE:\n\t  case RBRACE0:\n\t       putback();\n\t       return;\n\t  case ',':\n\t       if (parens_lev == 0)\n\t\t    return;\n\t       break;\n\t  case 0:\n\t       if (verbose)\n\t\t    file_error(_(\"unexpected end of file in expression\"),\n\t\t\t       NULL);\n\t       return;\n\t    \n\t  case IDENTIFIER:\n\t       name = tok.token;\n\t       line = tok.line;\n\t       nexttoken();\n\t       if (tok.type == '(') {\n\t\t    call(name, line);\n\t\t    parens_lev++;\n\t       } else {\n\t\t    reference(name, line);\n\t\t    if (tok.type == MEMBER_OF) {\n\t\t\t while (tok.type == MEMBER_OF)\n\t\t\t      nexttoken();\n\t\t    } else {\n\t\t\t putback();\n\t\t    }\n\t       }\n\t       break;\n\t  case '(':\n\t       /* maybe typecast */\n\t       if (nexttoken() == TYPE)\n\t\t    skip_to(')');\n\t       else {\n\t\t    putback();\n\t\t    parens_lev++;\n\t       }\n\t       break;\n\t  case ')':\n\t       parens_lev--;\n\t       break;\n\t  }\n\t  nexttoken();\n     }\n}",
      "lines": 61,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "parse_function_declaration": {
      "start_point": [
        626,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "void\nparse_function_declaration(Ident *ident, int parm)\n{\n     int error_recovery = 0;\n     ident->type_end = -1;\n     parse_knr_dcl(ident);\n\n restart:\n     switch (tok.type) {\n     case ')':\n\t  if (parm)\n\t       break;\n\t  /*FALLTHROUGH*/\n     default:\n\t  if (error_recovery) \n\t       nexttoken();\n\t  else {\n\t       if (verbose) \n\t\t    file_error(_(\"expected `;'\"), &tok);\n\t       error_recovery = 1;\n\t  }\n\t  goto restart;\n\t  \n     case ';':\n     case ',':\n\t  break;\n     case LBRACE0:\n     case LBRACE:\n\t  if (ident->name) {\n\t       caller = lookup(ident->name);\n\t       if (caller && caller->storage == AutoStorage)\n\t\t    caller = NULL;\n\t       func_body();\n\t  }\n\t  break;\n     case 0:\n\t  if (verbose)\n\t       file_error(_(\"unexpected end of file in declaration\"), NULL);\n     }\n}",
      "lines": 40,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "fake_struct": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "int\nfake_struct(Ident *ident)\n{\n     Stackpos sp;\n     \n     mark(sp);\n     ident->type_end = -1;\n     if (tok.type == STRUCT) {\n\t  if (nexttoken() == IDENTIFIER) {\n\t       ident->type_end = curs;\n\t  }\n\t  putback();\n\t  skip_struct();\n\t  if (tok.type == IDENTIFIER || tok.type == MODIFIER) {\n\t       int pos = curs-1;\n\t       restore(sp);\n\t       if (ident->type_end == -1) {\n\t\t    /* there was no tag. Insert { ... } */\n\t\t    tokdel(curs, pos - 1);\n\t\t    tokins(curs, IDENTIFIER, tok.line, \"{ ... }\");\n\t\t    debugtoken(&tok, \"modified stack\");\n\t       }\n\t  } else if (tok.type == '(')\n\t       return 0;\n\t  else if (tok.type != ';')\n\t       file_error(_(\"missing `;' after struct declaration\"), &tok);\n\t  return 1;\n     }\n     return 0;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "parse_variable_declaration": {
      "start_point": [
        698,
        0
      ],
      "end_point": [
        766,
        1
      ],
      "content": "void\nparse_variable_declaration(Ident *ident, int parm)\n{\n     Stackpos sp;\n     \n     mark(sp);\n     ident->type_end = -1;\n     if (tok.type == STRUCT || tok.type == UNION) {\n\t  if (nexttoken() == IDENTIFIER) {\n\t       ident->type_end = curs;\n\t  }\n\t  putback();\n\t  skip_struct();\n\t  while (tok.type == MODIFIER || tok.type == QUALIFIER)\n\t       nexttoken();\n\t  if (tok.type == IDENTIFIER) {\n\t       int pos = curs-1;\n\t       restore(sp);\n\t       if (ident->type_end == -1) {\n\t\t    /* there was no tag. Insert { ... } */\n\t\t    tokdel(curs, pos - 1);\n\t\t    tokins(curs, IDENTIFIER, tok.line, \"{ ... }\");\n\t\t    debugtoken(&tok, \"modified stack\");\n\t       }\n\t  } else {\n\t       if (tok.type == ';')\n\t\t    return;\n\t       restore(sp);\n\t  }\n     }\n again:\n     parse_dcl(ident, 0);\n     \n select:    \n     switch (tok.type) {\n     case ')':\n\t  if (parm)\n\t       break;\n\t  /*FALLTHROUGH*/\n     default:\n\t  if (verbose) \n\t       file_error(_(\"expected `;'\"), &tok);\n\t  /* FIXME: should putback() here */\n\t  /* FALLTHRU */\n     case ';':\n\t  break;\n     case ',':\n\t  if (parm)\n\t       break;\n\t  tos = ident->type_end;\n\t  restore(sp);\n\t  goto again;\n     case '=':\n\t  nexttoken();\n\t  if (tok.type == LBRACE || tok.type == LBRACE0)\n\t       initializer_list();\n\t  else\n\t       expression();\n\t  goto select;\n\t  break;\n     case LBRACE0:\n     case LBRACE:\n\t  func_body();\n\t  break;\n     case 0:\n\t  if (verbose)\n\t       file_error(_(\"unexpected end of file in declaration\"), NULL);\n     }\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "initializer_list": {
      "start_point": [
        768,
        0
      ],
      "end_point": [
        797,
        1
      ],
      "content": "void\ninitializer_list()\n{\n     int lev = 0;\n     while (1) {\n\t  switch (tok.type) {\n\t  case LBRACE:\n\t  case LBRACE0:\n\t       lev++;\n\t       break;\n\t  case RBRACE:\n\t  case RBRACE0:\n\t       if (--lev <= 0) {\n\t\t    nexttoken();\n\t\t    return;\n\t       }\n\t       break;\n\t  case 0:\n\t       file_error(_(\"unexpected end of file in initializer list\"),\n\t\t\t  NULL);\n\t       return;\n\t  case ',':\n\t       break;\n\t  default:\n\t       expression();\n\t       break;\n\t  }\n\t  nexttoken();\n     }\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "parse_knr_dcl": {
      "start_point": [
        799,
        0
      ],
      "end_point": [
        804,
        1
      ],
      "content": "void\nparse_knr_dcl(Ident *ident)\n{\n     ident->type_end = -1;\n     parse_dcl(ident, !strict_ansi);     \n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "skip_struct": {
      "start_point": [
        806,
        0
      ],
      "end_point": [
        825,
        1
      ],
      "content": "void\nskip_struct()\n{\n     if (nexttoken() == IDENTIFIER) {\n\t  nexttoken();\n     } else if (tok.type == ';')\n\t  return;\n     \n     if (tok.type == LBRACE || tok.type == LBRACE0) {\n\t  if (skip_balanced('{', '}', 1) == -1) {\n\t       file_error(_(\"unexpected end of file in struct\"), NULL);\n\t       return;\n\t  }\n     }\n\n     while (tok.type == PARM_WRAPPER) {\n\t  if (skip_balanced('(', ')', 0) == -1)\n\t      file_error(_(\"unexpected end of file in struct\"), NULL);\n     }\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "parse_typedef": {
      "start_point": [
        827,
        0
      ],
      "end_point": [
        845,
        1
      ],
      "content": "void\nparse_typedef()\n{\n     Ident ident;\n     \n     ident.name = NULL;\n     ident.type_end = -1;\n     ident.parmcnt = -1;\n     ident.line = -1;\n     ident.storage = AnyStorage;\n     \n     nexttoken();\n     if (!fake_struct(&ident))\n\t  putback();\n     \n     dcl(&ident);\n     if (ident.name) \n\t  declare_type(&ident);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "parse_dcl": {
      "start_point": [
        847,
        0
      ],
      "end_point": [
        859,
        1
      ],
      "content": "void\nparse_dcl(Ident *ident, int maybe_knr)\n{\n     ident->parmcnt = -1;\n     ident->name = NULL;\n     putback();\n     dcl(ident);\n     save_stack();\n     if (ident->name)\n\t  declare(ident, maybe_knr);\n     else \n\t  undo_save_stack();\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dcl": {
      "start_point": [
        861,
        0
      ],
      "end_point": [
        891,
        1
      ],
      "content": "int\ndcl(Ident *idptr)\n{\n     while (nexttoken() != 0 && tok.type != '(') {\n\t  if (tok.type == MODIFIER) {\n\t       if (idptr && idptr->type_end == -1)\n\t\t    idptr->type_end = curs-1;\n\t  } else if (tok.type == PARM_WRAPPER) {\n\t       if (skip_balanced('(', ')', 0) == -1) {\n\t\t    file_error(_(\"unexpected end of file in function declaration\"),\n\t\t\t       NULL);\n\t\t    return 1;\n\t       }\n\t  } else if (tok.type == IDENTIFIER) {\n\t       int type;\n\t       \n\t       while (tok.type == IDENTIFIER)\n\t\t    nexttoken();\n\t       type = tok.type;\n\t       putback();\n\t       if (!(type == TYPE ||\n\t\t     type == MODIFIER || type == QUALIFIER))\n\t\t    break;\n\t  } else if (tok.type == ')' || tok.type == ';') {\n\t       return 1;\n\t  }\n     }\n     if (idptr && idptr->type_end == -1)\n\t  idptr->type_end = curs-1;\n     return dirdcl(idptr);\n}",
      "lines": 31,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "dirdcl": {
      "start_point": [
        893,
        0
      ],
      "end_point": [
        940,
        1
      ],
      "content": "int\ndirdcl(Ident *idptr)\n{\n     int wrapper = 0;\n     int *parm_ptr = NULL;\n     \n     if (tok.type == '(') {\n\t  dcl(idptr);\n\t  if (tok.type != ')' && verbose) {\n\t       file_error(_(\"expected `)'\"), &tok);\n\t       return 1;\n\t  }\n     } else if (tok.type == IDENTIFIER) {\n\t  if (idptr) {\n\t       idptr->name = tok.token;\n\t       idptr->line = tok.line;\n\t       parm_ptr = &idptr->parmcnt;\n\t  }\n     }\n     \n     if (nexttoken() == PARM_WRAPPER) {\n\t  wrapper = 1;\n\t  nexttoken(); /* read '(' */\n     } else\n\t  putback();\n\n     while (nexttoken() == '[' || tok.type == '(') {\n\t  if (tok.type == '[') \n\t       skip_to(']');\n\t  else {\n\t       maybe_parm_list(parm_ptr);\n\t       if (tok.type != ')' && verbose) {\n\t\t    file_error(_(\"expected `)'\"), &tok);\n\t\t    return 1;\n\t       }\n\t  }\n     }\n     if (wrapper)\n\t  nexttoken(); /* read ')' */\n\n     while (tok.type == PARM_WRAPPER) {\n\t  if (skip_balanced('(', ')', 0) == -1)\n\t       file_error(_(\"unexpected end of file in function declaration\"),\n\t\t\t  NULL);\n     }\n     \n     return 0;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "parmdcl": {
      "start_point": [
        942,
        0
      ],
      "end_point": [
        964,
        1
      ],
      "content": "int\nparmdcl(Ident *idptr)\n{\n     int type;\n\n     while (nexttoken() != 0 && tok.type != '(') {\n\t  if (tok.type == MODIFIER) {\n\t       if (idptr && idptr->type_end == -1)\n\t\t    idptr->type_end = curs-1;\n\t  } else if (tok.type == IDENTIFIER) {\n\t       while (tok.type == IDENTIFIER)\n\t\t    nexttoken();\n\t       type = tok.type;\n\t       putback();\n\t       if (type != MODIFIER) \n\t\t    break;\n\t  } else if (tok.type == ')' || tok.type == ',') \n\t       return 0;\n     }\n     if (idptr && idptr->type_end == -1)\n\t  idptr->type_end = curs-1;\n     return dirdcl(idptr);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "maybe_parm_list": {
      "start_point": [
        967,
        0
      ],
      "end_point": [
        1014,
        1
      ],
      "content": "void\nmaybe_parm_list(int *parm_cnt_return)\n{\n     int parmcnt = 0;\n     Ident ident;\n     int level;\n\n     parm_level++;\n     while (nexttoken()) {\n\t  switch (tok.type) {\n\t  case ')':\n\t       if (parm_cnt_return)\n\t\t    *parm_cnt_return = parmcnt;\n\t       parm_level--;\n\t       return;\n\t  case ',':\n\t       break;\n\t  case QUALIFIER:\n\t  case IDENTIFIER:\n\t  case MODIFIER: /* unsigned * */\n\t  case STRUCT:\n\t  case UNION:\n\t  case TYPE:\n\t       parmcnt++;\n\t       ident.storage = AutoStorage;\n\t       parse_declaration(&ident, 1);\n\t       putback();\n\t       break;\n\t  default:\n\t       if (verbose)\n\t\t    file_error(_(\"unexpected token in parameter list\"),\n\t\t\t       &tok);\n\t       level = 0;\n\t       do {\n\t\t    if (tok.type == '(') \n\t\t\t level++;\n\t\t    else if (tok.type == ')') {\n\t\t\t if (level-- == 0)\n\t\t\t      break;\n\t\t    }\n\t       } while (nexttoken());\n\t\t    ;\n\t       putback();\n\t  }\n     }\n     if (verbose)\n\t  file_error(_(\"unexpected end of file in parameter list\"), NULL);\n}",
      "lines": 48,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "func_body": {
      "start_point": [
        1016,
        0
      ],
      "end_point": [
        1072,
        1
      ],
      "content": "void\nfunc_body()\n{\n     Ident ident;\n     \n     level++;\n     move_parms(level);\n     while (level) {\n\t  cleanup_stack();\n\t  nexttoken();\n\t  switch (tok.type) {\n\t  default:\n\t       expression();\n\t       break;\n\t  case STATIC:\n\t       ident.storage = StaticStorage;\n\t       nexttoken();\n\t       parse_variable_declaration(&ident, 0);\n\t       break;\n\t  case TYPE:\n\t  case STRUCT:\n\t       ident.storage = AutoStorage;\n\t       parse_variable_declaration(&ident, 0);\n\t       break;\n\t  case EXTERN:\n\t       ident.storage = ExplicitExternStorage;\n\t       parse_declaration(&ident, 0);\n\t       break;\n\t  case LBRACE0:\n\t  case '{':\n\t       level++;\n\t       break;\n\t  case RBRACE0:\n\t       if (use_indentation) {\n\t\t    if (verbose && level != 1)\n\t\t\t file_error(_(\"forced function body close\"), NULL);\n\t\t    for ( ; level; level--) {\n\t\t\t delete_autos(level);\n\t\t    }\n\t\t    break;\n\t       }\n\t       /* else: */\n\t       /* FALLTHRU */\n\t  case '}':\n\t       delete_autos(level);\n\t       level--;\n\t       break;\n\t  case 0:\n\t       if (verbose)\n\t\t    file_error(_(\"unexpected end of file in function body\"),\n\t\t\t       NULL);\n\t       caller = NULL;\n\t       return;\n\t  }\n     }\n     caller = NULL;\n}",
      "lines": 57,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "get_knr_args": {
      "start_point": [
        1074,
        0
      ],
      "end_point": [
        1125,
        1
      ],
      "content": "int\nget_knr_args(Ident *ident)\n{\n     int parmcnt, stop;\n     Stackpos sp, new_sp;\n     Ident id;\n\n     switch (tok.type) {\n     case IDENTIFIER:\n     case TYPE:\n     case STRUCT:\n\t  /* maybe K&R function definition */\n\t  \n\t  mark(sp);\n\t  parmcnt = 0;\n\t  \n\t  for (stop = 0; !stop && parmcnt < ident->parmcnt;\n\t       nexttoken()) {\n\t       id.type_end = -1;\n\t       switch (tok.type) {\n\t       case LBRACE:\n\t       case LBRACE0:\n\t\t    putback();\n\t\t    stop = 1;\n\t\t    break;\n\t       case TYPE:\n\t       case IDENTIFIER:\n\t       case STRUCT:\n\t\t    putback();\n\t\t    mark(new_sp);\n\t\t    if (dcl(&id) == 0) {\n\t\t\t parmcnt++;\n\t\t\t if (tok.type == ',') {\n\t\t\t      do {\n\t\t\t\t   tos = id.type_end; /* ouch! */\n\t\t\t\t   restore(new_sp);\n\t\t\t\t   dcl(&id);\n\t\t\t      } while (tok.type == ',');\n\t\t\t } else if (tok.type != ';')\n\t\t\t      putback();\n\t\t\t break;\n\t\t    }\n\t\t    /* else */\n\t\t    /* FALLTHRU */\n\t       default:\n\t\t    restore(sp);\n\t\t    return 1;\n\t       }\n\t  }\n     }\n     return 0;\n}",
      "lines": 52,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "declare": {
      "start_point": [
        1127,
        0
      ],
      "end_point": [
        1188,
        1
      ],
      "content": "void\ndeclare(Ident *ident, int maybe_knr)\n{\n     Symbol *sp;\n     \n     if (ident->storage == AutoStorage) {\n\t  undo_save_stack();\n\t  sp = install_ident(ident->name, ident->storage);\n\t  if (parm_level) {\n\t       sp->level = parm_level;\n\t       sp->flag = symbol_parm;\n\t  } else\n\t       sp->level = level;\n\t  sp->arity = -1;\n\t  return;\n     } \n\n     if ((ident->parmcnt >= 0\n\t  && (!maybe_knr || get_knr_args(ident) == 0)\n\t  && !(tok.type == LBRACE || tok.type == LBRACE0 || tok.type == TYPE\n\t       || tok.type == PARM_WRAPPER))\n\t || (ident->parmcnt < 0 && ident->storage == ExplicitExternStorage)) {\n\t  undo_save_stack();\n\t  /* add_external()?? */\n\t  return;\n     }\n     \n     sp = get_symbol(ident->name);\n     if (sp->source) {\n\t  if (ident->storage == StaticStorage\n\t      && (sp->storage != StaticStorage || level > 0)) {\n\t       sp = install_ident(ident->name, ident->storage);\n\t  } else {\n\t       if (sp->arity >= 0)\n\t\t    error_at_line(0, 0, filename, ident->line, \n\t\t\t\t  _(\"%s/%d redefined\"),\n\t\t\t\t  ident->name, sp->arity);\n\t       else\n\t\t    error_at_line(0, 0, filename, ident->line, \n\t\t\t\t  _(\"%s redefined\"),\n\t\t\t\t  ident->name);\n\t       error_at_line(0, 0, sp->source, sp->def_line,\n\t\t\t     _(\"this is the place of previous definition\"));\n\t  }\n     }\n\n     sp->type = SymIdentifier;\n     sp->arity = ident->parmcnt;\n     ident_change_storage(sp, \n\t\t\t  (ident->storage == ExplicitExternStorage) ?\n\t\t\t  ExternStorage : ident->storage);\n     sp->decl = finish_save_stack(ident->name);\n     sp->source = filename;\n     sp->def_line = ident->line;\n     sp->level = level;\n     if (debug)\n\t  fprintf(stderr, _(\"%s:%d: %s/%d defined to %s\\n\"),\n\t\t filename,\n\t\t line_num,\n\t\t ident->name, ident->parmcnt,\n\t\t sp->decl);\n}",
      "lines": 62,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "declare_type": {
      "start_point": [
        1190,
        0
      ],
      "end_point": [
        1210,
        1
      ],
      "content": "void\ndeclare_type(Ident *ident)\n{\n     Symbol *sp;\n     \n     undo_save_stack();\n     sp = lookup(ident->name);\n     for ( ; sp; sp = sp->next)\n\t  if (sp->type == SymToken && sp->token_type == TYPE)\n\t       break;\n     if (!sp)\n\t  sp = install(ident->name, INSTALL_UNIT_LOCAL);\n     sp->type = SymToken;\n     sp->token_type = TYPE;\n     sp->source = filename;\n     sp->def_line = ident->line;\n     sp->ref_line = NULL;\n     if (debug)\n\t  fprintf(stderr, _(\"%s:%d: type %s\\n\"), filename, line_num,\n\t\t  ident->name);\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "get_symbol": {
      "start_point": [
        1212,
        0
      ],
      "end_point": [
        1226,
        1
      ],
      "content": "Symbol *\nget_symbol(char *name)\n{\n     Symbol *sp = lookup(name) ;\n     \n     if (sp) {\n\t  for (; sp; sp = sp->next) {\n\t       if (sp->type == SymIdentifier && strcmp(sp->name, name) == 0)\n\t\t    break;\n\t  }\n\t  if (sp)\n\t       return sp;\n     }\n     return install_ident(name, ExternStorage);\n}",
      "lines": 15,
      "depth": 14,
      "decorators": [
        "Symbol",
        "*\nget_symbol(char *name)",
        "*"
      ]
    },
    "add_reference": {
      "start_point": [
        1228,
        0
      ],
      "end_point": [
        1244,
        1
      ],
      "content": "Symbol *\nadd_reference(char *name, int line)\n{\n     Symbol *sp = get_symbol(name);\n     Ref *refptr;\n\n     if (sp->storage == AutoStorage\n\t || (sp->storage == StaticStorage && globals_only()))\n\t  return NULL;\n     refptr = xmalloc(sizeof(*refptr));\n     refptr->source = filename;\n     refptr->line = line;\n     if (!sp->ref_line)\n\t  sp->ref_line = linked_list_create(free);\n     linked_list_append(&sp->ref_line, refptr);\n     return sp;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "Symbol",
        "*\nadd_reference(char *name, int line)",
        "*"
      ]
    },
    "call": {
      "start_point": [
        1247,
        0
      ],
      "end_point": [
        1263,
        1
      ],
      "content": "void\ncall(char *name, int line)\n{\n     Symbol *sp;\n\n     sp = add_reference(name, line);\n     if (!sp)\n\t  return;\n     if (sp->arity < 0)\n\t  sp->arity = 0;\n     if (caller) {\n\t  if (!data_in_list(caller, sp->caller))\n\t       linked_list_append(&sp->caller, caller);\n\t  if (!data_in_list(sp, caller->callee))\n\t       linked_list_append(&caller->callee, sp);\n     }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "reference": {
      "start_point": [
        1265,
        0
      ],
      "end_point": [
        1277,
        1
      ],
      "content": "void\nreference(char *name, int line)\n{\n     Symbol *sp = add_reference(name, line);\n     if (!sp)\n\t  return;\n     if (caller) {\n\t  if (!data_in_list(caller, sp->caller))\n\t       linked_list_append(&sp->caller, caller);\n\t  if (!data_in_list(sp, caller->callee))\n\t       linked_list_append(&caller->callee, sp);\n     }\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/src/parser.h": {},
  "cflow/cflow-1.5/src/posix.c": {
    "print_symbol_type": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void\nprint_symbol_type(FILE *outfile, Symbol *sym)\n{\n     if (sym->decl) \n\t  fprintf(outfile, \"%s, <%s %d>\",\n\t\t  sym->decl,\n\t\t  sym->source,\n\t\t  sym->def_line);\n     else\n\t  fprintf(outfile, \"<>\");\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_symbol": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static int\nprint_symbol(FILE *outfile, int line, struct output_symbol *s)\n{\n     print_level(s->level, s->last);\n     fprintf(outfile, \"%s: \", s->sym->name);\n     \n     if (brief_listing) {\n\t  if (s->sym->expand_line) {\n\t       fprintf(outfile, \"%d\", s->sym->expand_line);\n\t       return 1;\n\t  } else if (s->sym->callee)\n\t       s->sym->expand_line = line;\n     }\n     print_symbol_type(outfile, s->sym);\n     return 0;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "posix_output_handler": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\nposix_output_handler(cflow_output_command cmd,\n\t\t     FILE *outfile, int line,\n\t\t     void *data, void *handler_data)\n{\n     switch (cmd) {\n     case cflow_output_init:\n\t  /* Additional check for consistency */\n\t  if (emacs_option)\n\t       error(EX_USAGE, 0,\n\t\t     _(\"--format=posix is not compatible with --emacs\"));\n\t  brief_listing = print_line_numbers = omit_symbol_names_option = 1;\n\t  break;\n     case cflow_output_begin:\n     case cflow_output_end:\n     case cflow_output_separator:\n\t  break;\n     case cflow_output_newline:\n\t  fprintf(outfile, \"\\n\");\n\t  break;\n     case cflow_output_text:\n\t  fprintf(outfile, \"%s\", (char*) data);\n\t  break;\n     case cflow_output_symbol:\n\t  return print_symbol(outfile, line, data);\n     }\n     return 0;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "cflow/cflow-1.5/src/rc.c": {
    "expand_argcv": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static void\nexpand_argcv(int *argc_ptr, char ***argv_ptr, int argc, char **argv)\n{\n     int i;\n     \n     *argv_ptr = xrealloc(*argv_ptr,\n\t\t\t  (*argc_ptr + argc + 1) * sizeof **argv_ptr);\n     for (i = 0; i < argc; i++)\n\t  (*argv_ptr)[*argc_ptr + i] = xstrdup(argv[i]);\n     (*argv_ptr)[*argc_ptr + i] = NULL;\n     *argc_ptr += argc;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_rc": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "void\nparse_rc(int *argc_ptr, char ***argv_ptr, char *name)\n{\n     struct stat st;\n     FILE *rcfile;\n     int size;\n     char *buf, *p;\n     struct wordsplit ws;\n     int wsflags;\n     int line;\n     \n     if (stat(name, &st))\n\t  return;\n     buf = xmalloc(st.st_size+1);\n     rcfile = fopen(name, \"r\");\n     if (!rcfile) {\n\t  error(EX_FATAL, errno, _(\"cannot open `%s'\"), name);\n\t  return;\n     }\n     size = fread(buf, 1, st.st_size, rcfile);\n     buf[size] = 0;\n     fclose(rcfile);\n\n     ws.ws_comment = \"#\";\n     wsflags = WRDSF_DEFFLAGS | WRDSF_COMMENT;\n     line = 0;\n     for (p = strtok(buf, \"\\n\"); p; p = strtok(NULL, \"\\n\")) {\n\t  ++line;\n\t  if (wordsplit(p, &ws, wsflags))\n\t       error(EX_FATAL, 0, \"%s:%d: %s\",\n\t\t     name, line, wordsplit_strerror(&ws));\n\t  wsflags |= WRDSF_REUSE;\n\t  if (ws.ws_wordc)\n\t       expand_argcv(argc_ptr, argv_ptr, ws.ws_wordc, ws.ws_wordv);\n     }\n     if (wsflags & WRDSF_REUSE)\n\t  wordsplit_free(&ws);\n     free(buf);\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "sourcerc": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\nsourcerc(int *argc_ptr, char ***argv_ptr)\n{\n     char *env;\n     int xargc = 1;\n     char **xargv; \n\n     xargv = xmalloc(2*sizeof *xargv);\n     xargv[0] = **argv_ptr;\n     xargv[1] = NULL;\n     \n     env = getenv(\"CFLOW_OPTIONS\");\n     if (env) {\n\t  struct wordsplit ws;\n\n\t  ws.ws_comment = \"#\";\n\t  if (wordsplit(env, &ws, WRDSF_DEFFLAGS | WRDSF_COMMENT))\n\t       error(EX_FATAL, 0, \"failed to parse CFLOW_OPTIONS: %s\",\n\t\t     wordsplit_strerror(&ws));\n\t  if (ws.ws_wordc)\n\t       expand_argcv(&xargc, &xargv, ws.ws_wordc, ws.ws_wordv);\n\t  wordsplit_free(&ws);\n     }\n\n     env = getenv(\"CFLOWRC\");\n     if (env) \n\t  parse_rc(&xargc, &xargv, env);\n     else {\n\t  char *home = getenv(\"HOME\");\n\t  if (home) {\n\t       int len = strlen(home);\n\t       char *buf = malloc(len + sizeof(LOCAL_RC)\n\t\t\t\t  + (home[len-1] != '/') );\n\t       if (!buf)\n\t\t    return;\n\t       strcpy(buf, home);\n\t       if (home[len-1] != '/')\n\t\t    buf[len++] = '/';\n\t       strcpy(buf+len, LOCAL_RC);\n\t       parse_rc(&xargc, &xargv, buf);\n\t       free(buf);\n\t  }\n     }\n     \n     if (xargc > 1) {\n\t  expand_argcv(&xargc, &xargv, *argc_ptr-1, *argv_ptr+1);\n\t  *argc_ptr = xargc;\n\t  *argv_ptr = xargv;\n     }\n}",
      "lines": 50,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/src/symbol.c": {
    "append_symbol": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static void\nappend_symbol(struct linked_list **plist, Symbol *sp)\n{\n     if (sp->entry) {\n\t  linked_list_unlink(sp->entry->list, sp->entry);\n\t  sp->entry = NULL;\n     }\n     if (!data_in_list(sp, *plist)) {\n\t  linked_list_append(plist, sp);\n\t  sp->entry = (*plist)->tail;\n     }\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hash_symbol_hasher": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static size_t\nhash_symbol_hasher(void const *data, size_t n_buckets)\n{\n     struct table_entry const *t = data;\n     if (!t->sym)\n\t  return ((size_t) data) % n_buckets;\n     return hash_string(t->sym->name, n_buckets);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "hash_symbol_compare": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static bool\nhash_symbol_compare(void const *data1, void const *data2)\n{\n     struct table_entry const *t1 = data1;\n     struct table_entry const *t2 = data2;\n     return t1->sym && t2->sym && strcmp(t1->sym->name, t2->sym->name) == 0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "lookup": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "Symbol *\nlookup(const char *name)\n{\n     Symbol s, *sym;\n     struct table_entry t, *tp;\n     \n     if (!symbol_table)\n\t  return NULL;\n     s.name = (char*) name;\n     t.sym = &s;\n     tp = hash_lookup(symbol_table, &t);\n     if (tp) {\n\t  sym = tp->sym;\n\t  while (sym->type == SymToken && sym->flag == symbol_alias)\n\t       sym = sym->alias;\n     } else\n\t  sym = NULL;\n     return sym;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "Symbol",
        "*\nlookup(const char *name)",
        "*"
      ]
    },
    "install": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "Symbol *\ninstall(char *name, int flags)\n{\n     Symbol *sym;\n     struct table_entry *tp, *ret;\n     \n     sym = xmalloc(sizeof(*sym));\n     memset(sym, 0, sizeof(*sym));\n     sym->type = SymUndefined;\n     sym->name = name;\n\n     tp = xmalloc(sizeof(*tp));\n     tp->sym = sym;\n     \n     if (((flags & INSTALL_CHECK_LOCAL) &&\n\t  canonical_filename && strcmp(filename, canonical_filename)) ||\n\t (flags & INSTALL_UNIT_LOCAL)) {\n\t  sym->flag = symbol_temp;\n\t  append_symbol(&static_symbol_list, sym);\n     } else\n\t  sym->flag = symbol_none;\n     \n     if (! ((symbol_table\n\t     || (symbol_table = hash_initialize (0, 0, \n\t\t\t\t\t\t hash_symbol_hasher,\n\t\t\t\t\t\t hash_symbol_compare, 0)))\n\t    && (ret = hash_insert (symbol_table, tp))))\n\t  xalloc_die ();\n\n     if (ret != tp) {\n\t  if (flags & INSTALL_OVERWRITE) {\n\t       free(sym);\n\t       free(tp);\n\t       return ret->sym;\n\t  }\n\t  if (ret->sym->type != SymUndefined) \n\t       sym->next = ret->sym;\n\t  ret->sym = sym;\n\t  free(tp);\n     }\n     sym->owner = ret;\n     return sym;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "Symbol",
        "*\ninstall(char *name, int flags)",
        "*"
      ]
    },
    "ident_change_storage": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nident_change_storage(Symbol *sp, enum storage storage)\n{\n     if (sp->storage == storage)\n\t  return;\n     if (sp->storage == StaticStorage)\n\t  /* FIXME */;\n\n     switch (storage) {\n     case StaticStorage:\n\t  append_symbol(&static_symbol_list, sp);\n\t  break;\n     case AutoStorage:\n\t  append_symbol(&auto_symbol_list, sp);\n\t  break;\n     default:\n\t  break;\n     }\n     sp->storage = storage;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "install_ident": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "Symbol *\ninstall_ident(char *name, enum storage storage)\n{\n     Symbol *sp;\n\n     sp = install(name, \n                  storage != AutoStorage ? \n                     INSTALL_CHECK_LOCAL : INSTALL_DEFAULT);\n     sp->type = SymIdentifier;\n     sp->arity = -1;\n     sp->storage = ExternStorage;\n     sp->decl = NULL;\n     sp->source = NULL;\n     sp->def_line = -1;\n     sp->ref_line = NULL;\n     sp->caller = sp->callee = NULL;\n     sp->level = -1;\n     ident_change_storage(sp, storage);\n     return sp;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "Symbol",
        "*\ninstall_ident(char *name, enum storage storage)",
        "*"
      ]
    },
    "unlink_symbol": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static void\nunlink_symbol(Symbol *sym)\n{\n     Symbol *s, *prev = NULL;\n     struct table_entry *tp = sym->owner;\n     for (s = tp->sym; s; ) {\n\t  Symbol *next = s->next;\n\t  if (s == sym) {\n\t       if (prev)\n\t\t    prev->next = next;\n\t       else\n\t\t    tp->sym = next;\n\t       break;\n\t  } else\n\t       prev = s;\n\t  s = next;\n     }\n\t       \n     sym->owner = NULL;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delete_symbol": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static void\ndelete_symbol(Symbol *sym)\n{\n     unlink_symbol(sym);\n     /* The symbol could have been referenced even if it is static\n\tin -i^s mode. See tests/static.at for details. */\n     if (sym->ref_line == NULL && !(reverse_tree && sym->callee)) {\n\t  linked_list_destroy(&sym->ref_line);\n\t  linked_list_destroy(&sym->caller);\n\t  linked_list_destroy(&sym->callee);\n\t  free(sym);\n     }\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "static_free": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "static void\nstatic_free(void *data)\n{\n     Symbol *sym = data;\n     struct table_entry *t = sym->owner;\n\n     if (!t)\n\t  return;\n     if (sym->flag == symbol_temp) \n\t  delete_symbol(sym);\n     else {\n\t  unlink_symbol(sym);\n\t  if (symbol_is_function(sym))\n\t       linked_list_append(&static_func_list, sym);\n     }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delete_statics": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "void\ndelete_statics()\n{\n     if (static_symbol_list) {\n\t  static_symbol_list->free_data = static_free;\n\t  linked_list_destroy(&static_symbol_list);\n     }\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "delete_level_autos": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "int\ndelete_level_autos(void *data, void *call_data)\n{\n     int level = *(int*)call_data;\n     Symbol *s = data;\n     if (s->level == level) {\n\t  delete_symbol(s);\n\t  return 1;\n     }\n     return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "delete_level_statics": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "int\ndelete_level_statics(void *data, void *call_data)\n{\n     int level = *(int*)call_data;\n     Symbol *s = data;\n     if (s->level == level) {\n\t  unlink_symbol(s);\n\t  return 1;\n     }\n     return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "delete_autos": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "void\ndelete_autos(int level)\n{\n     linked_list_iterate(&auto_symbol_list, delete_level_autos, &level);\n     linked_list_iterate(&static_symbol_list, delete_level_statics, &level);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "collect_processor": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "static bool\ncollect_processor(void *data, void *proc_data)\n{\n     struct table_entry *t = data;\n     struct collect_data *cd = proc_data;\n     Symbol *s;\n     for (s = t->sym; s; s = s->next) {\n\t  if (cd->sel(s)) {\n\t       if (cd->sym)\n\t\t    cd->sym[cd->index] = s;\n\t       cd->index++;\n\t  }\n     }\n     return true;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "collect_symbols": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "size_t\ncollect_symbols(Symbol ***return_sym, int (*sel)(Symbol *p),\n\t\tsize_t reserved_slots)\n{\n     struct collect_data cdata;\n\n     cdata.sym = NULL;\n     cdata.index = 0;\n     cdata.sel = sel;\n     hash_do_for_each (symbol_table, collect_processor, &cdata);\n     cdata.sym = calloc(cdata.index + reserved_slots, sizeof(*cdata.sym));\n     if (!cdata.sym)\n\t  xalloc_die();\n     cdata.index = 0;\n     hash_do_for_each (symbol_table, collect_processor, &cdata);\n     *return_sym = cdata.sym;\n     return cdata.index;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "collect_functions": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "size_t\ncollect_functions(Symbol ***return_sym)\n{\n     Symbol **symbols;\n     size_t num, snum;\n     struct linked_list_entry *p;\n\n     /* Count static functions */\n     snum = 0;\n     if (static_func_list)\n\t  for (p = linked_list_head(static_func_list); p; p = p->next)\n\t       snum++;\n     \n     /* Collect global functions */\n     num = collect_symbols(&symbols, symbol_is_function, snum);\n\n     /* Collect static functions */\n     if (snum) \n\t  for (p = linked_list_head(static_func_list); p; p = p->next)\n\t       symbols[num++] = p->data;\n     *return_sym = symbols;\n     return num;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    },
    "delete_parms_itr": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "int\ndelete_parms_itr(void *data, void *call_data)\n{\n     int level = *(int*)call_data;\n     Symbol *s = data;\n     struct table_entry *t = s->owner;\n\t  \n     if (!t)\n\t  return 1;\n     if (s->type == SymIdentifier && s->storage == AutoStorage\n\t && s->flag == symbol_parm && s->level > level) {\n\t  delete_symbol(s);\n\t  return 1;\n     }\n     return 0;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "delete_parms": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "void\ndelete_parms(int level)\n{\n     linked_list_iterate(&auto_symbol_list, delete_parms_itr, &level);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "move_parms": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "void\nmove_parms(int level)\n{\n     struct linked_list_entry *p;\n\n     for (p = linked_list_head(auto_symbol_list); p; p = p->next) {\n\t  Symbol *s = p->data;\n\n\t  if (s->type == SymIdentifier && s->storage == AutoStorage\n\t      && s->flag == symbol_parm) {\n\t       s->level = level;\n\t       s->flag = symbol_none;\n\t  }\n     }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "cflow/cflow-1.5/src/wordsplit.c": {
    "_wsplt_alloc_die": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static void\n_wsplt_alloc_die (struct wordsplit *wsp)\n{\n  wsp->ws_error (_(\"memory exhausted\"));\n  abort ();\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_wsplt_error": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static void\n_wsplt_error (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n  fputc ('\\n', stderr);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_wsplt_nomem": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static int\n_wsplt_nomem (struct wordsplit *wsp)\n{\n  errno = ENOMEM;\n  wsp->ws_errno = WRDSE_NOSPACE;\n  if (wsp->ws_flags & WRDSF_ENOMEMABRT)\n    wsp->ws_alloc_die (wsp);\n  if (wsp->ws_flags & WRDSF_SHOWERR)\n    wordsplit_perror (wsp);\n  if (!(wsp->ws_flags & WRDSF_REUSE))\n    wordsplit_free (wsp);\n  wordsplit_free_nodes (wsp);\n  return wsp->ws_errno;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_init0": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static void\nwordsplit_init0 (struct wordsplit *wsp)\n{\n  if (wsp->ws_flags & WRDSF_REUSE)\n    {\n      if (!(wsp->ws_flags & WRDSF_APPEND))\n\twordsplit_free_words (wsp);\n    }\n  else\n    {\n      wsp->ws_wordv = NULL;\n      wsp->ws_wordc = 0;\n      wsp->ws_wordn = 0;\n    }\n\n  wsp->ws_errno = 0;\n  wsp->ws_head = wsp->ws_tail = NULL;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_init": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static int\nwordsplit_init (struct wordsplit *wsp, const char *input, size_t len,\n\t\tint flags)\n{\n  wsp->ws_flags = flags;\n\n  if (!(wsp->ws_flags & WRDSF_ALLOC_DIE))\n    wsp->ws_alloc_die = _wsplt_alloc_die;\n  if (!(wsp->ws_flags & WRDSF_ERROR))\n    wsp->ws_error = _wsplt_error;\n\n  if (!(wsp->ws_flags & WRDSF_NOVAR)\n      && !(wsp->ws_flags & (WRDSF_ENV | WRDSF_GETVAR)))\n    {\n      errno = EINVAL;\n      wsp->ws_errno = WRDSE_USAGE;\n      if (wsp->ws_flags & WRDSF_SHOWERR)\n\twordsplit_perror (wsp);\n      return wsp->ws_errno;\n    }\n\n  if (!(wsp->ws_flags & WRDSF_NOCMD))\n    {\n      errno = EINVAL;\n      wsp->ws_errno = WRDSE_NOSUPP;\n      if (wsp->ws_flags & WRDSF_SHOWERR)\n\twordsplit_perror (wsp);\n      return wsp->ws_errno;\n    }\n\n  if (wsp->ws_flags & WRDSF_SHOWDBG)\n    {\n      if (!(wsp->ws_flags & WRDSF_DEBUG))\n\t{\n\t  if (wsp->ws_flags & WRDSF_ERROR)\n\t    wsp->ws_debug = wsp->ws_error;\n\t  else if (wsp->ws_flags & WRDSF_SHOWERR)\n\t    wsp->ws_debug = _wsplt_error;\n\t  else\n\t    wsp->ws_flags &= ~WRDSF_SHOWDBG;\n\t}\n    }\n\n  wsp->ws_input = input;\n  wsp->ws_len = len;\n\n  if (!(wsp->ws_flags & WRDSF_DOOFFS))\n    wsp->ws_offs = 0;\n\n  if (!(wsp->ws_flags & WRDSF_DELIM))\n    wsp->ws_delim = \" \\t\\n\";\n\n  if (!(wsp->ws_flags & WRDSF_COMMENT))\n    wsp->ws_comment = NULL;\n\n  if (!(wsp->ws_flags & WRDSF_CLOSURE))\n    wsp->ws_closure = NULL;\n\n  wsp->ws_endp = 0;\n\n  wordsplit_init0 (wsp);\n\n  return 0;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloc_space": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static int\nalloc_space (struct wordsplit *wsp, size_t count)\n{\n  size_t offs = (wsp->ws_flags & WRDSF_DOOFFS) ? wsp->ws_offs : 0;\n  char **ptr;\n  size_t newalloc;\n\n  if (wsp->ws_wordv == NULL)\n    {\n      newalloc = offs + count > ALLOC_INIT ? count : ALLOC_INIT;\n      ptr = calloc (newalloc, sizeof (ptr[0]));\n    }\n  else if (wsp->ws_wordn < offs + wsp->ws_wordc + count)\n    {\n      newalloc = offs + wsp->ws_wordc +\n\t(count > ALLOC_INCR ? count : ALLOC_INCR);\n      ptr = realloc (wsp->ws_wordv, newalloc * sizeof (ptr[0]));\n    }\n  else\n    return 0;\n\n  if (ptr)\n    {\n      wsp->ws_wordn = newalloc;\n      wsp->ws_wordv = ptr;\n    }\n  else\n    return _wsplt_nomem (wsp);\n  return 0;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "the": {
      "start_point": [
        214,
        7
      ],
      "end_point": [
        230,
        1
      ],
      "content": "segment even if it is empty */\n\nstruct wordsplit_node\n{\n  struct wordsplit_node *prev;\t/* Previous element */\n  struct wordsplit_node *next;\t/* Next element */\n  int flags;\t\t\t/* Node flags */\n  union\n  {\n    struct\n    {\n      size_t beg;\t\t/* Start of word in ws_input */\n      size_t end;\t\t/* End of word in ws_input */\n    } segm;\n    char *word;\n  } v;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": null
    },
    "wsnode_flagstr": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static const char *\nwsnode_flagstr (int flags)\n{\n  static char retbuf[6];\n  char *p = retbuf;\n\n  if (flags & _WSNF_WORD)\n    *p++ = 'w';\n  else if (flags & _WSNF_NULL)\n    *p++ = 'n';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_QUOTE)\n    *p++ = 'q';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_NOEXPAND)\n    *p++ = 'E';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_JOIN)\n    *p++ = 'j';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_SEXP)\n    *p++ = 's';\n  else\n    *p++ = '-';\n  *p = 0;\n  return retbuf;\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nwsnode_flagstr (int flags)",
        "*"
      ]
    },
    "wsnode_ptr": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static const char *\nwsnode_ptr (struct wordsplit *wsp, struct wordsplit_node *p)\n{\n  if (p->flags & _WSNF_NULL)\n    return \"\";\n  else if (p->flags & _WSNF_WORD)\n    return p->v.word;\n  else\n    return wsp->ws_input + p->v.segm.beg;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nwsnode_ptr (struct wordsplit *wsp, struct wordsplit_node *p)",
        "*"
      ]
    },
    "wsnode_len": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "static size_t\nwsnode_len (struct wordsplit_node *p)\n{\n  if (p->flags & _WSNF_NULL)\n    return 0;\n  else if (p->flags & _WSNF_WORD)\n    return strlen (p->v.word);\n  else\n    return p->v.segm.end - p->v.segm.beg;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "wsnode_new": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static int\nwsnode_new (struct wordsplit *wsp, struct wordsplit_node **pnode)\n{\n  struct wordsplit_node *node = calloc (1, sizeof (*node));\n  if (!node)\n    return _wsplt_nomem (wsp);\n  *pnode = node;\n  return 0;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_free": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static void\nwsnode_free (struct wordsplit_node *p)\n{\n  if (p->flags & _WSNF_WORD)\n    free (p->v.word);\n  free (p);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wsnode_append": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "static void\nwsnode_append (struct wordsplit *wsp, struct wordsplit_node *node)\n{\n  node->next = NULL;\n  node->prev = wsp->ws_tail;\n  if (wsp->ws_tail)\n    wsp->ws_tail->next = node;\n  else\n    wsp->ws_head = node;\n  wsp->ws_tail = node;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wsnode_remove": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "static void\nwsnode_remove (struct wordsplit *wsp, struct wordsplit_node *node)\n{\n  struct wordsplit_node *p;\n\n  p = node->prev;\n  if (p)\n    {\n      p->next = node->next;\n      if (!node->next)\n\tp->flags &= ~_WSNF_JOIN;\n    }\n  else\n    wsp->ws_head = node->next;\n\n  p = node->next;\n  if (p)\n    p->prev = node->prev;\n  else\n    wsp->ws_tail = node->prev;\n\n  node->next = node->prev = NULL;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wsnode_insert": {
      "start_point": [
        340,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "static void\nwsnode_insert (struct wordsplit *wsp, struct wordsplit_node *node,\n\t       struct wordsplit_node *anchor, int before)\n{\n  if (!wsp->ws_head)\n    {\n      node->next = node->prev = NULL;\n      wsp->ws_head = wsp->ws_tail = node;\n    }\n  else if (before)\n    {\n      if (anchor->prev)\n\twsnode_insert (wsp, node, anchor->prev, 0);\n      else\n\t{\n\t  node->prev = NULL;\n\t  node->next = anchor;\n\t  anchor->prev = node;\n\t  wsp->ws_head = node;\n\t}\n    }\n  else\n    {\n      struct wordsplit_node *p;\n\n      p = anchor->next;\n      if (p)\n\tp->prev = node;\n      else\n\twsp->ws_tail = node;\n      node->next = p;\n      node->prev = anchor;\n      anchor->next = node;\n    }\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_add_segm": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "static int\nwordsplit_add_segm (struct wordsplit *wsp, size_t beg, size_t end, int flg)\n{\n  struct wordsplit_node *node;\n  int rc;\n\n  if (end == beg && !(flg & _WSNF_EMPTYOK))\n    return 0;\n  rc = wsnode_new (wsp, &node);\n  if (rc)\n    return rc;\n  node->flags = flg & ~(_WSNF_WORD | _WSNF_EMPTYOK);\n  node->v.segm.beg = beg;\n  node->v.segm.end = end;\n  wsnode_append (wsp, node);\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_free_nodes": {
      "start_point": [
        394,
        0
      ],
      "end_point": [
        406,
        1
      ],
      "content": "static void\nwordsplit_free_nodes (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p;)\n    {\n      struct wordsplit_node *next = p->next;\n      wsnode_free (p);\n      p = next;\n    }\n  wsp->ws_head = wsp->ws_tail = NULL;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_dump_nodes": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "static void\nwordsplit_dump_nodes (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n  int n = 0;\n\n  for (p = wsp->ws_head, n = 0; p; p = p->next, n++)\n    {\n      if (p->flags & _WSNF_WORD)\n\twsp->ws_debug (\"%4d: %p: %#04x (%s):%s;\",\n\t\t       n, p, p->flags, wsnode_flagstr (p->flags), p->v.word);\n      else\n\twsp->ws_debug (\"%4d: %p: %#04x (%s):%.*s;\",\n\t\t       n, p, p->flags, wsnode_flagstr (p->flags),\n\t\t       (int) (p->v.segm.end - p->v.segm.beg),\n\t\t       wsp->ws_input + p->v.segm.beg);\n    }\n}",
      "lines": 18,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "coalesce_segment": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        476,
        1
      ],
      "content": "static int\ncoalesce_segment (struct wordsplit *wsp, struct wordsplit_node *node)\n{\n  struct wordsplit_node *p, *end;\n  size_t len = 0;\n  char *buf, *cur;\n  int stop;\n\n  for (p = node; p && (p->flags & _WSNF_JOIN); p = p->next)\n    {\n      len += wsnode_len (p);\n    }\n  if (p)\n    len += wsnode_len (p);\n  end = p;\n\n  buf = malloc (len + 1);\n  if (!buf)\n    return _wsplt_nomem (wsp);\n  cur = buf;\n\n  p = node;\n  for (stop = 0; !stop;)\n    {\n      struct wordsplit_node *next = p->next;\n      const char *str = wsnode_ptr (wsp, p);\n      size_t slen = wsnode_len (p);\n\n      memcpy (cur, str, slen);\n      cur += slen;\n      if (p != node)\n\t{\n\t  wsnode_remove (wsp, p);\n\t  stop = p == end;\n\t  wsnode_free (p);\n\t}\n      p = next;\n    }\n\n  *cur = 0;\n\n  node->flags &= ~_WSNF_JOIN;\n\n  if (node->flags & _WSNF_WORD)\n    free (node->v.word);\n  else\n    node->flags |= _WSNF_WORD;\n  node->v.word = buf;\n  return 0;\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_quoteremoval": {
      "start_point": [
        478,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "static int\nwsnode_quoteremoval (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n  void (*uqfn) (char *, const char *, size_t) =\n    (wsp->ws_flags & WRDSF_CESCAPES) ?\n    wordsplit_c_unquote_copy : wordsplit_sh_unquote_copy;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      const char *str = wsnode_ptr (wsp, p);\n      size_t slen = wsnode_len (p);\n      int unquote;\n\n      if (wsp->ws_flags & WRDSF_QUOTE)\n\t{\n\t  unquote = !(p->flags & _WSNF_NOEXPAND);\n\t}\n      else\n\tunquote = 0;\n\n      if (unquote)\n\t{\n\t  if (!(p->flags & _WSNF_WORD))\n\t    {\n\t      char *newstr = malloc (slen + 1);\n\t      if (!newstr)\n\t\treturn _wsplt_nomem (wsp);\n\t      memcpy (newstr, str, slen);\n\t      newstr[slen] = 0;\n\t      p->v.word = newstr;\n\t      p->flags |= _WSNF_WORD;\n\t    }\n\n\t  if (wsp->ws_flags & WRDSF_ESCAPE)\n\t    wordsplit_general_unquote_copy (p->v.word, str, slen,\n\t\t\t\t            wsp->ws_escape);\n\t  else\n\t    uqfn (p->v.word, str, slen);\n\t}\n    }\n  return 0;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_coalesce": {
      "start_point": [
        522,
        0
      ],
      "end_point": [
        534,
        1
      ],
      "content": "static int\nwsnode_coalesce (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      if (p->flags & _WSNF_JOIN)\n\tif (coalesce_segment (wsp, p))\n\t  return 1;\n    }\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_finish": {
      "start_point": [
        536,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "static int\nwordsplit_finish (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n  size_t n;\n\n  n = 0;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    n++;\n\n  if (alloc_space (wsp, n + 1))\n    return 1;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      const char *str = wsnode_ptr (wsp, p);\n      size_t slen = wsnode_len (p);\n      char *newstr = malloc (slen + 1);\n\n      /* Assign newstr first, even if it is NULL.  This way\n         wordsplit_free will work even if we return\n         nomem later. */\n      wsp->ws_wordv[wsp->ws_offs + wsp->ws_wordc] = newstr;\n      if (!newstr)\n\treturn _wsplt_nomem (wsp);\n      memcpy (newstr, str, slen);\n      newstr[slen] = 0;\n\n      wsp->ws_wordc++;\n\n    }\n  wsp->ws_wordv[wsp->ws_offs + wsp->ws_wordc] = NULL;\n  return 0;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "node_split_prefix": {
      "start_point": [
        574,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "static int\nnode_split_prefix (struct wordsplit *wsp,\n\t\t   struct wordsplit_node **ptail,\n\t\t   struct wordsplit_node *node,\n\t\t   size_t beg, size_t len, int flg)\n{\n  struct wordsplit_node *newnode;\n\n  if (len == 0)\n    return 0;\n  if (wsnode_new (wsp, &newnode))\n    return 1;\n  wsnode_insert (wsp, newnode, *ptail, 0);\n  if (node->flags & _WSNF_WORD)\n    {\n      const char *str = wsnode_ptr (wsp, node);\n      char *newstr = malloc (len + 1);\n      if (!newstr)\n\treturn _wsplt_nomem (wsp);\n      memcpy (newstr, str + beg, len);\n      newstr[len] = 0;\n      newnode->flags = _WSNF_WORD;\n      newnode->v.word = newstr;\n    }\n  else\n    {\n      newnode->v.segm.beg = node->v.segm.beg + beg;\n      newnode->v.segm.end = newnode->v.segm.beg + len;\n    }\n  newnode->flags |= flg;\n  *ptail = newnode;\n  return 0;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_closing_cbrace": {
      "start_point": [
        608,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "static int\nfind_closing_cbrace (const char *str, size_t i, size_t len, size_t * poff)\n{\n  enum\n  { st_init, st_squote, st_dquote } state = st_init;\n  size_t level = 1;\n\n  for (; i < len; i++)\n    {\n      switch (state)\n\t{\n\tcase st_init:\n\t  switch (str[i])\n\t    {\n\t    case '{':\n\t      level++;\n\t      break;\n\n\t    case '}':\n\t      if (--level == 0)\n\t\t{\n\t\t  *poff = i;\n\t\t  return 0;\n\t\t}\n\t      break;\n\n\t    case '\"':\n\t      state = st_dquote;\n\t      break;\n\n\t    case '\\'':\n\t      state = st_squote;\n\t      break;\n\t    }\n\t  break;\n\n\tcase st_squote:\n\t  if (str[i] == '\\'')\n\t    state = st_init;\n\t  break;\n\n\tcase st_dquote:\n\t  if (str[i] == '\\\\')\n\t    i++;\n\t  else if (str[i] == '\"')\n\t    state = st_init;\n\t  break;\n\t}\n    }\n  return 1;\n}",
      "lines": 51,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_find_env": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        698,
        1
      ],
      "content": "static const char *\nwordsplit_find_env (struct wordsplit *wsp, const char *name, size_t len)\n{\n  size_t i;\n\n  if (!(wsp->ws_flags & WRDSF_ENV))\n    return NULL;\n\n  if (wsp->ws_flags & WRDSF_ENV_KV)\n    {\n      /* A key-value pair environment */\n      for (i = 0; wsp->ws_env[i]; i++)\n\t{\n\t  size_t elen = strlen (wsp->ws_env[i]);\n\t  if (elen == len && memcmp (wsp->ws_env[i], name, elen) == 0)\n\t    return wsp->ws_env[i + 1];\n\t  /* Skip the value.  Break the loop if it is NULL. */\n\t  i++;\n\t  if (wsp->ws_env[i] == NULL)\n\t    break;\n\t}\n    }\n  else\n    {\n      /* Usual (A=B) environment. */\n      for (i = 0; wsp->ws_env[i]; i++)\n\t{\n\t  size_t j;\n\t  const char *var = wsp->ws_env[i];\n\n\t  for (j = 0; j < len; j++)\n\t    if (name[j] != var[j])\n\t      break;\n\t  if (j == len && var[j] == '=')\n\t    return var + j + 1;\n\t}\n    }\n  return NULL;\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nwordsplit_find_env (struct wordsplit *wsp, const char *name, size_t len)",
        "*"
      ]
    },
    "expvar": {
      "start_point": [
        700,
        0
      ],
      "end_point": [
        870,
        1
      ],
      "content": "static int\nexpvar (struct wordsplit *wsp, const char *str, size_t len,\n\tstruct wordsplit_node **ptail, const char **pend, int flg)\n{\n  size_t i = 0;\n  const char *defstr = NULL;\n  const char *value;\n  const char *vptr;\n  struct wordsplit_node *newnode;\n  const char *start = str - 1;\n\n  if (ISALPHA (str[0]) || str[0] == '_')\n    {\n      for (i = 1; i < len; i++)\n\tif (!(ISALNUM (str[i]) || str[i] == '_'))\n\t  break;\n      *pend = str + i - 1;\n    }\n  else if (str[0] == '{')\n    {\n      str++;\n      len--;\n      for (i = 1; i < len; i++)\n\tif (str[i] == '}' || str[i] == ':')\n\t  break;\n      if (str[i] == ':')\n\t{\n\t  size_t j;\n\n\t  defstr = str + i + 1;\n\t  if (find_closing_cbrace (str, i + 1, len, &j))\n\t    {\n\t      wsp->ws_errno = WRDSE_CBRACE;\n\t      return 1;\n\t    }\n\t  *pend = str + j;\n\t}\n      else if (str[i] == '}')\n\t{\n\t  defstr = NULL;\n\t  *pend = str + i;\n\t}\n      else\n\t{\n\t  wsp->ws_errno = WRDSE_CBRACE;\n\t  return 1;\n\t}\n    }\n  else\n    {\n      if (wsnode_new (wsp, &newnode))\n\treturn 1;\n      wsnode_insert (wsp, newnode, *ptail, 0);\n      *ptail = newnode;\n      newnode->flags = _WSNF_WORD | flg;\n      newnode->v.word = malloc (3);\n      if (!newnode->v.word)\n\treturn _wsplt_nomem (wsp);\n      newnode->v.word[0] = '$';\n      newnode->v.word[1] = str[0];\n      newnode->v.word[2] = 0;\n      *pend = str;\n      return 0;\n    }\n\n  /* Actually expand the variable */\n  /* str - start of the variable name\n     i   - its length\n     defstr - default replacement str */\n\n  vptr = wordsplit_find_env (wsp, str, i);\n  if (vptr)\n    {\n      value = strdup (vptr);\n      if (!value)\n\treturn _wsplt_nomem (wsp);\n    }\n  else if (wsp->ws_flags & WRDSF_GETVAR)\n    value = wsp->ws_getvar (str, i, wsp->ws_closure);\n  else if (wsp->ws_flags & WRDSF_UNDEF)\n    {\n      wsp->ws_errno = WRDSE_UNDEF;\n      if (wsp->ws_flags & WRDSF_SHOWERR)\n\twordsplit_perror (wsp);\n      return 1;\n    }\n  else\n    {\n      if (wsp->ws_flags & WRDSF_WARNUNDEF)\n\twsp->ws_error (_(\"warning: undefined variable `%.*s'\"), (int) i, str);\n      if (wsp->ws_flags & WRDSF_KEEPUNDEF)\n\tvalue = NULL;\n      else\n\tvalue = \"\";\n    }\n  /* FIXME: handle defstr */\n  if (value)\n    {\n      if (flg & _WSNF_QUOTE)\n\t{\n\t  if (wsnode_new (wsp, &newnode))\n\t    return 1;\n\t  wsnode_insert (wsp, newnode, *ptail, 0);\n\t  *ptail = newnode;\n\t  newnode->flags = _WSNF_WORD | _WSNF_NOEXPAND | flg;\n\t  newnode->v.word = strdup (value);\n\t  if (!newnode->v.word)\n\t    return _wsplt_nomem (wsp);\n\t}\n      else if (*value == 0)\n\t{\n\t  /* Empty string is a special case */\n\t  if (wsnode_new (wsp, &newnode))\n\t    return 1;\n\t  wsnode_insert (wsp, newnode, *ptail, 0);\n\t  *ptail = newnode;\n\t  newnode->flags = _WSNF_NULL;\n\t}\n      else\n\t{\n\t  struct wordsplit ws;\n\t  int i;\n\n\t  ws.ws_delim = wsp->ws_delim;\n\t  if (wordsplit (value, &ws,\n\t\t\t WRDSF_NOVAR | WRDSF_NOCMD | WRDSF_DELIM | WRDSF_WS))\n\t    {\n\t      wordsplit_free (&ws);\n\t      return 1;\n\t    }\n\t  for (i = 0; i < ws.ws_wordc; i++)\n\t    {\n\t      if (wsnode_new (wsp, &newnode))\n\t\treturn 1;\n\t      wsnode_insert (wsp, newnode, *ptail, 0);\n\t      *ptail = newnode;\n\t      newnode->flags = _WSNF_WORD |\n\t\t_WSNF_NOEXPAND |\n\t\t(i + 1 < ws.ws_wordc ? (flg & ~_WSNF_JOIN) : flg);\n\t      newnode->v.word = strdup (ws.ws_wordv[i]);\n\t      if (!newnode->v.word)\n\t\treturn _wsplt_nomem (wsp);\n\t    }\n\t  wordsplit_free (&ws);\n\t}\n    }\n  else if (wsp->ws_flags & WRDSF_KEEPUNDEF)\n    {\n      size_t size = *pend - start + 1;\n\n      if (wsnode_new (wsp, &newnode))\n\treturn 1;\n      wsnode_insert (wsp, newnode, *ptail, 0);\n      *ptail = newnode;\n      newnode->flags = _WSNF_WORD | _WSNF_NOEXPAND | flg;\n      newnode->v.word = malloc (size + 1);\n      if (!newnode->v.word)\n\treturn _wsplt_nomem (wsp);\n      memcpy (newnode->v.word, start, size);\n      newnode->v.word[size] = 0;\n    }\n  else\n    {\n      if (wsnode_new (wsp, &newnode))\n\treturn 1;\n      wsnode_insert (wsp, newnode, *ptail, 0);\n      *ptail = newnode;\n      newnode->flags = _WSNF_NULL;\n    }\n  return 0;\n}",
      "lines": 171,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "node_expand_vars": {
      "start_point": [
        872,
        0
      ],
      "end_point": [
        919,
        1
      ],
      "content": "static int\nnode_expand_vars (struct wordsplit *wsp, struct wordsplit_node *node)\n{\n  const char *str = wsnode_ptr (wsp, node);\n  size_t slen = wsnode_len (node);\n  const char *end = str + slen;\n  const char *p;\n  size_t off = 0;\n  struct wordsplit_node *tail = node;\n\n  for (p = str; p < end; p++)\n    {\n      if (*p == '\\\\')\n\t{\n\t  p++;\n\t  continue;\n\t}\n      if (*p == '$')\n\t{\n\t  size_t n = p - str;\n\n\t  if (tail != node)\n\t    tail->flags |= _WSNF_JOIN;\n\t  if (node_split_prefix (wsp, &tail, node, off, n, _WSNF_JOIN))\n\t    return 1;\n\t  p++;\n\t  if (expvar (wsp, p, slen - n, &tail, &p,\n\t\t      node->flags & (_WSNF_JOIN | _WSNF_QUOTE)))\n\t    return 1;\n\t  off += p - str + 1;\n\t  str = p + 1;\n\t}\n    }\n  if (p > str)\n    {\n      if (tail != node)\n\ttail->flags |= _WSNF_JOIN;\n      if (node_split_prefix (wsp, &tail, node, off, p - str,\n\t\t\t     node->flags & _WSNF_JOIN))\n\treturn 1;\n    }\n  if (tail != node)\n    {\n      wsnode_remove (wsp, node);\n      wsnode_free (node);\n    }\n  return 0;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_nullelim": {
      "start_point": [
        922,
        0
      ],
      "end_point": [
        937,
        1
      ],
      "content": "static void\nwsnode_nullelim (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p;)\n    {\n      struct wordsplit_node *next = p->next;\n      if (p->flags & _WSNF_NULL)\n\t{\n\t  wsnode_remove (wsp, p);\n\t  wsnode_free (p);\n\t}\n      p = next;\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_varexp": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "static int\nwordsplit_varexp (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p;)\n    {\n      struct wordsplit_node *next = p->next;\n      if (!(p->flags & _WSNF_NOEXPAND))\n\tif (node_expand_vars (wsp, p))\n\t  return 1;\n      p = next;\n    }\n\n  wsnode_nullelim (wsp);\n  return 0;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_trimws": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        986,
        1
      ],
      "content": "static void\nwordsplit_trimws (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      size_t n;\n\n      if (p->flags & _WSNF_QUOTE)\n\tcontinue;\n\n      /* Skip leading whitespace: */\n      for (n = p->v.segm.beg; n < p->v.segm.end && ISWS (wsp->ws_input[n]);\n\t   n++)\n\t;\n      p->v.segm.beg = n;\n      /* Trim trailing whitespace */\n      for (n = p->v.segm.end;\n\t   n > p->v.segm.beg && ISWS (wsp->ws_input[n - 1]); n--);\n      p->v.segm.end = n;\n      if (p->v.segm.beg == p->v.segm.end)\n\tp->flags |= _WSNF_NULL;\n    }\n\n  wsnode_nullelim (wsp);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "skip_sed_expr": {
      "start_point": [
        988,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "static int\nskip_sed_expr (const char *command, size_t i, size_t len)\n{\n  int state;\n\n  do\n    {\n      int delim;\n\n      if (command[i] == ';')\n\ti++;\n      if (!(command[i] == 's' && i + 3 < len && ISPUNCT (command[i + 1])))\n\tbreak;\n\n      delim = command[++i];\n      state = 1;\n      for (i++; i < len; i++)\n\t{\n\t  if (state == 3)\n\t    {\n\t      if (command[i] == delim || !ISALNUM (command[i]))\n\t\tbreak;\n\t    }\n\t  else if (command[i] == '\\\\')\n\t    i++;\n\t  else if (command[i] == delim)\n\t    state++;\n\t}\n    }\n  while (state == 3 && i < len && command[i] == ';');\n  return i;\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "skip_delim": {
      "start_point": [
        1021,
        0
      ],
      "end_point": [
        1048,
        1
      ],
      "content": "static size_t\nskip_delim (struct wordsplit *wsp)\n{\n  size_t start = wsp->ws_endp;\n  if (wsp->ws_flags & WRDSF_SQUEEZE_DELIMS)\n    {\n      if ((wsp->ws_flags & WRDSF_RETURN_DELIMS) &&\n\t  ISDELIM (wsp, wsp->ws_input[start]))\n\t{\n\t  int delim = wsp->ws_input[start];\n\t  do\n\t    start++;\n\t  while (start < wsp->ws_len && delim == wsp->ws_input[start]);\n\t}\n      else\n\t{\n\t  do\n\t    start++;\n\t  while (start < wsp->ws_len && ISDELIM (wsp, wsp->ws_input[start]));\n\t}\n      start--;\n    }\n\n  if (!(wsp->ws_flags & WRDSF_RETURN_DELIMS))\n    start++;\n\n  return start;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "scan_qstring": {
      "start_point": [
        1054,
        0
      ],
      "end_point": [
        1083,
        1
      ],
      "content": "static int\nscan_qstring (struct wordsplit *wsp, size_t start, size_t * end)\n{\n  size_t j;\n  const char *command = wsp->ws_input;\n  size_t len = wsp->ws_len;\n  char q = command[start];\n\n  for (j = start + 1; j < len && command[j] != q; j++)\n    if (q == '\"' && command[j] == '\\\\')\n      j++;\n  if (j < len && command[j] == q)\n    {\n      int flags = _WSNF_QUOTE | _WSNF_EMPTYOK;\n      if (q == '\\'')\n\tflags |= _WSNF_NOEXPAND;\n      if (wordsplit_add_segm (wsp, start + 1, j, flags))\n\treturn _WRDS_ERR;\n      *end = j;\n    }\n  else\n    {\n      wsp->ws_endp = start;\n      wsp->ws_errno = WRDSE_QUOTE;\n      if (wsp->ws_flags & WRDSF_SHOWERR)\n\twordsplit_perror (wsp);\n      return _WRDS_ERR;\n    }\n  return 0;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_word": {
      "start_point": [
        1085,
        0
      ],
      "end_point": [
        1170,
        1
      ],
      "content": "static int\nscan_word (struct wordsplit *wsp, size_t start)\n{\n  size_t len = wsp->ws_len;\n  const char *command = wsp->ws_input;\n  const char *comment = wsp->ws_comment;\n  int join = 0;\n  int flags = 0;\n\n  size_t i = start;\n\n  if (i >= len)\n    {\n      wsp->ws_errno = WRDSE_EOF;\n      return _WRDS_EOF;\n    }\n\n  start = i;\n\n  if (wsp->ws_flags & WRDSF_SED_EXPR\n      && command[i] == 's' && i + 3 < len && ISPUNCT (command[i + 1]))\n    {\n      flags = _WSNF_SEXP;\n      i = skip_sed_expr (command, i, len);\n    }\n  else if (!ISDELIM (wsp, command[i]))\n    {\n      while (i < len)\n\t{\n\t  if (comment && strchr (comment, command[i]) != NULL)\n\t    {\n\t      size_t j;\n\t      for (j = i + 1; j < len && command[j] != '\\n'; j++)\n\t\t;\n\t      if (wordsplit_add_segm (wsp, start, i, 0))\n\t\treturn _WRDS_ERR;\n\t      wsp->ws_endp = j;\n\t      return _WRDS_OK;\n\t    }\n\n\t  if (wsp->ws_flags & WRDSF_QUOTE)\n\t    {\n\t      if (command[i] == '\\\\')\n\t\t{\n\t\t  if (++i == len)\n\t\t    break;\n\t\t  i++;\n\t\t  continue;\n\t\t}\n\n\t      if (((wsp->ws_flags & WRDSF_SQUOTE) && command[i] == '\\'') ||\n\t\t  ((wsp->ws_flags & WRDSF_DQUOTE) && command[i] == '\"'))\n\t\t{\n\t\t  if (join && wsp->ws_tail)\n\t\t    wsp->ws_tail->flags |= _WSNF_JOIN;\n\t\t  if (wordsplit_add_segm (wsp, start, i, _WSNF_JOIN))\n\t\t    return _WRDS_ERR;\n\t\t  if (scan_qstring (wsp, i, &i))\n\t\t    return _WRDS_ERR;\n\t\t  start = i + 1;\n\t\t  join = 1;\n\t\t}\n\t    }\n\n\t  if (ISDELIM (wsp, command[i]))\n\t    break;\n\t  else\n\t    i++;\n\t}\n    }\n  else if (wsp->ws_flags & WRDSF_RETURN_DELIMS)\n    {\n      i++;\n    }\n  else if (!(wsp->ws_flags & WRDSF_SQUEEZE_DELIMS))\n    flags |= _WSNF_EMPTYOK;\n\n  if (join && i > start && wsp->ws_tail)\n    wsp->ws_tail->flags |= _WSNF_JOIN;\n  if (wordsplit_add_segm (wsp, start, i, flags))\n    return _WRDS_ERR;\n  wsp->ws_endp = i;\n  if (wsp->ws_flags & WRDSF_INCREMENTAL)\n    return _WRDS_EOF;\n  return _WRDS_OK;\n}",
      "lines": 86,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_c_unquote_char": {
      "start_point": [
        1174,
        0
      ],
      "end_point": [
        1185,
        1
      ],
      "content": "int\nwordsplit_c_unquote_char (int c)\n{\n  char *p;\n\n  for (p = quote_transtab; *p; p += 2)\n    {\n      if (*p == c)\n\treturn p[1];\n    }\n  return c;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "wordsplit_c_quote_char": {
      "start_point": [
        1187,
        0
      ],
      "end_point": [
        1199,
        1
      ],
      "content": "int\nwordsplit_c_quote_char (int c)\n{\n  char *p;\n\n  for (p = quote_transtab + sizeof (quote_transtab) - 2;\n       p > quote_transtab; p -= 2)\n    {\n      if (*p == c)\n\treturn p[-1];\n    }\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "xtonum": {
      "start_point": [
        1204,
        0
      ],
      "end_point": [
        1218,
        1
      ],
      "content": "static int\nxtonum (int *pval, const char *src, int base, int cnt)\n{\n  int i, val;\n\n  for (i = 0, val = 0; i < cnt; i++, src++)\n    {\n      int n = *(unsigned char *) src;\n      if (n > 127 || (n = to_num (n)) >= base)\n\tbreak;\n      val = val * base + n;\n    }\n  *pval = val;\n  return i;\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_c_quoted_length": {
      "start_point": [
        1220,
        0
      ],
      "end_point": [
        1248,
        1
      ],
      "content": "size_t\nwordsplit_c_quoted_length (const char *str, int quote_hex, int *quote)\n{\n  size_t len = 0;\n\n  *quote = 0;\n  for (; *str; str++)\n    {\n      if (strchr (\" \\\"\", *str))\n\t*quote = 1;\n\n      if (*str == ' ')\n\tlen++;\n      else if (*str == '\"')\n\tlen += 2;\n      else if (*str != '\\t' && *str != '\\\\' && ISPRINT (*str))\n\tlen++;\n      else if (quote_hex)\n\tlen += 3;\n      else\n\t{\n\t  if (wordsplit_c_quote_char (*str) != -1)\n\t    len += 2;\n\t  else\n\t    len += 4;\n\t}\n    }\n  return len;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "size_t"
      ]
    },
    "wordsplit_general_unquote_copy": {
      "start_point": [
        1250,
        0
      ],
      "end_point": [
        1263,
        1
      ],
      "content": "void\nwordsplit_general_unquote_copy (char *dst, const char *src, size_t n,\n\t\t\t\t   const char *escapable)\n{\n  int i;\n\n  for (i = 0; i < n;)\n    {\n      if (src[i] == '\\\\' && i < n && strchr (escapable, src[i + 1]))\n\ti++;\n      *dst++ = src[i++];\n    }\n  *dst = 0;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_sh_unquote_copy": {
      "start_point": [
        1265,
        0
      ],
      "end_point": [
        1277,
        1
      ],
      "content": "void\nwordsplit_sh_unquote_copy (char *dst, const char *src, size_t n)\n{\n  int i;\n\n  for (i = 0; i < n;)\n    {\n      if (src[i] == '\\\\')\n\ti++;\n      *dst++ = src[i++];\n    }\n  *dst = 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_c_unquote_copy": {
      "start_point": [
        1279,
        0
      ],
      "end_point": [
        1342,
        1
      ],
      "content": "void\nwordsplit_c_unquote_copy (char *dst, const char *src, size_t n)\n{\n  int i = 0;\n  int c;\n\n  while (i < n)\n    {\n      if (src[i] == '\\\\')\n\t{\n\t  ++i;\n\t  if (src[i] == 'x' || src[i] == 'X')\n\t    {\n\t      if (n - i < 2)\n\t\t{\n\t\t  *dst++ = '\\\\';\n\t\t  *dst++ = src[i++];\n\t\t}\n\t      else\n\t\t{\n\t\t  int off = xtonum (&c, src + i + 1,\n\t\t\t\t    16, 2);\n\t\t  if (off == 0)\n\t\t    {\n\t\t      *dst++ = '\\\\';\n\t\t      *dst++ = src[i++];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst++ = c;\n\t\t      i += off + 1;\n\t\t    }\n\t\t}\n\t    }\n\t  else if ((unsigned char) src[i] < 128 && ISDIGIT (src[i]))\n\t    {\n\t      if (n - i < 1)\n\t\t{\n\t\t  *dst++ = '\\\\';\n\t\t  *dst++ = src[i++];\n\t\t}\n\t      else\n\t\t{\n\t\t  int off = xtonum (&c, src + i, 8, 3);\n\t\t  if (off == 0)\n\t\t    {\n\t\t      *dst++ = '\\\\';\n\t\t      *dst++ = src[i++];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst++ = c;\n\t\t      i += off;\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    *dst++ = wordsplit_c_unquote_char (src[i++]);\n\t}\n      else\n\t*dst++ = src[i++];\n    }\n  *dst = 0;\n}",
      "lines": 64,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_c_quote_copy": {
      "start_point": [
        1344,
        0
      ],
      "end_point": [
        1381,
        1
      ],
      "content": "void\nwordsplit_c_quote_copy (char *dst, const char *src, int quote_hex)\n{\n  for (; *src; src++)\n    {\n      if (*src == '\"')\n\t{\n\t  *dst++ = '\\\\';\n\t  *dst++ = *src;\n\t}\n      else if (*src != '\\t' && *src != '\\\\' && ISPRINT (*src))\n\t*dst++ = *src;\n      else\n\t{\n\t  char tmp[4];\n\n\t  if (quote_hex)\n\t    {\n\t      snprintf (tmp, sizeof tmp, \"%%%02X\", *(unsigned char *) src);\n\t      memcpy (dst, tmp, 3);\n\t      dst += 3;\n\t    }\n\t  else\n\t    {\n\t      int c = wordsplit_c_quote_char (*src);\n\t      *dst++ = '\\\\';\n\t      if (c != -1)\n\t\t*dst++ = c;\n\t      else\n\t\t{\n\t\t  snprintf (tmp, sizeof tmp, \"%03o\", *(unsigned char *) src);\n\t\t  memcpy (dst, tmp, 3);\n\t\t  dst += 3;\n\t\t}\n\t    }\n\t}\n    }\n}",
      "lines": 38,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_process_list": {
      "start_point": [
        1383,
        0
      ],
      "end_point": [
        1458,
        1
      ],
      "content": "static int\nwordsplit_process_list (struct wordsplit *wsp, size_t start)\n{\n  if (wsp->ws_flags & WRDSF_NOSPLIT)\n    {\n      /* Treat entire input as a quoted argument */\n      if (wordsplit_add_segm (wsp, start, wsp->ws_len, _WSNF_QUOTE))\n\treturn wsp->ws_errno;\n    }\n  else\n    {\n      int rc;\n\n      while ((rc = scan_word (wsp, start)) == _WRDS_OK)\n\tstart = skip_delim (wsp);\n      /* Make sure tail element is not joinable */\n      if (wsp->ws_tail)\n\twsp->ws_tail->flags &= ~_WSNF_JOIN;\n      if (rc == _WRDS_ERR)\n\treturn wsp->ws_errno;\n    }\n\n  if (wsp->ws_flags & WRDSF_SHOWDBG)\n    {\n      wsp->ws_debug (\"Initial list:\");\n      wordsplit_dump_nodes (wsp);\n    }\n\n  if (wsp->ws_flags & WRDSF_WS)\n    {\n      /* Trim leading and trailing whitespace */\n      wordsplit_trimws (wsp);\n      if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t{\n\t  wsp->ws_debug (\"After WS trimming:\");\n\t  wordsplit_dump_nodes (wsp);\n\t}\n    }\n\n  /* Expand variables (FIXME: & commands) */\n  if (!(wsp->ws_flags & WRDSF_NOVAR))\n    {\n      if (wordsplit_varexp (wsp))\n\t{\n\t  wordsplit_free_nodes (wsp);\n\t  return wsp->ws_errno;\n\t}\n      if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t{\n\t  wsp->ws_debug (\"Expanded list:\");\n\t  wordsplit_dump_nodes (wsp);\n\t}\n    }\n\n  do\n    {\n      if (wsnode_quoteremoval (wsp))\n\tbreak;\n      if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t{\n\t  wsp->ws_debug (\"After quote removal:\");\n\t  wordsplit_dump_nodes (wsp);\n\t}\n\n      if (wsnode_coalesce (wsp))\n\tbreak;\n\n      if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t{\n\t  wsp->ws_debug (\"Coalesced list:\");\n\t  wordsplit_dump_nodes (wsp);\n\t}\n    }\n  while (0);\n  return wsp->ws_errno;\n}",
      "lines": 76,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_len": {
      "start_point": [
        1460,
        0
      ],
      "end_point": [
        1526,
        1
      ],
      "content": "int\nwordsplit_len (const char *command, size_t length, struct wordsplit *wsp, \n               int flags)\n{\n  int rc;\n  size_t start;\n  const char *cmdptr;\n  size_t cmdlen;\n\n  if (!command)\n    {\n      if (!(flags & WRDSF_INCREMENTAL))\n\treturn EINVAL;\n\n      start = skip_delim (wsp);\n      if (wsp->ws_endp == wsp->ws_len)\n\t{\n\t  wsp->ws_errno = WRDSE_NOINPUT;\n\t  if (wsp->ws_flags & WRDSF_SHOWERR)\n\t    wordsplit_perror (wsp);\n\t  return wsp->ws_errno;\n\t}\n\n      cmdptr = wsp->ws_input + wsp->ws_endp;\n      cmdlen = wsp->ws_len - wsp->ws_endp;\n      wsp->ws_flags |= WRDSF_REUSE;\n      wordsplit_init0 (wsp);\n    }\n  else\n    {\n      cmdptr = command;\n      cmdlen = length;\n      start = 0;\n      rc = wordsplit_init (wsp, cmdptr, cmdlen, flags);\n      if (rc)\n\treturn rc;\n    }\n\n  if (wsp->ws_flags & WRDSF_SHOWDBG)\n    wsp->ws_debug (\"Input:%.*s;\", (int) cmdlen, cmdptr);\n\n  rc = wordsplit_process_list (wsp, start);\n  if (rc == 0 && (flags & WRDSF_INCREMENTAL))\n    {\n      while (!wsp->ws_head && wsp->ws_endp < wsp->ws_len)\n\t{\n\t  start = skip_delim (wsp);\n\t  if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t    {\n\t      cmdptr = wsp->ws_input + wsp->ws_endp;\n\t      cmdlen = wsp->ws_len - wsp->ws_endp;\n\t      wsp->ws_debug (\"Restart:%.*s;\", (int) cmdlen, cmdptr);\n\t    }\n\t  rc = wordsplit_process_list (wsp, start);\n\t  if (rc)\n\t    break;\n\t}\n    }\n  if (rc)\n    {\n      wordsplit_free_nodes (wsp);\n      return rc;\n    }\n  wordsplit_finish (wsp);\n  wordsplit_free_nodes (wsp);\n  return wsp->ws_errno;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "wordsplit": {
      "start_point": [
        1528,
        0
      ],
      "end_point": [
        1533,
        1
      ],
      "content": "int\nwordsplit (const char *command, struct wordsplit *ws, int flags)\n{\n  return wordsplit_len (command, command ? strlen (command) : 0, ws,\n\t\t\t   flags);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "wordsplit_free_words": {
      "start_point": [
        1535,
        0
      ],
      "end_point": [
        1550,
        1
      ],
      "content": "void\nwordsplit_free_words (struct wordsplit *ws)\n{\n  size_t i;\n\n  for (i = 0; i < ws->ws_wordc; i++)\n    {\n      char *p = ws->ws_wordv[ws->ws_offs + i];\n      if (p)\n\t{\n\t  free (p);\n\t  ws->ws_wordv[ws->ws_offs + i] = NULL;\n\t}\n    }\n  ws->ws_wordc = 0;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_free": {
      "start_point": [
        1552,
        0
      ],
      "end_point": [
        1558,
        1
      ],
      "content": "void\nwordsplit_free (struct wordsplit *ws)\n{\n  wordsplit_free_words (ws);\n  free (ws->ws_wordv);\n  ws->ws_wordv = NULL;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_perror": {
      "start_point": [
        1560,
        0
      ],
      "end_point": [
        1602,
        1
      ],
      "content": "void\nwordsplit_perror (struct wordsplit *wsp)\n{\n  switch (wsp->ws_errno)\n    {\n    case WRDSE_EOF:\n      wsp->ws_error (_(\"no error\"));\n      break;\n\n    case WRDSE_QUOTE:\n      wsp->ws_error (_(\"missing closing %c (start near #%lu)\"),\n\t\t     wsp->ws_input[wsp->ws_endp],\n\t\t     (unsigned long) wsp->ws_endp);\n      break;\n\n    case WRDSE_NOSPACE:\n      wsp->ws_error (_(\"memory exhausted\"));\n      break;\n\n    case WRDSE_NOSUPP:\n      wsp->ws_error (_(\"command substitution is not yet supported\"));\n      break;\n\n    case WRDSE_USAGE:\n      wsp->ws_error (_(\"invalid wordsplit usage\"));\n      break;\n\n    case WRDSE_CBRACE:\n      wsp->ws_error (_(\"unbalanced curly brace\"));\n      break;\n\n    case WRDSE_UNDEF:\n      wsp->ws_error (_(\"undefined variable\"));\n      break;\n\n    case WRDSE_NOINPUT:\n      wsp->ws_error (_(\"input exhausted\"));\n      break;\n\n    default:\n      wsp->ws_error (_(\"unknown error\"));\n    }\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_strerror": {
      "start_point": [
        1617,
        0
      ],
      "end_point": [
        1623,
        1
      ],
      "content": "const char *\nwordsplit_strerror (struct wordsplit *ws)\n{\n  if (ws->ws_errno < _wordsplit_nerrs)\n    return _wordsplit_errstr[ws->ws_errno];\n  return N_(\"unknown error\");\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nwordsplit_strerror (struct wordsplit *ws)",
        "*"
      ]
    }
  },
  "cflow/cflow-1.5/src/wordsplit.h": {}
}