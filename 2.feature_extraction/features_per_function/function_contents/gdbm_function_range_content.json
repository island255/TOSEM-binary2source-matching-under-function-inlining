{
  "gdbm/gdbm-1.15/compat/close.c": {
    "dbmclose": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\ndbmclose ()\n{\n  if (_gdbm_file != NULL)\n    {\n      dbm_close (_gdbm_file);\n      _gdbm_file = NULL;\n    }\n  return (0);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/dbm-priv.h": {},
  "gdbm/gdbm-1.15/compat/dbm.h": {},
  "gdbm/gdbm-1.15/compat/dbmclose.c": {
    "dbm_close": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "void\ndbm_close (DBM *dbm)\n{\n  gdbm_close (dbm->file);\n  close (dbm->dirfd);\n  if (dbm->_dbm_memory.dptr)\n    free (dbm->_dbm_memory.dptr);\n  if (dbm->_dbm_fetch_val)\n    free (dbm->_dbm_fetch_val);\n  free (dbm);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/dbmdelete.c": {
    "dbm_delete": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\ndbm_delete (DBM *dbm, datum key)\n{\n  int rc = gdbm_delete (dbm->file, key);\n  if (rc)\n    __gdbm_error_to_ndbm (dbm);\n  return rc;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/dbmdirfno.c": {
    "dbm_dirfno": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\ndbm_dirfno (DBM *dbm)\n{\n  return dbm->dirfd;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/dbmerr.c": {
    "dbm_error": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "int\ndbm_error (DBM *dbf)\n{\n  return dbf->_dbm_errno;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "dbm_clearerr": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "void\ndbm_clearerr (DBM *dbf)\n{\n  dbf->_dbm_errno = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/dbmfetch.c": {
    "dbm_fetch": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "datum\ndbm_fetch (DBM *dbm, datum key)\n{\n  datum  ret_val;\t\t/* The return value. */\n\n  /* Free previous dynamic memory, do actual call, and save pointer to new\n     memory. */\n  ret_val = gdbm_fetch (dbm->file, key);\n  if (dbm->_dbm_fetch_val != NULL)\n    free (dbm->_dbm_fetch_val);\n  dbm->_dbm_fetch_val = ret_val.dptr;\n  __gdbm_error_to_ndbm (dbm);\n  /* Return the new value. */\n  return ret_val;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "datum"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/dbminit.c": {
    "dbminit": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ndbminit (char *file)\n{\n  if (_gdbm_file != NULL)\n    dbm_close (_gdbm_file);\n  /* Try to open the file as a writer.  DBM never created a file. */\n  _gdbm_file = dbm_open (file, O_RDWR, 0644);\n  /* If it was not opened, try opening it as a reader. */\n  if (_gdbm_file == NULL)\n    {\n      _gdbm_file = dbm_open (file, O_RDONLY, 0644);\n      /* Did we successfully open the file? */\n      if (_gdbm_file == NULL)\n\t{\n          gdbm_set_errno (NULL, GDBM_FILE_OPEN_ERROR, TRUE);\n\t  return -1;\n\t}\n    }\n  return 0;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/dbmopen.c": {
    "getint": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static unsigned\ngetint (const unsigned char *cp)\n{\n  return (cp[0] << 24) + (cp[1] << 16) + (cp[2] << 8) + cp[3];\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "putint": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static void\nputint (unsigned char *cp, unsigned n)\n{\n  cp[0] = (n >> 24) & 0xff;\n  cp[1] = (n >> 16) & 0xff;\n  cp[2] = (n >> 8) & 0xff;\n  cp[3] = n & 0xff;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ndbm_open_dir_file0": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static int\nndbm_open_dir_file0 (const char *file_name, int pagfd, int mode)\n{\n  int fd = -1;\n  struct stat st, pagst;\n  unsigned char dirbuf[DEF_DIR_SIZE];\n  int flags = (mode & GDBM_OPENMASK) == GDBM_READER ?\n                O_RDONLY : O_RDWR;\n\n  if (mode & GDBM_CLOEXEC)\n    flags |= O_CLOEXEC;\n      \n  if (fstat (pagfd, &pagst))\n    {\n      gdbm_set_errno (NULL, GDBM_FILE_OPEN_ERROR, TRUE); /* FIXME: special code? */\n      return -1;\n    } \n      \n  /* Previous versions of GDBM linked pag to dir. Try to detect this: */\n  if (stat (file_name, &st) == 0)\n    {\n      if (st.st_nlink >= 2)\n\t{\n\t  if (st.st_dev == pagst.st_dev && st.st_ino == pagst.st_ino)\n\t    {\n\t      if (unlink (file_name))\n\t\t{\n\t\t  if ((mode & GDBM_OPENMASK) == GDBM_READER)\n\t\t    /* Ok, try to cope with it. */\n\t\t    return pagfd;\n\t\t  else\n\t\t    {\n\t\t      gdbm_set_errno (NULL, GDBM_FILE_OPEN_ERROR, TRUE); \n\t\t      return -1;\n\t\t    } \n\t\t}\n\t    }\n\t  else\n\t    {\n\t      gdbm_set_errno (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n\t      return -1;\n\t    }\n\t}\n      else if (st.st_size == 0)\n\t/* ok */;\n      else if (st.st_size != DEF_DIR_SIZE)\n\t{\n\t  gdbm_set_errno (NULL, GDBM_BAD_MAGIC_NUMBER, FALSE);\n\t  return -1;\n\t}\n      else\n\t{\n\t  fd = open (file_name, flags);\n\t  if (fd == -1)\n\t    {\n\t      gdbm_set_errno (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n\t      return fd;\n\t    }\n\t  \n\t  if (read (fd, dirbuf, sizeof (dirbuf)) != sizeof (dirbuf))\n\t    {\n\t      gdbm_set_errno (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n\t      close (fd);\n\t      return -1;\n\t    } \n\t  \n\t  if (getint (dirbuf) == GDBM_DIR_MAGIC)\n\t    {\n\t      int v[3];\n\t      \n\t      v[0] = getint (dirbuf + 4);\n\t      v[1] = getint (dirbuf + 8);\n\t      v[2] = getint (dirbuf + 12);\n\t      \n\t      if (gdbm_version_cmp (v, gdbm_version_number) <= 0)\n\t\treturn fd;\n\t    }\n\t  close (fd);\n\t  gdbm_set_errno (NULL, GDBM_BAD_MAGIC_NUMBER, FALSE);\n\t  return -1;\n\t}\n    }\n  \n  /* File does not exist.  Create it. */\n  fd = open (file_name, flags | O_CREAT, pagst.st_mode & 0777);\n  if (fd >= 0)\n    {\n      putint (dirbuf, GDBM_DIR_MAGIC);\n      putint (dirbuf + 4, gdbm_version_number[0]);\n      putint (dirbuf + 8, gdbm_version_number[1]);\n      putint (dirbuf + 12, gdbm_version_number[2]);\n\n      if (write (fd, dirbuf, sizeof (dirbuf)) != sizeof (dirbuf))\n\t{\n\t  gdbm_set_errno (NULL, GDBM_FILE_WRITE_ERROR, FALSE);\n\t  close (fd);\n\t  fd = -1;\n\t} \n    }\n  \n  return fd;\n}",
      "lines": 102,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ndbm_open_dir_file": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static int\nndbm_open_dir_file (const char *base, int pagfd, int mode)\n{\n  char *file_name = malloc (strlen (base) + sizeof (DIRSUF));\n  int fd;\n  \n  if (!file_name)\n    {\n      gdbm_set_errno (NULL, GDBM_MALLOC_ERROR, FALSE);\n      return -1;\n    }\n  fd = ndbm_open_dir_file0 (strcat (strcpy (file_name, base), DIRSUF),\n\t\t\t    pagfd, mode);\n  free (file_name);\n  return fd;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dbm_open": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "DBM *\ndbm_open (char *file, int flags, int mode)\n{\n  char *pag_file;\t    /* Used to construct \"file.pag\". */\n  DBM *dbm = NULL;\n  int open_flags;\n  int f;\n  \n  /* Prepare the correct name for \"file.pag\". */\n  pag_file = (char *) malloc (strlen (file) + 5);\n  if (!pag_file)\n    {\n      gdbm_set_errno (NULL, GDBM_MALLOC_ERROR, FALSE); /* For the hell of it. */\n      return NULL;\n    }\n\n  strcpy (pag_file, file);\n  strcat (pag_file, \".pag\");\n\n  /* Call the actual routine, saving the pointer to the file information. */\n  f = flags & (O_RDONLY | O_RDWR | O_CREAT | O_TRUNC);\n\n  if (f == O_RDONLY)\n    {\n      open_flags = GDBM_READER;\n      mode = 0;\n    }\n  else if (f == (O_RDWR | O_CREAT))\n    {\n      open_flags = GDBM_WRCREAT;\n    }\n  else if ((f & O_TRUNC) == O_TRUNC)\n    {\n      open_flags = GDBM_NEWDB;\n    }\n  else\n    {\n      open_flags = GDBM_WRITER;\n      mode = 0;\n    }\n\n  if (flags & O_CLOEXEC)\n    open_flags |= GDBM_CLOEXEC;\n\n  open_flags |= GDBM_NOLOCK;\n  \n  dbm = calloc (1, sizeof (*dbm));\n  if (!dbm)\n    {\n      free (pag_file);\n      gdbm_set_errno (NULL, GDBM_MALLOC_ERROR, FALSE); /* For the hell of it. */\n      return NULL;\n    }\n      \n  dbm->file = gdbm_open (pag_file, 0, open_flags, mode, NULL);\n\n  /* Did we successfully open the file? */\n  if (dbm->file == NULL)\n    {\n      gdbm_set_errno (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n      free (dbm);\n      dbm = NULL;\n    }\n  else\n    {\n      dbm->dirfd = ndbm_open_dir_file (file, dbm->file->desc, open_flags);\n      if (dbm->dirfd == -1)\n\t{\n\t  gdbm_close (dbm->file);\n\t  free (dbm);\n\t  dbm = NULL;\n\t}\n    }\n\n  free (pag_file);\n  return dbm;\n}",
      "lines": 77,
      "depth": 11,
      "decorators": [
        "DBM",
        "*\ndbm_open (char *file, int flags, int mode)",
        "*"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/dbmpagfno.c": {
    "dbm_pagfno": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\ndbm_pagfno (DBM *dbm)\n{\n  return dbm->file->desc;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/dbmrdonly.c": {
    "dbm_rdonly": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\ndbm_rdonly (DBM *dbm)\n{\n  return (dbm->file->read_write == GDBM_READER);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/dbmseq.c": {
    "dbm_firstkey": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "datum\ndbm_firstkey (DBM *dbm)\n{\n  datum ret_val;\n\n  /* Free previous dynamic memory, do actual call, and save pointer to new\n     memory. */\n  ret_val = gdbm_firstkey (dbm->file);\n  if (dbm->_dbm_memory.dptr != NULL)\n    free (dbm->_dbm_memory.dptr);\n  dbm->_dbm_memory = ret_val;\n  __gdbm_error_to_ndbm (dbm);\n  /* Return the new value. */\n  return ret_val;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "datum"
      ]
    },
    "dbm_nextkey": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "datum\ndbm_nextkey (DBM *dbm)\n{\n  datum ret_val;\n\n  /* Make sure we have a valid key. */\n  if (dbm->_dbm_memory.dptr == NULL)\n    return dbm->_dbm_memory;\n\n  /* Call gdbm nextkey with the old value. After that, free the old value. */\n  ret_val = gdbm_nextkey (dbm->file, dbm->_dbm_memory);\n  if (dbm->_dbm_memory.dptr != NULL)\n    free (dbm->_dbm_memory.dptr);\n  dbm->_dbm_memory = ret_val;\n  __gdbm_error_to_ndbm (dbm);\n  /* Return the new value. */\n  return ret_val;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "datum"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/dbmstore.c": {
    "dbm_store": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\ndbm_store (DBM *dbm, datum key, datum content, int flags)\n{\n  int rc = gdbm_store (dbm->file, key, content, flags);\n  __gdbm_error_to_ndbm (dbm);\n  return rc;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/delete.c": {
    "delete": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\ndelete (datum key)\n{\n  return dbm_delete (_gdbm_file, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/fetch.c": {
    "fetch": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "datum\nfetch (datum key)\n{\n  return dbm_fetch (_gdbm_file, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "datum"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/ndbm.h": {},
  "gdbm/gdbm-1.15/compat/seq.c": {
    "firstkey": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "datum\nfirstkey (void)\n{\n  return dbm_firstkey (_gdbm_file);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "datum"
      ]
    },
    "nextkey": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "datum\nnextkey (datum key)\n{\n  return dbm_nextkey (_gdbm_file);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "datum"
      ]
    }
  },
  "gdbm/gdbm-1.15/compat/store.c": {
    "store": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nstore (datum key, datum content)\n{\n  return dbm_store (_gdbm_file, key, content, DBM_REPLACE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/base64.c": {
    "_gdbm_base64_encode": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\n_gdbm_base64_encode (const unsigned char *input, size_t input_len,\n\t\t     unsigned char **output, size_t *output_size,\n\t\t     size_t *nbytes)\n{\n  size_t olen = 4 * (input_len + 2) / 3 + 1;\n  unsigned char *out;\n\n  if (olen > *output_size)\n    {\n      out = realloc (*output, olen);\n      if (!out)\n\treturn GDBM_MALLOC_ERROR;\n      *output = out;\n      *output_size = olen;\n    }\n  else\n    out = *output;\n  \n  while (input_len >= 3)\n    {\n      *out++ = b64tab[input[0] >> 2];\n      *out++ = b64tab[((input[0] << 4) & 0x30) | (input[1] >> 4)];\n      *out++ = b64tab[((input[1] << 2) & 0x3c) | (input[2] >> 6)];\n      *out++ = b64tab[input[2] & 0x3f];\n      input_len -= 3;\n      input += 3;\n    }\n\n  if (input_len > 0)\n    {\n      unsigned char c = (input[0] << 4) & 0x30;\n      *out++ = b64tab[input[0] >> 2];\n      if (input_len > 1)\n\tc |= input[1] >> 4;\n      *out++ = b64tab[c];\n      *out++ = (input_len < 2) ? '=' : b64tab[(input[1] << 2) & 0x3c];\n      *out++ = '=';\n    }\n  *out = 0;\n  *nbytes = out - *output;\n  return 0;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_base64_decode": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\n_gdbm_base64_decode (const unsigned char *input, size_t input_len,\n\t\t     unsigned char **output, size_t *output_size,\n\t\t     size_t *inbytes, size_t *outbytes)\n{\n  int rc = 0;\n  int olen = input_len;\n  unsigned char *out;\n  size_t ins = 0;\n  \n  if (olen > *output_size)\n    {\n      out = realloc (*output, olen);\n      if (!out)\n\treturn GDBM_MALLOC_ERROR;\n      *output = out;\n      *output_size = olen;\n    }\n  else\n    out = *output;\n\n  do\n    {\n      if (input_len < 4)\n\tbreak;\n      if (input[0] > 127 || b64val[input[0]] == -1\n\t  || input[1] > 127 || b64val[input[1]] == -1\n\t  || input[2] > 127 || ((input[2] != '=') && (b64val[input[2]] == -1))\n\t  || input[3] > 127 || ((input[3] != '=')\n\t\t\t\t&& (b64val[input[3]] == -1)))\n\t{\n\t  rc = GDBM_ILLEGAL_DATA;\n\t  break;\n\t}\n      *out++ = (b64val[input[0]] << 2) | (b64val[input[1]] >> 4);\n      if (input[2] != '=')\n\t{\n\t  *out++ = ((b64val[input[1]] << 4) & 0xf0) | (b64val[input[2]] >> 2);\n\t  if (input[3] != '=')\n\t    *out++ = ((b64val[input[2]] << 6) & 0xc0) | b64val[input[3]];\n\t}\n      input += 4;\n      input_len -= 4;\n      ins += 4;\n    }\n  while (input_len > 0);\n  *inbytes = ins;\n  *outbytes = out - *output;\n  return rc;\n}",
      "lines": 50,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/bucket.c": {
    "_gdbm_new_bucket": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\n_gdbm_new_bucket (GDBM_FILE dbf, hash_bucket *bucket, int bits)\n{\n  int index;\n\n  /* Initialize the avail block. */\n  bucket->av_count = 0;\n\n  /* Set the information fields first. */\n  bucket->bucket_bits = bits;\n  bucket->count = 0;\n  \n  /* Initialize all bucket elements. */\n  for (index = 0; index < dbf->header->bucket_elems; index++)\n    bucket->h_table[index].hash_value = -1;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gdbm_dir_entry_valid_p": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\ngdbm_dir_entry_valid_p (GDBM_FILE dbf, int dir_index)\n{\n  return dir_index >= 0\n         && dir_index < GDBM_DIR_COUNT (dbf)\n         && dbf->dir[dir_index] >= 2*dbf->header->block_size;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_get_bucket": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "int\n_gdbm_get_bucket (GDBM_FILE dbf, int dir_index)\n{\n  int rc;\n  off_t bucket_adr;\t/* The address of the correct hash bucket.  */\n  off_t\tfile_pos;\t/* The return address for lseek. */\n  int   index;\t\t/* Loop index. */\n\n  if (!gdbm_dir_entry_valid_p (dbf, dir_index))\n    {\n      /* FIXME: negative caching? */\n      GDBM_SET_ERRNO (dbf, GDBM_BAD_DIR_ENTRY, TRUE);\n      return -1;\n    }\n  \n  /* Initial set up. */\n  dbf->bucket_dir = dir_index;\n  bucket_adr = dbf->dir[dir_index];\n  \n  if (dbf->bucket_cache == NULL)\n    {\n      if (_gdbm_init_cache (dbf, DEFAULT_CACHESIZE) == -1)\n\t{\n\t  _gdbm_fatal (dbf, _(\"couldn't init cache\"));\n\t  return -1;\n\t}\n    }\n\n  /* If that one is not already current, we must find it. */\n  if (dbf->cache_entry->ca_adr != bucket_adr)\n    {\n      size_t lru;\n      hash_bucket *bucket;\n      \n      /* Look in the cache. */\n      for (index = 0; index < dbf->cache_size; index++)\n        {\n\t  if (dbf->bucket_cache[index].ca_adr == bucket_adr)\n\t    {\n\t      dbf->bucket = dbf->bucket_cache[index].ca_bucket;\n\t      dbf->cache_entry = &dbf->bucket_cache[index];\n\t      return 0;\n\t    }\n        }\n\n      /* It is not in the cache, read it from the disk. */\n\n      /* Position the file pointer */\n      file_pos = gdbm_file_seek (dbf, bucket_adr, SEEK_SET);\n      if (file_pos != bucket_adr)\n\t{\n\t  GDBM_SET_ERRNO (dbf, GDBM_FILE_SEEK_ERROR, TRUE);\n\t  _gdbm_fatal (dbf, _(\"lseek error\"));\n\t  return -1;\n\t}\n      \n      /* Flush and drop the last recently used cache entry */\n      lru = (dbf->last_read + 1) % dbf->cache_size;\n      if (dbf->bucket_cache[lru].ca_changed)\n\t{\n\t  if (_gdbm_write_bucket (dbf, &dbf->bucket_cache[lru]))\n\t    return -1;\n\t}\n      _gdbm_cache_entry_invalidate (dbf, lru);\n      \n      /* Read the bucket. */\n      rc = _gdbm_full_read (dbf, dbf->bucket_cache[lru].ca_bucket,\n\t\t\t    dbf->header->bucket_size);\n      if (rc)\n\t{\n\t  GDBM_DEBUG (GDBM_DEBUG_ERR,\n\t\t      \"%s: error reading bucket: %s\",\n\t\t      dbf->name, gdbm_db_strerror (dbf));\n\t  dbf->need_recovery = TRUE;\n\t  _gdbm_fatal (dbf, gdbm_db_strerror (dbf));\n\t  return -1;\n\t}\n      /* Validate the bucket */\n      bucket = dbf->bucket_cache[lru].ca_bucket;\n      if (!(bucket->count >= 0\n\t    && bucket->count <= dbf->header->bucket_elems\n\t    && bucket->bucket_bits >= 0\n\t    && bucket->bucket_bits <= dbf->header->dir_bits))\n\t{\n\t  GDBM_SET_ERRNO (dbf, GDBM_BAD_BUCKET, TRUE);\n\t  return -1;\n\t}\n      /* Validate bucket_avail table */\n      if (gdbm_bucket_avail_table_validate (dbf, bucket))\n\treturn -1;\n\n      /* Finally, store it in cache */\n      dbf->last_read = lru;\n      dbf->bucket_cache[lru].ca_adr = bucket_adr;\n      dbf->bucket = dbf->bucket_cache[lru].ca_bucket;\n      dbf->cache_entry = &dbf->bucket_cache[lru];\n      dbf->cache_entry->ca_data.elem_loc = -1;\n      dbf->cache_entry->ca_changed = FALSE;\n    }\n  return 0;\n}",
      "lines": 101,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_read_bucket_at": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "int\n_gdbm_read_bucket_at (GDBM_FILE dbf, off_t off, hash_bucket *bucket,\n\t\t      size_t size)\n{\n  off_t file_pos;\n  int i;\n\n  if (dbf->cache_entry && dbf->cache_entry->ca_adr == off)\n    {\n      memcpy (bucket, dbf->bucket, size);\n      return 0;\n    }\n\n  /* Look in the cache. */\n  for (i = 0; i < dbf->cache_size; i++)\n    {\n      if (dbf->bucket_cache[i].ca_adr == off)\n\t{\n\t  memcpy (bucket, dbf->bucket_cache[i].ca_bucket, size);\n\t  return 0;\n\t}\n    }\n\n  /* Read the bucket. */\n  file_pos = gdbm_file_seek (dbf, off, SEEK_SET);\n  if (file_pos != off)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_FILE_SEEK_ERROR, TRUE);\n      return -1;\n    }\n  if (_gdbm_full_read (dbf, bucket, size))\n    {\n      GDBM_DEBUG (GDBM_DEBUG_ERR,\n\t\t  \"%s: error reading bucket: %s\",\n\t\t  dbf->name, gdbm_db_strerror (dbf));\n      return -1;\n    }\n  return 0;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_split_bucket": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "int\n_gdbm_split_bucket (GDBM_FILE dbf, int next_insert)\n{\n  hash_bucket *bucket[2]; \t/* Pointers to the new buckets. */\n\n  int          new_bits;\t/* The number of bits for the new buckets. */\n  int\t       cache_0;\t\t/* Location in the cache for the buckets. */\n  int\t       cache_1;\n  off_t        adr_0;\t\t/* File address of the new bucket 0. */\n  off_t        adr_1;\t\t/* File address of the new bucket 1. */\n  avail_elem   old_bucket;\t/* Avail Struct for the old bucket. */\n\n  off_t        dir_start0;\t/* Used in updating the directory. */\n  off_t        dir_start1;\n  off_t        dir_end;\n\n  off_t       *new_dir;\t\t/* Pointer to the new directory. */\n  off_t        dir_adr; \t/* Address of the new directory. */\n  int          dir_size;\t/* Size of the new directory. */\n  off_t        old_adr[GDBM_HASH_BITS];  /* Address of the old directories. */\n  int          old_size[GDBM_HASH_BITS]; /* Size of the old directories. */\n  int\t       old_count;\t/* Number of old directories. */\n\n  int          index;\t\t/* Used in array indexing. */\n  int          index1;\t\t/* Used in array indexing. */\n  int          elem_loc;\t/* Location in new bucket to put element. */\n  bucket_element *old_el;\t/* Pointer into the old bucket. */\n  int\t       select;\t\t/* Used to index bucket during movement. */\n  \n  /* No directories are yet old. */\n  old_count = 0;\n\n  if (dbf->bucket_cache == NULL)\n    {\n      if (_gdbm_init_cache (dbf, DEFAULT_CACHESIZE) == -1)\n\t{\n\t  _gdbm_fatal (dbf, _(\"couldn't init cache\"));\n\t  return -1;\n\t}\n    }\n\n  while (dbf->bucket->count == dbf->header->bucket_elems)\n    {\n      /* Initialize the \"new\" buckets in the cache. */\n      do\n\t{\n\t  dbf->last_read = (dbf->last_read + 1) % dbf->cache_size;\n\t  cache_0 = dbf->last_read;\n\t}      \n      while (dbf->bucket_cache[cache_0].ca_bucket == dbf->bucket);\n      bucket[0] = dbf->bucket_cache[cache_0].ca_bucket;\n      if (dbf->bucket_cache[cache_0].ca_changed)\n\t{\n\t  if (_gdbm_write_bucket (dbf, &dbf->bucket_cache[cache_0]))\n\t    return -1;\n\t}\n      do\n\t{\n\t  dbf->last_read = (dbf->last_read + 1) % dbf->cache_size;\n\t  cache_1 = dbf->last_read;\n\t}      \n      while (dbf->bucket_cache[cache_1].ca_bucket == dbf->bucket);\n      bucket[1] = dbf->bucket_cache[cache_1].ca_bucket;\n      if (dbf->bucket_cache[cache_1].ca_changed)\n\t{\n\t  if (_gdbm_write_bucket (dbf, &dbf->bucket_cache[cache_1]))\n\t    return -1;\n\t}\n      new_bits = dbf->bucket->bucket_bits + 1;\n      _gdbm_new_bucket (dbf, bucket[0], new_bits);\n      _gdbm_new_bucket (dbf, bucket[1], new_bits);\n      adr_0 = _gdbm_alloc (dbf, dbf->header->bucket_size);\n      if (adr_0 == 0)\n\treturn -1;\n      dbf->bucket_cache[cache_0].ca_adr = adr_0;\n      adr_1 = _gdbm_alloc (dbf, dbf->header->bucket_size);\n      if (adr_1 == 0)\n\treturn -1;\n      dbf->bucket_cache[cache_1].ca_adr = adr_1;\n\n      /* Double the directory size if necessary. */\n      if (dbf->header->dir_bits == dbf->bucket->bucket_bits)\n\t{\n\t  if (dbf->header->dir_size >= GDBM_MAX_DIR_HALF)\n\t    {\n\t      GDBM_SET_ERRNO (dbf, GDBM_DIR_OVERFLOW, TRUE);\n\t      _gdbm_fatal (dbf, _(\"directory overflow\"));\n\t      return -1;\n\t    }\n\t  dir_size = dbf->header->dir_size * 2;\n\t  dir_adr  = _gdbm_alloc (dbf, dir_size);\n\t  if (dir_adr == 0)\n\t    return -1;\n\t  new_dir = malloc (dir_size);\n\t  if (new_dir == NULL)\n\t    {\n\t      GDBM_SET_ERRNO (dbf, GDBM_MALLOC_ERROR, TRUE);\n\t      _gdbm_fatal (dbf, _(\"malloc error\"));\n\t      return -1;\n\t    }\n\n\t  for (index = 0; index < GDBM_DIR_COUNT (dbf); index++)\n\t    {\n\t      new_dir[2*index]   = dbf->dir[index];\n\t      new_dir[2*index+1] = dbf->dir[index];\n\t    }\n\t  \n\t  /* Update header. */\n\t  old_adr[old_count] = dbf->header->dir;\n\t  dbf->header->dir = dir_adr;\n\t  old_size[old_count] = dbf->header->dir_size;\n\t  dbf->header->dir_size = dir_size;\n\t  dbf->header->dir_bits = new_bits;\n\t  old_count++;\n\t  \n\t  /* Now update dbf.  */\n\t  dbf->header_changed = TRUE;\n\t  dbf->bucket_dir *= 2;\n\t  free (dbf->dir);\n\t  dbf->dir = new_dir;\n\t}\n\n      /* Copy all elements in dbf->bucket into the new buckets. */\n      for (index = 0; index < dbf->header->bucket_elems; index++)\n\t{\n\t  old_el = &dbf->bucket->h_table[index];\n\t  select = (old_el->hash_value >> (GDBM_HASH_BITS - new_bits)) & 1;\n\t  elem_loc = old_el->hash_value % dbf->header->bucket_elems;\n\t  while (bucket[select]->h_table[elem_loc].hash_value != -1)\n\t    elem_loc = (elem_loc + 1) % dbf->header->bucket_elems;\n\t  bucket[select]->h_table[elem_loc] = *old_el;\n\t  bucket[select]->count++;\n\t}\n      \n      /* Allocate avail space for the bucket[1]. */\n      bucket[1]->bucket_avail[0].av_adr\n\t= _gdbm_alloc (dbf, dbf->header->block_size);\n      if (bucket[1]->bucket_avail[0].av_adr == 0)\n\treturn -1;\n      bucket[1]->bucket_avail[0].av_size = dbf->header->block_size;\n      bucket[1]->av_count = 1;\n      \n      /* Copy the avail elements in dbf->bucket to bucket[0]. */\n      bucket[0]->av_count = dbf->bucket->av_count;\n      index = 0;\n      index1 = 0;\n      if (bucket[0]->av_count == BUCKET_AVAIL)\n\t{\n\t  /* The avail is full, move the first one to bucket[1]. */\n\t  _gdbm_put_av_elem (dbf->bucket->bucket_avail[0],\n\t\t\t     bucket[1]->bucket_avail,\n\t\t\t     &bucket[1]->av_count, FALSE);\n\t  index = 1;\n\t  bucket[0]->av_count--;\n\t}\n      for (; index < dbf->bucket->av_count; index++)\n\t{\n\t  bucket[0]->bucket_avail[index1++] = dbf->bucket->bucket_avail[index];\n\t}\n      \n      /* Update the directory.  We have new file addresses for both buckets. */\n      dir_start1 = (dbf->bucket_dir >> (dbf->header->dir_bits - new_bits)) | 1;\n      dir_end = (dir_start1 + 1) << (dbf->header->dir_bits - new_bits);\n      dir_start1 = dir_start1 << (dbf->header->dir_bits - new_bits);\n      dir_start0 = dir_start1 - (dir_end - dir_start1);\n      for (index = dir_start0; index < dir_start1; index++)\n\tdbf->dir[index] = adr_0;\n      for (index = dir_start1; index < dir_end; index++)\n\tdbf->dir[index] = adr_1;\n      \n      \n      /* Set changed flags. */\n      dbf->bucket_cache[cache_0].ca_changed = TRUE;\n      dbf->bucket_cache[cache_1].ca_changed = TRUE;\n      dbf->bucket_changed = TRUE;\n      dbf->directory_changed = TRUE;\n      dbf->second_changed = TRUE;\n      \n      /* Update the cache! */\n      dbf->bucket_dir = _gdbm_bucket_dir (dbf, next_insert);\n      \n      /* Invalidate old cache entry. */\n      old_bucket.av_adr  = dbf->cache_entry->ca_adr;\n      old_bucket.av_size = dbf->header->bucket_size;\n      dbf->cache_entry->ca_adr = 0;\n      dbf->cache_entry->ca_changed = FALSE;\n      \n      /* Set dbf->bucket to the proper bucket. */\n      if (dbf->dir[dbf->bucket_dir] == adr_0)\n\t{\n\t  dbf->bucket = bucket[0];\n\t  dbf->cache_entry = &dbf->bucket_cache[cache_0];\n\t  _gdbm_put_av_elem (old_bucket,\n\t\t\t     bucket[1]->bucket_avail,\n\t\t\t     &bucket[1]->av_count, FALSE);\n\t}\n      else\n\t{\n\t  dbf->bucket = bucket[1];\n\t  dbf->cache_entry = &dbf->bucket_cache[cache_1];\n\t  _gdbm_put_av_elem (old_bucket,\n\t\t\t     bucket[0]->bucket_avail,\n\t\t\t     &bucket[0]->av_count, FALSE);\n\t}\n      \n    }\n\n  /* Get rid of old directories. */\n  for (index = 0; index < old_count; index++)\n    if (_gdbm_free (dbf, old_adr[index], old_size[index]))\n      return -1;\n\n  return 0;\n}",
      "lines": 214,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_write_bucket": {
      "start_point": [
        431,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "int\n_gdbm_write_bucket (GDBM_FILE dbf, cache_elem *ca_entry)\n{\n  int rc;\n  off_t file_pos;\t/* The return value for lseek. */\n\n  file_pos = gdbm_file_seek (dbf, ca_entry->ca_adr, SEEK_SET);\n  if (file_pos != ca_entry->ca_adr)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_FILE_SEEK_ERROR, TRUE);\n      _gdbm_fatal (dbf, _(\"lseek error\"));\n      return -1;\n    }\n  rc = _gdbm_full_write (dbf, ca_entry->ca_bucket, dbf->header->bucket_size);\n  if (rc)\n    {\n      GDBM_DEBUG (GDBM_DEBUG_STORE|GDBM_DEBUG_ERR,\n\t\t  \"%s: error writing bucket: %s\",\n\t\t  dbf->name, gdbm_db_strerror (dbf));\t  \n      _gdbm_fatal (dbf, gdbm_strerror (rc));\n      return -1;\n    }\n\n  ca_entry->ca_changed = FALSE;\n  ca_entry->ca_data.hash_val = -1;\n  ca_entry->ca_data.elem_loc = -1;\n  return 0;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/datconv.c": {
    "f_stringz": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static int\nf_stringz (FILE *fp, void *ptr, int size)\n{\n  int sz;\n  char *s;\n  \n  for (sz = 1, s = ptr; *s; s++, sz++)\n    {\n      int c;\n      \n      if (isprint (*s))\n\tfputc (*s, fp);\n      else if ((c = escape (*s)))\n\tfprintf (fp, \"\\\\%c\", c);\n      else\n\tfprintf (fp, \"\\\\%03o\", *s);\n    }\n  return sz;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "f_string": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static int\nf_string (FILE *fp, void *ptr, int size)\n{\n  int sz;\n  char *s;\n  \n  for (sz = 0, s = ptr; sz < size; s++, sz++)\n    {\n      int c;\n      \n      if (isprint (*s))\n\tfputc (*s, fp);\n      else if ((c = escape (*s)))\n\tfprintf (fp, \"\\\\%c\", c);\n      else\n\tfprintf (fp, \"\\\\%03o\", *s);\n    }\n  return sz;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "s_char": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "int\ns_char (struct xdatum *xd, char *str)\n{\n  xd_store (xd, str, 1);\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "s_double": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\ns_double (struct xdatum *xd, char *str)\n{\n  double d;\n  char *p;\n  \n  errno = 0;\n  d = strtod (str, &p);\n  if (errno || *p)\n    return 1;\n  xd_store (xd, &d, sizeof (d));\n  return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "s_float": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\ns_float (struct xdatum *xd, char *str)\n{\n  float d;\n  char *p;\n  \n  errno = 0;\n  d = strtod (str, &p);\n  if (errno || *p)\n    return 1;\n  xd_store (xd, &d, sizeof (d));\n  return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "s_stringz": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\ns_stringz (struct xdatum *xd, char *str)\n{\n  xd_store (xd, str, strlen (str) + 1);\n  return 0;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "s_string": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ns_string (struct xdatum *xd, char *str)\n{\n  xd_store (xd, str, strlen (str));\n  return 0;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "datadef_lookup": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "struct datadef *\ndatadef_lookup (const char *name)\n{\n  struct datadef *p;\n\n  for (p = datatab; p->name; p++)\n    if (strcmp (p->name, name) == 0)\n      return p;\n  return NULL;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "struct datadef",
        "struct",
        "datadef",
        "*\ndatadef_lookup (const char *name)",
        "*"
      ]
    },
    "dsegm_new": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "struct dsegm *\ndsegm_new (int type)\n{\n  struct dsegm *p = emalloc (sizeof (*p));\n  p->next = NULL;\n  p->type = type;\n  return p;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "struct dsegm",
        "struct",
        "dsegm",
        "*\ndsegm_new (int type)",
        "*"
      ]
    },
    "dsegm_new_field": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "struct dsegm *\ndsegm_new_field (struct datadef *type, char *id, int dim)\n{\n  struct dsegm *p = dsegm_new (FDEF_FLD);\n  p->v.field.type = type;\n  p->v.field.name = id;\n  p->v.field.dim = dim;\n  return p;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "struct dsegm",
        "struct",
        "dsegm",
        "*\ndsegm_new_field (struct datadef *type, char *id, int dim)",
        "*"
      ]
    },
    "dsegm_free_list": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "void\ndsegm_free_list (struct dsegm *dp)\n{\n  while (dp)\n    {\n      struct dsegm *next = dp->next;\n      free (dp);\n      dp = next;\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "datum_format": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void\ndatum_format (FILE *fp, datum const *dat, struct dsegm *ds)\n{\n  int off = 0;\n  char *delim[2];\n  int first_field = 1;\n  \n  if (!ds)\n    {\n      fprintf (fp, \"%.*s\\n\", dat->dsize, dat->dptr);\n      return;\n    }\n\n  if (variable_get (\"delim1\", VART_STRING, (void*) &delim[0]))\n    abort ();\n  if (variable_get (\"delim2\", VART_STRING, (void*) &delim[1]))\n    abort ();\n  \n  for (; ds && off <= dat->dsize; ds = ds->next)\n    {\n      switch (ds->type)\n\t{\n\tcase FDEF_FLD:\n\t  if (!first_field)\n\t    fwrite (delim[1], strlen (delim[1]), 1, fp);\n\t  if (ds->v.field.name)\n\t    fprintf (fp, \"%s=\", ds->v.field.name);\n\t  if (ds->v.field.dim > 1)\n\t    fprintf (fp, \"{ \");\n\t  if (ds->v.field.type->format)\n\t    {\n\t      int i, n;\n\n\t      for (i = 0; i < ds->v.field.dim; i++)\n\t\t{\n\t\t  if (i)\n\t\t    fwrite (delim[0], strlen (delim[0]), 1, fp);\n\t\t  if (off + ds->v.field.type->size > dat->dsize)\n\t\t    {\n\t\t      fprintf (fp, _(\"(not enough data)\"));\n\t\t      off += dat->dsize;\n\t\t      break;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      n = ds->v.field.type->format (fp,\n\t\t\t\t\t\t    (char*) dat->dptr + off,\n\t\t\t\t\t\t    ds->v.field.type->size ?\n\t\t\t\t\t\t      ds->v.field.type->size :\n\t\t\t\t\t\t      dat->dsize - off);\n\t\t      off += n;\n\t\t    }\n\t\t}\n\t    }\n\t  if (ds->v.field.dim > 1)\n\t    fprintf (fp, \" }\");\n\t  first_field = 0;\n\t  break;\n\t  \n\tcase FDEF_OFF:\n\t  off = ds->v.n;\n\t  break;\n\t  \n\tcase FDEF_PAD:\n\t  off += ds->v.n;\n\t  break;\n\t}\n    }\n}",
      "lines": 69,
      "depth": 23,
      "decorators": [
        "void"
      ]
    },
    "xd_expand": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "void\nxd_expand (struct xdatum *xd, size_t size)\n{\n  if (xd->dmax < size)\n    {\n      xd->dptr = erealloc (xd->dptr, size);\n      memset (xd->dptr + xd->dmax, 0, size - xd->dmax);\n      xd->dmax = size;\n    }\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "xd_store": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "void\nxd_store (struct xdatum *xd, void *val, size_t size)\n{\n  xd_expand (xd, xd->off + size);\n  memcpy (xd->dptr + xd->off, val, size);\n  xd->off += size;\n  if (xd->off > xd->dsize)\n    xd->dsize = xd->off;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "datum_scan_notag": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        407,
        1
      ],
      "content": "static int\ndatum_scan_notag (datum *dat, struct dsegm *ds, struct kvpair *kv)\n{\n  struct xdatum xd;\n  int i;\n  struct slist *s;\n  int err = 0;\n  \n  memset (&xd, 0, sizeof (xd));\n  \n  for (; err == 0 && ds && kv; ds = ds->next, kv = kv->next)\n    {\n      if (kv->key)\n\t{\n\t  lerror (&kv->loc,\n\t\t       _(\"mixing tagged and untagged values is not allowed\"));\n\t  err = 1;\n\t  break;\n\t}\n      \n      switch (ds->type)\n\t{\n\tcase FDEF_FLD:\n\t  if (!ds->v.field.type->scan)\n\t    abort ();\n\n\t  if (kv->type == KV_STRING && ds->v.field.dim > 1)\n\t    {\n\t      /* If a char[] value was supplied as a quoted string.\n\t         convert it it list for further processing */\n\t      if (ds->v.field.type->size == 1)\n\t\t{\n\t\t  struct slist *head = slist_new_l (kv->val.s, 1);\n\t\t  struct slist *tail = head;\n\t\t  char *s;\n\t\t  for (s = kv->val.s + 1; *s; s++)\n\t\t    slist_insert (&tail, slist_new_l (s, 1));\n\t\t  free (kv->val.s);\n\t\t  kv->val.l = head;\n\t\t  kv->type = KV_LIST;\n\t\t}\n\t    }\n\t  \n\t  switch (kv->type)\n\t    {\n\t    case KV_STRING:\n\t      err = ds->v.field.type->scan (&xd, kv->val.s);\n\t      if (err)\n\t\tlerror (&kv->loc, _(\"cannot convert\"));\n\t      break;\n\t      \n\t    case KV_LIST:\n\t      for (i = 0, s = kv->val.l; i < ds->v.field.dim && s;\n\t\t   i++, s = s->next)\n\t\t{\n\t\t  err = ds->v.field.type->scan (&xd, s->str);\n\t\t  if (err)\n\t\t    {\n\t\t      lerror (&kv->loc,\n\t\t\t\t   _(\"cannot convert value #%d: %s\"),\n\t\t\t\t   i, s->str);\n\t\t      break;\n\t\t    }\n\t\t}\n\t      if (s)\n\t\t{\n\t\t  lerror (&kv->loc, \"surplus initializers ignored\");\n\t\t  err = 1;\n\t\t}\n\t    }\t\t\t\t      \n\t  break;\n\n\tcase FDEF_OFF:\n\t  xd_expand (&xd, ds->v.n);\n\t  xd.off = ds->v.n;\n\t  break;\n\t  \n\tcase FDEF_PAD:\n\t  xd_expand (&xd, xd.off + ds->v.n);\n\t  xd.off += ds->v.n;\n\t  break;\n\t}\n    }\n\n  if (err)\n    {\n      free (xd.dptr);\n      return 1;\n    }\n\n  dat->dptr  = xd.dptr;\n  dat->dsize = xd.dsize;\n      \n  return 0;\n}",
      "lines": 95,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "datum_scan_tag": {
      "start_point": [
        409,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "static int\ndatum_scan_tag (datum *dat, struct dsegm *ds, struct kvpair *kv)\n{\n  lerror (&kv->loc, \"tagged values are not yet supported\");\n  return 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "datum_scan": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        420,
        1
      ],
      "content": "int\ndatum_scan (datum *dat, struct dsegm *ds, struct kvpair *kv)\n{\n  return (kv->key ? datum_scan_tag : datum_scan_notag) (dat, ds, kv);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "dsprint": {
      "start_point": [
        422,
        0
      ],
      "end_point": [
        462,
        1
      ],
      "content": "void\ndsprint (FILE *fp, int what, struct dsegm *ds)\n{\n  static char *dsstr[] = { \"key\", \"content\" };\n  int delim;\n  \n  fprintf (fp, \"define %s\", dsstr[what]);\n  if (ds->next)\n    {\n      fprintf (fp, \" {\\n\");\n      delim = '\\t';\n    }\n  else\n    delim = ' ';\n  for (; ds; ds = ds->next)\n    {\n      switch (ds->type)\n\t{\n\tcase FDEF_FLD:\n\t  fprintf (fp, \"%c%s\", delim, ds->v.field.type->name);\n\t  if (ds->v.field.name)\n\t    fprintf (fp, \" %s\", ds->v.field.name);\n\t  if (ds->v.field.dim > 1)\n\t    fprintf (fp, \"[%d]\", ds->v.field.dim);\n\t  break;\n\t  \n\tcase FDEF_OFF:\n\t  fprintf (fp, \"%coffset %d\", delim, ds->v.n);\n\t  break;\n\n\tcase FDEF_PAD:\n\t  fprintf (fp, \"%cpad %d\", delim, ds->v.n);\n\t  break;\n\t}\n      if (ds->next)\n\tfputc (',', fp);\n      fputc ('\\n', fp);\n    }\n  if (delim == '\\t')\n    fputs (\"}\\n\", fp);\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/debug.c": {
    "gdbm_debug_token": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\ngdbm_debug_token (char const *tok)\n{\n  int i;\n\n  for (i = 0; gdbm_debug_token_tab[i].name; i++)\n    if (strcmp (gdbm_debug_token_tab[i].name, tok) == 0)\n      return gdbm_debug_token_tab[i].flag;\n\n  return 0;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "gdbm_debug_parse_state": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\ngdbm_debug_parse_state (int (*f) (void *, int, char const *), void *d)\n{\n  int i;\n  \n  for (i = 0; gdbm_debug_token_tab[i].name; i++)\n    {\n      if (gdbm_debug_token_tab[i].flag == GDBM_DEBUG_ALL)\n\tcontinue;\n      if (gdbm_debug_flags & gdbm_debug_token_tab[i].flag)\n\t{\n\t  if (f (d, gdbm_debug_token_tab[i].flag, gdbm_debug_token_tab[i].name))\n\t    break;\n\t}\n    }\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "datbuf_format": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static int\ndatbuf_format (char vbuf[DATBUFSIZE], const char *buf, size_t size)\n{\n  char *p = vbuf;\n  char *q = vbuf + 51;\n  int i;\n  size_t j = 0;\n  static char hexchar[] = \"0123456789ABCDEF\";\n  \n  for (i = 0; i < 16; i++)\n    {\n      unsigned c;\n      if (j < size)\n\t{\n\t  c = *(const unsigned char*)buf++;\n\t  j++;\n\n\t  *p++ = hexchar[c >> 4];\n\t  *p++ = hexchar[c & 0xf];\n\t  *p++ = ' ';\n\t  \n\t  *q++ = isprint (c) ? c : '.';\n\t  if (i == 7)\n\t    {\n\t      *p++ = ' ';\n\t      *q++ = ' ';\n\t    }\n\t}\n      else\n\t{\n\t  *p++ = ' ';\n\t  *p++ = ' ';\n\t  *p++ = ' ';\n\t  *q++ = ' ';\n\t}\n    }\n  *p++ = ' ';\n  *p = ' ';\n  *q = 0;\n  return j;\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gdbm_debug_datum": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\ngdbm_debug_datum (datum dat, char const *pfx)\n{\n  char const *buf = dat.dptr;\n  size_t size = dat.dsize;\n  unsigned off;\n  char vbuf[DATBUFSIZE];\n\n  if (!buf)\n    {\n      gdbm_debug_printer (\"%s%s\\n\", pfx, \"NULL\");\n      return;\n    }\n\n  gdbm_debug_printer (\"size=%d\\n\", size);\n  off = 0;\n  while (size)\n    {\n      size_t rd = datbuf_format (vbuf, buf, size);\n      gdbm_debug_printer (\"%s%04x:  %s\\n\", pfx, off, vbuf);\n      size -= rd;\n      buf += rd;\n      off += rd;\n    }\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/err.c": {
    "prerror": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static void\nprerror (const char *fmt, va_list ap, const char *diag, const char *sysdiag)\n{\n  fprintf (stderr, \"%s: \", progname);\n  vfprintf (stderr, fmt, ap);\n  if (diag)\n    fprintf (stderr, \": %s\", diag);\n  if (sysdiag)\n    fprintf (stderr, \": %s\", sysdiag);\n  fputc ('\\n', stderr);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "verror": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\nverror (const char *fmt, va_list ap)\n{\n  prerror (fmt, ap, NULL, NULL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "error": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nerror (const char *fmt, ...)\n{\n  va_list ap;\n  va_start (ap, fmt);\n  verror (fmt, ap);\n  va_end (ap);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "sys_perror": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\nsys_perror (int code, const char *fmt, ...)\n{\n  va_list ap;\n  va_start (ap, fmt);\n  prerror (fmt, ap, strerror (code), NULL);\n  va_end (ap);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "gdbm_perror": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\ngdbm_perror (const char *fmt, ...)\n{\n  va_list ap;\n  va_start (ap, fmt);\n  prerror (fmt, ap, gdbm_strerror (gdbm_errno),\n\t   gdbm_syserr[gdbm_errno] ? strerror (errno) : NULL);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/falloc.c": {
    "_gdbm_alloc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "off_t\n_gdbm_alloc (GDBM_FILE dbf, int num_bytes)\n{\n  off_t file_adr;\t\t/* The address of the block. */\n  avail_elem av_el;\t\t/* For temporary use. */\n\n  /* The current bucket is the first place to look for space. */\n  av_el = get_elem (num_bytes, dbf->bucket->bucket_avail,\n\t\t    &dbf->bucket->av_count);\n\n  /* If we did not find some space, we have more work to do. */\n  if (av_el.av_size == 0)\n    {\n      /* If the header avail table is less than half full, and there's\n\t something on the stack. */\n      if ((dbf->header->avail.count <= (dbf->header->avail.size >> 1))\n          && (dbf->header->avail.next_block != 0))\n        if (pop_avail_block (dbf))\n\t  return 0;\n\n      /* check the header avail table next */\n      av_el = get_elem (num_bytes, dbf->header->avail.av_table,\n      \t\t\t&dbf->header->avail.count);\n      if (av_el.av_size == 0)\n        /* Get another full block from end of file. */\n        av_el = get_block (num_bytes, dbf);\n\n      dbf->header_changed = TRUE;\n    }\n\n  /* We now have the place from which we will allocate the new space. */\n  file_adr = av_el.av_adr;\n\n  /* Put the unused space back in the avail block. */\n  av_el.av_adr += num_bytes;\n  av_el.av_size -= num_bytes;\n  if (_gdbm_free (dbf, av_el.av_adr, av_el.av_size))\n    return 0;\n\n  /* Return the address. */\n  return file_adr;\n  \n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "off_t"
      ]
    },
    "_gdbm_free": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "int\n_gdbm_free (GDBM_FILE dbf, off_t file_adr, int num_bytes)\n{\n  avail_elem temp;\n\n  /* Is it too small to worry about? */\n  if (num_bytes <= IGNORE_SIZE)\n    return 0;\n\n  /* Initialize the avail element. */\n  temp.av_size = num_bytes;\n  temp.av_adr = file_adr;\n\n  /* Is the freed space large or small? */\n  if ((num_bytes >= dbf->header->block_size) || dbf->central_free)\n    {\n      if (dbf->header->avail.count == dbf->header->avail.size)\n\t{\n\t  if (push_avail_block (dbf))\n\t    return -1;\n\t}\n      _gdbm_put_av_elem (temp, dbf->header->avail.av_table,\n\t\t\t &dbf->header->avail.count, dbf->coalesce_blocks);\n      dbf->header_changed = TRUE;\n    }\n  else\n    {\n      /* Try to put into the current bucket. */\n      if (dbf->bucket->av_count < BUCKET_AVAIL)\n\t_gdbm_put_av_elem (temp, dbf->bucket->bucket_avail,\n\t\t\t   &dbf->bucket->av_count, dbf->coalesce_blocks);\n      else\n\t{\n\t  if (dbf->header->avail.count == dbf->header->avail.size)\n\t    {\n\t      if (push_avail_block (dbf))\n\t\treturn -1;\n\t    }\n\t  _gdbm_put_av_elem (temp, dbf->header->avail.av_table,\n\t\t\t     &dbf->header->avail.count, dbf->coalesce_blocks);\n\t  dbf->header_changed = TRUE;\n\t}\n    }\n\n  if (dbf->header_changed && adjust_bucket_avail (dbf))\n    return -1;\n\n  /* All work is done. */\n  return 0;\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "pop_avail_block": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static int\npop_avail_block (GDBM_FILE dbf)\n{\n  int rc;\n  off_t file_pos;\t\t/* For use with the lseek system call. */\n  avail_elem new_el;\n  avail_block *new_blk;\n  int index;\n  \n  if (dbf->header->avail.count == dbf->header->avail.size)\n    {\n      /* We're kind of stuck here, so we re-split the header in order to\n         avoid crashing.  Sigh. */\n      if (push_avail_block (dbf))\n\treturn -1;\n    }\n\n  /* Set up variables. */\n  new_el.av_adr = dbf->header->avail.next_block;\n  new_el.av_size = ( ( (dbf->header->avail.size * sizeof (avail_elem)) >> 1)\n\t\t\t+ sizeof (avail_block));\n\n  /* Allocate space for the block. */\n  new_blk = malloc (new_el.av_size);\n  if (new_blk == NULL)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_MALLOC_ERROR, TRUE);\n      _gdbm_fatal (dbf, _(\"malloc failed\"));\n      return -1;\n    }\n\n  /* Read the block. */\n  file_pos = gdbm_file_seek (dbf, new_el.av_adr, SEEK_SET);\n  if (file_pos != new_el.av_adr)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_FILE_SEEK_ERROR, TRUE);\n      free (new_blk);\n      _gdbm_fatal (dbf, _(\"lseek error\"));\n      return -1;\n    }\n\n  rc = _gdbm_full_read (dbf, new_blk, new_el.av_size);\n  if (rc)\n    {\n      free (new_blk);\n      _gdbm_fatal (dbf, gdbm_db_strerror (dbf));\n      return -1;\n    }\n\n  if (gdbm_avail_block_validate (dbf, new_blk))\n    {\n      free (new_blk);\n      _gdbm_fatal (dbf, gdbm_db_strerror (dbf));\n      return -1;\n    }\n\n  /* Add the elements from the new block to the header. */\n  index = 0;\n  while (index < new_blk->count)\n    {\n      while (index < new_blk->count\n\t     && dbf->header->avail.count < dbf->header->avail.size)\n\t{\n\t   /* With luck, this will merge a lot of blocks! */\n\t   _gdbm_put_av_elem (new_blk->av_table[index],\n\t\t\t      dbf->header->avail.av_table,\n\t\t\t      &dbf->header->avail.count, TRUE);\n\t   index++;\n\t}\n      if (dbf->header->avail.count == dbf->header->avail.size)\n        {\n          /* We're kind of stuck here, so we re-split the header in order to\n             avoid crashing.  Sigh. */\n          if (push_avail_block (dbf))\n\t    {\n\t      free (new_blk);\n\t      return -1;\n\t    }\n\t}\n    }\n\n  /* Fix next_block, as well. */\n  dbf->header->avail.next_block = new_blk->next_block;\n\n  /* We changed the header. */\n  dbf->header_changed = TRUE;\n\n  /* Free the previous avail block.   It is possible that the header table\n     is now FULL, which will cause us to overflow it! */\n  if (dbf->header->avail.count == dbf->header->avail.size)\n    {\n      /* We're kind of stuck here, so we re-split the header in order to\n         avoid crashing.  Sigh. */\n      if (push_avail_block (dbf))\n\t{\n\t  free (new_blk);\n\t  return -1;\n\t}\n    }\n\n  _gdbm_put_av_elem (new_el, dbf->header->avail.av_table,\n\t\t     &dbf->header->avail.count, TRUE);\n  free (new_blk);\n\n  return 0;\n}",
      "lines": 106,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "push_avail_block": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static int\npush_avail_block (GDBM_FILE dbf)\n{\n  int  av_size;\n  off_t av_adr;\n  int  index;\n  off_t file_pos;\n  avail_block *temp;\n  avail_elem  new_loc;\n  int rc;\n\n  /* Caclulate the size of the split block. */\n  av_size = ( (dbf->header->avail.size * sizeof (avail_elem)) >> 1)\n            + sizeof (avail_block);\n\n  /* Get address in file for new av_size bytes. */\n  new_loc = get_elem (av_size, dbf->header->avail.av_table,\n\t\t      &dbf->header->avail.count);\n  if (new_loc.av_size == 0)\n    new_loc = get_block (av_size, dbf);\n  av_adr = new_loc.av_adr;\n\n  /* Split the header block. */\n  temp = calloc (1, av_size);\n  if (temp == NULL)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_MALLOC_ERROR, TRUE);\n      _gdbm_fatal (dbf, _(\"malloc error\"));\n      return -1;\n    }\n\n  /* Set the size to be correct AFTER the pop_avail_block. */\n  temp->size = dbf->header->avail.size;\n  temp->count = 0;\n  temp->next_block = dbf->header->avail.next_block;\n  dbf->header->avail.next_block = av_adr;\n  for (index = 1; index < dbf->header->avail.count; index++)\n    if ( (index & 0x1) == 1)\t/* Index is odd. */\n      temp->av_table[temp->count++] = dbf->header->avail.av_table[index];\n    else\n      dbf->header->avail.av_table[index>>1]\n\t= dbf->header->avail.av_table[index];\n\n  /* Update the header avail count to previous size divided by 2. */\n  dbf->header->avail.count >>= 1;\n\n  /* Free the unneeded space. */\n  new_loc.av_adr += av_size;\n  new_loc.av_size -= av_size;\n  _gdbm_free (dbf, new_loc.av_adr, new_loc.av_size);\n\n  /* Update the disk. */\n  file_pos = gdbm_file_seek (dbf, av_adr, SEEK_SET);\n  if (file_pos != av_adr)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_FILE_SEEK_ERROR, TRUE);\n      _gdbm_fatal (dbf, _(\"lseek error\"));\n      return -1;\n    }\n\n  rc = _gdbm_full_write (dbf, temp, av_size);\n  if (rc)\n    {\n      GDBM_DEBUG (GDBM_DEBUG_STORE|GDBM_DEBUG_ERR,\n\t\t  \"%s: error writing avail data: %s\",\n\t\t  dbf->name, gdbm_db_strerror (dbf));\t  \n      _gdbm_fatal (dbf, gdbm_db_strerror (dbf));\n      return -1;\n    }\n\n  free (temp);\n\n  return 0;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_elem": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static avail_elem\nget_elem (int size, avail_elem av_table[], int *av_count)\n{\n  int index;\t\t\t/* For searching through the avail block. */\n  avail_elem val;\t\t/* The default return value. */\n\n  /* Initialize default return value. */\n  val.av_adr = 0;\n  val.av_size = 0;\n\n  /* Search for element.  List is sorted by size. */\n  index = 0;\n  while (index < *av_count && av_table[index].av_size < size)\n    {\n      index++;\n    }\n\n  /* Did we find one of the right size? */\n  if (index >= *av_count)\n    return val;\n\n  /* Ok, save that element and move all others up one. */\n  val = av_table[index];\n  *av_count -= 1;\n  while (index < *av_count)\n    {\n      av_table[index] = av_table[index+1];\n      index++;\n    }\n\n  return val;\n}",
      "lines": 32,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "avail_elem"
      ]
    },
    "_gdbm_put_av_elem": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "int\n_gdbm_put_av_elem (avail_elem new_el, avail_elem av_table[], int *av_count,\n     \t\t   int can_merge)\n{\n  int index;\t\t\t/* For searching through the avail block. */\n  int index1;\n\n  /* Is it too small to deal with? */\n  if (new_el.av_size <= IGNORE_SIZE)\n    return FALSE;\n\n  if (can_merge == TRUE)\n    {\n      /* Search for blocks to coalesce with this one. */\n      index = 0;\n\n      while (index < *av_count)\n\t{\n\t  /* Can we merge with the previous block? */\n\t  if ((av_table[index].av_adr\n\t       + av_table[index].av_size) == new_el.av_adr)\n\t    {\n\t      /* Simply expand the entry. */\n\t      av_table[index].av_size += new_el.av_size;\n\t    }\n\t    /* Can we merge with the next block? */\n\t    else if ((new_el.av_adr\n\t      \t      + new_el.av_size) == av_table[index].av_adr)\n\t      {\n\t        /* Update this entry. */\n\t        av_table[index].av_adr = new_el.av_adr;\n\t\tav_table[index].av_size += new_el.av_size;\n\t      }\n\t    /* Not contiguous */\n\t    else\n\t      {\n\t\tindex++;\n\t\tcontinue;\n\t      }\n\t    \n\t    /* If we got here, we're done. */\n\t    return TRUE;\n\t}\n    }\n\n  /* Search for place to put element.  List is sorted by size. */\n  index = 0;\n  while (index < *av_count && av_table[index].av_size < new_el.av_size)\n    {\n      index++;\n    }\n\n  /* Move all others up one. */\n  index1 = *av_count-1;\n  while (index1 >= index)\n    {\n      av_table[index1+1] = av_table[index1];\n      index1--;\n    }\n\n  /* Add the new element. */\n  av_table[index] = new_el;\n\n  /* Increment the number of elements. */\n  *av_count += 1;\n\n  return TRUE;\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "get_block": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "static avail_elem\nget_block (int size, GDBM_FILE dbf)\n{\n  avail_elem val;\n\n  /* Need at least one block. */\n  val.av_adr  = dbf->header->next_block;\n  val.av_size = dbf->header->block_size;\n\n  /* Get enough blocks to fit the need. */\n  while (val.av_size < size)\n    val.av_size += dbf->header->block_size;\n\n  /* Update the header and return. */\n  dbf->header->next_block += val.av_size;\n\n  /* We changed the header. */\n  dbf->header_changed = TRUE;\n\n  return val;\n  \n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "avail_elem"
      ]
    },
    "adjust_bucket_avail": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        533,
        1
      ],
      "content": "static int\nadjust_bucket_avail (GDBM_FILE dbf)\n{\n  int third = BUCKET_AVAIL / 3;\n  avail_elem av_el;\n\n  /* Can we add more entries to the bucket? */\n  if (dbf->bucket->av_count < third)\n    {\n      if (dbf->header->avail.count > 0)\n\t{\n\t  //FIXME: what if _gdbm_put_av_elem return FALSE?\n\t  dbf->header->avail.count -= 1;\n\t  av_el = dbf->header->avail.av_table[dbf->header->avail.count];\n\t  _gdbm_put_av_elem (av_el, dbf->bucket->bucket_avail,\n\t\t\t     &dbf->bucket->av_count, dbf->coalesce_blocks);\n\t  dbf->bucket_changed = TRUE;\n\t}\n      return 0;\n    }\n\n  /* Is there too much in the bucket? */\n  while (dbf->bucket->av_count > BUCKET_AVAIL-third\n\t && dbf->header->avail.count < dbf->header->avail.size)\n    {\n      av_el = get_elem (0, dbf->bucket->bucket_avail, &dbf->bucket->av_count);\n      if (av_el.av_size == 0\n\t  || _gdbm_put_av_elem (av_el, dbf->header->avail.av_table,\n\t\t\t\t&dbf->header->avail.count,\n\t\t\t\tdbf->coalesce_blocks) == FALSE) \n\t{\n\t  GDBM_SET_ERRNO (dbf, GDBM_BAD_AVAIL, TRUE);\n\t  return -1;\n\t}\n      dbf->bucket_changed = TRUE;\n    }\n  return 0;\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/findkey.c": {
    "gdbm_bucket_element_valid_p": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\ngdbm_bucket_element_valid_p (GDBM_FILE dbf, int elem_loc)\n{\n  return\n    elem_loc < dbf->header->bucket_elems\n    && dbf->bucket->h_table[elem_loc].hash_value != -1\n    && dbf->bucket->h_table[elem_loc].key_size >= 0\n    && off_t_sum_ok (dbf->bucket->h_table[elem_loc].data_pointer,\n\t\t     dbf->bucket->h_table[elem_loc].key_size)\n    && dbf->bucket->h_table[elem_loc].data_size >= 0\n    && off_t_sum_ok (dbf->bucket->h_table[elem_loc].data_pointer\n\t\t     + dbf->bucket->h_table[elem_loc].key_size,\n\t\t     dbf->bucket->h_table[elem_loc].data_size);\n}",
      "lines": 14,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_read_entry": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "char *\n_gdbm_read_entry (GDBM_FILE dbf, int elem_loc)\n{\n  int rc;\n  int key_size;\n  int data_size;\n  size_t dsize;\n  off_t file_pos;\n  data_cache_elem *data_ca;\n\n  /* Is it already in the cache? */\n  if (dbf->cache_entry->ca_data.elem_loc == elem_loc)\n    return dbf->cache_entry->ca_data.dptr;\n\n  if (!gdbm_bucket_element_valid_p (dbf, elem_loc))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_BAD_HASH_TABLE, TRUE);\n      return NULL;\n    }\n  \n  /* Set sizes and pointers. */\n  key_size = dbf->bucket->h_table[elem_loc].key_size;\n  data_size = dbf->bucket->h_table[elem_loc].data_size;\n  dsize = key_size + data_size;\n  data_ca = &dbf->cache_entry->ca_data;\n\n  /* Set up the cache. */\n  data_ca->key_size = key_size;\n  data_ca->data_size = data_size;\n  data_ca->elem_loc = elem_loc;\n  data_ca->hash_val = dbf->bucket->h_table[elem_loc].hash_value;\n\n  if (dsize <= data_ca->dsize)\n    {\n      if (data_ca->dsize == 0)\n\t{\n\t  data_ca->dptr = malloc (1);\n\t  if (data_ca->dptr)\n\t    data_ca->dsize = 1;\n\t  else\n\t    {\n\t      GDBM_SET_ERRNO2 (dbf, GDBM_MALLOC_ERROR, FALSE, GDBM_DEBUG_LOOKUP);\n\t      _gdbm_fatal (dbf, _(\"malloc error\"));\n\t      return NULL;\n\t    }\n\t}\n    }\n  else\n    {\n      char *p = realloc (data_ca->dptr, dsize);\n      if (p)\n\t{\n\t  data_ca->dptr = p;\n\t  data_ca->dsize = dsize;\n\t}\n      else\n\t{\n\t  GDBM_SET_ERRNO2 (dbf, GDBM_MALLOC_ERROR, FALSE, GDBM_DEBUG_LOOKUP);\n\t  _gdbm_fatal (dbf, _(\"malloc error\"));\n\t  return NULL;\n\t}\n    }\n\n  /* Read into the cache. */\n  file_pos = gdbm_file_seek (dbf, dbf->bucket->h_table[elem_loc].data_pointer, \n\t\t      SEEK_SET);\n  if (file_pos != dbf->bucket->h_table[elem_loc].data_pointer)\n    {\n      GDBM_SET_ERRNO2 (dbf, GDBM_FILE_SEEK_ERROR, TRUE, GDBM_DEBUG_LOOKUP);\n      _gdbm_fatal (dbf, _(\"lseek error\"));\n      return NULL;\n    }\n  \n  rc = _gdbm_full_read (dbf, data_ca->dptr, key_size+data_size);\n  if (rc)\n    {\n      GDBM_DEBUG (GDBM_DEBUG_ERR|GDBM_DEBUG_LOOKUP|GDBM_DEBUG_READ,\n\t\t  \"%s: error reading entry: %s\",\n\t\t  dbf->name, gdbm_db_strerror (dbf));\n      dbf->need_recovery = TRUE;\n      _gdbm_fatal (dbf, gdbm_db_strerror (dbf));\n      return NULL;\n    }\n  \n  return data_ca->dptr;\n}",
      "lines": 86,
      "depth": 15,
      "decorators": [
        "char",
        "*\n_gdbm_read_entry (GDBM_FILE dbf, int elem_loc)",
        "*"
      ]
    },
    "_gdbm_findkey": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "int\n_gdbm_findkey (GDBM_FILE dbf, datum key, char **ret_dptr, int *ret_hash_val)\n{\n  int    bucket_hash_val;\t/* The hash value from the bucket. */\n  int    new_hash_val;          /* Computed hash value for the key */\n  char  *file_key;\t\t/* The complete key as stored in the file. */\n  int    bucket_dir;            /* Number of the bucket in directory. */\n  int    elem_loc;\t\t/* The location in the bucket. */\n  int    home_loc;\t\t/* The home location in the bucket. */\n  int    key_size;\t\t/* Size of the key on the file.  */\n\n  GDBM_DEBUG_DATUM (GDBM_DEBUG_LOOKUP, key, \"%s: fetching key:\", dbf->name);\n  \n  /* Compute hash value and load proper bucket.  */\n  _gdbm_hash_key (dbf, key, &new_hash_val, &bucket_dir, &elem_loc);\n\n  GDBM_DEBUG (GDBM_DEBUG_LOOKUP, \"%s: location = %#4x:%d:%d\", dbf->name,\n\t      new_hash_val, bucket_dir, elem_loc);\n\n  if (ret_hash_val)\n    *ret_hash_val = new_hash_val;\n  if (_gdbm_get_bucket (dbf, bucket_dir))\n    return -1;\n  \n  /* Is the element the last one found for this bucket? */\n  if (dbf->cache_entry->ca_data.elem_loc != -1 \n      && new_hash_val == dbf->cache_entry->ca_data.hash_val\n      && dbf->cache_entry->ca_data.key_size == key.dsize\n      && dbf->cache_entry->ca_data.dptr != NULL\n      && memcmp (dbf->cache_entry->ca_data.dptr, key.dptr, key.dsize) == 0)\n    {\n      GDBM_DEBUG (GDBM_DEBUG_LOOKUP, \"%s: found in cache\", dbf->name);\n      /* This is it. Return the cache pointer. */\n      if (ret_dptr)\n\t*ret_dptr = dbf->cache_entry->ca_data.dptr + key.dsize;\n      return dbf->cache_entry->ca_data.elem_loc;\n    }\n      \n  /* It is not the cached value, search for element in the bucket. */\n  home_loc = elem_loc;\n  bucket_hash_val = dbf->bucket->h_table[elem_loc].hash_value;\n  while (bucket_hash_val != -1)\n    {\n      key_size = dbf->bucket->h_table[elem_loc].key_size;\n      if (bucket_hash_val != new_hash_val\n\t || key_size != key.dsize\n\t || memcmp (dbf->bucket->h_table[elem_loc].key_start, key.dptr,\n\t\t\t(SMALL < key_size ? SMALL : key_size)) != 0) \n\t{\n\t  /* Current elem_loc is not the item, go to next item. */\n\t  elem_loc = (elem_loc + 1) % dbf->header->bucket_elems;\n\t  if (elem_loc == home_loc)\n\t    break;\n\t  bucket_hash_val = dbf->bucket->h_table[elem_loc].hash_value;\n\t}\n      else\n\t{\n\t  /* This may be the one we want.\n\t     The only way to tell is to read it. */\n\t  file_key = _gdbm_read_entry (dbf, elem_loc);\n\t  if (!file_key)\n\t    {\n\t      GDBM_DEBUG (GDBM_DEBUG_LOOKUP, \"%s: error reading entry: %s\",\n\t\t\t  dbf->name, gdbm_db_strerror (dbf));\n\t      return -1;\n\t    }\n\t  if (memcmp (file_key, key.dptr, key_size) == 0)\n\t    {\n\t      /* This is the item. */\n\t      GDBM_DEBUG (GDBM_DEBUG_LOOKUP, \"%s: found\", dbf->name);\n\t      if (ret_dptr)\n\t\t*ret_dptr = file_key + key.dsize;\n\t      return elem_loc;\n\t    }\n\t  else\n\t    {\n\t      /* Not the item, try the next one.  Return if not found. */\n\t      elem_loc = (elem_loc + 1) % dbf->header->bucket_elems;\n\t      if (elem_loc == home_loc)\n\t\tbreak;\n\t      bucket_hash_val = dbf->bucket->h_table[elem_loc].hash_value;\n\t    }\n\t}\n      GDBM_DEBUG (GDBM_DEBUG_LOOKUP, \"%s: next location = %#4x:%d:%d\",\n\t\t  dbf->name, bucket_hash_val, bucket_dir, elem_loc);\n    }\n\n  /* If we get here, we never found the key. */\n  GDBM_SET_ERRNO2 (dbf, GDBM_ITEM_NOT_FOUND, FALSE, GDBM_DEBUG_LOOKUP);\n  return -1;\n\n}",
      "lines": 92,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/fullio.c": {
    "_gdbm_full_read": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\n_gdbm_full_read (GDBM_FILE dbf, void *buffer, size_t size)\n{\n  char *ptr = buffer;\n  while (size)\n    {\n      ssize_t rdbytes = gdbm_file_read (dbf, ptr, size);\n      if (rdbytes == -1)\n\t{\n\t  if (errno == EINTR)\n\t    continue;\n\t  if (gdbm_last_errno (dbf) == GDBM_NO_ERROR)\n\t    GDBM_SET_ERRNO (dbf, GDBM_FILE_READ_ERROR, FALSE);\n\t  return -1;\n\t}\n      if (rdbytes == 0)\n\t{\n\t  GDBM_SET_ERRNO (dbf, GDBM_FILE_EOF, FALSE);\n\t  return -1;\n\t}\n      ptr += rdbytes;\n      size -= rdbytes;\n    }\n  return 0;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_full_write": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\n_gdbm_full_write (GDBM_FILE dbf, void *buffer, size_t size)\n{\n  char *ptr = buffer;\n  while (size)\n    {\n      ssize_t wrbytes = gdbm_file_write (dbf, ptr, size);\n      if (wrbytes == -1)\n\t{\n\t  if (errno == EINTR)\n\t    continue;\n\t  if (gdbm_last_errno (dbf) == GDBM_NO_ERROR)\n\t    GDBM_SET_ERRNO (dbf, GDBM_FILE_WRITE_ERROR, TRUE);\n\t  return -1;\n\t}\n      if (wrbytes == 0)\n\t{\n\t  errno = ENOSPC;\n\t  GDBM_SET_ERRNO (dbf, GDBM_FILE_WRITE_ERROR, TRUE);\n\t  return -1;\n\t}\n      ptr += wrbytes;\n      size -= wrbytes;\n    }\n  return 0;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_file_extend": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "int\n_gdbm_file_extend (GDBM_FILE dbf, off_t size)\n{\n  size_t page_size = sysconf (_SC_PAGESIZE);\n  char *buf;\n  off_t file_end;\n\n  file_end = lseek (dbf->desc, 0, SEEK_END);\n  if (!file_end)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_FILE_SEEK_ERROR, FALSE);\n      return -1;\n    }\n  size -= file_end;\n  if (size > 0)\n    {\n      if (size < page_size)\n\tpage_size = size;\n      buf = calloc (1, page_size);\n      if (!buf)\n\t{\n\t  GDBM_SET_ERRNO (dbf, GDBM_MALLOC_ERROR, FALSE);\n\t  return -1;\n\t}\n\n      while (size)\n\t{\n\t  ssize_t n = write (dbf->desc, buf,\n\t\t\t     size < page_size ? size : page_size);\n\t  if (n <= 0)\n\t    {\n\t      GDBM_SET_ERRNO (dbf, GDBM_FILE_WRITE_ERROR, TRUE);\n\t      break;\n\t    }\n\t  size -= n;\n\t}\n      free (buf);\n      if (size)\n\treturn -1;\n    }\n  return 0;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmapp.h": {},
  "gdbm/gdbm-1.15/src/gdbmclose.c": {
    "gdbm_close": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void\ngdbm_close (GDBM_FILE dbf)\n{\n  int index;\t/* For freeing the bucket cache. */\n\n  if (dbf->desc != -1)\n    {\n      /* Make sure the database is all on disk. */\n      if (dbf->read_write != GDBM_READER)\n\tgdbm_file_sync (dbf);\n\n      /* Close the file and free all malloced memory. */\n#if HAVE_MMAP\n      _gdbm_mapped_unmap (dbf);\n#endif\n      if (dbf->file_locking)\n\t_gdbm_unlock_file (dbf);\n\n      close (dbf->desc);\n    }\n\n  gdbm_clear_error (dbf);\n  \n  free (dbf->name);\n  free (dbf->dir);\n\n  if (dbf->bucket_cache != NULL)\n    {\n      for (index = 0; index < dbf->cache_size; index++)\n\t{\n\t  free (dbf->bucket_cache[index].ca_bucket);\n\t  free (dbf->bucket_cache[index].ca_data.dptr);\n\t}\n      free (dbf->bucket_cache);\n    }\n  free (dbf->header);\n  free (dbf);\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmconst.h": {},
  "gdbm/gdbm-1.15/src/gdbmcount.c": {
    "gdbm_count": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\ngdbm_count (GDBM_FILE dbf, gdbm_count_t *pcount)\n{\n  int nbuckets = GDBM_DIR_COUNT (dbf);\n  gdbm_count_t count = 0;\n  int i;\n  \n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, -1);\n  \n  for (i = 0; i < nbuckets; i = _gdbm_next_bucket_dir (dbf, i))\n    {\n      if (_gdbm_get_bucket (dbf, i))\n\treturn -1;\n      count += dbf->bucket->count;\n    }\n  *pcount = count;\n  return 0;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmdefs.h": {
    "off_t_sum_ok": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static inline off_t\noff_t_sum_ok (off_t a, off_t b)\n{\n  return OFF_T_MAX - a >= b;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "off_t"
      ]
    },
    "gdbm_avail_block_valid_p": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int inline\ngdbm_avail_block_valid_p (avail_block const *av)\n{\n  return (av->size > 1 && av->count >= 0 && av->count <= av->size);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int",
        "inline",
        "inline"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmdelete.c": {
    "gdbm_delete": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\ngdbm_delete (GDBM_FILE dbf, datum key)\n{\n  int elem_loc;\t\t/* The location in the current hash bucket. */\n  int last_loc;\t\t/* Last location emptied by the delete.  */\n  int home;\t\t/* Home position of an item. */\n  bucket_element elem;  /* The element to be deleted. */\n  off_t free_adr;       /* Temporary storage for address and size. */\n  int   free_size;\n\n  GDBM_ASSERT_CONSISTENCY (dbf, -1);\n\n  /* First check to make sure this guy is a writer. */\n  if (dbf->read_write == GDBM_READER)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_READER_CANT_DELETE, FALSE);\n      return -1;\n    }\n  \n  /* Initialize the gdbm_errno variable. */\n  gdbm_set_errno (dbf, GDBM_NO_ERROR, FALSE);\n\n  /* Find the item. */\n  elem_loc = _gdbm_findkey (dbf, key, NULL, NULL);\n  if (elem_loc == -1)\n    return -1;\n\n  /* Save the element.  */\n  elem = dbf->bucket->h_table[elem_loc];\n\n  /* Delete the element.  */\n  dbf->bucket->h_table[elem_loc].hash_value = -1;\n  dbf->bucket->count--;\n\n  /* Move other elements to guarantee that they can be found. */\n  last_loc = elem_loc;\n  elem_loc = (elem_loc + 1) % dbf->header->bucket_elems;\n  while (elem_loc != last_loc\n\t && dbf->bucket->h_table[elem_loc].hash_value != -1)\n    {\n      home = dbf->bucket->h_table[elem_loc].hash_value\n\t     % dbf->header->bucket_elems;\n      if ( (last_loc < elem_loc && (home <= last_loc || home > elem_loc))\n\t  || (last_loc > elem_loc && home <= last_loc && home > elem_loc))\n\t\n\t{\n\t  dbf->bucket->h_table[last_loc] = dbf->bucket->h_table[elem_loc];\n\t  dbf->bucket->h_table[elem_loc].hash_value = -1;\n\t  last_loc = elem_loc;\n\t}\n      elem_loc = (elem_loc + 1) % dbf->header->bucket_elems;\n    }\n\n  /* Free the file space. */\n  free_adr = elem.data_pointer;\n  free_size = elem.key_size + elem.data_size;\n  if (_gdbm_free (dbf, free_adr, free_size))\n    return -1;\n\n  /* Set the flags. */\n  dbf->bucket_changed = TRUE;\n\n  /* Invalidate data cache for the current bucket. */\n  dbf->cache_entry->ca_data.hash_val = -1;\n  dbf->cache_entry->ca_data.key_size = 0;\n  dbf->cache_entry->ca_data.elem_loc = -1;\n\n  /* Do the writes. */\n  return _gdbm_end_update (dbf);\n}",
      "lines": 70,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmdump.c": {
    "print_datum": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\nprint_datum (datum const *dat, unsigned char **bufptr,\n\t     size_t *bufsize, FILE *fp)\n{\n  int rc;\n  size_t len;\n  unsigned char *p;\n  \n  fprintf (fp, \"#:len=%lu\\n\", (unsigned long) dat->dsize);\n  rc = _gdbm_base64_encode ((unsigned char*) dat->dptr, dat->dsize,\n\t\t\t    bufptr, bufsize, &len);\n  if (rc)\n    return rc;\n  \n  p = *bufptr;\n  while (len)\n    {\n      size_t n = len;\n      if (n > _GDBM_MAX_DUMP_LINE_LEN)\n\tn = _GDBM_MAX_DUMP_LINE_LEN;\n      if (fwrite (p, n, 1, fp) != 1)\n\treturn GDBM_FILE_WRITE_ERROR;\n      fputc ('\\n', fp);\n      len -= n;\n      p += n;\n    }\n  return 0;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_gdbm_dump_ascii": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\n_gdbm_dump_ascii (GDBM_FILE dbf, FILE *fp)\n{\n  time_t t;\n  int fd;\n  struct stat st;\n  struct passwd *pw;\n  struct group *gr;\n  datum key;\n  size_t count = 0;\n  unsigned char *buffer = NULL;\n  size_t bufsize = 0;\n  int rc;\n\n  fd = gdbm_fdesc (dbf);\n  if (fstat (fd, &st))\n    return GDBM_FILE_STAT_ERROR;\n\n  /* Print header */\n  time (&t);\n  fprintf (fp, \"# GDBM dump file created by %s on %s\",\n\t   gdbm_version, ctime (&t));\n  fprintf (fp, \"#:version=1.0\\n\");\n\n  fprintf (fp, \"#:file=%s\\n\", dbf->name);\n  fprintf (fp, \"#:uid=%lu,\", (unsigned long) st.st_uid);\n  pw = getpwuid (st.st_uid);\n  if (pw)\n    fprintf (fp, \"user=%s,\", pw->pw_name);\n  fprintf (fp, \"gid=%lu,\", (unsigned long) st.st_gid);\n  gr = getgrgid (st.st_gid);\n  if (gr)\n    fprintf (fp, \"group=%s,\", gr->gr_name);\n  fprintf (fp, \"mode=%03o\\n\", st.st_mode & 0777);\n  fprintf (fp, \"# End of header\\n\");\n  \n  key = gdbm_firstkey (dbf);\n\n  while (key.dptr)\n    {\n      datum nextkey;\n      datum data = gdbm_fetch (dbf, key);\n      if (data.dptr)\n \t{\n\t  if ((rc = print_datum (&key, &buffer, &bufsize, fp)) ||\n\t      (rc = print_datum (&data, &buffer, &bufsize, fp)))\n\t    {\n\t      free (key.dptr);\n\t      free (data.dptr);\n\t      GDBM_SET_ERRNO (dbf, rc, FALSE);\n\t      break;\n\t    }\n \t}\n      else\n\tbreak;\n      nextkey = gdbm_nextkey (dbf, key);\n      free (key.dptr);\n      free (data.dptr);\n      key = nextkey;\n      count++;\n    }\n\n  if (rc == 0 && (rc = gdbm_last_errno (dbf)) == 0)\n    {\n      \n      /* FIXME: Something like that won't hurt, although load does not\n\t use it currently. */\n      fprintf (fp, \"#:count=%lu\\n\", (unsigned long) count);\n      fprintf (fp, \"# End of data\\n\");\n    }\n  free (buffer);\n\n  \n  return rc ? -1 : 0;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "gdbm_dump_to_file": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\ngdbm_dump_to_file (GDBM_FILE dbf, FILE *fp, int format)\n{\n  int rc;\n  \n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, -1);\n  \n  switch (format)\n    {\n    case GDBM_DUMP_FMT_BINARY:\n      rc = gdbm_export_to_file (dbf, fp) == -1;\n      break;\n\n    case GDBM_DUMP_FMT_ASCII:\n      rc = _gdbm_dump_ascii (dbf, fp);\n      break;\n\n    default:\n      GDBM_SET_ERRNO (NULL, GDBM_BAD_OPEN_FLAGS, FALSE);\n      return EINVAL;\n    }\n  \n  if (rc == 0 && ferror (fp))\n    {\n      GDBM_SET_ERRNO (NULL, GDBM_FILE_WRITE_ERROR, FALSE);\n      rc = -1;\n    }\n\n  return rc;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "gdbm_dump": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "int\ngdbm_dump (GDBM_FILE dbf, const char *filename, int fmt, int open_flags,\n\t   int mode)\n{\n  int nfd, rc;\n  FILE *fp;\n  \n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, -1);\n  \n  /* Only support GDBM_WCREAT or GDBM_NEWDB */\n  switch (open_flags)\n    {\n    case GDBM_WRCREAT:\n      nfd = open (filename, O_WRONLY | O_CREAT | O_EXCL, mode);\n      if (nfd == -1)\n\t{\n\t  GDBM_SET_ERRNO (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n\t  return -1;\n\t}\n      break;\n    case GDBM_NEWDB:\n      nfd = open (filename, O_WRONLY | O_CREAT | O_TRUNC, mode);\n      if (nfd == -1)\n\t{\n\t  GDBM_SET_ERRNO (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n\t  return -1;\n\t}\n      break;\n    default:\n      GDBM_SET_ERRNO (NULL, GDBM_BAD_OPEN_FLAGS, FALSE);\n      return -1;\n  }\n\n  fp = fdopen (nfd, \"w\");\n  if (!fp)\n    {\n      close (nfd);\n      GDBM_SET_ERRNO (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n      return -1;\n    }\n  rc = gdbm_dump_to_file (dbf, fp, fmt);\n  fclose (fp);\n  return rc;\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmerrno.c": {
    "gdbm_errno_location": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int *\ngdbm_errno_location (void)\n{\n  return &gdbm_errno_storage;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int",
        "*\ngdbm_errno_location (void)",
        "*"
      ]
    },
    "gdbm_set_errno": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\ngdbm_set_errno (GDBM_FILE dbf, gdbm_error ec, int fatal)\n{\n  if (dbf)\n    {\n      free (dbf->last_errstr);\n      dbf->last_errstr = NULL;\n      \n      dbf->last_error = ec;\n      if (gdbm_syserr[ec])\n\tdbf->last_syserror = errno;\n      else\n\tdbf->last_syserror = 0;\n      dbf->need_recovery = fatal;\n    }\n  gdbm_errno = ec;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gdbm_last_errno": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "gdbm_error\ngdbm_last_errno (GDBM_FILE dbf)\n{\n  if (!dbf)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  return dbf->last_error;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "gdbm_error"
      ]
    },
    "gdbm_last_syserr": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\ngdbm_last_syserr (GDBM_FILE dbf)\n{\n  if (!dbf)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  return dbf->last_syserror;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gdbm_needs_recovery": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\ngdbm_needs_recovery (GDBM_FILE dbf)\n{\n  if (!dbf)\n    return 0;\n  return dbf->need_recovery;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "gdbm_clear_error": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\ngdbm_clear_error (GDBM_FILE dbf)\n{\n  if (dbf)\n    {\n      dbf->last_error = GDBM_NO_ERROR;\n      dbf->last_syserror = 0;\n      free (dbf->last_errstr);\n      dbf->last_errstr = NULL;\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gdbm_strerror": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "const char *\ngdbm_strerror (gdbm_error error)\n{\n  if (error < _GDBM_MIN_ERRNO || error > _GDBM_MAX_ERRNO)\n    error = GDBM_UNKNOWN_ERROR;\n  return gettext (gdbm_errlist[error]);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngdbm_strerror (gdbm_error error)",
        "*"
      ]
    },
    "gdbm_db_strerror": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "char const *\ngdbm_db_strerror (GDBM_FILE dbf)\n{\n  if (!dbf->last_errstr)\n    {\n      char const *errstr = gdbm_strerror (dbf->last_error);\n\n      if (dbf->last_syserror)\n\t{\n\t  char const *syserrstr = strerror (dbf->last_syserror);\n\t  size_t len = strlen (errstr) + strlen (syserrstr) + 2;\n\t  dbf->last_errstr = malloc (len + 1);\n\t  if (!dbf->last_errstr)\n\t    return errstr;\n\n\t  strcpy (dbf->last_errstr, errstr);\n\t  strcat (dbf->last_errstr, \": \");\n\t  strcat (dbf->last_errstr, syserrstr);\n\t}\n      else\n\treturn errstr;\n    }\n  return dbf->last_errstr;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ngdbm_db_strerror (GDBM_FILE dbf)",
        "*"
      ]
    },
    "gdbm_check_syserr": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "int\ngdbm_check_syserr (gdbm_error n)\n{\n  if (n >= _GDBM_MIN_ERRNO && n <= _GDBM_MAX_ERRNO)\n    return gdbm_syserr[n];\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmexists.c": {
    "gdbm_exists": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\ngdbm_exists (GDBM_FILE dbf, datum key)\n{\n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, 0);\n  \n  if (_gdbm_findkey (dbf, key, NULL, NULL) < 0)\n    {\n      if (gdbm_errno == GDBM_ITEM_NOT_FOUND)\n\tgdbm_set_errno (dbf, GDBM_NO_ERROR, FALSE);\n      return 0;\n    }\n  return 1;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmexp.c": {
    "gdbm_export_to_file": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\ngdbm_export_to_file (GDBM_FILE dbf, FILE *fp)\n{\n  unsigned long size;\n  datum key, nextkey, data;\n  const char *header1 = \"!\\r\\n! GDBM FLAT FILE DUMP -- THIS IS NOT A TEXT FILE\\r\\n! \";\n  const char *header2 = \"\\r\\n!\\r\\n\";\n  int count = 0;\n\n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, -1);\n  \n  /* Write out the text header. */\n  if (fwrite (header1, strlen (header1), 1, fp) != 1)\n    goto write_fail;\n  if (fwrite (gdbm_version, strlen (gdbm_version), 1, fp) != 1)\n    goto write_fail;\n  if (fwrite (header2, strlen (header2), 1, fp) != 1)\n    goto write_fail;\n\n  /* For each item in the database, write out a record to the file. */\n  key = gdbm_firstkey (dbf);\n\n  while (key.dptr != NULL)\n    {\n      data = gdbm_fetch (dbf, key);\n      if (data.dptr == NULL)\n\t{\n\t  if (gdbm_errno != GDBM_NO_ERROR)\n\t    return -1;\n\t}\n      else\n \t{\n\t  /* Add the data to the new file. */\n\t  size = htonl (key.dsize);\n\t  if (fwrite (&size, sizeof (size), 1, fp) != 1)\n\t    goto write_fail;\n\t  if (fwrite (key.dptr, key.dsize, 1, fp) != 1)\n\t    goto write_fail;\n\n\t  size = htonl (data.dsize);\n\t  if (fwrite (&size, sizeof (size), 1, fp) != 1)\n\t    goto write_fail;\n\t  if (fwrite (data.dptr, data.dsize, 1, fp) != 1)\n\t    goto write_fail;\n \t}\n      \n      nextkey = gdbm_nextkey (dbf, key);\n      free (key.dptr);\n      free (data.dptr);\n      key = nextkey;\n      \n      count++;\n    }\n  if (gdbm_errno != GDBM_ITEM_NOT_FOUND)\n    return -1;\n  \n  return count;\n  \n write_fail:\n  \n  GDBM_SET_ERRNO (NULL, GDBM_FILE_WRITE_ERROR, FALSE);\n  return -1;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "gdbm_export": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "int\ngdbm_export (GDBM_FILE dbf, const char *exportfile, int flags, int mode)\n{\n  int nfd, rc;\n  FILE *fp;\n  \n  /* Only support GDBM_WCREAT or GDBM_NEWDB */\n  switch (flags)\n    {\n    case GDBM_WRCREAT:\n      nfd = open (exportfile, O_WRONLY | O_CREAT | O_EXCL, mode);\n      if (nfd == -1)\n\t{\n\t  GDBM_SET_ERRNO (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n\t  return -1;\n\t}\n      break;\n    case GDBM_NEWDB:\n      nfd = open (exportfile, O_WRONLY | O_CREAT | O_TRUNC, mode);\n      if (nfd == -1)\n\t{\n\t  GDBM_SET_ERRNO (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n\t  return -1;\n\t}\n      break;\n    default:\n#ifdef GDBM_BAD_OPEN_FLAGS\n      GDBM_SET_ERRNO (NULL, GDBM_BAD_OPEN_FLAGS, FALSE);\n#else\n      GDBM_SET_ERRNO (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n#endif\n      return -1;\n  }\n\n  fp = fdopen (nfd, \"w\");\n  if (!fp)\n    {\n      close (nfd);\n      GDBM_SET_ERRNO (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n      return -1;\n    }\n\t\n  rc = gdbm_export_to_file (dbf, fp);\n  fclose (fp);\n  return rc;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmfdesc.c": {
    "gdbm_fdesc": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\ngdbm_fdesc(GDBM_FILE dbf)\n{\n  return (dbf->desc);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmfetch.c": {
    "gdbm_fetch": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "datum\ngdbm_fetch (GDBM_FILE dbf, datum key)\n{\n  datum  return_val;\t\t/* The return value. */\n  int    elem_loc;\t\t/* The location in the bucket. */\n  char  *find_data;\t\t/* Returned from find_key. */\n\n  GDBM_DEBUG_DATUM (GDBM_DEBUG_READ, key, \"%s: fetching key:\", dbf->name);\n\n  /* Set the default return value. */\n  return_val.dptr  = NULL;\n  return_val.dsize = 0;\n\n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, return_val);\n  \n  /* Initialize the gdbm_errno variable. */\n  gdbm_set_errno (dbf, GDBM_NO_ERROR, FALSE);\n\n  /* Find the key and return a pointer to the data. */\n  elem_loc = _gdbm_findkey (dbf, key, &find_data, NULL);\n\n  /* Copy the data if the key was found.  */\n  if (elem_loc >= 0)\n    {\n      /* This is the item.  Return the associated data. */\n      return_val.dsize = dbf->bucket->h_table[elem_loc].data_size;\n      if (return_val.dsize == 0)\n\treturn_val.dptr = (char *) malloc (1);\n      else\n\treturn_val.dptr = (char *) malloc (return_val.dsize);\n      if (return_val.dptr == NULL)\n\t{\n\t  GDBM_SET_ERRNO2 (dbf, GDBM_MALLOC_ERROR, FALSE, GDBM_DEBUG_READ);\n\t  return return_val;\n\t}\n      memcpy (return_val.dptr, find_data, return_val.dsize);\n      \n      GDBM_DEBUG_DATUM (GDBM_DEBUG_READ, return_val,\n\t\t\t\"%s: found\", dbf->name);\n    }\n  else\n    GDBM_DEBUG (GDBM_DEBUG_READ, \"%s: key not found\", dbf->name);\n  \n  return return_val;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "datum"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmimp.c": {
    "gdbm_import_from_file": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "int\ngdbm_import_from_file (GDBM_FILE dbf, FILE *fp, int flag)\n{\n  int seenbang, seennewline, rret;\n  unsigned long rsize, size;\n  int ec;\n  char *kbuffer, *dbuffer;\n  size_t kbufsize, dbufsize;\n  datum key, data;\n  int count = 0;\n\n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, -1);\n  \n  seenbang = 0;\n  seennewline = 0;\n  kbuffer = NULL;\n  dbuffer = NULL;\n\n  /* Read (and discard) four lines begining with ! and ending with \\n. */\n  while (1)\n    {\n      if ((rret = fgetc (fp)) == -1)\n\t{\n\t  GDBM_SET_ERRNO (NULL, GDBM_FILE_READ_ERROR, FALSE);\n\t  return -1;\n\t}\n      \n      if (rret == '!')\n\tseenbang++;\n      if (rret == '\\n')\n\t{\n\t  if (seenbang > 3 && seennewline > 2)\n\t    {\n\t      /* End of last line. */\n\t      break;\n\t    }\n\t  seennewline++;\n\t}\n    }\n\n  /* Allocate buffers. */\n  kbufsize = GDBM_MIN_BLOCK_SIZE;\n  kbuffer = malloc (kbufsize);\n  if (kbuffer == NULL)\n    {\n      GDBM_SET_ERRNO (NULL, GDBM_MALLOC_ERROR, FALSE);\n      return -1;\n    }\n  dbufsize = GDBM_MIN_BLOCK_SIZE;\n  dbuffer = malloc (dbufsize);\n  if (dbuffer == NULL)\n    {\n      free (kbuffer);\n      GDBM_SET_ERRNO (NULL, GDBM_MALLOC_ERROR, FALSE);\n      return -1;\n    }\n\n  ec = GDBM_NO_ERROR;\n  /* Insert/replace records in the database until we run out of file. */\n  while ((rret = fread (&rsize, sizeof (rsize), 1, fp)) == 1)\n    {\n      /* Read the key. */\n      size = ntohl (rsize);\n      if (size > INT_MAX)\n\t{\n\t  ec = GDBM_ILLEGAL_DATA;\n\t  break;\n\t}\n      \n      if (size > kbufsize)\n\t{\n\t  kbufsize = (size + GDBM_MIN_BLOCK_SIZE);\n\t  kbuffer = realloc (kbuffer, kbufsize);\n\t  if (kbuffer == NULL)\n\t    {\n\t      ec = GDBM_MALLOC_ERROR;\n\t      break;\n\t    }\n\t}\n      if (fread (kbuffer, size, 1, fp) != 1)\n\t{\n\t  ec = GDBM_FILE_READ_ERROR;\n\t  break;\n\t}\n\n      key.dptr = kbuffer;\n      key.dsize = (int) size;\n\n      /* Read the data. */\n      if (fread (&rsize, sizeof (rsize), 1, fp) != 1)\n\t{\n\t  ec = GDBM_FILE_READ_ERROR;\n\t  break;\n\t}\n\n      size = ntohl (rsize);\n      if (size > INT_MAX)\n\t{\n\t  ec = GDBM_ILLEGAL_DATA;\n\t  break;\n\t}\n      if (size > dbufsize)\n\t{\n\t  dbufsize = (size + GDBM_MIN_BLOCK_SIZE);\n\t  dbuffer = realloc (dbuffer, dbufsize);\n\t  if (dbuffer == NULL)\n\t    {\n\t      ec = GDBM_MALLOC_ERROR;\n\t      break;\n\t    }\n\t}\n      if (fread (dbuffer, size, 1, fp) != 1)\n\t{\n\t  ec = GDBM_FILE_READ_ERROR;\n\t  break;\n\t}\n\n      data.dptr = dbuffer;\n      data.dsize = (int) size;\n\n      if (gdbm_store (dbf, key, data, flag) != 0)\n\t{\n\t  /* Keep the existing errno. */\n\t  ec = gdbm_errno;\n\t  break;\n\t}\n\n      count++;\n    }\n\n  if (rret < 0)\n    ec = GDBM_FILE_READ_ERROR;\n  \n  free (kbuffer);\n  free (dbuffer);\n\n  if (ec == GDBM_NO_ERROR)\n    return count;\n\n  GDBM_SET_ERRNO (NULL, ec, FALSE);\n  return -1;\n}",
      "lines": 143,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "gdbm_import": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "int\ngdbm_import (GDBM_FILE dbf, const char *importfile, int flag)\n{\n  FILE *fp;\n  int rc;\n  \n  fp = fopen (importfile, \"r\");\n  if (!fp)\n    {\n      GDBM_SET_ERRNO (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n      return -1;\n    }\n  rc = gdbm_import_from_file (dbf, fp, flag);\n  fclose (fp);\n  return rc;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmload.c": {
    "dump_file_free": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static void\ndump_file_free (struct dump_file *file)\n{\n  free (file->linebuf);\n  free (file->buffer);\n  free (file->data[0].buffer);\n  free (file->data[1].buffer);\n  free (file->header);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getparm": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static const char *\ngetparm (const char *buf, const char *parm)\n{\n  if (!buf)\n    return NULL;\n  while (*buf)\n    {\n      const char *p;\n      for (p = parm; *p == *buf; p++, buf++)\n\t;\n      if (*p == 0 && *buf == '=')\n\treturn buf + 1;\n      buf += strlen (buf) + 1;\n    }\n  return NULL;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ngetparm (const char *buf, const char *parm)",
        "*"
      ]
    },
    "get_dump_line": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static size_t\nget_dump_line (struct dump_file *file)\n{\n  char buf[80];\n  \n  if (file->lblevel == 0)\n    {\n      while (fgets (buf, sizeof buf, file->fp))\n\t{\n\t  size_t n = strlen (buf);\n\t  \n\t  if (buf[n-1] == '\\n')\n\t    {\n\t      file->line++;\n\t      --n;\n\t    }\n\t  \n\t  if (n + 1 + file->lblevel > file->lbsize)\n\t    {\n\t      size_t s = ((file->lblevel + n + _GDBM_MAX_DUMP_LINE_LEN)\n\t\t\t  / _GDBM_MAX_DUMP_LINE_LEN)\n\t\t          * _GDBM_MAX_DUMP_LINE_LEN;\n\t      char *newp = realloc (file->linebuf, s);\n\t      if (!newp)\n\t\treturn GDBM_MALLOC_ERROR;\n\t      file->linebuf = newp;\n\t      file->lbsize = s;\n\t    }\n\t  \n\t  memcpy (file->linebuf + file->lblevel, buf, n);\n\t  file->lblevel += n;\n\t  if (buf[n])\n\t    {\n\t      file->linebuf[file->lblevel] = 0;\n\t      break;\n\t    }\n\t}\n    }\n  return file->lblevel;\n}",
      "lines": 40,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "get_data": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static int\nget_data (struct dump_file *file)\n{\n  size_t n;\n\n  file->buflevel = 0;\n  file->parmc = 0;\n  \n  while ((n = get_dump_line (file)))\n    {\n      if (file->linebuf[0] == '#')\n\treturn 0;\n      if (n + file->buflevel > file->bufsize)\n\t{\n\t  size_t s = ((file->buflevel + n + _GDBM_MAX_DUMP_LINE_LEN - 1)\n\t\t      / _GDBM_MAX_DUMP_LINE_LEN)\n\t              * _GDBM_MAX_DUMP_LINE_LEN;\n\t  char *newp = realloc (file->buffer, s);\n\t  if (!newp)\n\t    return GDBM_MALLOC_ERROR;\n\t  file->buffer = newp;\n\t  file->bufsize = s;\n\t}\n      memcpy (file->buffer + file->buflevel, file->linebuf, n);\n      file->buflevel += n;\n      file->lblevel = 0;\n    }\n  return ferror (file->fp) ? GDBM_FILE_READ_ERROR : 0;\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_parms": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "static int\nget_parms (struct dump_file *file)\n{\n  size_t n;\n\n  file->buflevel = 0;\n  file->parmc = 0;\n  while ((n = get_dump_line (file)))\n    {\n      char *p;\n\n      p = file->linebuf;\n      if (*p != '#')\n\treturn 0;\n      if (n == 0 || *++p != ':')\n\t{\n\t  file->lblevel = 0;\n\t  continue;\n\t}\n      if (--n == 0)\n\t{\n\t  file->lblevel = 0;\n\t  continue;\n\t}\n      \n      if (n + 1 + file->buflevel > file->bufsize)\n\t{\n\t  size_t s = ((file->buflevel + n + _GDBM_MAX_DUMP_LINE_LEN)\n\t\t      / _GDBM_MAX_DUMP_LINE_LEN)\n\t              * _GDBM_MAX_DUMP_LINE_LEN;\n\t  char *newp = realloc (file->buffer, s);\n\t  if (!newp)\n\t    return GDBM_MALLOC_ERROR;\n\t  file->buffer = newp;\n\t  file->bufsize = s;\n\t}\n\n      while (*p)\n\t{\n\t  p++;\n\t  while (*p == ' ' || *p == '\\t')\n\t    p++;\n\t  if (*p)\n\t    {\n\t      while (*p && *p != '=')\n\t\tfile->buffer[file->buflevel++] = *p++;\n\t      \n\t      if (*p == '=')\n\t\t{\n\t\t  file->buffer[file->buflevel++] = *p++;\n\t\t  if (*p == '\"')\n\t\t    {\n\t\t      p++;\n\t\t      while (*p && *p != '\"')\n\t\t\tfile->buffer[file->buflevel++] = *p++;\n\n\t\t      if (*p == '\"')\n\t\t\tp++;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      while (!(*p == 0 || *p == ','))\n\t\t\tfile->buffer[file->buflevel++] = *p++;\n\t\t    }\n\t\t  file->parmc++;\n\t\t  file->buffer[file->buflevel++] = 0;\n\t\t}\n\t      else\n\t\treturn GDBM_ILLEGAL_DATA;\n\t    }\n\t  else\n\t    break;\n\t}\n      file->lblevel = 0;\n    }\n\n  if (file->buffer)\n    file->buffer[file->buflevel] = 0;\n  \n  return ferror (file->fp) ? GDBM_FILE_READ_ERROR : 0;\n}",
      "lines": 81,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_len": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "int\nget_len (const char *param, size_t *plen)\n{\n  unsigned long n;\n  const char *p = getparm (param, \"len\");\n  char *end;\n  \n  if (!p)\n    return GDBM_ITEM_NOT_FOUND;\n\n  errno = 0;\n  n = strtoul (p, &end, 10);\n  if (*end == 0 && errno == 0)\n    {\n      *plen = n;\n      return 0;\n    }\n\n  return GDBM_ILLEGAL_DATA;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "read_record": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "int\nread_record (struct dump_file *file, char *param, int n, datum *dat)\n{\n  int rc;\n  size_t len, consumed_size, decoded_size;\n\n  if (!param)\n    {\n      rc = get_parms (file);\n      if (rc)\n\treturn rc;\n      if (file->parmc == 0)\n\treturn GDBM_ITEM_NOT_FOUND;\n      param = file->buffer;\n    }\n  rc = get_len (param, &len);\n  if (rc)\n    return rc;\n  dat->dsize = len; /* FIXME: data type mismatch */\n  rc = get_data (file);\n  if (rc)\n    return rc;\n\n  rc = _gdbm_base64_decode ((unsigned char *)file->buffer, file->buflevel,\n\t\t\t    &file->data[n].buffer, &file->data[n].size,\n\t\t\t    &consumed_size, &decoded_size);\n  if (rc)\n    return rc;\n  if (consumed_size != file->buflevel || decoded_size != len)\n    return GDBM_ILLEGAL_DATA;\n  dat->dptr = (void*) file->data[n].buffer;\n  return 0;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_set_gdbm_meta_info": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "static int\n_set_gdbm_meta_info (GDBM_FILE dbf, char *param, int meta_mask)\n{\n  unsigned long n;\n  uid_t owner_uid;\n  uid_t owner_gid;\n  mode_t mode;\n  int meta_flags = 0;\n  const char *p;\n  char *end;\n\n  if (!(meta_mask & GDBM_META_MASK_OWNER))\n    {\n      p = getparm (param, \"user\");\n      if (p)\n\t{\n\t  struct passwd *pw = getpwnam (p);\n\t  if (pw)\n\t    {\n\t      owner_uid = pw->pw_uid;\n\t      meta_flags |= META_UID;\n\t    }\n\t}\n\n      if (!(meta_flags & META_UID) && (p = getparm (param, \"uid\")))\n\t{\n\t  errno = 0;\n\t  n = strtoul (p, &end, 10);\n\t  if (*end == 0 && errno == 0)\n\t    {\n\t      owner_uid = n;\n\t      meta_flags |= META_UID;\n\t    }\n\t}\n\n      p = getparm (param, \"group\");\n      if (p)\n\t{\n\t  struct group *gr = getgrnam (p);\n\t  if (gr)\n\t    {\n\t      owner_gid = gr->gr_gid;\n\t      meta_flags |= META_GID;\n\t    }\n\t}\n      if (!(meta_flags & META_GID) && (p = getparm (param, \"gid\")))\n\t{\n\t  errno = 0;\n\t  n = strtoul (p, &end, 10);\n\t  if (*end == 0 && errno == 0)\n\t    {\n\t      owner_gid = n;\n\t      meta_flags |= META_GID;\n\t    }\n\t}\n    }\n  \n  if (!(meta_mask & GDBM_META_MASK_MODE))\n    {\n      p = getparm (param, \"mode\");\n      if (p)\n\t{\n\t  errno = 0;\n\t  n = strtoul (p, &end, 8);\n\t  if (*end == 0 && errno == 0)\n\t    {\n\t      mode = n & 0777;\n\t      meta_flags |= META_MODE;\n\t    }\n\t}\n    }\n  \n  if (meta_flags)\n    {\n      int fd = gdbm_fdesc (dbf);\n      if (getuid () == 0 && (meta_flags & (META_UID|META_GID)))\n\t{\n\t  if ((meta_flags & (META_UID|META_GID)) != (META_UID|META_GID))\n\t    {\n\t      struct stat st;\n\t      if (fstat (fd, &st))\n\t\t{\n\t\t  GDBM_SET_ERRNO (dbf, GDBM_FILE_STAT_ERROR, FALSE);\n\t\t  return 1;\n\t\t}\n\t      if (!(meta_flags & META_UID))\n\t\towner_uid = st.st_uid;\n\t      if (!(meta_flags & META_GID))\n\t\towner_gid = st.st_gid;\n\t    }\n\t  if (fchown (fd, owner_uid, owner_gid))\n\t    {\n\t      GDBM_SET_ERRNO (dbf, GDBM_ERR_FILE_OWNER, FALSE);\n\t      return 1;\n\t    }\n\t}\n      if ((meta_flags & META_MODE) && fchmod (fd, mode))\n\t{\n\t  GDBM_SET_ERRNO (dbf, GDBM_ERR_FILE_OWNER, FALSE);\n\t  return 1;\n\t}\n    }\n  return 0;\n}",
      "lines": 104,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_gdbm_load_file": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "int\n_gdbm_load_file (struct dump_file *file, GDBM_FILE dbf, GDBM_FILE *ofp,\n\t\t int replace, int meta_mask)\n{\n  char *param = NULL;\n  int rc;\n  GDBM_FILE tmp = NULL;\n  \n  rc = get_parms (file);\n  if (rc)\n    return rc;\n  \n  if (file->parmc)\n    {\n      file->header = file->buffer;\n      file->buffer = NULL;\n      file->bufsize = file->buflevel = 0;\n    }\n  else\n    return GDBM_ILLEGAL_DATA;\n\n  if (!dbf)\n    {\n      const char *filename = getparm (file->header, \"file\");\n      if (!filename)\n\treturn GDBM_NO_DBNAME;\n      tmp = gdbm_open (filename, 0,\n\t\t       replace ? GDBM_WRCREAT : GDBM_NEWDB, 0600, NULL);\n      if (!tmp)\n\treturn gdbm_errno;\n      dbf = tmp;\n    }\n  \n  param = file->header;\n  while (1)\n    {\n      datum key, content;\n      rc = read_record (file, param, 0, &key);\n      if (rc)\n\t{\n\t  if (rc == GDBM_ITEM_NOT_FOUND && feof (file->fp))\n\t    rc = 0;\n\t  break;\n\t}\n      param = NULL;\n\n      rc = read_record (file, NULL, 1, &content);\n      if (rc)\n\tbreak;\n      \n      if (gdbm_store (dbf, key, content, replace))\n\t{\n\t  rc = gdbm_errno;\n\t  break;\n\t}\n    }\n\n  if (rc == 0)\n    {\n      rc = _set_gdbm_meta_info (dbf, file->header, meta_mask);\n      *ofp = dbf;\n    }\n  else if (tmp)\n    gdbm_close (tmp);\n    \n  return rc;\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "read_bdb_header": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        477,
        1
      ],
      "content": "static int\nread_bdb_header (struct dump_file *file)\n{    \n  char buf[256];\n  \n  file->line = 1;\n  if (!fgets (buf, sizeof (buf), file->fp))\n    return -1;\n  if (strcmp (buf, \"VERSION=3\\n\"))\n    return -1;\n  while (fgets (buf, sizeof (buf), file->fp))\n    {\n      ++file->line;\n      if (strcmp (buf, \"HEADER=END\\n\") == 0)\n\treturn 0;\n    }\n  return -1;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "c2x": {
      "start_point": [
        479,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "static int\nc2x (int c)\n{\n  static char xdig[] = \"0123456789abcdef\";\n  char *p = strchr (xdig, c);\n  if (!p)\n    return -1;\n  return p - xdig;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "xdatum_read": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        529,
        1
      ],
      "content": "static int\nxdatum_read (FILE *fp, datum *d, size_t *pdmax)\n{\n  int c;\n  size_t dmax = *pdmax;\n  \n  d->dsize = 0;\n  while ((c = fgetc (fp)) != EOF && c != '\\n')\n    {\n      int t, n;\n      \n      t = c2x (c);\n      if (t == -1)\n\treturn EOF;\n      t <<= 4;\n\n      if ((c = fgetc (fp)) == EOF)\n\tbreak;\n    \n      n = c2x (c);\n      if (n == -1)\n\treturn EOF;\n      t += n;\n\n      if (d->dsize == dmax)\n\t{\n\t  char *np = realloc (d->dptr, dmax + DINCR);\n\t  if (!np)\n\t    return GDBM_MALLOC_ERROR;\n\t  d->dptr = np;\n\t  dmax += DINCR;\n\t}\n      d->dptr[d->dsize++] = t;\n    }\n  *pdmax = dmax;\n  if (c == '\\n')\n    return 0;\n  return c;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gdbm_load_bdb_dump": {
      "start_point": [
        531,
        0
      ],
      "end_point": [
        565,
        1
      ],
      "content": "int\ngdbm_load_bdb_dump (struct dump_file *file, GDBM_FILE dbf, int replace)\n{\n  datum xd[2];\n  size_t xs[2];\n  int rc, c;\n  int i;\n  \n  if (read_bdb_header (file))\n    return -1;\n  memset (&xd, 0, sizeof (xd));\n  xs[0] = xs[1] = 0;\n  i = 0;\n  while ((c = fgetc (file->fp)) == ' ')\n    {\n      rc = xdatum_read (file->fp, &xd[i], &xs[i]);\n      if (rc)\n\tbreak;\n      ++file->line;\n\n      if (i == 1)\n\t{\n\t  if (gdbm_store (dbf, xd[0], xd[1], replace))\n\t    return gdbm_errno;\n\t}\n      i = !i;\n    }\n  //FIXME: Read \"DATA=END\"\n  free (xd[0].dptr);\n  free (xd[1].dptr);\n  if (rc == 0 && i)\n    rc = EOF;\n    \n  return rc;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "gdbm_load_from_file": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        618,
        1
      ],
      "content": "int\ngdbm_load_from_file (GDBM_FILE *pdbf, FILE *fp, int replace,\n\t\t     int meta_mask,\n\t\t     unsigned long *line)\n{\n  struct dump_file df;\n  int rc;\n\n  if (!pdbf || !fp)\n    return EINVAL;\n\n  /* Guess input file format */\n  rc = fgetc (fp);\n  ungetc (rc, fp);\n  if (rc == '!')\n    {\n      if (line)\n\t*line = 0;\n      if (!*pdbf)\n\t{\n\t  GDBM_SET_ERRNO (NULL, GDBM_NO_DBNAME, FALSE);\n\t  return -1;\n\t}\n      if (gdbm_import_from_file (*pdbf, fp, replace) == -1)\n\treturn -1;\n      return 0;\n    }\n\n  memset (&df, 0, sizeof df);\n  df.fp = fp;\n\n  if (rc == 'V')\n    {\n      if (!*pdbf)\n\t{\n\t  GDBM_SET_ERRNO (NULL, GDBM_NO_DBNAME, FALSE);\n\t  return -1;\n\t}\n      rc = gdbm_load_bdb_dump (&df, *pdbf, replace);\n    }\n  else\n    rc = _gdbm_load_file (&df, *pdbf, pdbf, replace, meta_mask);\n  dump_file_free (&df);\n  if (rc)\n    {\n      if (line)\n\t*line = df.line;\n      GDBM_SET_ERRNO (NULL, rc, FALSE);\n      return -1;\n    }\n  return 0;\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "gdbm_load": {
      "start_point": [
        620,
        0
      ],
      "end_point": [
        637,
        1
      ],
      "content": "int\ngdbm_load (GDBM_FILE *pdbf, const char *filename, int replace,\n\t   int meta_mask,\n\t   unsigned long *line)\n{\n  FILE *fp;\n  int rc;\n  \n  fp = fopen (filename, \"r\");\n  if (!fp)\n    {\n      GDBM_SET_ERRNO (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n      return -1;\n    }\n  rc = gdbm_load_from_file (pdbf, fp, replace, meta_mask, line);\n  fclose (fp);\n  return rc;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmopen.c": {
    "compute_directory_size": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static void\ncompute_directory_size (blksize_t block_size,\n\t\t\tint *ret_dir_size, int *ret_dir_bits)\n{\n  /* Create the initial hash table directory.  */\n  int dir_size = 8 * sizeof (off_t);\n  int dir_bits = 3;\n\n  while (dir_size < block_size && dir_bits < GDBM_HASH_BITS - 3)\n    {\n      dir_size <<= 1;\n      dir_bits++;\n    }\n\n  *ret_dir_size = dir_size;\n  *ret_dir_bits = dir_bits;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bucket_element_count": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static inline int\nbucket_element_count (size_t bucket_size)\n{\n  return (bucket_size - sizeof (hash_bucket)) / sizeof (bucket_element) + 1;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "gdbm_avail_table_valid_p": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\ngdbm_avail_table_valid_p (GDBM_FILE dbf, avail_elem const *av, int count)\n{\n  off_t prev = 0;\n  int i;\n    \n  prev = 0;\n  for (i = 0; i < count; i++, av++)\n    {\n      if (!(av->av_size >= prev\n\t    && av->av_adr >= dbf->header->bucket_size\n\t    && av->av_adr + av->av_size <= dbf->header->next_block))\n\treturn 0;\n      prev = av->av_size;\n    }\n  return 1;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "gdbm_avail_block_validate": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\ngdbm_avail_block_validate (GDBM_FILE dbf, avail_block *avblk)\n{\n  if (!(gdbm_avail_block_valid_p (avblk)\n\t&& gdbm_avail_table_valid_p (dbf, avblk->av_table, avblk->count)))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_BAD_AVAIL, TRUE);\n      return -1;\n    }\n  return 0;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "gdbm_bucket_avail_table_validate": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\ngdbm_bucket_avail_table_validate (GDBM_FILE dbf, hash_bucket *bucket)\n{\n  if (!(bucket->av_count >= 0\n\t&& bucket->av_count <= BUCKET_AVAIL\n\t&& gdbm_avail_table_valid_p (dbf, bucket->bucket_avail,\n\t\t\t\t     bucket->av_count)))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_BAD_AVAIL, TRUE);\n      return -1;\n    }\n  return 0;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "validate_header": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static int\nvalidate_header (gdbm_file_header const *hdr, struct stat const *st)\n{\n  int dir_size, dir_bits;\n  \n  /* Is the magic number good? */\n  if (hdr->header_magic != GDBM_MAGIC)\n    {\n      switch (hdr->header_magic)\n\t{\n\tcase GDBM_OMAGIC:\n\t  /* OK */\n\t  break;\n\n\tcase GDBM_OMAGIC_SWAP:\n\tcase GDBM_MAGIC32_SWAP:\n\tcase GDBM_MAGIC64_SWAP:\n\t  return GDBM_BYTE_SWAPPED;\n\n\tcase GDBM_MAGIC32:\n\tcase GDBM_MAGIC64:\n\t  return GDBM_BAD_FILE_OFFSET;\n\n\tdefault:\n\t  return GDBM_BAD_MAGIC_NUMBER;\n\t}\n    }\n  \n  if (!(hdr->block_size > 0\n\t&& hdr->block_size > sizeof (gdbm_file_header)\n\t&& hdr->block_size - sizeof (gdbm_file_header) >=\n\tsizeof(hdr->avail.av_table[0])))\n    {\n      return GDBM_BLOCK_SIZE_ERROR;\n    }\n\n  if (hdr->next_block != st->st_size)\n    /* FIXME: Should return GDBM_NEED_RECOVERY instead? */\n    return GDBM_BAD_HEADER;\n\n  /* Make sure dir and dir + dir_size fall within the file boundary */\n  if (!(hdr->dir > 0\n\t&& hdr->dir < st->st_size\n\t&& hdr->dir_size > 0\n\t&& hdr->dir + hdr->dir_size < st->st_size))\n    return GDBM_BAD_HEADER;\n\n  compute_directory_size (hdr->block_size, &dir_size, &dir_bits);\n  if (!(hdr->dir_size >= dir_size))\n    return GDBM_BAD_HEADER;\n  compute_directory_size (hdr->dir_size, &dir_size, &dir_bits);\n  if (hdr->dir_bits != dir_bits)\n    return GDBM_BAD_HEADER;\n  \n  if (!(hdr->bucket_size > sizeof(hash_bucket)))\n    return GDBM_BAD_HEADER;\n\n  if (hdr->bucket_elems != bucket_element_count (hdr->bucket_size))\n    return GDBM_BAD_HEADER;\n\n  if (((hdr->block_size - sizeof (gdbm_file_header)) / sizeof(avail_elem) + 1)\n      != hdr->avail.size)\n    return GDBM_BAD_HEADER;    \n  \n  return 0;\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gdbm_fd_open": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        579,
        1
      ],
      "content": "GDBM_FILE \ngdbm_fd_open (int fd, const char *file_name, int block_size,\n\t      int flags, void (*fatal_func) (const char *))\n{\n  GDBM_FILE dbf;\t\t/* The record to return. */\n  struct stat file_stat;\t/* Space for the stat information. */\n  off_t       file_pos;\t\t/* Used with seeks. */\n  int \t      index;\t\t/* Used as a loop index. */\n  \n  /* Initialize the gdbm_errno variable. */\n  gdbm_set_errno (NULL, GDBM_NO_ERROR, FALSE);\n\n  /* Get the status of the file. */\n  if (fstat (fd, &file_stat))\n    {\n      if (flags & GDBM_CLOERROR)\n\tSAVE_ERRNO (close (fd));\n      GDBM_SET_ERRNO2 (NULL, GDBM_FILE_STAT_ERROR, FALSE, GDBM_DEBUG_OPEN);\n      return NULL;\n    }\n  \n  /* Allocate new info structure. */\n  dbf = calloc (1, sizeof (*dbf));\n  if (dbf == NULL)\n    {\n      if (flags & GDBM_CLOERROR)\n\tSAVE_ERRNO (close (fd));\n      GDBM_SET_ERRNO2 (NULL, GDBM_MALLOC_ERROR, FALSE, GDBM_DEBUG_OPEN);\n      return NULL;\n    }\n\n  dbf->desc = fd;\n  \n  /* Initialize some fields for known values.  This is done so gdbm_close\n     will work if called before allocating some structures. */\n  dbf->dir  = NULL;\n  dbf->bucket = NULL;\n  dbf->header = NULL;\n  dbf->bucket_cache = NULL;\n  dbf->cache_size = 0;\n\n  dbf->memory_mapping = FALSE;\n  dbf->mapped_size_max = SIZE_T_MAX;\n  dbf->mapped_region = NULL;\n  dbf->mapped_size = 0;\n  dbf->mapped_pos = 0;\n  dbf->mapped_off = 0;\n  \n  /* Save name of file. */\n  dbf->name = strdup (file_name);\n  if (dbf->name == NULL)\n    {\n      if (flags & GDBM_CLOERROR)\n\tclose (fd);\n      free (dbf);\n      GDBM_SET_ERRNO2 (NULL, GDBM_MALLOC_ERROR, FALSE, GDBM_DEBUG_OPEN);\n      return NULL;\n    }\n\n  /* Initialize the fatal error routine. */\n  dbf->fatal_err = fatal_func;\n\n  dbf->fast_write = TRUE;\t/* Default to setting fast_write. */\n  dbf->file_locking = TRUE;\t/* Default to doing file locking. */\n  dbf->central_free = FALSE;\t/* Default to not using central_free. */\n  dbf->coalesce_blocks = FALSE; /* Default to not coalesce blocks. */\n\n  dbf->need_recovery = FALSE;\n  dbf->last_error = GDBM_NO_ERROR;\n  dbf->last_syserror = 0;\n  dbf->last_errstr = NULL;\n  \n  /* GDBM_FAST used to determine whether or not we set fast_write. */\n  if (flags & GDBM_SYNC)\n    {\n      /* If GDBM_SYNC has been requested, don't do fast_write. */\n      dbf->fast_write = FALSE;\n    }\n  if (flags & GDBM_NOLOCK)\n    {\n      dbf->file_locking = FALSE;\n    }\n\n  dbf->cloexec = !!(flags & GDBM_CLOEXEC);\n  \n  /* Zero-length file can't be a reader... */\n  if (((flags & GDBM_OPENMASK) == GDBM_READER) && (file_stat.st_size == 0))\n    {\n      if (flags & GDBM_CLOERROR)\n\tclose (dbf->desc);\n      free (dbf->name);\n      free (dbf);\n      GDBM_SET_ERRNO2 (NULL, GDBM_EMPTY_DATABASE, FALSE, GDBM_DEBUG_OPEN);\n      return NULL;\n    }\n\n  /* Record the kind of user. */\n  dbf->read_write = (flags & GDBM_OPENMASK);\n\n  /* Lock the file in the appropriate way. */\n  if (dbf->file_locking)\n    {\n      if (_gdbm_lock_file (dbf) == -1)\n\t{\n\t  if (flags & GDBM_CLOERROR)\n\t    close (dbf->desc);\n\t  free (dbf->name);\n\t  free (dbf);\n          GDBM_SET_ERRNO2 (NULL,\n\t\t\t   (flags & GDBM_OPENMASK) == GDBM_READER\n\t\t\t     ? GDBM_CANT_BE_READER : GDBM_CANT_BE_WRITER,\n\t\t\t   FALSE,\n\t\t\t   GDBM_DEBUG_OPEN);\n\t  return NULL;\n\t}\n    }\n\n  /* If we do have a write lock and it was a GDBM_NEWDB, it is \n     now time to truncate the file. */\n  if ((flags & GDBM_OPENMASK) == GDBM_NEWDB && file_stat.st_size != 0)\n    {\n      TRUNCATE (dbf);\n      if (fstat (dbf->desc, &file_stat))\n\t{\n\t  if (flags & GDBM_CLOERROR)\n\t    close (dbf->desc);\n\t  free (dbf->name);\n\t  free (dbf);\n\t  GDBM_SET_ERRNO2 (NULL, GDBM_FILE_STAT_ERROR, FALSE, GDBM_DEBUG_OPEN);\n\t  return NULL;\n\t}\n    }\n\n  /* Decide if this is a new file or an old file. */\n  if (file_stat.st_size == 0)\n    {\n      /* This is a new file.  Create an empty database.  */\n      int dir_size, dir_bits;\n      \n      /* Start with the blocksize. */\n      if (block_size < GDBM_MIN_BLOCK_SIZE)\n\t{\n\t  block_size = STATBLKSIZE (file_stat);\n\t  flags &= ~GDBM_BSEXACT;\n\t}\n      compute_directory_size (block_size, &dir_size, &dir_bits);\n      GDBM_DEBUG (GDBM_DEBUG_OPEN, \"%s: computed dir_size=%d, dir_bits=%d\",\n\t\t  dbf->name, dir_size, dir_bits);\n      /* Check for correct block_size. */\n      if (dir_size != block_size)\n\t{\n\t  if (flags & GDBM_BSEXACT)\n\t    {\n\t      if (!(flags & GDBM_CLOERROR))\n\t\tdbf->desc = -1;\n\t      gdbm_close (dbf);\n\t      GDBM_SET_ERRNO2 (NULL, GDBM_BLOCK_SIZE_ERROR, FALSE,\n\t\t\t       GDBM_DEBUG_OPEN);\n\t      return NULL;\n\t    }\n\t  else\n\t    block_size = dir_size;\n\t}\n      GDBM_DEBUG (GDBM_DEBUG_OPEN, \"%s: block_size=%d\", dbf->name, block_size);\n      \n      /* Get space for the file header. It will be written to disk, so\n         make sure there's no garbage in it. */\n      dbf->header = calloc (1, block_size);\n      if (dbf->header == NULL)\n\t{\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  gdbm_close (dbf);\n\t  GDBM_SET_ERRNO2 (NULL, GDBM_MALLOC_ERROR, FALSE, GDBM_DEBUG_OPEN);\n\t  return NULL;\n\t}\n\n      /* Set the magic number and the block_size. */\n      dbf->header->header_magic = GDBM_MAGIC;\n      dbf->header->block_size = block_size;\n      dbf->header->dir_size = dir_size;\n      dbf->header->dir_bits = dir_bits;\n\n      /* Allocate the space for the directory. */\n      dbf->dir = (off_t *) malloc (dbf->header->dir_size);\n      if (dbf->dir == NULL)\n\t{\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  gdbm_close (dbf);\n\t  GDBM_SET_ERRNO2 (NULL, GDBM_MALLOC_ERROR, FALSE, GDBM_DEBUG_OPEN);\n\t  return NULL;\n\t}\n      dbf->header->dir = dbf->header->block_size;\n\n      /* Create the first and only hash bucket. */\n      dbf->header->bucket_elems = bucket_element_count (dbf->header->block_size);\n      dbf->header->bucket_size  = dbf->header->block_size;\n      dbf->bucket = calloc (1, dbf->header->bucket_size);\n      if (dbf->bucket == NULL)\n\t{\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  gdbm_close (dbf);\n\t  GDBM_SET_ERRNO2 (NULL, GDBM_MALLOC_ERROR, FALSE, GDBM_DEBUG_OPEN);\n\t  return NULL;\n\t}\n      _gdbm_new_bucket (dbf, dbf->bucket, 0);\n      dbf->bucket->av_count = 1;\n      dbf->bucket->bucket_avail[0].av_adr = 3*dbf->header->block_size;\n      dbf->bucket->bucket_avail[0].av_size = dbf->header->block_size;\n\n      /* Set table entries to point to hash buckets. */\n      for (index = 0; index < GDBM_DIR_COUNT (dbf); index++)\n\tdbf->dir[index] = 2*dbf->header->block_size;\n\n      /* Initialize the active avail block. */\n      dbf->header->avail.size\n\t= ( (dbf->header->block_size - sizeof (gdbm_file_header))\n\t / sizeof (avail_elem)) + 1;\n      dbf->header->avail.count = 0;\n      dbf->header->avail.next_block = 0;\n      dbf->header->next_block  = 4*dbf->header->block_size;\n\n      /* Write initial configuration to the file. */\n      /* Block 0 is the file header and active avail block. */\n      if (_gdbm_full_write (dbf, dbf->header, dbf->header->block_size))\n\t{\n\t  GDBM_DEBUG (GDBM_DEBUG_OPEN|GDBM_DEBUG_ERR,\n\t\t      \"%s: error writing header: %s\",\n\t\t      dbf->name, gdbm_db_strerror (dbf));\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  SAVE_ERRNO (gdbm_close (dbf));\n\t  return NULL;\n\t}\n\n      /* Block 1 is the initial bucket directory. */\n      if (_gdbm_full_write (dbf, dbf->dir, dbf->header->dir_size))\n\t{\n\t  GDBM_DEBUG (GDBM_DEBUG_OPEN|GDBM_DEBUG_ERR,\n\t\t      \"%s: error writing directory: %s\",\n\t\t      dbf->name, gdbm_db_strerror (dbf));\t  \n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  SAVE_ERRNO (gdbm_close (dbf));\n\t  return NULL;\n\t}\n\n      /* Block 2 is the only bucket. */\n      if (_gdbm_full_write (dbf, dbf->bucket, dbf->header->bucket_size))\n\t{\n\t  GDBM_DEBUG (GDBM_DEBUG_OPEN|GDBM_DEBUG_ERR,\n\t\t      \"%s: error writing bucket: %s\",\n\t\t      dbf->name, gdbm_db_strerror (dbf));\t  \n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  SAVE_ERRNO (gdbm_close (dbf));\n\t  return NULL;\n\t}\n      \n      if (_gdbm_file_extend (dbf, dbf->header->next_block))\n\t{\n\t  GDBM_DEBUG (GDBM_DEBUG_OPEN|GDBM_DEBUG_ERR,\n\t\t      \"%s: error extending file: %s\",\n\t\t      dbf->name, gdbm_db_strerror (dbf));\t  \n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  SAVE_ERRNO (gdbm_close (dbf));\n\t  return NULL;\n\t}\n\t  \n      /* Wait for initial configuration to be written to disk. */\n      gdbm_file_sync (dbf);\n\n      free (dbf->bucket);\n    }\n  else\n    {\n      /* This is an old database.  Read in the information from the file\n\t header and initialize the hash directory. */\n\n      gdbm_file_header partial_header;  /* For the first part of it. */\n      int rc;\n      \n      /* Read the partial file header. */\n      if (_gdbm_full_read (dbf, &partial_header, sizeof (gdbm_file_header)))\n\t{\n\t  GDBM_DEBUG (GDBM_DEBUG_ERR|GDBM_DEBUG_OPEN,\n\t\t      \"%s: error reading partial header: %s\",\n\t\t      dbf->name, gdbm_db_strerror (dbf));\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  SAVE_ERRNO (gdbm_close (dbf));\n\t  return NULL;\n\t}\n\n      /* Is the header valid? */\n      rc = validate_header (&partial_header, &file_stat);\n      if (rc != GDBM_NO_ERROR)\n\t{\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  gdbm_close (dbf);\n\t  GDBM_SET_ERRNO2 (NULL, rc, FALSE, GDBM_DEBUG_OPEN);\n\t  return NULL;\n\t}\n      \n      /* It is a good database, read the entire header. */\n      dbf->header = malloc (partial_header.block_size);\n      if (dbf->header == NULL)\n\t{\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  SAVE_ERRNO (gdbm_close (dbf));\n\t  GDBM_SET_ERRNO2 (NULL, GDBM_MALLOC_ERROR, FALSE, GDBM_DEBUG_OPEN);\n\t  return NULL;\n\t}\n      \n      memcpy (dbf->header, &partial_header, sizeof (gdbm_file_header));\n      if (_gdbm_full_read (dbf, &dbf->header->avail.av_table[1],\n\t\t\t   dbf->header->block_size - sizeof (gdbm_file_header)))\n\t{\n\t  GDBM_DEBUG (GDBM_DEBUG_ERR|GDBM_DEBUG_OPEN,\n\t\t      \"%s: error reading av_table: %s\",\n\t\t      dbf->name, gdbm_db_strerror (dbf));\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  SAVE_ERRNO (gdbm_close (dbf));\n\t  return NULL;\n\t}\n\n      if (gdbm_avail_block_validate (dbf, &dbf->header->avail))\n\t{\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  SAVE_ERRNO (gdbm_close (dbf));\n\t  return NULL;\n\t}\t  \n\t\n      /* Allocate space for the hash table directory.  */\n      dbf->dir = malloc (dbf->header->dir_size);\n      if (dbf->dir == NULL)\n\t{\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  gdbm_close (dbf);\n\t  GDBM_SET_ERRNO2 (NULL, GDBM_MALLOC_ERROR, FALSE, GDBM_DEBUG_OPEN);\n\t  return NULL;\n\t}\n\n      /* Read the hash table directory. */\n      file_pos = gdbm_file_seek (dbf, dbf->header->dir, SEEK_SET);\n      if (file_pos != dbf->header->dir)\n\t{\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  SAVE_ERRNO (gdbm_close (dbf));\n\t  GDBM_SET_ERRNO2 (NULL, GDBM_FILE_SEEK_ERROR, FALSE, GDBM_DEBUG_OPEN);\n\t  return NULL;\n\t}\n\n      if (_gdbm_full_read (dbf, dbf->dir, dbf->header->dir_size))\n\t{\n\t  GDBM_DEBUG (GDBM_DEBUG_ERR|GDBM_DEBUG_OPEN,\n\t\t      \"%s: error reading dir: %s\",\n\t\t      dbf->name, gdbm_db_strerror (dbf));\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  SAVE_ERRNO (gdbm_close (dbf));\n\t  return NULL;\n\t}\n\n    }\n\n#if HAVE_MMAP\n  if (!(flags & GDBM_NOMMAP))\n    {\n      if (_gdbm_mapped_init (dbf) == 0)\n\tdbf->memory_mapping = TRUE;\n      else\n\t{\n\t  /* gdbm_errno should already be set. */\n\t  GDBM_DEBUG (GDBM_DEBUG_ERR|GDBM_DEBUG_OPEN,\n\t\t      \"%s: _gdbm_mapped_init failed: %s\",\n\t\t      dbf->name, strerror (errno));\n\n\t  if (!(flags & GDBM_CLOERROR))\n\t    dbf->desc = -1;\n\t  SAVE_ERRNO (gdbm_close (dbf));\n\t  return NULL;\n\t}\n    }\n#endif\n\n  /* Finish initializing dbf. */\n  dbf->last_read = -1;\n  dbf->bucket = NULL;\n  dbf->bucket_dir = 0;\n  dbf->cache_entry = NULL;\n  dbf->header_changed = FALSE;\n  dbf->directory_changed = FALSE;\n  dbf->bucket_changed = FALSE;\n  dbf->second_changed = FALSE;\n\n  GDBM_DEBUG (GDBM_DEBUG_ALL, \"%s: opened successfully\", dbf->name);\n\n  /* Everything is fine, return the pointer to the file\n     information structure.  */\n  return dbf;\n}",
      "lines": 411,
      "depth": 14,
      "decorators": [
        "GDBM_FILE"
      ]
    },
    "gdbm_open": {
      "start_point": [
        601,
        0
      ],
      "end_point": [
        637,
        1
      ],
      "content": "GDBM_FILE \ngdbm_open (const char *file, int block_size, int flags, int mode,\n     \t   void (*fatal_func) (const char *))\n{\n  int fd;\n  /* additional bits for open(2) flags */\n  int fbits = 0;\n\n  switch (flags & GDBM_OPENMASK)\n    {\n      case GDBM_READER:\n\tfbits = O_RDONLY;\n\tbreak;\n\n      case GDBM_WRITER:\n\tfbits = O_RDWR;\n\tbreak;\n\n      case GDBM_NEWDB:\n\tfbits = O_RDWR|O_CREAT;\n\tbreak;\n\n      default:\n\tfbits = O_RDWR|O_CREAT;\n    }\n  if (flags & GDBM_CLOEXEC)\n    fbits |= O_CLOEXEC;\n  \n  fd = open (file, fbits, mode);\n  if (fd < 0)\n    {\n      GDBM_SET_ERRNO2 (NULL, GDBM_FILE_OPEN_ERROR, FALSE, GDBM_DEBUG_OPEN);\n      return NULL;\n    }\n  return gdbm_fd_open (fd, file, block_size, flags | GDBM_CLOERROR,\n\t\t       fatal_func);\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "GDBM_FILE"
      ]
    },
    "_gdbm_init_cache": {
      "start_point": [
        640,
        0
      ],
      "end_point": [
        672,
        1
      ],
      "content": "int\n_gdbm_init_cache (GDBM_FILE dbf, size_t size)\n{\n  int index;\n\n  if (dbf->bucket_cache == NULL)\n    {\n      dbf->bucket_cache = calloc (size, sizeof(cache_elem));\n      if (dbf->bucket_cache == NULL)\n        {\n          GDBM_SET_ERRNO (dbf, GDBM_MALLOC_ERROR, TRUE);\n          return -1;\n        }\n      dbf->cache_size = size;\n\n      for (index = 0; index < size; index++)\n        {\n\t  (dbf->bucket_cache[index]).ca_bucket =\n\t    malloc (dbf->header->bucket_size);\n          if ((dbf->bucket_cache[index]).ca_bucket == NULL)\n\t    {\n              GDBM_SET_ERRNO (dbf, GDBM_MALLOC_ERROR, TRUE);\n\t      return -1;\n            }\n\t  dbf->bucket_cache[index].ca_data.dptr = NULL;\n\t  dbf->bucket_cache[index].ca_data.dsize = 0;\n\t  _gdbm_cache_entry_invalidate (dbf, index);\n        }\n      dbf->bucket = dbf->bucket_cache[0].ca_bucket;\n      dbf->cache_entry = &dbf->bucket_cache[0];\n    }\n  return 0;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_cache_entry_invalidate": {
      "start_point": [
        674,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "void\n_gdbm_cache_entry_invalidate (GDBM_FILE dbf, int index)\n{\n  dbf->bucket_cache[index].ca_adr = 0;\n  dbf->bucket_cache[index].ca_changed = FALSE;\n  dbf->bucket_cache[index].ca_data.hash_val = -1;\n  dbf->bucket_cache[index].ca_data.elem_loc = -1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmreorg.c": {
    "gdbm_reorganize": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\ngdbm_reorganize (GDBM_FILE dbf)\n{\n  gdbm_recovery rcvr;\n  \n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, -1);\n\n  rcvr.max_failures = 0;\n  return gdbm_recover (dbf, &rcvr, GDBM_RCVR_MAX_FAILURES|GDBM_RCVR_FORCE);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmseq.c": {
    "get_next_key": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static void\nget_next_key (GDBM_FILE dbf, int elem_loc, datum *return_val)\n{\n  int   found;\t\t\t/* Have we found the next key. */\n  char  *find_data;\t\t/* Data pointer returned by find_key. */\n\n  /* Find the next key. */\n  found = FALSE;\n  while (!found)\n    {\n      /* Advance to the next location in the bucket. */\n      elem_loc++;\n      if (elem_loc == dbf->header->bucket_elems)\n\t{\n\t  /* We have finished the current bucket, get the next bucket.  */\n\t  elem_loc = 0;\n\n\t  /* Find the next bucket.  It is possible several entries in\n\t     the bucket directory point to the same bucket. */\n\t  while (dbf->bucket_dir < GDBM_DIR_COUNT (dbf)\n\t\t && dbf->cache_entry->ca_adr == dbf->dir[dbf->bucket_dir])\n\t    dbf->bucket_dir++;\n\n\t  /* Check to see if there was a next bucket. */\n\t  if (dbf->bucket_dir < GDBM_DIR_COUNT (dbf))\n\t    {\n\t      if (_gdbm_get_bucket (dbf, dbf->bucket_dir))\n\t\treturn;\n\t    }\n\t  else\n\t    {\n\t      /* No next key, just return. */\n\t      GDBM_SET_ERRNO2 (dbf, GDBM_ITEM_NOT_FOUND, FALSE,\n\t\t\t       GDBM_DEBUG_LOOKUP);\n\t      return;\n\t    }\n\t}\n      found = dbf->bucket->h_table[elem_loc].hash_value != -1;\n    }\n  \n  /* Found the next key, read it into return_val. */\n  find_data = _gdbm_read_entry (dbf, elem_loc);\n  if (!find_data)\n    return;\n  return_val->dsize = dbf->bucket->h_table[elem_loc].key_size;\n  if (return_val->dsize == 0)\n    return_val->dptr = (char *) malloc (1);\n  else\n    return_val->dptr = (char *) malloc (return_val->dsize);\n  if (return_val->dptr == NULL)\n    {\n      return_val->dsize = 0;\n      GDBM_SET_ERRNO2 (dbf, GDBM_MALLOC_ERROR, FALSE, GDBM_DEBUG_LOOKUP);\n    }\n  else\n    memcpy (return_val->dptr, find_data, return_val->dsize);\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gdbm_firstkey": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "datum\ngdbm_firstkey (GDBM_FILE dbf)\n{\n  datum return_val;\t\t/* To return the first key. */\n\n  /* Set the default return value for not finding a first entry. */\n  return_val.dptr = NULL;\n\n  GDBM_DEBUG (GDBM_DEBUG_READ, \"%s: getting first key\", dbf->name);\n  \n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, return_val);\n  \n  /* Initialize the gdbm_errno variable. */\n  gdbm_set_errno (dbf, GDBM_NO_ERROR, FALSE);\n\n  /* Get the first bucket.  */\n  if (_gdbm_get_bucket (dbf, 0) == 0)\n    {\n      /* Look for first entry. */\n      get_next_key (dbf, -1, &return_val);\n      \n      if (return_val.dptr) \n\tGDBM_DEBUG_DATUM (GDBM_DEBUG_READ, return_val, \"%s: found\", dbf->name);\n      else\n\tGDBM_DEBUG (GDBM_DEBUG_READ, \"%s: key not found\", dbf->name);\n    }\n  \n  return return_val;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "datum"
      ]
    },
    "gdbm_nextkey": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "datum\ngdbm_nextkey (GDBM_FILE dbf, datum key)\n{\n  datum  return_val;\t\t/* The return value. */\n  int    elem_loc;\t\t/* The location in the bucket. */\n\n  /* Set the default return value for no next entry. */\n  return_val.dptr = NULL;\n\n  GDBM_DEBUG_DATUM (GDBM_DEBUG_READ, key, \"%s: getting next key\", dbf->name);\n  \n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, return_val);\n  \n  /* Initialize the gdbm_errno variable. */\n  gdbm_set_errno (dbf, GDBM_NO_ERROR, FALSE);\n\n  /* Do we have a valid key? */\n  if (key.dptr == NULL)\n    {\n      GDBM_DEBUG (GDBM_DEBUG_READ, \"%s: key not found\", dbf->name);\n      GDBM_SET_ERRNO2 (dbf, GDBM_ITEM_NOT_FOUND, /* FIXME: special error code perhaps */\n\t\t       FALSE,\n\t\t       GDBM_DEBUG_LOOKUP);\n      return return_val;\n    }\n  \n  /* Find the key.  */\n  elem_loc = _gdbm_findkey (dbf, key, NULL, NULL);\n  if (elem_loc == -1) return return_val;\n  \n  /* Find the next key. */  \n  get_next_key (dbf, elem_loc, &return_val);\n\n  if (return_val.dptr) \n    GDBM_DEBUG_DATUM (GDBM_DEBUG_READ, return_val, \"%s: found\", dbf->name);\n  else\n    GDBM_DEBUG (GDBM_DEBUG_READ, \"%s: key not found\", dbf->name);\n\n  return return_val;\n}",
      "lines": 41,
      "depth": 9,
      "decorators": [
        "datum"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmsetopt.c": {
    "getbool": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\ngetbool (void *optval, int optlen)\n{\n  int n;\n  \n  if (!optval || optlen != sizeof (int) ||\n      (((n = *(int*)optval) != TRUE) && n != FALSE))\n    return -1;\n  return n;\n}",
      "lines": 10,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_size": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static int\nget_size (void *optval, int optlen, size_t *ret)\n{\n  if (!optval)\n    return -1;\n  if (optlen == sizeof (unsigned))\n    *ret = *(unsigned*) optval;\n  else if (optlen == sizeof (unsigned long))\n    *ret = *(unsigned long*) optval;\n  else if (optlen == sizeof (size_t))\n    *ret = *(size_t*) optval;\n  else\n    return -1;\n  return 0;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_setcachesize": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static int\nsetopt_gdbm_setcachesize (GDBM_FILE dbf, void *optval, int optlen)\n{\n  size_t sz;\n\n  if (dbf->bucket_cache != NULL)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ALREADY_SET, FALSE);\n      return -1;\n    }\n  \n  /* Optval will point to the new size of the cache. */\n  if (get_size (optval, optlen, &sz))\n    {     \n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }  \n  return _gdbm_init_cache (dbf, (sz > 9) ? sz : 10);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_getcachesize": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static int\nsetopt_gdbm_getcachesize (GDBM_FILE dbf, void *optval, int optlen)\n{\n  if (!optval || optlen != sizeof (size_t))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  *(size_t*) optval = dbf->cache_size;\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_fastmode": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int\nsetopt_gdbm_fastmode (GDBM_FILE dbf, void *optval, int optlen)\n{\n  int n;\n\n  if ((n = getbool (optval, optlen)) == -1)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  dbf->fast_write = n;\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_setsyncmode": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "static int\nsetopt_gdbm_setsyncmode (GDBM_FILE dbf, void *optval, int optlen)\n{\n  int n;\n\n  /* Optval will point to either true or false. */\n  if ((n = getbool (optval, optlen)) == -1)\n    { \n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  dbf->fast_write = !n;\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_getsyncmode": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static int\nsetopt_gdbm_getsyncmode (GDBM_FILE dbf, void *optval, int optlen)\n{\n  if (!optval || optlen != sizeof (int))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  *(int*) optval = !dbf->fast_write;\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_setcentfree": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static int\nsetopt_gdbm_setcentfree (GDBM_FILE dbf, void *optval, int optlen)\n{\n  int n;\n  \n  /* Optval will point to either true or false. */\n  if ((n = getbool (optval, optlen)) == -1)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  dbf->central_free = n;\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_getcentfree": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static int\nsetopt_gdbm_getcentfree (GDBM_FILE dbf, void *optval, int optlen)\n{\n  if (!optval || optlen != sizeof (int))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  *(int*) optval = !dbf->central_free;\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_setcoalesceblks": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static int\nsetopt_gdbm_setcoalesceblks (GDBM_FILE dbf, void *optval, int optlen)\n{\n  int n;\n  \n  /* Optval will point to either true or false. */\n  if ((n = getbool (optval, optlen)) == -1)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  dbf->coalesce_blocks = n;\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_getcoalesceblks": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static int\nsetopt_gdbm_getcoalesceblks (GDBM_FILE dbf, void *optval, int optlen)\n{\n  if (!optval || optlen != sizeof (int))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  *(int*) optval = dbf->coalesce_blocks;\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_setmmap": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static int\nsetopt_gdbm_setmmap (GDBM_FILE dbf, void *optval, int optlen)\n{\n  int n;\n  \n  if ((n = getbool (optval, optlen)) == -1)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  gdbm_file_sync (dbf);\n  if (n == dbf->memory_mapping)\n    return 0;\n  if (n)\n    {\n      if (_gdbm_mapped_init (dbf) == 0)\n\tdbf->memory_mapping = TRUE;\n      else\n\treturn -1;\n    }\n  else\n    {\n      _gdbm_mapped_unmap (dbf);\n      dbf->memory_mapping = FALSE;\n    }\n  return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_getmmap": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static int\nsetopt_gdbm_getmmap (GDBM_FILE dbf, void *optval, int optlen)\n{\n  if (!optval || optlen != sizeof (int))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  *(int*) optval = dbf->memory_mapping;\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_setmaxmapsize": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static int\nsetopt_gdbm_setmaxmapsize (GDBM_FILE dbf, void *optval, int optlen)\n{\n  size_t page_size = sysconf (_SC_PAGESIZE);\n  size_t sz;\n\n  if (get_size (optval, optlen, &sz))\n    { \n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  dbf->mapped_size_max = ((sz + page_size - 1) / page_size) * page_size;\n  _gdbm_mapped_init (dbf);\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_getmaxmapsize": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static int\nsetopt_gdbm_getmaxmapsize (GDBM_FILE dbf, void *optval, int optlen)\n{\n  if (!optval || optlen != sizeof (size_t))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  *(size_t*) optval = dbf->mapped_size_max;\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_getflags": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static int\nsetopt_gdbm_getflags (GDBM_FILE dbf, void *optval, int optlen)\n{\n  if (!optval || optlen != sizeof (int))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  else\n    {\n      int flags = dbf->read_write;\n      if (!dbf->fast_write)\n\tflags |= GDBM_SYNC;\n      if (!dbf->file_locking)\n\tflags |= GDBM_NOLOCK;\n      if (!dbf->memory_mapping)\n\tflags |= GDBM_NOMMAP;\n      *(int*) optval = flags;\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_getdbname": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "static int\nsetopt_gdbm_getdbname (GDBM_FILE dbf, void *optval, int optlen)\n{\n  if (!optval || optlen != sizeof (char*))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n      return -1;\n    }\n  else\n    {\n      char *p = strdup (dbf->name);\n      if (!p)\n\t{\n\t  GDBM_SET_ERRNO (dbf, GDBM_MALLOC_ERROR, FALSE);\n\t  return -1;\n\t}\n      *(char**) optval = p;\n    }\n  return 0;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setopt_gdbm_getblocksize": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "static int\nsetopt_gdbm_getblocksize (GDBM_FILE dbf, void *optval, int optlen)\n{\n  if (optval && optlen == sizeof (int))\n    {\n      *(int*) optval = dbf->header->block_size;\n      return 0;\n    }\n  \n  GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n  return -1;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gdbm_setopt": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "int\ngdbm_setopt (GDBM_FILE dbf, int optflag, void *optval, int optlen)\n{\n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, -1);\n\n  if (optflag >= 0\n      && optflag < sizeof (setopt_handler_tab) / sizeof (setopt_handler_tab[0])\n      && setopt_handler_tab[optflag])\n    return setopt_handler_tab[optflag] (dbf, optval, optlen);\n  \n  GDBM_SET_ERRNO (dbf, GDBM_OPT_ILLEGAL, FALSE);\n  return -1;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmstore.c": {
    "gdbm_store": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "int\ngdbm_store (GDBM_FILE dbf, datum key, datum content, int flags)\n{\n  int  new_hash_val;\t\t/* The new hash value. */\n  int  elem_loc;\t\t/* The location in hash bucket. */\n  off_t file_adr;\t\t/* The address of new space in the file.  */\n  off_t file_pos;\t\t/* The position after a lseek. */\n  off_t free_adr;\t\t/* For keeping track of a freed section. */\n  int  free_size;\n  int   new_size;\t\t/* Used in allocating space. */\n  int rc;\n\n  GDBM_DEBUG_DATUM (GDBM_DEBUG_STORE, key, \"%s: storing key:\", dbf->name);\n\n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, -1);\n  \n  /* First check to make sure this guy is a writer. */\n  if (dbf->read_write == GDBM_READER)\n    {\n      GDBM_SET_ERRNO2 (dbf, GDBM_READER_CANT_STORE, FALSE,\n\t\t       GDBM_DEBUG_STORE);\n      return -1;\n    }\n\n  /* Check for illegal data values.  A NULL dptr field is illegal because\n     NULL dptr returned by a lookup procedure indicates an error. */\n  if ((key.dptr == NULL) || (content.dptr == NULL))\n    {\n      GDBM_SET_ERRNO2 (dbf, GDBM_ILLEGAL_DATA, FALSE,\n\t\t       GDBM_DEBUG_STORE);\n      return -1;\n    }\n\n  /* Initialize the gdbm_errno variable. */\n  gdbm_set_errno (dbf, GDBM_NO_ERROR, FALSE);\n\n  /* Look for the key in the file.\n     A side effect loads the correct bucket and calculates the hash value. */\n  elem_loc = _gdbm_findkey (dbf, key, NULL, &new_hash_val);\n\n  /* Initialize these. */\n  file_adr = 0;\n  new_size = key.dsize + content.dsize;\n\n  /* Did we find the item? */\n  if (elem_loc != -1)\n    {\n      if (flags == GDBM_REPLACE)\n\t{\n\t  /* Just replace the data. */\n\t  free_adr = dbf->bucket->h_table[elem_loc].data_pointer;\n\t  free_size = dbf->bucket->h_table[elem_loc].key_size\n\t              + dbf->bucket->h_table[elem_loc].data_size;\n\t  if (free_size != new_size)\n\t    {\n\t      if (_gdbm_free (dbf, free_adr, free_size))\n\t\treturn -1;\n\t    }\n\t  else\n\t    {\n\t      /* Just reuse the same address! */\n\t      file_adr = free_adr;\n\t    }\n\t}\n      else\n\t{\n\t  GDBM_SET_ERRNO2 (dbf, GDBM_CANNOT_REPLACE, FALSE,\n\t\t\t   GDBM_DEBUG_STORE);\n\t  return 1;\n\t}\n    }\n  else if (gdbm_errno == GDBM_ITEM_NOT_FOUND)\n    gdbm_set_errno (dbf, GDBM_NO_ERROR, FALSE); /* clear error state */\n  else\n    return -1;\n\n  /* Get the file address for the new space.\n     (Current bucket's free space is first place to look.) */\n  if (file_adr == 0)\n    {\n      file_adr = _gdbm_alloc (dbf, new_size);\n      if (file_adr == 0)\n\treturn -1;\n    }\n\n  /* If this is a new entry in the bucket, we need to do special things. */\n  if (elem_loc == -1)\n    {\n      int start_loc;\n      \n      if (dbf->bucket->count == dbf->header->bucket_elems)\n\t{\n\t  /* Split the current bucket. */\n\t  if (_gdbm_split_bucket (dbf, new_hash_val))\n\t    return -1;\n\t}\n      \n      /* Find space to insert into bucket and set elem_loc to that place. */\n      elem_loc = start_loc = new_hash_val % dbf->header->bucket_elems;\n      while (dbf->bucket->h_table[elem_loc].hash_value != -1)\n\t{\n\t  elem_loc = (elem_loc + 1) % dbf->header->bucket_elems;\n\t  if (elem_loc == start_loc)\n\t    {\n\t      GDBM_SET_ERRNO (dbf, GDBM_BAD_HASH_TABLE, TRUE);\n\t      return -1;\n\t    }\n\t}\n      \n      /* We now have another element in the bucket.  Add the new information.*/\n      dbf->bucket->count++;\n      dbf->bucket->h_table[elem_loc].hash_value = new_hash_val;\n      memcpy (dbf->bucket->h_table[elem_loc].key_start, key.dptr,\n\t     (SMALL < key.dsize ? SMALL : key.dsize));\n    }\n\n\n  /* Update current bucket data pointer and sizes. */\n  dbf->bucket->h_table[elem_loc].data_pointer = file_adr;\n  dbf->bucket->h_table[elem_loc].key_size = key.dsize;\n  dbf->bucket->h_table[elem_loc].data_size = content.dsize;\n\n  /* Write the data to the file. */\n  file_pos = gdbm_file_seek (dbf, file_adr, SEEK_SET);\n  if (file_pos != file_adr)\n    {\n      GDBM_DEBUG (GDBM_DEBUG_STORE|GDBM_DEBUG_ERR,\n\t\t  \"%s: lseek: %s\", dbf->name, strerror (errno));      \n      GDBM_SET_ERRNO2 (dbf, GDBM_FILE_SEEK_ERROR, TRUE, GDBM_DEBUG_STORE);\n      _gdbm_fatal (dbf, _(\"lseek error\"));\n      return -1;\n    }\n\n  rc = _gdbm_full_write (dbf, key.dptr, key.dsize);\n  if (rc)\n    {\n      GDBM_DEBUG (GDBM_DEBUG_STORE|GDBM_DEBUG_ERR,\n\t\t  \"%s: error writing key: %s\",\n\t\t  dbf->name, gdbm_db_strerror (dbf));      \n      _gdbm_fatal (dbf, gdbm_db_strerror (dbf));\n      return -1;\n    }\n\n  rc = _gdbm_full_write (dbf, content.dptr, content.dsize);\n  if (rc)\n    {\n      GDBM_DEBUG (GDBM_DEBUG_STORE|GDBM_DEBUG_ERR,\n\t\t  \"%s: error writing content: %s\",\n\t\t  dbf->name, gdbm_db_strerror (dbf));      \n      _gdbm_fatal (dbf, gdbm_db_strerror (dbf));\n      return -1;\n    }\n\n  /* Current bucket has changed. */\n  dbf->cache_entry->ca_changed = TRUE;\n  dbf->bucket_changed = TRUE;\n\n  /* Write everything that is needed to the disk. */\n  return _gdbm_end_update (dbf);\n}",
      "lines": 161,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmsync.c": {
    "gdbm_sync": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\ngdbm_sync (GDBM_FILE dbf)\n{\n  /* Return immediately if the database needs recovery */\t\n  GDBM_ASSERT_CONSISTENCY (dbf, );\n\n  /* Initialize the gdbm_errno variable. */\n  gdbm_set_errno (dbf, GDBM_NO_ERROR, FALSE);\n\n  /* Do the sync on the file. */\n  gdbm_file_sync (dbf);\n\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmtool.c": {
    "closedb": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static void\nclosedb (void)\n{\n  if (gdbm_file)\n    {\n      gdbm_close (gdbm_file);\n      gdbm_file = NULL;\n      free (file_name);\n      file_name = NULL;\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "opendb": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static int\nopendb (char *dbname)\n{\n  int cache_size = 0;\n  int block_size = 0;\n  int flags = 0;\n  int filemode;\n  GDBM_FILE db;\n  \n  switch (variable_get (\"cachesize\", VART_INT, (void**) &cache_size))\n    {\n    case VAR_OK:\n    case VAR_ERR_NOTSET:\n      break;\n    default:\n      abort ();\n    }\n  switch (variable_get (\"blocksize\", VART_INT, (void**) &block_size))\n    {\n    case VAR_OK:\n    case VAR_ERR_NOTSET:\n      break;\n    default:\n      abort ();\n    }\n  \n  if (!variable_is_true (\"lock\"))\n    flags |= GDBM_NOLOCK;\n  if (!variable_is_true (\"mmap\"))\n    flags |= GDBM_NOMMAP;\n  if (variable_is_true (\"sync\"))\n    flags |= GDBM_SYNC;\n      \n  if (open_mode == GDBM_NEWDB)\n    {\n      if (interactive () && variable_is_true (\"confirm\") &&\n\t  access (dbname, F_OK) == 0)\n\t{\n\t  if (!getyn (_(\"database %s already exists; overwrite\"), dbname))\n\t    return 1;\n\t}\n    }\n  \n  if (variable_get (\"filemode\", VART_INT, (void**) &filemode))\n    abort ();\n\n  db = gdbm_open (dbname, block_size, open_mode | flags, filemode, NULL);\n\n  if (db == NULL)\n    {\n      terror (_(\"cannot open database %s: %s\"), dbname,\n\t      gdbm_strerror (gdbm_errno));\n      return 1;\n    }\n\n  if (cache_size &&\n      gdbm_setopt (db, GDBM_CACHESIZE, &cache_size, sizeof (int)) == -1)\n    terror (_(\"gdbm_setopt failed: %s\"), gdbm_strerror (gdbm_errno));\n\n  if (gdbm_file)\n    gdbm_close (gdbm_file);\n  \n  gdbm_file = db;\n  return 0;\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "checkdb": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static int\ncheckdb (void)\n{\n  if (!gdbm_file)\n    {\n      if (!file_name)\n\t{\n\t  file_name = estrdup (GDBMTOOL_DEFFILE);\n\t  terror (_(\"warning: using default database file %s\"),\n\t\t\tfile_name);\n\t}\n      return opendb (file_name);\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "checkdb_begin": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static int\ncheckdb_begin (struct handler_param *param GDBM_ARG_UNUSED,\n\t       size_t *exp_count GDBM_ARG_UNUSED)\n{\n  return checkdb ();\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "bucket_print_lines": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "size_t\nbucket_print_lines (hash_bucket *bucket)\n{\n  return 6 + gdbm_file->header->bucket_elems + 3 + bucket->av_count;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    },
    "format_key_start": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static void\nformat_key_start (FILE *fp, bucket_element *elt)\n{\n  int size = SMALL < elt->key_size ? SMALL : elt->key_size;\n  int i;\n\n  for (i = 0; i < size; i++)\n    {\n      if (isprint (elt->key_start[i]))\n\tfprintf (fp, \"   %c\", elt->key_start[i]);\n      else\n\tfprintf (fp, \" %03o\", elt->key_start[i]);\n    }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_bucket": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "void\nprint_bucket (FILE *fp, hash_bucket *bucket, const char *mesg, ...)\n{\n  int index;\n  va_list ap;\n\n  fprintf (fp, \"******* \");\n  va_start(ap, mesg);\n  vfprintf (fp, mesg, ap);\n  va_end (ap);\n  fprintf (fp, \" **********\\n\\n\");\n  fprintf (fp,\n\t   _(\"bits = %d\\ncount= %d\\nHash Table:\\n\"),\n\t   bucket->bucket_bits, bucket->count);\n  fprintf (fp,\n\t   _(\"    #    hash value     key size    data size     data adr home  key start\\n\"));\n  for (index = 0; index < gdbm_file->header->bucket_elems; index++)\n    {\n      fprintf (fp, \" %4d  %12x  %11d  %11d  %11lu %4d\", index,\n\t       bucket->h_table[index].hash_value,\n\t       bucket->h_table[index].key_size,\n\t       bucket->h_table[index].data_size,\n\t       (unsigned long) bucket->h_table[index].data_pointer,\n\t       bucket->h_table[index].hash_value %\n\t       gdbm_file->header->bucket_elems);\n      if (bucket->h_table[index].key_size)\n\t{\n\t  fprintf (fp, \" \");\n\t  format_key_start (fp, &bucket->h_table[index]);\n\t}\n      fprintf (fp, \"\\n\");\n    }\n\n  fprintf (fp, _(\"\\nAvail count = %1d\\n\"), bucket->av_count);\n  fprintf (fp, _(\"Address           size\\n\"));\n  for (index = 0; index < bucket->av_count; index++)\n    fprintf (fp, \"%11lu%9d\\n\",\n\t     (unsigned long) bucket->bucket_avail[index].av_adr,\n\t     bucket->bucket_avail[index].av_size);\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_gdbm_avail_list_size": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "size_t\n_gdbm_avail_list_size (GDBM_FILE dbf, size_t min_size)\n{\n  int             temp;\n  int             size;\n  avail_block    *av_stk;\n  size_t          lines;\n  \n  lines = 4 + dbf->header->avail.count;\n  if (lines > min_size)\n    return lines;\n  /* Initialize the variables for a pass throught the avail stack. */\n  temp = dbf->header->avail.next_block;\n  size = (((dbf->header->avail.size * sizeof (avail_elem)) >> 1)\n\t  + sizeof (avail_block));\n  av_stk = emalloc (size);\n\n  /* Traverse the stack. */\n  while (temp)\n    {\n      if (gdbm_file_seek (dbf, temp, SEEK_SET) != temp)\n\t{\n\t  terror (\"lseek: %s\", strerror (errno));\n\t  break;\n\t}\n      \n      if (_gdbm_full_read (dbf, av_stk, size))\n\t{\n\t  terror (\"read: %s\", gdbm_db_strerror (dbf));\n\t  break;\n\t}\n\n      if (gdbm_avail_block_valid_p (av_stk))\n\t{\n\t  lines += av_stk->count;\n\t  if (lines > min_size)\n\t    break;\n\t}\n      temp = av_stk->next_block;\n    }\n  free (av_stk);\n\n  return lines;\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "size_t"
      ]
    },
    "av_table_display": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static void\nav_table_display (avail_elem *av_table, int count, FILE *fp)\n{\n  int i;\n  \n  for (i = 0; i < count; i++)\n    {\n      fprintf (fp, \"  %15d   %10lu \\n\",\n\t       av_table[i].av_size, (unsigned long) av_table[i].av_adr);\n    }\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_gdbm_print_avail_list": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "void\n_gdbm_print_avail_list (FILE *fp, GDBM_FILE dbf)\n{\n  int             temp;\n  int             size;\n  avail_block    *av_stk;\n  \n  /* Print the the header avail block.  */\n  fprintf (fp, _(\"\\nheader block\\nsize  = %d\\ncount = %d\\n\"),\n\t   dbf->header->avail.size, dbf->header->avail.count);\n  av_table_display (dbf->header->avail.av_table, dbf->header->avail.count, fp);\n\n  /* Initialize the variables for a pass throught the avail stack. */\n  temp = dbf->header->avail.next_block;\n  size = (dbf->header->avail.size * sizeof (avail_elem))\n\t  + sizeof (avail_block);\n  av_stk = emalloc (size);\n\n  /* Print the stack. */\n  while (temp)\n    {\n      if (gdbm_file_seek (dbf, temp, SEEK_SET) != temp)\n\t{\n\t  terror (\"lseek: %s\", strerror (errno));\n\t  break;\n\t}\n      \n      if (_gdbm_full_read (dbf, av_stk, size))\n\t{\n          terror (\"read: %s\", gdbm_db_strerror (dbf));\n\t  break;\n\t}\n\n      /* Print the block! */\n      fprintf (fp, _(\"\\nblock = %d\\nsize  = %d\\ncount = %d\\n\"), temp,\n\t       av_stk->size, av_stk->count);\n      if (gdbm_avail_block_validate (dbf, av_stk) == 0)\n\tav_table_display (av_stk->av_table, av_stk->count, fp);\n      else\n\tterror (_(\"invalid avail_block\"));\n      temp = av_stk->next_block;\n    }\n  free (av_stk);\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_gdbm_print_bucket_cache": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "void\n_gdbm_print_bucket_cache (FILE *fp, GDBM_FILE dbf)\n{\n  int             index;\n  char            changed;\n\n  if (dbf->bucket_cache != NULL)\n    {\n      fprintf (fp,\n\t_(\"Bucket Cache (size %zu):\\n  Index:         Address  Changed  Data_Hash \\n\"),\n\t dbf->cache_size);\n      for (index = 0; index < dbf->cache_size; index++)\n\t{\n\t  changed = dbf->bucket_cache[index].ca_changed;\n\t  fprintf (fp, \"  %5d:  %15lu %7s  %x\\n\",\n\t\t   index,\n\t\t   (unsigned long) dbf->bucket_cache[index].ca_adr,\n\t\t   (changed ? _(\"True\") : _(\"False\")),\n\t\t   dbf->bucket_cache[index].ca_data.hash_val);\n\t}\n    }\n  else\n    fprintf (fp, _(\"Bucket cache has not been initialized.\\n\"));\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "trimnl": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "int\ntrimnl (char *str)\n{\n  int len = strlen (str);\n\n  if (str[len - 1] == '\\n')\n    {\n      str[--len] = 0;\n      return 1;\n    }\n  return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "get_screen_lines": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "int\nget_screen_lines ()\n{\n#ifdef TIOCGWINSZ\n  if (isatty (1))\n    {\n      struct winsize ws;\n\n      ws.ws_col = ws.ws_row = 0;\n      if ((ioctl(1, TIOCGWINSZ, (char *) &ws) < 0) || ws.ws_row == 0)\n\t{\n\t  const char *lines = getenv (\"LINES\");\n\t  if (lines)\n\t    ws.ws_row = strtol (lines, NULL, 10);\n\t}\n      return ws.ws_row;\n    }\n#else\n  const char *lines = getenv (\"LINES\");\n  if (lines)\n    return strtol (lines, NULL, 10);\n#endif\n  return -1;\n}",
      "lines": 24,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "open_handler": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "void\nopen_handler (struct handler_param *param)\n{\n  char *name = tildexpand (PARAM_STRING (param, 0));\n  closedb ();\n  if (opendb (name) == 0)\n    file_name = name;\n  else\n    free (name);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "close_handler": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "void\nclose_handler (struct handler_param *param)\n{\n  if (!gdbm_file)\n    terror (_(\"nothing to close\"));\n  else\n    closedb ();\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "count_to_str": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "static char *\ncount_to_str (gdbm_count_t count, char *buf, size_t bufsize)\n{\n  char *p = buf + bufsize;\n\n  *--p = 0;\n  if (count == 0)\n    *--p = '0';\n  else\n    while (count)\n      {\n\tif (p == buf)\n\t  return NULL;\n\t*--p = '0' + count % 10;\n\tcount /= 10;\n      }\n  return p;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ncount_to_str (gdbm_count_t count, char *buf, size_t bufsize)",
        "*"
      ]
    },
    "count_handler": {
      "start_point": [
        417,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "void\ncount_handler (struct handler_param *param)\n{\n  gdbm_count_t count;\n\n  if (gdbm_count (gdbm_file, &count))\n    terror (\"gdbm_count: %s\", gdbm_strerror (gdbm_errno));\n  else\n    {\n      char buf[128];\n      char *p = count_to_str (count, buf, sizeof buf);\n\n      if (!p)\n\tterror (_(\"count buffer overflow\"));\n      else\n\tfprintf (param->fp, \n\t\t ngettext (\"There is %s item in the database.\\n\",\n\t\t\t   \"There are %s items in the database.\\n\",\n\t\t\t   count),\n\t\t p);\n    }\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "delete_handler": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        451,
        1
      ],
      "content": "void\ndelete_handler (struct handler_param *param)\n{\n  if (gdbm_delete (gdbm_file, PARAM_DATUM (param, 0)) != 0)\n    {\n      if (gdbm_errno == GDBM_ITEM_NOT_FOUND)\n\tterror (_(\"Item not found\"));\n      else\n\tterror (_(\"Can't delete: %s\"), gdbm_strerror (gdbm_errno));\n    }\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "fetch_handler": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        468,
        1
      ],
      "content": "void\nfetch_handler (struct handler_param *param)\n{\n  return_data = gdbm_fetch (gdbm_file, PARAM_DATUM (param, 0));\n  if (return_data.dptr != NULL)\n    {\n      datum_format (param->fp, &return_data, dsdef[DS_CONTENT]);\n      fputc ('\\n', param->fp);\n      free (return_data.dptr);\n    }\n  else if (gdbm_errno == GDBM_ITEM_NOT_FOUND)\n    terror (\"%s\", _(\"No such item found.\"));\n  else\n    terror (_(\"Can't fetch data: %s\"), gdbm_strerror (gdbm_errno));\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "store_handler": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "void\nstore_handler (struct handler_param *param)\n{\n  if (gdbm_store (gdbm_file,\n\t\t  PARAM_DATUM (param, 0), PARAM_DATUM (param, 1),\n\t\t  GDBM_REPLACE) != 0)\n    terror (_(\"Item not inserted: %s.\"), gdbm_db_strerror (gdbm_file));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "firstkey_handler": {
      "start_point": [
        482,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "void\nfirstkey_handler (struct handler_param *param)\n{\n  if (key_data.dptr != NULL)\n    free (key_data.dptr);\n  key_data = gdbm_firstkey (gdbm_file);\n  if (key_data.dptr != NULL)\n    {\n      datum_format (param->fp, &key_data, dsdef[DS_KEY]);\n      fputc ('\\n', param->fp);\n\n      return_data = gdbm_fetch (gdbm_file, key_data);\n      datum_format (param->fp, &return_data, dsdef[DS_CONTENT]);\n      fputc ('\\n', param->fp);\n\n      free (return_data.dptr);\n    }\n  else if (gdbm_errno == GDBM_ITEM_NOT_FOUND)\n    fprintf (param->fp, _(\"No such item found.\\n\"));\n  else\n    terror (_(\"Can't find key: %s\"), gdbm_strerror (gdbm_errno));\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "nextkey_handler": {
      "start_point": [
        506,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "void\nnextkey_handler (struct handler_param *param)\n{\n  if (param->argc == 1)\n    {\n      if (key_data.dptr != NULL)\n\tfree (key_data.dptr);\n      key_data.dptr = emalloc (PARAM_DATUM (param, 0).dsize);\n      key_data.dsize = PARAM_DATUM (param, 0).dsize;\n      memcpy (key_data.dptr, PARAM_DATUM (param, 0).dptr, key_data.dsize);\n    }\n  return_data = gdbm_nextkey (gdbm_file, key_data);\n  if (return_data.dptr != NULL)\n    {\n      key_data = return_data;\n      datum_format (param->fp, &key_data, dsdef[DS_KEY]);\n      fputc ('\\n', param->fp);\n\n      return_data = gdbm_fetch (gdbm_file, key_data);\n      datum_format (param->fp, &return_data, dsdef[DS_CONTENT]);\n      fputc ('\\n', param->fp);\n\n      free (return_data.dptr);\n    }\n  else if (gdbm_errno == GDBM_ITEM_NOT_FOUND)\n    {\n      terror (\"%s\", _(\"No such item found.\"));\n      free (key_data.dptr);\n      key_data.dptr = NULL;\n    }\n  else\n    terror (_(\"Can't find key: %s\"), gdbm_strerror (gdbm_errno));\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "reorganize_handler": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        548,
        1
      ],
      "content": "void\nreorganize_handler (struct handler_param *param GDBM_ARG_UNUSED)\n{\n  if (gdbm_reorganize (gdbm_file))\n    terror (\"%s\", _(\"Reorganization failed.\"));\n  else\n    fprintf (param->fp, \"%s\\n\", _(\"Reorganization succeeded.\"));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "err_printer": {
      "start_point": [
        550,
        0
      ],
      "end_point": [
        559,
        1
      ],
      "content": "static void\nerr_printer (void *data GDBM_ARG_UNUSED, char const *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n  fprintf (stderr, \"\\n\");\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "recover_handler": {
      "start_point": [
        562,
        0
      ],
      "end_point": [
        660,
        1
      ],
      "content": "void\nrecover_handler (struct handler_param *param)\n{\n  gdbm_recovery rcvr;\n  int flags = 0;\n  int rc;\n  int i;\n  char *p;\n  int summary = 0;\n  \n  for (i = 0; i < param->argc; i++)\n    {\n      char *arg = PARAM_STRING (param, i);\n      if (strcmp (arg, \"verbose\") == 0)\n\t{\n\t  rcvr.errfun = err_printer;\n\t  flags |= GDBM_RCVR_ERRFUN;\n\t}\n      else if (strcmp (arg, \"summary\") == 0)\n\t{\n\t  summary = 1;\n\t}\n      else if (strcmp (arg, \"backup\") == 0)\n\t{\n\t  rcvr.errfun = err_printer;\n\t  flags |= GDBM_RCVR_BACKUP;\n\t}\n      else if (strncmp (arg, \"max-failures=\", 13) == 0)\n\t{\n\t  rcvr.max_failures = strtoul (arg + 13, &p, 10);\n\t  if (*p)\n\t    {\n\t      printf (_(\"not a number (stopped near %s)\\n\"), p);\n\t      return;\n\t    }\n\t  flags |= GDBM_RCVR_MAX_FAILURES;\n\t}\n      else if (strncmp (arg, \"max-failed-keys=\", 16) == 0)\n\t{\n\t  rcvr.max_failed_keys = strtoul (arg + 16, &p, 10);\n\t  if (*p)\n\t    {\n\t      printf (_(\"not a number (stopped near %s)\\n\"), p);\n\t      return;\n\t    }\n\t  flags |= GDBM_RCVR_MAX_FAILED_KEYS;\n\t}\n      else if (strncmp (arg, \"max-failed-buckets=\", 19) == 0)\n\t{\n\t  rcvr.max_failures = strtoul (arg + 19, &p, 10);\n\t  if (*p)\n\t    {\n\t      printf (_(\"not a number (stopped near %s)\\n\"), p);\n\t      return;\n\t    }\n\t  flags |= GDBM_RCVR_MAX_FAILED_BUCKETS;\n\t}\n      else\n\t{\n\t  terror (_(\"unrecognized argument: %s\"), arg);\n\t  return;\n\t}\n    }\n\n  rc = gdbm_recover (gdbm_file, &rcvr, flags);\n\n  if (rc == 0)\n    {\n      fprintf (param->fp, _(\"Recovery succeeded.\\n\"));\n      if (summary)\n\t{\n\t  fprintf (param->fp,\n\t\t   _(\"Keys recovered: %lu, failed: %lu, duplicate: %lu\\n\"),\n\t\t   (unsigned long) rcvr.recovered_keys,\n\t\t   (unsigned long) rcvr.failed_keys,\n\t\t   (unsigned long) rcvr.duplicate_keys);\n\t  fprintf (param->fp,\n\t\t   _(\"Buckets recovered: %lu, failed: %lu\\n\"),\n\t\t   (unsigned long) rcvr.recovered_buckets,\n\t\t   (unsigned long) rcvr.failed_buckets);\n\t}\n      \n      if (rcvr.backup_name)\n\t{\n\t  fprintf (param->fp,\n\t\t   _(\"Original database preserved in file %s\"),\n\t\t   rcvr.backup_name);\n\t  free (rcvr.backup_name);\n\t}\n      fputc ('\\n', param->fp);\n    }\n  else\n    {\n      fprintf (stderr, _(\"Recovery failed: %s\"), gdbm_strerror (gdbm_errno));\n      if (gdbm_syserr[gdbm_errno])\n\tfprintf (stderr, \": %s\", strerror (errno));\n      fputc ('\\n', stderr);\n    }\n}",
      "lines": 99,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "avail_begin": {
      "start_point": [
        663,
        0
      ],
      "end_point": [
        671,
        1
      ],
      "content": "int\navail_begin (struct handler_param *param GDBM_ARG_UNUSED, size_t *exp_count)\n{\n  if (checkdb ())\n    return 1;\n  if (exp_count)\n    *exp_count = _gdbm_avail_list_size (gdbm_file, SIZE_T_MAX);\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "avail_handler": {
      "start_point": [
        673,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "void\navail_handler (struct handler_param *param)\n{\n  _gdbm_print_avail_list (param->fp, gdbm_file);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "print_current_bucket_begin": {
      "start_point": [
        680,
        0
      ],
      "end_point": [
        693,
        1
      ],
      "content": "int\nprint_current_bucket_begin (struct handler_param *param GDBM_ARG_UNUSED,\n\t\t\t    size_t *exp_count)\n{\n  if (checkdb ())\n    return 1;\n  if (!gdbm_file->bucket)\n    return 0;\n  if (exp_count)\n    *exp_count = gdbm_file->bucket\n                   ? bucket_print_lines (gdbm_file->bucket) + 3\n                   : 1;\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "print_current_bucket_handler": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "void\nprint_current_bucket_handler (struct handler_param *param)\n{\n  if (!gdbm_file->bucket)\n    fprintf (param->fp, _(\"no current bucket\\n\"));\n  else\n    {\n      if (param->argc)\n\tprint_bucket (param->fp, gdbm_file->bucket, _(\"Bucket #%s\"),\n\t\t      PARAM_STRING (param, 0));\n      else\n\tprint_bucket (param->fp, gdbm_file->bucket, \"%s\", _(\"Current bucket\"));\n      fprintf (param->fp, _(\"\\n current directory entry = %d.\\n\"),\n\t       gdbm_file->bucket_dir);\n      fprintf (param->fp, _(\" current bucket address  = %lu.\\n\"),\n\t       (unsigned long) gdbm_file->cache_entry->ca_adr);\n    }\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "getnum": {
      "start_point": [
        714,
        0
      ],
      "end_point": [
        735,
        1
      ],
      "content": "int\ngetnum (int *pnum, char *arg, char **endp)\n{\n  char *p;\n  unsigned long x = strtoul (arg, &p, 10);\n  if (*p && !isspace (*p))\n    {\n      printf (_(\"not a number (stopped near %s)\\n\"), p);\n      return 1;\n    }\n  while (*p && isspace (*p))\n    p++;\n  if (endp)\n    *endp = p;\n  else if (*p)\n    {\n      printf (_(\"not a number (stopped near %s)\\n\"), p);\n      return 1;\n    }\n  *pnum = x;\n  return 0;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "print_bucket_begin": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        763,
        1
      ],
      "content": "int\nprint_bucket_begin (struct handler_param *param, size_t *exp_count)\n{\n  int temp;\n\n  if (checkdb ())\n    return 1;\n  \n  if (getnum (&temp, PARAM_STRING (param, 0), NULL))\n    return 1;\n\n  if (temp >= GDBM_DIR_COUNT (gdbm_file))\n    {\n      terror (_(\"Not a bucket.\"));\n      return 1;\n    }\n  if (_gdbm_get_bucket (gdbm_file, temp))\n    {\n      terror (\"%s\", gdbm_db_strerror (gdbm_file));\n      return 1;\n    }\n  if (exp_count)\n    *exp_count = bucket_print_lines (gdbm_file->bucket) + 3;\n  return 0;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "print_dir_begin": {
      "start_point": [
        766,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "int\nprint_dir_begin (struct handler_param *param GDBM_ARG_UNUSED, size_t *exp_count)\n{\n  if (checkdb ())\n    return 1;\n  if (exp_count)\n    *exp_count = GDBM_DIR_COUNT (gdbm_file) + 3;\n  return 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "bucket_count": {
      "start_point": [
        776,
        0
      ],
      "end_point": [
        792,
        1
      ],
      "content": "static size_t\nbucket_count (void)\n{\n  int i;\n  off_t last = 0;\n  size_t count = 0;\n  \n  for (i = 0; i < GDBM_DIR_COUNT (gdbm_file); i++)\n    {\n      if (gdbm_file->dir[i] != last)\n\t{\n\t  ++count;\n\t  last = gdbm_file->dir[i];\n\t}\n    }\n  return count;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "print_dir_handler": {
      "start_point": [
        794,
        0
      ],
      "end_point": [
        807,
        1
      ],
      "content": "void\nprint_dir_handler (struct handler_param *param)\n{\n  int i;\n  \n  fprintf (param->fp, _(\"Hash table directory.\\n\"));\n  fprintf (param->fp, _(\"  Size =  %d.  Bits = %d,  Buckets = %zu.\\n\\n\"),\n\t   gdbm_file->header->dir_size, gdbm_file->header->dir_bits,\n\t   bucket_count ());\n  \n  for (i = 0; i < GDBM_DIR_COUNT (gdbm_file); i++)\n    fprintf (param->fp, \"  %10d:  %12lu\\n\",\n\t     i, (unsigned long) gdbm_file->dir[i]);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print_header_begin": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        818,
        1
      ],
      "content": "int\nprint_header_begin (struct handler_param *param GDBM_ARG_UNUSED, size_t *exp_count)\n{\n  if (checkdb ())\n    return 1;\n  if (exp_count)\n    *exp_count = 14;\n  return 0;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "print_header_handler": {
      "start_point": [
        820,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "void\nprint_header_handler (struct handler_param *param)\n{\n  FILE *fp = param->fp;\n  \n  fprintf (fp, _(\"\\nFile Header: \\n\\n\"));\n  fprintf (fp, _(\"  table        = %lu\\n\"),\n\t   (unsigned long) gdbm_file->header->dir);\n  fprintf (fp, _(\"  table size   = %d\\n\"), gdbm_file->header->dir_size);\n  fprintf (fp, _(\"  table bits   = %d\\n\"), gdbm_file->header->dir_bits);\n  fprintf (fp, _(\"  block size   = %d\\n\"), gdbm_file->header->block_size);\n  fprintf (fp, _(\"  bucket elems = %d\\n\"), gdbm_file->header->bucket_elems);\n  fprintf (fp, _(\"  bucket size  = %d\\n\"), gdbm_file->header->bucket_size);\n  fprintf (fp, _(\"  header magic = %x\\n\"), gdbm_file->header->header_magic);\n  fprintf (fp, _(\"  next block   = %lu\\n\"),\n\t   (unsigned long) gdbm_file->header->next_block);\n  fprintf (fp, _(\"  avail size   = %d\\n\"), gdbm_file->header->avail.size);\n  fprintf (fp, _(\"  avail count  = %d\\n\"), gdbm_file->header->avail.count);\n  fprintf (fp, _(\"  avail nx blk = %lu\\n\"),\n\t   (unsigned long) gdbm_file->header->avail.next_block);\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "hash_handler": {
      "start_point": [
        843,
        0
      ],
      "end_point": [
        860,
        1
      ],
      "content": "void\nhash_handler (struct handler_param *param)\n{\n  if (gdbm_file)\n    {\n      int hashval, bucket, off;\n      _gdbm_hash_key (gdbm_file, PARAM_DATUM (param, 0),\n\t\t       &hashval, &bucket, &off);\n      fprintf (param->fp, _(\"hash value = %x, bucket #%u, slot %u\"),\n\t\thashval,\n\t\thashval >> (GDBM_HASH_BITS - gdbm_file->header->dir_bits),\n\t\thashval % gdbm_file->header->bucket_elems);\n    }\n  else\n    fprintf (param->fp, _(\"hash value = %x\"),\n\t      _gdbm_hash (PARAM_DATUM (param, 0)));\n  fprintf (param->fp, \".\\n\");\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "print_cache_begin": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        871,
        1
      ],
      "content": "int\nprint_cache_begin (struct handler_param *param GDBM_ARG_UNUSED, size_t *exp_count)\n{\n  if (checkdb ())\n    return 1;\n  if (exp_count)\n    *exp_count = gdbm_file->bucket_cache ? gdbm_file->cache_size + 1 : 1;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "print_cache_handler": {
      "start_point": [
        873,
        0
      ],
      "end_point": [
        877,
        1
      ],
      "content": "void\nprint_cache_handler (struct handler_param *param)\n{\n  _gdbm_print_bucket_cache (param->fp, gdbm_file);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "print_version_handler": {
      "start_point": [
        880,
        0
      ],
      "end_point": [
        884,
        1
      ],
      "content": "void\nprint_version_handler (struct handler_param *param)\n{\n  fprintf (param->fp, \"%s\\n\", gdbm_version);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "list_begin": {
      "start_point": [
        887,
        0
      ],
      "end_point": [
        905,
        1
      ],
      "content": "int\nlist_begin (struct handler_param *param GDBM_ARG_UNUSED, size_t *exp_count)\n{\n  if (checkdb ())\n    return 1;\n  if (exp_count)\n    {\n      gdbm_count_t count;\n\n      if (gdbm_count (gdbm_file, &count))\n\t *exp_count = 0;\n      else if (count > SIZE_T_MAX)\n\t *exp_count = SIZE_T_MAX;\n      else\n\t *exp_count = count;\n    }\n\n  return 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "list_handler": {
      "start_point": [
        907,
        0
      ],
      "end_point": [
        935,
        1
      ],
      "content": "void\nlist_handler (struct handler_param *param)\n{\n  datum key;\n  datum data;\n\n  key = gdbm_firstkey (gdbm_file);\n  while (key.dptr)\n    {\n      datum nextkey = gdbm_nextkey (gdbm_file, key);\n\n      data = gdbm_fetch (gdbm_file, key);\n      if (!data.dptr)\n\t {\n\t   terror (_(\"%s; the key was:\"), gdbm_db_strerror (gdbm_file));\n\t   datum_format (stderr, &key, dsdef[DS_KEY]);\n\t }\n      else\n\t {\n\t   datum_format (param->fp, &key, dsdef[DS_KEY]);\n\t   fputc (' ', param->fp);\n\t   datum_format (param->fp, &data, dsdef[DS_CONTENT]);\n\t   fputc ('\\n', param->fp);\n\t   free (data.dptr);\n\t }\n      free (key.dptr);\n      key = nextkey;\n    }\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "quit_handler": {
      "start_point": [
        938,
        0
      ],
      "end_point": [
        944,
        1
      ],
      "content": "void\nquit_handler (struct handler_param *param GDBM_ARG_UNUSED)\n{\n  closedb ();\n  input_done ();\n  exit (EXIT_OK);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "export_handler": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        977,
        1
      ],
      "content": "void\nexport_handler (struct handler_param *param)\n{\n  int format = GDBM_DUMP_FMT_ASCII;\n  int flags = GDBM_WRCREAT;\n  int i;\n  int filemode;\n\n  for (i = 0; i < param->argc; i++)\n    {\n      if (strcmp (PARAM_STRING (param, i), \"truncate\") == 0)\n\t flags = GDBM_NEWDB;\n      else if (strcmp (PARAM_STRING (param, i), \"binary\") == 0)\n\t format = GDBM_DUMP_FMT_BINARY;\n      else if (strcmp (PARAM_STRING (param, i), \"ascii\") == 0)\n\t format = GDBM_DUMP_FMT_ASCII;\n      else\n\t {\n\t   terror (_(\"unrecognized argument: %s\"), PARAM_STRING (param, i));\n\t   return;\n\t }\n    }\n\n  if (variable_get (\"filemode\", VART_INT, (void**) &filemode))\n    abort ();\n  if (gdbm_dump (gdbm_file, PARAM_STRING (param, 0), format, flags, filemode))\n    {\n      terror (_(\"error dumping database: %s\"),\n\t\t     gdbm_strerror (gdbm_errno));\n    }\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "import_handler": {
      "start_point": [
        980,
        0
      ],
      "end_point": [
        1043,
        1
      ],
      "content": "void\nimport_handler (struct handler_param *param)\n{\n  int flag = GDBM_INSERT;\n  unsigned long err_line;\n  int meta_mask = 0;\n  int i;\n  int rc;\n\n  for (i = 0; i < param->argc; i++)\n    {\n      if (strcmp (PARAM_STRING (param, i), \"replace\") == 0)\n\t flag = GDBM_REPLACE;\n      else if (strcmp (PARAM_STRING (param, i), \"nometa\") == 0)\n\t meta_mask = GDBM_META_MASK_MODE | GDBM_META_MASK_OWNER;\n      else\n\t {\n\t   terror (_(\"unrecognized argument: %s\"),\n\t\t   PARAM_STRING (param, i));\n\t   return;\n\t }\n    }\n\n  rc = gdbm_load (&gdbm_file, PARAM_STRING (param, 0), flag,\n\t\t   meta_mask, &err_line);\n  if (rc && gdbm_errno == GDBM_NO_DBNAME)\n    {\n      int t = open_mode;\n\n      open_mode = GDBM_NEWDB;\n      rc = checkdb ();\n      open_mode = t;\n\n      if (rc)\n\t return;\n\n      rc = gdbm_load (&gdbm_file, PARAM_STRING (param, 0), flag,\n\t\t       meta_mask, &err_line);\n    }\n  if (rc)\n    {\n      switch (gdbm_errno)\n\t {\n\t case GDBM_ERR_FILE_OWNER:\n\t case GDBM_ERR_FILE_MODE:\n\t   terror (_(\"error restoring metadata: %s (%s)\"),\n\t\t\t gdbm_strerror (gdbm_errno), strerror (errno));\n\t   break;\n\n\t default:\n\t   if (err_line)\n\t     terror (\"%s:%lu: %s\", PARAM_STRING (param, 0), err_line,\n\t\t     gdbm_strerror (gdbm_errno));\n\t   else\n\t     terror (_(\"cannot load from %s: %s\"), PARAM_STRING (param, 0),\n\t\t     gdbm_strerror (gdbm_errno));\n\t }\n      return;\n    }\n\n  free (file_name);\n  if (gdbm_setopt (gdbm_file, GDBM_GETDBNAME, &file_name, sizeof (file_name)))\n    terror (_(\"gdbm_setopt failed: %s\"), gdbm_strerror (gdbm_errno));\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "status_handler": {
      "start_point": [
        1046,
        0
      ],
      "end_point": [
        1059,
        1
      ],
      "content": "void\nstatus_handler (struct handler_param *param)\n{\n  if (file_name)\n    fprintf (param->fp, _(\"Database file: %s\\n\"), file_name);\n  else\n    fprintf (param->fp, \"%s\\n\", _(\"No database name\"));\n  if (gdbm_file)\n    fprintf (param->fp, \"%s\\n\", _(\"Database is open\"));\n  else\n    fprintf (param->fp, \"%s\\n\", _(\"Database is not open\"));\n  dsprint (param->fp, DS_KEY, dsdef[DS_KEY]);\n  dsprint (param->fp, DS_CONTENT, dsdef[DS_CONTENT]);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "debug_flag_printer": {
      "start_point": [
        1062,
        0
      ],
      "end_point": [
        1068,
        1
      ],
      "content": "static int\ndebug_flag_printer (void *data, int flag, char const *tok)\n{\n  FILE *fp = data;\n  fprintf (fp, \" %s\", tok);\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "debug_handler": {
      "start_point": [
        1071,
        0
      ],
      "end_point": [
        1130,
        1
      ],
      "content": "void\ndebug_handler (struct handler_param *param)\n{\n#if GDBM_DEBUG_ENABLE\n  if (param->vararg)\n    {\n      struct gdbmarg *arg;\n      int i;\n      \n      for (arg = param->vararg, i = 0; arg; arg = arg->next, i++)\n\t{\n\t  if (arg->type == GDBM_ARG_STRING)\n\t    {\n\t      int flag;\n\t      int negate;\n\t      char const *tok = arg->v.string;\n\t      \n\t      if (tok[0] == '-')\n\t\t{\n\t\t  ++tok;\n\t\t  negate = 1;\n\t\t}\n\t      else if (tok[0] == '+')\n\t\t{\n\t\t  ++tok;\n\t\t  negate = 0;\n\t\t}\n\t      else\n\t\tnegate = 0;\n\t      \n              flag = gdbm_debug_token (tok);\n\t      if (flag)\n\t\t{\n\t\t  if (negate)\n\t\t    gdbm_debug_flags &= ~flag;\n\t\t  else\n\t\t    gdbm_debug_flags |= flag;\n\t\t}\n\t      else\n\t\tterror (_(\"unknown debug flag: %s\"), tok);\n\t    }\n\t  else\n\t    terror (_(\"invalid type of argument %d\"), i);\n\t}\n    }\n  else\n    {\n      fprintf (param->fp, _(\"Debug flags:\"));\n      if (gdbm_debug_flags)\n\t{\n\t  gdbm_debug_parse_state (debug_flag_printer, param->fp);\n\t}\n      else\n\tfprintf (param->fp, \" %s\", _(\"none\"));\n      fputc ('\\n', param->fp);\n    }\n#else\n  terror (\"%s\", _(\"compiled without debug support\"));\n#endif\n}",
      "lines": 60,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "source_handler": {
      "start_point": [
        1132,
        0
      ],
      "end_point": [
        1140,
        1
      ],
      "content": "void\nsource_handler (struct handler_param *param)\n{\n  char *fname = tildexpand (PARAM_STRING (param, 0));\n  instream_t istr = instream_file_create (fname);\n  free (fname);\n  if (istr && input_context_push (istr) == 0)\n    yyparse ();\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "cmdcmp": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1392,
        1
      ],
      "content": "static int\ncmdcmp (const void *a, const void *b)\n{\n  struct command const *ac = a;\n  struct command const *bc = b;\n  return strcmp (ac->name, bc->name);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_commands": {
      "start_point": [
        1394,
        0
      ],
      "end_point": [
        1399,
        1
      ],
      "content": "void\nsort_commands ()\n{\n  qsort (command_tab, sizeof (command_tab) / sizeof (command_tab[0]) - 1,\n\t sizeof (command_tab[0]), cmdcmp);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "command_generator": {
      "start_point": [
        1404,
        0
      ],
      "end_point": [
        1433,
        1
      ],
      "content": "char *\ncommand_generator (const char *text, int state)\n{\n  const char *name;\n  static int len;\n  static struct command *cmd;\n\n  /* If this is a new word to complete, initialize now.  This includes\n     saving the length of TEXT for efficiency, and initializing the index\n     variable to 0. */\n  if (!state)\n    {\n      cmd = command_tab;\n      len = strlen (text);\n    }\n\n  if (!cmd->name)\n    return NULL;\n\n  /* Return the next name which partially matches from the command list. */\n  while ((name = cmd->name))\n    {\n      cmd++;\n      if (strncmp (name, text, len) == 0)\n        return strdup (name);\n    }\n\n  /* If no names matched, then return NULL. */\n  return NULL;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "char",
        "*\ncommand_generator (const char *text, int state)",
        "*"
      ]
    },
    "help_begin": {
      "start_point": [
        1438,
        0
      ],
      "end_point": [
        1444,
        1
      ],
      "content": "int\nhelp_begin (struct handler_param *param GDBM_ARG_UNUSED, size_t *exp_count)\n{\n  if (exp_count)\n    *exp_count = sizeof (command_tab) / sizeof (command_tab[0]) + 1;\n  return 0;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "help_handler": {
      "start_point": [
        1446,
        0
      ],
      "end_point": [
        1467,
        1
      ],
      "content": "void\nhelp_handler (struct handler_param *param)\n{\n  struct command *cmd;\n  FILE *fp = param->fp;\n  \n  for (cmd = command_tab; cmd->name; cmd++)\n    {\n      int i;\n      int n;\n\n      n = fprintf (fp, \" %s\", cmd->name);\n\n      for (i = 0; i < NARGS && cmd->args[i].name; i++)\n\tn += fprintf (fp, \" %s\", gettext (cmd->args[i].name));\n\n      if (n < CMDCOLS)\n\tfprintf (fp, \"%*.s\", CMDCOLS-n, \"\");\n      fprintf (fp, \" %s\", gettext (cmd->doc));\n      fputc ('\\n', fp);\n    }\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "command_lookup": {
      "start_point": [
        1469,
        0
      ],
      "end_point": [
        1518,
        1
      ],
      "content": "int\ncommand_lookup (const char *str, struct locus *loc, struct command **pcmd)\n{\n  enum { fcom_init, fcom_found, fcom_ambig, fcom_abort } state = fcom_init;\n  struct command *cmd, *found = NULL;\n  size_t len = strlen (str);\n  \n  for (cmd = command_tab; state != fcom_abort && cmd->name; cmd++)\n    {\n      if (memcmp (cmd->name, str, len < cmd->len ? len : cmd->len) == 0)\n\t{\n\t  switch (state)\n\t    {\n\t    case fcom_init:\n\t      found = cmd;\n\t      state = fcom_found;\n\t      break;\n\n\t    case fcom_found:\n\t      if (!interactive ())\n\t\t{\n\t\t  state = fcom_abort;\n\t\t  found = NULL;\n\t\t  continue;\n\t\t}\n\t      fprintf (stderr, \"ambiguous command: %s\\n\", str);\n\t      fprintf (stderr, \"    %s\\n\", found->name);\n\t      found = NULL;\n\t      state = fcom_ambig;\n\t      /* fall through */\n\t    case fcom_ambig:\n\t      fprintf (stderr, \"    %s\\n\", cmd->name);\n\t      break;\n\t      \n\t    case fcom_abort:\n\t      /* should not happen */\n\t      abort ();\n\t    }\n\t}\n    }\n\n  if (state == fcom_init)\n    lerror (loc, interactive () ? _(\"Invalid command. Try ? for help.\") :\n\t                          _(\"Unknown command\"));\n  if (!found)\n    return T_BOGUS;\n\n  *pcmd = found;\n  return found->tok;\n}",
      "lines": 50,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "gdbmarg_string": {
      "start_point": [
        1550,
        0
      ],
      "end_point": [
        1561,
        1
      ],
      "content": "struct gdbmarg *\ngdbmarg_string (char *string, struct locus *loc)\n{\n  struct gdbmarg *arg = ecalloc (1, sizeof (*arg));\n  arg->next = NULL;\n  arg->type = GDBM_ARG_STRING;\n  arg->ref = 1;\n  if (loc)\n    arg->loc = *loc;\n  arg->v.string = string;\n  return arg;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "struct gdbmarg",
        "struct",
        "gdbmarg",
        "*\ngdbmarg_string (char *string, struct locus *loc)",
        "*"
      ]
    },
    "gdbmarg_datum": {
      "start_point": [
        1563,
        0
      ],
      "end_point": [
        1574,
        1
      ],
      "content": "struct gdbmarg *\ngdbmarg_datum (datum *dat, struct locus *loc)\n{\n  struct gdbmarg *arg = ecalloc (1, sizeof (*arg));\n  arg->next = NULL;\n  arg->type = GDBM_ARG_DATUM;\n  arg->ref = 1;\n  if (loc)\n    arg->loc = *loc;\n  arg->v.dat = *dat;\n  return arg;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "struct gdbmarg",
        "struct",
        "gdbmarg",
        "*\ngdbmarg_datum (datum *dat, struct locus *loc)",
        "*"
      ]
    },
    "gdbmarg_kvpair": {
      "start_point": [
        1576,
        0
      ],
      "end_point": [
        1587,
        1
      ],
      "content": "struct gdbmarg *\ngdbmarg_kvpair (struct kvpair *kvp, struct locus *loc)\n{\n  struct gdbmarg *arg = ecalloc (1, sizeof (*arg));\n  arg->next = NULL;\n  arg->type = GDBM_ARG_KVPAIR;\n  arg->ref = 1;\n  if (loc)\n    arg->loc = *loc;\n  arg->v.kvpair = kvp;\n  return arg;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "struct gdbmarg",
        "struct",
        "gdbmarg",
        "*\ngdbmarg_kvpair (struct kvpair *kvp, struct locus *loc)",
        "*"
      ]
    },
    "slist_new_s": {
      "start_point": [
        1589,
        0
      ],
      "end_point": [
        1596,
        1
      ],
      "content": "struct slist *\nslist_new_s (char *s)\n{\n  struct slist *lp = emalloc (sizeof (*lp));\n  lp->next = NULL;\n  lp->str = s;\n  return lp;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "struct slist",
        "struct",
        "slist",
        "*\nslist_new_s (char *s)",
        "*"
      ]
    },
    "slist_new": {
      "start_point": [
        1598,
        0
      ],
      "end_point": [
        1602,
        1
      ],
      "content": "struct slist *\nslist_new (char const *s)\n{\n  return slist_new_s (estrdup (s));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct slist",
        "struct",
        "slist",
        "*\nslist_new (char const *s)",
        "*"
      ]
    },
    "slist_new_l": {
      "start_point": [
        1604,
        0
      ],
      "end_point": [
        1611,
        1
      ],
      "content": "struct slist *\nslist_new_l (char const *s, size_t l)\n{\n  char *copy = emalloc (l + 1);\n  memcpy (copy, s, l);\n  copy[l] = 0;\n  return slist_new_s (copy);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "struct slist",
        "struct",
        "slist",
        "*\nslist_new_l (char const *s, size_t l)",
        "*"
      ]
    },
    "slist_free": {
      "start_point": [
        1613,
        0
      ],
      "end_point": [
        1623,
        1
      ],
      "content": "void\nslist_free (struct slist *lp)\n{\n  while (lp)\n    {\n      struct slist *next = lp->next;\n      free (lp->str);\n      free (lp);\n      lp = next;\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "slist_insert": {
      "start_point": [
        1625,
        0
      ],
      "end_point": [
        1638,
        1
      ],
      "content": "void\nslist_insert (struct slist **where, struct slist *what)\n{\n  if (*where)\n    {\n      while (what->next)\n\twhat = what->next;\n      what->next = (*where)->next;\n      (*where)->next = what;\n    }\n  else\n    what->next = NULL;\n  *where = what;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "kvpair_string": {
      "start_point": [
        1640,
        0
      ],
      "end_point": [
        1649,
        1
      ],
      "content": "struct kvpair *\nkvpair_string (struct locus *loc, char *val)\n{\n  struct kvpair *p = ecalloc (1, sizeof (*p));\n  p->type = KV_STRING;\n  if (loc)\n    p->loc = *loc;\n  p->val.s = val;\n  return p;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "struct kvpair",
        "struct",
        "kvpair",
        "*\nkvpair_string (struct locus *loc, char *val)",
        "*"
      ]
    },
    "kvpair_list": {
      "start_point": [
        1651,
        0
      ],
      "end_point": [
        1660,
        1
      ],
      "content": "struct kvpair *\nkvpair_list (struct locus *loc, struct slist *s)\n{\n  struct kvpair *p = ecalloc (1, sizeof (*p));\n  p->type = KV_LIST;\n  if (loc)\n    p->loc = *loc;\n  p->val.l = s;\n  return p;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "struct kvpair",
        "struct",
        "kvpair",
        "*\nkvpair_list (struct locus *loc, struct slist *s)",
        "*"
      ]
    },
    "kvlist_free": {
      "start_point": [
        1662,
        0
      ],
      "end_point": [
        1682,
        1
      ],
      "content": "static void\nkvlist_free (struct kvpair *kvp)\n{\n  while (kvp)\n    {\n      struct kvpair *next = kvp->next;\n      free (kvp->key);\n      switch (kvp->type)\n\t{\n\tcase KV_STRING:\n\t  free (kvp->val.s);\n\t  break;\n\n\tcase KV_LIST:\n\t  slist_free (kvp->val.l);\n\t  break;\n\t}\n      free (kvp);\n      kvp = next;\n    }\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gdbmarg_free": {
      "start_point": [
        1684,
        0
      ],
      "end_point": [
        1707,
        1
      ],
      "content": "int\ngdbmarg_free (struct gdbmarg *arg)\n{\n  if (arg && --arg->ref == 0)\n    {\n      switch (arg->type)\n\t{\n\tcase GDBM_ARG_STRING:\n\t  free (arg->v.string);\n\t  break;\n\n\tcase GDBM_ARG_KVPAIR:\n\t  kvlist_free (arg->v.kvpair);\n\t  break;\n\n\tcase GDBM_ARG_DATUM:\n\t  free (arg->v.dat.dptr);\n\t  break;\n\t}\n      free (arg);\n      return 0;\n    }\n  return 1;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "gdbmarg_destroy": {
      "start_point": [
        1709,
        0
      ],
      "end_point": [
        1714,
        1
      ],
      "content": "void\ngdbmarg_destroy (struct gdbmarg **parg)\n{\n  if (parg && gdbmarg_free (*parg))\n    *parg = NULL;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gdbmarglist_init": {
      "start_point": [
        1716,
        0
      ],
      "end_point": [
        1722,
        1
      ],
      "content": "void\ngdbmarglist_init (struct gdbmarglist *lst, struct gdbmarg *arg)\n{\n  if (arg)\n    arg->next = NULL;\n  lst->head = lst->tail = arg;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "gdbmarglist_add": {
      "start_point": [
        1724,
        0
      ],
      "end_point": [
        1733,
        1
      ],
      "content": "void\ngdbmarglist_add (struct gdbmarglist *lst, struct gdbmarg *arg)\n{\n  arg->next = NULL;\n  if (lst->tail)\n    lst->tail->next = arg;\n  else\n    lst->head = arg;\n  lst->tail = arg;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "gdbmarglist_free": {
      "start_point": [
        1735,
        0
      ],
      "end_point": [
        1747,
        1
      ],
      "content": "void\ngdbmarglist_free (struct gdbmarglist *lst)\n{\n  struct gdbmarg *arg;\n\n  for (arg = lst->head; arg; )\n    {\n      struct gdbmarg *next = arg->next;\n      gdbmarg_free (arg);\n      arg = next;\n    }\n  lst->head = lst->tail = NULL;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "param_free_argv": {
      "start_point": [
        1752,
        0
      ],
      "end_point": [
        1760,
        1
      ],
      "content": "void\nparam_free_argv (struct handler_param *param, int n)\n{\n  int i;\n\n  for (i = 0; i < n; i++)\n    gdbmarg_destroy (&param->argv[i]);\n  param->argc = 0;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "coerce_ref": {
      "start_point": [
        1765,
        0
      ],
      "end_point": [
        1770,
        1
      ],
      "content": "struct gdbmarg *\ncoerce_ref (struct gdbmarg *arg, struct argdef *def)\n{\n  ++arg->ref;\n  return arg;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "struct gdbmarg",
        "struct",
        "gdbmarg",
        "*\ncoerce_ref (struct gdbmarg *arg, struct argdef *def)",
        "*"
      ]
    },
    "coerce_k2d": {
      "start_point": [
        1772,
        0
      ],
      "end_point": [
        1780,
        1
      ],
      "content": "struct gdbmarg *\ncoerce_k2d (struct gdbmarg *arg, struct argdef *def)\n{\n  datum d;\n  \n  if (datum_scan (&d, dsdef[def->ds], arg->v.kvpair))\n    return NULL;\n  return gdbmarg_datum (&d, &arg->loc);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct gdbmarg",
        "struct",
        "gdbmarg",
        "*\ncoerce_k2d (struct gdbmarg *arg, struct argdef *def)",
        "*"
      ]
    },
    "coerce_s2d": {
      "start_point": [
        1782,
        0
      ],
      "end_point": [
        1795,
        1
      ],
      "content": "struct gdbmarg *\ncoerce_s2d (struct gdbmarg *arg, struct argdef *def)\n{\n  datum d;\n  struct kvpair kvp;\n\n  memset (&kvp, 0, sizeof (kvp));\n  kvp.type = KV_STRING;\n  kvp.val.s = arg->v.string;\n  \n  if (datum_scan (&d, dsdef[def->ds], &kvp))\n    return NULL;\n  return gdbmarg_datum (&d, &arg->loc);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "struct gdbmarg",
        "struct",
        "gdbmarg",
        "*\ncoerce_s2d (struct gdbmarg *arg, struct argdef *def)",
        "*"
      ]
    },
    "coerce": {
      "start_point": [
        1808,
        0
      ],
      "end_point": [
        1818,
        1
      ],
      "content": "struct gdbmarg *\ncoerce (struct gdbmarg *arg, struct argdef *def)\n{\n  if (!coerce_tab[def->type][arg->type])\n    {\n      lerror (&arg->loc, _(\"cannot coerce %s to %s\"),\n\t\t    argtypestr[arg->type], argtypestr[def->type]);\n      return NULL;\n    }\n  return coerce_tab[def->type][arg->type] (arg, def);\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "struct gdbmarg",
        "struct",
        "gdbmarg",
        "*\ncoerce (struct gdbmarg *arg, struct argdef *def)",
        "*"
      ]
    },
    "run_last_command": {
      "start_point": [
        1823,
        0
      ],
      "end_point": [
        1846,
        1
      ],
      "content": "void\nrun_last_command (void)\n{\n  if (interactive ())\n    {\n      if (last_cmd)\n\t{\n\t  switch (last_cmd->repeat)\n\t    {\n\t    case REPEAT_NEVER:\n\t      break;\n\t    case REPEAT_NOARG:\n\t      gdbmarglist_free (&last_args);\n\t      /* FALLTHROUGH */\n\t    case REPEAT_ALWAYS:\n\t      if (run_command (last_cmd, &last_args))\n\t\texit (EXIT_USAGE);\n\t      break;\n\t    default:\n\t      abort ();\n\t    }\n\t}\n    }\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "run_command": {
      "start_point": [
        1848,
        0
      ],
      "end_point": [
        1975,
        1
      ],
      "content": "int\nrun_command (struct command *cmd, struct gdbmarglist *arglist)\n{\n  int i;\n  struct gdbmarg *arg;\n  char *pager = NULL;\n  char argbuf[128];\n  size_t expected_lines, *expected_lines_ptr;\n  FILE *pagfp = NULL;\n\n  variable_get (\"pager\", VART_STRING, (void**) &pager);\n  \n  arg = arglist ? arglist->head : NULL;\n\n  for (i = 0; cmd->args[i].name && arg; i++, arg = arg->next)\n    {\n      if (i >= argmax)\n\t{\n\t  argmax += ARGINC;\n\t  param.argv = erealloc (param.argv,\n\t\t\t\t sizeof (param.argv[0]) * argmax);\n\t}\n      if ((param.argv[i] = coerce (arg, &cmd->args[i])) == NULL)\n\t{\n\t  param_free_argv (&param, i);\n\t  return 1;\n\t}\n    }\n\n  for (; cmd->args[i].name; i++)\n    {\n      char *argname = cmd->args[i].name;\n      struct gdbmarg *t;\n      \n      if (*argname == '[')\n\t/* Optional argument */\n\tbreak;\n\n      if (!interactive ())\n\t{\n\t  terror (_(\"%s: not enough arguments\"), cmd->name);\n\t  return 1;\n\t}\n      printf (\"%s? \", argname);\n      fflush (stdout);\n      if (fgets (argbuf, sizeof argbuf, stdin) == NULL)\n\t{\n\t  terror (_(\"unexpected eof\"));\n\t  exit (EXIT_USAGE);\n\t}\n\n      trimnl (argbuf);\n      if (i >= argmax)\n\t{\n\t  argmax += ARGINC;\n\t  param.argv = erealloc (param.argv,\n\t\t\t\t sizeof (param.argv[0]) * argmax);\n\t}\n\n      t = gdbmarg_string (estrdup (argbuf), &yylloc);\n      if ((param.argv[i] = coerce (t, &cmd->args[i])) == NULL)\n\t{\n\t  gdbmarg_free (t);\n\t  param_free_argv (&param, i);\n\t  return 1;\n\t}\n    }\n\n  if (arg && !cmd->variadic)\n    {\n      terror (_(\"%s: too many arguments\"), cmd->name);\n      return 1;\n    }\n\n  /* Prepare for calling the handler */\n  param.argc = i;\n  if (!param.argv)\n    {\n      argmax = ARGINC;\n      param.argv = ecalloc (argmax, sizeof (param.argv[0]));\n    }\n  param.argv[i] = NULL;\n  param.vararg = arg;\n  param.fp = NULL;\n  param.data = NULL;\n  pagfp = NULL;\n      \n  expected_lines = 0;\n  expected_lines_ptr = (interactive () && pager) ? &expected_lines : NULL;\n  if (!(cmd->begin && cmd->begin (&param, expected_lines_ptr)))\n    {\n      if (pager && expected_lines > get_screen_lines ())\n\t{\n\t  pagfp = popen (pager, \"w\");\n\t  if (pagfp)\n\t    param.fp = pagfp;\n\t  else\n\t    {\n\t      terror (_(\"cannot run pager `%s': %s\"), pager,\n\t\t\t    strerror (errno));\n\t      pager = NULL;\n\t      param.fp = stdout;\n\t    }\t  \n\t}\n      else\n\tparam.fp = stdout;\n  \n      cmd->handler (&param);\n      if (cmd->end)\n\tcmd->end (param.data);\n      else if (param.data)\n\tfree (param.data);\n\n      if (pagfp)\n\tpclose (pagfp);\n    }\n\n  param_free_argv (&param, param.argc);\n\n  last_cmd = cmd;\n  if (arglist->head != last_args.head)\n    {\n      gdbmarglist_free (&last_args);\n      last_args = *arglist;\n    }\n  \n  return 0;\n}",
      "lines": 128,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "source_rcfile": {
      "start_point": [
        1977,
        0
      ],
      "end_point": [
        2014,
        1
      ],
      "content": "static void\nsource_rcfile (void)\n{\n  instream_t istr = NULL;\n  \n  if (access (GDBMTOOLRC, R_OK) == 0)\n    {\n      istr = instream_file_create (GDBMTOOLRC);\n    }\n  else\n    {\n      char *fname;\n      char *p = getenv (\"HOME\");\n      if (!p)\n\t{\n\t  struct passwd *pw = getpwuid (getuid ());\n\t  if (!pw)\n\t    {\n\t      terror (_(\"cannot find home directory\"));\n\t      return;\n\t    }\n\t  p = pw->pw_dir;\n\t}\n      fname = mkfilename (p, GDBMTOOLRC, NULL);\n      if (access (fname, R_OK) == 0)\n\t{\n\t  istr = instream_file_create (GDBMTOOLRC);\n\t}\n      free (fname);\n    }\n\n  if (istr)\n    {\n      if (input_context_push (istr))\n\texit (EXIT_FATAL);\n      yyparse ();\n    }\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "debug_printer": {
      "start_point": [
        2017,
        0
      ],
      "end_point": [
        2025,
        1
      ],
      "content": "void\ndebug_printer (char const *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        2028,
        0
      ],
      "end_point": [
        2177,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int opt;\n  int bv;\n  int norc = 0;\n  int res;\n  char *source = NULL;\n  instream_t input = NULL;\n  \n  set_progname (argv[0]);\n#if GDBM_DEBUG_ENABLE\n  gdbm_debug_printer = debug_printer;\n#endif\n\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  sort_commands ();\n  \n  /* Initialize variables. */\n  dsdef[DS_KEY] = dsegm_new_field (datadef_lookup (\"string\"), NULL, 1);\n  dsdef[DS_CONTENT] = dsegm_new_field (datadef_lookup (\"string\"), NULL, 1);\n\n  variable_set (\"open\", VART_STRING, \"wrcreat\");\n  variable_set (\"pager\", VART_STRING, getenv (\"PAGER\"));\n  \n  input_init ();\n  lex_trace (0);\n  \n  for (opt = parseopt_first (argc, argv, optab);\n       opt != EOF;\n       opt = parseopt_next ())\n    switch (opt)\n      {\n      case 'f':\n\tsource = optarg;\n\tbreak;\n\t\n      case 'l':\n\tbv = 0;\n\tvariable_set (\"lock\", VART_BOOL, &bv);\n\tbreak;\n\n      case 'm':\n\tbv = 0;\n\tvariable_set (\"mmap\", VART_BOOL, &bv);\n\tbreak;\n\n      case 's':\n\tbv = 1;\n\tvariable_set (\"sync\", VART_BOOL, &bv);\n\tbreak;\n\t\n      case 'r':\n\tvariable_set (\"open\", VART_STRING, \"readonly\");\n\tbreak;\n\t\n      case 'n':\n\tvariable_set (\"open\", VART_STRING, \"newdb\");\n\tbreak;\n\n      case 'N':\n\tnorc = 1;\n\tbreak;\n\t\n      case 'c':\n\tvariable_set (\"cachesize\", VART_STRING, optarg);\n\tbreak;\n\t\n      case 'b':\n\tvariable_set (\"blocksize\", VART_STRING, optarg);\n\tbreak;\n\t\n      case 'g':\n\tfile_name = estrdup (optarg);\n\tbreak;\n\n      case 'q':\n\tbv = 1;\n\tvariable_set (\"quiet\", VART_BOOL, &bv);\n\tbreak;\n\n      case OPT_LEX_TRACE:\n\tlex_trace (1);\n\tbreak;\n\n      case OPT_GRAM_TRACE:\n\tgram_trace (1);\n\tbreak;\n\t\n      default:\n\tterror (_(\"unknown option; try `%s -h' for more info\"),\n\t\tprogname);\n\texit (EXIT_USAGE);\n      }\n  \n  argc -= optind;\n  argv += optind;\n\n  if (source && strcmp (source, \"-\"))\n    {\n      input = instream_file_create (source);\n      if (!input)\n\texit (1);\n    }\n  \n  if (argc >= 1)\n    {\n      file_name = estrdup (argv[0]);\n      argc--;\n      argv++;\n      if (argc)\n\t{\n\t  if (input)\n\t    {\n\t      terror (_(\"--file and and command cannot be used together\"));\n\t      exit (EXIT_USAGE);\n\t    }\n\t  input = instream_argv_create (argc, argv);\n\t  if (!input)\n\t    exit (1);\n\t}\n    }\n\n  signal (SIGPIPE, SIG_IGN);\n\n  memset (&param, 0, sizeof (param));\n  argmax = 0;\n\n  if (!norc)\n    source_rcfile ();\n\n  if (!input)\n    input = instream_stdin_create ();\n  \n  /* Welcome message. */\n  if (instream_interactive (input) && !variable_is_true (\"quiet\"))\n    printf (_(\"\\nWelcome to the gdbm tool.  Type ? for help.\\n\\n\"));\n\n  if (input_context_push (input))\n    exit (EXIT_FATAL);\n  res = yyparse ();\n  closedb ();\n  input_done ();\n  return res;\n}",
      "lines": 150,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbmtool.h": {
    "instream_name": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline char const *\ninstream_name (instream_t in)\n{\n  return in->in_name;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "const",
        "const",
        "*\ninstream_name (instream_t in)",
        "*"
      ]
    },
    "instream_read": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static inline ssize_t\ninstream_read (instream_t in, char *buf, size_t size)\n{\n  return in->in_read (in, buf, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "ssize_t"
      ]
    },
    "instream_close": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static inline void\ninstream_close (instream_t in)\n{\n  in->in_close (in);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "instream_interactive": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static inline int\ninstream_interactive (instream_t in)\n{\n  return in->in_inter;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "instream_eq": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static inline int\ninstream_eq (instream_t a, instream_t b)\n{\n  return a->in_eq (a, b);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbm_dump.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  GDBM_FILE dbf;\n  int rc, opt;\n  char *dbname, *filename;\n  FILE *fp;\n\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  set_progname (argv[0]);\n\n  for (opt = parseopt_first (argc, argv, optab);\n       opt != EOF;\n       opt = parseopt_next ())\n    {\n    switch (opt)\n      {\n      case 'H':\n\tif (strcmp (optarg, \"binary\") == 0)\n\t  format = GDBM_DUMP_FMT_BINARY;\n\telse if (strcmp (optarg, \"ascii\") == 0)\n\t  format = GDBM_DUMP_FMT_ASCII;\n\telse\n\t  {\n\t    format = atoi (optarg);\n\t    switch (format)\n\t      {\n\t      case GDBM_DUMP_FMT_BINARY:\n\t      case GDBM_DUMP_FMT_ASCII:\n\t\tbreak;\n\t      default:\n\t\terror (_(\"unknown dump format\"));\n\t\texit (EXIT_USAGE);\n\t      }\n\t  }\n\tbreak;\n\t\n      default:\n\terror (_(\"unknown option\"));\n\texit (EXIT_USAGE);\n      }\n    }\n\n  argc -= optind;\n  argv += optind;\n\n  if (argc == 0)\n    {\n      parseopt_print_help ();\n      exit (EXIT_OK);\n    }\n\n  if (argc > 2)\n    {\n      error (_(\"too many arguments; try `%s -h' for more info\"), progname);\n      exit (EXIT_USAGE);\n    }\n  \n  dbname = argv[0];\n  if (argc == 2)\n    filename = argv[1];\n  else\n    filename = NULL;\n\n  if (!filename || strcmp (filename, \"-\") == 0)\n    {\n      filename = \"<stdout>\";\n      fp = stdout;\n    }\n  else\n    {\n      fp = fopen (filename, \"w\");\n      if (!fp)\n\t{\n\t  sys_perror (errno, _(\"cannot open %s\"), filename);\n\t  exit (EXIT_FATAL);\n\t}\n    }\n\n  dbf = gdbm_open (dbname, 0, GDBM_READER, 0600, NULL);\n  if (!dbf)\n    {\n      gdbm_perror (_(\"gdbm_open failed\"));\n      exit (EXIT_FATAL);\n    }\n\n  rc = gdbm_dump_to_file (dbf, fp, format);\n  if (rc)\n    {\n      gdbm_perror (_(\"dump error\"), filename);\n    }\n  \n  gdbm_close (dbf);\n\n  exit (rc == GDBM_NO_ERROR ? EXIT_OK : EXIT_FATAL);\n}",
      "lines": 101,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gdbm_load.c": {
    "set_meta_info": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nset_meta_info (GDBM_FILE dbf)\n{\n  if (meta_mask)\n    {\n      int fd = gdbm_fdesc (dbf);\n\n      if (meta_mask & GDBM_META_MASK_OWNER)\n\t{\n\t  if (fchown (fd, owner_uid, owner_gid))\n\t    {\n\t      GDBM_SET_ERRNO (dbf, GDBM_ERR_FILE_OWNER, FALSE);\n\t      return 1;\n\t    }\n\t}\n      if ((meta_mask & GDBM_META_MASK_MODE) && fchmod (fd, mode))\n\t{\n\t  GDBM_SET_ERRNO (dbf, GDBM_ERR_FILE_OWNER, FALSE);\n\t  return 1;\n\t}\n    }\n  return 0;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_int": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\nget_int (const char *arg)\n{\n  char *p;\n  long n;\n \n  errno = 0;\n  n = strtol (arg, &p, 0);\n  if (*p)\n    {\n      error (_(\"invalid number: %s\"), arg);\n      exit (EXIT_USAGE);\n    }\n  if (errno)\n    {\n      error (_(\"invalid number: %s: %s\"), arg, strerror (errno));\n      exit (EXIT_USAGE);\n    }\n  return n;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  GDBM_FILE dbf = NULL;\n  int rc, opt;\n  char *dbname, *filename;\n  FILE *fp;\n  unsigned long err_line, n;\n  char *end;\n  int oflags = GDBM_NEWDB|GDBM_NOMMAP;\n  int cache_size = 0;\n  int block_size = 0;\n  \n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  set_progname (argv[0]);\n\n  for (opt = parseopt_first (argc, argv, optab);\n       opt != EOF;\n       opt = parseopt_next ())\n    {\n    switch (opt)\n      {\n      case 'b':\n\tblock_size = get_int (optarg);\n\tbreak;\n\t\n      case 'c':\n\tcache_size = get_int (optarg);\n\tbreak;\n\n      case 'm':\n\t{\n\t  errno = 0;\n\t  n = strtoul (optarg, &end, 8);\n\t  if (*end == 0 && errno == 0)\n\t    {\n\t      mode = n & 0777;\n\t      meta_mask |= GDBM_META_MASK_MODE;\n\t    }\n\t  else\n\t    {\n\t      error (\"%s\", _(\"invalid octal number\"));\n\t      exit (EXIT_USAGE);\n\t    }\n\t}\n\tbreak;\n\n      case 'u':\n\t{\n\t  size_t len;\n\t  struct passwd *pw;\n\t  \n\t  len = strcspn (optarg, \".:\");\n\t  if (optarg[len])\n\t    optarg[len++] = 0;\n\t  pw = getpwnam (optarg);\n\t  if (pw)\n\t    owner_uid = pw->pw_uid;\n\t  else\n\t    {\n\t      errno = 0;\n\t      n = strtoul (optarg, &end, 10);\n\t      if (*end == 0 && errno == 0)\n\t\towner_uid = n;\n\t      else\n\t\t{\n\t\t  error (_(\"invalid user name: %s\"), optarg);\n\t\t  exit (EXIT_USAGE);\n\t\t}\n\t    }\n\t  \n\t  if (optarg[len])\n\t    {\n\t      char *grname = optarg + len;\n\t      struct group *gr = getgrnam (grname);\n\t      if (gr)\n\t\towner_gid = gr->gr_gid;\n\t      else\n\t\t{\n\t\t  errno = 0;\n\t\t  n = strtoul (grname, &end, 10);\n\t\t  if (*end == 0 && errno == 0)\n\t\t    owner_gid = n;\n\t\t  else\n\t\t    {\n\t\t      error (_(\"invalid group name: %s\"), grname);\n\t\t      exit (EXIT_USAGE);\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if (!pw)\n\t\t{\n\t\t  pw = getpwuid (owner_uid);\n\t\t  if (!pw)\n\t\t    {\n\t\t      error (_(\"no such UID: %lu\"), (unsigned long)owner_uid);\n\t\t      exit (EXIT_USAGE);\n\t\t    }\n\t\t}\n\t      owner_gid = pw->pw_gid;\n\t    }\n\t  meta_mask |= GDBM_META_MASK_OWNER;\n\t}\n\tbreak;\n\t  \n      case 'r':\n\treplace = 1;\n\tbreak;\n\n      case 'n':\n\tno_meta_option = 1;\n\tbreak;\n\n      case 'M':\n\toflags &= ~GDBM_NOMMAP;\n\tbreak;\n\t\n      default:\n\terror (_(\"unknown option\"));\n\texit (EXIT_USAGE);\n      }\n    }\n\n  argc -= optind;\n  argv += optind;\n  \n  if (argc == 0)\n    {\n      parseopt_print_help ();\n      exit (EXIT_OK);\n    }\n\n  if (argc > 2)\n    {\n      error (_(\"too many arguments; try `%s -h' for more info\"), progname);\n      exit (EXIT_USAGE);\n    }\n  \n  filename = argv[0];\n  if (argc == 2)\n    dbname = argv[1];\n  else\n    dbname = NULL;\n\n  if (strcmp (filename, \"-\") == 0)\n    {\n      filename = \"<stdin>\";\n      fp = stdin;\n    }\n  else\n    {\n      fp = fopen (filename, \"r\");\n      if (!fp)\n\t{\n\t  sys_perror (errno, _(\"cannot open %s\"), filename);\n\t  exit (EXIT_FATAL);\n\t}\n    }\n  \n  if (dbname)\n    {\n      dbf = gdbm_open (dbname, block_size, oflags, 0600, NULL);\n      if (!dbf)\n\t{\n\t  gdbm_perror (_(\"gdbm_open failed\"));\n\t  exit (EXIT_FATAL);\n\t}\n\n      if (cache_size &&\n\t  gdbm_setopt (dbf, GDBM_SETCACHESIZE, &cache_size, sizeof (int)) == -1)\n\terror (_(\"gdbm_setopt failed: %s\"), gdbm_strerror (gdbm_errno));\n    }\n  \n  rc = gdbm_load_from_file (&dbf, fp, replace,\n\t\t\t    no_meta_option ?\n\t\t\t      (GDBM_META_MASK_MODE | GDBM_META_MASK_OWNER) :\n\t\t\t      meta_mask,\n\t\t\t    &err_line);\n  if (rc)\n    {\n      switch (gdbm_errno)\n\t{\n\tcase GDBM_ERR_FILE_OWNER:\n\tcase GDBM_ERR_FILE_MODE:\n\t  error (_(\"error restoring metadata: %s (%s)\"),\n\t\t gdbm_strerror (gdbm_errno), strerror (errno));\n\t  rc = EXIT_MILD;\n\t  break;\n\t  \n\tdefault:\n\t  if (err_line)\n\t    gdbm_perror (\"%s:%lu\", filename, err_line);\n\t  else\n\t    gdbm_perror (_(\"cannot load from %s\"), filename);\n\t  rc = EXIT_FATAL;\n\t}\n    }\n\n  if (dbf)\n    {\n      if (!no_meta_option && set_meta_info (dbf))\n\t{\n\t  error (_(\"error restoring metadata: %s (%s)\"),\n\t\t gdbm_strerror (gdbm_errno), strerror (errno));\n\t  rc = EXIT_MILD;\n\t}\n      \n      if (!dbname)\n\t{\n\t  if (gdbm_setopt (dbf, GDBM_GETDBNAME, &dbname, sizeof (dbname)))\n\t    gdbm_perror (_(\"gdbm_setopt failed\"));\n\t  else\n\t    {\n\t      printf (\"%s: created %s\\n\", progname, dbname);\n\t      free (dbname);\n\t    }\n\t}\n      gdbm_close (dbf);\n    }\n  exit (rc);\n}",
      "lines": 228,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (translation != msg_ctxt_id)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (!(translation == msg_ctxt_id || translation == msgid_plural))\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gram.c": {
    "yytnamerr": {
      "start_point": [
        1061,
        0
      ],
      "end_point": [
        1098,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1109,
        0
      ],
      "end_point": [
        1238,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULL, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULL;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULL, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 130,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "terror": {
      "start_point": [
        2182,
        0
      ],
      "end_point": [
        2190,
        1
      ],
      "content": "void\nterror (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vlerror (&yylloc, fmt, ap);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "yyerror": {
      "start_point": [
        2192,
        0
      ],
      "end_point": [
        2197,
        1
      ],
      "content": "int\nyyerror (char const *s)\n{\n  terror (\"%s\", s);\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gram_trace": {
      "start_point": [
        2199,
        0
      ],
      "end_point": [
        2205,
        1
      ],
      "content": "void\ngram_trace (int n)\n{\n#if GDBMTOOL_DEBUG  \n  yydebug = 1;\n#endif\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/gram.h": {},
  "gdbm/gdbm-1.15/src/gram.y": {
    "input": [
      {
        "start_point": [
          77,
          12
        ],
        "end_point": [
          81,
          6
        ],
        "content": "T_CMD arglist eol\n            {\n\t      if (run_command ($1, &$2) && !interactive ())\n\t\texit (EXIT_USAGE);\n\t    }",
        "lines": 5,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          82,
          12
        ],
        "end_point": [
          93,
          6
        ],
        "content": "set eol\n          | defn eol\n\t  | T_BOGUS eol\n\t    {\n\t      if (interactive ())\n\t\t{\n\t\t  yyclearin;\n\t\t  yyerrok;\n\t\t}\n\t      else\n\t\tYYERROR;\n\t    }",
        "lines": 12,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          121,
          12
        ],
        "end_point": [
          125,
          6
        ],
        "content": "arg1list arg\n\t    {\n\t      gdbmarglist_add (&$1, $2);\n\t      $$ = $1;\n\t    }",
        "lines": 5,
        "depth": 8,
        "decorators": null
      }
    ],
    "T_IDENT": [
      {
        "start_point": [
          247,
          12
        ],
        "end_point": [
          251,
          6
        ],
        "content": "T_OFF T_NUM\n\t    {\n\t      $$ = dsegm_new (FDEF_OFF);\n\t      $$->v.n = $2;\n\t    }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          252,
          12
        ],
        "end_point": [
          256,
          6
        ],
        "content": "T_PAD T_NUM\n\t    {\n\t      $$ = dsegm_new (FDEF_PAD);\n\t      $$->v.n = $2;\n\t    }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      }
    ],
    "terror": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "void\nterror (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vlerror (&yylloc, fmt, ap);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "yyerror": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "int\nyyerror (char const *s)\n{\n  terror (\"%s\", s);\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gram_trace": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "void\ngram_trace (int n)\n{\n#if GDBMTOOL_DEBUG  \n  yydebug = 1;\n#endif\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/hash.c": {
    "_gdbm_hash": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\n_gdbm_hash (datum key)\n{\n  unsigned int value;\t/* Used to compute the hash value.  */\n  int   index;\t\t/* Used to cycle through random values. */\n\n  /* Set the initial value from key. */\n  value = 0x238F13AF * key.dsize;\n  for (index = 0; index < key.dsize; index++)\n    value = (value + (key.dptr[index] << (index*5 % 24))) & 0x7FFFFFFF;\n\n  value = (1103515243 * value + 12345) & 0x7FFFFFFF;  \n\n  /* Return the value. */\n  return((int) value);\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_bucket_dir": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\n_gdbm_bucket_dir (GDBM_FILE dbf, int hash)\n{\n  return hash >> (GDBM_HASH_BITS - dbf->header->dir_bits);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_hash_key": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\n_gdbm_hash_key (GDBM_FILE dbf, datum key, int *hash, int *bucket, int *offset)\n{\n  int hashval = _gdbm_hash (key);\n  *hash = hashval;\n  *bucket = _gdbm_bucket_dir (dbf, hashval);\n  *offset = hashval % dbf->header->bucket_elems;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/input-argv.c": {
    "instream_argv_read": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static ssize_t\ninstream_argv_read (instream_t istr, char *buf, size_t size)\n{\n  size_t total = 0;\n  struct instream_argv *i = (struct instream_argv*)istr;\n  char const specials[] = \" \\\"\\t\\n[]{},=\";\n  char const escapable[] = \"\\\\\\\"\";\n  \n  while (total < size)\n    {\n      if (*i->cur == 0)\n\t{\n\t  if (i->quote)\n\t    {\n\t      buf[total++] = '\"';\n\t      i->quote = 0;\n\t      continue;\n\t    }\n\t  \n\t  if (i->idx == i->argc)\n\t    {\n\t      if (!i->delim)\n\t\t{\n\t\t  i->cur = \"\\n\";\n\t\t  i->delim = 1;\n\t\t}\n\t      else\n\t\tbreak;\n\t    }\n\t  else if (!i->delim)\n\t    {\n\t      i->cur = \" \";\n\t      i->delim = 1;\n\t    }\n\t  else\n\t    {\n\t      size_t len;\n\t      i->cur = i->argv[i->idx++];\n\t      i->delim = 0;\n\t      len = strlen (i->cur);\n\t      if (len > 1 && i->cur[0] == '\"' && i->cur[len-1] == '\"')\n\t\ti->quote = 0;\n\t      else if (i->cur[strcspn (i->cur, specials)])\n\t\t{\n\t\t  buf[total++] = '\"';\n\t\t  i->quote = 1;\n\t\t  continue;\n\t\t}\n\t      else\n\t\ti->quote = 0;\n\t    }\n\t}\n      \n      if (strchr (escapable, *i->cur))\n\t{\n\t  if (total + 2 > size)\n\t    break;\n\t  buf[total++] = '\\\\';\n\t  i->cur++;\n\t}\n      buf[total++] = *i->cur++;\n    }\n  return total;\n}",
      "lines": 64,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "instream_argv_close": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static void\ninstream_argv_close (instream_t istr)\n{\n  struct instream_argv *i = (struct instream_argv *)istr;\n  free (i);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "instream_argv_eq": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int\ninstream_argv_eq (instream_t a, instream_t b)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "instream_argv_create": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "instream_t\ninstream_argv_create (int argc, char **argv)\n{\n  struct instream_argv *istr;\n\n  istr = emalloc (sizeof *istr);\n  istr->base.in_name = \"argv\";\n  istr->base.in_inter = 0;\n  istr->base.in_read = instream_argv_read;\n  istr->base.in_close = instream_argv_close;\n  istr->base.in_eq = instream_argv_eq;\n  \n  istr->argc = argc;\n  istr->argv = argv;\n  istr->idx = 0;\n  istr->cur = \"\";\n  istr->delim = 1;\n  istr->quote = 0;\n  \n  return (instream_t) istr;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "instream_t"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/input-file.c": {
    "instream_file_read": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "static ssize_t\ninstream_file_read (instream_t istr, char *buf, size_t size)\n{\n  struct instream_file *file = (struct instream_file *)istr;\n  return fread (buf, 1, size, file->fp);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "instream_file_close": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void\ninstream_file_close (instream_t istr)\n{\n  struct instream_file *file = (struct instream_file *)istr;\n  fclose (file->fp);\n  free (file->base.in_name);\n  free (file);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "instream_file_eq": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\ninstream_file_eq (instream_t a, instream_t b)\n{\n  struct instream_file *file_a = (struct instream_file *)a;\n  struct instream_file *file_b = (struct instream_file *)b;\n  return file_a->dev == file_b->dev && file_a->ino == file_b->ino;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "instream_file_create": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "instream_t\ninstream_file_create (char const *name)\n{\n  struct instream_file *istr;\n  struct stat st;\n  FILE *fp;\n\n  if (stat (name, &st))\n    {\n      terror (_(\"cannot open `%s': %s\"), name, strerror (errno));\n      return NULL;\n    }\n  else if (!S_ISREG (st.st_mode))\n    {\n      terror (_(\"%s is not a regular file\"), name);\n      return NULL;\n    }\n\n  fp = fopen (name, \"r\");\n  if (!fp)\n    {\n      terror (_(\"cannot open %s for reading: %s\"), name,\n\t      strerror (errno));\n      return NULL;\n    }\n  \n  istr = emalloc (sizeof *istr);\n  istr->base.in_name = estrdup (name);\n  istr->base.in_inter = 0;\n  istr->base.in_read = instream_file_read;\n  istr->base.in_close = instream_file_close;\n  istr->base.in_eq = instream_file_eq;\n  istr->fp = fp;\n  istr->dev = st.st_dev;\n  istr->ino = st.st_ino;\n\n  return (instream_t) istr;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "instream_t"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/input-rl.c": {
    "pre_input": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\npre_input (void)\n{\n  if (pre_input_line)\n    {\n      rl_insert_text (pre_input_line);\n      free (pre_input_line);\n      pre_input_line = NULL;\n      rl_redisplay ();\n    }\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "retrieve_history": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static int\nretrieve_history (char *str)\n{\n  char *out;\n  int rc;\n\n  rc = history_expand (str, &out);\n  switch (rc)\n    {\n    case -1:\n      yyerror (out);\n      free (out);\n      return 1;\n\n    case 0:\n      free (out);\n      break;\n\n    case 1:\n      pre_input_line = out;\n      return 1;\n\n    case 2:\n      printf (\"%s\\n\", out);\n      free (out);\n      return 1;\n    }\n  return 0;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "input_history_begin": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "int\ninput_history_begin (struct handler_param *param, size_t *exp_count)\n{\n  struct history_param *p;\n  int from = 0, count = history_length;\n\n  switch (param->argc)\n    {\n    case 1:\n      if (getnum (&count, param->argv[0]->v.string, NULL))\n\treturn 1;\n      if (count > history_length)\n\tcount = history_length;\n      else\n\tfrom = history_length - count;\n      break;\n\n    case 2:\n      if (getnum (&from, param->argv[0]->v.string, NULL))\n\treturn 1;\n      if (from)\n\t--from;\n      if (getnum (&count, param->argv[1]->v.string, NULL))\n\treturn 1;\n\n      if (count > history_length)\n\tcount = history_length;\n    }\n  p = emalloc (sizeof *p);\n  p->from = from;\n  p->count = count;\n  param->data = p;\n  if (exp_count)\n    *exp_count = count;\n  return 0;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "input_history_handler": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void\ninput_history_handler (struct handler_param *param)\n{\n  struct history_param *p = param->data;\n  int i;\n  HIST_ENTRY **hlist;\n  FILE *fp = param->fp;\n  \n  hlist = history_list ();\n  for (i = 0; i < p->count; i++)\n    fprintf (fp, \"%4d) %s\\n\", p->from + i + 1, hlist[p->from + i]->line);\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "get_history_file_name": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static char *\nget_history_file_name (void)\n{\n  static char *filename = NULL;\n\n  if (!filename)\n    {\n      char *hname;\n\n      hname = emalloc (sizeof HISTFILE_PREFIX + strlen (rl_readline_name) +\n\t\t       sizeof HISTFILE_SUFFIX - 1);\n      strcpy (hname, HISTFILE_PREFIX);\n      strcat (hname, rl_readline_name);\n      strcat (hname, HISTFILE_SUFFIX);\n      filename = tildexpand (hname);\n      free (hname);\n    }\n  return filename;\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_history_file_name (void)",
        "*"
      ]
    },
    "shell_completion": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "static char **\nshell_completion (const char *text, int start, int end)\n{\n  char **matches;\n\n  matches = (char **) NULL;\n\n  /* If this word is at the start of the line, then it is a command\n     to complete.  Otherwise it is the name of a file in the current\n     directory. */\n  if (start == 0)\n    matches = rl_completion_matches (text, command_generator);\n\n  return (matches);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "**\nshell_completion (const char *text, int start, int end)",
        "*",
        "*\nshell_completion (const char *text, int start, int end)",
        "*"
      ]
    },
    "input_init": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void\ninput_init (void)\n{\n  /* Allow conditional parsing of the ~/.inputrc file. */\n  rl_readline_name = (char *) progname;\n  rl_attempted_completion_function = shell_completion;\n  rl_pre_input_hook = pre_input;\n  read_history (get_history_file_name ());\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "input_done": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\ninput_done (void)\n{\n  write_history (get_history_file_name ());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "instream_stdin_close": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "static void\ninstream_stdin_close (instream_t istr)\n{\n  free (istr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "stdin_read_readline": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "static ssize_t\nstdin_read_readline (instream_t istr, char *buf, size_t size)\n{\n  static char *input_line;\n  static size_t input_length;\n  static size_t input_off;\n#define input_ptr() (input_line + input_off)\n#define input_size() (input_length - input_off)\n  size_t len = input_size ();\n  if (!len)\n    {\n      if (input_line)\n\t{\n\tnewline:\n\t  free (input_line);\n\t  input_line = NULL;\n\t  buf[0] = '\\n';\n\t  return 1;\n\t}\n      else\n\t{\n\t  char *prompt;\n\tagain:\n\t  prompt = make_prompt ();\n\t  input_line = readline (prompt);\n\t  free (prompt);\n\t  if (!input_line)\n\t    return 0;\n\t  input_length = strlen (input_line);\n\t  input_off = 0;\n\t  if (input_length)\n\t    {\n\t      if (retrieve_history (input_line))\n\t\t{\n\t\t  free (input_line);\n\t\t  goto again;\n\t\t}\n\t    }\n\t  else\n\t    goto newline;\n\t  len = input_size ();\n\t  add_history (input_line);\n\t}\n    }\n  \n  if (len > size)\n    len = size;\n  memcpy (buf, input_ptr (), len);\n  input_off += len;\n\n  return len;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "instream_stdin_read": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static ssize_t\ninstream_stdin_read (instream_t istr, char *buf, size_t size)\n{\n  if (istr->in_inter)\n    return stdin_read_readline (istr, buf, size);\n  return fread (buf, 1, size, stdin);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "instream_stdin_eq": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "static int\ninstream_stdin_eq (instream_t a, instream_t b)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "instream_stdin_create": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "instream_t\ninstream_stdin_create (void)\n{\n  struct instream *istr;\n\n  istr = emalloc (sizeof *istr);\n  istr->in_name = \"stdin\";\n  istr->in_inter = isatty (fileno (stdin));\n  istr->in_read = instream_stdin_read;\n  istr->in_close = instream_stdin_close;\n  istr->in_eq = instream_stdin_eq;\n\n  return istr;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "instream_t"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/input-std.c": {
    "instream_stdin_read": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "static ssize_t\ninstream_stdin_read (instream_t istr, char *buf, size_t size)\n{\n  if (istr->in_inter)\n    print_prompt_at_bol ();\n  if (fgets (buf, size, stdin) == NULL)\n    return 0;\n  return strlen (buf);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "instream_stdin_close": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static void\ninstream_stdin_close (instream_t istr)\n{\n  free (istr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "instream_stdin_eq": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static int\ninstream_stdin_eq (instream_t a, instream_t b)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "instream_stdin_create": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "instream_t\ninstream_stdin_create (void)\n{\n  struct instream *istr;\n\n  istr = emalloc (sizeof *istr);\n  istr->in_name = \"stdin\";\n  istr->in_inter = isatty (fileno (stdin));\n  istr->in_read = instream_stdin_read;\n  istr->in_close = instream_stdin_close;\n  istr->in_eq = instream_stdin_eq;\n\n  return istr;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "instream_t"
      ]
    },
    "input_init": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\ninput_init (void)\n{\n  /* nothing */\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "input_done": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void\ninput_done (void)\n{\n  /* nothing */\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/lex.c": {
    "advance_line": {
      "start_point": [
        594,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "void\nadvance_line (void)\n{\n  ++context_tos->point.line;\n  context_tos->point.col = 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "interactive": {
      "start_point": [
        631,
        0
      ],
      "end_point": [
        635,
        1
      ],
      "content": "int\ninteractive (void)\n{\n  return context_tos && instream_interactive (context_tos->input);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "input_context_lookup": {
      "start_point": [
        637,
        0
      ],
      "end_point": [
        646,
        1
      ],
      "content": "static struct context *\ninput_context_lookup (instream_t istr)\n{\n  struct context *cp;\n\n  for (cp = context_tos; cp; cp = cp->parent)\n    if (instream_eq (cp->input, istr))\n      break;\n  return cp;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct context",
        "struct",
        "context",
        "*\ninput_context_lookup (instream_t istr)",
        "*"
      ]
    },
    "input_context_push": {
      "start_point": [
        648,
        0
      ],
      "end_point": [
        679,
        1
      ],
      "content": "int\ninput_context_push (instream_t input)\n{\n  struct context *cp;\n\n  cp = input_context_lookup (input);\n  if (cp)\n    {\n      terror (_(\"recursive sourcing\"));\n      if (cp->parent)\n\tlerror (&cp->locus, _(\"%s already sourced here\"),\n\t\tinstream_name (input));\n      return 1;\n    }\n\n  yy_switch_to_buffer (yy_create_buffer (NULL, YY_BUF_SIZE));\n\n  /* Create new context */\n\n  cp = ecalloc (1, sizeof (*cp));\n  cp->locus = yylloc;\n  cp->point.file = estrdup (instream_name (input));\n  cp->point.line = 1;\n  cp->point.col = 0;\n  \n  cp->input = input;\n  cp->buf = YY_CURRENT_BUFFER;\n  cp->parent = context_tos;\n  context_tos = cp;\n\n  return 0;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "lex_trace": {
      "start_point": [
        681,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "void\nlex_trace (int n)\n{\n  yy_flex_debug = n;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "input_context_pop": {
      "start_point": [
        687,
        0
      ],
      "end_point": [
        708,
        1
      ],
      "content": "int\ninput_context_pop (void)\n{\n  struct context *cp;\n\n  if (!context_tos)\n    return 1;\n  instream_close (context_tos->input);\n  free (context_tos->point.file);\n  memset (&yylloc, 0, sizeof (yylloc));\n  cp = context_tos->parent;\n  free (context_tos);\n  context_tos = cp;\n  if (!cp)\n    return 1;\n\n  yylloc = cp->locus;\n  yy_delete_buffer (YY_CURRENT_BUFFER);\n  yy_switch_to_buffer (cp->buf);\n\n  return 0;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "t_num": {
      "start_point": [
        710,
        0
      ],
      "end_point": [
        728,
        1
      ],
      "content": "static int\nt_num (int base)\n{\n  long n;\n  errno = 0;\n  n = strtol (yytext, NULL, base);\n  if (errno)\n    {\n      lerror (&yylloc, \"%s\", strerror (errno));\n      return T_BOGUS;\n    }\n  if (n < INT_MIN || n > INT_MAX)\n    {\n      lerror (&yylloc, \"value out of range\");\n      return T_BOGUS;\n    }\n  yylval.num = n;\n  return T_NUM;  \n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_next_buffer": {
      "start_point": [
        1382,
        0
      ],
      "end_point": [
        1483,
        1
      ],
      "content": "static int yy_get_next_buffer (void)\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tyy_size_t num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\tYY_FATAL_ERROR(\n\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart(yyin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tyy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 102,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        1487,
        4
      ],
      "end_point": [
        1512,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (void)\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\tyy_current_state += YY_AT_BOL();\n\n\t(yy_state_ptr) = (yy_state_buf);\n\t*(yy_state_ptr)++ = yy_current_state;\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 86 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t*(yy_state_ptr)++ = yy_current_state;\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        1519,
        4
      ],
      "end_point": [
        1536,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n{\n\tregister int yy_is_jam;\n    \n\tregister YY_CHAR yy_c = 1;\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 86 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 85);\n\tif ( ! yy_is_jam )\n\t\t*(yy_state_ptr)++ = yy_current_state;\n\n\t\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "input": {
      "start_point": [
        1542,
        4
      ],
      "end_point": [
        1611,
        1
      ],
      "content": "static int input  (void)\n#endif\n\n{\n\tint c;\n    \n\t*(yy_c_buf_p) = (yy_hold_char);\n\n\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tyy_size_t offset = (yy_c_buf_p) - (yytext_ptr);\n\t\t\t++(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer(  ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tyyrestart(yyin );\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( yywrap( ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*(yy_c_buf_p) = '\\0';\t/* preserve yytext */\n\t(yy_hold_char) = *++(yy_c_buf_p);\n\n\tYY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\\n');\n\n\treturn c;\n}",
      "lines": 70,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyrestart": {
      "start_point": [
        1619,
        4
      ],
      "end_point": [
        1630,
        1
      ],
      "content": "void yyrestart  (FILE * input_file )\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer(yyin,YY_BUF_SIZE );\n\t}\n\n\tyy_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tyy_load_buffer_state( );\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_switch_to_buffer": {
      "start_point": [
        1636,
        4
      ],
      "end_point": [
        1665,
        1
      ],
      "content": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_load_buffer_state": {
      "start_point": [
        1667,
        0
      ],
      "end_point": [
        1673,
        1
      ],
      "content": "static void yy_load_buffer_state  (void)\n{\n    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\t(yy_hold_char) = *(yy_c_buf_p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_create_buffer": {
      "start_point": [
        1681,
        4
      ],
      "end_point": [
        1703,
        1
      ],
      "content": "YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_delete_buffer": {
      "start_point": [
        1709,
        4
      ],
      "end_point": [
        1722,
        1
      ],
      "content": "void yy_delete_buffer (YY_BUFFER_STATE  b )\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree((void *) b->yy_ch_buf  );\n\n\tyyfree((void *) b  );\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "yy_init_buffer": {
      "start_point": [
        1728,
        4
      ],
      "end_point": [
        1750,
        1
      ],
      "content": "static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n\n{\n\tint oerrno = errno;\n    \n\tyy_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flush_buffer": {
      "start_point": [
        1756,
        4
      ],
      "end_point": [
        1777,
        1
      ],
      "content": "void yy_flush_buffer (YY_BUFFER_STATE  b )\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state( );\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yypush_buffer_state": {
      "start_point": [
        1785,
        0
      ],
      "end_point": [
        1809,
        1
      ],
      "content": "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack();\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yypop_buffer_state": {
      "start_point": [
        1815,
        0
      ],
      "end_point": [
        1829,
        1
      ],
      "content": "void yypop_buffer_state (void)\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yyensure_buffer_stack": {
      "start_point": [
        1834,
        0
      ],
      "end_point": [
        1875,
        1
      ],
      "content": "static void yyensure_buffer_stack (void)\n{\n\tyy_size_t num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_scan_buffer": {
      "start_point": [
        1883,
        0
      ],
      "end_point": [
        1910,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_string": {
      "start_point": [
        1920,
        0
      ],
      "end_point": [
        1924,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )\n{\n    \n\treturn yy_scan_bytes(yystr,strlen(yystr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_bytes": {
      "start_point": [
        1933,
        0
      ],
      "end_point": [
        1961,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) yyalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        1967,
        0
      ],
      "end_point": [
        1971,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyget_lineno": {
      "start_point": [
        1995,
        0
      ],
      "end_point": [
        1999,
        1
      ],
      "content": "int yyget_lineno  (void)\n{\n        \n    return yylineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyget_in": {
      "start_point": [
        2004,
        0
      ],
      "end_point": [
        2007,
        1
      ],
      "content": "FILE *yyget_in  (void)\n{\n        return yyin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_in  (void)",
        "*"
      ]
    },
    "yyget_out": {
      "start_point": [
        2012,
        0
      ],
      "end_point": [
        2015,
        1
      ],
      "content": "FILE *yyget_out  (void)\n{\n        return yyout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_out  (void)",
        "*"
      ]
    },
    "yyget_leng": {
      "start_point": [
        2020,
        0
      ],
      "end_point": [
        2023,
        1
      ],
      "content": "yy_size_t yyget_leng  (void)\n{\n        return yyleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "yy_size_t"
      ]
    },
    "yyget_text": {
      "start_point": [
        2029,
        0
      ],
      "end_point": [
        2032,
        1
      ],
      "content": "char *yyget_text  (void)\n{\n        return yytext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*yyget_text  (void)",
        "*"
      ]
    },
    "yyset_lineno": {
      "start_point": [
        2038,
        0
      ],
      "end_point": [
        2042,
        1
      ],
      "content": "void yyset_lineno (int  line_number )\n{\n    \n    yylineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yyset_in": {
      "start_point": [
        2050,
        0
      ],
      "end_point": [
        2053,
        1
      ],
      "content": "void yyset_in (FILE *  in_str )\n{\n        yyin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyset_out": {
      "start_point": [
        2055,
        0
      ],
      "end_point": [
        2058,
        1
      ],
      "content": "void yyset_out (FILE *  out_str )\n{\n        yyout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyget_debug": {
      "start_point": [
        2060,
        0
      ],
      "end_point": [
        2063,
        1
      ],
      "content": "int yyget_debug  (void)\n{\n        return yy_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyset_debug": {
      "start_point": [
        2065,
        0
      ],
      "end_point": [
        2068,
        1
      ],
      "content": "void yyset_debug (int  bdebug )\n{\n        yy_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        2070,
        0
      ],
      "end_point": [
        2101,
        1
      ],
      "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n    (yy_state_buf) = 0;\n    (yy_state_ptr) = 0;\n    (yy_full_match) = 0;\n    (yy_lp) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yylex_destroy": {
      "start_point": [
        2104,
        0
      ],
      "end_point": [
        2126,
        1
      ],
      "content": "int yylex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    yyfree ( (yy_state_buf) );\n    (yy_state_buf)  = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        2133,
        0
      ],
      "end_point": [
        2138,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        2142,
        0
      ],
      "end_point": [
        2149,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyalloc": {
      "start_point": [
        2152,
        0
      ],
      "end_point": [
        2155,
        1
      ],
      "content": "void *yyalloc (yy_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*yyalloc (yy_size_t  size )",
        "*"
      ]
    },
    "yyrealloc": {
      "start_point": [
        2157,
        0
      ],
      "end_point": [
        2167,
        1
      ],
      "content": "void *yyrealloc  (void * ptr, yy_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*yyrealloc  (void * ptr, yy_size_t  size )",
        "*"
      ]
    },
    "yyfree": {
      "start_point": [
        2169,
        0
      ],
      "end_point": [
        2172,
        1
      ],
      "content": "void yyfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yywrap": {
      "start_point": [
        2180,
        0
      ],
      "end_point": [
        2184,
        1
      ],
      "content": "int\nyywrap (void)\n{\n  return input_context_pop ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "begin_def": {
      "start_point": [
        2186,
        0
      ],
      "end_point": [
        2190,
        1
      ],
      "content": "void\nbegin_def (void)\n{\n  BEGIN (DEF);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "end_def": {
      "start_point": [
        2192,
        0
      ],
      "end_point": [
        2196,
        1
      ],
      "content": "void\nend_def (void)\n{\n  BEGIN (CMD);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "print_prompt_at_bol": {
      "start_point": [
        2198,
        0
      ],
      "end_point": [
        2208,
        1
      ],
      "content": "void\nprint_prompt_at_bol (void)\n{\n  if (YY_AT_BOL ())\n    {\n      char *s = make_prompt ();\n      fputs (s, stdout);\n      fflush (stdout);\n      free (s);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "string_begin": {
      "start_point": [
        2220,
        0
      ],
      "end_point": [
        2224,
        1
      ],
      "content": "void\nstring_begin (void)\n{\n  strseg_head = strseg_tail = NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "strseg_attach": {
      "start_point": [
        2226,
        0
      ],
      "end_point": [
        2235,
        1
      ],
      "content": "void\nstrseg_attach (struct strseg *seg)\n{\n  seg->next = NULL;\n  if (strseg_tail)\n    strseg_tail->next = seg;\n  else\n    strseg_head = seg;\n  strseg_tail = seg;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "string_add": {
      "start_point": [
        2237,
        0
      ],
      "end_point": [
        2244,
        1
      ],
      "content": "void\nstring_add (const char *s, int l)\n{\n  struct strseg *seg = emalloc (sizeof (*seg) + l);\n  memcpy (seg->ptr, s, l);\n  seg->len = l;\n  strseg_attach (seg);\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "string_addc": {
      "start_point": [
        2246,
        0
      ],
      "end_point": [
        2253,
        1
      ],
      "content": "void\nstring_addc (int c)\n{\n  struct strseg *seg = emalloc (sizeof (*seg));\n  seg->ptr[0] = c;\n  seg->len = 1;\n  strseg_attach (seg);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "string_end": {
      "start_point": [
        2255,
        0
      ],
      "end_point": [
        2280,
        1
      ],
      "content": "char *\nstring_end (void)\n{\n  int len = 1;\n  struct strseg *seg;\n  char *ret, *p;\n  \n  for (seg = strseg_head; seg; seg = seg->next)\n    len += seg->len;\n\n  ret = emalloc (len);\n  p = ret;\n  for (seg = strseg_head; seg; )\n    {\n      struct strseg *next = seg->next;\n      memcpy (p, seg->ptr, seg->len);\n      p += seg->len;\n      free (seg);\n      seg = next;\n    }\n  *p = 0;\n\n  strseg_head = strseg_tail = NULL;\n\n  return ret;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "char",
        "*\nstring_end (void)",
        "*"
      ]
    },
    "unescape": {
      "start_point": [
        2284,
        0
      ],
      "end_point": [
        2295,
        1
      ],
      "content": "int\nunescape (int c)\n{\n  char *p;\n\n  for (p = transtab; *p; p += 2)\n    {\n      if (*p == c)\n\treturn p[1];\n    }\n  return c;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "escape": {
      "start_point": [
        2297,
        0
      ],
      "end_point": [
        2307,
        1
      ],
      "content": "int\nescape (int c)\n{\n  char *p;\n  for (p = transtab + sizeof (transtab) - 2; p > transtab; p -= 2)\n    {\n      if (*p == c)\n\treturn p[-1];\n    }\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "vlerror": {
      "start_point": [
        2309,
        0
      ],
      "end_point": [
        2321,
        1
      ],
      "content": "void\nvlerror (struct locus *loc, const char *fmt, va_list ap)\n{\n  if (!interactive ())\n    fprintf (stderr, \"%s: \", progname);\n  if (loc && loc->beg.file)\n    {\n      YY_LOCATION_PRINT (stderr, *loc);\n      fprintf (stderr, \": \");\n    }\n  vfprintf (stderr, fmt, ap);\n  fputc ('\\n', stderr);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "lerror": {
      "start_point": [
        2323,
        0
      ],
      "end_point": [
        2331,
        1
      ],
      "content": "void\nlerror (struct locus *loc, const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vlerror (loc, fmt, ap);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "pe_file_name": {
      "start_point": [
        2334,
        0
      ],
      "end_point": [
        2338,
        1
      ],
      "content": "static struct slist *\npe_file_name (void)\n{\n  return file_name ? slist_new (file_name) : NULL;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct slist",
        "struct",
        "slist",
        "*\npe_file_name (void)",
        "*"
      ]
    },
    "pe_program_name": {
      "start_point": [
        2340,
        0
      ],
      "end_point": [
        2344,
        1
      ],
      "content": "static struct slist *\npe_program_name (void)\n{\n  return slist_new (progname);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "struct slist",
        "struct",
        "slist",
        "*\npe_program_name (void)",
        "*"
      ]
    },
    "pe_package_name": {
      "start_point": [
        2346,
        0
      ],
      "end_point": [
        2350,
        1
      ],
      "content": "static struct slist *\npe_package_name (void)\n{\n  return slist_new (PACKAGE_NAME);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "struct slist",
        "struct",
        "slist",
        "*\npe_package_name (void)",
        "*"
      ]
    },
    "pe_program_version": {
      "start_point": [
        2352,
        0
      ],
      "end_point": [
        2356,
        1
      ],
      "content": "static struct slist *\npe_program_version (void)\n{\n  return slist_new (PACKAGE_VERSION);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "struct slist",
        "struct",
        "slist",
        "*\npe_program_version (void)",
        "*"
      ]
    },
    "pe_space": {
      "start_point": [
        2358,
        0
      ],
      "end_point": [
        2362,
        1
      ],
      "content": "static struct slist *\npe_space (void)\n{\n  return slist_new (\" \");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct slist",
        "struct",
        "slist",
        "*\npe_space (void)",
        "*"
      ]
    },
    "expand_char": {
      "start_point": [
        2379,
        0
      ],
      "end_point": [
        2398,
        1
      ],
      "content": "static int\nexpand_char (int c, struct slist **tailp)\n{\n  struct prompt_exp *p;\n\n  if (c && c != '%')\n    {\n      for (p = prompt_exp; p->ch; p++)\n\t{\n\t  if (c == p->ch)\n\t    {\n\t      struct slist *s = p->fun ();\n\t      if (s)\n\t\tslist_insert (tailp, s);\n\t      return 0;\n\t    }\n\t}\n    }\n  return 1;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "psname": {
      "start_point": [
        2400,
        0
      ],
      "end_point": [
        2406,
        1
      ],
      "content": "char const *\npsname (void)\n{\n  if (YYSTATE == DEF || YYSTATE == MLSTR)\n    return \"ps2\";\n  return \"ps1\";\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\npsname (void)",
        "*"
      ]
    },
    "make_prompt": {
      "start_point": [
        2408,
        0
      ],
      "end_point": [
        2477,
        1
      ],
      "content": "char *\nmake_prompt (void)\n{\n  const char *s;\n  const char *prompt;\n  struct slist *head = NULL, *tail = NULL, *p;\n  char *ret, *end;\n  size_t len;\n  \n  switch (variable_get (psname (), VART_STRING, (void *) &prompt))\n    {\n    case VAR_OK:\n      break;\n\n    case VAR_ERR_NOTSET:\n      return NULL;\n      \n    default:\n      abort ();\n    }\n\n  for (s = prompt; *s; )\n    {\n      if (*s == '%' && s[1])\n\t{\n\t  if (s > prompt)\n\t    {\n\t      slist_insert (&tail, slist_new_l (prompt, s - prompt));\n\t      if (!head)\n\t\thead = tail;\n\t    }\n\t  if (expand_char (s[1], &tail) == 0)\n\t    {\n\t      if (!head)\n\t\thead = tail;\n\t      prompt = s + 2;\n\t    }\n\t  else\n\t    prompt = s;\n\t  s += 2;\n\t}\n      else\n\t++s;\n    }\n\n  if (s > prompt)\n    {\n      slist_insert (&tail, slist_new_l (prompt, s - prompt));\n      if (!head)\n\thead = tail;\n    }\n\n  len = 0;\n  for (p = head; p; p = p->next)\n    len += strlen (p->str);\n\n  ret = emalloc (len + 1);\n  end = ret;\n  for (p = head; p; p = p->next)\n    {\n      s = p->str;\n      while (*s)\n\t*end++ = *s++;\n    }\n  *end = 0;\n\n  slist_free (head);\n  \n  return ret;\n}",
      "lines": 70,
      "depth": 15,
      "decorators": [
        "char",
        "*\nmake_prompt (void)",
        "*"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/lex.l": {
    "advance_line": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\nadvance_line (void)\n{\n  ++context_tos->point.line;\n  context_tos->point.col = 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "interactive": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\ninteractive (void)\n{\n  return context_tos && instream_interactive (context_tos->input);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "input_context_lookup": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static struct context *\ninput_context_lookup (instream_t istr)\n{\n  struct context *cp;\n\n  for (cp = context_tos; cp; cp = cp->parent)\n    if (instream_eq (cp->input, istr))\n      break;\n  return cp;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct context",
        "struct",
        "context",
        "*\ninput_context_lookup (instream_t istr)",
        "*"
      ]
    },
    "input_context_push": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\ninput_context_push (instream_t input)\n{\n  struct context *cp;\n\n  cp = input_context_lookup (input);\n  if (cp)\n    {\n      terror (_(\"recursive sourcing\"));\n      if (cp->parent)\n\tlerror (&cp->locus, _(\"%s already sourced here\"),\n\t\tinstream_name (input));\n      return 1;\n    }\n\n  yy_switch_to_buffer (yy_create_buffer (NULL, YY_BUF_SIZE));\n\n  /* Create new context */\n\n  cp = ecalloc (1, sizeof (*cp));\n  cp->locus = yylloc;\n  cp->point.file = estrdup (instream_name (input));\n  cp->point.line = 1;\n  cp->point.col = 0;\n  \n  cp->input = input;\n  cp->buf = YY_CURRENT_BUFFER;\n  cp->parent = context_tos;\n  context_tos = cp;\n\n  return 0;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "lex_trace": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "void\nlex_trace (int n)\n{\n  yy_flex_debug = n;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "input_context_pop": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\ninput_context_pop (void)\n{\n  struct context *cp;\n\n  if (!context_tos)\n    return 1;\n  instream_close (context_tos->input);\n  free (context_tos->point.file);\n  memset (&yylloc, 0, sizeof (yylloc));\n  cp = context_tos->parent;\n  free (context_tos);\n  context_tos = cp;\n  if (!cp)\n    return 1;\n\n  yylloc = cp->locus;\n  yy_delete_buffer (YY_CURRENT_BUFFER);\n  yy_switch_to_buffer (cp->buf);\n\n  return 0;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "t_num": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static int\nt_num (int base)\n{\n  long n;\n  errno = 0;\n  n = strtol (yytext, NULL, base);\n  if (errno)\n    {\n      lerror (&yylloc, \"%s\", strerror (errno));\n      return T_BOGUS;\n    }\n  if (n < INT_MIN || n > INT_MAX)\n    {\n      lerror (&yylloc, \"value out of range\");\n      return T_BOGUS;\n    }\n  yylval.num = n;\n  return T_NUM;  \n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yywrap": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "int\nyywrap (void)\n{\n  return input_context_pop ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "begin_def": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "void\nbegin_def (void)\n{\n  BEGIN (DEF);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "end_def": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "void\nend_def (void)\n{\n  BEGIN (CMD);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "print_prompt_at_bol": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "void\nprint_prompt_at_bol (void)\n{\n  if (YY_AT_BOL ())\n    {\n      char *s = make_prompt ();\n      fputs (s, stdout);\n      fflush (stdout);\n      free (s);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "string_begin": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "void\nstring_begin (void)\n{\n  strseg_head = strseg_tail = NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "strseg_attach": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "void\nstrseg_attach (struct strseg *seg)\n{\n  seg->next = NULL;\n  if (strseg_tail)\n    strseg_tail->next = seg;\n  else\n    strseg_head = seg;\n  strseg_tail = seg;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "string_add": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "void\nstring_add (const char *s, int l)\n{\n  struct strseg *seg = emalloc (sizeof (*seg) + l);\n  memcpy (seg->ptr, s, l);\n  seg->len = l;\n  strseg_attach (seg);\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "string_addc": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "void\nstring_addc (int c)\n{\n  struct strseg *seg = emalloc (sizeof (*seg));\n  seg->ptr[0] = c;\n  seg->len = 1;\n  strseg_attach (seg);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "string_end": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "char *\nstring_end (void)\n{\n  int len = 1;\n  struct strseg *seg;\n  char *ret, *p;\n  \n  for (seg = strseg_head; seg; seg = seg->next)\n    len += seg->len;\n\n  ret = emalloc (len);\n  p = ret;\n  for (seg = strseg_head; seg; )\n    {\n      struct strseg *next = seg->next;\n      memcpy (p, seg->ptr, seg->len);\n      p += seg->len;\n      free (seg);\n      seg = next;\n    }\n  *p = 0;\n\n  strseg_head = strseg_tail = NULL;\n\n  return ret;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "char",
        "*\nstring_end (void)",
        "*"
      ]
    },
    "unescape": {
      "start_point": [
        394,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "int\nunescape (int c)\n{\n  char *p;\n\n  for (p = transtab; *p; p += 2)\n    {\n      if (*p == c)\n\treturn p[1];\n    }\n  return c;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "escape": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "int\nescape (int c)\n{\n  char *p;\n  for (p = transtab + sizeof (transtab) - 2; p > transtab; p -= 2)\n    {\n      if (*p == c)\n\treturn p[-1];\n    }\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "vlerror": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "void\nvlerror (struct locus *loc, const char *fmt, va_list ap)\n{\n  if (!interactive ())\n    fprintf (stderr, \"%s: \", progname);\n  if (loc && loc->beg.file)\n    {\n      YY_LOCATION_PRINT (stderr, *loc);\n      fprintf (stderr, \": \");\n    }\n  vfprintf (stderr, fmt, ap);\n  fputc ('\\n', stderr);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "lerror": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "void\nlerror (struct locus *loc, const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vlerror (loc, fmt, ap);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "pe_file_name": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        448,
        1
      ],
      "content": "static struct slist *\npe_file_name (void)\n{\n  return file_name ? slist_new (file_name) : NULL;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct slist",
        "struct",
        "slist",
        "*\npe_file_name (void)",
        "*"
      ]
    },
    "pe_program_name": {
      "start_point": [
        450,
        0
      ],
      "end_point": [
        454,
        1
      ],
      "content": "static struct slist *\npe_program_name (void)\n{\n  return slist_new (progname);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "struct slist",
        "struct",
        "slist",
        "*\npe_program_name (void)",
        "*"
      ]
    },
    "pe_package_name": {
      "start_point": [
        456,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "static struct slist *\npe_package_name (void)\n{\n  return slist_new (PACKAGE_NAME);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "struct slist",
        "struct",
        "slist",
        "*\npe_package_name (void)",
        "*"
      ]
    },
    "pe_program_version": {
      "start_point": [
        462,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "static struct slist *\npe_program_version (void)\n{\n  return slist_new (PACKAGE_VERSION);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "struct slist",
        "struct",
        "slist",
        "*\npe_program_version (void)",
        "*"
      ]
    },
    "pe_space": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "static struct slist *\npe_space (void)\n{\n  return slist_new (\" \");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct slist",
        "struct",
        "slist",
        "*\npe_space (void)",
        "*"
      ]
    },
    "expand_char": {
      "start_point": [
        489,
        0
      ],
      "end_point": [
        508,
        1
      ],
      "content": "static int\nexpand_char (int c, struct slist **tailp)\n{\n  struct prompt_exp *p;\n\n  if (c && c != '%')\n    {\n      for (p = prompt_exp; p->ch; p++)\n\t{\n\t  if (c == p->ch)\n\t    {\n\t      struct slist *s = p->fun ();\n\t      if (s)\n\t\tslist_insert (tailp, s);\n\t      return 0;\n\t    }\n\t}\n    }\n  return 1;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "psname": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "char const *\npsname (void)\n{\n  if (YYSTATE == DEF || YYSTATE == MLSTR)\n    return \"ps2\";\n  return \"ps1\";\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\npsname (void)",
        "*"
      ]
    },
    "make_prompt": {
      "start_point": [
        518,
        0
      ],
      "end_point": [
        587,
        1
      ],
      "content": "char *\nmake_prompt (void)\n{\n  const char *s;\n  const char *prompt;\n  struct slist *head = NULL, *tail = NULL, *p;\n  char *ret, *end;\n  size_t len;\n  \n  switch (variable_get (psname (), VART_STRING, (void *) &prompt))\n    {\n    case VAR_OK:\n      break;\n\n    case VAR_ERR_NOTSET:\n      return NULL;\n      \n    default:\n      abort ();\n    }\n\n  for (s = prompt; *s; )\n    {\n      if (*s == '%' && s[1])\n\t{\n\t  if (s > prompt)\n\t    {\n\t      slist_insert (&tail, slist_new_l (prompt, s - prompt));\n\t      if (!head)\n\t\thead = tail;\n\t    }\n\t  if (expand_char (s[1], &tail) == 0)\n\t    {\n\t      if (!head)\n\t\thead = tail;\n\t      prompt = s + 2;\n\t    }\n\t  else\n\t    prompt = s;\n\t  s += 2;\n\t}\n      else\n\t++s;\n    }\n\n  if (s > prompt)\n    {\n      slist_insert (&tail, slist_new_l (prompt, s - prompt));\n      if (!head)\n\thead = tail;\n    }\n\n  len = 0;\n  for (p = head; p; p = p->next)\n    len += strlen (p->str);\n\n  ret = emalloc (len + 1);\n  end = ret;\n  for (p = head; p; p = p->next)\n    {\n      s = p->str;\n      while (*s)\n\t*end++ = *s++;\n    }\n  *end = 0;\n\n  slist_free (head);\n  \n  return ret;\n}",
      "lines": 70,
      "depth": 15,
      "decorators": [
        "char",
        "*\nmake_prompt (void)",
        "*"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/lock.c": {
    "gdbm_locked": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ngdbm_locked (GDBM_FILE dbf)\n{\n  return (dbf->lock_type != LOCKING_NONE);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_unlock_file": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\n_gdbm_unlock_file (GDBM_FILE dbf)\n{\n#if HAVE_FCNTL_LOCK\n  struct flock fl;\n#endif\n\n  switch (dbf->lock_type)\n    {\n      case LOCKING_FLOCK:\n#if HAVE_FLOCK\n\tflock (dbf->desc, LOCK_UN);\n#endif\n\tbreak;\n\n      case LOCKING_LOCKF:\n#if HAVE_LOCKF\n\tlockf (dbf->desc, F_ULOCK, (off_t)0L);\n#endif\n\tbreak;\n\n      case LOCKING_FCNTL:\n#if HAVE_FCNTL_LOCK\n\tfl.l_type = F_UNLCK;\n\tfl.l_whence = SEEK_SET;\n\tfl.l_start = fl.l_len = (off_t)0L;\n\tfcntl (dbf->desc, F_SETLK, &fl);\n#endif\n\tbreak;\n\n      case LOCKING_NONE:\n        break;\n    }\n\n  dbf->lock_type = LOCKING_NONE;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_gdbm_lock_file": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "int\n_gdbm_lock_file (GDBM_FILE dbf)\n{\n#if HAVE_FCNTL_LOCK\n  struct flock fl;\n#endif\n  int lock_val = -1;\n\n#if HAVE_FLOCK\n  if (dbf->read_write == GDBM_READER)\n    lock_val = flock (dbf->desc, LOCK_SH + LOCK_NB);\n  else\n    lock_val = flock (dbf->desc, LOCK_EX + LOCK_NB);\n\n  if ((lock_val == -1) && (errno == EWOULDBLOCK))\n    {\n      dbf->lock_type = LOCKING_NONE;\n      return lock_val;\n    }\n  else if (lock_val != -1)\n    {\n      dbf->lock_type = LOCKING_FLOCK;\n      return lock_val;\n    }\n#endif\n\n#if HAVE_LOCKF\n  /* Mask doesn't matter for lockf. */\n  lock_val = lockf (dbf->desc, F_LOCK, (off_t)0L);\n  if ((lock_val == -1) && (errno == EDEADLK))\n    {\n      dbf->lock_type = LOCKING_NONE;\n      return lock_val;\n    }\n  else if (lock_val != -1)\n    {\n      dbf->lock_type = LOCKING_LOCKF;\n      return lock_val;\n    }\n#endif\n\n#if HAVE_FCNTL_LOCK\n  /* If we're still here, try fcntl. */\n  if (dbf->read_write == GDBM_READER)\n    fl.l_type = F_RDLCK;\n  else\n    fl.l_type = F_WRLCK;\n  fl.l_whence = SEEK_SET;\n  fl.l_start = fl.l_len = (off_t)0L;\n  lock_val = fcntl (dbf->desc, F_SETLK, &fl);\n\n  if (lock_val != -1)\n    dbf->lock_type = LOCKING_FCNTL;\n#endif\n\n  if (lock_val == -1)\n    dbf->lock_type = LOCKING_NONE;\n  return lock_val;\n}",
      "lines": 59,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/mem.c": {
    "ealloc_die": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "void\nealloc_die ()\n{\n  error (\"%s\", strerror (ENOMEM));\n  exit (EXIT_FATAL);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "emalloc": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "void *\nemalloc (size_t size)\n{\n  void *p = malloc (size);\n  if (!p)\n    ealloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nemalloc (size_t size)",
        "*"
      ]
    },
    "erealloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nerealloc (void *ptr, size_t size)\n{\n  void *newptr = realloc (ptr, size);\n  if (!newptr)\n    ealloc_die ();\n  return newptr;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nerealloc (void *ptr, size_t size)",
        "*"
      ]
    },
    "ecalloc": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void *\necalloc (size_t nmemb, size_t size)\n{\n  void *p = calloc (nmemb, size);\n  if (!p)\n    ealloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\necalloc (size_t nmemb, size_t size)",
        "*"
      ]
    },
    "ezalloc": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void *\nezalloc (size_t size)\n{\n  return ecalloc (1, size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void",
        "*\nezalloc (size_t size)",
        "*"
      ]
    },
    "estrdup": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "char *\nestrdup (const char *str)\n{\n  char *p;\n\n  if (!str)\n    return NULL;\n  p = emalloc (strlen (str) + 1);\n  strcpy (p, str);\n  return p;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "char",
        "*\nestrdup (const char *str)",
        "*"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/mmap.c": {
    "SUM_FILE_SIZE": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static inline off_t\nSUM_FILE_SIZE (GDBM_FILE dbf, off_t delta)\n{\n  if (delta >= 0\n      && off_t_sum_ok (dbf->mapped_off, dbf->mapped_size)\n      && off_t_sum_ok (dbf->mapped_off + dbf->mapped_size, delta))\n    return dbf->mapped_off + dbf->mapped_size + delta;\n  return -1;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "off_t"
      ]
    },
    "_gdbm_file_size": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\n_gdbm_file_size (GDBM_FILE dbf, off_t *psize)\n{\n  struct stat sb;\n  if (fstat (dbf->desc, &sb))\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_FILE_STAT_ERROR, FALSE);\n      return -1;\n    }\n  *psize = sb.st_size;\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_mapped_unmap": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "void\n_gdbm_mapped_unmap (GDBM_FILE dbf)\n{\n  if (dbf->mapped_region)\n    {\n      munmap (dbf->mapped_region, dbf->mapped_size);\n      dbf->mapped_region = NULL;\n      dbf->mapped_size = 0;\n      dbf->mapped_pos = 0;\n      dbf->mapped_off = 0;\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_gdbm_internal_remap": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "int\n_gdbm_internal_remap (GDBM_FILE dbf, size_t size)\n{\n  void *p;\n  int flags = PROT_READ;\n  size_t page_size = sysconf (_SC_PAGESIZE);\n\n  if (dbf->mapped_region)\n    {\n      munmap (dbf->mapped_region, dbf->mapped_size);\n      dbf->mapped_region = NULL;\n    }\n  dbf->mapped_size = size;\n\n  if (size == 0)\n    return 0;\n  \n  dbf->mapped_pos += dbf->mapped_off % page_size;\n  dbf->mapped_off = (dbf->mapped_off / page_size) * page_size;\n\n  if (dbf->read_write)\n    flags |= PROT_WRITE;\n  \n  p = mmap (NULL, dbf->mapped_size, flags, MAP_SHARED,\n\t    dbf->desc, dbf->mapped_off);\n  if (p == MAP_FAILED)\n    {\n      dbf->mapped_region = NULL;\n      GDBM_SET_ERRNO (dbf, GDBM_MALLOC_ERROR, FALSE);\n      return -1;\n    }\n  \n  dbf->mapped_region = p;\n  return 0;\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_mapped_remap": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "int\n_gdbm_mapped_remap (GDBM_FILE dbf, off_t size, int flag)\n{\n  off_t file_size, pos;\n\n  if (size < 0)\n    {\n      errno = EINVAL;\n      GDBM_SET_ERRNO (dbf, GDBM_FILE_SEEK_ERROR, TRUE);\n      return -1;\n    }\n\n  if (size < dbf->mapped_size)\n    /* Nothing to do */\n    return 0;\n  \n  if (_gdbm_file_size (dbf, &file_size))\n    {\n      SAVE_ERRNO (_gdbm_mapped_unmap (dbf));\n      return -1; \n    }\n\n  if (flag == _REMAP_END && size < file_size)\n    size = file_size;\n  \n  if (dbf->read_write)\n    {\n      if (size > file_size)\n\t{\n\t  if (flag != _REMAP_DEFAULT)\n\t    {\n\t      if (size < dbf->header->next_block)\n\t\tsize = dbf->header->next_block;\n\t      if (_gdbm_file_extend (dbf, size))\n\t\treturn -1;\n\t      file_size = size;\n\t    }\n\t  else\n\t    {\n\t      return 0;\n\t    }\n\t}\n    }\n  else\n    {\n      if (size > file_size)\n\tsize = file_size;\n      \n      if (size == SUM_FILE_SIZE (dbf, 0))\n\treturn 0;\n    }\n\n  pos = _GDBM_MMAPPED_POS (dbf);\n  if (size > dbf->mapped_size_max)\n    {\n      dbf->mapped_off = pos;\n      dbf->mapped_pos = 0;\n      size = dbf->mapped_size_max;\n      if (dbf->mapped_off + size > file_size)\n\tsize = file_size - dbf->mapped_off;\n    }\n  else\n    {\n      dbf->mapped_pos += dbf->mapped_off;\n      dbf->mapped_off = 0;\n    }\n  if (pos > file_size)\n    {\n      errno = EINVAL;\n      GDBM_SET_ERRNO (dbf, GDBM_FILE_SEEK_ERROR, TRUE);\n      return -1;\n    }\n  return _gdbm_internal_remap (dbf, size);\n}",
      "lines": 74,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_mapped_init": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "int\n_gdbm_mapped_init (GDBM_FILE dbf)\n{\n  if (dbf->mapped_size_max == 0)\n    dbf->mapped_size_max = SIZE_T_MAX;\n  return _gdbm_mapped_remap (dbf, 0, _REMAP_END);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_mapped_read": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "ssize_t\n_gdbm_mapped_read (GDBM_FILE dbf, void *buffer, size_t len)\n{\n  if (dbf->memory_mapping)\n    {\n      ssize_t total = 0;\n      char *cbuf = buffer;\n      \n      while (len)\n\t{\n\t  size_t nbytes;\n\n\t  if (_GDBM_NEED_REMAP (dbf))\n\t    {\n\t      off_t pos = _GDBM_MMAPPED_POS (dbf);\n\t      if (_gdbm_mapped_remap (dbf, SUM_FILE_SIZE (dbf, len),\n\t\t\t\t      _REMAP_DEFAULT))\n\t\t{\n\t\t  int rc;\n\n\t\t  if (dbf->need_recovery)\n\t\t    return -1;\n\n\t\t  /* Disable memory mapping and retry */\n\t\t  dbf->memory_mapping = FALSE;\n\t\t  if (lseek (dbf->desc, pos, SEEK_SET) != pos)\n\t\t    return total > 0 ? total : -1;\n\t\t  rc = read (dbf->desc, cbuf, len);\n\t\t  if (rc == -1)\n\t\t    return total > 0 ? total : -1;\n\t\t  return total + rc;\n\t\t}\n\t    }\n\n\t  nbytes = dbf->mapped_size - dbf->mapped_pos;\n\t  if (nbytes == 0)\n\t    break;\n\t  if (nbytes > len)\n\t    nbytes = len;\n\n\t  memcpy (cbuf, (char*) dbf->mapped_region + dbf->mapped_pos, nbytes);\n\t  cbuf += nbytes;\n\t  dbf->mapped_pos += nbytes;\n\t  total += nbytes;\n\t  len -= nbytes;\n\t}\n      return total;\n    }\n  return read (dbf->desc, buffer, len);\n}",
      "lines": 50,
      "depth": 17,
      "decorators": [
        "ssize_t"
      ]
    },
    "_gdbm_mapped_write": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "ssize_t\n_gdbm_mapped_write (GDBM_FILE dbf, void *buffer, size_t len)\n{\n  if (dbf->memory_mapping)\n    {\n      ssize_t total = 0;\n      char *cbuf = buffer;\n\n      while (len)\n\t{\n\t  size_t nbytes;\n\n\t  if (_GDBM_NEED_REMAP (dbf))\n\t    {\n\t      off_t pos = _GDBM_MMAPPED_POS (dbf);\n\t      if (_gdbm_mapped_remap (dbf, SUM_FILE_SIZE (dbf, len),\n\t\t\t\t      _REMAP_EXTEND))\n\t\t{\n\t\t  int rc;\n\n\t\t  if (dbf->need_recovery)\n\t\t    return -1;\n\n\t\t  dbf->memory_mapping = FALSE;\n\t\t  if (lseek (dbf->desc, pos, SEEK_SET) != pos)\n\t\t    return total > 0 ? total : -1;\n\t\t  rc = write (dbf->desc, cbuf, len);\n\t\t  if (rc == -1)\n\t\t    return total > 0 ? total : -1;\n\t\t  return total + rc;\n\t\t}\n\t    }\n\n\t  nbytes = dbf->mapped_size - dbf->mapped_pos;\n\t  if (nbytes == 0)\n\t    break;\n\t  if (nbytes > len)\n\t    nbytes = len;\n\n\t  memcpy ((char*) dbf->mapped_region + dbf->mapped_pos, cbuf, nbytes);\n\t  cbuf += nbytes;\n\t  dbf->mapped_pos += nbytes;\n\t  total += nbytes;\n\t  len -= nbytes;\n\t}\n      return total;\n    }\n  return write (dbf->desc, buffer, len);\n}",
      "lines": 49,
      "depth": 17,
      "decorators": [
        "ssize_t"
      ]
    },
    "_gdbm_mapped_lseek": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "off_t\n_gdbm_mapped_lseek (GDBM_FILE dbf, off_t offset, int whence)\n{\n  if (dbf->memory_mapping)\n    {\n      off_t needle;\n      \n      switch (whence)\n\t{\n\tcase SEEK_SET:\n\t  needle = offset;\n\t  break;\n\t  \n\tcase SEEK_CUR:\n\t  needle = offset + _GDBM_MMAPPED_POS (dbf);\n\t  break;\n\t  \n\tcase SEEK_END:\n\t  {\n \t    off_t file_size;\n\t    if (_gdbm_file_size (dbf, &file_size))\n\t      return -1;\n\t    needle = file_size - offset; \n\t    break;\n\t  }\n\t}\n\n      if (needle < 0)\n\t{\n\t  errno = EINVAL;\n\t  return -1;\n\t}\n      \n      if (!_GDBM_IN_MAPPED_REGION_P (dbf, needle))\n\t{\n\t  _gdbm_mapped_unmap (dbf);\n\t  dbf->mapped_off = needle;\n\t  dbf->mapped_pos = 0;\n\t}\n      else\n\tdbf->mapped_pos = needle - dbf->mapped_off;\n      return needle;\n    }\n  return lseek (dbf->desc, offset, whence);\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "off_t"
      ]
    },
    "_gdbm_mapped_sync": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "int\n_gdbm_mapped_sync (GDBM_FILE dbf)\n{\n  if (dbf->mapped_region)\n    {\n      return msync (dbf->mapped_region, dbf->mapped_size,\n\t\t    MS_SYNC | MS_INVALIDATE);\n    }\n  return fsync (dbf->desc);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/parseopt.c": {
    "optcmp": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\noptcmp (const void *a, const void *b)\n{\n  struct gdbm_option const *ap = (struct gdbm_option const *)a;\n  struct gdbm_option const *bp = (struct gdbm_option const *)b;\n\n  while (ap->opt_flags & PARSEOPT_ALIAS)\n    ap--;\n  while (bp->opt_flags & PARSEOPT_ALIAS)\n    bp--;\n  \n  if (IS_VALID_SHORT_OPTION(ap) && IS_VALID_SHORT_OPTION(bp))\n    return ap->opt_short - bp->opt_short;\n  if (IS_VALID_LONG_OPTION(ap) && IS_VALID_LONG_OPTION(bp))\n    return strcmp (ap->opt_long, bp->opt_long);\n  if (IS_VALID_LONG_OPTION(ap))\n    return 1;\n  return -1;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_options": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\nsort_options (int start, int count)\n{\n  qsort (option_tab + start, count, sizeof (option_tab[0]), optcmp);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sort_group": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static size_t\nsort_group (size_t start)\n{\n  size_t i;\n  \n  for (i = start; i < option_count && !IS_GROUP_HEADER (&option_tab[i]); i++)\n    ;\n  sort_options (start, i - start);\n  return i + 1;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "sort_all_options": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static void\nsort_all_options (void)\n{\n  size_t start;\n\n  /* Ensure sane start of options.  This is necessary because optcmp backs up\n     until it finds an element with cleared PARSEOPT_ALIAS flag bit. */\n  option_tab[0].opt_flags &= PARSEOPT_ALIAS;\n  for (start = 0; start < option_count; )\n    {\n      if (IS_GROUP_HEADER (&option_tab[start]))\n\tstart = sort_group (start + 1);\n      else \n\tstart = sort_group (start);\n    }\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_options": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "static void\nadd_options (struct gdbm_option *options)\n{\n  size_t optcnt = 0;\n  size_t argcnt = 0;\n  size_t count = 0;\n  struct gdbm_option *opt;\n  \n  for (opt = options; !OPT_END(opt); opt++)\n    {\n      count++;\n      if (IS_OPTION(opt))\n\t{\n\t  optcnt++;\n\t  if (opt->opt_arg)\n\t    argcnt++;\n\t}\n    }\n\n  if (option_count + count + 1 > option_max)\n    {\n      option_max = option_count + count + 1;\n      option_tab = erealloc (option_tab,\n\t\t\t     sizeof (option_tab[0]) * option_max);\n    }\n  \n#ifdef HAVE_GETOPT_LONG\n  if (long_option_count + optcnt + 1 > long_option_max)\n    {\n      long_option_max = long_option_count + optcnt + 1;\n      long_options = erealloc (long_options,\n\t\t\t       sizeof (long_options[0]) * long_option_max);\n    }\n#endif\n  if (short_option_count + optcnt + argcnt + 1 > short_option_max)\n    {\n      short_option_max = short_option_count + optcnt + argcnt + 1;\n      short_options = erealloc (short_options,\n\t\t\t\tsizeof (short_options[0]) * short_option_max);\n    }\n\n  for (opt = options; !OPT_END(opt); opt++)\n    {\n      option_tab[option_count++] = *opt;\n      if (!IS_OPTION (opt))\n\tcontinue;\n      if (IS_VALID_SHORT_OPTION (opt))\n\t{\n\t  short_options[short_option_count++] = opt->opt_short;\n\t  if (opt->opt_arg)\n\t    short_options[short_option_count++] = ':';\n\t}\n#ifdef HAVE_GETOPT_LONG\n      if (IS_VALID_LONG_OPTION (opt))\n\t{\n\t  long_options[long_option_count].name = opt->opt_long;\n\t  long_options[long_option_count].has_arg = opt->opt_arg != NULL;\n\t  long_options[long_option_count].flag = NULL;\n\t  long_options[long_option_count].val = opt->opt_short;\n\t  long_option_count++;\n\t}\n#endif\n    }\n  short_options[short_option_count] = 0;\n#ifdef HAVE_GETOPT_LONG\n  memset (&long_options[long_option_count], 0,\n\t  sizeof long_options[long_option_count]);\n#endif\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parseopt_first": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nparseopt_first (int pc, char **pv, struct gdbm_option *opts)\n{\n  free (option_tab);\n  free (short_options);\n  short_option_count = short_option_max = 0;\n#ifdef HAVE_GETOPT_LONG\n  free (long_options);\n  long_option_count = long_option_max = 0;\n#endif\n  add_options (opts);\n  add_options (parseopt_default_options);\n  opterr = 0;\n  argc = pc;\n  argv = pv;\n  return parseopt_next ();\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "indent": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static void\nindent (size_t start, size_t col)\n{\n  for (; start < col; start++)\n    putchar (' ');\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_option_descr": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static void\nprint_option_descr (const char *descr, size_t lmargin, size_t rmargin)\n{\n  if (!(descr && descr[0]))\n    return;\n  descr = gettext (descr);\n  while (*descr)\n    {\n      size_t s = 0;\n      size_t i;\n      size_t width = rmargin - lmargin;\n      \n      for (i = 0; ; i++)\n\t{\n\t  if (descr[i] == 0 || descr[i] == ' ' || descr[i] == '\\t')\n\t    {\n\t      if (i > width)\n\t\tbreak;\n\t      s = i;\n\t      if (descr[i] == 0)\n\t\tbreak;\n\t    }\n\t}\n      fwrite (descr, 1, s, stdout);\n      fputc ('\\n', stdout);\n      descr += s;\n      if (*descr)\n\t{\n\t  indent (0, lmargin);\n\t  descr++;\n\t}\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_option": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "size_t\nprint_option (size_t num)\n{\n  struct gdbm_option *opt = option_tab + num;\n  size_t next, i;\n  int delim;\n  int w;\n  \n  if (IS_GROUP_HEADER (opt))\n    {\n      indent (0, GROUPCOLUMN);\n      print_option_descr (opt->opt_descr, GROUPCOLUMN, RMARGIN);\n      putchar ('\\n');\n      return num + 1;\n    }\n\n  /* count aliases */\n  for (next = num + 1;\n       next < option_count && option_tab[next].opt_flags & PARSEOPT_ALIAS;\n       next++);\n\n  if (opt->opt_flags & PARSEOPT_HIDDEN)\n    return next;\n\n  w = 0;\n  for (i = num; i < next; i++)\n    {\n      if (IS_VALID_SHORT_OPTION (&option_tab[i]))\n\t{\n\t  if (w == 0)\n\t    {\n\t      indent (0, LMARGIN);\n\t      w = LMARGIN;\n\t    }\n\t  else\n\t    w += printf (\", \");\n\t  w += printf (\"-%c\", option_tab[i].opt_short);\n\t  delim = ' ';\n\t}\n    }\n#ifdef HAVE_GETOPT_LONG\n  for (i = num; i < next; i++)\n    {\n      if (IS_VALID_LONG_OPTION (&option_tab[i]))\n\t{\n\t  if (w == 0)\n\t    {\n\t      indent (0, LMARGIN);\n\t      w = LMARGIN;\n\t    }\n\t  else\n\t    w += printf (\", \");\n\t  w += printf (\"--%s\", option_tab[i].opt_long);\n\t  delim = '=';\n\t}\n    }\n#else\n  if (!w)\n    return next;\n#endif\n  if (opt->opt_arg)\n    {\n      argsused = 1;\n      w += printf (\"%c%s\", delim, gettext (opt->opt_arg));\n    }\n  if (w >= DESCRCOLUMN)\n    {\n      putchar ('\\n');\n      w = 0;\n    }\n  indent (w, DESCRCOLUMN);\n  print_option_descr (opt->opt_descr, DESCRCOLUMN, RMARGIN);\n\n  return next;\n}",
      "lines": 75,
      "depth": 14,
      "decorators": [
        "size_t"
      ]
    },
    "parseopt_print_help": {
      "start_point": [
        340,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "void\nparseopt_print_help (void)\n{\n  unsigned i;\n\n  argsused = 0;\n\n  printf (\"%s %s [%s]... %s\\n\", _(\"Usage:\"),\n\t  parseopt_program_name ? parseopt_program_name : progname,\n\t  _(\"OPTION\"),\n\t  gettext (parseopt_program_args));\n  print_option_descr (parseopt_program_doc, 0, RMARGIN);\n  putchar ('\\n');\n\n  sort_all_options ();\n  for (i = 0; i < option_count; )\n    {\n      i = print_option (i);\n    }\n  putchar ('\\n');\n#ifdef HAVE_GETOPT_LONG\n  if (argsused)\n    {\n      print_option_descr (N_(\"Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options.\"), 0, RMARGIN);\n      putchar ('\\n');\n    }\n#endif\n  if (parseopt_help_hook)\n    parseopt_help_hook (stdout);\n\n /* TRANSLATORS: The placeholder indicates the bug-reporting address\n    for this package.  Please add _another line_ saying\n    \"Report translation bugs to <...>\\n\" with the address for translation\n    bugs (typically your translation team's web or email address).  */\n  printf (_(\"Report bugs to %s.\\n\"), program_bug_address);\n  \n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#endif\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "cmpidx_short": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "static int\ncmpidx_short (const void *a, const void *b)\n{\n  unsigned const *ai = (unsigned const *)a;\n  unsigned const *bi = (unsigned const *)b;\n\n  return option_tab[*ai].opt_short - option_tab[*bi].opt_short;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmpidx_long": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "static int\ncmpidx_long (const void *a, const void *b)\n{\n  unsigned const *ai = (unsigned const *)a;\n  unsigned const *bi = (unsigned const *)b;\n  struct gdbm_option const *ap = option_tab + *ai;\n  struct gdbm_option const *bp = option_tab + *bi;\n  return strcmp (ap->opt_long, bp->opt_long);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_usage": {
      "start_point": [
        402,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "void\nprint_usage (void)\n{\n  unsigned i;\n  unsigned n;\n  char buf[RMARGIN+1];\n  unsigned *idxbuf;\n  unsigned nidx;\n  \n#define FLUSH\t\t\t\t\t\t\t\t\\\n  do\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      buf[n] = 0;\t\t\t\t\t\t\t\\\n      printf (\"%s\\n\", buf);\t\t\t\t\t\t\\\n      n = USAGECOLUMN;\t\t\t\t\t\t\t\\\n      memset (buf, ' ', n);\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  while (0)\n#define ADDC(c)\t\t\t\t\t\t\t        \\\n  do\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (n == RMARGIN) FLUSH;\t\t\t\t\t\t\\\n      buf[n++] = c;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  while (0)\n\n  idxbuf = ecalloc (option_count, sizeof (idxbuf[0]));\n\n  n = snprintf (buf, sizeof buf, \"%s %s \", _(\"Usage:\"),\n\t\tparseopt_program_name ? parseopt_program_name : progname);\n\n  /* Print a list of short options without arguments. */\n  for (i = nidx = 0; i < option_count; i++)\n    if (IS_VALID_SHORT_OPTION (&option_tab[i]) && !option_tab[i].opt_arg)\n      idxbuf[nidx++] = i;\n\n  if (nidx)\n    {\n      qsort (idxbuf, nidx, sizeof (idxbuf[0]), cmpidx_short);\n\n      ADDC ('[');\n      ADDC ('-');\n      for (i = 0; i < nidx; i++)\n\t{\n\t  ADDC (option_tab[idxbuf[i]].opt_short);\n\t}\n      ADDC (']');\n    }\n\n  /* Print a list of short options with arguments. */\n  for (i = nidx = 0; i < option_count; i++)\n    {\n      if (IS_VALID_SHORT_OPTION (&option_tab[i]) && option_tab[i].opt_arg)\n\tidxbuf[nidx++] = i;\n    }\n\n  if (nidx)\n    {\n      qsort (idxbuf, nidx, sizeof (idxbuf[0]), cmpidx_short);\n    \n      for (i = 0; i < nidx; i++)\n\t{\n\t  struct gdbm_option *opt = option_tab + idxbuf[i];\n\t  const char *arg = gettext (opt->opt_arg);\n\t  size_t len = 5 + strlen (arg) + 1;\n\t  \n\t  if (n + len > RMARGIN) FLUSH;\n\t  buf[n++] = ' ';\n\t  buf[n++] = '[';\n\t  buf[n++] = '-';\n\t  buf[n++] = opt->opt_short;\n\t  buf[n++] = ' ';\n\t  strcpy (&buf[n], arg);\n\t  n += strlen (arg);\n\t  buf[n++] = ']';\n\t}\n    }\n  \n#ifdef HAVE_GETOPT_LONG\n  /* Print a list of long options */\n  for (i = nidx = 0; i < option_count; i++)\n    {\n      if (IS_VALID_LONG_OPTION (&option_tab[i]))\n\tidxbuf[nidx++] = i;\n    }\n\n  if (nidx)\n    {\n      qsort (idxbuf, nidx, sizeof (idxbuf[0]), cmpidx_long);\n\t\n      for (i = 0; i < nidx; i++)\n\t{\n\t  struct gdbm_option *opt = option_tab + idxbuf[i];\n\t  const char *arg = opt->opt_arg ? gettext (opt->opt_arg) : NULL;\n\t  size_t len = 3 + strlen (opt->opt_long)\n\t                 + (arg ? 1 + strlen (arg) : 0);\n\t  if (n + len > RMARGIN) FLUSH;\n\t  buf[n++] = ' ';\n\t  buf[n++] = '[';\n\t  buf[n++] = '-';\n\t  buf[n++] = '-';\n\t  strcpy (&buf[n], opt->opt_long);\n\t  n += strlen (opt->opt_long);\n\t  if (opt->opt_arg)\n\t    {\n\t      buf[n++] = '=';\n\t      strcpy (&buf[n], arg);\n\t      n += strlen (arg);\n\t    }\n\t  buf[n++] = ']';\n\t}\n    }\n#endif\n  FLUSH;\n  free (idxbuf);\n}",
      "lines": 116,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "print_version_only": {
      "start_point": [
        530,
        0
      ],
      "end_point": [
        543,
        1
      ],
      "content": "void\nprint_version_only (void)\n{\n  printf (\"%s (%s) %s\\n\",\n\t   parseopt_program_name ? parseopt_program_name : progname,\n\t   PACKAGE_NAME,\n\t   PACKAGE_VERSION);\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  printf (version_etc_copyright, _(\"(C)\"), \"2011-2017\");\n  puts (license_text);\n  putchar ('\\n');\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "handle_option": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "static int\nhandle_option (int c)\n{\n  switch (c)\n    {\n    case 'h':\n      parseopt_print_help ();\n      exit (0);\n      \n    case 'V':\n      print_version_only ();\n      exit (0);\n      \n    case OPT_USAGE:\n      print_usage ();\n      exit (0);\n      \n    default:\n      break;\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parseopt_next": {
      "start_point": [
        569,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "int\nparseopt_next ()\n{\n  int rc;\n  \n  do\n    {\n#ifdef HAVE_GETOPT_LONG\n      rc = getopt_long (argc, argv, short_options, long_options, NULL);\n#else\n      rc = getopt (argc, argv, short_options);\n#endif\n    }\n  while (handle_option (rc));\n  return rc;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/progname.c": {
    "set_progname": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "void\nset_progname (const char *arg)\n{\n  const char *p = strrchr (arg, '/');\n  if (p)\n    ++p;\n  else\n    p = arg;\n  if (strncmp (p, \"lt-\", 3) == 0)\n    p += 3;\n  progname = p;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/proto.h": {
    "gdbm_file_read": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static inline ssize_t\ngdbm_file_read (GDBM_FILE dbf, void *buf, size_t size)\n{\n#if HAVE_MMAP\n  return _gdbm_mapped_read (dbf, buf, size);\n#else\n  return read (dbf->desc, buf, size);\n#endif\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "ssize_t"
      ]
    },
    "gdbm_file_write": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static inline ssize_t\ngdbm_file_write (GDBM_FILE dbf, void *buf, size_t size)\n{\n#if HAVE_MMAP\n  return _gdbm_mapped_write (dbf, buf, size);\n#else\n  return write (dbf->desc, buf, size);\n#endif\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "ssize_t"
      ]
    },
    "gdbm_file_seek": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static inline off_t\ngdbm_file_seek (GDBM_FILE dbf, off_t off, int whence)\n{\n#if HAVE_MMAP\n  return _gdbm_mapped_lseek (dbf, off, whence);\n#else\n  return lseek (dbf->desc, off, whence);\n#endif\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "off_t"
      ]
    },
    "gdbm_file_sync": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static inline void\ngdbm_file_sync (GDBM_FILE dbf)\n{\n#if HAVE_MMAP\n  _gdbm_mapped_sync (dbf);\n#elif HAVE_FSYNC\n  fsync (dbf->desc);\n#else\n  sync ();\n  sync ();\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/recover.c": {
    "gdbm_copy_meta": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\ngdbm_copy_meta (GDBM_FILE dst, GDBM_FILE src)\n{\n  struct stat st;\n\n  if (fstat (src->desc, &st))\n    {\n      GDBM_SET_ERRNO (src, GDBM_FILE_STAT_ERROR, src->need_recovery);\n      return -1;\n    }\n  if (fchown (dst->desc, st.st_uid, st.st_gid))\n    {\n      GDBM_SET_ERRNO (dst, GDBM_ERR_FILE_OWNER, dst->need_recovery);\n      return -1;\n    }\n  if (fchmod (dst->desc, st.st_mode & 0777))\n    {\n      GDBM_SET_ERRNO (dst, GDBM_ERR_FILE_MODE, dst->need_recovery);\n      return -1;\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "backup_name": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static char *\nbackup_name (char const *name)\n{\n  char *buf;\n  size_t len;\n  size_t suf_pos;\n  size_t suf_len;\n  \n#define INITIAL_SUFFIX \".~1~\"\n  \n  len = strlen (name + sizeof (INITIAL_SUFFIX));\n  buf = malloc (len);\n  if (!buf)\n    return NULL;\n  strcpy (buf, name);\n  suf_pos = strlen (buf) + 2; \n  suf_len = 1;\n  strcat (buf, INITIAL_SUFFIX);\n\n  while (access (buf, F_OK) == 0)\n    {\n      size_t i = suf_len;\n      while (buf[suf_pos + i - 1] == '9')\n\t{\n\t  buf[suf_pos + i - 1] = '0';\n\t  i--;\n\t  if (i == 0)\n\t    {\n\t      char *p = realloc (buf, ++len);\n\t      if (!p)\n\t\t{\n\t\t  SAVE_ERRNO (free (buf));\n\t\t  return NULL;\n\t\t}\n\t      memmove (p + suf_pos + 1, p + suf_pos, suf_len + 2);\n\t      buf = p;\n\t      suf_len++;\n\t      i++;\n\t    }\n\t}\n      ++buf[suf_pos + i - 1];\n    }\n  return buf;\n}",
      "lines": 44,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nbackup_name (char const *name)",
        "*"
      ]
    },
    "_gdbm_finish_transfer": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        185,
        2
      ],
      "content": "static int\n_gdbm_finish_transfer (GDBM_FILE dbf, GDBM_FILE new_dbf,\n\t\t       gdbm_recovery *rcvr, int flags)\n{\n  int i;\n  \n  /* Write everything. */\n  if (_gdbm_end_update (new_dbf))\n    {\n      gdbm_close (new_dbf);\n      return -1;\n    }\n  gdbm_sync (new_dbf);\n\n  if (gdbm_copy_meta (new_dbf, dbf))\n    {\n      gdbm_close (new_dbf);\n      return -1;\n    }\n  \n#if HAVE_MMAP\n  _gdbm_mapped_unmap (dbf);\n#endif\n\n  if (flags & GDBM_RCVR_BACKUP)\n    {\n      char *bkname = backup_name (dbf->name);\n      if (!bkname)\n\t{\n\t  SAVE_ERRNO (gdbm_close (new_dbf));\n\t  GDBM_SET_ERRNO (NULL, GDBM_BACKUP_FAILED, FALSE);\n\t  return -1;\n\t}\n      if (rename (dbf->name, bkname) != 0)\n\t{\n\t  SAVE_ERRNO (gdbm_close (new_dbf); free (bkname));\n\t  GDBM_SET_ERRNO (NULL, GDBM_BACKUP_FAILED, FALSE);\n\t  return -1;\n\t}\n      rcvr->backup_name = bkname;\n    }\n  \n  /* Move the new file to old name. */\n\n  if (rename (new_dbf->name, dbf->name) != 0)\n    {\n      GDBM_SET_ERRNO (NULL, GDBM_REORGANIZE_FAILED, FALSE);\n      gdbm_close (new_dbf);\n      return -1;\n    }\n\n  /* Fix up DBF to have the correct information for the new file. */\n  if (dbf->file_locking)\n    _gdbm_unlock_file (dbf);\n  close (dbf->desc);\n  free (dbf->header);\n  free (dbf->dir);\n\n  if (dbf->bucket_cache != NULL)\n    {\n      for (i = 0; i < dbf->cache_size; i++)\n\t {\n\t   free (dbf->bucket_cache[i].ca_bucket);\n\t   free (dbf->bucket_cache[i].ca_data.dptr);\n\t }\n      free (dbf->bucket_cache);\n   }\n\n   dbf->desc              = new_dbf->desc;\n   dbf->header            = new_dbf->header;\n   dbf->dir               = new_dbf->dir;\n   dbf->bucket            = new_dbf->bucket;\n   dbf->bucket_dir        = new_dbf->bucket_dir;\n   dbf->last_read         = new_dbf->last_read;\n   dbf->bucket_cache      = new_dbf->bucket_cache;\n   dbf->cache_size        = new_dbf->cache_size;\n   dbf->header_changed    = new_dbf->header_changed;\n   dbf->directory_changed = new_dbf->directory_changed;\n   dbf->bucket_changed    = new_dbf->bucket_changed;\n   dbf->second_changed    = new_dbf->second_changed;\n\n   free (new_dbf->name);\n   free (new_dbf);\n   \n #if HAVE_MMAP\n   /* Re-initialize mapping if required */\n   if (dbf->memory_mapping)\n     _gdbm_mapped_init (dbf);\n #endif\n\n   /* Make sure the new database is all on disk. */\n   gdbm_file_sync (dbf);\n\n   /* Force the right stuff for a correct bucket cache. */\n   dbf->cache_entry    = &dbf->bucket_cache[0];\n   return _gdbm_get_bucket (dbf, 0);\n }",
      "lines": 97,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_gdbm_next_bucket_dir": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "int\n_gdbm_next_bucket_dir (GDBM_FILE dbf, int bucket_dir)\n{\n  int dir_count = GDBM_DIR_COUNT (dbf);\n  if (bucket_dir < 0 || bucket_dir >= dir_count)\n    bucket_dir = dir_count;\n  else\n    {\n      off_t cur = dbf->dir[bucket_dir];\n      while (++bucket_dir < dir_count && cur == dbf->dir[bucket_dir])\n\t;\n    }\n  return bucket_dir;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "check_db": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "static int\ncheck_db (GDBM_FILE dbf)\n{\n  int bucket_dir, i;\n  int nbuckets = GDBM_DIR_COUNT (dbf);\n\n  for (bucket_dir = 0; bucket_dir < nbuckets;\n       bucket_dir = _gdbm_next_bucket_dir (dbf, bucket_dir))\n    {      \n      if (_gdbm_get_bucket (dbf, bucket_dir))\n\treturn 1;\n      else\n\t{\n\t  if (dbf->bucket->count < 0\n\t      || dbf->bucket->count > dbf->header->bucket_elems)\n\t    return 1;\n\t  for (i = 0; i < dbf->header->bucket_elems; i++)\n\t    {\n\t      char *dptr;\n\t      datum key;\n\t      int hashval, bucket, off;\n\n\t      if (dbf->bucket->h_table[i].hash_value == -1)\n\t\tcontinue;\n\t      dptr = _gdbm_read_entry (dbf, i);\n\t      if (!dptr)\n\t\treturn 1;\n\t      \n\t      key.dptr   = dptr;\n\t      key.dsize  = dbf->bucket->h_table[i].key_size;\n\n\t      if (memcmp (dbf->bucket->h_table[i].key_start, key.dptr,\n\t\t\t  (SMALL < key.dsize ? SMALL : key.dsize)))\n\t\treturn 1;\n\t      \n\t      _gdbm_hash_key (dbf, key, &hashval, &bucket, &off);\n\t      if (bucket >= nbuckets)\n\t\treturn 1;\n\t      if (hashval != dbf->bucket->h_table[i].hash_value)\n\t\treturn 1;\n\t      if (dbf->dir[bucket] != dbf->dir[bucket_dir])\n\t\treturn 1;\n\t    }\n\t}\n    }\n  return 0;\n}",
      "lines": 47,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "run_recovery": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "static int\nrun_recovery (GDBM_FILE dbf, GDBM_FILE new_dbf, gdbm_recovery *rcvr, int flags)\n{\n  int bucket_dir, i;\n  int nbuckets = GDBM_DIR_COUNT (dbf);\n\n  for (bucket_dir = 0; bucket_dir < nbuckets;\n       bucket_dir = _gdbm_next_bucket_dir (dbf, bucket_dir))\n    {\n      \n      if (_gdbm_get_bucket (dbf, bucket_dir))\n\t{\n\t  if (flags & GDBM_RCVR_ERRFUN)\n\t    rcvr->errfun (rcvr->data, _(\"can't read bucket #%d: %s\"),\n\t\t\t  bucket_dir,\n\t\t\t  gdbm_db_strerror (dbf));\n\t  rcvr->failed_buckets++;\n\t  if ((flags & GDBM_RCVR_MAX_FAILED_BUCKETS)\n\t      && rcvr->failed_buckets == rcvr->max_failed_buckets)\n\t    return -1;\n\t  if ((flags & GDBM_RCVR_MAX_FAILURES)\n\t      && (rcvr->failed_buckets + rcvr->failed_keys) == rcvr->max_failures)\n\t    return -1;\n\t}\n      else\n\t{\n\t  rcvr->recovered_buckets++;\n\t  for (i = 0; i < dbf->header->bucket_elems; i++)\n\t    {\n\t      char *dptr;\n\t      datum key, data;\n\t    \n\t      if (dbf->bucket->h_table[i].hash_value == -1)\n\t\tcontinue;\n\t      dptr = _gdbm_read_entry (dbf, i);\n\t      if (dptr)\n\t\trcvr->recovered_keys++;\n\t      else\n\t\t{\n\t\t  if (flags & GDBM_RCVR_ERRFUN)\n\t\t    rcvr->errfun (rcvr->data,\n\t\t\t\t  _(\"can't read key pair %d:%d (%lu:%d): %s\"),\n\t\t\t\t  bucket_dir, i,\n\t\t\t\t  (unsigned long) dbf->bucket->h_table[i].data_pointer,\n\t\t\t\t  dbf->bucket->h_table[i].key_size\n\t\t\t\t    + dbf->bucket->h_table[i].data_size,\n\t\t\t\t  gdbm_db_strerror (dbf));\n\t\t  rcvr->failed_keys++;\n\t\t  if ((flags & GDBM_RCVR_MAX_FAILED_KEYS)\n\t\t      && rcvr->failed_keys == rcvr->max_failed_keys)\n\t\t    return -1;\n\t\t  if ((flags & GDBM_RCVR_MAX_FAILURES)\n\t\t      && (rcvr->failed_buckets + rcvr->failed_keys) == rcvr->max_failures)\n\t\t    return -1;\n\t\t  continue;\n\t\t}\n\n\t      key.dptr   = dptr;\n\t      key.dsize  = dbf->bucket->h_table[i].key_size;\n\n\t      data.dptr  = dptr + key.dsize;\n\t      data.dsize = dbf->bucket->h_table[i].data_size;\n\t    \n\t      if (gdbm_store (new_dbf, key, data, GDBM_INSERT) != 0)\n\t\t{\n\t\t  switch (gdbm_last_errno (new_dbf))\n\t\t    {\n\t\t    case GDBM_CANNOT_REPLACE:\n\t\t      rcvr->duplicate_keys++;\n\t\t      if (flags & GDBM_RCVR_ERRFUN)\n\t\t\trcvr->errfun (rcvr->data,\n\t\t          _(\"ignoring duplicate key %d:%d (%lu:%d)\"),\n\t\t\t  bucket_dir, i,\n\t\t\t  (unsigned long) dbf->bucket->h_table[i].data_pointer,\n\t\t\t  dbf->bucket->h_table[i].key_size\n\t\t\t\t      + dbf->bucket->h_table[i].data_size);\n\t\t      break;\n\t\t      \n\t\t    default:\n\t\t      if (flags & GDBM_RCVR_ERRFUN)\n\t\t\trcvr->errfun (rcvr->data,\n\t\t\t  _(\"fatal: can't store element %d:%d (%lu:%d): %s\"),\n\t\t\t  bucket_dir, i,\n\t\t\t  (unsigned long) dbf->bucket->h_table[i].data_pointer,\n\t\t\t  dbf->bucket->h_table[i].key_size\n\t\t\t\t    + dbf->bucket->h_table[i].data_size,\n\t\t\t  gdbm_db_strerror (new_dbf));\n\t\t      return -1;\n\t\t    }\n\t\t}\t\n\t    }\n\t}\n    }\n  \n  return 0;\n}",
      "lines": 96,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gdbm_recover": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "int\ngdbm_recover (GDBM_FILE dbf, gdbm_recovery *rcvr, int flags)\n{ \n  GDBM_FILE new_dbf;\t     /* The new file. */\n  char *new_name;\t     /* A temporary name. */\n  size_t len;\n  int fd;\n  int rc;\n  gdbm_recovery rs;\n  \n  /* Readers can not reorganize! */\n  if (dbf->read_write == GDBM_READER)\n    {\n      GDBM_SET_ERRNO (dbf, GDBM_READER_CANT_REORGANIZE, dbf->need_recovery);\n      return -1;\n    }\n\n  /* Initialize gdbm_recovery structure */\n  if (!rcvr)\n    {\n      rcvr  = &rs;\n      flags = 0;\n    }\n  rcvr->recovered_keys = 0;\n  rcvr->recovered_buckets = 0;\n  rcvr->failed_keys = 0;\n  rcvr->failed_buckets = 0;\n  rcvr->duplicate_keys = 0;\n  rcvr->backup_name = NULL;\n\n  rc = 0;\n  if ((flags & GDBM_RCVR_FORCE) || check_db (dbf))\n    {\n      gdbm_clear_error (dbf);\n      len = strlen (dbf->name);\n      new_name = malloc (len + sizeof (TMPSUF));\n      if (!new_name)\n\t{\n\t  GDBM_SET_ERRNO (NULL, GDBM_MALLOC_ERROR, FALSE);\n\t  return -1;\n\t}\n      strcat (strcpy (new_name, dbf->name), TMPSUF);\n  \n      fd = mkstemp (new_name);\n      if (fd == -1)\n\t{\n\t  GDBM_SET_ERRNO (NULL, GDBM_FILE_OPEN_ERROR, FALSE);\n\t  free (new_name);\n\t  return -1;\n\t}\n  \n      new_dbf = gdbm_fd_open (fd, new_name, dbf->header->block_size,\n\t\t\t      GDBM_WRCREAT\n\t\t\t      | (dbf->cloexec ? GDBM_CLOEXEC : 0)\n\t\t\t      | GDBM_CLOERROR, dbf->fatal_err);\n  \n      SAVE_ERRNO (free (new_name));\n  \n      if (new_dbf == NULL)\n\t{\n\t  GDBM_SET_ERRNO (NULL, GDBM_REORGANIZE_FAILED, FALSE);\n\t  return -1;\n\t}\n\n      rc = run_recovery (dbf, new_dbf, rcvr, flags);\n  \n      if (rc == 0)\n\trc = _gdbm_finish_transfer (dbf, new_dbf, rcvr, flags);\n      else\n\tgdbm_close (new_dbf);\n    }\n\n  if (rc == 0)\n    {\n      gdbm_clear_error (dbf);\n      dbf->need_recovery = FALSE;\n    }\n\n  return rc;\n}",
      "lines": 80,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/systems.h": {},
  "gdbm/gdbm-1.15/src/update.c": {
    "write_header": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static int\nwrite_header (GDBM_FILE dbf)\n{\n  off_t file_pos;\t/* Return value for lseek. */\n  int rc;\n\n  file_pos = gdbm_file_seek (dbf, 0L, SEEK_SET);\n  if (file_pos != 0)\n    {\n      GDBM_SET_ERRNO2 (dbf, GDBM_FILE_SEEK_ERROR, TRUE, GDBM_DEBUG_STORE);\n      _gdbm_fatal (dbf, _(\"lseek error\"));\n      return -1;\n    }\n\n  rc = _gdbm_full_write (dbf, dbf->header, dbf->header->block_size);\n  \n  if (rc)\n    {\n      GDBM_DEBUG (GDBM_DEBUG_STORE|GDBM_DEBUG_ERR,\n\t\t  \"%s: error writing header: %s\",\n\t\t  dbf->name, gdbm_db_strerror (dbf));\t        \n      return -1;\n    }\n\n  /* Sync the file if fast_write is FALSE. */\n  if (dbf->fast_write == FALSE)\n    gdbm_file_sync (dbf);\n\n  return 0;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_gdbm_end_update": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\n_gdbm_end_update (GDBM_FILE dbf)\n{\n  off_t file_pos;\t/* Return value for lseek. */\n  int rc;\n  \n  /* Write the current bucket. */\n  if (dbf->bucket_changed && (dbf->cache_entry != NULL))\n    {\n      if (_gdbm_write_bucket (dbf, dbf->cache_entry))\n\treturn -1;\n      dbf->bucket_changed = FALSE;\n    }\n\n  /* Write the other changed buckets if there are any. */\n  if (dbf->second_changed)\n    {\n      if (dbf->bucket_cache != NULL)\n        {\n          int index;\n\n          for (index = 0; index < dbf->cache_size; index++)\n\t    {\n\t      if (dbf->bucket_cache[index].ca_changed)\n\t\t{\n\t\t  if (_gdbm_write_bucket (dbf, &dbf->bucket_cache[index]))\n\t\t    return -1;\n\t\t}\n            }\n        }\n      dbf->second_changed = FALSE;\n    }\n  \n  /* Write the directory. */\n  if (dbf->directory_changed)\n    {\n      file_pos = gdbm_file_seek (dbf, dbf->header->dir, SEEK_SET);\n      if (file_pos != dbf->header->dir)\n\t{\n\t  GDBM_SET_ERRNO2 (dbf, GDBM_FILE_SEEK_ERROR, TRUE, GDBM_DEBUG_STORE);\n\t  _gdbm_fatal (dbf, _(\"lseek error\"));\n\t  return -1;\n\t}\n\n      rc = _gdbm_full_write (dbf, dbf->dir, dbf->header->dir_size);\n      if (rc)\n\t{\n\t  GDBM_DEBUG (GDBM_DEBUG_STORE|GDBM_DEBUG_ERR,\n\t\t      \"%s: error writing directory: %s\",\n\t\t      dbf->name, gdbm_db_strerror (dbf));\t  \t  \n\t  _gdbm_fatal (dbf, gdbm_db_strerror (dbf));\n\t  return -1;\n\t}\n\n      dbf->directory_changed = FALSE;\n      if (!dbf->header_changed && dbf->fast_write == FALSE)\n\tgdbm_file_sync (dbf);\n    }\n\n  /* Final write of the header. */\n  if (dbf->header_changed)\n    {\n      if (write_header (dbf))\n\treturn -1;\n      if (_gdbm_file_extend (dbf, dbf->header->next_block))\n\treturn -1;\n      dbf->header_changed = FALSE;\n    }\n\n  return 0;\n}",
      "lines": 71,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_gdbm_fatal": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "void\n_gdbm_fatal (GDBM_FILE dbf, const char *val)\n{\n  if (dbf && dbf->fatal_err)\n    {\n      (*dbf->fatal_err) (val);\n      exit (1);\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/util.c": {
    "mkfilename": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "char *\nmkfilename (const char *dir, const char *file, const char *suf)\n{\n  char *tmp;\n  size_t dirlen = strlen (dir);\n  size_t suflen = suf ? strlen (suf) : 0;\n  size_t fillen = strlen (file);\n  size_t len;\n  \n  while (dirlen > 0 && dir[dirlen-1] == '/')\n    dirlen--;\n\n  len = dirlen + (dir[0] ? 1 : 0) + fillen + suflen;\n  tmp = emalloc (len + 1);\n  memcpy (tmp, dir, dirlen);\n  if (dir[0])\n    tmp[dirlen++] = '/';\n  memcpy (tmp + dirlen, file, fillen);\n  if (suf)\n    memcpy (tmp + dirlen + fillen, suf, suflen);\n  tmp[len] = 0;\n  return tmp;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "char",
        "*\nmkfilename (const char *dir, const char *file, const char *suf)",
        "*"
      ]
    },
    "tildexpand": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "char *\ntildexpand (char *s)\n{\n  if (s[0] == '~')\n    {\n      char *p = s + 1;\n      size_t len = strcspn (p, \"/\");\n      struct passwd *pw;\n\n      if (len == 0)\n\tpw = getpwuid (getuid ());\n      else\n\t{\n\t  char *user = emalloc (len + 1);\n\t  \n\t  memcpy (user, p, len);\n\t  user[len] = 0;\n\t  pw = getpwnam (user);\n\t  free (user);\n\t}\n      if (pw)\n\treturn mkfilename (pw->pw_dir, p + len + 1, NULL);\n    }\n  return estrdup (s);\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "char",
        "*\ntildexpand (char *s)",
        "*"
      ]
    },
    "vgetyn": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int\nvgetyn (const char *prompt, va_list ap)\n{\n  int state = 0;\n  int c, resp;\n\n  do\n    {\n      switch (state)\n\t{\n\tcase 1:\n\t  if (c == ' ' || c == '\\t')\n\t    continue;\n\t  resp = c;\n\t  state = 2;\n\t  /* fall through */\n\tcase 2:\n\t  if (c == '\\n')\n\t    {\n\t      switch (resp)\n\t\t{\n\t\tcase 'y':\n\t\tcase 'Y':\n\t\t  return 1;\n\t\tcase 'n':\n\t\tcase 'N':\n\t\t  return 0;\n\t\tdefault:\n\t\t  fprintf (stdout, \"%s\\n\", _(\"Please, reply 'y' or 'n'\"));\n\t\t}\n\t      state = 0;\n\t    } else\n\t    break;\n\t  \n\tcase 0:\n\t  vfprintf (stdout, prompt, ap);\n\t  fprintf (stdout, \" [y/n]?\");\n\t  fflush (stdout);\n\t  state = 1;\n\t  break;\n\t}\n    } while ((c = getchar ()) != EOF);\n  exit (EXIT_USAGE);\n}",
      "lines": 44,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "getyn": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\ngetyn (const char *prompt, ...)\n{\n  va_list ap;\n  int rc;\n  \n  va_start (ap, prompt);\n  rc = vgetyn (prompt, ap);\n  va_end (ap);\n  return rc;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/var.c": {
    "open_hook": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static int\nopen_hook (struct variable *var, union value *v)\n{\n  static struct {\n    char *s;\n    int t;\n  } trans[] = {\n    { \"newdb\", GDBM_NEWDB },\n    { \"wrcreat\", GDBM_WRCREAT },\n    { \"rw\", GDBM_WRCREAT },\n    { \"reader\", GDBM_READER },\n    { \"readonly\", GDBM_READER },\n    { NULL }\n  };\n  int i;\n\n  if (!v)\n    return VAR_ERR_BADVALUE;\n  \n  for (i = 0; trans[i].s; i++)\n    if (strcmp (trans[i].s, v->string) == 0)\n      {\n\topen_mode = trans[i].t;\n\treturn VAR_OK;\n      }\n\n  return VAR_ERR_BADVALUE;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "varfind": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static struct variable *\nvarfind (const char *name)\n{\n  struct variable *vp;\n\n  for (vp = vartab; vp->name; vp++)\n    if (strcmp (vp->name, name) == 0)\n      return vp;\n  \n  return NULL;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct variable",
        "struct",
        "variable",
        "*\nvarfind (const char *name)",
        "*"
      ]
    },
    "s2s": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static int\ns2s (union value *vp, void *val, int flags)\n{\n  vp->string = estrdup (val);\n  return VAR_OK;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "b2s": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static int\nb2s (union value *vp, void *val, int flags)\n{\n  vp->string = estrdup (*(int*)val ? \"true\" : \"false\");\n  return VAR_OK;\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "i2s": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static int\ni2s (union value *vp, void *val, int flags)\n{\n  char buf[128];\n  snprintf (buf, sizeof buf, \"%d\", *(int*)val);\n  vp->string = estrdup (buf);\n  return VAR_OK;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "s2b": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\ns2b (union value *vp, void *val, int flags)\n{\n  static char *trueval[] = { \"on\", \"true\", \"yes\", NULL };\n  static char *falseval[] = { \"off\", \"false\", \"no\", NULL };\n  int i;\n  unsigned long n;\n  char *p;\n  \n  for (i = 0; trueval[i]; i++)\n    if (strcasecmp (trueval[i], val) == 0)\n      {\n\tvp->bool = 1;\n\treturn VAR_OK;\n      }\n  \n  for (i = 0; falseval[i]; i++)\n    if (strcasecmp (falseval[i], val) == 0)\n      {\n\tvp->bool = 0;\n\treturn VAR_OK;\n      }\n  \n  n = strtoul (val, &p, 0);\n  if (*p)\n    return VAR_ERR_BADTYPE;\n  vp->bool = !!n;\n  return VAR_OK;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "s2i": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static int\ns2i (union value *vp, void *val, int flags)\n{\n  char *p;\n  int n = strtoul (val, &p, (flags & VARF_OCTAL) ? 8 : 10);\n\n  if (*p)\n    return VAR_ERR_BADTYPE;\n\n  vp->num = n;\n  return VAR_OK;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "b2b": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "static int\nb2b (union value *vp, void *val, int flags)\n{\n  vp->bool = !!*(int*)val;\n  return VAR_OK;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "b2i": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "static int\nb2i (union value *vp, void *val, int flags)\n{\n  vp->num = *(int*)val;\n  return VAR_OK;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "i2i": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static int\ni2i (union value *vp, void *val, int flags)\n{\n  vp->num = *(int*)val;\n  return VAR_OK;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "i2b": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static int\ni2b (union value *vp, void *val, int flags)\n{\n  vp->bool = *(int*)val;\n  return VAR_OK;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "variable_set": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "int\nvariable_set (const char *name, int type, void *val)\n{\n  struct variable *vp = varfind (name);\n  int rc;\n  union value v, *valp;\n  \n  if (!vp)\n    return VAR_ERR_NOTDEF;\n\n  if (val)\n    {\n      memset (&v, 0, sizeof (v));\n      rc = setvar[vp->type][type] (&v, val, vp->flags);\n      if (rc)\n\treturn rc;\n      valp = &v; \n    }\n  else\n    {\n      if (vp->flags & VARF_PROT)\n\treturn VAR_ERR_BADVALUE;\n      valp = NULL;\n    }\n  \n  if (vp->hook && (rc = vp->hook (vp, valp)) != VAR_OK)\n    return rc;\n\n  if (vp->type == VART_STRING && (vp->flags & VARF_SET))\n    free (vp->v.string);\n\n  if (!val)\n    {\n      vp->flags &= (VARF_INIT|VARF_SET);\n    }\n  else\n    {\n      vp->v = v;\n      vp->flags &= ~VARF_INIT;\n      vp->flags |= VARF_SET;\n    }\n  \n  return VAR_OK;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "variable_unset": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "int\nvariable_unset (const char *name)\n{\n  struct variable *vp = varfind (name);\n  int rc;\n    \n  if (!vp)\n    return VAR_ERR_NOTDEF;\n  if (vp->flags & VARF_PROT)\n    return VAR_ERR_BADVALUE;\n\n  if (vp->hook && (rc = vp->hook (vp, NULL)) != VAR_OK)\n    return rc;\n\n  vp->flags &= ~(VARF_INIT|VARF_SET);\n\n  return VAR_OK;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "variable_get": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\nvariable_get (const char *name, int type, void **val)\n{\n  struct variable *vp = varfind (name);\n\n  if (!vp)\n    return VAR_ERR_NOTDEF;\n  \n  if (type != vp->type)\n    return VAR_ERR_BADTYPE;\n\n  if (!VAR_IS_SET (vp))\n    return VAR_ERR_NOTSET;\n  \n  switch (vp->type)\n    {\n    case VART_STRING:\n      *val = vp->v.string;\n      break;\n\n    case VART_BOOL:\n      *(int*)val = vp->v.bool;\n      break;\n      \n    case VART_INT:\n      *(int*)val = vp->v.num;\n      break;\n    }\n\n  return VAR_OK;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "varcmp": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "static int\nvarcmp (const void *a, const void *b)\n{\n  return strcmp (((struct variable const *)a)->name,\n\t\t ((struct variable const *)b)->name);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "variable_print_all": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "void\nvariable_print_all (FILE *fp)\n{\n  struct variable *vp;\n  char *s;\n  static int sorted;\n  \n  if (!sorted)\n    {\n      qsort (vartab, sizeof (vartab) / sizeof (vartab[0]) - 1,\n\t     sizeof (vartab[0]), varcmp);\n      sorted = 1;\n    }\n  \n  for (vp = vartab; vp->name; vp++)\n    {\n      if (!VAR_IS_SET (vp))\n\t{\n\t  fprintf (fp, \"# %s is unset\", vp->name);\n\t}\n      else\n\t{\n\t  switch (vp->type)\n\t    {\n\t    case VART_INT:\n\t      fprintf (fp, (vp->flags & VARF_OCTAL) ? \"%s=%03o\" : \"%s=%d\",\n\t\t       vp->name, vp->v.num);\n\t      break;\n\t      \n\t    case VART_BOOL:\n\t      fprintf (fp, \"%s%s\", vp->v.bool ? \"\" : \"no\", vp->name);\n\t      break;\n\t      \n\t    case VART_STRING:\n\t      fprintf (fp, \"%s=\\\"\", vp->name);\n\t      for (s = vp->v.string; *s; s++)\n\t\t{\n\t\t  int c;\n\t\t  \n\t\t  if (isprint (*s))\n\t\t    fputc (*s, fp);\n\t\t  else if ((c = escape (*s)))\n\t\t    fprintf (fp, \"\\\\%c\", c);\n\t\t  else\n\t\t    fprintf (fp, \"\\\\%03o\", *s);\n\t\t}\n\t      fprintf (fp, \"\\\"\");\n\t    }\n\t}\n      fputc ('\\n', fp);\n    }\n}",
      "lines": 52,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "variable_is_set": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "int\nvariable_is_set (const char *name)\n{\n  struct variable *vp = varfind (name);\n\n  if (!vp)\n    return 0;\n  return VAR_IS_SET (vp);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "variable_is_true": {
      "start_point": [
        377,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "int\nvariable_is_true (const char *name)\n{\n  int n;\n\n  if (variable_get (name, VART_BOOL, (void **) &n) == VAR_OK)\n    return n;\n  return 0;\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/src/version.c": {
    "gdbm_version_cmp": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\ngdbm_version_cmp (int const a[], int const b[])\n{\n  if (a[0] > b[0])\n    return 1;\n  else if (a[0] < b[0])\n    return -1;\n\n  if (a[1] > b[1])\n    return 1;\n  else if (a[1] < b[1])\n    return -1;\n\n  if (a[2] > b[2])\n    return 1;\n  else if (a[2] < b[2])\n    return -1;\n\n  return 0;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/dtdel.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *progname = canonical_progname (argv[0]);\n  char *dbname;\n  datum key;\n  int flags = 0;\n  int data_z = 0;\n  int rc = 0;\n  \n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      if (strcmp (arg, \"-h\") == 0)\n\t{\n\t  printf (\"usage: %s [-null] [-nolock] [-nommap] [-sync] DBFILE KEY [KEY...]\\n\",\n\t\t  progname);\n\t  exit (0);\n\t}\n      else if (strcmp (arg, \"-null\") == 0)\n\tdata_z = 1;\n      else if (strcmp (arg, \"-nolock\") == 0)\n\tflags |= GDBM_NOLOCK;\n      else if (strcmp (arg, \"-nommap\") == 0)\n\tflags |= GDBM_NOMMAP;\n      else if (strcmp (arg, \"-sync\") == 0)\n\tflags |= GDBM_SYNC;\n      else if (strcmp (arg, \"--\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  break;\n\t}\n      else if (arg[0] == '-')\n\t{\n\t  fprintf (stderr, \"%s: unknown option %s\\n\", progname, arg);\n\t  exit (1);\n\t}\n      else\n\tbreak;\n    }\n\n  if (argc < 2)\n    {\n      fprintf (stderr, \"%s: wrong arguments\\n\", progname);\n      exit (1);\n    }\n  dbname = *argv;\n  \n  if (dbminit (dbname))\n    {\n      fprintf (stderr, \"dbminit failed\\n\");\n      exit (1);\n    }\n\n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      key.dptr = arg;\n      key.dsize = strlen (arg) + !!data_z;\n\n      if (delete(key))\n\t{\n\t  fprintf (stderr, \"%s: cannot delete %s: %s\\n\",\n\t\t   progname, arg, gdbm_strerror (gdbm_errno));\n\t  rc = 2;\n\t}\n    }\n  dbmclose ();\n  exit (rc);\n}",
      "lines": 73,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/dtdump.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *progname = canonical_progname (argv[0]);\n  char *dbname;\n  datum key;\n  datum data;\n  int delim = '\\t';\n  \n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      if (strcmp (arg, \"-h\") == 0)\n\t{\n\t  printf (\"usage: %s [-delim=CHR] DBFILE\\n\", progname);\n\t  exit (0);\n\t}\n      else if (strncmp (arg, \"-delim=\", 7) == 0)\n\tdelim = arg[7];\n      else if (strcmp (arg, \"--\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  break;\n\t}\n      else if (arg[0] == '-')\n\t{\n\t  fprintf (stderr, \"%s: unknown option %s\\n\", progname, arg);\n\t  exit (1);\n\t}\n      else\n\tbreak;\n    }\n\n  if (argc != 1)\n    {\n      fprintf (stderr, \"%s: wrong arguments\\n\", progname);\n      exit (1);\n    }\n  dbname = *argv;\n  \n  if (dbminit (dbname))\n    {\n      fprintf (stderr, \"dbminit failed\\n\");\n      exit (1);\n    }\n\n  for (key = firstkey (); key.dptr; key = nextkey (key))\n    {\n      int i;\n      \n      for (i = 0; i < key.dsize && key.dptr[i]; i++)\n\t{\n\t  if (key.dptr[i] == delim || key.dptr[i] == '\\\\')\n\t    fputc ('\\\\', stdout);\n\t  fputc (key.dptr[i], stdout);\n\t}\n\n      fputc (delim, stdout);\n\n      data = fetch (key);\n      i = data.dsize;\n      if (data.dptr[i-1] == 0)\n\ti--;\n      \n      fwrite (data.dptr, i, 1, stdout);\n      \n      fputc ('\\n', stdout);\n    }\n\n  dbmclose ();\n  exit (0);\n}",
      "lines": 74,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/dtfetch.c": {
    "print_key": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "void\nprint_key (FILE *fp, datum key, int delim)\n{\n  size_t i;\n  \n  for (i = 0; i < key.dsize && key.dptr[i]; i++)\n    {\n      if (key.dptr[i] == delim || key.dptr[i] == '\\\\')\n\tfputc ('\\\\', fp);\n      fputc (key.dptr[i], fp);\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *progname = canonical_progname (argv[0]);\n  char *dbname;\n  datum key;\n  datum data;\n  int data_z = 0;\n  int delim = 0;\n  int rc = 0;\n  \n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      if (strcmp (arg, \"-h\") == 0)\n\t{\n\t  printf (\"usage: %s [-null] [-delim=CHR] DBFILE KEY [KEY...]\\n\",\n\t\t  progname);\n\t  exit (0);\n\t}\n      else if (strcmp (arg, \"-null\") == 0)\n\tdata_z = 1;\n      else if (strncmp (arg, \"-delim=\", 7) == 0)\n\tdelim = arg[7];\n      else if (strcmp (arg, \"--\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  break;\n\t}\n      else if (arg[0] == '-')\n\t{\n\t  fprintf (stderr, \"%s: unknown option %s\\n\", progname, arg);\n\t  exit (1);\n\t}\n      else\n\tbreak;\n    }\n\n  if (argc < 2)\n    {\n      fprintf (stderr, \"%s: wrong arguments\\n\", progname);\n      exit (1);\n    }\n  dbname = *argv;\n\n  if (dbminit (dbname))\n    {\n      fprintf (stderr, \"dbminit failed\\n\");\n      exit (1);\n    }\n\n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      key.dptr = arg;\n      key.dsize = strlen (arg) + !!data_z;\n\n      data = fetch (key);\n      if (data.dptr == NULL)\n\t{\n\t  rc = 2;\n\t  fprintf (stderr, \"%s: \", progname);\n\t  print_key (stderr, key, delim);\n\t  fprintf (stderr, \": not found\\n\");\n\t  continue;\n\t}\n      if (delim)\n\t{\n\t  print_key (stdout, key, delim);\n\t  fputc (delim, stdout);\n\t}\n\n      fwrite (data.dptr, data.dsize - !!data_z, 1, stdout);\n      \n      fputc ('\\n', stdout);\n    }\n\n  dbmclose ();\n  exit (rc);\n}",
      "lines": 83,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/dtload.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *progname = canonical_progname (argv[0]);\n  char *dbname;\n  int line = 0;\n  char buf[1024];\n  datum key;\n  datum data;\n  int delim = '\\t';\n  int data_z = 0;\n  \n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      if (strcmp (arg, \"-h\") == 0)\n\t{\n\t  printf (\"usage: %s [-null] [-delim=CHR] DBFILE\\n\", progname);\n\t  exit (0);\n\t}\n      else if (strcmp (arg, \"-null\") == 0)\n\tdata_z = 1;\n      else if (strncmp (arg, \"-delim=\", 7) == 0)\n\tdelim = arg[7];\n      else if (strcmp (arg, \"--\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  break;\n\t}\n      else if (arg[0] == '-')\n\t{\n\t  fprintf (stderr, \"%s: unknown option %s\\n\", progname, arg);\n\t  exit (1);\n\t}\n      else\n\tbreak;\n    }\n\n  if (argc != 1)\n    {\n      fprintf (stderr, \"%s: wrong arguments\\n\", progname);\n      exit (1);\n    }\n\n  /* Check if .pag file exists. Create it if it doesn't, as DBM\n     cannot do it itself. */\n  \n  dbname = malloc (strlen (*argv) + sizeof (PAGSUF));\n  if (!dbname)\n    abort ();\n\n  strcat (strcpy (dbname, *argv), PAGSUF);\n\n  if (access (dbname, F_OK))\n    {\n      int fd = creat (dbname, 0644);\n      if (fd < 0)\n\t{\n\t  fprintf (stderr, \"%s: \", progname);\n\t  perror (dbname);\n\t  exit (1);\n\t}\n      close (fd);\n    }\n  free (dbname);\n\n  if (dbminit (*argv))\n    {\n      fprintf (stderr, \"dbminit failed\\n\");\n      exit (1);\n    }\n\n  while (fgets (buf, sizeof buf, stdin))\n    {\n      size_t i, j;\n      size_t len = strlen (buf);\n\n      if (buf[len - 1] != '\\n')\n\t{\n\t  fprintf (stderr, \"%s: %d: line too long\\n\",\n\t\t   progname, line);\n\t  continue;\n\t}\n\n      buf[--len] = 0;\n      \n      line++;\n\n      for (i = j = 0; i < len; i++)\n\t{\n\t  if (buf[i] == '\\\\')\n\t    i++;\n\t  else if (buf[i] == delim)\n\t    break;\n\t  else\n\t    buf[j++] = buf[i];\n\t}\n\n      if (buf[i] != delim)\n\t{\n\t  fprintf (stderr, \"%s: %d: malformed line\\n\",\n\t\t   progname, line);\n\t  continue;\n\t}\n      buf[j] = 0;\n      \n      key.dptr = buf;\n      key.dsize = j + data_z;\n      data.dptr = buf + i + 1;\n      data.dsize = strlen (data.dptr) + data_z;\n      if (store (key, data) != 0)\n\t{\n\t  fprintf (stderr, \"%s: %d: item not inserted\\n\",\n\t\t   progname, line);\n\t  exit (1);\n\t}\n    }\n  dbmclose ();\n  exit (0);\n}",
      "lines": 122,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/d_creat_ce.c": {
    "ntos": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "char *\nntos (int n, char *buf, size_t size)\n{\n  char *p = buf + size;\n  *--p = 0;\n  do\n    {\n      int x = n % 10;\n      *--p = '0' + x;\n      n /= 10;\n    }\n  while (n);\n  return p;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "char",
        "*\nntos (int n, char *buf, size_t size)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n   DBM *d;\n   char fdbuf[2][80];\n   int i;\n   int flags = O_RDONLY;\n   \n   if (argc < 2)\n     {\n       fprintf (stderr, \"usage: %s PATH-TO-FDOP [-creat] [-write]\\n\", argv[0]);\n       return 2;\n     }\n\n   for (i = 2; i < argc; i++)\n     {\n       if (strcmp (argv[i], \"-creat\") == 0)\n\t flags = O_RDWR|O_CREAT;\n       else if (strcmp (argv[i], \"-write\") == 0)\n\t flags = O_RDWR;\n       else\n\t {\n\t   fprintf (stderr, \"%s: unknown option: %s\\n\",\n\t\t    argv[0], argv[i]);\n\t   return 2;\n\t }\n       \n     }\n   \n   if (!O_CLOEXEC)\n     return 77;\n   \n   d = dbm_open (\"file\", flags|O_CLOEXEC, 0600);\n   if (!d)\n     {\n       perror (\"dbm_open\");\n       return 3;\n     }\n\n   execl (argv[1], \"fdop\",\n\t  ntos (dbm_pagfno (d), fdbuf[0], sizeof (fdbuf[0])),\n\t  ntos (dbm_dirfno (d), fdbuf[1], sizeof (fdbuf[1])),\n\t  NULL);\n   return 127;\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/fdop.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int fd = dup (0);\n  \n  while (--argc)\n    {\n      int n = atoi (*++argv);\n      if (n < fd)\n\treturn 1;\n    }\n  return 0;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/gtdel.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *progname = canonical_progname (argv[0]);\n  const char *dbname;\n  datum key;\n  int flags = 0;\n  GDBM_FILE dbf;\n  int data_z = 0;\n  int rc = 0;\n  \n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      if (strcmp (arg, \"-h\") == 0)\n\t{\n\t  printf (\"usage: %s [-null] [-nolock] [-nommap] [-sync] DBFILE KEY [KEY...]\\n\",\n\t\t  progname);\n\t  exit (0);\n\t}\n      else if (strcmp (arg, \"-null\") == 0)\n\tdata_z = 1;\n      else if (strcmp (arg, \"-nolock\") == 0)\n\tflags |= GDBM_NOLOCK;\n      else if (strcmp (arg, \"-nommap\") == 0)\n\tflags |= GDBM_NOMMAP;\n      else if (strcmp (arg, \"-sync\") == 0)\n\tflags |= GDBM_SYNC;\n      else if (strcmp (arg, \"--\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  break;\n\t}\n      else if (arg[0] == '-')\n\t{\n\t  fprintf (stderr, \"%s: unknown option %s\\n\", progname, arg);\n\t  exit (1);\n\t}\n      else\n\tbreak;\n    }\n\n  if (argc < 2)\n    {\n      fprintf (stderr, \"%s: wrong arguments\\n\", progname);\n      exit (1);\n    }\n  dbname = *argv;\n  \n  dbf = gdbm_open (dbname, 0, GDBM_WRITER|flags, 0, NULL);\n  if (!dbf)\n    {\n      fprintf (stderr, \"gdbm_open failed: %s\\n\", gdbm_strerror (gdbm_errno));\n      exit (1);\n    }\n\n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      key.dptr = arg;\n      key.dsize = strlen (arg) + !!data_z;\n\n      if (gdbm_delete(dbf, key))\n\t{\n\t  fprintf (stderr, \"%s: cannot delete %s: %s\\n\",\n\t\t   progname, arg, gdbm_strerror (gdbm_errno));\n\t  rc = 2;\n\t}\n    }\n  gdbm_close (dbf);\n  exit (rc);\n}",
      "lines": 75,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/gtdump.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *progname = canonical_progname (argv[0]);\n  const char *dbname;\n  datum key;\n  datum data;\n  int flags = 0;\n  GDBM_FILE dbf;\n  int delim = '\\t';\n  \n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      if (strcmp (arg, \"-h\") == 0)\n\t{\n\t  printf (\"usage: %s [-nolock] [-nommap] [-delim=CHR] DBFILE\\n\",\n\t\t  progname);\n\t  exit (0);\n\t}\n      else if (strcmp (arg, \"-nolock\") == 0)\n\tflags |= GDBM_NOLOCK;\n      else if (strcmp (arg, \"-nommap\") == 0)\n\tflags |= GDBM_NOMMAP;\n      else if (strcmp (arg, \"-sync\") == 0)\n\tflags |= GDBM_SYNC;\n      else if (strncmp (arg, \"-delim=\", 7) == 0)\n\tdelim = arg[7];\n      else if (strcmp (arg, \"--\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  break;\n\t}\n      else if (arg[0] == '-')\n\t{\n\t  fprintf (stderr, \"%s: unknown option %s\\n\", progname, arg);\n\t  exit (1);\n\t}\n      else\n\tbreak;\n    }\n\n  if (argc != 1)\n    {\n      fprintf (stderr, \"%s: wrong arguments\\n\", progname);\n      exit (1);\n    }\n  dbname = *argv;\n  \n  dbf = gdbm_open (dbname, 0, GDBM_READER|flags, 00664, NULL);\n  if (!dbf)\n    {\n      fprintf (stderr, \"gdbm_open failed: %s\\n\", gdbm_strerror (gdbm_errno));\n      exit (1);\n    }\n\n  key = gdbm_firstkey (dbf);\n  while (key.dptr)\n    {\n      size_t i;\n      datum nextkey;\n      \n      for (i = 0; i < key.dsize && key.dptr[i]; i++)\n\t{\n\t  if (key.dptr[i] == delim || key.dptr[i] == '\\\\')\n\t    fputc ('\\\\', stdout);\n\t  fputc (key.dptr[i], stdout);\n\t}\n\n      fputc (delim, stdout);\n\n      data = gdbm_fetch (dbf, key);\n      i = data.dsize;\n      if (data.dptr[i-1] == 0)\n\ti--;\n      \n      fwrite (data.dptr, i, 1, stdout);\n      free (data.dptr);\n      \n      fputc ('\\n', stdout);\n\n      nextkey = gdbm_nextkey (dbf, key);\n      free (key.dptr);\n      key = nextkey;\n    }\n\n  if (gdbm_errno != GDBM_ITEM_NOT_FOUND)\n    {\n      fprintf (stderr, \"unexpected error: %s\\n\", gdbm_strerror (gdbm_errno));\n      exit (1);\n    }\n  \n  gdbm_close (dbf);\n  exit (0);\n}",
      "lines": 97,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/gtfetch.c": {
    "print_key": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "void\nprint_key (FILE *fp, datum key, int delim)\n{\n  size_t i;\n  \n  for (i = 0; i < key.dsize && key.dptr[i]; i++)\n    {\n      if (key.dptr[i] == delim || key.dptr[i] == '\\\\')\n\tfputc ('\\\\', fp);\n      fputc (key.dptr[i], fp);\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *progname = canonical_progname (argv[0]);\n  const char *dbname;\n  datum key;\n  datum data;\n  int flags = 0;\n  GDBM_FILE dbf;\n  int data_z = 0;\n  int delim = 0;\n  int rc = 0;\n  \n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      if (strcmp (arg, \"-h\") == 0)\n\t{\n\t  printf (\"usage: %s [-nolock] [-nommap] [-null] [-delim=CHR] DBFILE KEY [KEY...]\\n\",\n\t\t  progname);\n\t  exit (0);\n\t}\n      else if (strcmp (arg, \"-nolock\") == 0)\n\tflags |= GDBM_NOLOCK;\n      else if (strcmp (arg, \"-nommap\") == 0)\n\tflags |= GDBM_NOMMAP;\n      else if (strcmp (arg, \"-null\") == 0)\n\tdata_z = 1;\n      else if (strncmp (arg, \"-delim=\", 7) == 0)\n\tdelim = arg[7];\n      else if (strcmp (arg, \"--\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  break;\n\t}\n      else if (arg[0] == '-')\n\t{\n\t  fprintf (stderr, \"%s: unknown option %s\\n\", progname, arg);\n\t  exit (1);\n\t}\n      else\n\tbreak;\n    }\n\n  if (argc < 2)\n    {\n      fprintf (stderr, \"%s: wrong arguments\\n\", progname);\n      exit (1);\n    }\n  dbname = *argv;\n  \n  dbf = gdbm_open (dbname, 0, GDBM_READER|flags, 00664, NULL);\n  if (!dbf)\n    {\n      fprintf (stderr, \"gdbm_open failed: %s\\n\", gdbm_strerror (gdbm_errno));\n      exit (1);\n    }\n\n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      key.dptr = arg;\n      key.dsize = strlen (arg) + !!data_z;\n\n      data = gdbm_fetch (dbf, key);\n      if (data.dptr == NULL)\n\t{\n\t  rc = 2;\n\t  if (gdbm_errno == GDBM_ITEM_NOT_FOUND)\n\t    {\n\t      fprintf (stderr, \"%s: \", progname);\n\t      print_key (stderr, key, delim);\n\t      fprintf (stderr, \": not found\\n\");\n\t    }\n\t  else\n\t    {\n\t      fprintf (stderr, \"%s: error: %s\\n\", progname,\n\t\t       gdbm_strerror (gdbm_errno));\n\t    }\n\t  continue;\n\t}\n      if (delim)\n\t{\n\t  print_key (stdout, key, delim);\n\t  fputc (delim, stdout);\n\t}\n\n      fwrite (data.dptr, data.dsize - !!data_z, 1, stdout);\n      free (data.dptr);\n      \n      fputc ('\\n', stdout);\n    }\n\n  gdbm_close (dbf);\n  exit (rc);\n}",
      "lines": 99,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/gtload.c": {
    "err_printer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\nerr_printer (void *data, char const *fmt, ...)\n{\n  va_list ap;\n\n  fprintf (stderr, \"%s: \", progname);\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n  fprintf (stderr, \"\\n\");\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "read_size": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "size_t\nread_size (char const *arg)\n{\n  char *p;\n  size_t ret;\n  \n  errno = 0;\n  ret = strtoul (arg, &p, 10);\n\t  \n  if (errno)\n    {\n      fprintf (stderr, \"%s: \", progname);\n      perror (arg);\n      exit (1);\n    }\n\n  if (*p)\n    {\n      fprintf (stderr, \"%s: bad number: %s\\n\", progname, arg);\n      exit (1);\n    }\n\n  return ret;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    },
    "debug_printer": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "void\ndebug_printer (char const *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        189,
        5
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *dbname;\n  int line = 0;\n  char buf[1024];\n  datum key;\n  datum data;\n  int replace = 0;\n  int flags = 0;\n  int mode = GDBM_WRCREAT;\n  int block_size = 0;\n  GDBM_FILE dbf;\n  int delim = '\\t';\n  int data_z = 0;\n  size_t mapped_size_max = 0;\n  int blksize;\n  int verbose = 0;\n  int recover = 0;\n  gdbm_recovery rcvr;\n  int rcvr_flags = 0;\n  \n  progname = canonical_progname (argv[0]);\n#ifdef GDBM_DEBUG_ENABLE\n  gdbm_debug_printer = debug_printer;\n#endif\n  \n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      if (strcmp (arg, \"-h\") == 0)\n\t{\n\t  printf (\"usage: %s [-replace] [-clear] [-blocksize=N] [-bsexact] [-verbose] [-null] [-nolock] [-nommap] [-maxmap=N] [-sync] [-delim=CHR] DBFILE\\n\", progname);\n\t  exit (0);\n\t}\n      else if (strcmp (arg, \"-replace\") == 0)\n\treplace |= GDBM_REPLACE;\n      else if (strcmp (arg, \"-clear\") == 0)\n\tmode = GDBM_NEWDB;\n      else if (strcmp (arg, \"-null\") == 0)\n\tdata_z = 1;\n      else if (strcmp (arg, \"-nolock\") == 0)\n\tflags |= GDBM_NOLOCK;\n      else if (strcmp (arg, \"-nommap\") == 0)\n\tflags |= GDBM_NOMMAP;\n      else if (strcmp (arg, \"-sync\") == 0)\n\tflags |= GDBM_SYNC;\n      else if (strcmp (arg, \"-bsexact\") == 0)\n\tflags |= GDBM_BSEXACT;\n      else if (strcmp (arg, \"-verbose\") == 0)\n\tverbose = 1;\n      else if (strncmp (arg, \"-blocksize=\", 11) == 0)\n\tblock_size = atoi (arg + 11);\n      else if (strncmp (arg, \"-maxmap=\", 8) == 0)\n\tmapped_size_max = read_size (arg + 8);\n      else if (strncmp (arg, \"-delim=\", 7) == 0)\n\tdelim = arg[7];\n      else if (strcmp (arg, \"-recover\") == 0)\n\trecover = 1;\n      else if (strcmp (arg, \"-verbose\") == 0)\n\t{\n\t  verbose = 1;\n\t  rcvr.errfun = err_printer;\n\t  rcvr_flags |= GDBM_RCVR_ERRFUN;\n\t}\n      else if (strcmp (arg, \"-backup\") == 0)\n\trcvr_flags |= GDBM_RCVR_BACKUP;\n      else if (strncmp (arg, \"-max-failures=\", 14) == 0)\n\t{\n\t  rcvr.max_failures = read_size (arg + 14);\n\t  rcvr_flags |= GDBM_RCVR_MAX_FAILURES;\n\t}\n      else if (strncmp (arg, \"-max-failed-keys=\", 17) == 0)\n\t{\n\t  rcvr.max_failed_keys = read_size (arg + 17);\n\t  rcvr_flags |= GDBM_RCVR_MAX_FAILED_KEYS;\n\t}\n      else if (strncmp (arg, \"-max-failed-buckets=\", 20) == 0)\n\t{\n\t  rcvr.max_failures = read_size (arg + 20);\n\t  rcvr_flags |= GDBM_RCVR_MAX_FAILED_BUCKETS;\n\t}\n#ifdef GDBM_DEBUG_ENABLE\n      else if (strncmp (arg, \"-debug=\", 7) == 0)\n\t{\n\t  char *p;\n\n\t  for (p = strtok (arg + 7, \",\"); p; p = strtok (NULL, \",\"))\n\t    {\n\t      int f = gdbm_debug_token (p);\n\t      if (!f)\n\t\tfprintf (stderr, \"%s: unknown flag: %s\\n\", progname, p);\n\t      else\n\t\tgdbm_debug_flags |= f;\n\t    }\n\t}\n#endif\n      else if (strcmp (arg, \"--\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  break;\n\t}\n      else if (arg[0] == '-')\n\t{\n\t  fprintf (stderr, \"%s: unknown option %s\\n\", progname, arg);\n\t  exit (1);\n\t}\n      else\n\tbreak;\n    }",
      "lines": 112,
      "depth": 29,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/gtopt.c": {
    "get_max_mmap_size": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static size_t\nget_max_mmap_size (const char *arg)\n{\n  char *p;\n  size_t size;\n  \n  errno = 0;\n  size = strtoul (arg, &p, 10);\n\t  \n  if (errno)\n    {\n      fprintf (stderr, \"%s: \", progname);\n      perror (\"maxmap\");\n      exit (1);\n    }\n  \n  if (*p)\n    {\n      fprintf (stderr, \"%s: bad maxmap\\n\", progname);\n      exit (1);\n    }\n  return size;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "test_getflags": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\ntest_getflags (void *valptr)\n{\n  int expected = mode | flags;\n#ifndef HAVE_MMAP\n  expected |= GDBM_NOMMAP;\n#endif\n  return (*(int*) valptr == expected) ? RES_PASS : RES_FAIL;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "test_dbname": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "int\ntest_dbname (void *valptr)\n{\n  char *s = *(char**)valptr;\n  int rc = strcmp (string, dbname) == 0 ? RES_PASS : RES_FAIL;\n  if (rc != RES_PASS)\n    printf (\"[got %s instead of %s] \", s, dbname);\n  free (s);\n  return rc;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "init_cachesize": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\ninit_cachesize (void *valptr, int valsize)\n{\n  *(size_t*) valptr = cache_size;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "test_getcachesize": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "int\ntest_getcachesize (void *valptr)\n{\n  return *(size_t*) valptr == cache_size ? RES_PASS : RES_FAIL;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "init_true": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\ninit_true (void *valptr, int valsize)\n{\n  *(int*) valptr = 1;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "init_false": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\ninit_false (void *valptr, int valsize)\n{\n  *(int*) valptr = 0;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "init_negate_bool": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "void\ninit_negate_bool (void *valptr, int valsize)\n{\n  *(int*) valptr = !retbool;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "test_true": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\ntest_true (void *valptr)\n{\n  return *(int*) valptr == 1 ? RES_PASS : RES_FAIL;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "test_false": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\ntest_false (void *valptr)\n{\n  return *(int*) valptr == 0 ? RES_PASS : RES_FAIL;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "test_negate_bool": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "int\ntest_negate_bool (void *valptr)\n{\n  return *(int*) valptr == !retbool ? RES_PASS : RES_FAIL;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "test_bool": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "int\ntest_bool (void *valptr)\n{\n  return *(int*) valptr == retbool ? RES_PASS : RES_FAIL;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "test_initial_maxmapsize": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "int\ntest_initial_maxmapsize(void *valptr)\n{\n  return *(size_t*) valptr == SIZE_T_MAX ? RES_PASS : RES_FAIL;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "init_maxmapsize": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "void\ninit_maxmapsize (void *valptr, int valsize)\n{\n  *(size_t*)valptr = mapped_size_max;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "test_maxmapsize": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "int\ntest_maxmapsize (void *valptr)\n{\n  size_t page_size = sysconf (_SC_PAGESIZE);\n  size_t expected_size = ((mapped_size_max + page_size - 1) / page_size) *\n\t                          page_size;\n  return (*(size_t*) valptr == expected_size) ? RES_PASS : RES_FAIL;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "test_mmap_group": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "int\ntest_mmap_group (void *valptr)\n{\n#ifdef HAVE_MMAP\n  return RES_PASS;\n#else\n  return RES_SKIP;\n#endif\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "groupok": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "int\ngroupok (char **argv, const char *group)\n{\n  int retval = 1;\n  \n  if (*argv)\n    {\n      char *arg;\n    \n      while ((arg = *argv++))\n\t{\n\t  if (*arg == '!')\n\t    {\n\t      if (strcasecmp (arg + 1, group) == 0)\n\t\treturn 0;\n\t      retval = 1;\n\t    }\n\t  else\n\t    {\n\t      if (strcasecmp (arg, group) == 0)\n\t\treturn 1;\n\t      retval = 0;\n\t    }\n\t}\n    }\n\n  return retval;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  GDBM_FILE dbf;\n  struct optest *op;\n  \n  progname = canonical_progname (argv[0]);\n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      if (strcmp (arg, \"-h\") == 0)\n\t{\n\t  printf (\"usage: %s [-blocksize=N] [-nolock] [-sync] [-maxmap=N] DBFILE [GROUP [GROUP...]\\n\",\n\t\t  progname);\n\t  exit (0);\n\t}\n      else if (strcmp (arg, \"-nolock\") == 0)\n\tflags |= GDBM_NOLOCK;\n      else if (strcmp (arg, \"-sync\") == 0)\n\tflags |= GDBM_SYNC;\n      else if (strncmp (arg, \"-blocksize=\", 11) == 0)\n\tblock_size = atoi (arg + 11);\n      else if (strncmp (arg, \"-maxmap=\", 8) == 0)\n\tmapped_size_max = get_max_mmap_size (arg + 8);\n      else if (strcmp (arg, \"--\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  break;\n\t}\n      else if (arg[0] == '-')\n\t{\n\t  fprintf (stderr, \"%s: unknown option %s\\n\", progname, arg);\n\t  exit (1);\n\t}\n      else\n\tbreak;\n    }\n\n  if (argc == 0)\n    {\n      fprintf (stderr, \"%s: wrong arguments\\n\", progname);\n      exit (1);\n    }\n  dbname = *argv;\n  ++argv;\n  --argc;\n  \n  dbf = gdbm_open (dbname, block_size, mode|flags, 00664, NULL);\n  if (!dbf)\n    {\n      fprintf (stderr, \"gdbm_open failed: %s\\n\", gdbm_strerror (gdbm_errno));\n      exit (1);\n    }\n\n  for (op = optest_tab; op->group; op++)\n    {\n      int rc;\n\n      if (!groupok (argv, op->group))\n\tcontinue;\n\n      if (!op->name)\n\t{\n\t  /* Group header */\n\t  const char *grp = op->group;\n\n\t  printf (\"* %s:\", grp);\n\t  if (op->test && (rc = op->test (NULL)) != RES_PASS)\n\t    {\n\t      printf (\" %s\", resstr[rc]);\n\t      for (op++; op->name && strcmp (op->group, grp) == 0; op++)\n\t\t;\n\t      op--;\n\t    }\n\t  putchar ('\\n');\n\t  continue;\n\t}\n\t\n      printf (\"%s: \", op->name);\n      if (op->init)\n\top->init (op->valptr, op->valsize);\n      \n      rc = gdbm_setopt (dbf, op->code, op->valptr, op->valsize);\n      if (rc)\n\t{\n\t  if (gdbm_errno == op->xfail)\n\t    puts (resstr[RES_XFAIL]);\n\t  else\n\t    printf (\"%s: %s\\n\", resstr[RES_FAIL],\n\t\t    gdbm_strerror (gdbm_errno));\n\t}\n      else if (!op->test)\n\tputs (resstr[RES_PASS]);\n      else\n\t{\n\t  rc = op->test (op->valptr);\n\t  assert (rc >= 0 && rc < _res_max);\n\t  puts (resstr[rc]);\n\t}\n    }\n  \n  gdbm_close (dbf);\n  exit (0);\n}",
      "lines": 106,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/gtrecover.c": {
    "err_printer": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\nerr_printer (void *data, char const *fmt, ...)\n{\n  va_list ap;\n\n  fprintf (stderr, \"%s: \", progname);\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n  fprintf (stderr, \"\\n\");\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *dbname;\n  GDBM_FILE dbf;\n  int rc = 0;\n  int open_flags = GDBM_WRITER;\n  gdbm_recovery rcvr;\n  int rcvr_flags = 0;\n  char *p;\n  \n  progname = canonical_progname (argv[0]);\n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      if (strcmp (arg, \"-h\") == 0)\n\t{\n\t  printf (\"usage: %s [-nolock] [-nommap] [-verbose] [-backup] [-max-failures=N] [-max-failed-keys=N] [-max-failed-buckets=N] DBFILE\\n\",\n\t\t  progname);\n\t  exit (0);\n\t}\n      else if (strcmp (arg, \"-nolock\") == 0)\n\topen_flags |= GDBM_NOLOCK;\n      else if (strcmp (arg, \"-nommap\") == 0)\n\topen_flags |= GDBM_NOMMAP;\n      else if (strcmp (arg, \"-verbose\") == 0)\n\t{\n\t  rcvr.errfun = err_printer;\n\t  rcvr_flags |= GDBM_RCVR_ERRFUN;\n\t}\n      else if (strcmp (arg, \"-backup\") == 0)\n\trcvr_flags |= GDBM_RCVR_BACKUP;\n      else if (strncmp (arg, \"-max-failures=\", 14) == 0)\n\t{\n\t  rcvr.max_failures = strtoul (arg + 14, &p, 10);\n\t  assert (*p == 0);\n\t  rcvr_flags |= GDBM_RCVR_MAX_FAILURES;\n\t}\n      else if (strncmp (arg, \"-max-failed-keys=\", 17) == 0)\n\t{\n\t  rcvr.max_failed_keys = strtoul (arg + 17, &p, 10);\n\t  assert (*p == 0);\n\t  rcvr_flags |= GDBM_RCVR_MAX_FAILED_KEYS;\n\t}\n      else if (strncmp (arg, \"-max-failed-buckets=\", 20) == 0)\n\t{\n\t  rcvr.max_failures = strtoul (arg + 20, &p, 10);\n\t  assert (*p == 0);\n\t  rcvr_flags |= GDBM_RCVR_MAX_FAILED_BUCKETS;\n\t}\n      else if (strcmp (arg, \"--\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  break;\n\t}\n      else if (arg[0] == '-')\n\t{\n\t  fprintf (stderr, \"%s: unknown option %s\\n\", progname, arg);\n\t  exit (1);\n\t}\n      else\n\tbreak;\n    }\n\n  if (argc < 1)\n    {\n      fprintf (stderr, \"%s: wrong arguments\\n\", progname);\n      exit (1);\n    }\n  dbname = *argv;\n  \n  dbf = gdbm_open (dbname, 0, open_flags, 0, NULL);\n  if (!dbf)\n    {\n      fprintf (stderr, \"gdbm_open failed: %s\\n\", gdbm_strerror (gdbm_errno));\n      exit (1);\n    }\n\n  rc = gdbm_recover (dbf, &rcvr, rcvr_flags);\n\n  gdbm_close (dbf);\n  exit (rc);\n}",
      "lines": 85,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/gtver.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *progname = canonical_progname (argv[0]);\n  int library = 0;\n\n  if (argc == 1)\n    {\n      printf (\"%s\\n\", gdbm_version);\n      exit (0);\n    }\n  \n  while (--argc)\n    {\n      char *arg = *++argv;\n\n      if (strcmp (arg, \"-help\") == 0)\n\t{\n\t  printf (\"usage: %s [-string] [-lib] [-header] [-major] [-minor] [-patch] [-full]\\n\", progname);\n\t  exit (0);\n\t}\n      else if (strcmp (arg, \"-string\") == 0)\n\tprintf (\"%s\\n\", gdbm_version);\n      else if (strcmp (arg, \"-lib\") == 0)\n\tlibrary = 1;\n      else if (strcmp (arg, \"-header\") == 0)\n\tlibrary = 0;\n      else if (strcmp (arg, \"-major\") == 0)\n\tprintf (\"%d\\n\", major_number (library));\n      else if (strcmp (arg, \"-minor\") == 0)\n\tprintf (\"%d\\n\", minor_number (library));\n      else if (strcmp (arg, \"-patch\") == 0)\n\tprintf (\"%d\\n\", patch_number (library));\n      else if (strcmp (arg, \"-full\") == 0)\n\tprintf (\"%d.%d.%d\\n\",\n\t\tmajor_number (library),\n\t\tminor_number (library),\n\t\tpatch_number (library));\n      else\n\t{\n\t  fprintf (stderr, \"%s: unknown option %s\\n\",\n\t\t   progname, arg);\n\t  exit (1);\n\t}\n    }\n  exit (0);\n}",
      "lines": 47,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/g_open_ce.c": {
    "ntos": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "char *\nntos (int n, char *buf, size_t size)\n{\n  char *p = buf + size;\n  *--p = 0;\n  do\n    {\n      int x = n % 10;\n      *--p = '0' + x;\n      n /= 10;\n    }\n  while (n);\n  return p;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "char",
        "*\nntos (int n, char *buf, size_t size)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  GDBM_FILE d;\n  char fdbuf[80];\n\n  if (argc != 2)\n    {\n      fprintf (stderr, \"usage: %s PATH-TO-FDOP\\n\", argv[0]);\n      return 2;\n    }\n  if (!O_CLOEXEC)\n    return 77;\n  d = gdbm_open (\"file.db\", 0, GDBM_NEWDB|GDBM_CLOEXEC, 0600, NULL);\n  if (!d)\n    {\n      fprintf (stderr, \"gdbm_open: %s\\n\", gdbm_strerror (gdbm_errno));\n      return 3;\n    }\n  execl (argv[1], \"fdop\",\n\t ntos (gdbm_fdesc (d), fdbuf, sizeof (fdbuf)), NULL);\n  return 127;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/g_reorg_ce.c": {
    "ntos": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "char *\nntos (int n, char *buf, size_t size)\n{\n  char *p = buf + size;\n  *--p = 0;\n  do\n    {\n      int x = n % 10;\n      *--p = '0' + x;\n      n /= 10;\n    }\n  while (n);\n  return p;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "char",
        "*\nntos (int n, char *buf, size_t size)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  GDBM_FILE d;\n  char fdbuf[80];\n\n  if (argc != 2)\n    {\n      fprintf (stderr, \"usage: %s PATH-TO-FDOP\\n\", argv[0]);\n      return 2;\n    }\n  if (!O_CLOEXEC)\n    return 77;\n  d = gdbm_open (\"file.db\", 0, GDBM_NEWDB|GDBM_CLOEXEC, 0600, NULL);\n  if (!d)\n    {\n      fprintf (stderr, \"gdbm_open: %s\\n\", gdbm_strerror (gdbm_errno));\n      return 3;\n    }\n  if (gdbm_reorganize (d))\n    {\n      fprintf (stderr, \"gdbm_reorganize: %s\\n\",\n\t       gdbm_strerror (gdbm_errno));\n      return 3;\n    }\n  execl (argv[1], \"fdop\",\n\t ntos (gdbm_fdesc (d), fdbuf, sizeof (fdbuf)), NULL);\n  return 127;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/num2word.c": {
    "copy": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\ncopy (const char *str, int dch)\n{\n  size_t len = strlen (str);\n  if (len + !!dch > bufoff)\n    abort ();\n  if (dch)\n    buffer[--bufoff] = dch;\n  bufoff -= len;\n  memcpy (buffer + bufoff, str, len);\n  delim = ' ';\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "format_100": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\nformat_100 (numeral_t num)\n{\n  if (num == 0)\n    ;\n  else if (num < 10)\n    copy (nstr[0][num], delim);\n  else if (num < 20)\n    copy (nstr[1][num-10], delim);\n  else \n    {\n      numeral_t tens = num / 10;\n      num %= 10;\n      if (num)\n\t{\n\t  copy (nstr[0][num], delim);\n\t  copy (\"-\", 0);\n\t  copy (nstr[2][tens], 0);\n\t}\n      else\n\tcopy (nstr[2][tens], delim);\n    }\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "format_1000": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\nformat_1000 (numeral_t num, int more)\n{\n  size_t n = num % 100;\n  num /= 100;\n  format_100 (n);\n  more |= num != 0;\n  if (n && more)\n    copy (\"and\", delim);\n  if (num)\n    {\n      copy (\"hundred\", delim);\n      copy (nstr[0][num], delim);\n    }\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "format_number": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\nformat_number (numeral_t num)\n{\n  int s = 0;\n  size_t off;\n\n  bufoff = bufsize;\n  buffer[--bufoff] = 0;\n  off = bufoff;\n  delim = 0;\n  \n  do\n    {\n      numeral_t n = num % 1000;\n\n      num /= 1000;\n      \n      if (s > 0 && ((n && off > bufoff) || num == 0))\n\tcopy (short_scale[s], delim);\n      s++;\n      \n      if (s > short_scale_max)\n\tabort ();\n      \n      format_1000 (n, num != 0);\n    }\n  while (num);\n  \n  if (bufoff + 1 == bufsize)\n    copy (nstr[0][0], 0);\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "print_number": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "void\nprint_number (numeral_t num)\n{\n  format_number (num);\n  if (revert_option)\n    printf (\"%s\\t%lu\\n\", buffer + bufoff, num);\n  else\n    printf (\"%lu\\t%s\\n\", num, buffer + bufoff);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "print_range": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void\nprint_range (numeral_t num, numeral_t to)\n{\n  for (; num <= to; num++)\n    print_number (num);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "xstrtoul": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "numeral_t\nxstrtoul (char *arg, char **endp)\n{\n  numeral_t num;\n  char *p;\n\n  errno = 0;\n  num = strtoul (arg, &p, 10);\n  if (errno)\n    {\n      fprintf (stderr, \"%s: invalid number: \", progname);\n      perror (arg);\n      exit (2);\n    }\n  if (endp)\n    *endp = p;\n  else if (*p)\n    {\n      fprintf (stderr, \"%s: invalid number (near %s)\\n\",\n\t       progname, p);\n      exit (2);\n    }\n    \n  return num;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "numeral_t"
      ]
    },
    "range_remove": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static void\nrange_remove (size_t i)\n{\n  range[i].count = 0;\n  range[i].start = range_avail;\n  range_avail = i;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "range_add": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static void\nrange_add (numeral_t start, numeral_t count)\n{\n  size_t i;\n  \n  if (range_avail == AVAIL_NIL)\n    {\n      size_t n = range_max;\n      \n      if (range_max == 0)\n\trange_max = RANGE_INITIAL_ALLOC;\n      else\n\t{\n\t  assert ((size_t)-1 / 3 * 2 / sizeof (range[0]) > range_max);\n\t  range_max += (range_max + 1) / 2;\n\t}\n      \n      range = realloc (range, range_max * sizeof (range[0]));\n      if (!range)\n\tabort ();\n\n      for (i = range_max; i > n; i--)\n\trange_remove (i - 1);\n    }\n\n  i = range_avail;\n  range_avail = range[i].start;\n\n  range[i].start = start;\n  range[i].count = count;\n  range_total += count;\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "range_get": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "numeral_t\nrange_get (size_t idx)\n{\n  numeral_t n;\n  size_t i;\n\n  for (i = 0; i < range_max; i++)\n    {\n      if (idx < range[i].count)\n\tbreak;\n      idx -= range[i].count;\n    }\n  assert (i < range_max);\n  n = range[i].start + idx;\n  if (range[i].count == 1)\n    range_remove (i);\n  else if (idx == 0)\n    {\n      range[i].start++;\n      range[i].count--;\n    }\n  else\n    {\n      /* Split range */\n      if (range[i].count > idx - 1)\n\t{\n\t  range_total -= range[i].count - idx - 1;\n\t  range_add (range[i].start + idx + 1, range[i].count - idx - 1);\n\t}\n      range[i].count = idx;\n    }\n  range_total--;\n  return n;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "numeral_t"
      ]
    },
    "usage": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "void\nusage (FILE *fp)\n{\n  fprintf (fp, \"usage: %s [-revert] [-random] RANGE [RANGE...]\\n\", progname);\n  fprintf (fp, \"Lists english numerals in given ranges\\n\\n\");\n  fprintf (fp, \"Each RANGE is one of:\\n\\n\");\n  fprintf (fp, \"  X:N        N numerals starting from X; interval [X,X+N]\\n\");\n  fprintf (fp, \"  X-Y        numerals from X to Y; interval [X,Y]\\n\\n\");\n  fprintf (fp, \"Options are:\\n\\n\");\n  fprintf (fp, \"  -random    produce list in random order\\n\");\n  fprintf (fp, \"  -revert    revert output columns (numeral first)\\n\");\n  fprintf (fp, \"  -help      display this help summary\\n\");\n  fprintf (fp, \"\\n\");\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        420,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  progname = *argv++;\n  --argc;\n\n  for (; argc; argc--, argv++)\n    {\n      char *arg = *argv;\n      if (strcmp (arg, \"-h\") == 0 || strcmp (arg, \"-help\") == 0)\n\t{\n\t  usage (stdout);\n\t  exit (0);\n\t}\n      else if (strcmp (arg, \"-revert\") == 0)\n\t{\n\t  revert_option = 1;\n\t}\n      else if (strcmp (arg, \"-random\") == 0)\n\t{\n\t  random_option = 1;\n\t}\n      else if (arg[0] == '-')\n\t{\n\t  fprintf (stderr, \"%s: unrecognized option: %s\\n\", progname, arg);\n\t  return 1;\n\t}\n      else\n\tbreak;\n    }\n  \n  for (; argc; argc--, argv++)\n    {\n      char *arg = *argv;\n      numeral_t num, num2;\n      char *p;\n\n      num = xstrtoul (arg, &p);\n      if (*p == 0)\n\trange_add (num, 1);\n      else if (*p == ':')\n\t{\n\t  *p++ = 0;\n\t  num2 = xstrtoul (p, NULL);\n\t  if (num2 == 0)\n\t    {\n\t      fprintf (stderr, \"%s: invalid count\\n\", progname);\n\t      exit (2);\n\t    }\n\t  range_add (num, num2);\n\t}\n      else if (*p == '-')\n\t{\n\t  *p++ = 0;\n\t  num2 = xstrtoul (p, NULL);\n\t  if (num2 < num)\n\t    {\n\t      fprintf (stderr, \"%s: invalid range: %lu-%lu\\n\",\n\t\t       progname, num, num2);\n\t      exit (2);\n\t    }\t    \n\t  range_add (num, num2 - num + 1);\n\t}\n      else\n\t{\n\t  fprintf (stderr, \"%s: invalid argument\\n\", progname);\n\t  exit (2);\n\t}\n    }\n\n  if (range_total == 0)\n    {\n      usage (stderr);\n      exit (1);\n    }\n  \n  if (random_option)\n    {\n      srandom (time (NULL));\n      while (range_total)\n\t{\n\t  numeral_t n = range_get (random () % range_total);\n\t  print_number (n);\n\t}\n    }\n  else\n    {\n      size_t i;\n      for (i = 0; i < range_max; i++)\n\tif (range[i].count)\n\t  print_range (range[i].start, range[i].start + range[i].count - 1);\n    }\n  exit (0);\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gdbm/gdbm-1.15/tests/progname.h": {
    "canonical_progname": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "const char *\ncanonical_progname (const char *str)\n{\n  const char *p;\n\n  p = strrchr (str, '/');\n  if (p)\n    p++;\n  else\n    p = str;\n  if (strncmp (p, \"lt-\", 3) == 0)\n    p += 3;\n  return p;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ncanonical_progname (const char *str)",
        "*"
      ]
    }
  }
}