{
  "tar/tar-1.30/gnu/acl-errno-valid.c": {
    "acl_errno_valid": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "bool\nacl_errno_valid (int errnum)\n{\n  /* Recognize some common errors such as from an NFS mount that does\n     not support ACLs, even when local drives do.  */\n  switch (errnum)\n    {\n    case EBUSY: return false;\n    case EINVAL: return false;\n#if defined __APPLE__ && defined __MACH__\n    case ENOENT: return false;\n#endif\n    case ENOSYS: return false;\n\n#if defined ENOTSUP && ENOTSUP != EOPNOTSUPP\n# if ENOTSUP != ENOSYS /* Needed for the MS-Windows port of GNU Emacs.  */\n    case ENOTSUP: return false;\n# endif\n#endif\n\n    case EOPNOTSUPP: return false;\n    default: return true;\n    }\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "tar/tar-1.30/gnu/acl-internal.c": {
    "acl_extended_nontrivial": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nacl_extended_nontrivial (acl_t acl)\n{\n  /* acl is non-trivial if it is non-empty.  */\n  return (acl_entries (acl) > 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "acl_access_nontrivial": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nacl_access_nontrivial (acl_t acl)\n{\n  /* acl is non-trivial if it has some entries other than for \"user::\",\n     \"group::\", and \"other::\".  Normally these three should be present\n     at least, allowing us to write\n        return (3 < acl_entries (acl));\n     but the following code is more robust.  */\n#  if HAVE_ACL_FIRST_ENTRY /* Linux, FreeBSD */\n\n  acl_entry_t ace;\n  int got_one;\n\n  for (got_one = acl_get_entry (acl, ACL_FIRST_ENTRY, &ace);\n       got_one > 0;\n       got_one = acl_get_entry (acl, ACL_NEXT_ENTRY, &ace))\n    {\n      acl_tag_t tag;\n      if (acl_get_tag_type (ace, &tag) < 0)\n        return -1;\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ || tag == ACL_OTHER))\n        return 1;\n    }\n  return got_one;\n\n#  elif HAVE_ACL_TO_SHORT_TEXT /* IRIX */\n  /* Don't use acl_get_entry: it is undocumented.  */\n\n  int count = acl->acl_cnt;\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      acl_entry_t ace = &acl->acl_entry[i];\n      acl_tag_t tag = ace->ae_tag;\n\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ\n            || tag == ACL_OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n\n#  elif HAVE_ACL_FREE_TEXT /* Tru64 */\n  /* Don't use acl_get_entry: it takes only one argument and does not work.  */\n\n  int count = acl->acl_num;\n  acl_entry_t ace;\n\n  for (ace = acl->acl_first; count > 0; ace = ace->next, count--)\n    {\n      acl_tag_t tag;\n      acl_perm_t perm;\n\n      tag = ace->entry->acl_type;\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ || tag == ACL_OTHER))\n        return 1;\n\n      perm = ace->entry->acl_perm;\n      /* On Tru64, perm can also contain non-standard bits such as\n         PERM_INSERT, PERM_DELETE, PERM_MODIFY, PERM_LOOKUP, ... */\n      if ((perm & ~(ACL_READ | ACL_WRITE | ACL_EXECUTE)) != 0)\n        return 1;\n    }\n  return 0;\n\n#  else\n\n  errno = ENOSYS;\n  return -1;\n#  endif\n}",
      "lines": 71,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "acl_default_nontrivial": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "int\nacl_default_nontrivial (acl_t acl)\n{\n  /* acl is non-trivial if it is non-empty.  */\n  return (acl_entries (acl) > 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "acl_nontrivial": [
      {
        "start_point": [
          131,
          0
        ],
        "end_point": [
          152,
          1
        ],
        "content": "int\nacl_nontrivial (int count, aclent_t *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      aclent_t *ace = &entries[i];\n\n      /* Note: If ace->a_type = USER_OBJ, ace->a_id is the st_uid from stat().\n         If ace->a_type = GROUP_OBJ, ace->a_id is the st_gid from stat().\n         We don't need to check ace->a_id in these cases.  */\n      if (!(ace->a_type == USER_OBJ\n            || ace->a_type == GROUP_OBJ\n            || ace->a_type == OTHER_OBJ\n            /* Note: Cygwin does not return a CLASS_OBJ (\"mask:\") entry\n               sometimes.  */\n            || ace->a_type == CLASS_OBJ))\n        return 1;\n    }\n  return 0;\n}",
        "lines": 22,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          344,
          0
        ],
        "end_point": [
          360,
          1
        ],
        "content": "int\nacl_nontrivial (int count, struct acl_entry *entries)\n{\n  int i;\n\n  if (count > 3)\n    return 1;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl_entry *ace = &entries[i];\n\n      if (ace->uid != ACL_NSUSER && ace->gid != ACL_NSGROUP)\n\treturn 1;\n    }\n  return 0;\n}",
        "lines": 17,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          393,
          0
        ],
        "end_point": [
          413,
          1
        ],
        "content": "int\nacl_nontrivial (struct acl *a)\n{\n  /* The normal way to iterate through an ACL is like this:\n       struct acl_entry *ace;\n       for (ace = a->acl_ext; ace != acl_last (a); ace = acl_nxt (ace))\n         {\n           struct ace_id *aei;\n           switch (ace->ace_type)\n             {\n             case ACC_PERMIT:\n             case ACC_DENY:\n             case ACC_SPECIFY:\n               ...;\n             }\n           for (aei = ace->ace_id; aei != id_last (ace); aei = id_nxt (aei))\n             ...\n         }\n   */\n  return (acl_last (a) != a->acl_ext ? 1 : 0);\n}",
        "lines": 21,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          454,
          0
        ],
        "end_point": [
          473,
          1
        ],
        "content": "int\nacl_nontrivial (int count, struct acl *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl *ace = &entries[i];\n\n      /* Note: If ace->a_type = USER_OBJ, ace->a_id is the st_uid from stat().\n         If ace->a_type = GROUP_OBJ, ace->a_id is the st_gid from stat().\n         We don't need to check ace->a_id in these cases.  */\n      if (!(ace->a_type == USER_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == GROUP_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == CLASS_OBJ\n            || ace->a_type == OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "acl_ace_nontrivial": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "int\nacl_ace_nontrivial (int count, ace_t *entries)\n{\n  int i;\n\n  /* The flags in the ace_t structure changed in a binary incompatible way\n     when ACL_NO_TRIVIAL etc. were introduced in <sys/acl.h> version 1.15.\n     How to distinguish the two conventions at runtime?\n     In the old convention, usually three ACEs have a_flags = ACE_OWNER /\n     ACE_GROUP / ACE_OTHER, in the range 0x0100..0x0400.  In the new\n     convention, these values are not used.  */\n  int old_convention = 0;\n\n  for (i = 0; i < count; i++)\n    if (entries[i].a_flags & (OLD_ACE_OWNER | OLD_ACE_GROUP | OLD_ACE_OTHER))\n      {\n        old_convention = 1;\n        break;\n      }\n\n  if (old_convention)\n    /* Running on Solaris 10.  */\n    for (i = 0; i < count; i++)\n      {\n        ace_t *ace = &entries[i];\n\n        /* Note:\n           If ace->a_flags = ACE_OWNER, ace->a_who is the st_uid from stat().\n           If ace->a_flags = ACE_GROUP, ace->a_who is the st_gid from stat().\n           We don't need to check ace->a_who in these cases.  */\n        if (!(ace->a_type == OLD_ALLOW\n              && (ace->a_flags == OLD_ACE_OWNER\n                  || ace->a_flags == OLD_ACE_GROUP\n                  || ace->a_flags == OLD_ACE_OTHER)))\n          return 1;\n      }\n  else\n    {\n      /* Running on Solaris 10 (newer version) or Solaris 11.  */\n      unsigned int access_masks[6] =\n        {\n          0, /* owner@ deny */\n          0, /* owner@ allow */\n          0, /* group@ deny */\n          0, /* group@ allow */\n          0, /* everyone@ deny */\n          0  /* everyone@ allow */\n        };\n\n      for (i = 0; i < count; i++)\n        {\n          ace_t *ace = &entries[i];\n          unsigned int index1;\n          unsigned int index2;\n\n          if (ace->a_type == NEW_ACE_ACCESS_ALLOWED_ACE_TYPE)\n            index1 = 1;\n          else if (ace->a_type == NEW_ACE_ACCESS_DENIED_ACE_TYPE)\n            index1 = 0;\n          else\n            return 1;\n\n          if (ace->a_flags == NEW_ACE_OWNER)\n            index2 = 0;\n          else if (ace->a_flags == (NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP))\n            index2 = 2;\n          else if (ace->a_flags == NEW_ACE_EVERYONE)\n            index2 = 4;\n          else\n            return 1;\n\n          access_masks[index1 + index2] |= ace->a_access_mask;\n        }\n\n      /* The same bit shouldn't be both allowed and denied.  */\n      if (access_masks[0] & access_masks[1])\n        return 1;\n      if (access_masks[2] & access_masks[3])\n        return 1;\n      if (access_masks[4] & access_masks[5])\n        return 1;\n\n      /* Check minimum masks.  */\n      if ((NEW_ACE_WRITE_NAMED_ATTRS\n           | NEW_ACE_WRITE_ATTRIBUTES\n           | NEW_ACE_WRITE_ACL\n           | NEW_ACE_WRITE_OWNER)\n          & ~ access_masks[1])\n        return 1;\n      access_masks[1] &= ~(NEW_ACE_WRITE_NAMED_ATTRS\n                           | NEW_ACE_WRITE_ATTRIBUTES\n                           | NEW_ACE_WRITE_ACL\n                           | NEW_ACE_WRITE_OWNER);\n      if ((NEW_ACE_READ_NAMED_ATTRS\n           | NEW_ACE_READ_ATTRIBUTES\n           | NEW_ACE_READ_ACL\n           | NEW_ACE_SYNCHRONIZE)\n          & ~ access_masks[5])\n        return 1;\n      access_masks[5] &= ~(NEW_ACE_READ_NAMED_ATTRS\n                           | NEW_ACE_READ_ATTRIBUTES\n                           | NEW_ACE_READ_ACL\n                           | NEW_ACE_SYNCHRONIZE);\n\n      /* Check the allowed or denied bits.  */\n      switch ((access_masks[0] | access_masks[1])\n              & ~(NEW_ACE_READ_NAMED_ATTRS\n                  | NEW_ACE_READ_ATTRIBUTES\n                  | NEW_ACE_READ_ACL\n                  | NEW_ACE_SYNCHRONIZE))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n      switch ((access_masks[2] | access_masks[3])\n              & ~(NEW_ACE_READ_NAMED_ATTRS\n                  | NEW_ACE_READ_ATTRIBUTES\n                  | NEW_ACE_READ_ACL\n                  | NEW_ACE_SYNCHRONIZE))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n      switch ((access_masks[4] | access_masks[5])\n              & ~(NEW_ACE_WRITE_NAMED_ATTRS\n                  | NEW_ACE_WRITE_ATTRIBUTES\n                  | NEW_ACE_WRITE_ACL\n                  | NEW_ACE_WRITE_OWNER))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n\n      /* Check that the NEW_ACE_WRITE_DATA and NEW_ACE_APPEND_DATA bits are\n         either both allowed or both denied.  */\n      if (((access_masks[0] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[0] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n      if (((access_masks[2] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[2] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n      if (((access_masks[4] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[4] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n    }\n\n  return 0;\n}",
      "lines": 175,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "aclv_nontrivial": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "int\naclv_nontrivial (int count, struct acl *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl *ace = &entries[i];\n\n      /* Note: If ace->a_type = USER_OBJ, ace->a_id is the st_uid from stat().\n         If ace->a_type = GROUP_OBJ, ace->a_id is the st_gid from stat().\n         We don't need to check ace->a_id in these cases.  */\n      if (!(ace->a_type == USER_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == GROUP_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == CLASS_OBJ\n            || ace->a_type == OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "acl_nfs4_nontrivial": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "int\nacl_nfs4_nontrivial (nfs4_acl_int_t *a)\n{\n#  if 1 /* let's try this first */\n  return (a->aclEntryN > 0 ? 1 : 0);\n#  else\n  int count = a->aclEntryN;\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      nfs4_ace_int_t *ace = &a->aclEntry[i];\n\n      if (!((ace->flags & ACE4_ID_SPECIAL) != 0\n            && (ace->aceWho.special_whoid == ACE4_WHO_OWNER\n                || ace->aceWho.special_whoid == ACE4_WHO_GROUP\n                || ace->aceWho.special_whoid == ACE4_WHO_EVERYONE)\n            && ace->aceType == ACE4_ACCESS_ALLOWED_ACE_TYPE\n            && ace->aceFlags == 0\n            && (ace->aceMask & ~(ACE4_READ_DATA | ACE4_LIST_DIRECTORY\n                                 | ACE4_WRITE_DATA | ACE4_ADD_FILE\n                                 | ACE4_EXECUTE)) == 0))\n        return 1;\n    }\n  return 0;\n#  endif\n}",
      "lines": 27,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "free_permission_context": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "void\nfree_permission_context (struct permission_context *ctx)\n{\n#if USE_ACL\n# if HAVE_ACL_GET_FILE /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n  if (ctx->acl)\n    acl_free (ctx->acl);\n#  if !HAVE_ACL_TYPE_EXTENDED\n  if (ctx->default_acl)\n    acl_free (ctx->default_acl);\n#  endif\n\n# elif defined GETACL /* Solaris, Cygwin */\n  free (ctx->entries);\n#  ifdef ACE_GETACL\n  free (ctx->ace_entries);\n#  endif\n\n# elif HAVE_GETACL /* HP-UX */\n\n#  if HAVE_ACLV_H\n#  endif\n\n# elif HAVE_STATACL /* older AIX */\n\n# elif HAVE_ACLSORT /* NonStop Kernel */\n\n# endif\n#endif\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/acl-internal.h": {
    "rpl_acl_get_fd": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "ACL_INTERNAL_INLINE acl_t\nrpl_acl_get_fd (int fd)\n{\n  return acl_get_fd (fd, ACL_TYPE_ACCESS);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "ACL_INTERNAL_INLINE",
        "acl_t",
        "acl_t"
      ]
    },
    "rpl_acl_set_fd": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "ACL_INTERNAL_INLINE int\nrpl_acl_set_fd (int fd, acl_t acl)\n{\n  return acl_set_fd (fd, ACL_TYPE_ACCESS, acl);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "ACL_INTERNAL_INLINE",
        "int",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/acl.h": {},
  "tar/tar-1.30/gnu/acl_entries.c": {
    "acl_entries": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nacl_entries (acl_t acl)\n{\n  int count = 0;\n\n  if (acl != NULL)\n    {\n#if HAVE_ACL_FIRST_ENTRY /* Linux, FreeBSD, Mac OS X */\n# if HAVE_ACL_TYPE_EXTENDED /* Mac OS X */\n      /* acl_get_entry returns 0 when it successfully fetches an entry,\n         and -1/EINVAL at the end.  */\n      acl_entry_t ace;\n      int got_one;\n\n      for (got_one = acl_get_entry (acl, ACL_FIRST_ENTRY, &ace);\n           got_one >= 0;\n           got_one = acl_get_entry (acl, ACL_NEXT_ENTRY, &ace))\n        count++;\n# else /* Linux, FreeBSD */\n      /* acl_get_entry returns 1 when it successfully fetches an entry,\n         and 0 at the end.  */\n      acl_entry_t ace;\n      int got_one;\n\n      for (got_one = acl_get_entry (acl, ACL_FIRST_ENTRY, &ace);\n           got_one > 0;\n           got_one = acl_get_entry (acl, ACL_NEXT_ENTRY, &ace))\n        count++;\n      if (got_one < 0)\n        return -1;\n# endif\n#else /* IRIX, Tru64 */\n# if HAVE_ACL_TO_SHORT_TEXT /* IRIX */\n      /* Don't use acl_get_entry: it is undocumented.  */\n      count = acl->acl_cnt;\n# endif\n# if HAVE_ACL_FREE_TEXT /* Tru64 */\n      /* Don't use acl_get_entry: it takes only one argument and does not\n         work.  */\n      count = acl->acl_num;\n# endif\n#endif\n    }\n\n  return count;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/alignof.h": {},
  "tar/tar-1.30/gnu/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\nfind_stack_direction (int *addr, int depth)\n{\n  int dir, dummy = 0;\n  if (! addr)\n    addr = &dummy;\n  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;\n  dir = depth ? find_stack_direction (addr, depth - 1) : 0;\n  return dir + dummy;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloca": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void *\nalloca (size_t size)\n{\n  auto char probe;              /* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)           /* Unknown growth direction.  */\n    STACK_DIR = find_stack_direction (NULL, (size & 1) + 20);\n#  endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently.  */\n\n  {\n    register header *hp;        /* Traverses linked list.  */\n\n#  ifdef emacs\n    BLOCK_INPUT;\n#  endif\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n          || (STACK_DIR < 0 && hp->h.deep < depth))\n        {\n          register header *np = hp->h.next;\n\n          free (hp);            /* Collect garbage.  */\n\n          hp = np;              /* -> next header.  */\n        }\n      else\n        break;                  /* Rest are not deeper.  */\n\n    last_alloca_header = hp;    /* -> last valid storage.  */\n\n#  ifdef emacs\n    UNBLOCK_INPUT;\n#  endif\n  }\n\n  if (size == 0)\n    return NULL;                /* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    /* Address of header.  */\n    register header *new;\n\n    size_t combined_size = sizeof (header) + size;\n    if (combined_size < sizeof (header))\n      memory_full ();\n\n    new = malloc (combined_size);\n\n    if (! new)\n      memory_full ();\n\n    new->h.next = last_alloca_header;\n    new->h.deep = depth;\n\n    last_alloca_header = new;\n\n    /* User storage begins just after header.  */\n\n    return (void *) (new + 1);\n  }\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "void",
        "*\nalloca (size_t size)",
        "*"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          328,
          0
        ],
        "end_point": [
          393,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n                                    + status.current_size\n                                    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n        abort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n        break;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n        abort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          402,
          0
        ],
        "end_point": [
          471,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#    endif\n      if (pseg == 0)\n        break;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#    endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "tar/tar-1.30/gnu/alloca.in.h": {},
  "tar/tar-1.30/gnu/allocator.c": {},
  "tar/tar-1.30/gnu/allocator.h": {},
  "tar/tar-1.30/gnu/anytostr.c": {
    "__attribute_warn_unused_result__": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "char * __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)\n{\n  char *p = buf + INT_STRLEN_BOUND (inttype);\n  *p = 0;\n\n  if (i < 0)\n    {\n      do\n        *--p = '0' - i % 10;\n      while ((i /= 10) != 0);\n\n      *--p = '-';\n    }\n  else\n    {\n      do\n        *--p = '0' + i % 10;\n      while ((i /= 10) != 0);\n    }\n\n  return p;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "* __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/areadlink-with-size.c": {
    "areadlink_with_size": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "char *\nareadlink_with_size (char const *file, size_t size)\n{\n  /* Some buggy file systems report garbage in st_size.  Defend\n     against them by ignoring outlandish st_size values in the initial\n     memory allocation.  */\n  size_t symlink_max = SYMLINK_MAX;\n  size_t INITIAL_LIMIT_BOUND = 8 * 1024;\n  size_t initial_limit = (symlink_max < INITIAL_LIMIT_BOUND\n                          ? symlink_max + 1\n                          : INITIAL_LIMIT_BOUND);\n\n  /* The initial buffer size for the link value.  */\n  size_t buf_size = size < initial_limit ? size + 1 : initial_limit;\n\n  while (1)\n    {\n      ssize_t r;\n      size_t link_length;\n      char *buffer = malloc (buf_size);\n\n      if (buffer == NULL)\n        return NULL;\n      r = readlink (file, buffer, buf_size);\n      link_length = r;\n\n      /* On AIX 5L v5.3 and HP-UX 11i v2 04/09, readlink returns -1\n         with errno == ERANGE if the buffer is too small.  */\n      if (r < 0 && errno != ERANGE)\n        {\n          int saved_errno = errno;\n          free (buffer);\n          errno = saved_errno;\n          return NULL;\n        }\n\n      if (link_length < buf_size)\n        {\n          buffer[link_length] = 0;\n          return buffer;\n        }\n\n      free (buffer);\n      if (buf_size <= MAXSIZE / 2)\n        buf_size *= 2;\n      else if (buf_size < MAXSIZE)\n        buf_size = MAXSIZE;\n      else\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n    }\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "char",
        "*\nareadlink_with_size (char const *file, size_t size)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/areadlink.c": {
    "careadlinkatcwd": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static ssize_t\ncareadlinkatcwd (int fd, char const *filename, char *buffer,\n                 size_t buffer_size)\n{\n  /* FD must be AT_FDCWD here, otherwise the caller is using this\n     function in contexts it was not meant for.  */\n  if (fd != AT_FDCWD)\n    abort ();\n  return readlink (filename, buffer, buffer_size);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "areadlink": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "char *\nareadlink (char const *filename)\n{\n  return careadlinkat (AT_FDCWD, filename, NULL, 0, NULL, careadlinkatcwd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nareadlink (char const *filename)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/areadlink.h": {},
  "tar/tar-1.30/gnu/areadlinkat-with-size.c": {
    "areadlinkat_with_size": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "char *\nareadlinkat_with_size (int fd, char const *file, size_t size)\n{\n  /* Some buggy file systems report garbage in st_size.  Defend\n     against them by ignoring outlandish st_size values in the initial\n     memory allocation.  */\n  size_t symlink_max = SYMLINK_MAX;\n  size_t INITIAL_LIMIT_BOUND = 8 * 1024;\n  size_t initial_limit = (symlink_max < INITIAL_LIMIT_BOUND\n                          ? symlink_max + 1\n                          : INITIAL_LIMIT_BOUND);\n\n  /* The initial buffer size for the link value.  */\n  size_t buf_size = size < initial_limit ? size + 1 : initial_limit;\n\n  while (1)\n    {\n      ssize_t r;\n      size_t link_length;\n      char *buffer = malloc (buf_size);\n\n      if (buffer == NULL)\n        return NULL;\n      r = readlinkat (fd, file, buffer, buf_size);\n      link_length = r;\n\n      /* On AIX 5L v5.3 and HP-UX 11i v2 04/09, readlink returns -1\n         with errno == ERANGE if the buffer is too small.  */\n      if (r < 0 && errno != ERANGE)\n        {\n          int saved_errno = errno;\n          free (buffer);\n          errno = saved_errno;\n          return NULL;\n        }\n\n      if (link_length < buf_size)\n        {\n          buffer[link_length] = 0;\n          return buffer;\n        }\n\n      free (buffer);\n      if (buf_size <= MAXSIZE / 2)\n        buf_size *= 2;\n      else if (buf_size < MAXSIZE)\n        buf_size = MAXSIZE;\n      else\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n    }\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "char",
        "*\nareadlinkat_with_size (int fd, char const *file, size_t size)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/areadlinkat.c": {
    "areadlinkat": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "char *\nareadlinkat (int fd, char const *filename)\n{\n  return careadlinkat (fd, filename, NULL, 0, NULL, readlinkat);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nareadlinkat (int fd, char const *filename)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/arg-nonnull.h": {},
  "tar/tar-1.30/gnu/argmatch.c": {
    "__argmatch_die": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static void\n__argmatch_die (void)\n{\n  ARGMATCH_DIE;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argmatch": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "ptrdiff_t\nargmatch (const char *arg, const char *const *arglist,\n          const char *vallist, size_t valsize)\n{\n  size_t i;                     /* Temporary index in ARGLIST.  */\n  size_t arglen;                /* Length of ARG.  */\n  ptrdiff_t matchind = -1;      /* Index of first nonexact match.  */\n  bool ambiguous = false;       /* If true, multiple nonexact match(es).  */\n\n  arglen = strlen (arg);\n\n  /* Test all elements for either exact match or abbreviated matches.  */\n  for (i = 0; arglist[i]; i++)\n    {\n      if (!strncmp (arglist[i], arg, arglen))\n        {\n          if (strlen (arglist[i]) == arglen)\n            /* Exact match found.  */\n            return i;\n          else if (matchind == -1)\n            /* First nonexact match found.  */\n            matchind = i;\n          else\n            {\n              /* Second nonexact match found.  */\n              if (vallist == NULL\n                  || memcmp (vallist + valsize * matchind,\n                             vallist + valsize * i, valsize))\n                {\n                  /* There is a real ambiguity, or we could not\n                     disambiguate. */\n                  ambiguous = true;\n                }\n            }\n        }\n    }\n  if (ambiguous)\n    return -2;\n  else\n    return matchind;\n}",
      "lines": 41,
      "depth": 17,
      "decorators": [
        "ptrdiff_t"
      ]
    },
    "argmatch_invalid": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\nargmatch_invalid (const char *context, const char *value, ptrdiff_t problem)\n{\n  char const *format = (problem == -1\n                        ? _(\"invalid argument %s for %s\")\n                        : _(\"ambiguous argument %s for %s\"));\n\n  error (0, 0, format, quotearg_n_style (0, ARGMATCH_QUOTING_STYLE, value),\n         quote_n (1, context));\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "argmatch_valid": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\nargmatch_valid (const char *const *arglist,\n                const char *vallist, size_t valsize)\n{\n  size_t i;\n  const char *last_val = NULL;\n\n  /* We try to put synonyms on the same line.  The assumption is that\n     synonyms follow each other */\n  fputs (_(\"Valid arguments are:\"), stderr);\n  for (i = 0; arglist[i]; i++)\n    if ((i == 0)\n        || memcmp (last_val, vallist + valsize * i, valsize))\n      {\n        fprintf (stderr, \"\\n  - %s\", quote (arglist[i]));\n        last_val = vallist + valsize * i;\n      }\n    else\n      {\n        fprintf (stderr, \", %s\", quote (arglist[i]));\n      }\n  putc ('\\n', stderr);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "__xargmatch_internal": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "ptrdiff_t\n__xargmatch_internal (const char *context,\n                      const char *arg, const char *const *arglist,\n                      const char *vallist, size_t valsize,\n                      argmatch_exit_fn exit_fn)\n{\n  ptrdiff_t res = argmatch (arg, arglist, vallist, valsize);\n  if (res >= 0)\n    /* Success. */\n    return res;\n\n  /* We failed.  Explain why. */\n  argmatch_invalid (context, arg, res);\n  argmatch_valid (arglist, vallist, valsize);\n  (*exit_fn) ();\n\n  return -1; /* To please the compilers. */\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "ptrdiff_t"
      ]
    },
    "argmatch_to_argument": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "const char *\nargmatch_to_argument (const char *value,\n                      const char *const *arglist,\n                      const char *vallist, size_t valsize)\n{\n  size_t i;\n\n  for (i = 0; arglist[i]; i++)\n    if (!memcmp (value, vallist + valsize * i, valsize))\n      return arglist[i];\n  return NULL;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nargmatch_to_argument (const char *value,\n                      const char *const *arglist,\n                      const char *vallist, size_t valsize)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "int\nmain (int argc, const char *const *argv)\n{\n  const char *cp;\n  enum backup_type backup_type = no_backups;\n\n  if (argc > 2)\n    {\n      fprintf (stderr, \"Usage: %s [VERSION_CONTROL]\\n\", getprogname ());\n      exit (1);\n    }\n\n  if ((cp = getenv (\"VERSION_CONTROL\")))\n    backup_type = XARGMATCH (\"$VERSION_CONTROL\", cp,\n                             backup_args, backup_vals);\n\n  if (argc == 2)\n    backup_type = XARGMATCH (getprogname (), argv[1],\n                             backup_args, backup_vals);\n\n  printf (\"The version control is '%s'\\n\",\n          ARGMATCH_TO_ARGUMENT (backup_type, backup_args, backup_vals));\n\n  return 0;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/argmatch.h": {},
  "tar/tar-1.30/gnu/argp-ba.c": {},
  "tar/tar-1.30/gnu/argp-eexst.c": {},
  "tar/tar-1.30/gnu/argp-fmtstream.c": {
    "__argp_make_fmtstream": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "argp_fmtstream_t\n__argp_make_fmtstream (FILE *stream,\n                       size_t lmargin, size_t rmargin, ssize_t wmargin)\n{\n  argp_fmtstream_t fs;\n\n  fs = (struct argp_fmtstream *) malloc (sizeof (struct argp_fmtstream));\n  if (fs != NULL)\n    {\n      fs->stream = stream;\n\n      fs->lmargin = lmargin;\n      fs->rmargin = rmargin;\n      fs->wmargin = wmargin;\n      fs->point_col = 0;\n      fs->point_offs = 0;\n\n      fs->buf = (char *) malloc (INIT_BUF_SIZE);\n      if (! fs->buf)\n        {\n          free (fs);\n          fs = 0;\n        }\n      else\n        {\n          fs->p = fs->buf;\n          fs->end = fs->buf + INIT_BUF_SIZE;\n        }\n    }\n\n  return fs;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "argp_fmtstream_t"
      ]
    },
    "__argp_fmtstream_free": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\n__argp_fmtstream_free (argp_fmtstream_t fs)\n{\n  __argp_fmtstream_update (fs);\n  if (fs->p > fs->buf)\n    {\n#ifdef _LIBC\n      __fxprintf (fs->stream, \"%.*s\", (int) (fs->p - fs->buf), fs->buf);\n#else\n      fwrite_unlocked (fs->buf, 1, fs->p - fs->buf, fs->stream);\n#endif\n    }\n  free (fs->buf);\n  free (fs);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "__argp_fmtstream_update": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "void\n__argp_fmtstream_update (argp_fmtstream_t fs)\n{\n  char *buf, *nl;\n  size_t len;\n\n  /* Scan the buffer for newlines.  */\n  buf = fs->buf + fs->point_offs;\n  while (buf < fs->p)\n    {\n      size_t r;\n\n      if (fs->point_col == 0 && fs->lmargin != 0)\n        {\n          /* We are starting a new line.  Print spaces to the left margin.  */\n          const size_t pad = fs->lmargin;\n          if (fs->p + pad < fs->end)\n            {\n              /* We can fit in them in the buffer by moving the\n                 buffer text up and filling in the beginning.  */\n              memmove (buf + pad, buf, fs->p - buf);\n              fs->p += pad; /* Compensate for bigger buffer. */\n              memset (buf, ' ', pad); /* Fill in the spaces.  */\n              buf += pad; /* Don't bother searching them.  */\n            }\n          else\n            {\n              /* No buffer space for spaces.  Must flush.  */\n              size_t i;\n              for (i = 0; i < pad; i++)\n                {\n#ifdef _LIBC\n                  if (_IO_fwide (fs->stream, 0) > 0)\n                    putwc_unlocked (L' ', fs->stream);\n                  else\n#endif\n                    putc_unlocked (' ', fs->stream);\n                }\n            }\n          fs->point_col = pad;\n        }\n\n      len = fs->p - buf;\n      nl = memchr (buf, '\\n', len);\n\n      if (fs->point_col < 0)\n        fs->point_col = 0;\n\n      if (!nl)\n        {\n          /* The buffer ends in a partial line.  */\n\n          if (fs->point_col + len < fs->rmargin)\n            {\n              /* The remaining buffer text is a partial line and fits\n                 within the maximum line width.  Advance point for the\n                 characters to be written and stop scanning.  */\n              fs->point_col += len;\n              break;\n            }\n          else\n            /* Set the end-of-line pointer for the code below to\n               the end of the buffer.  */\n            nl = fs->p;\n        }\n      else if (fs->point_col + (nl - buf) < (ssize_t) fs->rmargin)\n        {\n          /* The buffer contains a full line that fits within the maximum\n             line width.  Reset point and scan the next line.  */\n          fs->point_col = 0;\n          buf = nl + 1;\n          continue;\n        }\n\n      /* This line is too long.  */\n      r = fs->rmargin - 1;\n\n      if (fs->wmargin < 0)\n        {\n          /* Truncate the line by overwriting the excess with the\n             newline and anything after it in the buffer.  */\n          if (nl < fs->p)\n            {\n              memmove (buf + (r - fs->point_col), nl, fs->p - nl);\n              fs->p -= buf + (r - fs->point_col) - nl;\n              /* Reset point for the next line and start scanning it.  */\n              fs->point_col = 0;\n              buf += r + 1; /* Skip full line plus \\n. */\n            }\n          else\n            {\n              /* The buffer ends with a partial line that is beyond the\n                 maximum line width.  Advance point for the characters\n                 written, and discard those past the max from the buffer.  */\n              fs->point_col += len;\n              fs->p -= fs->point_col - r;\n              break;\n            }\n        }\n      else\n        {\n          /* Do word wrap.  Go to the column just past the maximum line\n             width and scan back for the beginning of the word there.\n             Then insert a line break.  */\n\n          char *p, *nextline;\n          int i;\n\n          p = buf + (r + 1 - fs->point_col);\n          while (p >= buf && !isblank ((unsigned char) *p))\n            --p;\n          nextline = p + 1;     /* This will begin the next line.  */\n\n          if (nextline > buf)\n            {\n              /* Swallow separating blanks.  */\n              if (p >= buf)\n                do\n                  --p;\n                while (p >= buf && isblank ((unsigned char) *p));\n              nl = p + 1;       /* The newline will replace the first blank. */\n            }\n          else\n            {\n              /* A single word that is greater than the maximum line width.\n                 Oh well.  Put it on an overlong line by itself.  */\n              p = buf + (r + 1 - fs->point_col);\n              /* Find the end of the long word.  */\n              if (p < nl)\n                do\n                  ++p;\n                while (p < nl && !isblank ((unsigned char) *p));\n              if (p == nl)\n                {\n                  /* It already ends a line.  No fussing required.  */\n                  fs->point_col = 0;\n                  buf = nl + 1;\n                  continue;\n                }\n              /* We will move the newline to replace the first blank.  */\n              nl = p;\n              /* Swallow separating blanks.  */\n              do\n                ++p;\n              while (isblank ((unsigned char) *p));\n              /* The next line will start here.  */\n              nextline = p;\n            }\n\n          /* Note: There are a bunch of tests below for\n             NEXTLINE == BUF + LEN + 1; this case is where NL happens to fall\n             at the end of the buffer, and NEXTLINE is in fact empty (and so\n             we need not be careful to maintain its contents).  */\n\n          if ((nextline == buf + len + 1\n               ? fs->end - nl < fs->wmargin + 1\n               : nextline - (nl + 1) < fs->wmargin)\n              && fs->p > nextline)\n            {\n              /* The margin needs more blanks than we removed.  */\n              if (fs->end - fs->p > fs->wmargin + 1)\n                /* Make some space for them.  */\n                {\n                  size_t mv = fs->p - nextline;\n                  memmove (nl + 1 + fs->wmargin, nextline, mv);\n                  nextline = nl + 1 + fs->wmargin;\n                  len = nextline + mv - buf;\n                  *nl++ = '\\n';\n                }\n              else\n                /* Output the first line so we can use the space.  */\n                {\n#ifdef _LIBC\n                  __fxprintf (fs->stream, \"%.*s\\n\",\n                              (int) (nl - fs->buf), fs->buf);\n#else\n                  if (nl > fs->buf)\n                    fwrite_unlocked (fs->buf, 1, nl - fs->buf, fs->stream);\n                  putc_unlocked ('\\n', fs->stream);\n#endif\n\n                  len += buf - fs->buf;\n                  nl = buf = fs->buf;\n                }\n            }\n          else\n            /* We can fit the newline and blanks in before\n               the next word.  */\n            *nl++ = '\\n';\n\n          if (nextline - nl >= fs->wmargin\n              || (nextline == buf + len + 1 && fs->end - nextline >= fs->wmargin))\n            /* Add blanks up to the wrap margin column.  */\n            for (i = 0; i < fs->wmargin; ++i)\n              *nl++ = ' ';\n          else\n            for (i = 0; i < fs->wmargin; ++i)\n#ifdef _LIBC\n              if (_IO_fwide (fs->stream, 0) > 0)\n                putwc_unlocked (L' ', fs->stream);\n              else\n#endif\n                putc_unlocked (' ', fs->stream);\n\n          /* Copy the tail of the original buffer into the current buffer\n             position.  */\n          if (nl < nextline)\n            memmove (nl, nextline, buf + len - nextline);\n          len -= nextline - buf;\n\n          /* Continue the scan on the remaining lines in the buffer.  */\n          buf = nl;\n\n          /* Restore bufp to include all the remaining text.  */\n          fs->p = nl + len;\n\n          /* Reset the counter of what has been output this line.  If wmargin\n             is 0, we want to avoid the lmargin getting added, so we set\n             point_col to a magic value of -1 in that case.  */\n          fs->point_col = fs->wmargin ? fs->wmargin : -1;\n        }\n    }\n\n  /* Remember that we've scanned as far as the end of the buffer.  */\n  fs->point_offs = fs->p - fs->buf;\n}",
      "lines": 226,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "__argp_fmtstream_ensure": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "int\n__argp_fmtstream_ensure (struct argp_fmtstream *fs, size_t amount)\n{\n  if ((size_t) (fs->end - fs->p) < amount)\n    {\n      ssize_t wrote;\n\n      /* Flush FS's buffer.  */\n      __argp_fmtstream_update (fs);\n\n#ifdef _LIBC\n      __fxprintf (fs->stream, \"%.*s\", (int) (fs->p - fs->buf), fs->buf);\n      wrote = fs->p - fs->buf;\n#else\n      wrote = fwrite_unlocked (fs->buf, 1, fs->p - fs->buf, fs->stream);\n#endif\n      if (wrote == fs->p - fs->buf)\n        {\n          fs->p = fs->buf;\n          fs->point_offs = 0;\n        }\n      else\n        {\n          fs->p -= wrote;\n          fs->point_offs -= wrote;\n          memmove (fs->buf, fs->buf + wrote, fs->p - fs->buf);\n          return 0;\n        }\n\n      if ((size_t) (fs->end - fs->buf) < amount)\n        /* Gotta grow the buffer.  */\n        {\n          size_t old_size = fs->end - fs->buf;\n          size_t new_size = old_size + amount;\n          char *new_buf;\n\n          if (new_size < old_size || ! (new_buf = realloc (fs->buf, new_size)))\n            {\n              __set_errno (ENOMEM);\n              return 0;\n            }\n\n          fs->buf = new_buf;\n          fs->end = new_buf + new_size;\n          fs->p = fs->buf;\n        }\n    }\n\n  return 1;\n}",
      "lines": 50,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "__argp_fmtstream_printf": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "ssize_t\n__argp_fmtstream_printf (struct argp_fmtstream *fs, const char *fmt, ...)\n{\n  int out;\n  size_t avail;\n  size_t size_guess = PRINTF_SIZE_GUESS; /* How much space to reserve. */\n\n  do\n    {\n      va_list args;\n\n      if (! __argp_fmtstream_ensure (fs, size_guess))\n        return -1;\n\n      va_start (args, fmt);\n      avail = fs->end - fs->p;\n      out = __vsnprintf (fs->p, avail, fmt, args);\n      va_end (args);\n      if ((size_t) out >= avail)\n        size_guess = out + 1;\n    }\n  while ((size_t) out >= avail);\n\n  fs->p += out;\n\n  return out;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/argp-fmtstream.h": {
    "__argp_fmtstream_write": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_write (argp_fmtstream_t __fs, const char *__str, size_t __len)\n{\n  if (__fs->p + __len <= __fs->end || __argp_fmtstream_ensure (__fs, __len))\n    {\n      memcpy (__fs->p, __str, __len);\n      __fs->p += __len;\n      return __len;\n    }\n  else\n    return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_puts": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "ARGP_FS_EI int\n__argp_fmtstream_puts (argp_fmtstream_t __fs, const char *__str)\n{\n  size_t __len = strlen (__str);\n  if (__len)\n    {\n      size_t __wrote = __argp_fmtstream_write (__fs, __str, __len);\n      return __wrote == __len ? 0 : -1;\n    }\n  else\n    return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "int",
        "int"
      ]
    },
    "__argp_fmtstream_putc": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "ARGP_FS_EI int\n__argp_fmtstream_putc (argp_fmtstream_t __fs, int __ch)\n{\n  if (__fs->p < __fs->end || __argp_fmtstream_ensure (__fs, 1))\n    return *__fs->p++ = __ch;\n  else\n    return EOF;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "int",
        "int"
      ]
    },
    "__argp_fmtstream_set_lmargin": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_lmargin (argp_fmtstream_t __fs, size_t __lmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->lmargin;\n  __fs->lmargin = __lmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_set_rmargin": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_rmargin (argp_fmtstream_t __fs, size_t __rmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->rmargin;\n  __fs->rmargin = __rmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_set_wmargin": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_wmargin (argp_fmtstream_t __fs, size_t __wmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->wmargin;\n  __fs->wmargin = __wmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_point": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_point (argp_fmtstream_t __fs)\n{\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  return __fs->point_col >= 0 ? __fs->point_col : 0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/argp-fs-xinl.c": {},
  "tar/tar-1.30/gnu/argp-help.c": {
    "validate_uparams": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static void\nvalidate_uparams (const struct argp_state *state, struct uparams *upptr)\n{\n  const struct uparam_name *up;\n\n  for (up = uparam_names; up < uparam_names + nuparam_names; up++)\n    {\n      if (up->is_bool\n          || up->uparams_offs == offsetof (struct uparams, rmargin))\n        continue;\n      if (*(int *)((char *)upptr + up->uparams_offs) >= upptr->rmargin)\n        {\n          __argp_failure (state, 0, 0,\n                          dgettext (state->root_argp->argp_domain,\n                                    \"\\\nARGP_HELP_FMT: %s value is less than or equal to %s\"),\n                          \"rmargin\", up->name);\n          return;\n        }\n    }\n  uparams = *upptr;\n  uparams.valid = 1;\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fill_in_uparams": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static void\nfill_in_uparams (const struct argp_state *state)\n{\n  const char *var = getenv (\"ARGP_HELP_FMT\");\n  struct uparams new_params = uparams;\n\n#define SKIPWS(p) do { while (isspace ((unsigned char) *p)) p++; } while (0);\n\n  if (var)\n    {\n      /* Parse var. */\n      while (*var)\n        {\n          SKIPWS (var);\n\n          if (isalpha ((unsigned char) *var))\n            {\n              size_t var_len;\n              const struct uparam_name *un;\n              int unspec = 0, val = 0;\n              const char *arg = var;\n\n              while (isalnum ((unsigned char) *arg) || *arg == '-' || *arg == '_')\n                arg++;\n              var_len = arg - var;\n\n              SKIPWS (arg);\n\n              if (*arg == '\\0' || *arg == ',')\n                unspec = 1;\n              else if (*arg == '=')\n                {\n                  arg++;\n                  SKIPWS (arg);\n                }\n\n              if (unspec)\n                {\n                  if (var[0] == 'n' && var[1] == 'o' && var[2] == '-')\n                    {\n                      val = 0;\n                      var += 3;\n                      var_len -= 3;\n                    }\n                  else\n                    val = 1;\n                }\n              else if (isdigit ((unsigned char) *arg))\n                {\n                  val = atoi (arg);\n                  while (isdigit ((unsigned char) *arg))\n                    arg++;\n                  SKIPWS (arg);\n                }\n\n              for (un = uparam_names;\n                   un < uparam_names + nuparam_names;\n                   un++)\n                if (strlen (un->name) == var_len\n                    && strncmp (var, un->name, var_len) == 0)\n                  {\n                    if (unspec && !un->is_bool)\n                      __argp_failure (state, 0, 0,\n                                      dgettext (state == NULL ? NULL\n                                                : state->root_argp->argp_domain,\n                                                \"\\\n%.*s: ARGP_HELP_FMT parameter requires a value\"),\n                                      (int) var_len, var);\n                    else\n                      *(int *)((char *)&new_params + un->uparams_offs) = val;\n                    break;\n                  }\n              if (un == uparam_names + nuparam_names)\n                __argp_failure (state, 0, 0,\n                                dgettext (state == NULL ? NULL\n                                          : state->root_argp->argp_domain, \"\\\n%.*s: Unknown ARGP_HELP_FMT parameter\"),\n                                (int) var_len, var);\n\n              var = arg;\n              if (*var == ',')\n                var++;\n            }\n          else if (*var)\n            {\n              __argp_failure (state, 0, 0,\n                              dgettext (state == NULL ? NULL\n                                        : state->root_argp->argp_domain,\n                                        \"Garbage in ARGP_HELP_FMT: %s\"), var);\n              break;\n            }\n        }\n      validate_uparams (state, &new_params);\n    }\n}",
      "lines": 95,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_char": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "static int\nfind_char (char ch, char *beg, char *end)\n{\n  while (beg < end)\n    if (*beg == ch)\n      return 1;\n    else\n      beg++;\n  return 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "make_hol": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        498,
        1
      ],
      "content": "static struct hol *\nmake_hol (const struct argp *argp, struct hol_cluster *cluster)\n{\n  char *so;\n  const struct argp_option *o;\n  const struct argp_option *opts = argp->options;\n  struct hol_entry *entry;\n  unsigned num_short_options = 0;\n  struct hol *hol = malloc (sizeof (struct hol));\n\n  assert (hol);\n\n  hol->num_entries = 0;\n  hol->clusters = 0;\n\n  if (opts)\n    {\n      int cur_group = 0;\n\n      /* The first option must not be an alias.  */\n      assert (! oalias (opts));\n\n      /* Calculate the space needed.  */\n      for (o = opts; ! oend (o); o++)\n        {\n          if (! oalias (o))\n            hol->num_entries++;\n          if (oshort (o))\n            num_short_options++;        /* This is an upper bound.  */\n        }\n\n      hol->entries = malloc (sizeof (struct hol_entry) * hol->num_entries);\n      hol->short_options = malloc (num_short_options + 1);\n\n      assert (hol->entries && hol->short_options);\n      if (SIZE_MAX <= UINT_MAX)\n        assert (hol->num_entries <= SIZE_MAX / sizeof (struct hol_entry));\n\n      /* Fill in the entries.  */\n      so = hol->short_options;\n      for (o = opts, entry = hol->entries; ! oend (o); entry++)\n        {\n          entry->opt = o;\n          entry->num = 0;\n          entry->short_options = so;\n          entry->group = cur_group =\n            o->group\n            ? o->group\n            : ((!o->name && !o->key)\n               ? cur_group + 1\n               : cur_group);\n          entry->cluster = cluster;\n          entry->argp = argp;\n\n          do\n            {\n              entry->num++;\n              if (oshort (o) && ! find_char (o->key, hol->short_options, so))\n                /* O has a valid short option which hasn't already been used.*/\n                *so++ = o->key;\n              o++;\n            }\n          while (! oend (o) && oalias (o));\n        }\n      *so = '\\0';               /* null terminated so we can find the length */\n    }\n\n  return hol;\n}",
      "lines": 69,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "struct hol",
        "struct",
        "hol",
        "*\nmake_hol (const struct argp *argp, struct hol_cluster *cluster)",
        "*"
      ]
    },
    "hol_add_cluster": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "static struct hol_cluster *\nhol_add_cluster (struct hol *hol, int group, const char *header, int index,\n                 struct hol_cluster *parent, const struct argp *argp)\n{\n  struct hol_cluster *cl = malloc (sizeof (struct hol_cluster));\n  if (cl)\n    {\n      cl->group = group;\n      cl->header = header;\n\n      cl->index = index;\n      cl->parent = parent;\n      cl->argp = argp;\n      cl->depth = parent ? parent->depth + 1 : 0;\n\n      cl->next = hol->clusters;\n      hol->clusters = cl;\n    }\n  return cl;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct hol_cluster",
        "struct",
        "hol_cluster",
        "*\nhol_add_cluster (struct hol *hol, int group, const char *header, int index,\n                 struct hol_cluster *parent, const struct argp *argp)",
        "*"
      ]
    },
    "hol_free": {
      "start_point": [
        525,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "static void\nhol_free (struct hol *hol)\n{\n  struct hol_cluster *cl = hol->clusters;\n\n  while (cl)\n    {\n      struct hol_cluster *next = cl->next;\n      free (cl);\n      cl = next;\n    }\n\n  if (hol->num_entries > 0)\n    {\n      free (hol->entries);\n      free (hol->short_options);\n    }\n\n  free (hol);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_entry_short_iterate": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        569,
        1
      ],
      "content": "static int\nhol_entry_short_iterate (const struct hol_entry *entry,\n                         int (*func)(const struct argp_option *opt,\n                                     const struct argp_option *real,\n                                     const char *domain, void *cookie),\n                         const char *domain, void *cookie)\n{\n  unsigned nopts;\n  int val = 0;\n  const struct argp_option *opt, *real = entry->opt;\n  char *so = entry->short_options;\n\n  for (opt = real, nopts = entry->num; nopts > 0 && !val; opt++, nopts--)\n    if (oshort (opt) && *so == opt->key)\n      {\n        if (!oalias (opt))\n          real = opt;\n        if (ovisible (opt))\n          val = (*func)(opt, real, domain, cookie);\n        so++;\n      }\n\n  return val;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "always_inline": {
      "start_point": [
        579,
        30
      ],
      "end_point": [
        595,
        1
      ],
      "content": "char *domain, void *cookie)\n{\n  unsigned nopts;\n  int val = 0;\n  const struct argp_option *opt, *real = entry->opt;\n\n  for (opt = real, nopts = entry->num; nopts > 0 && !val; opt++, nopts--)\n    if (opt->name)\n      {\n        if (!oalias (opt))\n          real = opt;\n        if (ovisible (opt))\n          val = (*func)(opt, real, domain, cookie);\n      }\n\n  return val;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": null
    },
    "until_short": {
      "start_point": [
        598,
        0
      ],
      "end_point": [
        603,
        1
      ],
      "content": "static int\nuntil_short (const struct argp_option *opt, const struct argp_option *real,\n             const char *domain, void *cookie)\n{\n  return oshort (opt) ? opt->key : 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_first_short": {
      "start_point": [
        606,
        0
      ],
      "end_point": [
        611,
        1
      ],
      "content": "static char\nhol_entry_first_short (const struct hol_entry *entry)\n{\n  return hol_entry_short_iterate (entry, until_short,\n                                  entry->argp->argp_domain, 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "hol_entry_first_long": {
      "start_point": [
        614,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "static const char *\nhol_entry_first_long (const struct hol_entry *entry)\n{\n  const struct argp_option *opt;\n  unsigned num;\n  for (opt = entry->opt, num = entry->num; num > 0; opt++, num--)\n    if (opt->name && ovisible (opt))\n      return opt->name;\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nhol_entry_first_long (const struct hol_entry *entry)",
        "*"
      ]
    },
    "hol_find_entry": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        648,
        1
      ],
      "content": "static struct hol_entry *\nhol_find_entry (struct hol *hol, const char *name)\n{\n  struct hol_entry *entry = hol->entries;\n  unsigned num_entries = hol->num_entries;\n\n  while (num_entries-- > 0)\n    {\n      const struct argp_option *opt = entry->opt;\n      unsigned num_opts = entry->num;\n\n      while (num_opts-- > 0)\n        if (opt->name && ovisible (opt) && strcmp (opt->name, name) == 0)\n          return entry;\n        else\n          opt++;\n\n      entry++;\n    }\n\n  return 0;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct hol_entry",
        "struct",
        "hol_entry",
        "*\nhol_find_entry (struct hol *hol, const char *name)",
        "*"
      ]
    },
    "hol_set_group": {
      "start_point": [
        652,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "static void\nhol_set_group (struct hol *hol, const char *name, int group)\n{\n  struct hol_entry *entry = hol_find_entry (hol, name);\n  if (entry)\n    entry->group = group;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "group_cmp": {
      "start_point": [
        662,
        0
      ],
      "end_point": [
        671,
        1
      ],
      "content": "static int\ngroup_cmp (int group1, int group2, int eq)\n{\n  if (group1 == group2)\n    return eq;\n  else if ((group1 < 0 && group2 < 0) || (group1 >= 0 && group2 >= 0))\n    return group1 - group2;\n  else\n    return group2 - group1;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_cluster_cmp": {
      "start_point": [
        675,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "static int\nhol_cluster_cmp (const struct hol_cluster *cl1, const struct hol_cluster *cl2)\n{\n  /* If one cluster is deeper than the other, use its ancestor at the same\n     level, so that finding the common ancestor is straightforward.  */\n  while (cl1->depth > cl2->depth)\n    cl1 = cl1->parent;\n  while (cl2->depth > cl1->depth)\n    cl2 = cl2->parent;\n\n  /* Now reduce both clusters to their ancestors at the point where both have\n     a common parent; these can be directly compared.  */\n  while (cl1->parent != cl2->parent)\n    cl1 = cl1->parent, cl2 = cl2->parent;\n\n  return group_cmp (cl1->group, cl2->group, cl2->index - cl1->index);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_cluster_base": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        701,
        1
      ],
      "content": "static struct hol_cluster *\nhol_cluster_base (struct hol_cluster *cl)\n{\n  while (cl->parent)\n    cl = cl->parent;\n  return cl;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct hol_cluster",
        "struct",
        "hol_cluster",
        "*\nhol_cluster_base (struct hol_cluster *cl)",
        "*"
      ]
    },
    "hol_cluster_is_child": {
      "start_point": [
        704,
        0
      ],
      "end_point": [
        711,
        1
      ],
      "content": "static int\nhol_cluster_is_child (const struct hol_cluster *cl1,\n                      const struct hol_cluster *cl2)\n{\n  while (cl1 && cl1 != cl2)\n    cl1 = cl1->parent;\n  return cl1 == cl2;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "canon_doc_option": {
      "start_point": [
        716,
        0
      ],
      "end_point": [
        729,
        1
      ],
      "content": "static int\ncanon_doc_option (const char **name)\n{\n  int non_opt;\n  /* Skip initial whitespace.  */\n  while (isspace (**name))\n    (*name)++;\n  /* Decide whether this looks like an option (leading '-') or not.  */\n  non_opt = (**name != '-');\n  /* Skip until part of name used for sorting.  */\n  while (**name && !isalnum (**name))\n    (*name)++;\n  return non_opt;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_cmp": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        806,
        1
      ],
      "content": "static int\nhol_entry_cmp (const struct hol_entry *entry1,\n               const struct hol_entry *entry2)\n{\n  /* The group numbers by which the entries should be ordered; if either is\n     in a cluster, then this is just the group within the cluster.  */\n  int group1 = entry1->group, group2 = entry2->group;\n\n  if (entry1->cluster != entry2->cluster)\n    {\n      /* The entries are not within the same cluster, so we can't compare them\n         directly, we have to use the appropriate clustering level too.  */\n      if (! entry1->cluster)\n        /* ENTRY1 is at the 'base level', not in a cluster, so we have to\n           compare it's group number with that of the base cluster in which\n           ENTRY2 resides.  Note that if they're in the same group, the\n           clustered option always comes last.  */\n        return group_cmp (group1, hol_cluster_base (entry2->cluster)->group, -1);\n      else if (! entry2->cluster)\n        /* Likewise, but ENTRY2's not in a cluster.  */\n        return group_cmp (hol_cluster_base (entry1->cluster)->group, group2, 1);\n      else\n        /* Both entries are in clusters, we can just compare the clusters.  */\n        return hol_cluster_cmp (entry1->cluster, entry2->cluster);\n    }\n  else if (group1 == group2)\n    /* The entries are both in the same cluster and group, so compare them\n       alphabetically.  */\n    {\n      int short1 = hol_entry_first_short (entry1);\n      int short2 = hol_entry_first_short (entry2);\n      int doc1 = odoc (entry1->opt);\n      int doc2 = odoc (entry2->opt);\n      const char *long1 = hol_entry_first_long (entry1);\n      const char *long2 = hol_entry_first_long (entry2);\n\n      if (doc1)\n        doc1 = long1 != NULL && canon_doc_option (&long1);\n      if (doc2)\n        doc2 = long2 != NULL && canon_doc_option (&long2);\n\n      if (doc1 != doc2)\n        /* 'documentation' options always follow normal options (or\n           documentation options that *look* like normal options).  */\n        return doc1 - doc2;\n      else if (!short1 && !short2 && long1 && long2)\n        /* Only long options.  */\n        return __strcasecmp (long1, long2);\n      else\n        /* Compare short/short, long/short, short/long, using the first\n           character of long options.  Entries without *any* valid\n           options (such as options with OPTION_HIDDEN set) will be put\n           first, but as they're not displayed, it doesn't matter where\n           they are.  */\n        {\n          char first1 = short1 ? short1 : long1 ? *long1 : 0;\n          char first2 = short2 ? short2 : long2 ? *long2 : 0;\n#ifdef _tolower\n          int lower_cmp = _tolower (first1) - _tolower (first2);\n#else\n          int lower_cmp = tolower (first1) - tolower (first2);\n#endif\n          /* Compare ignoring case, except when the options are both the\n             same letter, in which case lower-case always comes first.  */\n          return lower_cmp ? lower_cmp : first2 - first1;\n        }\n    }\n  else\n    /* Within the same cluster, but not the same group, so just compare\n       groups.  */\n    return group_cmp (group1, group2, 0);\n}",
      "lines": 72,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_qcmp": {
      "start_point": [
        809,
        0
      ],
      "end_point": [
        813,
        1
      ],
      "content": "static int\nhol_entry_qcmp (const void *entry1_v, const void *entry2_v)\n{\n  return hol_entry_cmp (entry1_v, entry2_v);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_sort": {
      "start_point": [
        818,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "static void\nhol_sort (struct hol *hol)\n{\n  if (hol->num_entries > 0)\n    {\n      unsigned i;\n      struct hol_entry *e;\n      for (i = 0, e = hol->entries; i < hol->num_entries; i++, e++)\n        e->ord = i;\n      qsort (hol->entries, hol->num_entries, sizeof (struct hol_entry),\n             hol_entry_qcmp);\n    }\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_append": {
      "start_point": [
        834,
        0
      ],
      "end_point": [
        924,
        1
      ],
      "content": "static void\nhol_append (struct hol *hol, struct hol *more)\n{\n  struct hol_cluster **cl_end = &hol->clusters;\n\n  /* Steal MORE's cluster list, and add it to the end of HOL's.  */\n  while (*cl_end)\n    cl_end = &(*cl_end)->next;\n  *cl_end = more->clusters;\n  more->clusters = 0;\n\n  /* Merge entries.  */\n  if (more->num_entries > 0)\n    {\n      if (hol->num_entries == 0)\n        {\n          hol->num_entries = more->num_entries;\n          hol->entries = more->entries;\n          hol->short_options = more->short_options;\n          more->num_entries = 0;        /* Mark MORE's fields as invalid.  */\n        }\n      else\n        /* Append the entries in MORE to those in HOL, taking care to only add\n           non-shadowed SHORT_OPTIONS values.  */\n        {\n          unsigned left;\n          char *so, *more_so;\n          struct hol_entry *e;\n          unsigned num_entries = hol->num_entries + more->num_entries;\n          struct hol_entry *entries =\n            malloc (num_entries * sizeof (struct hol_entry));\n          unsigned hol_so_len = strlen (hol->short_options);\n          char *short_options =\n            malloc (hol_so_len + strlen (more->short_options) + 1);\n\n          assert (entries && short_options);\n          if (SIZE_MAX <= UINT_MAX)\n            assert (num_entries <= SIZE_MAX / sizeof (struct hol_entry));\n\n          __mempcpy (__mempcpy (entries, hol->entries,\n                                hol->num_entries * sizeof (struct hol_entry)),\n                     more->entries,\n                     more->num_entries * sizeof (struct hol_entry));\n\n          __mempcpy (short_options, hol->short_options, hol_so_len);\n\n          /* Fix up the short options pointers from HOL.  */\n          for (e = entries, left = hol->num_entries; left > 0; e++, left--)\n            e->short_options\n              = short_options + (e->short_options - hol->short_options);\n\n          /* Now add the short options from MORE, fixing up its entries\n             too.  */\n          so = short_options + hol_so_len;\n          more_so = more->short_options;\n          for (left = more->num_entries; left > 0; e++, left--)\n            {\n              int opts_left;\n              const struct argp_option *opt;\n\n              e->short_options = so;\n\n              for (opts_left = e->num, opt = e->opt; opts_left; opt++, opts_left--)\n                {\n                  int ch = *more_so;\n                  if (oshort (opt) && ch == opt->key)\n                    /* The next short option in MORE_SO, CH, is from OPT.  */\n                    {\n                      if (! find_char (ch, short_options,\n                                       short_options + hol_so_len))\n                        /* The short option CH isn't shadowed by HOL's options,\n                           so add it to the sum.  */\n                        *so++ = ch;\n                      more_so++;\n                    }\n                }\n            }\n\n          *so = '\\0';\n\n          free (hol->entries);\n          free (hol->short_options);\n\n          hol->entries = entries;\n          hol->num_entries = num_entries;\n          hol->short_options = short_options;\n        }\n    }\n\n  hol_free (more);\n}",
      "lines": 91,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "indent_to": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "static void\nindent_to (argp_fmtstream_t stream, unsigned col)\n{\n  int needed = col - __argp_fmtstream_point (stream);\n  while (needed-- > 0)\n    __argp_fmtstream_putc (stream, ' ');\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "space": {
      "start_point": [
        937,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "static void\nspace (argp_fmtstream_t stream, size_t ensure)\n{\n  if (__argp_fmtstream_point (stream) + ensure\n      >= __argp_fmtstream_rmargin (stream))\n    __argp_fmtstream_putc (stream, '\\n');\n  else\n    __argp_fmtstream_putc (stream, ' ');\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "arg": {
      "start_point": [
        950,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "static void\narg (const struct argp_option *real, const char *req_fmt, const char *opt_fmt,\n     const char *domain, argp_fmtstream_t stream)\n{\n  if (real->arg)\n    {\n      if (real->flags & OPTION_ARG_OPTIONAL)\n        __argp_fmtstream_printf (stream, opt_fmt,\n                                 dgettext (domain, real->arg));\n      else\n        __argp_fmtstream_printf (stream, req_fmt,\n                                 dgettext (domain, real->arg));\n    }\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "filter_doc": {
      "start_point": [
        999,
        0
      ],
      "end_point": [
        1012,
        1
      ],
      "content": "static const char *\nfilter_doc (const char *doc, int key, const struct argp *argp,\n            const struct argp_state *state)\n{\n  if (argp && argp->help_filter)\n    /* We must apply a user filter to this output.  */\n    {\n      void *input = __argp_input (argp, state);\n      return (*argp->help_filter) (key, doc, input);\n    }\n  else\n    /* No filter.  */\n    return doc;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nfilter_doc (const char *doc, int key, const struct argp *argp,\n            const struct argp_state *state)",
        "*"
      ]
    },
    "print_header": {
      "start_point": [
        1019,
        0
      ],
      "end_point": [
        1046,
        1
      ],
      "content": "static void\nprint_header (const char *str, const struct argp *argp,\n              struct pentry_state *pest)\n{\n  const char *tstr = dgettext (argp->argp_domain, str);\n  const char *fstr = filter_doc (tstr, ARGP_KEY_HELP_HEADER, argp, pest->state);\n\n  if (fstr)\n    {\n      if (*fstr)\n        {\n          if (pest->hhstate->prev_entry)\n            /* Precede with a blank line.  */\n            __argp_fmtstream_putc (pest->stream, '\\n');\n          indent_to (pest->stream, uparams.header_col);\n          __argp_fmtstream_set_lmargin (pest->stream, uparams.header_col);\n          __argp_fmtstream_set_wmargin (pest->stream, uparams.header_col);\n          __argp_fmtstream_puts (pest->stream, fstr);\n          __argp_fmtstream_set_lmargin (pest->stream, 0);\n          __argp_fmtstream_putc (pest->stream, '\\n');\n        }\n\n      pest->hhstate->sep_groups = 1; /* Separate subsequent groups. */\n    }\n\n  if (fstr != tstr)\n    free ((char *) fstr);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "comma": {
      "start_point": [
        1052,
        0
      ],
      "end_point": [
        1083,
        1
      ],
      "content": "static void\ncomma (unsigned col, struct pentry_state *pest)\n{\n  if (pest->first)\n    {\n      const struct hol_entry *pe = pest->hhstate->prev_entry;\n      const struct hol_cluster *cl = pest->entry->cluster;\n\n      if (pest->hhstate->sep_groups && pe && pest->entry->group != pe->group)\n        __argp_fmtstream_putc (pest->stream, '\\n');\n\n      if (cl && cl->header && *cl->header\n          && (!pe\n              || (pe->cluster != cl\n                  && !hol_cluster_is_child (pe->cluster, cl))))\n        /* If we're changing clusters, then this must be the start of the\n           ENTRY's cluster unless that is an ancestor of the previous one\n           (in which case we had just popped into a sub-cluster for a bit).\n           If so, then print the cluster's header line.  */\n        {\n          int old_wm = __argp_fmtstream_wmargin (pest->stream);\n          print_header (cl->header, cl->argp, pest);\n          __argp_fmtstream_set_wmargin (pest->stream, old_wm);\n        }\n\n      pest->first = 0;\n    }\n  else\n    __argp_fmtstream_puts (pest->stream, \", \");\n\n  indent_to (pest->stream, col);\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_entry_help": {
      "start_point": [
        1086,
        0
      ],
      "end_point": [
        1210,
        1
      ],
      "content": "static void\nhol_entry_help (struct hol_entry *entry, const struct argp_state *state,\n                argp_fmtstream_t stream, struct hol_help_state *hhstate)\n{\n  unsigned num;\n  const struct argp_option *real = entry->opt, *opt;\n  char *so = entry->short_options;\n  int have_long_opt = 0;        /* We have any long options.  */\n  /* Saved margins.  */\n  int old_lm = __argp_fmtstream_set_lmargin (stream, 0);\n  int old_wm = __argp_fmtstream_wmargin (stream);\n  /* PEST is a state block holding some of our variables that we'd like to\n     share with helper functions.  */\n  struct pentry_state pest = { entry, stream, hhstate, 1, state };\n\n  if (! odoc (real))\n    for (opt = real, num = entry->num; num > 0; opt++, num--)\n      if (opt->name && ovisible (opt))\n        {\n          have_long_opt = 1;\n          break;\n        }\n\n  /* First emit short options.  */\n  __argp_fmtstream_set_wmargin (stream, uparams.short_opt_col); /* For truly bizarre cases. */\n  for (opt = real, num = entry->num; num > 0; opt++, num--)\n    if (oshort (opt) && opt->key == *so)\n      /* OPT has a valid (non shadowed) short option.  */\n      {\n        if (ovisible (opt))\n          {\n            comma (uparams.short_opt_col, &pest);\n            __argp_fmtstream_putc (stream, '-');\n            __argp_fmtstream_putc (stream, *so);\n            if (!have_long_opt || uparams.dup_args)\n              arg (real, \" %s\", \"[%s]\",\n                   state == NULL ? NULL : state->root_argp->argp_domain,\n                   stream);\n            else if (real->arg)\n              hhstate->suppressed_dup_arg = 1;\n          }\n        so++;\n      }\n\n  /* Now, long options.  */\n  if (odoc (real))\n    /* A \"documentation\" option.  */\n    {\n      __argp_fmtstream_set_wmargin (stream, uparams.doc_opt_col);\n      for (opt = real, num = entry->num; num > 0; opt++, num--)\n        if (opt->name && ovisible (opt))\n          {\n            comma (uparams.doc_opt_col, &pest);\n            /* Calling dgettext here isn't quite right, since sorting will\n               have been done on the original; but documentation options\n               should be pretty rare anyway...  */\n            __argp_fmtstream_puts (stream,\n                                   dgettext (state == NULL ? NULL\n                                             : state->root_argp->argp_domain,\n                                             opt->name));\n          }\n    }\n  else\n    /* A real long option.  */\n    {\n      __argp_fmtstream_set_wmargin (stream, uparams.long_opt_col);\n      for (opt = real, num = entry->num; num > 0; opt++, num--)\n        if (opt->name && ovisible (opt))\n          {\n            comma (uparams.long_opt_col, &pest);\n            __argp_fmtstream_printf (stream, \"--%s\", opt->name);\n            arg (real, \"=%s\", \"[=%s]\",\n                 state == NULL ? NULL : state->root_argp->argp_domain, stream);\n          }\n    }\n\n  /* Next, documentation strings.  */\n  __argp_fmtstream_set_lmargin (stream, 0);\n\n  if (pest.first)\n    {\n      /* Didn't print any switches, what's up?  */\n      if (!oshort (real) && !real->name)\n        /* This is a group header, print it nicely.  */\n        print_header (real->doc, entry->argp, &pest);\n      else\n        /* Just a totally shadowed option or null header; print nothing.  */\n        goto cleanup;           /* Just return, after cleaning up.  */\n    }\n  else\n    {\n      const char *tstr = real->doc ? dgettext (state == NULL ? NULL\n                                               : state->root_argp->argp_domain,\n                                               real->doc) : 0;\n      const char *fstr = filter_doc (tstr, real->key, entry->argp, state);\n      if (fstr && *fstr)\n        {\n          unsigned int col = __argp_fmtstream_point (stream);\n\n          __argp_fmtstream_set_lmargin (stream, uparams.opt_doc_col);\n          __argp_fmtstream_set_wmargin (stream, uparams.opt_doc_col);\n\n          if (col > (unsigned int) (uparams.opt_doc_col + 3))\n            __argp_fmtstream_putc (stream, '\\n');\n          else if (col >= (unsigned int) uparams.opt_doc_col)\n            __argp_fmtstream_puts (stream, \"   \");\n          else\n            indent_to (stream, uparams.opt_doc_col);\n\n          __argp_fmtstream_puts (stream, fstr);\n        }\n      if (fstr && fstr != tstr)\n        free ((char *) fstr);\n\n      /* Reset the left margin.  */\n      __argp_fmtstream_set_lmargin (stream, 0);\n      __argp_fmtstream_putc (stream, '\\n');\n    }\n\n  hhstate->prev_entry = entry;\n\ncleanup:\n  __argp_fmtstream_set_lmargin (stream, old_lm);\n  __argp_fmtstream_set_wmargin (stream, old_wm);\n}",
      "lines": 125,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_help": {
      "start_point": [
        1213,
        0
      ],
      "end_point": [
        1241,
        1
      ],
      "content": "static void\nhol_help (struct hol *hol, const struct argp_state *state,\n          argp_fmtstream_t stream)\n{\n  unsigned num;\n  struct hol_entry *entry;\n  struct hol_help_state hhstate = { 0, 0, 0 };\n\n  for (entry = hol->entries, num = hol->num_entries; num > 0; entry++, num--)\n    hol_entry_help (entry, state, stream, &hhstate);\n\n  if (hhstate.suppressed_dup_arg && uparams.dup_args_note)\n    {\n      const char *tstr = dgettext (state == NULL ? NULL\n                                   : state->root_argp->argp_domain, \"\\\nMandatory or optional arguments to long options are also mandatory or \\\noptional for any corresponding short options.\");\n      const char *fstr = filter_doc (tstr, ARGP_KEY_HELP_DUP_ARGS_NOTE,\n                                     state ? state->root_argp : 0, state);\n      if (fstr && *fstr)\n        {\n          __argp_fmtstream_putc (stream, '\\n');\n          __argp_fmtstream_puts (stream, fstr);\n          __argp_fmtstream_putc (stream, '\\n');\n        }\n      if (fstr && fstr != tstr)\n        free ((char *) fstr);\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_argless_short_opt": {
      "start_point": [
        1247,
        0
      ],
      "end_point": [
        1257,
        1
      ],
      "content": "static int\nadd_argless_short_opt (const struct argp_option *opt,\n                       const struct argp_option *real,\n                       const char *domain, void *cookie)\n{\n  char **snao_end = cookie;\n  if (!(opt->arg || real->arg)\n      && !((opt->flags | real->flags) & OPTION_NO_USAGE))\n    *(*snao_end)++ = opt->key;\n  return 0;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage_argful_short_opt": {
      "start_point": [
        1261,
        0
      ],
      "end_point": [
        1289,
        1
      ],
      "content": "static int\nusage_argful_short_opt (const struct argp_option *opt,\n                        const struct argp_option *real,\n                        const char *domain, void *cookie)\n{\n  argp_fmtstream_t stream = cookie;\n  const char *arg = opt->arg;\n  int flags = opt->flags | real->flags;\n\n  if (! arg)\n    arg = real->arg;\n\n  if (arg && !(flags & OPTION_NO_USAGE))\n    {\n      arg = dgettext (domain, arg);\n\n      if (flags & OPTION_ARG_OPTIONAL)\n        __argp_fmtstream_printf (stream, \" [-%c[%s]]\", opt->key, arg);\n      else\n        {\n          /* Manually do line wrapping so that it (probably) won't\n             get wrapped at the embedded space.  */\n          space (stream, 6 + strlen (arg));\n          __argp_fmtstream_printf (stream, \"[-%c %s]\", opt->key, arg);\n        }\n    }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage_long_opt": {
      "start_point": [
        1293,
        0
      ],
      "end_point": [
        1320,
        1
      ],
      "content": "static int\nusage_long_opt (const struct argp_option *opt,\n                const struct argp_option *real,\n                const char *domain, void *cookie)\n{\n  argp_fmtstream_t stream = cookie;\n  const char *arg = opt->arg;\n  int flags = opt->flags | real->flags;\n\n  if (! arg)\n    arg = real->arg;\n\n  if (! (flags & OPTION_NO_USAGE))\n    {\n      if (arg)\n        {\n          arg = dgettext (domain, arg);\n          if (flags & OPTION_ARG_OPTIONAL)\n            __argp_fmtstream_printf (stream, \" [--%s[=%s]]\", opt->name, arg);\n          else\n            __argp_fmtstream_printf (stream, \" [--%s=%s]\", opt->name, arg);\n        }\n      else\n        __argp_fmtstream_printf (stream, \" [--%s]\", opt->name);\n    }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_usage": {
      "start_point": [
        1323,
        0
      ],
      "end_point": [
        1359,
        1
      ],
      "content": "static void\nhol_usage (struct hol *hol, argp_fmtstream_t stream)\n{\n  if (hol->num_entries > 0)\n    {\n      unsigned nentries;\n      struct hol_entry *entry;\n      char *short_no_arg_opts = alloca (strlen (hol->short_options) + 1);\n      char *snao_end = short_no_arg_opts;\n\n      /* First we put a list of short options without arguments.  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_short_iterate (entry, add_argless_short_opt,\n                                 entry->argp->argp_domain, &snao_end);\n      if (snao_end > short_no_arg_opts)\n        {\n          *snao_end++ = 0;\n          __argp_fmtstream_printf (stream, \" [-%s]\", short_no_arg_opts);\n        }\n\n      /* Now a list of short options *with* arguments.  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_short_iterate (entry, usage_argful_short_opt,\n                                 entry->argp->argp_domain, stream);\n\n      /* Finally, a list of long options (whew!).  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_long_iterate (entry, usage_long_opt,\n                                entry->argp->argp_domain, stream);\n    }\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argp_hol": {
      "start_point": [
        1363,
        0
      ],
      "end_point": [
        1382,
        1
      ],
      "content": "static struct hol *\nargp_hol (const struct argp *argp, struct hol_cluster *cluster)\n{\n  const struct argp_child *child = argp->children;\n  struct hol *hol = make_hol (argp, cluster);\n  if (child)\n    while (child->argp)\n      {\n        struct hol_cluster *child_cluster =\n          ((child->group || child->header)\n           /* Put CHILD->argp within its own cluster.  */\n           ? hol_add_cluster (hol, child->group, child->header,\n                              child - argp->children, cluster, argp)\n           /* Just merge it into the parent's cluster.  */\n           : cluster);\n        hol_append (hol, argp_hol (child->argp, child_cluster)) ;\n        child++;\n      }\n  return hol;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "struct hol",
        "struct",
        "hol",
        "*\nargp_hol (const struct argp *argp, struct hol_cluster *cluster)",
        "*"
      ]
    },
    "argp_args_levels": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1400,
        1
      ],
      "content": "static size_t\nargp_args_levels (const struct argp *argp)\n{\n  size_t levels = 0;\n  const struct argp_child *child = argp->children;\n\n  if (argp->args_doc && strchr (argp->args_doc, '\\n'))\n    levels++;\n\n  if (child)\n    while (child->argp)\n      levels += argp_args_levels ((child++)->argp);\n\n  return levels;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "argp_args_usage": {
      "start_point": [
        1407,
        0
      ],
      "end_point": [
        1460,
        1
      ],
      "content": "static int\nargp_args_usage (const struct argp *argp, const struct argp_state *state,\n                 char **levels, int advance, argp_fmtstream_t stream)\n{\n  char *our_level = *levels;\n  int multiple = 0;\n  const struct argp_child *child = argp->children;\n  const char *tdoc = dgettext (argp->argp_domain, argp->args_doc), *nl = 0;\n  const char *fdoc = filter_doc (tdoc, ARGP_KEY_HELP_ARGS_DOC, argp, state);\n\n  if (fdoc)\n    {\n      const char *cp = fdoc;\n      nl = __strchrnul (cp, '\\n');\n      if (*nl != '\\0')\n        /* This is a 'multi-level' args doc; advance to the correct position\n           as determined by our state in LEVELS, and update LEVELS.  */\n        {\n          int i;\n          multiple = 1;\n          for (i = 0; i < *our_level; i++)\n            cp = nl + 1, nl = __strchrnul (cp, '\\n');\n          (*levels)++;\n        }\n\n      /* Manually do line wrapping so that it (probably) won't get wrapped at\n         any embedded spaces.  */\n      space (stream, 1 + nl - cp);\n\n      __argp_fmtstream_write (stream, cp, nl - cp);\n    }\n  if (fdoc && fdoc != tdoc)\n    free ((char *)fdoc);        /* Free user's modified doc string.  */\n\n  if (child)\n    while (child->argp)\n      advance = !argp_args_usage ((child++)->argp, state, levels, advance, stream);\n\n  if (advance && multiple)\n    {\n      /* Need to increment our level.  */\n      if (*nl)\n        /* There's more we can do here.  */\n        {\n          (*our_level)++;\n          advance = 0;          /* Our parent shouldn't advance also. */\n        }\n      else if (*our_level > 0)\n        /* We had multiple levels, but used them up; reset to zero.  */\n        *our_level = 0;\n    }\n\n  return !advance;\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "argp_doc": {
      "start_point": [
        1469,
        0
      ],
      "end_point": [
        1553,
        1
      ],
      "content": "static int\nargp_doc (const struct argp *argp, const struct argp_state *state,\n          int post, int pre_blank, int first_only,\n          argp_fmtstream_t stream)\n{\n  const char *text;\n  const char *inp_text;\n  void *input = 0;\n  int anything = 0;\n  size_t inp_text_limit = 0;\n  const char *doc = dgettext (argp->argp_domain, argp->doc);\n  const struct argp_child *child = argp->children;\n\n  if (doc)\n    {\n      char *vt = strchr (doc, '\\v');\n      inp_text = post ? (vt ? vt + 1 : 0) : doc;\n      inp_text_limit = (!post && vt) ? (vt - doc) : 0;\n    }\n  else\n    inp_text = 0;\n\n  if (argp->help_filter)\n    /* We have to filter the doc strings.  */\n    {\n      if (inp_text_limit)\n        /* Copy INP_TEXT so that it's nul-terminated.  */\n        inp_text = __strndup (inp_text, inp_text_limit);\n      input = __argp_input (argp, state);\n      text =\n        (*argp->help_filter) (post\n                              ? ARGP_KEY_HELP_POST_DOC\n                              : ARGP_KEY_HELP_PRE_DOC,\n                              inp_text, input);\n    }\n  else\n    text = (const char *) inp_text;\n\n  if (text)\n    {\n      if (pre_blank)\n        __argp_fmtstream_putc (stream, '\\n');\n\n      if (text == inp_text && inp_text_limit)\n        __argp_fmtstream_write (stream, inp_text, inp_text_limit);\n      else\n        __argp_fmtstream_puts (stream, text);\n\n      if (__argp_fmtstream_point (stream) > __argp_fmtstream_lmargin (stream))\n        __argp_fmtstream_putc (stream, '\\n');\n\n      anything = 1;\n    }\n\n  if (text && text != inp_text)\n    free ((char *) text);       /* Free TEXT returned from the help filter.  */\n  if (inp_text && inp_text_limit && argp->help_filter)\n    free ((char *) inp_text);   /* We copied INP_TEXT, so free it now.  */\n\n  if (post && argp->help_filter)\n    /* Now see if we have to output a ARGP_KEY_HELP_EXTRA text.  */\n    {\n      text = (*argp->help_filter) (ARGP_KEY_HELP_EXTRA, 0, input);\n      if (text)\n        {\n          if (anything || pre_blank)\n            __argp_fmtstream_putc (stream, '\\n');\n          __argp_fmtstream_puts (stream, text);\n          free ((char *) text);\n          if (__argp_fmtstream_point (stream)\n              > __argp_fmtstream_lmargin (stream))\n            __argp_fmtstream_putc (stream, '\\n');\n          anything = 1;\n        }\n    }\n\n  if (child)\n    while (child->argp && !(first_only && anything))\n      anything |=\n        argp_doc ((child++)->argp, state,\n                  post, anything || pre_blank, first_only,\n                  stream);\n\n  return anything;\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_help": {
      "start_point": [
        1559,
        0
      ],
      "end_point": [
        1698,
        1
      ],
      "content": "static void\n_help (const struct argp *argp, const struct argp_state *state, FILE *stream,\n       unsigned flags, char *name)\n{\n  int anything = 0;             /* Whether we've output anything.  */\n  struct hol *hol = 0;\n  argp_fmtstream_t fs;\n\n  if (! stream)\n    return;\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n  __flockfile (stream);\n#endif\n\n  if (! uparams.valid)\n    fill_in_uparams (state);\n\n  fs = __argp_make_fmtstream (stream, 0, uparams.rmargin, 0);\n  if (! fs)\n    {\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n      __funlockfile (stream);\n#endif\n      return;\n    }\n\n  if (flags & (ARGP_HELP_USAGE | ARGP_HELP_SHORT_USAGE | ARGP_HELP_LONG))\n    {\n      hol = argp_hol (argp, 0);\n\n      /* If present, these options always come last.  */\n      hol_set_group (hol, \"help\", -1);\n      hol_set_group (hol, \"version\", -1);\n\n      hol_sort (hol);\n    }\n\n  if (flags & (ARGP_HELP_USAGE | ARGP_HELP_SHORT_USAGE))\n    /* Print a short \"Usage:\" message.  */\n    {\n      int first_pattern = 1, more_patterns;\n      size_t num_pattern_levels = argp_args_levels (argp);\n      char *pattern_levels = alloca (num_pattern_levels);\n\n      memset (pattern_levels, 0, num_pattern_levels);\n\n      do\n        {\n          int old_lm;\n          int old_wm = __argp_fmtstream_set_wmargin (fs, uparams.usage_indent);\n          char *levels = pattern_levels;\n\n          if (first_pattern)\n            __argp_fmtstream_printf (fs, \"%s %s\",\n                                     dgettext (argp->argp_domain, \"Usage:\"),\n                                     name);\n          else\n            __argp_fmtstream_printf (fs, \"%s %s\",\n                                     dgettext (argp->argp_domain, \"  or: \"),\n                                     name);\n\n          /* We set the lmargin as well as the wmargin, because hol_usage\n             manually wraps options with newline to avoid annoying breaks.  */\n          old_lm = __argp_fmtstream_set_lmargin (fs, uparams.usage_indent);\n\n          if (flags & ARGP_HELP_SHORT_USAGE)\n            /* Just show where the options go.  */\n            {\n              if (hol->num_entries > 0)\n                __argp_fmtstream_puts (fs, dgettext (argp->argp_domain,\n                                                     \" [OPTION...]\"));\n            }\n          else\n            /* Actually print the options.  */\n            {\n              hol_usage (hol, fs);\n              flags |= ARGP_HELP_SHORT_USAGE; /* But only do so once.  */\n            }\n\n          more_patterns = argp_args_usage (argp, state, &levels, 1, fs);\n\n          __argp_fmtstream_set_wmargin (fs, old_wm);\n          __argp_fmtstream_set_lmargin (fs, old_lm);\n\n          __argp_fmtstream_putc (fs, '\\n');\n          anything = 1;\n\n          first_pattern = 0;\n        }\n      while (more_patterns);\n    }\n\n  if (flags & ARGP_HELP_PRE_DOC)\n    anything |= argp_doc (argp, state, 0, 0, 1, fs);\n\n  if (flags & ARGP_HELP_SEE)\n    {\n      __argp_fmtstream_printf (fs, dgettext (argp->argp_domain, \"\\\nTry '%s --help' or '%s --usage' for more information.\\n\"),\n                               name, name);\n      anything = 1;\n    }\n\n  if (flags & ARGP_HELP_LONG)\n    /* Print a long, detailed help message.  */\n    {\n      /* Print info about all the options.  */\n      if (hol->num_entries > 0)\n        {\n          if (anything)\n            __argp_fmtstream_putc (fs, '\\n');\n          hol_help (hol, state, fs);\n          anything = 1;\n        }\n    }\n\n  if (flags & ARGP_HELP_POST_DOC)\n    /* Print any documentation strings at the end.  */\n    anything |= argp_doc (argp, state, 1, anything, 0, fs);\n\n  if ((flags & ARGP_HELP_BUG_ADDR) && argp_program_bug_address)\n    {\n      if (anything)\n        __argp_fmtstream_putc (fs, '\\n');\n      __argp_fmtstream_printf (fs, dgettext (argp->argp_domain,\n                                             \"Report bugs to %s.\\n\"),\n                               argp_program_bug_address);\n      anything = 1;\n    }\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n  __funlockfile (stream);\n#endif\n\n  if (hol)\n    hol_free (hol);\n\n  __argp_fmtstream_free (fs);\n}",
      "lines": 140,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__argp_help": {
      "start_point": [
        1702,
        0
      ],
      "end_point": [
        1706,
        1
      ],
      "content": "void __argp_help (const struct argp *argp, FILE *stream,\n                  unsigned flags, char *name)\n{\n  _help (argp, 0, stream, flags, name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "__argp_short_program_name": {
      "start_point": [
        1712,
        0
      ],
      "end_point": [
        1727,
        1
      ],
      "content": "char *\n__argp_short_program_name (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  char *name = strrchr (program_invocation_name, '/');\n  return name ? name + 1 : program_invocation_name;\n# else\n  /* FIXME: What now? Miles suggests that it is better to use NULL,\n     but currently the value is passed on directly to fputs_unlocked,\n     so that requires more changes. */\n# if __GNUC__\n#  warning No reasonable value to return\n# endif /* __GNUC__ */\n  return \"\";\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "char",
        "*\n__argp_short_program_name (void)",
        "*"
      ]
    },
    "__argp_state_help": {
      "start_point": [
        1732,
        0
      ],
      "end_point": [
        1751,
        1
      ],
      "content": "void\n__argp_state_help (const struct argp_state *state, FILE *stream, unsigned flags)\n{\n  if ((!state || ! (state->flags & ARGP_NO_ERRS)) && stream)\n    {\n      if (state && (state->flags & ARGP_LONG_ONLY))\n        flags |= ARGP_HELP_LONG_ONLY;\n\n      _help (state ? state->root_argp : 0, state, stream, flags,\n             state ? state->name : __argp_short_program_name ());\n\n      if (!state || ! (state->flags & ARGP_NO_EXIT))\n        {\n          if (flags & ARGP_HELP_EXIT_ERR)\n            exit (argp_err_exit_status);\n          if (flags & ARGP_HELP_EXIT_OK)\n            exit (0);\n        }\n  }\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "__argp_error": {
      "start_point": [
        1759,
        0
      ],
      "end_point": [
        1806,
        1
      ],
      "content": "void\n__argp_error (const struct argp_state *state, const char *fmt, ...)\n{\n  if (!state || !(state->flags & ARGP_NO_ERRS))\n    {\n      FILE *stream = state ? state->err_stream : stderr;\n\n      if (stream)\n        {\n          va_list ap;\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __flockfile (stream);\n#endif\n\n          va_start (ap, fmt);\n\n#ifdef _LIBC\n          char *buf;\n\n          if (_IO_vasprintf (&buf, fmt, ap) < 0)\n            buf = NULL;\n\n          __fxprintf (stream, \"%s: %s\\n\",\n                      state ? state->name : __argp_short_program_name (), buf);\n\n          free (buf);\n#else\n          fputs_unlocked (state ? state->name : __argp_short_program_name (),\n                          stream);\n          putc_unlocked (':', stream);\n          putc_unlocked (' ', stream);\n\n          vfprintf (stream, fmt, ap);\n\n          putc_unlocked ('\\n', stream);\n#endif\n\n          __argp_state_help (state, stream, ARGP_HELP_STD_ERR);\n\n          va_end (ap);\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __funlockfile (stream);\n#endif\n        }\n    }\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "__argp_failure": {
      "start_point": [
        1819,
        0
      ],
      "end_point": [
        1906,
        1
      ],
      "content": "void\n__argp_failure (const struct argp_state *state, int status, int errnum,\n                const char *fmt, ...)\n{\n  if (!state || !(state->flags & ARGP_NO_ERRS))\n    {\n      FILE *stream = state ? state->err_stream : stderr;\n\n      if (stream)\n        {\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __flockfile (stream);\n#endif\n\n#ifdef _LIBC\n          __fxprintf (stream, \"%s\",\n                      state ? state->name : __argp_short_program_name ());\n#else\n          fputs_unlocked (state ? state->name : __argp_short_program_name (),\n                          stream);\n#endif\n\n          if (fmt)\n            {\n              va_list ap;\n\n              va_start (ap, fmt);\n#ifdef _LIBC\n              char *buf;\n\n              if (_IO_vasprintf (&buf, fmt, ap) < 0)\n                buf = NULL;\n\n              __fxprintf (stream, \": %s\", buf);\n\n              free (buf);\n#else\n              putc_unlocked (':', stream);\n              putc_unlocked (' ', stream);\n\n              vfprintf (stream, fmt, ap);\n#endif\n\n              va_end (ap);\n            }\n\n          if (errnum)\n            {\n              char buf[200];\n\n#ifdef _LIBC\n              __fxprintf (stream, \": %s\",\n                          __strerror_r (errnum, buf, sizeof (buf)));\n#else\n              char const *s = NULL;\n              putc_unlocked (':', stream);\n              putc_unlocked (' ', stream);\n# if GNULIB_STRERROR_R_POSIX || HAVE_DECL_STRERROR_R\n#  if !GNULIB_STRERROR_R_POSIX && STRERROR_R_CHAR_P\n              s = __strerror_r (errnum, buf, sizeof buf);\n#  else\n              if (__strerror_r (errnum, buf, sizeof buf) == 0)\n                s = buf;\n#  endif\n# endif\n              if (! s && ! (s = strerror (errnum)))\n                s = dgettext (state->root_argp->argp_domain,\n                              \"Unknown system error\");\n              fputs_unlocked (s, stream);\n#endif\n            }\n\n#if _LIBC\n          if (_IO_fwide (stream, 0) > 0)\n            putwc_unlocked (L'\\n', stream);\n          else\n#endif\n            putc_unlocked ('\\n', stream);\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __funlockfile (stream);\n#endif\n\n          if (status && (!state || !(state->flags & ARGP_NO_EXIT)))\n            exit (status);\n        }\n    }\n}",
      "lines": 88,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/argp-namefrob.h": {},
  "tar/tar-1.30/gnu/argp-parse.c": {
    "argp_default_parser": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static error_t\nargp_default_parser (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case '?':\n      __argp_state_help (state, state->out_stream, ARGP_HELP_STD_HELP);\n      break;\n    case OPT_USAGE:\n      __argp_state_help (state, state->out_stream,\n                         ARGP_HELP_USAGE | ARGP_HELP_EXIT_OK);\n      break;\n\n    case OPT_PROGNAME:          /* Set the program name.  */\n#if defined _LIBC || HAVE_DECL_PROGRAM_INVOCATION_NAME\n      program_invocation_name = arg;\n#endif\n      /* [Note that some systems only have PROGRAM_INVOCATION_SHORT_NAME (aka\n         __PROGNAME), in which case, PROGRAM_INVOCATION_NAME is just defined\n         to be that, so we have to be a bit careful here.]  */\n\n      /* Update what we use for messages.  */\n      state->name = __argp_base_name (arg);\n\n#if defined _LIBC || HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n      program_invocation_short_name = state->name;\n#endif\n\n      if ((state->flags & (ARGP_PARSE_ARGV0 | ARGP_NO_ERRS))\n          == ARGP_PARSE_ARGV0)\n        /* Update what getopt uses too.  */\n        state->argv[0] = arg;\n\n      break;\n\n    case OPT_HANG:\n      _argp_hang = atoi (arg ? arg : \"3600\");\n      while (_argp_hang-- > 0)\n        __sleep (1);\n      break;\n\n    default:\n      return EBADKEY;\n    }\n  return 0;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "argp_version_parser": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static error_t\nargp_version_parser (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case 'V':\n      if (argp_program_version_hook)\n        (*argp_program_version_hook) (state->out_stream, state);\n      else if (argp_program_version)\n        fprintf (state->out_stream, \"%s\\n\", argp_program_version);\n      else\n        __argp_error (state, \"%s\",\n                      dgettext (state->root_argp->argp_domain,\n                                \"(PROGRAM ERROR) No version known!?\"));\n      if (! (state->flags & ARGP_NO_EXIT))\n        exit (0);\n      break;\n    default:\n      return EBADKEY;\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "find_long_option": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "static int\nfind_long_option (struct option *long_options, const char *name)\n{\n  struct option *l = long_options;\n  while (l->name != NULL)\n    if (name != NULL && strcmp (l->name, name) == 0)\n      return l - long_options;\n    else\n      l++;\n  if (name == NULL)\n    return l - long_options;\n  else\n    return -1;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "group_parse": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static error_t\ngroup_parse (struct group *group, struct argp_state *state, int key, char *arg)\n{\n  if (group->parser)\n    {\n      error_t err;\n      state->hook = group->hook;\n      state->input = group->input;\n      state->child_inputs = group->child_inputs;\n      state->arg_num = group->args_processed;\n      err = (*group->parser)(key, arg, state);\n      group->hook = state->hook;\n      return err;\n    }\n  else\n    return EBADKEY;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "convert_options": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "static struct group *\nconvert_options (const struct argp *argp,\n                 struct group *parent, unsigned parent_index,\n                 struct group *group, struct parser_convert_state *cvt)\n{\n  /* REAL is the most recent non-alias value of OPT.  */\n  const struct argp_option *real = argp->options;\n  const struct argp_child *children = argp->children;\n\n  if (real || argp->parser)\n    {\n      const struct argp_option *opt;\n\n      if (real)\n        for (opt = real; !__option_is_end (opt); opt++)\n          {\n            if (! (opt->flags & OPTION_ALIAS))\n              /* OPT isn't an alias, so we can use values from it.  */\n              real = opt;\n\n            if (! (real->flags & OPTION_DOC))\n              /* A real option (not just documentation).  */\n              {\n                if (__option_is_short (opt))\n                  /* OPT can be used as a short option.  */\n                  {\n                    *cvt->short_end++ = opt->key;\n                    if (real->arg)\n                      {\n                        *cvt->short_end++ = ':';\n                        if (real->flags & OPTION_ARG_OPTIONAL)\n                          *cvt->short_end++ = ':';\n                      }\n                    *cvt->short_end = '\\0'; /* keep 0 terminated */\n                  }\n\n                if (opt->name\n                    && find_long_option (cvt->parser->long_opts, opt->name) < 0)\n                  /* OPT can be used as a long option.  */\n                  {\n                    cvt->long_end->name = opt->name;\n                    cvt->long_end->has_arg =\n                      (real->arg\n                       ? (real->flags & OPTION_ARG_OPTIONAL\n                          ? optional_argument\n                          : required_argument)\n                       : no_argument);\n                    cvt->long_end->flag = 0;\n                    /* we add a disambiguating code to all the user's\n                       values (which is removed before we actually call\n                       the function to parse the value); this means that\n                       the user loses use of the high 8 bits in all his\n                       values (the sign of the lower bits is preserved\n                       however)...  */\n                    cvt->long_end->val =\n                      ((opt->key ? opt->key : real->key) & USER_MASK)\n                      + (((group - cvt->parser->groups) + 1) << USER_BITS);\n\n                    /* Keep the LONG_OPTS list terminated.  */\n                    (++cvt->long_end)->name = NULL;\n                  }\n              }\n            }\n\n      group->parser = argp->parser;\n      group->argp = argp;\n      group->short_end = cvt->short_end;\n      group->args_processed = 0;\n      group->parent = parent;\n      group->parent_index = parent_index;\n      group->input = 0;\n      group->hook = 0;\n      group->child_inputs = 0;\n\n      if (children)\n        /* Assign GROUP's CHILD_INPUTS field some space from\n           CVT->child_inputs_end.*/\n        {\n          unsigned num_children = 0;\n          while (children[num_children].argp)\n            num_children++;\n          group->child_inputs = cvt->child_inputs_end;\n          cvt->child_inputs_end += num_children;\n        }\n\n      parent = group++;\n    }\n  else\n    parent = 0;\n\n  if (children)\n    {\n      unsigned index = 0;\n      while (children->argp)\n        group =\n          convert_options (children++->argp, parent, index++, group, cvt);\n    }\n\n  return group;\n}",
      "lines": 100,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "struct group",
        "struct",
        "group",
        "*\nconvert_options (const struct argp *argp,\n                 struct group *parent, unsigned parent_index,\n                 struct group *group, struct parser_convert_state *cvt)",
        "*"
      ]
    },
    "parser_convert": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "static void\nparser_convert (struct parser *parser, const struct argp *argp, int flags)\n{\n  struct parser_convert_state cvt;\n\n  cvt.parser = parser;\n  cvt.short_end = parser->short_opts;\n  cvt.long_end = parser->long_opts;\n  cvt.child_inputs_end = parser->child_inputs;\n\n  if (flags & ARGP_IN_ORDER)\n    *cvt.short_end++ = '-';\n  else if (flags & ARGP_NO_ARGS)\n    *cvt.short_end++ = '+';\n  *cvt.short_end = '\\0';\n\n  cvt.long_end->name = NULL;\n\n  parser->argp = argp;\n\n  if (argp)\n    parser->egroup = convert_options (argp, 0, 0, parser->groups, &cvt);\n  else\n    parser->egroup = parser->groups; /* No parsers at all! */\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "calc_sizes": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        454,
        1
      ],
      "content": "static void\ncalc_sizes (const struct argp *argp,  struct parser_sizes *szs)\n{\n  const struct argp_child *child = argp->children;\n  const struct argp_option *opt = argp->options;\n\n  if (opt || argp->parser)\n    {\n      szs->num_groups++;\n      if (opt)\n        {\n          int num_opts = 0;\n          while (!__option_is_end (opt++))\n            num_opts++;\n          szs->short_len += num_opts * 3; /* opt + up to 2 ':'s */\n          szs->long_len += num_opts;\n        }\n    }\n\n  if (child)\n    while (child->argp)\n      {\n        calc_sizes ((child++)->argp, szs);\n        szs->num_child_inputs++;\n      }\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parser_init": {
      "start_point": [
        457,
        0
      ],
      "end_point": [
        566,
        1
      ],
      "content": "static error_t\nparser_init (struct parser *parser, const struct argp *argp,\n             int argc, char **argv, int flags, void *input)\n{\n  error_t err = 0;\n  struct group *group;\n  struct parser_sizes szs;\n  struct _getopt_data opt_data = _GETOPT_DATA_INITIALIZER;\n  char *storage;\n  size_t glen, gsum;\n  size_t clen, csum;\n  size_t llen, lsum;\n  size_t slen, ssum;\n\n  szs.short_len = (flags & ARGP_NO_ARGS) ? 0 : 1;\n  szs.long_len = 0;\n  szs.num_groups = 0;\n  szs.num_child_inputs = 0;\n\n  if (argp)\n    calc_sizes (argp, &szs);\n\n  /* Lengths of the various bits of storage used by PARSER.  */\n  glen = (szs.num_groups + 1) * sizeof (struct group);\n  clen = szs.num_child_inputs * sizeof (void *);\n  llen = (szs.long_len + 1) * sizeof (struct option);\n  slen = szs.short_len + 1;\n\n  /* Sums of previous lengths, properly aligned.  There's no need to\n     align gsum, since struct group is aligned at least as strictly as\n     void * (since it contains a void * member).  And there's no need\n     to align lsum, since struct option is aligned at least as\n     strictly as char.  */\n  gsum = glen;\n  csum = alignto (gsum + clen, alignof (struct option));\n  lsum = csum + llen;\n  ssum = lsum + slen;\n\n  parser->storage = malloc (ssum);\n  if (! parser->storage)\n    return ENOMEM;\n\n  storage = parser->storage;\n  parser->groups = parser->storage;\n  parser->child_inputs = (void **) (storage + gsum);\n  parser->long_opts = (struct option *) (storage + csum);\n  parser->short_opts = storage + lsum;\n  parser->opt_data = opt_data;\n\n  memset (parser->child_inputs, 0, clen);\n  parser_convert (parser, argp, flags);\n\n  memset (&parser->state, 0, sizeof (struct argp_state));\n  parser->state.root_argp = parser->argp;\n  parser->state.argc = argc;\n  parser->state.argv = argv;\n  parser->state.flags = flags;\n  parser->state.err_stream = stderr;\n  parser->state.out_stream = stdout;\n  parser->state.next = 0;       /* Tell getopt to initialize.  */\n  parser->state.pstate = parser;\n\n  parser->try_getopt = 1;\n\n  /* Call each parser for the first time, giving it a chance to propagate\n     values to child parsers.  */\n  if (parser->groups < parser->egroup)\n    parser->groups->input = input;\n  for (group = parser->groups;\n       group < parser->egroup && (!err || err == EBADKEY);\n       group++)\n    {\n      if (group->parent)\n        /* If a child parser, get the initial input value from the parent. */\n        group->input = group->parent->child_inputs[group->parent_index];\n\n      if (!group->parser\n          && group->argp->children && group->argp->children->argp)\n        /* For the special case where no parsing function is supplied for an\n           argp, propagate its input to its first child, if any (this just\n           makes very simple wrapper argps more convenient).  */\n        group->child_inputs[0] = group->input;\n\n      err = group_parse (group, &parser->state, ARGP_KEY_INIT, 0);\n    }\n  if (err == EBADKEY)\n    err = 0;                    /* Some parser didn't understand.  */\n\n  if (err)\n    return err;\n\n  if (parser->state.flags & ARGP_NO_ERRS)\n    {\n      parser->opt_data.opterr = 0;\n      if (parser->state.flags & ARGP_PARSE_ARGV0)\n        /* getopt always skips ARGV[0], so we have to fake it out.  As long\n           as OPTERR is 0, then it shouldn't actually try to access it.  */\n        parser->state.argv--, parser->state.argc++;\n    }\n  else\n    parser->opt_data.opterr = 1;        /* Print error messages.  */\n\n  if (parser->state.argv == argv && argv[0])\n    /* There's an argv[0]; use it for messages.  */\n    parser->state.name = __argp_base_name (argv[0]);\n  else\n    parser->state.name = __argp_short_program_name ();\n\n  return 0;\n}",
      "lines": 110,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_finalize": {
      "start_point": [
        569,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "static error_t\nparser_finalize (struct parser *parser,\n                 error_t err, int arg_ebadkey, int *end_index)\n{\n  struct group *group;\n\n  if (err == EBADKEY && arg_ebadkey)\n    /* Suppress errors generated by unparsed arguments.  */\n    err = 0;\n\n  if (! err)\n    {\n      if (parser->state.next == parser->state.argc)\n        /* We successfully parsed all arguments!  Call all the parsers again,\n           just a few more times... */\n        {\n          for (group = parser->groups;\n               group < parser->egroup && (!err || err==EBADKEY);\n               group++)\n            if (group->args_processed == 0)\n              err = group_parse (group, &parser->state, ARGP_KEY_NO_ARGS, 0);\n          for (group = parser->egroup - 1;\n               group >= parser->groups && (!err || err==EBADKEY);\n               group--)\n            err = group_parse (group, &parser->state, ARGP_KEY_END, 0);\n\n          if (err == EBADKEY)\n            err = 0;            /* Some parser didn't understand.  */\n\n          /* Tell the user that all arguments are parsed.  */\n          if (end_index)\n            *end_index = parser->state.next;\n        }\n      else if (end_index)\n        /* Return any remaining arguments to the user.  */\n        *end_index = parser->state.next;\n      else\n        /* No way to return the remaining arguments, they must be bogus. */\n        {\n          if (!(parser->state.flags & ARGP_NO_ERRS)\n              && parser->state.err_stream)\n            fprintf (parser->state.err_stream,\n                     dgettext (parser->argp->argp_domain,\n                               \"%s: Too many arguments\\n\"),\n                     parser->state.name);\n          err = EBADKEY;\n        }\n    }\n\n  /* Okay, we're all done, with either an error or success; call the parsers\n     to indicate which one.  */\n\n  if (err)\n    {\n      /* Maybe print an error message.  */\n      if (err == EBADKEY)\n        /* An appropriate message describing what the error was should have\n           been printed earlier.  */\n        __argp_state_help (&parser->state, parser->state.err_stream,\n                           ARGP_HELP_STD_ERR);\n\n      /* Since we didn't exit, give each parser an error indication.  */\n      for (group = parser->groups; group < parser->egroup; group++)\n        group_parse (group, &parser->state, ARGP_KEY_ERROR, 0);\n    }\n  else\n    /* Notify parsers of success, and propagate back values from parsers.  */\n    {\n      /* We pass over the groups in reverse order so that child groups are\n         given a chance to do there processing before passing back a value to\n         the parent.  */\n      for (group = parser->egroup - 1\n           ; group >= parser->groups && (!err || err == EBADKEY)\n           ; group--)\n        err = group_parse (group, &parser->state, ARGP_KEY_SUCCESS, 0);\n      if (err == EBADKEY)\n        err = 0;                /* Some parser didn't understand.  */\n    }\n\n  /* Call parsers once more, to do any final cleanup.  Errors are ignored.  */\n  for (group = parser->egroup - 1; group >= parser->groups; group--)\n    group_parse (group, &parser->state, ARGP_KEY_FINI, 0);\n\n  if (err == EBADKEY)\n    err = EINVAL;\n\n  free (parser->storage);\n\n  return err;\n}",
      "lines": 90,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_arg": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "static error_t\nparser_parse_arg (struct parser *parser, char *val)\n{\n  /* Save the starting value of NEXT, first adjusting it so that the arg\n     we're parsing is again the front of the arg vector.  */\n  int index = --parser->state.next;\n  error_t err = EBADKEY;\n  struct group *group;\n  int key = 0;                  /* Which of ARGP_KEY_ARG[S] we used.  */\n\n  /* Try to parse the argument in each parser.  */\n  for (group = parser->groups\n       ; group < parser->egroup && err == EBADKEY\n       ; group++)\n    {\n      parser->state.next++;     /* For ARGP_KEY_ARG, consume the arg.  */\n      key = ARGP_KEY_ARG;\n      err = group_parse (group, &parser->state, key, val);\n\n      if (err == EBADKEY)\n        /* This parser doesn't like ARGP_KEY_ARG; try ARGP_KEY_ARGS instead. */\n        {\n          parser->state.next--; /* For ARGP_KEY_ARGS, put back the arg.  */\n          key = ARGP_KEY_ARGS;\n          err = group_parse (group, &parser->state, key, 0);\n        }\n    }\n\n  if (! err)\n    {\n      if (key == ARGP_KEY_ARGS)\n        /* The default for ARGP_KEY_ARGS is to assume that if NEXT isn't\n           changed by the user, *all* arguments should be considered\n           consumed.  */\n        parser->state.next = parser->state.argc;\n\n      if (parser->state.next > index)\n        /* Remember that we successfully processed a non-option\n           argument -- but only if the user hasn't gotten tricky and set\n           the clock back.  */\n        (--group)->args_processed += (parser->state.next - index);\n      else\n        /* The user wants to reparse some args, give getopt another try.  */\n        parser->try_getopt = 1;\n    }\n\n  return err;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_opt": {
      "start_point": [
        716,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "static error_t\nparser_parse_opt (struct parser *parser, int opt, char *val)\n{\n  /* The group key encoded in the high bits; 0 for short opts or\n     group_number + 1 for long opts.  */\n  int group_key = opt >> USER_BITS;\n  error_t err = EBADKEY;\n\n  if (group_key == 0)\n    /* A short option.  By comparing OPT's position in SHORT_OPTS to the\n       various starting positions in each group's SHORT_END field, we can\n       determine which group OPT came from.  */\n    {\n      struct group *group;\n      char *short_index = strchr (parser->short_opts, opt);\n\n      if (short_index)\n        for (group = parser->groups; group < parser->egroup; group++)\n          if (group->short_end > short_index)\n            {\n              err = group_parse (group, &parser->state, opt,\n                                 parser->opt_data.optarg);\n              break;\n            }\n    }\n  else\n    /* A long option.  Preserve the sign in the user key, without\n       invoking undefined behavior.  Assume two's complement.  */\n    {\n      int user_key =\n        ((opt & (1 << (USER_BITS - 1))) ? ~USER_MASK : 0) | (opt & USER_MASK);\n      err =\n        group_parse (&parser->groups[group_key - 1], &parser->state,\n                     user_key, parser->opt_data.optarg);\n    }\n\n  if (err == EBADKEY)\n    /* At least currently, an option not recognized is an error in the\n       parser, because we pre-compute which parser is supposed to deal\n       with each option.  */\n    {\n      static const char bad_key_err[] =\n        N_(\"(PROGRAM ERROR) Option should have been recognized!?\");\n      if (group_key == 0)\n        __argp_error (&parser->state, \"-%c: %s\", opt,\n                      dgettext (parser->argp->argp_domain, bad_key_err));\n      else\n        {\n          struct option *long_opt = parser->long_opts;\n          while (long_opt->val != opt && long_opt->name)\n            long_opt++;\n          __argp_error (&parser->state, \"--%s: %s\",\n                        long_opt->name ? long_opt->name : \"???\",\n                        dgettext (parser->argp->argp_domain, bad_key_err));\n        }\n    }\n\n  return err;\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_next": {
      "start_point": [
        780,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "static error_t\nparser_parse_next (struct parser *parser, int *arg_ebadkey)\n{\n  int opt;\n  error_t err = 0;\n\n  if (parser->state.quoted && parser->state.next < parser->state.quoted)\n    /* The next argument pointer has been moved to before the quoted\n       region, so pretend we never saw the quoting \"--\", and give getopt\n       another chance.  If the user hasn't removed it, getopt will just\n       process it again.  */\n    parser->state.quoted = 0;\n\n  if (parser->try_getopt && !parser->state.quoted)\n    /* Give getopt a chance to parse this.  */\n    {\n      /* Put it back in OPTIND for getopt.  */\n      parser->opt_data.optind = parser->state.next;\n      /* Distinguish KEY_ERR from a real option.  */\n      parser->opt_data.optopt = KEY_END;\n      if (parser->state.flags & ARGP_LONG_ONLY)\n        opt = _getopt_long_only_r (parser->state.argc, parser->state.argv,\n                                   parser->short_opts, parser->long_opts, 0,\n                                   &parser->opt_data);\n      else\n        opt = _getopt_long_r (parser->state.argc, parser->state.argv,\n                              parser->short_opts, parser->long_opts, 0,\n                              &parser->opt_data);\n      /* And see what getopt did.  */\n      parser->state.next = parser->opt_data.optind;\n\n      if (opt == KEY_END)\n        /* Getopt says there are no more options, so stop using\n           getopt; we'll continue if necessary on our own.  */\n        {\n          parser->try_getopt = 0;\n          if (parser->state.next > 1\n              && strcmp (parser->state.argv[parser->state.next - 1], QUOTE)\n                   == 0)\n            /* Not only is this the end of the options, but it's a\n               \"quoted\" region, which may have args that *look* like\n               options, so we definitely shouldn't try to use getopt past\n               here, whatever happens.  */\n            parser->state.quoted = parser->state.next;\n        }\n      else if (opt == KEY_ERR && parser->opt_data.optopt != KEY_END)\n        /* KEY_ERR can have the same value as a valid user short\n           option, but in the case of a real error, getopt sets OPTOPT\n           to the offending character, which can never be KEY_END.  */\n        {\n          *arg_ebadkey = 0;\n          return EBADKEY;\n        }\n    }\n  else\n    opt = KEY_END;\n\n  if (opt == KEY_END)\n    {\n      /* We're past what getopt considers the options.  */\n      if (parser->state.next >= parser->state.argc\n          || (parser->state.flags & ARGP_NO_ARGS))\n        /* Indicate that we're done.  */\n        {\n          *arg_ebadkey = 1;\n          return EBADKEY;\n        }\n      else\n        /* A non-option arg; simulate what getopt might have done.  */\n        {\n          opt = KEY_ARG;\n          parser->opt_data.optarg = parser->state.argv[parser->state.next++];\n        }\n    }\n\n  if (opt == KEY_ARG)\n    /* A non-option argument; try each parser in turn.  */\n    err = parser_parse_arg (parser, parser->opt_data.optarg);\n  else\n    err = parser_parse_opt (parser, opt, parser->opt_data.optarg);\n\n  if (err == EBADKEY)\n    *arg_ebadkey = (opt == KEY_END || opt == KEY_ARG);\n\n  return err;\n}",
      "lines": 86,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "__argp_parse": {
      "start_point": [
        872,
        0
      ],
      "end_point": [
        932,
        1
      ],
      "content": "error_t\n__argp_parse (const struct argp *argp, int argc, char **argv, unsigned flags,\n              int *end_index, void *input)\n{\n  error_t err;\n  struct parser parser;\n\n  /* If true, then err == EBADKEY is a result of a non-option argument failing\n     to be parsed (which in some cases isn't actually an error).  */\n  int arg_ebadkey = 0;\n\n#ifndef _LIBC\n  if (!(flags & ARGP_PARSE_ARGV0))\n    {\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n      if (!program_invocation_name)\n        program_invocation_name = argv[0];\n#endif\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n      if (!program_invocation_short_name)\n        program_invocation_short_name = __argp_base_name (argv[0]);\n#endif\n    }\n#endif\n\n  if (! (flags & ARGP_NO_HELP))\n    /* Add our own options.  */\n    {\n      struct argp_child *child = alloca (4 * sizeof (struct argp_child));\n      struct argp *top_argp = alloca (sizeof (struct argp));\n\n      /* TOP_ARGP has no options, it just serves to group the user & default\n         argps.  */\n      memset (top_argp, 0, sizeof (*top_argp));\n      top_argp->children = child;\n\n      memset (child, 0, 4 * sizeof (struct argp_child));\n\n      if (argp)\n        (child++)->argp = argp;\n      (child++)->argp = &argp_default_argp;\n      if (argp_program_version || argp_program_version_hook)\n        (child++)->argp = &argp_version_argp;\n      child->argp = 0;\n\n      argp = top_argp;\n    }\n\n  /* Construct a parser for these arguments.  */\n  err = parser_init (&parser, argp, argc, argv, flags, input);\n\n  if (! err)\n    /* Parse! */\n    {\n      while (! err)\n        err = parser_parse_next (&parser, &arg_ebadkey);\n      err = parser_finalize (&parser, err, arg_ebadkey, end_index);\n    }\n\n  return err;\n}",
      "lines": 61,
      "depth": 13,
      "decorators": [
        "error_t"
      ]
    },
    "__argp_input": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        953,
        1
      ],
      "content": "void *\n__argp_input (const struct argp *argp, const struct argp_state *state)\n{\n  if (state)\n    {\n      struct group *group;\n      struct parser *parser = state->pstate;\n\n      for (group = parser->groups; group < parser->egroup; group++)\n        if (group->argp == argp)\n          return group->input;\n    }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void",
        "*\n__argp_input (const struct argp *argp, const struct argp_state *state)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/argp-pin.c": {},
  "tar/tar-1.30/gnu/argp-pv.c": {},
  "tar/tar-1.30/gnu/argp-pvh.c": {},
  "tar/tar-1.30/gnu/argp-version-etc.c": {
    "version_etc_hook": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void\nversion_etc_hook (FILE *stream, struct argp_state *state)\n{\n  version_etc_ar (stream, program_canonical_name, PACKAGE_NAME, VERSION,\n                  program_authors);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argp_version_setup": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\nargp_version_setup (const char *name, const char * const *authors)\n{\n  argp_program_version_hook = version_etc_hook;\n  program_canonical_name = name;\n  program_authors = authors;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/argp-version-etc.h": {},
  "tar/tar-1.30/gnu/argp-xinl.c": {},
  "tar/tar-1.30/gnu/argp.h": {
    "__argp_usage": {
      "start_point": [
        593,
        0
      ],
      "end_point": [
        597,
        1
      ],
      "content": "ARGP_EI void\n__argp_usage (const struct argp_state *__state)\n{\n  __argp_state_help (__state, stderr, ARGP_HELP_STD_USAGE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "ARGP_EI",
        "void",
        "void"
      ]
    },
    "__NTH": [
      {
        "start_point": [
          599,
          0
        ],
        "end_point": [
          609,
          1
        ],
        "content": "ARGP_EI int\n__NTH (__option_is_short (const struct argp_option *__opt))\n{\n  if (__opt->flags & OPTION_DOC)\n    return 0;\n  else\n    {\n      int __key = __opt->key;\n      return __key > 0 && __key <= UCHAR_MAX && isprint (__key);\n    }\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "ARGP_EI",
          "int",
          "int"
        ]
      },
      {
        "start_point": [
          611,
          0
        ],
        "end_point": [
          615,
          1
        ],
        "content": "ARGP_EI int\n__NTH (__option_is_end (const struct argp_option *__opt))\n{\n  return !__opt->key && !__opt->name && !__opt->doc && !__opt->group;\n}",
        "lines": 5,
        "depth": 9,
        "decorators": [
          "ARGP_EI",
          "int",
          "int"
        ]
      }
    ]
  },
  "tar/tar-1.30/gnu/asnprintf.c": {
    "asnprintf": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "char",
        "*\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/asprintf.c": {
    "asprintf": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nasprintf (char **resultp, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = vasprintf (resultp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/assure.h": {},
  "tar/tar-1.30/gnu/at-func.c": {
    "AT_FUNC_NAME": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "FUNC_RESULT\nAT_FUNC_NAME (int fd, char const *file AT_FUNC_POST_FILE_PARAM_DECLS)\n{\n  VALIDATE_FLAG (flag);\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return CALL_FUNC (file);\n\n#ifdef GNULIB_SUPPORT_ONLY_AT_FDCWD\n  errno = ENOTSUP;\n  return FUNC_FAIL;\n#else\n  {\n  /* Be careful to choose names unlikely to conflict with\n     AT_FUNC_POST_FILE_PARAM_DECLS.  */\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  FUNC_RESULT err;\n\n  {\n    char proc_buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (proc_buf, fd, file);\n    if (proc_file)\n      {\n        FUNC_RESULT proc_result = CALL_FUNC (proc_file);\n        int proc_errno = errno;\n        if (proc_file != proc_buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (FUNC_FAIL != proc_result)\n          return proc_result;\n        if (! EXPECTED_ERRNO (proc_errno))\n          {\n            errno = proc_errno;\n            return proc_result;\n          }\n      }\n  }\n\n  if (save_cwd (&saved_cwd) != 0)\n    openat_save_fail (errno);\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return FUNC_FAIL;\n    }\n\n  if (fchdir (fd) != 0)\n    {\n      saved_errno = errno;\n      free_cwd (&saved_cwd);\n      errno = saved_errno;\n      return FUNC_FAIL;\n    }\n\n  err = CALL_FUNC (file);\n  saved_errno = (err == FUNC_FAIL ? errno : 0);\n\n  if (restore_cwd (&saved_cwd) != 0)\n    openat_restore_fail (errno);\n\n  free_cwd (&saved_cwd);\n\n  if (saved_errno)\n    errno = saved_errno;\n  return err;\n  }\n#endif\n}",
      "lines": 75,
      "depth": 14,
      "decorators": [
        "FUNC_RESULT"
      ]
    }
  },
  "tar/tar-1.30/gnu/at-func2.c": {
    "at_func2": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "int\nat_func2 (int fd1, char const *file1,\n          int fd2, char const *file2,\n          int (*func) (char const *file1, char const *file2))\n{\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  int err;\n  char *file1_alt;\n  char *file2_alt;\n  struct stat st1;\n  struct stat st2;\n\n  /* There are 16 possible scenarios, based on whether an fd is\n     AT_FDCWD or real, and whether a file is absolute or relative:\n\n         fd1  file1 fd2  file2  action\n     0   cwd  abs   cwd  abs    direct call\n     1   cwd  abs   cwd  rel    direct call\n     2   cwd  abs   fd   abs    direct call\n     3   cwd  abs   fd   rel    chdir to fd2\n     4   cwd  rel   cwd  abs    direct call\n     5   cwd  rel   cwd  rel    direct call\n     6   cwd  rel   fd   abs    direct call\n     7   cwd  rel   fd   rel    convert file1 to abs, then case 3\n     8   fd   abs   cwd  abs    direct call\n     9   fd   abs   cwd  rel    direct call\n     10  fd   abs   fd   abs    direct call\n     11  fd   abs   fd   rel    chdir to fd2\n     12  fd   rel   cwd  abs    chdir to fd1\n     13  fd   rel   cwd  rel    convert file2 to abs, then case 12\n     14  fd   rel   fd   abs    chdir to fd1\n     15a fd1  rel   fd1  rel    chdir to fd1\n     15b fd1  rel   fd2  rel    chdir to fd1, then case 7\n\n     Try some optimizations to reduce fd to AT_FDCWD, or to at least\n     avoid converting an absolute name or doing a double chdir.  */\n\n  if ((fd1 == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file1))\n      && (fd2 == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file2)))\n    return func (file1, file2); /* Case 0-2, 4-6, 8-10.  */\n\n  /* If /proc/self/fd works, we don't need any stat or chdir.  */\n  {\n    char proc_buf1[OPENAT_BUFFER_SIZE];\n    char *proc_file1 = ((fd1 == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file1))\n                        ? (char *) file1\n                        : openat_proc_name (proc_buf1, fd1, file1));\n    if (proc_file1)\n      {\n        char proc_buf2[OPENAT_BUFFER_SIZE];\n        char *proc_file2 = ((fd2 == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file2))\n                            ? (char *) file2\n                            : openat_proc_name (proc_buf2, fd2, file2));\n        if (proc_file2)\n          {\n            int proc_result = func (proc_file1, proc_file2);\n            int proc_errno = errno;\n            if (proc_file1 != proc_buf1 && proc_file1 != file1)\n              free (proc_file1);\n            if (proc_file2 != proc_buf2 && proc_file2 != file2)\n              free (proc_file2);\n            /* If the syscall succeeds, or if it fails with an unexpected\n               errno value, then return right away.  Otherwise, fall through\n               and resort to using save_cwd/restore_cwd.  */\n            if (0 <= proc_result)\n              return proc_result;\n            if (! EXPECTED_ERRNO (proc_errno))\n              {\n                errno = proc_errno;\n                return proc_result;\n              }\n          }\n        else if (proc_file1 != proc_buf1 && proc_file1 != file1)\n          free (proc_file1);\n      }\n  }\n\n  /* Cases 3, 7, 11-15 remain.  Time to normalize directory fds, if\n     possible.  */\n  if (IS_ABSOLUTE_FILE_NAME (file1))\n    fd1 = AT_FDCWD; /* Case 11 reduced to 3.  */\n  else if (IS_ABSOLUTE_FILE_NAME (file2))\n    fd2 = AT_FDCWD; /* Case 14 reduced to 12.  */\n\n  /* Cases 3, 7, 12, 13, 15 remain.  */\n\n  if (fd1 == AT_FDCWD) /* Cases 3, 7.  */\n    {\n      if (stat (\".\", &st1) == -1 || fstat (fd2, &st2) == -1)\n        return -1;\n      if (!S_ISDIR (st2.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      if (SAME_INODE (st1, st2)) /* Reduced to cases 1, 5.  */\n        return func (file1, file2);\n    }\n  else if (fd2 == AT_FDCWD) /* Cases 12, 13.  */\n    {\n      if (stat (\".\", &st2) == -1 || fstat (fd1, &st1) == -1)\n        return -1;\n      if (!S_ISDIR (st1.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      if (SAME_INODE (st1, st2)) /* Reduced to cases 4, 5.  */\n        return func (file1, file2);\n    }\n  else if (fd1 != fd2) /* Case 15b.  */\n    {\n      if (fstat (fd1, &st1) == -1 || fstat (fd2, &st2) == -1)\n        return -1;\n      if (!S_ISDIR (st1.st_mode) || !S_ISDIR (st2.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      if (SAME_INODE (st1, st2)) /* Reduced to case 15a.  */\n        {\n          fd2 = fd1;\n          if (stat (\".\", &st1) == 0 && SAME_INODE (st1, st2))\n            return func (file1, file2); /* Further reduced to case 5.  */\n        }\n    }\n  else /* Case 15a.  */\n    {\n      if (fstat (fd1, &st1) == -1)\n        return -1;\n      if (!S_ISDIR (st1.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      if (stat (\".\", &st2) == 0 && SAME_INODE (st1, st2))\n        return func (file1, file2); /* Reduced to case 5.  */\n    }\n\n  /* Cases 3, 7, 12, 13, 15a, 15b remain.  With all reductions in\n     place, it is time to start changing directories.  */\n\n  if (save_cwd (&saved_cwd) != 0)\n    openat_save_fail (errno);\n\n  if (fd1 != AT_FDCWD && fd2 != AT_FDCWD && fd1 != fd2) /* Case 15b.  */\n    {\n      if (fchdir (fd1) != 0)\n        {\n          saved_errno = errno;\n          free_cwd (&saved_cwd);\n          errno = saved_errno;\n          return -1;\n        }\n      fd1 = AT_FDCWD; /* Reduced to case 7.  */\n    }\n\n  /* Cases 3, 7, 12, 13, 15a remain.  Convert one relative name to\n     absolute, if necessary.  */\n\n  file1_alt = (char *) file1;\n  file2_alt = (char *) file2;\n\n  if (fd1 == AT_FDCWD && !IS_ABSOLUTE_FILE_NAME (file1)) /* Case 7.  */\n    {\n      /* It would be nicer to use:\n         file1_alt = file_name_concat (xgetcwd (), file1, NULL);\n         but libraries should not call xalloc_die.  */\n      char *cwd = getcwd (NULL, 0);\n      if (!cwd)\n        {\n          saved_errno = errno;\n          free_cwd (&saved_cwd);\n          errno = saved_errno;\n          return -1;\n        }\n      file1_alt = mfile_name_concat (cwd, file1, NULL);\n      if (!file1_alt)\n        {\n          saved_errno = errno;\n          free (cwd);\n          free_cwd (&saved_cwd);\n          errno = saved_errno;\n          return -1;\n        }\n      free (cwd); /* Reduced to case 3.  */\n    }\n  else if (fd2 == AT_FDCWD && !IS_ABSOLUTE_FILE_NAME (file2)) /* Case 13.  */\n    {\n      char *cwd = getcwd (NULL, 0);\n      if (!cwd)\n        {\n          saved_errno = errno;\n          free_cwd (&saved_cwd);\n          errno = saved_errno;\n          return -1;\n        }\n      file2_alt = mfile_name_concat (cwd, file2, NULL);\n      if (!file2_alt)\n        {\n          saved_errno = errno;\n          free (cwd);\n          free_cwd (&saved_cwd);\n          errno = saved_errno;\n          return -1;\n        }\n      free (cwd); /* Reduced to case 12.  */\n    }\n\n  /* Cases 3, 12, 15a remain.  Change to the correct directory.  */\n  if (fchdir (fd1 == AT_FDCWD ? fd2 : fd1) != 0)\n    {\n      saved_errno = errno;\n      free_cwd (&saved_cwd);\n      if (file1 != file1_alt)\n        free (file1_alt);\n      else if (file2 != file2_alt)\n        free (file2_alt);\n      errno = saved_errno;\n      return -1;\n    }\n\n  /* Finally safe to perform the user's function, then clean up.  */\n\n  err = func (file1_alt, file2_alt);\n  saved_errno = (err < 0 ? errno : 0);\n\n  if (file1 != file1_alt)\n    free (file1_alt);\n  else if (file2 != file2_alt)\n    free (file2_alt);\n\n  if (restore_cwd (&saved_cwd) != 0)\n    openat_restore_fail (errno);\n\n  free_cwd (&saved_cwd);\n\n  if (saved_errno)\n    errno = saved_errno;\n  return err;\n}",
      "lines": 242,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/backup-find.c": {
    "find_backup_file_name": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\nfind_backup_file_name (char const *file, enum backup_type backup_type)\n{\n  char *result = backupfile_internal (file, backup_type, false);\n  if (!result)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nfind_backup_file_name (char const *file, enum backup_type backup_type)",
        "*"
      ]
    },
    "get_version": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "enum backup_type\nget_version (char const *context, char const *version)\n{\n  if (version == 0 || *version == 0)\n    return numbered_existing_backups;\n  else\n    return XARGMATCH (context, version, backup_args, backup_types);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "enum backup_type",
        "enum",
        "backup_type"
      ]
    },
    "xget_version": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "enum backup_type\nxget_version (char const *context, char const *version)\n{\n  if (version && *version)\n    return get_version (context, version);\n  else\n    return get_version (\"$VERSION_CONTROL\", getenv (\"VERSION_CONTROL\"));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "enum backup_type",
        "enum",
        "backup_type"
      ]
    }
  },
  "tar/tar-1.30/gnu/backup-internal.h": {},
  "tar/tar-1.30/gnu/backupfile.c": {
    "set_simple_backup_suffix": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nset_simple_backup_suffix (char const *s)\n{\n  if (!s)\n    s = getenv (\"SIMPLE_BACKUP_SUFFIX\");\n  simple_backup_suffix = s && *s && s == last_component (s) ? s : \"~\";\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_extension": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static void\ncheck_extension (char *file, size_t filelen, char e)\n{\n  char *base = last_component (file);\n  size_t baselen = base_len (base);\n  size_t baselen_max = HAVE_LONG_FILE_NAMES ? 255 : NAME_MAX_MINIMUM;\n\n  if (HAVE_DOS_FILE_NAMES || NAME_MAX_MINIMUM < baselen)\n    {\n      /* The new base name is long enough to require a pathconf check.  */\n      long name_max;\n\n      /* Temporarily modify the buffer into its parent directory name,\n         invoke pathconf on the directory, and then restore the buffer.  */\n      char tmp[sizeof \".\"];\n      memcpy (tmp, base, sizeof \".\");\n      strcpy (base, \".\");\n      errno = 0;\n      name_max = pathconf (file, _PC_NAME_MAX);\n      if (0 <= name_max || errno == 0)\n        {\n          long size = baselen_max = name_max;\n          if (name_max != size)\n            baselen_max = SIZE_MAX;\n        }\n      memcpy (base, tmp, sizeof \".\");\n    }\n\n  if (HAVE_DOS_FILE_NAMES && baselen_max <= 12)\n    {\n      /* Live within DOS's 8.3 limit.  */\n      char *dot = strchr (base, '.');\n      if (!dot)\n        baselen_max = 8;\n      else\n        {\n          char const *second_dot = strchr (dot + 1, '.');\n          baselen_max = (second_dot\n                         ? second_dot - base\n                         : dot + 1 - base + 3);\n        }\n    }\n\n  if (baselen_max < baselen)\n    {\n      baselen = file + filelen - base;\n      if (baselen_max <= baselen)\n        baselen = baselen_max - 1;\n      base[baselen] = e;\n      base[baselen + 1] = '\\0';\n    }\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "numbered_backup": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static enum numbered_backup_result\nnumbered_backup (char **buffer, size_t buffer_size, size_t filelen,\n                 ptrdiff_t base_offset, DIR **dirpp)\n{\n  enum numbered_backup_result result = BACKUP_IS_NEW;\n  DIR *dirp = *dirpp;\n  struct dirent *dp;\n  char *buf = *buffer;\n  size_t versionlenmax = 1;\n  char *base = buf + base_offset;\n  size_t baselen = base_len (base);\n\n  if (dirp)\n    rewinddir (dirp);\n  else\n    {\n      /* Temporarily modify the buffer into its parent directory name,\n         open the directory, and then restore the buffer.  */\n      char tmp[sizeof \".\"];\n      memcpy (tmp, base, sizeof \".\");\n      strcpy (base, \".\");\n      dirp = opendir (buf);\n      if (!dirp && errno == ENOMEM)\n        result = BACKUP_NOMEM;\n      memcpy (base, tmp, sizeof \".\");\n      strcpy (base + baselen, \".~1~\");\n      if (!dirp)\n        return result;\n      *dirpp = dirp;\n    }\n\n  while ((dp = readdir (dirp)) != NULL)\n    {\n      char const *p;\n      char *q;\n      bool all_9s;\n      size_t versionlen;\n\n      if (_D_EXACT_NAMLEN (dp) < baselen + 4)\n        continue;\n\n      if (memcmp (buf + base_offset, dp->d_name, baselen + 2) != 0)\n        continue;\n\n      p = dp->d_name + baselen + 2;\n\n      /* Check whether this file has a version number and if so,\n         whether it is larger.  Use string operations rather than\n         integer arithmetic, to avoid problems with integer overflow.  */\n\n      if (! ('1' <= *p && *p <= '9'))\n        continue;\n      all_9s = (*p == '9');\n      for (versionlen = 1; ISDIGIT (p[versionlen]); versionlen++)\n        all_9s &= (p[versionlen] == '9');\n\n      if (! (p[versionlen] == '~' && !p[versionlen + 1]\n             && (versionlenmax < versionlen\n                 || (versionlenmax == versionlen\n                     && memcmp (buf + filelen + 2, p, versionlen) <= 0))))\n        continue;\n\n      /* This entry has the largest version number seen so far.\n         Append this highest numbered extension to the file name,\n         prepending '0' to the number if it is all 9s.  */\n\n      versionlenmax = all_9s + versionlen;\n      result = (all_9s ? BACKUP_IS_LONGER : BACKUP_IS_SAME_LENGTH);\n      size_t new_buffer_size = filelen + 2 + versionlenmax + 2;\n      if (buffer_size < new_buffer_size)\n        {\n          if (! xalloc_oversized (new_buffer_size, 2))\n            new_buffer_size *= 2;\n          char *new_buf = realloc (buf, new_buffer_size);\n          if (!new_buf)\n            {\n              *buffer = buf;\n              return BACKUP_NOMEM;\n            }\n          buf = new_buf;\n          buffer_size = new_buffer_size;\n        }\n      q = buf + filelen;\n      *q++ = '.';\n      *q++ = '~';\n      *q = '0';\n      q += all_9s;\n      memcpy (q, p, versionlen + 2);\n\n      /* Add 1 to the version number.  */\n\n      q += versionlen;\n      while (*--q == '9')\n        *q = '0';\n      ++*q;\n    }\n\n  *buffer = buf;\n  return result;\n}",
      "lines": 100,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "enum numbered_backup_result",
        "enum",
        "numbered_backup_result"
      ]
    },
    "backupfile_internal": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "char *\nbackupfile_internal (char const *file, enum backup_type backup_type, bool rename)\n{\n  ptrdiff_t base_offset = last_component (file) - file;\n  size_t filelen = base_offset + strlen (file + base_offset);\n\n  if (! simple_backup_suffix)\n    set_simple_backup_suffix (NULL);\n\n  /* Allow room for simple or \".~N~\" backups.  The guess must be at\n     least sizeof \".~1~\", but otherwise will be adjusted as needed.  */\n  size_t simple_backup_suffix_size = strlen (simple_backup_suffix) + 1;\n  size_t backup_suffix_size_guess = simple_backup_suffix_size;\n  enum { GUESS = sizeof \".~12345~\" };\n  if (backup_suffix_size_guess < GUESS)\n    backup_suffix_size_guess = GUESS;\n\n  ssize_t ssize = filelen + backup_suffix_size_guess + 1;\n  char *s = malloc (ssize);\n  if (!s)\n    return s;\n\n  DIR *dirp = NULL;\n  while (true)\n    {\n      memcpy (s, file, filelen + 1);\n\n      if (backup_type == simple_backups)\n        memcpy (s + filelen, simple_backup_suffix, simple_backup_suffix_size);\n      else\n        switch (numbered_backup (&s, ssize, filelen, base_offset, &dirp))\n          {\n          case BACKUP_IS_SAME_LENGTH:\n            break;\n\n          case BACKUP_IS_NEW:\n            if (backup_type == numbered_existing_backups)\n              {\n                backup_type = simple_backups;\n                memcpy (s + filelen, simple_backup_suffix,\n                        simple_backup_suffix_size);\n              }\n            check_extension (s, filelen, '~');\n            break;\n\n          case BACKUP_IS_LONGER:\n            check_extension (s, filelen, '~');\n            break;\n\n          case BACKUP_NOMEM:\n            free (s);\n            errno = ENOMEM;\n            return NULL;\n          }\n\n      if (! rename)\n        break;\n\n      int sdir = dirp ? dirfd (dirp) : -1;\n      if (sdir < 0)\n        {\n          sdir = AT_FDCWD;\n          base_offset = 0;\n        }\n      unsigned flags = backup_type == simple_backups ? 0 : RENAME_NOREPLACE;\n      if (renameat2 (AT_FDCWD, file, sdir, s + base_offset, flags) == 0)\n        break;\n      int e = errno;\n      if (e != EEXIST)\n        {\n          if (dirp)\n            closedir (dirp);\n          free (s);\n          errno = e;\n          return NULL;\n        }\n    }\n\n  if (dirp)\n    closedir (dirp);\n  return s;\n}",
      "lines": 82,
      "depth": 15,
      "decorators": [
        "char",
        "*\nbackupfile_internal (char const *file, enum backup_type backup_type, bool rename)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/backupfile.h": {},
  "tar/tar-1.30/gnu/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/basename.c": {
    "base_name": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char *\nbase_name (char const *name)\n{\n  char const *base = last_component (name);\n  size_t length;\n\n  /* If there is no last component, then name is a file system root or the\n     empty string.  */\n  if (! *base)\n    return xstrndup (name, base_len (name));\n\n  /* Collapse a sequence of trailing slashes into one.  */\n  length = base_len (base);\n  if (ISSLASH (base[length]))\n    length++;\n\n  /* On systems with drive letters, \"a/b:c\" must return \"./b:c\" rather\n     than \"b:c\" to avoid confusion with a drive letter.  On systems\n     with pure POSIX semantics, this is not an issue.  */\n  if (FILE_SYSTEM_PREFIX_LEN (base))\n    {\n      char *p = xmalloc (length + 3);\n      p[0] = '.';\n      p[1] = '/';\n      memcpy (p + 2, base, length);\n      p[length + 2] = '\\0';\n      return p;\n    }\n\n  /* Finally, copy the basename.  */\n  return xstrndup (base, length);\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "char",
        "*\nbase_name (char const *name)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/bitrotate.c": {},
  "tar/tar-1.30/gnu/bitrotate.h": {
    "uint64_t": [
      {
        "start_point": [
          37,
          0
        ],
        "end_point": [
          41,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotl64 (uint64_t x, int n)\n{\n  return ((x << n) | (x >> (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotr64 (uint64_t x, int n)\n{\n  return ((x >> n) | (x << (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint32_t": [
      {
        "start_point": [
          56,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotl32 (uint32_t x, int n)\n{\n  return ((x << n) | (x >> (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          65,
          0
        ],
        "end_point": [
          69,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotr32 (uint32_t x, int n)\n{\n  return ((x >> n) | (x << (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "rotl_sz": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotl_sz (size_t x, int n)\n{\n  return ((x << n) | (x >> ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "rotr_sz": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotr_sz (size_t x, int n)\n{\n  return ((x >> n) | (x << ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "uint16_t": [
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          98,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotl16 (uint16_t x, int n)\n{\n  return ((x << n) | (x >> (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          105,
          0
        ],
        "end_point": [
          109,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotr16 (uint16_t x, int n)\n{\n  return ((x >> n) | (x << (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint8_t": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotl8 (uint8_t x, int n)\n{\n  return ((x << n) | (x >> (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          127,
          0
        ],
        "end_point": [
          131,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotr8 (uint8_t x, int n)\n{\n  return ((x >> n) | (x << (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ]
  },
  "tar/tar-1.30/gnu/btowc.c": {
    "btowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "wint_t\nbtowc (int c)\n{\n  if (c != EOF)\n    {\n      char buf[1];\n      wchar_t wc;\n\n      buf[0] = c;\n      if (mbtowc (&wc, buf, 1) >= 0)\n        return wc;\n    }\n  return WEOF;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "wint_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/c++defs.h": {},
  "tar/tar-1.30/gnu/c-ctype.c": {},
  "tar/tar-1.30/gnu/c-ctype.h": {
    "c_isalnum": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalnum (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalpha (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isascii": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isascii (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_CNTRL:\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isblank (int c)\n{\n  return c == ' ' || c == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_iscntrl (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_CNTRL:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isgraph (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_islower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isprint (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_ispunct (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_PUNCT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isspace (int c)\n{\n  switch (c)\n    {\n    case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isxdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_A_THRU_F:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_tolower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return c - 'A' + 'a';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_toupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return c - 'a' + 'A';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/c-strcase.h": {},
  "tar/tar-1.30/gnu/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/canonicalize-lgpl.c": {
    "alloc_failed": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static void\nalloc_failed (void)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Avoid errno problem without using the malloc or realloc modules; see:\n     https://lists.gnu.org/r/bug-gnulib/2016-08/msg00025.html  */\n  errno = ENOMEM;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__realpath": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "char *\n__realpath (const char *name, char *resolved)\n{\n  char *rpath, *dest, *extra_buf = NULL;\n  const char *start, *end, *rpath_limit;\n  long int path_max;\n  int num_links = 0;\n  size_t prefix_len;\n\n  if (name == NULL)\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n         either parameter is a null pointer.  We extend this to allow\n         the RESOLVED parameter to be NULL in case the we are expected to\n         allocate the room for the return value.  */\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  if (name[0] == '\\0')\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n         the name argument points to an empty string.  */\n      __set_errno (ENOENT);\n      return NULL;\n    }\n\n#ifdef PATH_MAX\n  path_max = PATH_MAX;\n#else\n  path_max = pathconf (name, _PC_PATH_MAX);\n  if (path_max <= 0)\n    path_max = 8192;\n#endif\n\n  if (resolved == NULL)\n    {\n      rpath = malloc (path_max);\n      if (rpath == NULL)\n        {\n          alloc_failed ();\n          return NULL;\n        }\n    }\n  else\n    rpath = resolved;\n  rpath_limit = rpath + path_max;\n\n  /* This is always zero for Posix hosts, but can be 2 for MS-Windows\n     and MS-DOS X:/foo/bar file names.  */\n  prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  if (!IS_ABSOLUTE_FILE_NAME (name))\n    {\n      if (!__getcwd (rpath, path_max))\n        {\n          rpath[0] = '\\0';\n          goto error;\n        }\n      dest = strchr (rpath, '\\0');\n      start = name;\n      prefix_len = FILE_SYSTEM_PREFIX_LEN (rpath);\n    }\n  else\n    {\n      dest = rpath;\n      if (prefix_len)\n        {\n          memcpy (rpath, name, prefix_len);\n          dest += prefix_len;\n        }\n      *dest++ = '/';\n      if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n        {\n          if (ISSLASH (name[1]) && !ISSLASH (name[2]) && !prefix_len)\n            *dest++ = '/';\n          *dest = '\\0';\n        }\n      start = name + prefix_len;\n    }\n\n  for (end = start; *start; start = end)\n    {\n#ifdef _LIBC\n      struct stat64 st;\n#else\n      struct stat st;\n#endif\n\n      /* Skip sequence of multiple path-separators.  */\n      while (ISSLASH (*start))\n        ++start;\n\n      /* Find end of path component.  */\n      for (end = start; *end && !ISSLASH (*end); ++end)\n        /* Nothing.  */;\n\n      if (end - start == 0)\n        break;\n      else if (end - start == 1 && start[0] == '.')\n        /* nothing */;\n      else if (end - start == 2 && start[0] == '.' && start[1] == '.')\n        {\n          /* Back up to previous component, ignore if at root already.  */\n          if (dest > rpath + prefix_len + 1)\n            for (--dest; dest > rpath && !ISSLASH (dest[-1]); --dest)\n              continue;\n          if (DOUBLE_SLASH_IS_DISTINCT_ROOT\n              && dest == rpath + 1 && !prefix_len\n              && ISSLASH (*dest) && !ISSLASH (dest[1]))\n            dest++;\n        }\n      else\n        {\n          size_t new_size;\n\n          if (!ISSLASH (dest[-1]))\n            *dest++ = '/';\n\n          if (dest + (end - start) >= rpath_limit)\n            {\n              ptrdiff_t dest_offset = dest - rpath;\n              char *new_rpath;\n\n              if (resolved)\n                {\n                  __set_errno (ENAMETOOLONG);\n                  if (dest > rpath + prefix_len + 1)\n                    dest--;\n                  *dest = '\\0';\n                  goto error;\n                }\n              new_size = rpath_limit - rpath;\n              if (end - start + 1 > path_max)\n                new_size += end - start + 1;\n              else\n                new_size += path_max;\n              new_rpath = (char *) realloc (rpath, new_size);\n              if (new_rpath == NULL)\n                {\n                  alloc_failed ();\n                  goto error;\n                }\n              rpath = new_rpath;\n              rpath_limit = rpath + new_size;\n\n              dest = rpath + dest_offset;\n            }\n\n#ifdef _LIBC\n          dest = __mempcpy (dest, start, end - start);\n#else\n          memcpy (dest, start, end - start);\n          dest += end - start;\n#endif\n          *dest = '\\0';\n\n          /* FIXME: if lstat fails with errno == EOVERFLOW,\n             the entry exists.  */\n#ifdef _LIBC\n          if (__lxstat64 (_STAT_VER, rpath, &st) < 0)\n#else\n          if (lstat (rpath, &st) < 0)\n#endif\n            goto error;\n\n          if (S_ISLNK (st.st_mode))\n            {\n              char *buf;\n              size_t len;\n              ssize_t n;\n\n              if (++num_links > MAXSYMLINKS)\n                {\n                  __set_errno (ELOOP);\n                  goto error;\n                }\n\n              buf = malloca (path_max);\n              if (!buf)\n                {\n                  __set_errno (ENOMEM);\n                  goto error;\n                }\n\n              n = __readlink (rpath, buf, path_max - 1);\n              if (n < 0)\n                {\n                  int saved_errno = errno;\n                  freea (buf);\n                  __set_errno (saved_errno);\n                  goto error;\n                }\n              buf[n] = '\\0';\n\n              if (!extra_buf)\n                {\n                  extra_buf = malloca (path_max);\n                  if (!extra_buf)\n                    {\n                      freea (buf);\n                      __set_errno (ENOMEM);\n                      goto error;\n                    }\n                }\n\n              len = strlen (end);\n              /* Check that n + len + 1 doesn't overflow and is <= path_max. */\n              if (n >= SIZE_MAX - len || n + len >= path_max)\n                {\n                  freea (buf);\n                  __set_errno (ENAMETOOLONG);\n                  goto error;\n                }\n\n              /* Careful here, end may be a pointer into extra_buf... */\n              memmove (&extra_buf[n], end, len + 1);\n              name = end = memcpy (extra_buf, buf, n);\n\n              if (IS_ABSOLUTE_FILE_NAME (buf))\n                {\n                  size_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);\n\n                  if (pfxlen)\n                    memcpy (rpath, buf, pfxlen);\n                  dest = rpath + pfxlen;\n                  *dest++ = '/'; /* It's an absolute symlink */\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n                    {\n                      if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)\n                        *dest++ = '/';\n                      *dest = '\\0';\n                    }\n                  /* Install the new prefix to be in effect hereafter.  */\n                  prefix_len = pfxlen;\n                }\n              else\n                {\n                  /* Back up to previous component, ignore if at root\n                     already: */\n                  if (dest > rpath + prefix_len + 1)\n                    for (--dest; dest > rpath && !ISSLASH (dest[-1]); --dest)\n                      continue;\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rpath + 1\n                      && ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)\n                    dest++;\n                }\n            }\n          else if (!S_ISDIR (st.st_mode) && *end != '\\0')\n            {\n              __set_errno (ENOTDIR);\n              goto error;\n            }\n        }\n    }\n  if (dest > rpath + prefix_len + 1 && ISSLASH (dest[-1]))\n    --dest;\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rpath + 1 && !prefix_len\n      && ISSLASH (*dest) && !ISSLASH (dest[1]))\n    dest++;\n  *dest = '\\0';\n\n  if (extra_buf)\n    freea (extra_buf);\n\n  return rpath;\n\nerror:\n  {\n    int saved_errno = errno;\n    if (extra_buf)\n      freea (extra_buf);\n    if (resolved == NULL)\n      free (rpath);\n    __set_errno (saved_errno);\n  }\n  return NULL;\n}",
      "lines": 278,
      "depth": 24,
      "decorators": [
        "char",
        "*\n__realpath (const char *name, char *resolved)",
        "*"
      ]
    },
    "__old_realpath": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "char *\nattribute_compat_text_section\n__old_realpath (const char *name, char *resolved)\n{\n  if (resolved == NULL)\n    {\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  return __realpath (name, resolved);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nattribute_compat_text_section\n__old_realpath (const char *name, char *resolved)",
        "*",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "__canonicalize_file_name": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "char *\n__canonicalize_file_name (const char *name)\n{\n  return __realpath (name, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__canonicalize_file_name (const char *name)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/careadlinkat.c": {
    "careadlinkat": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "char *\ncareadlinkat (int fd, char const *filename,\n              char *buffer, size_t buffer_size,\n              struct allocator const *alloc,\n              ssize_t (*preadlinkat) (int, char const *, char *, size_t))\n{\n  char *buf;\n  size_t buf_size;\n  size_t buf_size_max =\n    SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n  char stack_buf[1024];\n\n  if (! alloc)\n    alloc = &stdlib_allocator;\n\n  if (! buffer_size)\n    {\n      /* Allocate the initial buffer on the stack.  This way, in the\n         common case of a symlink of small size, we get away with a\n         single small malloc() instead of a big malloc() followed by a\n         shrinking realloc().  */\n      buffer = stack_buf;\n      buffer_size = sizeof stack_buf;\n    }\n\n  buf = buffer;\n  buf_size = buffer_size;\n\n  do\n    {\n      /* Attempt to read the link into the current buffer.  */\n      ssize_t link_length = preadlinkat (fd, filename, buf, buf_size);\n      size_t link_size;\n      if (link_length < 0)\n        {\n          /* On AIX 5L v5.3 and HP-UX 11i v2 04/09, readlink returns -1\n             with errno == ERANGE if the buffer is too small.  */\n          int readlinkat_errno = errno;\n          if (readlinkat_errno != ERANGE)\n            {\n              if (buf != buffer)\n                {\n                  alloc->free (buf);\n                  errno = readlinkat_errno;\n                }\n              return NULL;\n            }\n        }\n\n      link_size = link_length;\n\n      if (link_size < buf_size)\n        {\n          buf[link_size++] = '\\0';\n\n          if (buf == stack_buf)\n            {\n              char *b = (char *) alloc->allocate (link_size);\n              buf_size = link_size;\n              if (! b)\n                break;\n              memcpy (b, buf, link_size);\n              buf = b;\n            }\n          else if (link_size < buf_size && buf != buffer && alloc->reallocate)\n            {\n              /* Shrink BUF before returning it.  */\n              char *b = (char *) alloc->reallocate (buf, link_size);\n              if (b)\n                buf = b;\n            }\n\n          return buf;\n        }\n\n      if (buf != buffer)\n        alloc->free (buf);\n\n      if (buf_size <= buf_size_max / 2)\n        buf_size *= 2;\n      else if (buf_size < buf_size_max)\n        buf_size = buf_size_max;\n      else if (buf_size_max < SIZE_MAX)\n        {\n          errno = ENAMETOOLONG;\n          return NULL;\n        }\n      else\n        break;\n      buf = (char *) alloc->allocate (buf_size);\n    }\n  while (buf);\n\n  if (alloc->die)\n    alloc->die (buf_size);\n  errno = ENOMEM;\n  return NULL;\n}",
      "lines": 98,
      "depth": 15,
      "decorators": [
        "char",
        "*\ncareadlinkat (int fd, char const *filename,\n              char *buffer, size_t buffer_size,\n              struct allocator const *alloc,\n              ssize_t (*preadlinkat) (int, char const *, char *, size_t))",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/careadlinkat.h": {},
  "tar/tar-1.30/gnu/chdir-long.c": {
    "cdb_init": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static void\ncdb_init (struct cd_buf *cdb)\n{\n  cdb->fd = AT_FDCWD;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_fchdir": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static int\ncdb_fchdir (struct cd_buf const *cdb)\n{\n  return fchdir (cdb->fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cdb_free": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static void\ncdb_free (struct cd_buf const *cdb)\n{\n  if (0 <= cdb->fd)\n    {\n      bool close_fail = close (cdb->fd);\n      assure (! close_fail);\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_advance_fd": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\ncdb_advance_fd (struct cd_buf *cdb, char const *dir)\n{\n  int new_fd = openat (cdb->fd, dir,\n                       O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n  if (new_fd < 0)\n    return -1;\n\n  cdb_free (cdb);\n  cdb->fd = new_fd;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_non_slash": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static char * _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)\n{\n  size_t n_slash = strspn (s, \"/\");\n  return (char *) s + n_slash;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "* _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "chdir_long": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nchdir_long (char *dir)\n{\n  int e = chdir (dir);\n  if (e == 0 || errno != ENAMETOOLONG)\n    return e;\n\n  {\n    size_t len = strlen (dir);\n    char *dir_end = dir + len;\n    struct cd_buf cdb;\n    size_t n_leading_slash;\n\n    cdb_init (&cdb);\n\n    /* If DIR is the empty string, then the chdir above\n       must have failed and set errno to ENOENT.  */\n    assure (0 < len);\n    assure (PATH_MAX <= len);\n\n    /* Count leading slashes.  */\n    n_leading_slash = strspn (dir, \"/\");\n\n    /* Handle any leading slashes as well as any name that matches\n       the regular expression, m!^//hostname[/]*! .  Handling this\n       prefix separately usually results in a single additional\n       cdb_advance_fd call, but it's worthwhile, since it makes the\n       code in the following loop cleaner.  */\n    if (n_leading_slash == 2)\n      {\n        int err;\n        /* Find next slash.\n           We already know that dir[2] is neither a slash nor '\\0'.  */\n        char *slash = memchr (dir + 3, '/', dir_end - (dir + 3));\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n        *slash = '\\0';\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n        dir = find_non_slash (slash + 1);\n      }\n    else if (n_leading_slash)\n      {\n        if (cdb_advance_fd (&cdb, \"/\") != 0)\n          goto Fail;\n        dir += n_leading_slash;\n      }\n\n    assure (*dir != '/');\n    assure (dir <= dir_end);\n\n    while (PATH_MAX <= dir_end - dir)\n      {\n        int err;\n        /* Find a slash that is PATH_MAX or fewer bytes away from dir.\n           I.e. see if there is a slash that will give us a name of\n           length PATH_MAX-1 or less.  */\n        char *slash = memrchr (dir, '/', PATH_MAX);\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n\n        *slash = '\\0';\n        assure (slash - dir < PATH_MAX);\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n\n        dir = find_non_slash (slash + 1);\n      }\n\n    if (dir < dir_end)\n      {\n        if (cdb_advance_fd (&cdb, dir) != 0)\n          goto Fail;\n      }\n\n    if (cdb_fchdir (&cdb) != 0)\n      goto Fail;\n\n    cdb_free (&cdb);\n    return 0;\n\n   Fail:\n    {\n      int saved_errno = errno;\n      cdb_free (&cdb);\n      errno = saved_errno;\n      return -1;\n    }\n  }\n}",
      "lines": 100,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *line = NULL;\n  size_t n = 0;\n  int len;\n\n  atexit (close_stdout);\n\n  len = getline (&line, &n, stdin);\n  if (len < 0)\n    {\n      int saved_errno = errno;\n      if (feof (stdin))\n        exit (0);\n\n      error (EXIT_FAILURE, saved_errno,\n             \"reading standard input\");\n    }\n  else if (len == 0)\n    exit (0);\n\n  if (line[len-1] == '\\n')\n    line[len-1] = '\\0';\n\n  if (chdir_long (line) != 0)\n    error (EXIT_FAILURE, errno,\n           \"chdir_long failed: %s\", line);\n\n  if (argc <= 1)\n    {\n      /* Using 'pwd' here makes sense only if it is a robust implementation,\n         like the one in coreutils after the 2004-04-19 changes.  */\n      char const *cmd = \"pwd\";\n      execlp (cmd, (char *) NULL);\n      error (EXIT_FAILURE, errno, \"%s\", cmd);\n    }\n\n  fclose (stdin);\n  fclose (stderr);\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/chdir-long.h": {},
  "tar/tar-1.30/gnu/chmodat.c": {},
  "tar/tar-1.30/gnu/chown.c": {
    "chown": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nchown (const char *file _GL_UNUSED, uid_t uid _GL_UNUSED,\n       gid_t gid _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_chown": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\nrpl_chown (const char *file, uid_t uid, gid_t gid)\n{\n  struct stat st;\n  bool stat_valid = false;\n  int result;\n\n# if CHOWN_CHANGE_TIME_BUG\n  if (gid != (gid_t) -1 || uid != (uid_t) -1)\n    {\n      if (stat (file, &st))\n        return -1;\n      stat_valid = true;\n    }\n# endif\n\n# if CHOWN_FAILS_TO_HONOR_ID_OF_NEGATIVE_ONE\n  if (gid == (gid_t) -1 || uid == (uid_t) -1)\n    {\n      /* Stat file to get id(s) that should remain unchanged.  */\n      if (!stat_valid && stat (file, &st))\n        return -1;\n      if (gid == (gid_t) -1)\n        gid = st.st_gid;\n      if (uid == (uid_t) -1)\n        uid = st.st_uid;\n    }\n# endif\n\n# if CHOWN_MODIFIES_SYMLINK\n  {\n    /* Handle the case in which the system-supplied chown function\n       does *not* follow symlinks.  Instead, it changes permissions\n       on the symlink itself.  To work around that, we open the\n       file (but this can fail due to lack of read or write permission) and\n       use fchown on the resulting descriptor.  */\n    int open_flags = O_NONBLOCK | O_NOCTTY;\n    int fd = open (file, O_RDONLY | open_flags);\n    if (0 <= fd\n        || (errno == EACCES\n            && 0 <= (fd = open (file, O_WRONLY | open_flags))))\n      {\n        int saved_errno;\n        bool fchown_socket_failure;\n\n        result = fchown (fd, uid, gid);\n        saved_errno = errno;\n\n        /* POSIX says fchown can fail with errno == EINVAL on sockets\n           and pipes, so fall back on chown in that case.  */\n        fchown_socket_failure =\n          (result != 0 && saved_errno == EINVAL\n           && fstat (fd, &st) == 0\n           && (S_ISFIFO (st.st_mode) || S_ISSOCK (st.st_mode)));\n\n        close (fd);\n\n        if (! fchown_socket_failure)\n          {\n            errno = saved_errno;\n            return result;\n          }\n      }\n    else if (errno != EACCES)\n      return -1;\n  }\n# endif\n\n# if CHOWN_TRAILING_SLASH_BUG\n  if (!stat_valid)\n    {\n      size_t len = strlen (file);\n      if (len && file[len - 1] == '/' && stat (file, &st))\n        return -1;\n    }\n# endif\n\n  result = chown (file, uid, gid);\n\n# if CHOWN_CHANGE_TIME_BUG\n  if (result == 0 && stat_valid\n      && (uid == st.st_uid || uid == (uid_t) -1)\n      && (gid == st.st_gid || gid == (gid_t) -1))\n    {\n      /* No change in ownership, but at least one argument was not -1,\n         so we are required to update ctime.  Since chown succeeded,\n         we assume that chmod will do likewise.  Fortunately, on all\n         known systems where a 'no-op' chown skips the ctime update, a\n         'no-op' chmod still does the trick.  */\n      result = chmod (file, st.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO\n                                          | S_ISUID | S_ISGID | S_ISVTX));\n    }\n# endif\n\n  return result;\n}",
      "lines": 96,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/chownat.c": {},
  "tar/tar-1.30/gnu/cloexec.c": {
    "set_cloexec_flag": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nset_cloexec_flag (int desc, bool value)\n{\n#ifdef F_SETFD\n\n  int flags = fcntl (desc, F_GETFD, 0);\n\n  if (0 <= flags)\n    {\n      int newflags = (value ? flags | FD_CLOEXEC : flags & ~FD_CLOEXEC);\n\n      if (flags == newflags\n          || fcntl (desc, F_SETFD, newflags) != -1)\n        return 0;\n    }\n\n  return -1;\n\n#else /* !F_SETFD */\n\n  /* Use dup2 to reject invalid file descriptors; the cloexec flag\n     will be unaffected.  */\n  if (desc < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (dup2 (desc, desc) < 0)\n    /* errno is EBADF here.  */\n    return -1;\n\n  /* There is nothing we can do on this kind of platform.  Punt.  */\n  return 0;\n#endif /* !F_SETFD */\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "dup_cloexec": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\ndup_cloexec (int fd)\n{\n  return fcntl (fd, F_DUPFD_CLOEXEC, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/cloexec.h": {},
  "tar/tar-1.30/gnu/close-stream.c": {
    "close_stream": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nclose_stream (FILE *stream)\n{\n  const bool some_pending = (__fpending (stream) != 0);\n  const bool prev_fail = (ferror (stream) != 0);\n  const bool fclose_fail = (fclose (stream) != 0);\n\n  /* Return an error indication if there was a previous failure or if\n     fclose failed, with one exception: ignore an fclose failure if\n     there was no previous error, no data remains to be flushed, and\n     fclose failed with EBADF.  That can happen when a program like cp\n     is invoked like this 'cp a b >&-' (i.e., with standard output\n     closed) and doesn't generate any output (hence no previous error\n     and nothing to be flushed).  */\n\n  if (prev_fail || (fclose_fail && (some_pending || errno != EBADF)))\n    {\n      if (! fclose_fail)\n        errno = 0;\n      return EOF;\n    }\n\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/close-stream.h": {},
  "tar/tar-1.30/gnu/close.c": {
    "close_nothrow": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "static int\nclose_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = close (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_close": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nrpl_close (int fd)\n{\n#if WINDOWS_SOCKETS\n  int retval = execute_all_close_hooks (close_nothrow, fd);\n#else\n  int retval = close_nothrow (fd);\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n\n  return retval;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/closedir.c": {
    "closedir": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nclosedir (DIR *dirp)\n{\n# if REPLACE_FCHDIR || REPLACE_DIRFD\n  int fd = dirfd (dirp);\n# endif\n  int retval;\n\n#if HAVE_CLOSEDIR\n# undef closedir\n\n  retval = closedir (dirp);\n\n# ifdef __KLIBC__\n  if (!retval)\n    _gl_unregister_dirp_fd (fd);\n# endif\n#else\n\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n  free (dirp);\n\n  retval = 0;\n\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n  return retval;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/closeout.c": {
    "close_stdout_set_file_name": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\nclose_stdout_set_file_name (const char *file)\n{\n  file_name = file;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "close_stdout_set_ignore_EPIPE": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\nclose_stdout_set_ignore_EPIPE (bool ignore)\n{\n  ignore_EPIPE = ignore;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "close_stdout": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\nclose_stdout (void)\n{\n  if (close_stream (stdout) != 0\n      && !(ignore_EPIPE && errno == EPIPE))\n    {\n      char const *write_error = _(\"write error\");\n      if (file_name)\n        error (0, errno, \"%s: %s\", quotearg_colon (file_name),\n               write_error);\n      else\n        error (0, errno, \"%s\", write_error);\n\n      _exit (exit_failure);\n    }\n\n  /* Close stderr only if not sanitizing, as sanitizers may report to\n     stderr after this function returns.  */\n  if (!SANITIZE_ADDRESS && close_stream (stderr) != 0)\n    _exit (exit_failure);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/closeout.h": {},
  "tar/tar-1.30/gnu/dirent--.h": {},
  "tar/tar-1.30/gnu/dirent-private.h": {},
  "tar/tar-1.30/gnu/dirent-safer.h": {},
  "tar/tar-1.30/gnu/dirent.in.h": {
    "dirfd": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        171,
        58
      ],
      "content": "static inline int (dirfd) (DIR *dp) { return dirfd (dp); }",
      "lines": 1,
      "depth": 6,
      "decorators": null
    }
  },
  "tar/tar-1.30/gnu/dirfd.c": {
    "_gl_register_dirp_fd": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\n_gl_register_dirp_fd (int fd, DIR *dirp)\n{\n  struct dirp_fd_list *new_dirp_fd = malloc (sizeof *new_dirp_fd);\n  if (!new_dirp_fd)\n    return -1;\n\n  new_dirp_fd->dirp = dirp;\n  new_dirp_fd->fd = fd;\n  new_dirp_fd->next = dirp_fd_start;\n\n  dirp_fd_start = new_dirp_fd;\n\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_gl_unregister_dirp_fd": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\n_gl_unregister_dirp_fd (int fd)\n{\n  struct dirp_fd_list *dirp_fd;\n  struct dirp_fd_list *dirp_fd_prev;\n\n  for (dirp_fd_prev = NULL, dirp_fd = dirp_fd_start; dirp_fd;\n       dirp_fd_prev = dirp_fd, dirp_fd = dirp_fd->next)\n    {\n      if (dirp_fd->fd == fd)\n        {\n          if (dirp_fd_prev)\n            dirp_fd_prev->next = dirp_fd->next;\n          else  /* dirp_fd == dirp_fd_start */\n            dirp_fd_start = dirp_fd_start->next;\n\n          close (fd);\n          free (dirp_fd);\n          break;\n        }\n    }\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "dirfd": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\ndirfd (DIR *dir_p)\n{\n  int fd = DIR_TO_FD (dir_p);\n  if (fd == -1)\n#ifndef __KLIBC__\n    errno = ENOTSUP;\n#else\n    {\n      struct dirp_fd_list *dirp_fd;\n\n      for (dirp_fd = dirp_fd_start; dirp_fd; dirp_fd = dirp_fd->next)\n        if (dirp_fd->dirp == dir_p)\n          return dirp_fd->fd;\n\n      errno = EINVAL;\n    }\n#endif\n\n  return fd;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/dirname.c": {
    "dir_name": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\ndir_name (char const *file)\n{\n  char *result = mdir_name (file);\n  if (!result)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\ndir_name (char const *file)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/dirname.h": {},
  "tar/tar-1.30/gnu/dosname.h": {},
  "tar/tar-1.30/gnu/dup-safer-flag.c": {
    "dup_safer_flag": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\ndup_safer_flag (int fd, int flag)\n{\n  return fcntl (fd, (flag & O_CLOEXEC) ? F_DUPFD_CLOEXEC : F_DUPFD,\n                STDERR_FILENO + 1);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/dup-safer.c": {
    "dup_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\ndup_safer (int fd)\n{\n  return fcntl (fd, F_DUPFD, STDERR_FILENO + 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/dup.c": {
    "dup_nothrow": [
      {
        "start_point": [
          31,
          0
        ],
        "end_point": [
          39,
          5
        ],
        "content": "static int\ndup_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = dup (fd);\n    }",
        "lines": 9,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          55,
          0
        ],
        "end_point": [
          73,
          1
        ],
        "content": "static int\ndup_nothrow (int fd)\n{\n  int dupfd;\n  struct stat sbuf;\n\n  dupfd = dup (fd);\n  if (dupfd == -1 && errno == ENOTSUP \\\n      && !fstat (fd, &sbuf) && S_ISDIR (sbuf.st_mode))\n    {\n      char path[_MAX_PATH];\n\n      /* Get a path from fd */\n      if (!__libc_Back_ioFHToPath (fd, path, sizeof (path)))\n        dupfd = open (path, O_RDONLY);\n    }\n\n  return dupfd;\n}",
        "lines": 19,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "rpl_dup": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nrpl_dup (int fd)\n{\n  int result = dup_nothrow (fd);\n#if REPLACE_FCHDIR\n  if (result >= 0)\n    result = _gl_register_dup (fd, result);\n#endif\n  return result;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/dup2.c": {
    "dup2_nothrow": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        57,
        5
      ],
      "content": "static int\ndup2_nothrow (int fd, int desired_fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = dup2 (fd, desired_fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ms_windows_dup2": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nms_windows_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n  /* If fd is closed, mingw hangs on dup2 (fd, fd).  If fd is open,\n     dup2 (fd, fd) returns 0, but all further attempts to use fd in\n     future dup2 calls will hang.  */\n  if (fd == desired_fd)\n    {\n      if ((HANDLE) _get_osfhandle (fd) == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n      return fd;\n    }\n\n  /* Wine 1.0.1 return 0 when desired_fd is negative but not -1:\n     https://bugs.winehq.org/show_bug.cgi?id=21289 */\n  if (desired_fd < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  result = dup2_nothrow (fd, desired_fd);\n\n  if (result == 0)\n    result = desired_fd;\n\n  return result;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_dup2dirfd": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static int\nklibc_dup2dirfd (int fd, int desired_fd)\n{\n  int tempfd;\n  int dupfd;\n\n  tempfd = open (\"NUL\", O_RDONLY);\n  if (tempfd == -1)\n    return -1;\n\n  if (tempfd == desired_fd)\n    {\n      close (tempfd);\n\n      char path[_MAX_PATH];\n      if (__libc_Back_ioFHToPath (fd, path, sizeof (path)))\n        return -1;\n\n      return open(path, O_RDONLY);\n    }\n\n  dupfd = klibc_dup2dirfd (fd, desired_fd);\n\n  close (tempfd);\n\n  return dupfd;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_dup2": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static int\nklibc_dup2 (int fd, int desired_fd)\n{\n  int dupfd;\n  struct stat sbuf;\n\n  dupfd = dup2 (fd, desired_fd);\n  if (dupfd == -1 && errno == ENOTSUP \\\n      && !fstat (fd, &sbuf) && S_ISDIR (sbuf.st_mode))\n    {\n      close (desired_fd);\n\n      return klibc_dup2dirfd (fd, desired_fd);\n    }\n\n  return dupfd;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup2": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nrpl_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n# ifdef F_GETFL\n  /* On Linux kernels 2.6.26-2.6.29, dup2 (fd, fd) returns -EBADF.\n     On Cygwin 1.5.x, dup2 (1, 1) returns 0.\n     On Cygwin 1.7.17, dup2 (1, -1) dumps core.\n     On Cygwin 1.7.25, dup2 (1, 256) can dump core.\n     On Haiku, dup2 (fd, fd) mistakenly clears FD_CLOEXEC.  */\n#  if HAVE_SETDTABLESIZE\n  setdtablesize (desired_fd + 1);\n#  endif\n  if (desired_fd < 0)\n    fd = desired_fd;\n  if (fd == desired_fd)\n    return fcntl (fd, F_GETFL) == -1 ? -1 : fd;\n# endif\n\n  result = dup2 (fd, desired_fd);\n\n  /* Correct an errno value on FreeBSD 6.1 and Cygwin 1.5.x.  */\n  if (result == -1 && errno == EMFILE)\n    errno = EBADF;\n# if REPLACE_FCHDIR\n  if (fd != desired_fd && result != -1)\n    result = _gl_register_dup (fd, result);\n# endif\n  return result;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dupfd": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static int\ndupfd (int fd, int desired_fd)\n{\n  int duplicated_fd = dup (fd);\n  if (duplicated_fd < 0 || duplicated_fd == desired_fd)\n    return duplicated_fd;\n  else\n    {\n      int r = dupfd (fd, desired_fd);\n      int e = errno;\n      close (duplicated_fd);\n      errno = e;\n      return r;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup2": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "int\ndup2 (int fd, int desired_fd)\n{\n  int result = fcntl (fd, F_GETFL) < 0 ? -1 : fd;\n  if (result == -1 || fd == desired_fd)\n    return result;\n  close (desired_fd);\n# ifdef F_DUPFD\n  result = fcntl (fd, F_DUPFD, desired_fd);\n#  if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (fd, result);\n#  endif\n# else\n  result = dupfd (fd, desired_fd);\n# endif\n  if (result == -1 && (errno == EMFILE || errno == EINVAL))\n    errno = EBADF;\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/errno.in.h": {},
  "tar/tar-1.30/gnu/error.c": {
    "is_open": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if _LIBC || GNULIB_STRERROR_R_POSIX || defined HAVE_STRERROR_R\n  char errbuf[1024];\n# if _LIBC || (!GNULIB_STRERROR_R_POSIX && STRERROR_R_CHAR_P)\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        205,
        42
      ],
      "end_point": [
        286,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 82,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/error.h": {},
  "tar/tar-1.30/gnu/euidaccess.c": {
    "euidaccess": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int\neuidaccess (const char *file, int mode)\n{\n#if HAVE_FACCESSAT                   /* glibc, AIX 7, Solaris 11, Cygwin 1.7 */\n  return faccessat (AT_FDCWD, file, mode, AT_EACCESS);\n#elif defined EFF_ONLY_OK               /* IRIX, OSF/1, Interix */\n  return access (file, mode | EFF_ONLY_OK);\n#elif defined ACC_SELF                  /* AIX */\n  return accessx (file, mode, ACC_SELF);\n#elif HAVE_EACCESS                      /* FreeBSD */\n  return eaccess (file, mode);\n#else       /* Mac OS X, NetBSD, OpenBSD, HP-UX, Solaris, Cygwin, mingw, BeOS */\n\n  uid_t uid = getuid ();\n  gid_t gid = getgid ();\n  uid_t euid = geteuid ();\n  gid_t egid = getegid ();\n  struct stat stats;\n\n# if HAVE_DECL_SETREGID && PREFER_NONREENTRANT_EUIDACCESS\n\n  /* Define PREFER_NONREENTRANT_EUIDACCESS if you prefer euidaccess to\n     return the correct result even if this would make it\n     nonreentrant.  Define this only if your entire application is\n     safe even if the uid or gid might temporarily change.  If your\n     application uses signal handlers or threads it is probably not\n     safe.  */\n\n  if (mode == F_OK)\n    return stat (file, &stats);\n  else\n    {\n      int result;\n      int saved_errno;\n\n      if (uid != euid)\n        setreuid (euid, uid);\n      if (gid != egid)\n        setregid (egid, gid);\n\n      result = access (file, mode);\n      saved_errno = errno;\n\n      /* Restore them.  */\n      if (uid != euid)\n        setreuid (uid, euid);\n      if (gid != egid)\n        setregid (gid, egid);\n\n      errno = saved_errno;\n      return result;\n    }\n\n# else\n\n  /* The following code assumes the traditional Unix model, and is not\n     correct on systems that have ACLs or the like.  However, it's\n     better than nothing, and it is reentrant.  */\n\n  unsigned int granted;\n  if (uid == euid && gid == egid)\n    /* If we are not set-uid or set-gid, access does the same.  */\n    return access (file, mode);\n\n  if (stat (file, &stats) != 0)\n    return -1;\n\n  /* The super-user can read and write any file, and execute any file\n     that anyone can execute.  */\n  if (euid == ROOT_UID\n      && ((mode & X_OK) == 0\n          || (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))\n    return 0;\n\n  /* Convert the mode to traditional form, clearing any bogus bits.  */\n  if (R_OK == 4 && W_OK == 2 && X_OK == 1 && F_OK == 0)\n    mode &= 7;\n  else\n    mode = ((mode & R_OK ? 4 : 0)\n            + (mode & W_OK ? 2 : 0)\n            + (mode & X_OK ? 1 : 0));\n\n  if (mode == 0)\n    return 0;                   /* The file exists.  */\n\n  /* Convert the file's permission bits to traditional form.  */\n  if (S_IRUSR == (4 << 6) && S_IWUSR == (2 << 6) && S_IXUSR == (1 << 6)\n      && S_IRGRP == (4 << 3) && S_IWGRP == (2 << 3) && S_IXGRP == (1 << 3)\n      && S_IROTH == (4 << 0) && S_IWOTH == (2 << 0) && S_IXOTH == (1 << 0))\n    granted = stats.st_mode;\n  else\n    granted = ((stats.st_mode & S_IRUSR ? 4 << 6 : 0)\n               + (stats.st_mode & S_IWUSR ? 2 << 6 : 0)\n               + (stats.st_mode & S_IXUSR ? 1 << 6 : 0)\n               + (stats.st_mode & S_IRGRP ? 4 << 3 : 0)\n               + (stats.st_mode & S_IWGRP ? 2 << 3 : 0)\n               + (stats.st_mode & S_IXGRP ? 1 << 3 : 0)\n               + (stats.st_mode & S_IROTH ? 4 << 0 : 0)\n               + (stats.st_mode & S_IWOTH ? 2 << 0 : 0)\n               + (stats.st_mode & S_IXOTH ? 1 << 0 : 0));\n\n  if (euid == stats.st_uid)\n    granted >>= 6;\n  else if (egid == stats.st_gid || group_member (stats.st_gid))\n    granted >>= 3;\n\n  if ((mode & ~granted) == 0)\n    return 0;\n  __set_errno (EACCESS);\n  return -1;\n\n# endif\n#endif\n}",
      "lines": 114,
      "depth": 26,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *file;\n  int mode;\n  int err;\n\n  if (argc < 3)\n    abort ();\n  file = argv[1];\n  mode = atoi (argv[2]);\n\n  err = euidaccess (file, mode);\n  printf (\"%d\\n\", err);\n  if (err != 0)\n    error (0, errno, \"%s\", file);\n  exit (0);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/exclude.c": {
    "exclude_add_pattern_buffer": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void\nexclude_add_pattern_buffer (struct exclude *ex, char *buf)\n{\n  struct pattern_buffer *pbuf = xmalloc (sizeof *pbuf);\n  pbuf->base = buf;\n  pbuf->next = ex->patbuf;\n  ex->patbuf = pbuf;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fnmatch_pattern_has_wildcards": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "bool\nfnmatch_pattern_has_wildcards (const char *str, int options)\n{\n  while (1)\n    {\n      switch (*str++)\n        {\n\tcase '.':\n\tcase '{':\n\tcase '}':\n\tcase '(':\n\tcase ')':\n\t  if (options & EXCLUDE_REGEX)\n\t    return true;\n\t  break;\n\n        case '\\\\':\n\t  if (options & EXCLUDE_REGEX)\n\t    continue;\n\t  else\n\t    str += ! (options & FNM_NOESCAPE) && *str;\n          break;\n\n        case '+': case '@': case '!':\n          if (options & FNM_EXTMATCH && *str == '(')\n            return true;\n          break;\n\n        case '?': case '*': case '[':\n          return true;\n\n        case '\\0':\n          return false;\n        }\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "unescape_pattern": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static void\nunescape_pattern (char *str)\n{\n  char const *q = str;\n  do\n    q += *q == '\\\\' && q[1];\n  while ((*str++ = *q++));\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "new_exclude": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "struct exclude *\nnew_exclude (void)\n{\n  return xzalloc (sizeof *new_exclude ());\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "struct exclude",
        "struct",
        "exclude",
        "*\nnew_exclude (void)",
        "*"
      ]
    },
    "string_hasher": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static size_t\nstring_hasher (void const *data, size_t n_buckets)\n{\n  char const *p = data;\n  return hash_string (p, n_buckets);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "string_hasher_ci": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static size_t\nstring_hasher_ci (void const *data, size_t n_buckets)\n{\n  char const *p = data;\n  mbui_iterator_t iter;\n  size_t value = 0;\n\n  for (mbui_init (iter, p); mbui_avail (iter); mbui_advance (iter))\n    {\n      mbchar_t m = mbui_cur (iter);\n      wchar_t wc;\n\n      if (m.wc_valid)\n        wc = towlower (m.wc);\n      else\n        wc = *m.ptr;\n\n      value = (value * 31 + wc) % n_buckets;\n    }\n\n  return value;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "string_compare": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static bool\nstring_compare (void const *data1, void const *data2)\n{\n  char const *p1 = data1;\n  char const *p2 = data2;\n  return strcmp (p1, p2) == 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "string_compare_ci": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static bool\nstring_compare_ci (void const *data1, void const *data2)\n{\n  char const *p1 = data1;\n  char const *p2 = data2;\n  return mbscasecmp (p1, p2) == 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "string_free": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static void\nstring_free (void *data)\n{\n  free (data);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "new_exclude_segment": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static void\nnew_exclude_segment (struct exclude *ex, enum exclude_type type, int options)\n{\n  struct exclude_segment *sp = xzalloc (sizeof (struct exclude_segment));\n  sp->type = type;\n  sp->options = options;\n  switch (type)\n    {\n    case exclude_pattern:\n      break;\n\n    case exclude_hash:\n      sp->v.table = hash_initialize (0, NULL,\n                                     (options & FNM_CASEFOLD) ?\n                                       string_hasher_ci\n                                       : string_hasher,\n                                     (options & FNM_CASEFOLD) ?\n                                       string_compare_ci\n                                       : string_compare,\n                                     string_free);\n      break;\n    }\n  sp->next = ex->head;\n  ex->head = sp;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_exclude_segment": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "static void\nfree_exclude_segment (struct exclude_segment *seg)\n{\n  size_t i;\n\n  switch (seg->type)\n    {\n    case exclude_pattern:\n      for (i = 0; i < seg->v.pat.exclude_count; i++)\n\t{\n\t  if (seg->v.pat.exclude[i].options & EXCLUDE_REGEX)\n\t    regfree (&seg->v.pat.exclude[i].v.re);\n\t}\n      free (seg->v.pat.exclude);\n      break;\n\n    case exclude_hash:\n      hash_free (seg->v.table);\n      break;\n    }\n  free (seg);\n}",
      "lines": 22,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_exclude": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "void\nfree_exclude (struct exclude *ex)\n{\n  struct exclude_segment *seg;\n  struct pattern_buffer *pbuf;\n\n  for (seg = ex->head; seg; )\n    {\n      struct exclude_segment *next = seg->next;\n      free_exclude_segment (seg);\n      seg = next;\n    }\n\n  for (pbuf = ex->patbuf; pbuf; )\n    {\n      struct pattern_buffer *next = pbuf->next;\n      free (pbuf->base);\n      free (pbuf);\n      pbuf = next;\n    }\n\n  free (ex);\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fnmatch_no_wildcards": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "static int\nfnmatch_no_wildcards (char const *pattern, char const *f, int options)\n{\n  if (! (options & FNM_LEADING_DIR))\n    return ((options & FNM_CASEFOLD)\n            ? mbscasecmp (pattern, f)\n            : strcmp (pattern, f));\n  else if (! (options & FNM_CASEFOLD))\n    {\n      size_t patlen = strlen (pattern);\n      int r = strncmp (pattern, f, patlen);\n      if (! r)\n        {\n          r = f[patlen];\n          if (r == '/')\n            r = 0;\n        }\n      return r;\n    }\n  else\n    {\n      /* Walk through a copy of F, seeing whether P matches any prefix\n         of F.\n\n         FIXME: This is an O(N**2) algorithm; it should be O(N).\n         Also, the copy should not be necessary.  However, fixing this\n         will probably involve a change to the mbs* API.  */\n\n      char *fcopy = xstrdup (f);\n      char *p;\n      int r;\n      for (p = fcopy; ; *p++ = '/')\n        {\n          p = strchr (p, '/');\n          if (p)\n            *p = '\\0';\n          r = mbscasecmp (pattern, fcopy);\n          if (!p || r <= 0)\n            break;\n        }\n      free (fcopy);\n      return r;\n    }\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "exclude_fnmatch": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "bool\nexclude_fnmatch (char const *pattern, char const *f, int options)\n{\n  int (*matcher) (char const *, char const *, int) =\n    (options & EXCLUDE_WILDCARDS\n     ? fnmatch\n     : fnmatch_no_wildcards);\n  bool matched = ((*matcher) (pattern, f, options) == 0);\n  char const *p;\n\n  if (! (options & EXCLUDE_ANCHORED))\n    for (p = f; *p && ! matched; p++)\n      if (*p == '/' && p[1] != '/')\n\tmatched = ((*matcher) (pattern, p + 1, options) == 0);\n\n  return matched;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "exclude_patopts": {
      "start_point": [
        394,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "static bool\nexclude_patopts (struct patopts const *opts, char const *f)\n{\n  int options = opts->options;\n\n  return (options & EXCLUDE_REGEX)\n          ? regexec (&opts->v.re, f, 0, NULL, 0) == 0\n          : exclude_fnmatch (opts->v.pattern, f, options);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "file_pattern_matches": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "static bool\nfile_pattern_matches (struct exclude_segment const *seg, char const *f)\n{\n  size_t exclude_count = seg->v.pat.exclude_count;\n  struct patopts const *exclude = seg->v.pat.exclude;\n  size_t i;\n\n  for (i = 0; i < exclude_count; i++)\n    {\n      if (exclude_patopts (exclude + i, f))\n        return true;\n    }\n  return false;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "file_name_matches": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        464,
        1
      ],
      "content": "static bool\nfile_name_matches (struct exclude_segment const *seg, char const *f,\n                   char *buffer)\n{\n  int options = seg->options;\n  Hash_table *table = seg->v.table;\n\n  do\n    {\n      /* initialize the pattern */\n      strcpy (buffer, f);\n\n      while (1)\n        {\n          if (hash_lookup (table, buffer))\n            return true;\n          if (options & FNM_LEADING_DIR)\n            {\n              char *p = strrchr (buffer, '/');\n              if (p)\n                {\n                  *p = 0;\n                  continue;\n                }\n            }\n          break;\n        }\n\n      if (!(options & EXCLUDE_ANCHORED))\n        {\n          f = strchr (f, '/');\n          if (f)\n            f++;\n        }\n      else\n        break;\n    }\n  while (f);\n\n  return false;\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "excluded_file_name": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "bool\nexcluded_file_name (struct exclude const *ex, char const *f)\n{\n  struct exclude_segment *seg;\n  bool invert = false;\n  char *filename = NULL;\n\n  /* If no patterns are given, the default is to include.  */\n  if (!ex->head)\n    return false;\n\n  /* Scan through the segments, reporting the status of the first match.\n     The segments are in reverse order, so this reports the status of\n     the last match in the original option list.  */\n  for (seg = ex->head; ; seg = seg->next)\n    {\n      if (seg->type == exclude_hash)\n        {\n          if (!filename)\n            filename = xmalloc (strlen (f) + 1);\n          if (file_name_matches (seg, f, filename))\n            break;\n        }\n      else\n        {\n          if (file_pattern_matches (seg, f))\n            break;\n        }\n\n      if (! seg->next)\n        {\n          /* If patterns are given but none match, the default is the\n             opposite of the last segment (i.e., the first in the\n             original option list).  For example, in the command\n             'grep -r --exclude=\"a*\" --include=\"*b\" pat dir', the\n             first option is --exclude so any file name matching\n             neither a* nor *b is included.  */\n          invert = true;\n          break;\n        }\n    }\n\n  free (filename);\n  return invert ^ ! (seg->options & EXCLUDE_INCLUDE);\n}",
      "lines": 45,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "add_exclude": {
      "start_point": [
        516,
        0
      ],
      "end_point": [
        602,
        1
      ],
      "content": "void\nadd_exclude (struct exclude *ex, char const *pattern, int options)\n{\n  struct exclude_segment *seg;\n  struct exclude_pattern *pat;\n  struct patopts *patopts;\n\n  if ((options & (EXCLUDE_REGEX|EXCLUDE_WILDCARDS))\n      && fnmatch_pattern_has_wildcards (pattern, options))\n    {\n      if (! (ex->head && ex->head->type == exclude_pattern\n\t     && ((ex->head->options & EXCLUDE_INCLUDE)\n\t\t == (options & EXCLUDE_INCLUDE))))\n\tnew_exclude_segment (ex, exclude_pattern, options);\n\n      seg = ex->head;\n\n      pat = &seg->v.pat;\n      if (pat->exclude_count == pat->exclude_alloc)\n        pat->exclude = x2nrealloc (pat->exclude, &pat->exclude_alloc,\n                                   sizeof *pat->exclude);\n      patopts = &pat->exclude[pat->exclude_count++];\n\n      patopts->options = options;\n      if (options & EXCLUDE_REGEX)\n\t{\n\t  int rc;\n\t  int cflags = REG_NOSUB|REG_EXTENDED|\n\t               ((options & FNM_CASEFOLD) ? REG_ICASE : 0);\n\n\t  if (options & FNM_LEADING_DIR)\n\t    {\n\t      char *tmp;\n\t      size_t len = strlen (pattern);\n\n\t      while (len > 0 && ISSLASH (pattern[len-1]))\n\t\t--len;\n\n\t      if (len == 0)\n\t\trc = 1;\n\t      else\n\t\t{\n\t\t  tmp = xmalloc (len + 7);\n\t\t  memcpy (tmp, pattern, len);\n\t\t  strcpy (tmp + len, \"(/.*)?\");\n\t\t  rc = regcomp (&patopts->v.re, tmp, cflags);\n\t\t  free (tmp);\n\t\t}\n\t    }\n\t  else\n\t    rc = regcomp (&patopts->v.re, pattern, cflags);\n\n\t  if (rc)\n\t    {\n\t      pat->exclude_count--;\n\t      return;\n\t    }\n\t}\n      else\n\t{\n\t  if (options & EXCLUDE_ALLOC)\n\t    {\n\t      pattern = xstrdup (pattern);\n\t      exclude_add_pattern_buffer (ex, (char*) pattern);\n\t    }\n\t  patopts->v.pattern = pattern;\n\t}\n    }\n  else\n    {\n      char *str, *p;\n      int exclude_hash_flags = (EXCLUDE_INCLUDE | EXCLUDE_ANCHORED\n                                | FNM_LEADING_DIR | FNM_CASEFOLD);\n      if (! (ex->head && ex->head->type == exclude_hash\n             && ((ex->head->options & exclude_hash_flags)\n                 == (options & exclude_hash_flags))))\n        new_exclude_segment (ex, exclude_hash, options);\n      seg = ex->head;\n\n      str = xstrdup (pattern);\n      if ((options & (EXCLUDE_WILDCARDS | FNM_NOESCAPE)) == EXCLUDE_WILDCARDS)\n        unescape_pattern (str);\n      p = hash_insert (seg->v.table, str);\n      if (p != str)\n        free (str);\n    }\n}",
      "lines": 87,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "add_exclude_fp": {
      "start_point": [
        609,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "int\nadd_exclude_fp (void (*add_func) (struct exclude *, char const *, int, void *),\n\t\tstruct exclude *ex, FILE *fp, int options,\n\t\tchar line_end,\n\t\tvoid *data)\n{\n  char *buf = NULL;\n  char *p;\n  char *pattern;\n  char const *lim;\n  size_t buf_alloc = 0;\n  size_t buf_count = 0;\n  int c;\n  int e = 0;\n\n  while ((c = getc (fp)) != EOF)\n    {\n      if (buf_count == buf_alloc)\n        buf = x2realloc (buf, &buf_alloc);\n      buf[buf_count++] = c;\n    }\n\n  if (ferror (fp))\n    e = errno;\n\n  buf = xrealloc (buf, buf_count + 1);\n  buf[buf_count] = line_end;\n  lim = buf + buf_count + ! (buf_count == 0 || buf[buf_count - 1] == line_end);\n\n  exclude_add_pattern_buffer (ex, buf);\n\n  pattern = buf;\n\n  for (p = buf; p < lim; p++)\n    if (*p == line_end)\n      {\n        char *pattern_end = p;\n\n        if (isspace ((unsigned char) line_end))\n          {\n            for (; ; pattern_end--)\n              if (pattern_end == pattern)\n                goto next_pattern;\n              else if (! isspace ((unsigned char) pattern_end[-1]))\n                break;\n          }\n\n        *pattern_end = '\\0';\n        (*add_func) (ex, pattern, options, data);\n\n      next_pattern:\n        pattern = p + 1;\n      }\n\n  errno = e;\n  return e ? -1 : 0;\n}",
      "lines": 57,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "call_addfn": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        672,
        1
      ],
      "content": "static void\ncall_addfn (struct exclude *ex, char const *pattern, int options, void *data)\n{\n  void (**addfnptr) (struct exclude *, char const *, int) = data;\n  (*addfnptr) (ex, pattern, options);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_exclude_file": {
      "start_point": [
        674,
        0
      ],
      "end_point": [
        694,
        1
      ],
      "content": "int\nadd_exclude_file (void (*add_func) (struct exclude *, char const *, int),\n\t\t  struct exclude *ex, char const *file_name, int options,\n\t\t  char line_end)\n{\n  bool use_stdin = file_name[0] == '-' && !file_name[1];\n  FILE *in;\n  int rc = 0;\n\n  if (use_stdin)\n    in = stdin;\n  else if (! (in = fopen (file_name, \"r\")))\n    return -1;\n\n  rc = add_exclude_fp (call_addfn, ex, in, options, line_end, &add_func);\n\n  if (!use_stdin && fclose (in) != 0)\n    rc = -1;\n\n  return rc;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/exclude.h": {},
  "tar/tar-1.30/gnu/exitfail.c": {},
  "tar/tar-1.30/gnu/exitfail.h": {},
  "tar/tar-1.30/gnu/faccessat.c": {
    "orig_faccessat": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\norig_faccessat (int fd, char const *name, int mode, int flag)\n{\n  return faccessat (fd, name, mode, flag);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_faccessat": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nrpl_faccessat (int fd, char const *file, int mode, int flag)\n{\n  int result = orig_faccessat (fd, file, mode, flag);\n\n  if (result == 0 && file[strlen (file) - 1] == '/')\n    {\n      struct stat st;\n      result = fstatat (fd, file, &st, 0);\n      if (result == 0 && !S_ISDIR (st.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n\n  return result;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fchdir.c": {
    "ensure_dirs_slot": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static bool\nensure_dirs_slot (size_t fd)\n{\n  if (fd < dirs_allocated)\n    free (dirs[fd].name);\n  else\n    {\n      size_t new_allocated;\n      dir_info_t *new_dirs;\n\n      new_allocated = 2 * dirs_allocated + 1;\n      if (new_allocated <= fd)\n        new_allocated = fd + 1;\n      new_dirs =\n        (dirs != NULL\n         ? (dir_info_t *) realloc (dirs, new_allocated * sizeof *dirs)\n         : (dir_info_t *) malloc (new_allocated * sizeof *dirs));\n      if (new_dirs == NULL)\n        return false;\n      memset (new_dirs + dirs_allocated, 0,\n              (new_allocated - dirs_allocated) * sizeof *dirs);\n      dirs = new_dirs;\n      dirs_allocated = new_allocated;\n    }\n  return true;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_name": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static char *\nget_name (char const *dir)\n{\n  char *cwd;\n  char *result;\n  int saved_errno;\n\n  if (IS_ABSOLUTE_FILE_NAME (dir))\n    return strdup (dir);\n\n  /* We often encounter \".\"; treat it as a special case.  */\n  cwd = getcwd (NULL, 0);\n  if (!cwd || (dir[0] == '.' && dir[1] == '\\0'))\n    return cwd;\n\n  result = mfile_name_concat (cwd, dir, NULL);\n  saved_errno = errno;\n  free (cwd);\n  errno = saved_errno;\n  return result;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_name (char const *dir)",
        "*"
      ]
    },
    "_gl_unregister_fd": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\n_gl_unregister_fd (int fd)\n{\n  if (fd >= 0 && fd < dirs_allocated)\n    {\n      free (dirs[fd].name);\n      dirs[fd].name = NULL;\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_gl_register_fd": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\n_gl_register_fd (int fd, const char *filename)\n{\n  struct stat statbuf;\n\n  assure (0 <= fd);\n  if (REPLACE_OPEN_DIRECTORY\n      || (fstat (fd, &statbuf) == 0 && S_ISDIR (statbuf.st_mode)))\n    {\n      if (!ensure_dirs_slot (fd)\n          || (dirs[fd].name = get_name (filename)) == NULL)\n        {\n          int saved_errno = errno;\n          close (fd);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n  return fd;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gl_register_dup": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "int\n_gl_register_dup (int oldfd, int newfd)\n{\n  assure (0 <= oldfd && 0 <= newfd && oldfd != newfd);\n  if (oldfd < dirs_allocated && dirs[oldfd].name)\n    {\n      /* Duplicated a directory; must ensure newfd is allocated.  */\n      if (!ensure_dirs_slot (newfd)\n          || (dirs[newfd].name = strdup (dirs[oldfd].name)) == NULL)\n        {\n          int saved_errno = errno;\n          close (newfd);\n          errno = saved_errno;\n          newfd = -1;\n        }\n    }\n  else if (newfd < dirs_allocated)\n    {\n      /* Duplicated a non-directory; ensure newfd is cleared.  */\n      free (dirs[newfd].name);\n      dirs[newfd].name = NULL;\n    }\n  return newfd;\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_gl_directory_name": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "const char *\n_gl_directory_name (int fd)\n{\n  if (0 <= fd && fd < dirs_allocated && dirs[fd].name != NULL)\n    return dirs[fd].name;\n  /* At this point, fd is either invalid, or open but not a directory.\n     If dup2 fails, errno is correctly EBADF.  */\n  if (0 <= fd)\n    {\n      if (dup2 (fd, fd) == fd)\n        errno = ENOTDIR;\n    }\n  else\n    errno = EBADF;\n  return NULL;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_gl_directory_name (int fd)",
        "*"
      ]
    },
    "fchdir": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nfchdir (int fd)\n{\n  const char *name = _gl_directory_name (fd);\n  return name ? chdir (name) : -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fchmodat.c": {
    "lchmod": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static int\nlchmod (char const *f _GL_UNUSED, mode_t m _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fchown-stub.c": {
    "fchown": {
      "start_point": [
        10,
        0
      ],
      "end_point": [
        15,
        1
      ],
      "content": "int\nfchown (int fd, uid_t uid, gid_t gid)\n{\n  errno = EPERM;\n  return -1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fchownat.c": {
    "rpl_fchownat": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "int\nrpl_fchownat (int fd, char const *file, uid_t owner, gid_t group, int flag)\n{\n# if FCHOWNAT_NOFOLLOW_BUG\n  if (flag == AT_SYMLINK_NOFOLLOW)\n    return local_lchownat (fd, file, owner, group);\n# endif\n# if FCHOWNAT_EMPTY_FILENAME_BUG\n  if (file[0] == '\\0')\n    {\n      errno = ENOENT;\n      return -1;\n    }\n# endif\n# if CHOWN_TRAILING_SLASH_BUG\n  {\n    size_t len = strlen (file);\n    struct stat st;\n    if (len && file[len - 1] == '/')\n      {\n        if (statat (fd, file, &st))\n          return -1;\n        if (flag == AT_SYMLINK_NOFOLLOW)\n          return fchownat (fd, file, owner, group, 0);\n      }\n  }\n# endif\n  return fchownat (fd, file, owner, group, flag);\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fcntl.c": {
    "dupfd": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static int\ndupfd (int oldfd, int newfd, int flags)\n{\n  /* Mingw has no way to create an arbitrary fd.  Iterate until all\n     file descriptors less than newfd are filled up.  */\n  HANDLE curr_process = GetCurrentProcess ();\n  HANDLE old_handle = (HANDLE) _get_osfhandle (oldfd);\n  unsigned char fds_to_close[OPEN_MAX_MAX / CHAR_BIT];\n  unsigned int fds_to_close_bound = 0;\n  int result;\n  BOOL inherit = flags & O_CLOEXEC ? FALSE : TRUE;\n  int mode;\n\n  if (newfd < 0 || getdtablesize () <= newfd)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (old_handle == INVALID_HANDLE_VALUE\n      || (mode = setmode (oldfd, O_BINARY)) == -1)\n    {\n      /* oldfd is not open, or is an unassigned standard file\n         descriptor.  */\n      errno = EBADF;\n      return -1;\n    }\n  setmode (oldfd, mode);\n  flags |= mode;\n\n  for (;;)\n    {\n      HANDLE new_handle;\n      int duplicated_fd;\n      unsigned int index;\n\n      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */\n                            old_handle,             /* SourceHandle */\n                            curr_process,           /* TargetProcessHandle */\n                            (PHANDLE) &new_handle,  /* TargetHandle */\n                            (DWORD) 0,              /* DesiredAccess */\n                            inherit,                /* InheritHandle */\n                            DUPLICATE_SAME_ACCESS)) /* Options */\n        {\n          switch (GetLastError ())\n            {\n              case ERROR_TOO_MANY_OPEN_FILES:\n                errno = EMFILE;\n                break;\n              case ERROR_INVALID_HANDLE:\n              case ERROR_INVALID_TARGET_HANDLE:\n              case ERROR_DIRECT_ACCESS_HANDLE:\n                errno = EBADF;\n                break;\n              case ERROR_INVALID_PARAMETER:\n              case ERROR_INVALID_FUNCTION:\n              case ERROR_INVALID_ACCESS:\n                errno = EINVAL;\n                break;\n              default:\n                errno = EACCES;\n                break;\n            }\n          result = -1;\n          break;\n        }\n      duplicated_fd = _open_osfhandle ((intptr_t) new_handle, flags);\n      if (duplicated_fd < 0)\n        {\n          CloseHandle (new_handle);\n          result = -1;\n          break;\n        }\n      if (newfd <= duplicated_fd)\n        {\n          result = duplicated_fd;\n          break;\n        }\n\n      /* Set the bit duplicated_fd in fds_to_close[].  */\n      index = (unsigned int) duplicated_fd / CHAR_BIT;\n      if (fds_to_close_bound <= index)\n        {\n          if (sizeof fds_to_close <= index)\n            /* Need to increase OPEN_MAX_MAX.  */\n            abort ();\n          memset (fds_to_close + fds_to_close_bound, '\\0',\n                  index + 1 - fds_to_close_bound);\n          fds_to_close_bound = index + 1;\n        }\n      fds_to_close[index] |= 1 << ((unsigned int) duplicated_fd % CHAR_BIT);\n    }\n\n  /* Close the previous fds that turned out to be too small.  */\n  {\n    int saved_errno = errno;\n    unsigned int duplicated_fd;\n\n    for (duplicated_fd = 0;\n         duplicated_fd < fds_to_close_bound * CHAR_BIT;\n         duplicated_fd++)\n      if ((fds_to_close[duplicated_fd / CHAR_BIT]\n           >> (duplicated_fd % CHAR_BIT))\n          & 1)\n        close (duplicated_fd);\n\n    errno = saved_errno;\n  }\n\n# if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (oldfd, result);\n# endif\n  return result;\n}",
      "lines": 114,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_fcntl": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "static int\nklibc_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg_ptr;\n  int arg;\n  struct stat sbuf;\n  int result = -1;\n\n  va_start (arg_ptr, action);\n  arg = va_arg (arg_ptr, int);\n  result = fcntl (fd, action, arg);\n  /* EPERM for F_DUPFD, ENOTSUP for others */\n  if (result == -1 && (errno == EPERM || errno == ENOTSUP)\n      && !fstat (fd, &sbuf) && S_ISDIR (sbuf.st_mode))\n  {\n    ULONG ulMode;\n\n    switch (action)\n      {\n      case F_DUPFD:\n        /* Find available fd */\n        while (fcntl (arg, F_GETFL) != -1 || errno != EBADF)\n          arg++;\n\n        result = dup2 (fd, arg);\n        break;\n\n      /* Using underlying APIs is right ? */\n      case F_GETFD:\n        if (DosQueryFHState (fd, &ulMode))\n          break;\n\n        result = (ulMode & OPEN_FLAGS_NOINHERIT) ? FD_CLOEXEC : 0;\n        break;\n\n      case F_SETFD:\n        if (arg & ~FD_CLOEXEC)\n          break;\n\n        if (DosQueryFHState (fd, &ulMode))\n          break;\n\n        if (arg & FD_CLOEXEC)\n          ulMode |= OPEN_FLAGS_NOINHERIT;\n        else\n          ulMode &= ~OPEN_FLAGS_NOINHERIT;\n\n        /* Filter supported flags.  */\n        ulMode &= (OPEN_FLAGS_WRITE_THROUGH | OPEN_FLAGS_FAIL_ON_ERROR\n                   | OPEN_FLAGS_NO_CACHE | OPEN_FLAGS_NOINHERIT);\n\n        if (DosSetFHState (fd, ulMode))\n          break;\n\n        result = 0;\n        break;\n\n      case F_GETFL:\n        result = 0;\n        break;\n\n      case F_SETFL:\n        if (arg != 0)\n          break;\n\n        result = 0;\n        break;\n\n      default :\n        errno = EINVAL;\n        break;\n      }\n  }\n\n  va_end (arg_ptr);\n\n  return result;\n}",
      "lines": 78,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fcntl": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "int\nrpl_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg;\n  int result = -1;\n  va_start (arg, action);\n  switch (action)\n    {\n\n#if !HAVE_FCNTL\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        result = dupfd (fd, target, 0);\n        break;\n      }\n#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        /* Detect invalid target; needed for cygwin 1.5.x.  */\n        if (target < 0 || getdtablesize () <= target)\n          errno = EINVAL;\n        else\n          {\n            /* Haiku alpha 2 loses fd flags on original.  */\n            int flags = fcntl (fd, F_GETFD);\n            if (flags < 0)\n              {\n                result = -1;\n                break;\n              }\n            result = fcntl (fd, action, target);\n            if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                result = -1;\n                errno = saved_errno;\n              }\n# if REPLACE_FCHDIR\n            if (0 <= result)\n              result = _gl_register_dup (fd, result);\n# endif\n          }\n        break;\n      } /* F_DUPFD */\n#endif /* FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR */\n\n    case F_DUPFD_CLOEXEC:\n      {\n        int target = va_arg (arg, int);\n\n#if !HAVE_FCNTL\n        result = dupfd (fd, target, O_CLOEXEC);\n        break;\n#else /* HAVE_FCNTL */\n        /* Try the system call first, if the headers claim it exists\n           (that is, if GNULIB_defined_F_DUPFD_CLOEXEC is 0), since we\n           may be running with a glibc that has the macro but with an\n           older kernel that does not support it.  Cache the\n           information on whether the system call really works, but\n           avoid caching failure if the corresponding F_DUPFD fails\n           for any reason.  0 = unknown, 1 = yes, -1 = no.  */\n        static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;\n        if (0 <= have_dupfd_cloexec)\n          {\n            result = fcntl (fd, action, target);\n            if (0 <= result || errno != EINVAL)\n              {\n                have_dupfd_cloexec = 1;\n# if REPLACE_FCHDIR\n                if (0 <= result)\n                  result = _gl_register_dup (fd, result);\n# endif\n              }\n            else\n              {\n                result = rpl_fcntl (fd, F_DUPFD, target);\n                if (result < 0)\n                  break;\n                have_dupfd_cloexec = -1;\n              }\n          }\n        else\n          result = rpl_fcntl (fd, F_DUPFD, target);\n        if (0 <= result && have_dupfd_cloexec == -1)\n          {\n            int flags = fcntl (result, F_GETFD);\n            if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                errno = saved_errno;\n                result = -1;\n              }\n          }\n        break;\n#endif /* HAVE_FCNTL */\n      } /* F_DUPFD_CLOEXEC */\n\n#if !HAVE_FCNTL\n    case F_GETFD:\n      {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n        HANDLE handle = (HANDLE) _get_osfhandle (fd);\n        DWORD flags;\n        if (handle == INVALID_HANDLE_VALUE\n            || GetHandleInformation (handle, &flags) == 0)\n          errno = EBADF;\n        else\n          result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;\n# else /* !W32 */\n        /* Use dup2 to reject invalid file descriptors.  No way to\n           access this information, so punt.  */\n        if (0 <= dup2 (fd, fd))\n          result = 0;\n# endif /* !W32 */\n        break;\n      } /* F_GETFD */\n#endif /* !HAVE_FCNTL */\n\n      /* Implementing F_SETFD on mingw is not trivial - there is no\n         API for changing the O_NOINHERIT bit on an fd, and merely\n         changing the HANDLE_FLAG_INHERIT bit on the underlying handle\n         can lead to odd state.  It may be possible by duplicating the\n         handle, using _open_osfhandle with the right flags, then\n         using dup2 to move the duplicate onto the original, but that\n         is not supported for now.  */\n\n    default:\n      {\n#if HAVE_FCNTL\n        void *p = va_arg (arg, void *);\n        result = fcntl (fd, action, p);\n#else\n        errno = EINVAL;\n#endif\n        break;\n      }\n    }\n  va_end (arg);\n  return result;\n}",
      "lines": 144,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fcntl.in.h": {},
  "tar/tar-1.30/gnu/fd-hook.c": {
    "execute_close_hooks": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nexecute_close_hooks (const struct fd_hook *remaining_list, gl_close_fn primary,\n                     int fd)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd);\n  else\n    return remaining_list->private_close_fn (remaining_list->private_next,\n                                             primary, fd);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_close_hooks": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nexecute_all_close_hooks (gl_close_fn primary, int fd)\n{\n  return execute_close_hooks (anchor.private_next, primary, fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "execute_ioctl_hooks": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nexecute_ioctl_hooks (const struct fd_hook *remaining_list, gl_ioctl_fn primary,\n                     int fd, int request, void *arg)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd, request, arg);\n  else\n    return remaining_list->private_ioctl_fn (remaining_list->private_next,\n                                             primary, fd, request, arg);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_ioctl_hooks": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nexecute_all_ioctl_hooks (gl_ioctl_fn primary,\n                         int fd, int request, void *arg)\n{\n  return execute_ioctl_hooks (anchor.private_next, primary, fd, request, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "register_fd_hook": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nregister_fd_hook (close_hook_fn close_hook, ioctl_hook_fn ioctl_hook, struct fd_hook *link)\n{\n  if (close_hook == NULL)\n    close_hook = execute_close_hooks;\n  if (ioctl_hook == NULL)\n    ioctl_hook = execute_ioctl_hooks;\n\n  if (link->private_next == NULL && link->private_prev == NULL)\n    {\n      /* Add the link to the doubly linked list.  */\n      link->private_next = anchor.private_next;\n      link->private_prev = &anchor;\n      link->private_close_fn = close_hook;\n      link->private_ioctl_fn = ioctl_hook;\n      anchor.private_next->private_prev = link;\n      anchor.private_next = link;\n    }\n  else\n    {\n      /* The link is already in use.  */\n      if (link->private_close_fn != close_hook\n          || link->private_ioctl_fn != ioctl_hook)\n        abort ();\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "unregister_fd_hook": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nunregister_fd_hook (struct fd_hook *link)\n{\n  struct fd_hook *next = link->private_next;\n  struct fd_hook *prev = link->private_prev;\n\n  if (next != NULL && prev != NULL)\n    {\n      /* The link is in use.  Remove it from the doubly linked list.  */\n      prev->private_next = next;\n      next->private_prev = prev;\n      /* Clear the link, to mark it unused.  */\n      link->private_next = NULL;\n      link->private_prev = NULL;\n      link->private_close_fn = NULL;\n      link->private_ioctl_fn = NULL;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/fd-hook.h": {},
  "tar/tar-1.30/gnu/fd-safer-flag.c": {
    "fd_safer_flag": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nfd_safer_flag (int fd, int flag)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer_flag (fd, flag);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fd-safer.c": {
    "fd_safer": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nfd_safer (int fd)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer (fd);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fdopendir.c": {
    "fdopendir": [
      {
        "start_point": [
          67,
          0
        ],
        "end_point": [
          97,
          1
        ],
        "content": "DIR *\nfdopendir (int fd)\n{\n  char path[_MAX_PATH];\n  DIR *dirp;\n\n  /* Get a path from fd */\n  if (__libc_Back_ioFHToPath (fd, path, sizeof (path)))\n    return NULL;\n\n  dirp = opendir (path);\n  if (!dirp)\n    return NULL;\n\n  /* Unregister fd registered by opendir() */\n  _gl_unregister_dirp_fd (dirfd (dirp));\n\n  /* Register our fd */\n  if (_gl_register_dirp_fd (fd, dirp))\n    {\n      int saved_errno = errno;\n\n      closedir (dirp);\n\n      errno = saved_errno;\n\n      dirp = NULL;\n    }\n\n  return dirp;\n}",
        "lines": 31,
        "depth": 9,
        "decorators": [
          "DIR",
          "*\nfdopendir (int fd)",
          "*"
        ]
      },
      {
        "start_point": [
          99,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "DIR *\nfdopendir (int fd)\n{\n  DIR *dir = fdopendir_with_dup (fd, -1, NULL);\n\n  if (! REPLACE_FCHDIR && ! dir)\n    {\n      int saved_errno = errno;\n      if (EXPECTED_ERRNO (saved_errno))\n        {\n          struct saved_cwd cwd;\n          if (save_cwd (&cwd) != 0)\n            openat_save_fail (errno);\n          dir = fdopendir_with_dup (fd, -1, &cwd);\n          saved_errno = errno;\n          free_cwd (&cwd);\n          errno = saved_errno;\n        }\n    }\n\n  return dir;\n}",
        "lines": 22,
        "depth": 13,
        "decorators": [
          "DIR",
          "*\nfdopendir (int fd)",
          "*"
        ]
      }
    ],
    "fdopendir_with_dup": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static DIR *\nfdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)\n{\n  int dupfd = dup (fd);\n  if (dupfd < 0 && errno == EMFILE)\n    dupfd = older_dupfd;\n  if (dupfd < 0)\n    return NULL;\n  else\n    {\n      DIR *dir;\n      int saved_errno;\n      if (dupfd < fd - 1 && dupfd != older_dupfd)\n        {\n          dir = fdopendir_with_dup (fd, dupfd, cwd);\n          saved_errno = errno;\n        }\n      else\n        {\n          close (fd);\n          dir = fd_clone_opendir (dupfd, cwd);\n          saved_errno = errno;\n          if (! dir)\n            {\n              int fd1 = dup (dupfd);\n              if (fd1 != fd)\n                openat_save_fail (fd1 < 0 ? errno : EBADF);\n            }\n        }\n\n      if (dupfd != older_dupfd)\n        close (dupfd);\n      errno = saved_errno;\n      return dir;\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "DIR",
        "*\nfdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)",
        "*"
      ]
    },
    "fd_clone_opendir": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static DIR *\nfd_clone_opendir (int fd, struct saved_cwd const *cwd)\n{\n  if (REPLACE_FCHDIR || ! cwd)\n    {\n      DIR *dir = NULL;\n      int saved_errno = EOPNOTSUPP;\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          dir = opendir (proc_file);\n          saved_errno = errno;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n# if REPLACE_FCHDIR\n      if (! dir && EXPECTED_ERRNO (saved_errno))\n        {\n          char const *name = _gl_directory_name (fd);\n          DIR *dp = name ? opendir (name) : NULL;\n\n          /* The caller has done an elaborate dance to arrange for opendir to\n             consume just the right file descriptor.  If dirfd returns -1,\n             though, we're on a system like mingw where opendir does not\n             consume a file descriptor.  Consume it via 'dup' instead.  */\n          if (dp && dirfd (dp) < 0)\n            dup (fd);\n\n          return dp;\n        }\n# endif\n      errno = saved_errno;\n      return dir;\n    }\n  else\n    {\n      if (fchdir (fd) != 0)\n        return NULL;\n      else\n        {\n          DIR *dir = opendir (\".\");\n          int saved_errno = errno;\n          if (restore_cwd (cwd) != 0)\n            openat_restore_fail (errno);\n          errno = saved_errno;\n          return dir;\n        }\n    }\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "DIR",
        "*\nfd_clone_opendir (int fd, struct saved_cwd const *cwd)",
        "*"
      ]
    },
    "rpl_fdopendir": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "DIR *\nrpl_fdopendir (int fd)\n{\n  struct stat st;\n  if (fstat (fd, &st))\n    return NULL;\n  if (!S_ISDIR (st.st_mode))\n    {\n      errno = ENOTDIR;\n      return NULL;\n    }\n  return fdopendir (fd);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "DIR",
        "*\nrpl_fdopendir (int fd)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/fdutimensat.c": {
    "fdutimensat": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\nfdutimensat (int fd, int dir, char const *file, struct timespec const ts[2],\n             int atflag)\n{\n  int result = 1;\n  if (0 <= fd)\n    result = futimens (fd, ts);\n  if (file && (fd < 0 || (result == -1 && errno == ENOSYS)))\n    result = utimensat (dir, file, ts, atflag);\n  if (result == 1)\n    {\n      errno = EBADF;\n      result = -1;\n    }\n  return result;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/file-has-acl.c": {
    "file_has_acl": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "int\nfile_has_acl (char const *name, struct stat const *sb)\n{\n#if USE_ACL\n  if (! S_ISLNK (sb->st_mode))\n    {\n\n# if GETXATTR_WITH_POSIX_ACLS\n\n      ssize_t ret;\n\n      ret = getxattr (name, XATTR_NAME_POSIX_ACL_ACCESS, NULL, 0);\n      if (ret < 0 && errno == ENODATA)\n        ret = 0;\n      else if (ret > 0)\n        return 1;\n\n      if (ret == 0 && S_ISDIR (sb->st_mode))\n        {\n          ret = getxattr (name, XATTR_NAME_POSIX_ACL_DEFAULT, NULL, 0);\n          if (ret < 0 && errno == ENODATA)\n            ret = 0;\n          else if (ret > 0)\n            return 1;\n        }\n\n      if (ret < 0)\n        return - acl_errno_valid (errno);\n      return ret;\n\n# elif HAVE_ACL_GET_FILE\n\n      /* POSIX 1003.1e (draft 17 -- abandoned) specific version.  */\n      /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n      int ret;\n\n      if (HAVE_ACL_EXTENDED_FILE) /* Linux */\n        {\n          /* On Linux, acl_extended_file is an optimized function: It only\n             makes two calls to getxattr(), one for ACL_TYPE_ACCESS, one for\n             ACL_TYPE_DEFAULT.  */\n          ret = acl_extended_file (name);\n        }\n      else /* FreeBSD, Mac OS X, IRIX, Tru64 */\n        {\n#  if HAVE_ACL_TYPE_EXTENDED /* Mac OS X */\n          /* On Mac OS X, acl_get_file (name, ACL_TYPE_ACCESS)\n             and acl_get_file (name, ACL_TYPE_DEFAULT)\n             always return NULL / EINVAL.  There is no point in making\n             these two useless calls.  The real ACL is retrieved through\n             acl_get_file (name, ACL_TYPE_EXTENDED).  */\n          acl_t acl = acl_get_file (name, ACL_TYPE_EXTENDED);\n          if (acl)\n            {\n              ret = acl_extended_nontrivial (acl);\n              acl_free (acl);\n            }\n          else\n            ret = -1;\n#  else /* FreeBSD, IRIX, Tru64 */\n          acl_t acl = acl_get_file (name, ACL_TYPE_ACCESS);\n          if (acl)\n            {\n              int saved_errno;\n\n              ret = acl_access_nontrivial (acl);\n              saved_errno = errno;\n              acl_free (acl);\n              errno = saved_errno;\n#   if HAVE_ACL_FREE_TEXT /* Tru64 */\n              /* On OSF/1, acl_get_file (name, ACL_TYPE_DEFAULT) always\n                 returns NULL with errno not set.  There is no point in\n                 making this call.  */\n#   else /* FreeBSD, IRIX */\n              /* On Linux, FreeBSD, IRIX, acl_get_file (name, ACL_TYPE_ACCESS)\n                 and acl_get_file (name, ACL_TYPE_DEFAULT) on a directory\n                 either both succeed or both fail; it depends on the\n                 file system.  Therefore there is no point in making the second\n                 call if the first one already failed.  */\n              if (ret == 0 && S_ISDIR (sb->st_mode))\n                {\n                  acl = acl_get_file (name, ACL_TYPE_DEFAULT);\n                  if (acl)\n                    {\n                      ret = (0 < acl_entries (acl));\n                      acl_free (acl);\n                    }\n                  else\n                    ret = -1;\n                }\n#   endif\n            }\n          else\n            ret = -1;\n#  endif\n        }\n      if (ret < 0)\n        return - acl_errno_valid (errno);\n      return ret;\n\n# elif HAVE_FACL && defined GETACL /* Solaris, Cygwin, not HP-UX */\n\n#  if defined ACL_NO_TRIVIAL\n\n      /* Solaris 10 (newer version), which has additional API declared in\n         <sys/acl.h> (acl_t) and implemented in libsec (acl_set, acl_trivial,\n         acl_fromtext, ...).  */\n      return acl_trivial (name);\n\n#  else /* Solaris, Cygwin, general case */\n\n      /* Solaris 2.5 through Solaris 10, Cygwin, and contemporaneous versions\n         of Unixware.  The acl() call returns the access and default ACL both\n         at once.  */\n      {\n        /* Initially, try to read the entries into a stack-allocated buffer.\n           Use malloc if it does not fit.  */\n        enum\n          {\n            alloc_init = 4000 / sizeof (aclent_t), /* >= 3 */\n            alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (aclent_t))\n          };\n        aclent_t buf[alloc_init];\n        size_t alloc = alloc_init;\n        aclent_t *entries = buf;\n        aclent_t *malloced = NULL;\n        int count;\n\n        for (;;)\n          {\n            count = acl (name, GETACL, alloc, entries);\n            if (count < 0 && errno == ENOSPC)\n              {\n                /* Increase the size of the buffer.  */\n                free (malloced);\n                if (alloc > alloc_max / 2)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                alloc = 2 * alloc; /* <= alloc_max */\n                entries = malloced =\n                  (aclent_t *) malloc (alloc * sizeof (aclent_t));\n                if (entries == NULL)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                continue;\n              }\n            break;\n          }\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == ENOTSUP)\n              ;\n            else\n              {\n                int saved_errno = errno;\n                free (malloced);\n                errno = saved_errno;\n                return -1;\n              }\n          }\n        else if (count == 0)\n          ;\n        else\n          {\n            /* Don't use MIN_ACL_ENTRIES:  It's set to 4 on Cygwin, but Cygwin\n               returns only 3 entries for files with no ACL.  But this is safe:\n               If there are more than 4 entries, there cannot be only the\n               \"user::\", \"group::\", \"other:\", and \"mask:\" entries.  */\n            if (count > 4)\n              {\n                free (malloced);\n                return 1;\n              }\n\n            if (acl_nontrivial (count, entries))\n              {\n                free (malloced);\n                return 1;\n              }\n          }\n        free (malloced);\n      }\n\n#   ifdef ACE_GETACL\n      /* Solaris also has a different variant of ACLs, used in ZFS and NFSv4\n         file systems (whereas the other ones are used in UFS file systems).  */\n      {\n        /* Initially, try to read the entries into a stack-allocated buffer.\n           Use malloc if it does not fit.  */\n        enum\n          {\n            alloc_init = 4000 / sizeof (ace_t), /* >= 3 */\n            alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (ace_t))\n          };\n        ace_t buf[alloc_init];\n        size_t alloc = alloc_init;\n        ace_t *entries = buf;\n        ace_t *malloced = NULL;\n        int count;\n\n        for (;;)\n          {\n            count = acl (name, ACE_GETACL, alloc, entries);\n            if (count < 0 && errno == ENOSPC)\n              {\n                /* Increase the size of the buffer.  */\n                free (malloced);\n                if (alloc > alloc_max / 2)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                alloc = 2 * alloc; /* <= alloc_max */\n                entries = malloced = (ace_t *) malloc (alloc * sizeof (ace_t));\n                if (entries == NULL)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                continue;\n              }\n            break;\n          }\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == EINVAL)\n              ;\n            else\n              {\n                int saved_errno = errno;\n                free (malloced);\n                errno = saved_errno;\n                return -1;\n              }\n          }\n        else if (count == 0)\n          ;\n        else\n          {\n            /* In the old (original Solaris 10) convention:\n               If there are more than 3 entries, there cannot be only the\n               ACE_OWNER, ACE_GROUP, ACE_OTHER entries.\n               In the newer Solaris 10 and Solaris 11 convention:\n               If there are more than 6 entries, there cannot be only the\n               ACE_OWNER, ACE_GROUP, ACE_EVERYONE entries, each once with\n               NEW_ACE_ACCESS_ALLOWED_ACE_TYPE and once with\n               NEW_ACE_ACCESS_DENIED_ACE_TYPE.  */\n            if (count > 6)\n              {\n                free (malloced);\n                return 1;\n              }\n\n            if (acl_ace_nontrivial (count, entries))\n              {\n                free (malloced);\n                return 1;\n              }\n          }\n        free (malloced);\n      }\n#   endif\n\n      return 0;\n#  endif\n\n# elif HAVE_GETACL /* HP-UX */\n\n      {\n        struct acl_entry entries[NACLENTRIES];\n        int count;\n\n        count = getacl (name, NACLENTRIES, entries);\n\n        if (count < 0)\n          {\n            /* ENOSYS is seen on newer HP-UX versions.\n               EOPNOTSUPP is typically seen on NFS mounts.\n               ENOTSUP was seen on Quantum StorNext file systems (cvfs).  */\n            if (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else /* count > 0 */\n          {\n            if (count > NACLENTRIES)\n              /* If NACLENTRIES cannot be trusted, use dynamic memory\n                 allocation.  */\n              abort ();\n\n            /* If there are more than 3 entries, there cannot be only the\n               (uid,%), (%,gid), (%,%) entries.  */\n            if (count > 3)\n              return 1;\n\n            {\n              struct stat statbuf;\n\n              if (stat (name, &statbuf) < 0)\n                return -1;\n\n              return acl_nontrivial (count, entries);\n            }\n          }\n      }\n\n#  if HAVE_ACLV_H /* HP-UX >= 11.11 */\n\n      {\n        struct acl entries[NACLVENTRIES];\n        int count;\n\n        count = acl ((char *) name, ACL_GET, NACLVENTRIES, entries);\n\n        if (count < 0)\n          {\n            /* EOPNOTSUPP is seen on NFS in HP-UX 11.11, 11.23.\n               EINVAL is seen on NFS in HP-UX 11.31.  */\n            if (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else /* count > 0 */\n          {\n            if (count > NACLVENTRIES)\n              /* If NACLVENTRIES cannot be trusted, use dynamic memory\n                 allocation.  */\n              abort ();\n\n            /* If there are more than 4 entries, there cannot be only the\n               four base ACL entries.  */\n            if (count > 4)\n              return 1;\n\n            return aclv_nontrivial (count, entries);\n          }\n      }\n\n#  endif\n\n# elif HAVE_ACLX_GET && defined ACL_AIX_WIP /* AIX */\n\n      acl_type_t type;\n      char aclbuf[1024];\n      void *acl = aclbuf;\n      size_t aclsize = sizeof (aclbuf);\n      mode_t mode;\n\n      for (;;)\n        {\n          /* The docs say that type being 0 is equivalent to ACL_ANY, but it\n             is not true, in AIX 5.3.  */\n          type.u64 = ACL_ANY;\n          if (aclx_get (name, 0, &type, aclbuf, &aclsize, &mode) >= 0)\n            break;\n          if (errno == ENOSYS)\n            return 0;\n          if (errno != ENOSPC)\n            {\n              if (acl != aclbuf)\n                {\n                  int saved_errno = errno;\n                  free (acl);\n                  errno = saved_errno;\n                }\n              return -1;\n            }\n          aclsize = 2 * aclsize;\n          if (acl != aclbuf)\n            free (acl);\n          acl = malloc (aclsize);\n          if (acl == NULL)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n\n      if (type.u64 == ACL_AIXC)\n        {\n          int result = acl_nontrivial ((struct acl *) acl);\n          if (acl != aclbuf)\n            free (acl);\n          return result;\n        }\n      else if (type.u64 == ACL_NFS4)\n        {\n          int result = acl_nfs4_nontrivial ((nfs4_acl_int_t *) acl);\n          if (acl != aclbuf)\n            free (acl);\n          return result;\n        }\n      else\n        {\n          /* A newer type of ACL has been introduced in the system.\n             We should better support it.  */\n          if (acl != aclbuf)\n            free (acl);\n          errno = EINVAL;\n          return -1;\n        }\n\n# elif HAVE_STATACL /* older AIX */\n\n      union { struct acl a; char room[4096]; } u;\n\n      if (statacl ((char *) name, STX_NORMAL, &u.a, sizeof (u)) < 0)\n        return -1;\n\n      return acl_nontrivial (&u.a);\n\n# elif HAVE_ACLSORT /* NonStop Kernel */\n\n      {\n        struct acl entries[NACLENTRIES];\n        int count;\n\n        count = acl ((char *) name, ACL_GET, NACLENTRIES, entries);\n\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == ENOTSUP)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else /* count > 0 */\n          {\n            if (count > NACLENTRIES)\n              /* If NACLENTRIES cannot be trusted, use dynamic memory\n                 allocation.  */\n              abort ();\n\n            /* If there are more than 4 entries, there cannot be only the\n               four base ACL entries.  */\n            if (count > 4)\n              return 1;\n\n            return acl_nontrivial (count, entries);\n          }\n      }\n\n# endif\n    }\n#endif\n\n  return 0;\n}",
      "lines": 460,
      "depth": 26,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fileblocks.c": {
    "st_blocks": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "off_t\nst_blocks (off_t size)\n{\n  off_t datablks = size / 512 + (size % 512 != 0);\n  off_t indrblks = 0;\n\n  if (datablks > NDIR)\n    {\n      indrblks = (datablks - NDIR - 1) / NINDIR + 1;\n\n      if (datablks > NDIR + NINDIR)\n        {\n          indrblks += (datablks - NDIR - NINDIR - 1) / (NINDIR * NINDIR) + 1;\n\n          if (datablks > NDIR + NINDIR + NINDIR * NINDIR)\n            indrblks++;\n        }\n    }\n\n  return datablks + indrblks;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "off_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/filename.h": {},
  "tar/tar-1.30/gnu/filenamecat-lgpl.c": {
    "longest_relative_suffix": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static char const * _GL_ATTRIBUTE_PURE\nlongest_relative_suffix (char const *f)\n{\n  for (f += FILE_SYSTEM_PREFIX_LEN (f); ISSLASH (*f); f++)\n    continue;\n  return f;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlongest_relative_suffix (char const *f)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "mfile_name_concat": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "char *\nmfile_name_concat (char const *dir, char const *abase, char **base_in_result)\n{\n  char const *dirbase = last_component (dir);\n  size_t dirbaselen = base_len (dirbase);\n  size_t dirlen = dirbase - dir + dirbaselen;\n  size_t needs_separator = (dirbaselen && ! ISSLASH (dirbase[dirbaselen - 1]));\n\n  char const *base = longest_relative_suffix (abase);\n  size_t baselen = strlen (base);\n\n  char *p_concat = malloc (dirlen + needs_separator + baselen + 1);\n  char *p;\n\n  if (p_concat == NULL)\n    return NULL;\n\n  p = mempcpy (p_concat, dir, dirlen);\n  *p = DIRECTORY_SEPARATOR;\n  p += needs_separator;\n\n  if (base_in_result)\n    *base_in_result = p - IS_ABSOLUTE_FILE_NAME (abase);\n\n  p = mempcpy (p, base, baselen);\n  *p = '\\0';\n\n  return p_concat;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "char",
        "*\nmfile_name_concat (char const *dir, char const *abase, char **base_in_result)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/filenamecat.h": {},
  "tar/tar-1.30/gnu/flexmember.h": {},
  "tar/tar-1.30/gnu/float+.h": {},
  "tar/tar-1.30/gnu/float.c": {},
  "tar/tar-1.30/gnu/float.in.h": {},
  "tar/tar-1.30/gnu/fnmatch.c": {
    "is_char_class": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "static wctype_t\nis_char_class (const wchar_t *wcs)\n{\n  char s[CHAR_CLASS_MAX_LENGTH + 1];\n  char *cp = s;\n\n  do\n    {\n      /* Test for a printable character from the portable character set.  */\n#  ifdef _LIBC\n      if (*wcs < 0x20 || *wcs > 0x7e\n          || *wcs == 0x24 || *wcs == 0x40 || *wcs == 0x60)\n        return (wctype_t) 0;\n#  else\n      switch (*wcs)\n        {\n        case L' ': case L'!': case L'\"': case L'#': case L'%':\n        case L'&': case L'\\'': case L'(': case L')': case L'*':\n        case L'+': case L',': case L'-': case L'.': case L'/':\n        case L'0': case L'1': case L'2': case L'3': case L'4':\n        case L'5': case L'6': case L'7': case L'8': case L'9':\n        case L':': case L';': case L'<': case L'=': case L'>':\n        case L'?':\n        case L'A': case L'B': case L'C': case L'D': case L'E':\n        case L'F': case L'G': case L'H': case L'I': case L'J':\n        case L'K': case L'L': case L'M': case L'N': case L'O':\n        case L'P': case L'Q': case L'R': case L'S': case L'T':\n        case L'U': case L'V': case L'W': case L'X': case L'Y':\n        case L'Z':\n        case L'[': case L'\\\\': case L']': case L'^': case L'_':\n        case L'a': case L'b': case L'c': case L'd': case L'e':\n        case L'f': case L'g': case L'h': case L'i': case L'j':\n        case L'k': case L'l': case L'm': case L'n': case L'o':\n        case L'p': case L'q': case L'r': case L's': case L't':\n        case L'u': case L'v': case L'w': case L'x': case L'y':\n        case L'z': case L'{': case L'|': case L'}': case L'~':\n          break;\n        default:\n          return (wctype_t) 0;\n        }\n#  endif\n\n      /* Avoid overrunning the buffer.  */\n      if (cp == s + CHAR_CLASS_MAX_LENGTH)\n        return (wctype_t) 0;\n\n      *cp++ = (char) *wcs++;\n    }\n  while (*wcs != L'\\0');\n\n  *cp = '\\0';\n\n#  ifdef _LIBC\n  return __wctype (s);\n#  else\n  return wctype (s);\n#  endif\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "wctype_t"
      ]
    },
    "fnmatch": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "int\nfnmatch (const char *pattern, const char *string, int flags)\n{\n# if HANDLE_MULTIBYTE\n#  define ALLOCA_LIMIT 2000\n  if (__builtin_expect (MB_CUR_MAX, 1) != 1)\n    {\n      mbstate_t ps;\n      size_t patsize;\n      size_t strsize;\n      size_t totsize;\n      wchar_t *wpattern;\n      wchar_t *wstring;\n      int res;\n\n      /* Calculate the size needed to convert the strings to\n         wide characters.  */\n      memset (&ps, '\\0', sizeof (ps));\n      patsize = mbsrtowcs (NULL, &pattern, 0, &ps) + 1;\n      if (__builtin_expect (patsize != 0, 1))\n        {\n          assert (mbsinit (&ps));\n          strsize = mbsrtowcs (NULL, &string, 0, &ps) + 1;\n          if (__builtin_expect (strsize != 0, 1))\n            {\n              assert (mbsinit (&ps));\n              totsize = patsize + strsize;\n              if (__builtin_expect (! (patsize <= totsize\n                                       && totsize <= SIZE_MAX / sizeof (wchar_t)),\n                                    0))\n                {\n                  errno = ENOMEM;\n                  return -1;\n                }\n\n              /* Allocate room for the wide characters.  */\n              if (__builtin_expect (totsize < ALLOCA_LIMIT, 1))\n                wpattern = (wchar_t *) alloca (totsize * sizeof (wchar_t));\n              else\n                {\n                  wpattern = malloc (totsize * sizeof (wchar_t));\n                  if (__builtin_expect (! wpattern, 0))\n                    {\n                      errno = ENOMEM;\n                      return -1;\n                    }\n                }\n              wstring = wpattern + patsize;\n\n              /* Convert the strings into wide characters.  */\n              mbsrtowcs (wpattern, &pattern, patsize, &ps);\n              assert (mbsinit (&ps));\n              mbsrtowcs (wstring, &string, strsize, &ps);\n\n              res = internal_fnwmatch (wpattern, wstring, wstring + strsize - 1,\n                                       flags & FNM_PERIOD, flags);\n\n              if (__builtin_expect (! (totsize < ALLOCA_LIMIT), 0))\n                free (wpattern);\n              return res;\n            }\n        }\n    }\n\n# endif /* HANDLE_MULTIBYTE */\n\n  return internal_fnmatch (pattern, string, string + strlen (string),\n                           flags & FNM_PERIOD, flags);\n}",
      "lines": 69,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fnmatch.in.h": {},
  "tar/tar-1.30/gnu/fnmatch_loop.c": {
    "internal_function": [
      {
        "start_point": [
          23,
          0
        ],
        "end_point": [
          981,
          1
        ],
        "content": "static int\ninternal_function\nFCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,\n     bool no_leading_period, int flags)\n{\n  register const CHAR *p = pattern, *n = string;\n  register UCHAR c;\n#ifdef _LIBC\n# if WIDE_CHAR_VERSION\n  const char *collseq = (const char *)\n    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n# else\n  const UCHAR *collseq = (const UCHAR *)\n    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n# endif\n#endif\n\n  while ((c = *p++) != L_('\\0'))\n    {\n      bool new_no_leading_period = false;\n      c = FOLD (c);\n\n      switch (c)\n        {\n        case L_('?'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period,\n                         flags);\n              if (res != -1)\n                return res;\n            }\n\n          if (n == string_end)\n            return FNM_NOMATCH;\n          else if (*n == L_('/') && (flags & FNM_FILE_NAME))\n            return FNM_NOMATCH;\n          else if (*n == L_('.') && no_leading_period)\n            return FNM_NOMATCH;\n          break;\n\n        case L_('\\\\'):\n          if (!(flags & FNM_NOESCAPE))\n            {\n              c = *p++;\n              if (c == L_('\\0'))\n                /* Trailing \\ loses.  */\n                return FNM_NOMATCH;\n              c = FOLD (c);\n            }\n          if (n == string_end || FOLD ((UCHAR) *n) != c)\n            return FNM_NOMATCH;\n          break;\n\n        case L_('*'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period,\n                         flags);\n              if (res != -1)\n                return res;\n            }\n\n          if (n != string_end && *n == L_('.') && no_leading_period)\n            return FNM_NOMATCH;\n\n          for (c = *p++; c == L_('?') || c == L_('*'); c = *p++)\n            {\n              if (*p == L_('(') && (flags & FNM_EXTMATCH) != 0)\n                {\n                  const CHAR *endp = END (p);\n                  if (endp != p)\n                    {\n                      /* This is a pattern.  Skip over it.  */\n                      p = endp;\n                      continue;\n                    }\n                }\n\n              if (c == L_('?'))\n                {\n                  /* A ? needs to match one character.  */\n                  if (n == string_end)\n                    /* There isn't another character; no match.  */\n                    return FNM_NOMATCH;\n                  else if (*n == L_('/')\n                           && __builtin_expect (flags & FNM_FILE_NAME, 0))\n                    /* A slash does not match a wildcard under\n                       FNM_FILE_NAME.  */\n                    return FNM_NOMATCH;\n                  else\n                    /* One character of the string is consumed in matching\n                       this ? wildcard, so *??? won't match if there are\n                       less than three characters.  */\n                    ++n;\n                }\n            }\n\n          if (c == L_('\\0'))\n            /* The wildcard(s) is/are the last element of the pattern.\n               If the name is a file name and contains another slash\n               this means it cannot match, unless the FNM_LEADING_DIR\n               flag is set.  */\n            {\n              int result = (flags & FNM_FILE_NAME) == 0 ? 0 : FNM_NOMATCH;\n\n              if (flags & FNM_FILE_NAME)\n                {\n                  if (flags & FNM_LEADING_DIR)\n                    result = 0;\n                  else\n                    {\n                      if (MEMCHR (n, L_('/'), string_end - n) == NULL)\n                        result = 0;\n                    }\n                }\n\n              return result;\n            }\n          else\n            {\n              const CHAR *endp;\n\n              endp = MEMCHR (n, (flags & FNM_FILE_NAME) ? L_('/') : L_('\\0'),\n                             string_end - n);\n              if (endp == NULL)\n                endp = string_end;\n\n              if (c == L_('[')\n                  || (__builtin_expect (flags & FNM_EXTMATCH, 0) != 0\n                      && (c == L_('@') || c == L_('+') || c == L_('!'))\n                      && *p == L_('(')))\n                {\n                  int flags2 = ((flags & FNM_FILE_NAME)\n                                ? flags : (flags & ~FNM_PERIOD));\n                  bool no_leading_period2 = no_leading_period;\n\n                  for (--p; n < endp; ++n, no_leading_period2 = false)\n                    if (FCT (p, n, string_end, no_leading_period2, flags2)\n                        == 0)\n                      return 0;\n                }\n              else if (c == L_('/') && (flags & FNM_FILE_NAME))\n                {\n                  while (n < string_end && *n != L_('/'))\n                    ++n;\n                  if (n < string_end && *n == L_('/')\n                      && (FCT (p, n + 1, string_end, flags & FNM_PERIOD, flags)\n                          == 0))\n                    return 0;\n                }\n              else\n                {\n                  int flags2 = ((flags & FNM_FILE_NAME)\n                                ? flags : (flags & ~FNM_PERIOD));\n                  int no_leading_period2 = no_leading_period;\n\n                  if (c == L_('\\\\') && !(flags & FNM_NOESCAPE))\n                    c = *p;\n                  c = FOLD (c);\n                  for (--p; n < endp; ++n, no_leading_period2 = false)\n                    if (FOLD ((UCHAR) *n) == c\n                        && (FCT (p, n, string_end, no_leading_period2, flags2)\n                            == 0))\n                      return 0;\n                }\n            }\n\n          /* If we come here no match is possible with the wildcard.  */\n          return FNM_NOMATCH;\n\n        case L_('['):\n          {\n            /* Nonzero if the sense of the character class is inverted.  */\n            const CHAR *p_init = p;\n            const CHAR *n_init = n;\n            register bool not;\n            CHAR cold;\n            UCHAR fn;\n\n            if (posixly_correct == 0)\n              posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n            if (n == string_end)\n              return FNM_NOMATCH;\n\n            if (*n == L_('.') && no_leading_period)\n              return FNM_NOMATCH;\n\n            if (*n == L_('/') && (flags & FNM_FILE_NAME))\n              /* '/' cannot be matched.  */\n              return FNM_NOMATCH;\n\n            not = (*p == L_('!') || (posixly_correct < 0 && *p == L_('^')));\n            if (not)\n              ++p;\n\n            fn = FOLD ((UCHAR) *n);\n\n            c = *p++;\n            for (;;)\n              {\n\t\tbool is_range = false;\n\n                if (!(flags & FNM_NOESCAPE) && c == L_('\\\\'))\n                  {\n                    if (*p == L_('\\0'))\n                      return FNM_NOMATCH;\n                    c = FOLD ((UCHAR) *p);\n                    ++p;\n\n                    goto normal_bracket;\n                  }\n                else if (c == L_('[') && *p == L_(':'))\n                  {\n                    /* Leave room for the null.  */\n                    CHAR str[CHAR_CLASS_MAX_LENGTH + 1];\n                    size_t c1 = 0;\n#if defined _LIBC || WIDE_CHAR_SUPPORT\n                    wctype_t wt;\n#endif\n                    const CHAR *startp = p;\n\n                    for (;;)\n                      {\n                        if (c1 == CHAR_CLASS_MAX_LENGTH)\n                          /* The name is too long and therefore the pattern\n                             is ill-formed.  */\n                          return FNM_NOMATCH;\n\n                        c = *++p;\n                        if (c == L_(':') && p[1] == L_(']'))\n                          {\n                            p += 2;\n                            break;\n                          }\n                        if (c < L_('a') || c >= L_('z'))\n                          {\n                            /* This cannot possibly be a character class name.\n                               Match it as a normal range.  */\n                            p = startp;\n                            c = L_('[');\n                            goto normal_bracket;\n                          }\n                        str[c1++] = c;\n                      }\n                    str[c1] = L_('\\0');\n\n#if defined _LIBC || WIDE_CHAR_SUPPORT\n                    wt = IS_CHAR_CLASS (str);\n                    if (wt == 0)\n                      /* Invalid character class name.  */\n                      return FNM_NOMATCH;\n\n# if defined _LIBC && ! WIDE_CHAR_VERSION\n                    /* The following code is glibc specific but does\n                       there a good job in speeding up the code since\n                       we can avoid the btowc() call.  */\n                    if (_ISCTYPE ((UCHAR) *n, wt))\n                      goto matched;\n# else\n                    if (ISWCTYPE (BTOWC ((UCHAR) *n), wt))\n                      goto matched;\n# endif\n#else\n                    if ((STREQ (str, L_(\"alnum\")) && isalnum ((UCHAR) *n))\n                        || (STREQ (str, L_(\"alpha\")) && isalpha ((UCHAR) *n))\n                        || (STREQ (str, L_(\"blank\")) && isblank ((UCHAR) *n))\n                        || (STREQ (str, L_(\"cntrl\")) && iscntrl ((UCHAR) *n))\n                        || (STREQ (str, L_(\"digit\")) && isdigit ((UCHAR) *n))\n                        || (STREQ (str, L_(\"graph\")) && isgraph ((UCHAR) *n))\n                        || (STREQ (str, L_(\"lower\")) && islower ((UCHAR) *n))\n                        || (STREQ (str, L_(\"print\")) && isprint ((UCHAR) *n))\n                        || (STREQ (str, L_(\"punct\")) && ispunct ((UCHAR) *n))\n                        || (STREQ (str, L_(\"space\")) && isspace ((UCHAR) *n))\n                        || (STREQ (str, L_(\"upper\")) && isupper ((UCHAR) *n))\n                        || (STREQ (str, L_(\"xdigit\")) && isxdigit ((UCHAR) *n)))\n                      goto matched;\n#endif\n                    c = *p++;\n                  }\n#ifdef _LIBC\n                else if (c == L_('[') && *p == L_('='))\n                  {\n                    UCHAR str[1];\n                    uint32_t nrules =\n                      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n                    const CHAR *startp = p;\n\n                    c = *++p;\n                    if (c == L_('\\0'))\n                      {\n                        p = startp;\n                        c = L_('[');\n                        goto normal_bracket;\n                      }\n                    str[0] = c;\n\n                    c = *++p;\n                    if (c != L_('=') || p[1] != L_(']'))\n                      {\n                        p = startp;\n                        c = L_('[');\n                        goto normal_bracket;\n                      }\n                    p += 2;\n\n                    if (nrules == 0)\n                      {\n                        if ((UCHAR) *n == str[0])\n                          goto matched;\n                      }\n                    else\n                      {\n                        const int32_t *table;\n# if WIDE_CHAR_VERSION\n                        const int32_t *weights;\n                        const int32_t *extra;\n# else\n                        const unsigned char *weights;\n                        const unsigned char *extra;\n# endif\n                        const int32_t *indirect;\n                        int32_t idx;\n                        const UCHAR *cp = (const UCHAR *) str;\n\n                        /* This #include defines a local function!  */\n# if WIDE_CHAR_VERSION\n#  include <locale/weightwc.h>\n# else\n#  include <locale/weight.h>\n# endif\n\n# if WIDE_CHAR_VERSION\n                        table = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEWC);\n                        weights = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTWC);\n                        extra = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAWC);\n                        indirect = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTWC);\n# else\n                        table = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n                        weights = (const unsigned char *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n                        extra = (const unsigned char *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n                        indirect = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n# endif\n\n                        idx = findidx (&cp);\n                        if (idx != 0)\n                          {\n                            /* We found a table entry.  Now see whether the\n                               character we are currently at has the same\n                               equivalence class value.  */\n                            int len = weights[idx & 0xffffff];\n                            int32_t idx2;\n                            const UCHAR *np = (const UCHAR *) n;\n\n                            idx2 = findidx (&np);\n                            if (idx2 != 0\n                                && (idx >> 24) == (idx2 >> 24)\n                                && len == weights[idx2 & 0xffffff])\n                              {\n                                int cnt = 0;\n\n                                idx &= 0xffffff;\n                                idx2 &= 0xffffff;\n\n                                while (cnt < len\n                                       && (weights[idx + 1 + cnt]\n                                           == weights[idx2 + 1 + cnt]))\n                                  ++cnt;\n\n                                if (cnt == len)\n                                  goto matched;\n                              }\n                          }\n                      }\n\n                    c = *p++;\n                  }\n#endif\n                else if (c == L_('\\0'))\n                  {\n                    /* [ unterminated, treat as normal character.  */\n                    p = p_init;\n                    n = n_init;\n                    c = L_('[');\n                    goto normal_match;\n                  }\n                else\n                  {\n#ifdef _LIBC\n                    bool is_seqval = false;\n\n                    if (c == L_('[') && *p == L_('.'))\n                      {\n                        uint32_t nrules =\n                          _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n                        const CHAR *startp = p;\n                        size_t c1 = 0;\n\n                        while (1)\n                          {\n                            c = *++p;\n                            if (c == L_('.') && p[1] == L_(']'))\n                              {\n                                p += 2;\n                                break;\n                              }\n                            if (c == '\\0')\n                              return FNM_NOMATCH;\n                            ++c1;\n                          }\n\n                        /* We have to handling the symbols differently in\n                           ranges since then the collation sequence is\n                           important.  */\n                        is_range = *p == L_('-') && p[1] != L_('\\0');\n\n                        if (nrules == 0)\n                          {\n                            /* There are no names defined in the collation\n                               data.  Therefore we only accept the trivial\n                               names consisting of the character itself.  */\n                            if (c1 != 1)\n                              return FNM_NOMATCH;\n\n                            if (!is_range && *n == startp[1])\n                              goto matched;\n\n                            cold = startp[1];\n                            c = *p++;\n                          }\n                        else\n                          {\n                            int32_t table_size;\n                            const int32_t *symb_table;\n# ifdef WIDE_CHAR_VERSION\n                            char str[c1];\n                            size_t strcnt;\n# else\n#  define str (startp + 1)\n# endif\n                            const unsigned char *extra;\n                            int32_t idx;\n                            int32_t elem;\n                            int32_t second;\n                            int32_t hash;\n\n# ifdef WIDE_CHAR_VERSION\n                            /* We have to convert the name to a single-byte\n                               string.  This is possible since the names\n                               consist of ASCII characters and the internal\n                               representation is UCS4.  */\n                            for (strcnt = 0; strcnt < c1; ++strcnt)\n                              str[strcnt] = startp[1 + strcnt];\n# endif\n\n                            table_size =\n                              _NL_CURRENT_WORD (LC_COLLATE,\n                                                _NL_COLLATE_SYMB_HASH_SIZEMB);\n                            symb_table = (const int32_t *)\n                              _NL_CURRENT (LC_COLLATE,\n                                           _NL_COLLATE_SYMB_TABLEMB);\n                            extra = (const unsigned char *)\n                              _NL_CURRENT (LC_COLLATE,\n                                           _NL_COLLATE_SYMB_EXTRAMB);\n\n                            /* Locate the character in the hashing table.  */\n                            hash = elem_hash (str, c1);\n\n                            idx = 0;\n                            elem = hash % table_size;\n                            if (symb_table[2 * elem] != 0)\n                              {\n                                second = hash % (table_size - 2) + 1;\n\n                                do\n                                  {\n                                    /* First compare the hashing value.  */\n                                    if (symb_table[2 * elem] == hash\n                                        && (c1\n                                            == extra[symb_table[2 * elem + 1]])\n                                        && memcmp (str,\n                                                   &extra[symb_table[2 * elem\n                                                                     + 1]\n                                                          + 1], c1) == 0)\n                                      {\n                                        /* Yep, this is the entry.  */\n                                        idx = symb_table[2 * elem + 1];\n                                        idx += 1 + extra[idx];\n                                        break;\n                                      }\n\n                                    /* Next entry.  */\n                                    elem += second;\n                                  }\n                                while (symb_table[2 * elem] != 0);\n                              }\n\n                            if (symb_table[2 * elem] != 0)\n                              {\n                                /* Compare the byte sequence but only if\n                                   this is not part of a range.  */\n# ifdef WIDE_CHAR_VERSION\n                                int32_t *wextra;\n\n                                idx += 1 + extra[idx];\n                                /* Adjust for the alignment.  */\n                                idx = (idx + 3) & ~3;\n\n                                wextra = (int32_t *) &extra[idx + 4];\n# endif\n\n                                if (! is_range)\n                                  {\n# ifdef WIDE_CHAR_VERSION\n                                    for (c1 = 0;\n                                         (int32_t) c1 < wextra[idx];\n                                         ++c1)\n                                      if (n[c1] != wextra[1 + c1])\n                                        break;\n\n                                    if ((int32_t) c1 == wextra[idx])\n                                      goto matched;\n# else\n                                    for (c1 = 0; c1 < extra[idx]; ++c1)\n                                      if (n[c1] != extra[1 + c1])\n                                        break;\n\n                                    if (c1 == extra[idx])\n                                      goto matched;\n# endif\n                                  }\n\n                                /* Get the collation sequence value.  */\n                                is_seqval = true;\n# ifdef WIDE_CHAR_VERSION\n                                cold = wextra[1 + wextra[idx]];\n# else\n                                /* Adjust for the alignment.  */\n                                idx += 1 + extra[idx];\n                                idx = (idx + 3) & ~4;\n                                cold = *((int32_t *) &extra[idx]);\n# endif\n\n                                c = *p++;\n                              }\n                            else if (c1 == 1)\n                              {\n                                /* No valid character.  Match it as a\n                                   single byte.  */\n                                if (!is_range && *n == str[0])\n                                  goto matched;\n\n                                cold = str[0];\n                                c = *p++;\n                              }\n                            else\n                              return FNM_NOMATCH;\n                          }\n                      }\n                    else\n# undef str\n#endif\n                      {\n                        c = FOLD (c);\n                      normal_bracket:\n\n                        /* We have to handling the symbols differently in\n                           ranges since then the collation sequence is\n                           important.  */\n                        is_range = (*p == L_('-') && p[1] != L_('\\0')\n                                    && p[1] != L_(']'));\n\n                        if (!is_range && c == fn)\n                          goto matched;\n\n#if _LIBC\n                        /* This is needed if we goto normal_bracket; from\n                           outside of is_seqval's scope.  */\n                        is_seqval = false;\n#endif\n\n                        cold = c;\n                        c = *p++;\n                      }\n\n                    if (c == L_('-') && *p != L_(']'))\n                      {\n#if _LIBC\n                        /* We have to find the collation sequence\n                           value for C.  Collation sequence is nothing\n                           we can regularly access.  The sequence\n                           value is defined by the order in which the\n                           definitions of the collation values for the\n                           various characters appear in the source\n                           file.  A strange concept, nowhere\n                           documented.  */\n                        uint32_t fcollseq;\n                        uint32_t lcollseq;\n                        UCHAR cend = *p++;\n\n# ifdef WIDE_CHAR_VERSION\n                        /* Search in the 'names' array for the characters.  */\n                        fcollseq = __collseq_table_lookup (collseq, fn);\n                        if (fcollseq == ~((uint32_t) 0))\n                          /* XXX We don't know anything about the character\n                             we are supposed to match.  This means we are\n                             failing.  */\n                          goto range_not_matched;\n\n                        if (is_seqval)\n                          lcollseq = cold;\n                        else\n                          lcollseq = __collseq_table_lookup (collseq, cold);\n# else\n                        fcollseq = collseq[fn];\n                        lcollseq = is_seqval ? cold : collseq[(UCHAR) cold];\n# endif\n\n                        is_seqval = false;\n                        if (cend == L_('[') && *p == L_('.'))\n                          {\n                            uint32_t nrules =\n                              _NL_CURRENT_WORD (LC_COLLATE,\n                                                _NL_COLLATE_NRULES);\n                            const CHAR *startp = p;\n                            size_t c1 = 0;\n\n                            while (1)\n                              {\n                                c = *++p;\n                                if (c == L_('.') && p[1] == L_(']'))\n                                  {\n                                    p += 2;\n                                    break;\n                                  }\n                                if (c == '\\0')\n                                  return FNM_NOMATCH;\n                                ++c1;\n                              }\n\n                            if (nrules == 0)\n                              {\n                                /* There are no names defined in the\n                                   collation data.  Therefore we only\n                                   accept the trivial names consisting\n                                   of the character itself.  */\n                                if (c1 != 1)\n                                  return FNM_NOMATCH;\n\n                                cend = startp[1];\n                              }\n                            else\n                              {\n                                int32_t table_size;\n                                const int32_t *symb_table;\n# ifdef WIDE_CHAR_VERSION\n                                char str[c1];\n                                size_t strcnt;\n# else\n#  define str (startp + 1)\n# endif\n                                const unsigned char *extra;\n                                int32_t idx;\n                                int32_t elem;\n                                int32_t second;\n                                int32_t hash;\n\n# ifdef WIDE_CHAR_VERSION\n                                /* We have to convert the name to a single-byte\n                                   string.  This is possible since the names\n                                   consist of ASCII characters and the internal\n                                   representation is UCS4.  */\n                                for (strcnt = 0; strcnt < c1; ++strcnt)\n                                  str[strcnt] = startp[1 + strcnt];\n# endif\n\n                                table_size =\n                                  _NL_CURRENT_WORD (LC_COLLATE,\n                                                    _NL_COLLATE_SYMB_HASH_SIZEMB);\n                                symb_table = (const int32_t *)\n                                  _NL_CURRENT (LC_COLLATE,\n                                               _NL_COLLATE_SYMB_TABLEMB);\n                                extra = (const unsigned char *)\n                                  _NL_CURRENT (LC_COLLATE,\n                                               _NL_COLLATE_SYMB_EXTRAMB);\n\n                                /* Locate the character in the hashing\n                                   table.  */\n                                hash = elem_hash (str, c1);\n\n                                idx = 0;\n                                elem = hash % table_size;\n                                if (symb_table[2 * elem] != 0)\n                                  {\n                                    second = hash % (table_size - 2) + 1;\n\n                                    do\n                                      {\n                                        /* First compare the hashing value.  */\n                                        if (symb_table[2 * elem] == hash\n                                            && (c1\n                                                == extra[symb_table[2 * elem + 1]])\n                                            && memcmp (str,\n                                                       &extra[symb_table[2 * elem + 1]\n                                                              + 1], c1) == 0)\n                                          {\n                                            /* Yep, this is the entry.  */\n                                            idx = symb_table[2 * elem + 1];\n                                            idx += 1 + extra[idx];\n                                            break;\n                                          }\n\n                                        /* Next entry.  */\n                                        elem += second;\n                                      }\n                                    while (symb_table[2 * elem] != 0);\n                                  }\n\n                                if (symb_table[2 * elem] != 0)\n                                  {\n                                    /* Compare the byte sequence but only if\n                                       this is not part of a range.  */\n# ifdef WIDE_CHAR_VERSION\n                                    int32_t *wextra;\n\n                                    idx += 1 + extra[idx];\n                                    /* Adjust for the alignment.  */\n                                    idx = (idx + 3) & ~4;\n\n                                    wextra = (int32_t *) &extra[idx + 4];\n# endif\n                                    /* Get the collation sequence value.  */\n                                    is_seqval = true;\n# ifdef WIDE_CHAR_VERSION\n                                    cend = wextra[1 + wextra[idx]];\n# else\n                                    /* Adjust for the alignment.  */\n                                    idx += 1 + extra[idx];\n                                    idx = (idx + 3) & ~4;\n                                    cend = *((int32_t *) &extra[idx]);\n# endif\n                                  }\n                                else if (symb_table[2 * elem] != 0 && c1 == 1)\n                                  {\n                                    cend = str[0];\n                                    c = *p++;\n                                  }\n                                else\n                                  return FNM_NOMATCH;\n                              }\n# undef str\n                          }\n                        else\n                          {\n                            if (!(flags & FNM_NOESCAPE) && cend == L_('\\\\'))\n                              cend = *p++;\n                            if (cend == L_('\\0'))\n                              return FNM_NOMATCH;\n                            cend = FOLD (cend);\n                          }\n\n                        /* XXX It is not entirely clear to me how to handle\n                           characters which are not mentioned in the\n                           collation specification.  */\n                        if (\n# ifdef WIDE_CHAR_VERSION\n                            lcollseq == 0xffffffff ||\n# endif\n                            lcollseq <= fcollseq)\n                          {\n                            /* We have to look at the upper bound.  */\n                            uint32_t hcollseq;\n\n                            if (is_seqval)\n                              hcollseq = cend;\n                            else\n                              {\n# ifdef WIDE_CHAR_VERSION\n                                hcollseq =\n                                  __collseq_table_lookup (collseq, cend);\n                                if (hcollseq == ~((uint32_t) 0))\n                                  {\n                                    /* Hum, no information about the upper\n                                       bound.  The matching succeeds if the\n                                       lower bound is matched exactly.  */\n                                    if (lcollseq != fcollseq)\n                                      goto range_not_matched;\n\n                                    goto matched;\n                                  }\n# else\n                                hcollseq = collseq[cend];\n# endif\n                              }\n\n                            if (lcollseq <= hcollseq && fcollseq <= hcollseq)\n                              goto matched;\n                          }\n# ifdef WIDE_CHAR_VERSION\n                      range_not_matched:\n# endif\n#else\n                        /* We use a boring value comparison of the character\n                           values.  This is better than comparing using\n                           'strcoll' since the latter would have surprising\n                           and sometimes fatal consequences.  */\n                        UCHAR cend = *p++;\n\n                        if (!(flags & FNM_NOESCAPE) && cend == L_('\\\\'))\n                          cend = *p++;\n                        if (cend == L_('\\0'))\n                          return FNM_NOMATCH;\n\n                        /* It is a range.  */\n                        if (cold <= fn && fn <= cend)\n                          goto matched;\n#endif\n\n                        c = *p++;\n                      }\n                  }\n\n                if (c == L_(']'))\n                  break;\n              }\n\n            if (!not)\n              return FNM_NOMATCH;\n            break;\n\n          matched:\n            /* Skip the rest of the [...] that already matched.  */\n            do\n              {\n              ignore_next:\n                c = *p++;\n\n                if (c == L_('\\0'))\n                  /* [... (unterminated) loses.  */\n                  return FNM_NOMATCH;\n\n                if (!(flags & FNM_NOESCAPE) && c == L_('\\\\'))\n                  {\n                    if (*p == L_('\\0'))\n                      return FNM_NOMATCH;\n                    /* XXX 1003.2d11 is unclear if this is right.  */\n                    ++p;\n                  }\n                else if (c == L_('[') && *p == L_(':'))\n                  {\n                    int c1 = 0;\n                    const CHAR *startp = p;\n\n                    while (1)\n                      {\n                        c = *++p;\n                        if (++c1 == CHAR_CLASS_MAX_LENGTH)\n                          return FNM_NOMATCH;\n\n                        if (*p == L_(':') && p[1] == L_(']'))\n                          break;\n\n                        if (c < L_('a') || c >= L_('z'))\n                          {\n                            p = startp;\n                            goto ignore_next;\n                          }\n                      }\n                    p += 2;\n                    c = *p++;\n                  }\n                else if (c == L_('[') && *p == L_('='))\n                  {\n                    c = *++p;\n                    if (c == L_('\\0'))\n                      return FNM_NOMATCH;\n                    c = *++p;\n                    if (c != L_('=') || p[1] != L_(']'))\n                      return FNM_NOMATCH;\n                    p += 2;\n                    c = *p++;\n                  }\n                else if (c == L_('[') && *p == L_('.'))\n                  {\n                    ++p;\n                    while (1)\n                      {\n                        c = *++p;\n                        if (c == '\\0')\n                          return FNM_NOMATCH;\n\n                        if (*p == L_('.') && p[1] == L_(']'))\n                          break;\n                      }\n                    p += 2;\n                    c = *p++;\n                  }\n              }\n            while (c != L_(']'));\n            if (not)\n              return FNM_NOMATCH;\n          }\n          break;\n\n        case L_('+'):\n        case L_('@'):\n        case L_('!'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period, flags);\n              if (res != -1)\n                return res;\n            }\n          goto normal_match;\n\n        case L_('/'):\n          if (NO_LEADING_PERIOD (flags))\n            {\n              if (n == string_end || c != (UCHAR) *n)\n                return FNM_NOMATCH;\n\n              new_no_leading_period = true;\n              break;\n            }\n          FALLTHROUGH;\n        default:\n        normal_match:\n          if (n == string_end || c != FOLD ((UCHAR) *n))\n            return FNM_NOMATCH;\n        }\n\n      no_leading_period = new_no_leading_period;\n      ++n;\n    }\n\n  if (n == string_end)\n    return 0;\n\n  if ((flags & FNM_LEADING_DIR) && n != string_end && *n == L_('/'))\n    /* The FNM_LEADING_DIR flag says that \"foo*\" matches \"foobar/frobozz\".  */\n    return 0;\n\n  return FNM_NOMATCH;\n}",
        "lines": 959,
        "depth": 36,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          984,
          0
        ],
        "end_point": [
          1020,
          1
        ],
        "content": "static const CHAR *\ninternal_function\nEND (const CHAR *pattern)\n{\n  const CHAR *p = pattern;\n\n  while (1)\n    if (*++p == L_('\\0'))\n      /* This is an invalid pattern.  */\n      return pattern;\n    else if (*p == L_('['))\n      {\n        /* Handle brackets special.  */\n        if (posixly_correct == 0)\n          posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n        /* Skip the not sign.  We have to recognize it because of a possibly\n           following ']'.  */\n        if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))\n          ++p;\n        /* A leading ']' is recognized as such.  */\n        if (*p == L_(']'))\n          ++p;\n        /* Skip over all characters of the list.  */\n        while (*p != L_(']'))\n          if (*p++ == L_('\\0'))\n            /* This is no valid pattern.  */\n            return pattern;\n      }\n    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')\n              || *p == L_('!')) && p[1] == L_('('))\n      p = END (p + 1);\n    else if (*p == L_(')'))\n      break;\n\n  return p + 1;\n}",
        "lines": 37,
        "depth": 18,
        "decorators": [
          "static",
          "static",
          "const",
          "const",
          "CHAR",
          "*\ninternal_function\nEND (const CHAR *pattern)",
          "*"
        ]
      },
      {
        "start_point": [
          1023,
          0
        ],
        "end_point": [
          1201,
          1
        ],
        "content": "static int\ninternal_function\nEXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,\n     bool no_leading_period, int flags)\n{\n  const CHAR *startp;\n  size_t level;\n  struct patternlist\n  {\n    struct patternlist *next;\n    CHAR str[FLEXIBLE_ARRAY_MEMBER];\n  } *list = NULL;\n  struct patternlist **lastp = &list;\n  size_t pattern_len = STRLEN (pattern);\n  const CHAR *p;\n  const CHAR *rs;\n  enum { ALLOCA_LIMIT = 8000 };\n\n  /* Parse the pattern.  Store the individual parts in the list.  */\n  level = 0;\n  for (startp = p = pattern + 1; ; ++p)\n    if (*p == L_('\\0'))\n      /* This is an invalid pattern.  */\n      return -1;\n    else if (*p == L_('['))\n      {\n        /* Handle brackets special.  */\n        if (posixly_correct == 0)\n          posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n        /* Skip the not sign.  We have to recognize it because of a possibly\n           following ']'.  */\n        if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))\n          ++p;\n        /* A leading ']' is recognized as such.  */\n        if (*p == L_(']'))\n          ++p;\n        /* Skip over all characters of the list.  */\n        while (*p != L_(']'))\n          if (*p++ == L_('\\0'))\n            /* This is no valid pattern.  */\n            return -1;\n      }\n    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')\n              || *p == L_('!')) && p[1] == L_('('))\n      /* Remember the nesting level.  */\n      ++level;\n    else if (*p == L_(')'))\n      {\n        if (level-- == 0)\n          {\n            /* This means we found the end of the pattern.  */\n#define NEW_PATTERN \\\n            struct patternlist *newp;                                         \\\n            size_t plen;                                                      \\\n            size_t plensize;                                                  \\\n            size_t newpsize;                                                  \\\n                                                                              \\\n            plen = (opt == L_('?') || opt == L_('@')                          \\\n                    ? pattern_len                                             \\\n                    : p - startp + 1UL);                                      \\\n            plensize = plen * sizeof (CHAR);                                  \\\n            newpsize = FLEXSIZEOF (struct patternlist, str, plensize);        \\\n            if ((size_t) -1 / sizeof (CHAR) < plen                            \\\n                || newpsize < offsetof (struct patternlist, str)              \\\n                || ALLOCA_LIMIT <= newpsize)                                  \\\n              return -1;                                                      \\\n            newp = (struct patternlist *) alloca (newpsize);                  \\\n            *((CHAR *) MEMPCPY (newp->str, startp, p - startp)) = L_('\\0');    \\\n            newp->next = NULL;                                                \\\n            *lastp = newp;                                                    \\\n            lastp = &newp->next\n            NEW_PATTERN;\n            break;\n          }\n      }\n    else if (*p == L_('|'))\n      {\n        if (level == 0)\n          {\n            NEW_PATTERN;\n            startp = p + 1;\n          }\n      }\n  assert (list != NULL);\n  assert (p[-1] == L_(')'));\n#undef NEW_PATTERN\n\n  switch (opt)\n    {\n    case L_('*'):\n      if (FCT (p, string, string_end, no_leading_period, flags) == 0)\n        return 0;\n      FALLTHROUGH;\n    case L_('+'):\n      do\n        {\n          for (rs = string; rs <= string_end; ++rs)\n            /* First match the prefix with the current pattern with the\n               current pattern.  */\n            if (FCT (list->str, string, rs, no_leading_period,\n                     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0\n                /* This was successful.  Now match the rest with the rest\n                   of the pattern.  */\n                && (FCT (p, rs, string_end,\n                         rs == string\n                         ? no_leading_period\n                         : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                         flags & FNM_FILE_NAME\n                         ? flags : flags & ~FNM_PERIOD) == 0\n                    /* This didn't work.  Try the whole pattern.  */\n                    || (rs != string\n                        && FCT (pattern - 1, rs, string_end,\n                                rs == string\n                                ? no_leading_period\n                                : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                                flags & FNM_FILE_NAME\n                                ? flags : flags & ~FNM_PERIOD) == 0)))\n              /* It worked.  Signal success.  */\n              return 0;\n        }\n      while ((list = list->next) != NULL);\n\n      /* None of the patterns lead to a match.  */\n      return FNM_NOMATCH;\n\n    case L_('?'):\n      if (FCT (p, string, string_end, no_leading_period, flags) == 0)\n        return 0;\n      FALLTHROUGH;\n    case L_('@'):\n      do\n        /* I cannot believe it but 'strcat' is actually acceptable\n           here.  Match the entire string with the prefix from the\n           pattern list and the rest of the pattern following the\n           pattern list.  */\n        if (FCT (STRCAT (list->str, p), string, string_end,\n                 no_leading_period,\n                 flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0)\n          /* It worked.  Signal success.  */\n          return 0;\n      while ((list = list->next) != NULL);\n\n      /* None of the patterns lead to a match.  */\n      return FNM_NOMATCH;\n\n    case L_('!'):\n      for (rs = string; rs <= string_end; ++rs)\n        {\n          struct patternlist *runp;\n\n          for (runp = list; runp != NULL; runp = runp->next)\n            if (FCT (runp->str, string, rs,  no_leading_period,\n                     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0)\n              break;\n\n          /* If none of the patterns matched see whether the rest does.  */\n          if (runp == NULL\n              && (FCT (p, rs, string_end,\n                       rs == string\n                       ? no_leading_period\n                       : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                       flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD)\n                  == 0))\n            /* This is successful.  */\n            return 0;\n        }\n\n      /* None of the patterns together with the rest of the pattern\n         lead to a match.  */\n      return FNM_NOMATCH;\n\n    default:\n      assert (! \"Invalid extended matching operator\");\n      break;\n    }\n\n  return -1;\n}",
        "lines": 179,
        "depth": 23,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ]
  },
  "tar/tar-1.30/gnu/fpending.c": {
    "__fpending": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "size_t\n__fpending (FILE *fp)\n{\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n  return fp->_IO_write_ptr - fp->_IO_write_base;\n#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  return fp->_p - fp->_bf._base;\n#elif defined __EMX__                /* emx+gcc */\n  return fp->_ptr - fp->_buffer;\n#elif defined __minix                /* Minix */\n  return fp_->_ptr - fp_->_buf;\n#elif defined _IOERR                 /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, MSVC, NonStop Kernel, OpenVMS */\n  return (fp_->_ptr ? fp_->_ptr - fp_->_base : 0);\n#elif defined __UCLIBC__             /* uClibc */\n  return (fp->__modeflags & __FLAG_WRITING ? fp->__bufpos - fp->__bufstart : 0);\n#elif defined __QNX__                /* QNX */\n  return (fp->_Mode & 0x2000 /*_MWRITE*/ ? fp->_Next - fp->_Buf : 0);\n#elif defined __MINT__               /* Atari FreeMiNT */\n  return fp->__bufp - fp->__buffer;\n#elif defined EPLAN9                 /* Plan9 */\n  return fp->wp - fp->buf;\n#else\n# error \"Please port gnulib fpending.c to your platform!\"\n  return 1;\n#endif\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/fpending.h": {},
  "tar/tar-1.30/gnu/fprintftime.c": {},
  "tar/tar-1.30/gnu/fprintftime.h": {},
  "tar/tar-1.30/gnu/fseek.c": {
    "fseek": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nfseek (FILE *fp, long offset, int whence)\n{\n  /* Use the replacement fseeko function with all its workarounds.  */\n  return fseeko (fp, (off_t)offset, whence);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fseeko.c": {},
  "tar/tar-1.30/gnu/fstat.c": {
    "orig_fstat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\norig_fstat (int fd, struct stat *buf)\n{\n  return fstat (fd, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstat": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nrpl_fstat (int fd, struct stat *buf)\n{\n#if REPLACE_FCHDIR && REPLACE_OPEN_DIRECTORY\n  /* Handle the case when rpl_open() used a dummy file descriptor to work\n     around an open() that can't normally visit directories.  */\n  const char *name = _gl_directory_name (fd);\n  if (name != NULL)\n    return stat (name, buf);\n#endif\n\n#ifdef WINDOWS_NATIVE\n  /* Fill the fields ourselves, because the original fstat function returns\n     values for st_atime, st_mtime, st_ctime that depend on the current time\n     zone.  See\n     <https://lists.gnu.org/r/bug-gnulib/2017-04/msg00134.html>  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  return _gl_fstat_by_handle (h, NULL, buf);\n#else\n  return orig_fstat (fd, buf);\n#endif\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/fstatat.c": {
    "orig_fstatat": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static int\norig_fstatat (int fd, char const *filename, struct stat *buf, int flags)\n{\n  return fstatat (fd, filename, buf, flags);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstatat": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nrpl_fstatat (int fd, char const *file, struct stat *st, int flag)\n{\n  int result = orig_fstatat (fd, file, st, flag);\n  size_t len;\n\n  if (LSTAT_FOLLOWS_SLASHED_SYMLINK || result != 0)\n    return result;\n  len = strlen (file);\n  if (flag & AT_SYMLINK_NOFOLLOW)\n    {\n      /* Fix lstat behavior.  */\n      if (file[len - 1] != '/' || S_ISDIR (st->st_mode))\n        return 0;\n      if (!S_ISLNK (st->st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      result = orig_fstatat (fd, file, st, flag & ~AT_SYMLINK_NOFOLLOW);\n    }\n  /* Fix stat behavior.  */\n  if (result == 0 && !S_ISDIR (st->st_mode) && file[len - 1] == '/')\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return result;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "stat_func": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nstat_func (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/full-write.c": {
    "full_rw": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "size_t\nfull_rw (int fd, const void *buf, size_t count)\n{\n  size_t total = 0;\n  const char *ptr = (const char *) buf;\n\n  while (count > 0)\n    {\n      size_t n_rw = safe_rw (fd, ptr, count);\n      if (n_rw == (size_t) -1)\n        break;\n      if (n_rw == 0)\n        {\n          errno = ZERO_BYTE_TRANSFER_ERRNO;\n          break;\n        }\n      total += n_rw;\n      ptr += n_rw;\n      count -= n_rw;\n    }\n\n  return total;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/full-write.h": {},
  "tar/tar-1.30/gnu/futimens.c": {
    "futimens": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nfutimens (int fd, struct timespec const times[2])\n{\n  /* fdutimens also works around bugs in native futimens, when running\n     with glibc compiled against newer headers but on a Linux kernel\n     older than 2.6.32.  */\n  return fdutimens (fd, NULL, times);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/get-permissions.c": {
    "get_permissions": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "int\nget_permissions (const char *name, int desc, mode_t mode,\n\t\t struct permission_context *ctx)\n{\n  memset (ctx, 0, sizeof *ctx);\n  ctx->mode = mode;\n\n#if USE_ACL && HAVE_ACL_GET_FILE\n  /* POSIX 1003.1e (draft 17 -- abandoned) specific version.  */\n  /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n# if !HAVE_ACL_TYPE_EXTENDED\n  /* Linux, FreeBSD, IRIX, Tru64 */\n\n  if (HAVE_ACL_GET_FD && desc != -1)\n    ctx->acl = acl_get_fd (desc);\n  else\n    ctx->acl = acl_get_file (name, ACL_TYPE_ACCESS);\n  if (ctx->acl == NULL)\n    return acl_errno_valid (errno) ? -1 : 0;\n\n  /* With POSIX ACLs, a file cannot have \"no\" acl; a file without\n     extended permissions has a \"minimal\" acl which is equivalent to the\n     file mode.  */\n\n  if (S_ISDIR (mode))\n    {\n      ctx->default_acl = acl_get_file (name, ACL_TYPE_DEFAULT);\n      if (ctx->default_acl == NULL)\n\treturn -1;\n    }\n\n# if HAVE_ACL_TYPE_NFS4  /* FreeBSD */\n\n  /* TODO (see set_permissions). */\n\n# endif\n\n#  else /* HAVE_ACL_TYPE_EXTENDED */\n  /* Mac OS X */\n\n  /* On Mac OS X,  acl_get_file (name, ACL_TYPE_ACCESS)\n     and           acl_get_file (name, ACL_TYPE_DEFAULT)\n     always return NULL / EINVAL.  You have to use\n                   acl_get_file (name, ACL_TYPE_EXTENDED)\n     or            acl_get_fd (open (name, ...))\n     to retrieve an ACL.\n     On the other hand,\n                   acl_set_file (name, ACL_TYPE_ACCESS, acl)\n     and           acl_set_file (name, ACL_TYPE_DEFAULT, acl)\n     have the same effect as\n                   acl_set_file (name, ACL_TYPE_EXTENDED, acl):\n     Each of these calls sets the file's ACL.  */\n\n  if (HAVE_ACL_GET_FD && desc != -1)\n    ctx->acl = acl_get_fd (desc);\n  else\n    ctx->acl = acl_get_file (name, ACL_TYPE_EXTENDED);\n  if (ctx->acl == NULL)\n    return acl_errno_valid (errno) ? -1 : 0;\n\n# endif\n\n#elif USE_ACL && defined GETACL /* Solaris, Cygwin, not HP-UX */\n\n  /* Solaris 2.5 through Solaris 10, Cygwin, and contemporaneous versions\n     of Unixware.  The acl() call returns the access and default ACL both\n     at once.  */\n# ifdef ACE_GETACL\n  /* Solaris also has a different variant of ACLs, used in ZFS and NFSv4\n     file systems (whereas the other ones are used in UFS file systems).\n     There is an API\n       pathconf (name, _PC_ACL_ENABLED)\n       fpathconf (desc, _PC_ACL_ENABLED)\n     that allows us to determine which of the two kinds of ACLs is supported\n     for the given file.  But some file systems may implement this call\n     incorrectly, so better not use it.\n     When fetching the source ACL, we simply fetch both ACL types.\n     When setting the destination ACL, we try either ACL types, assuming\n     that the kernel will translate the ACL from one form to the other.\n     (See in <http://docs.sun.com/app/docs/doc/819-2241/6n4huc7ia?l=en&a=view>\n     the description of ENOTSUP.)  */\n  for (;;)\n    {\n      int ret;\n\n      if (desc != -1)\n\tret = facl (desc, ACE_GETACLCNT, 0, NULL);\n      else\n\tret = acl (name, ACE_GETACLCNT, 0, NULL);\n      if (ret < 0)\n\t{\n\t  if (errno == ENOSYS || errno == EINVAL)\n\t    ret = 0;\n\t  else\n\t    return -1;\n\t}\n      ctx->ace_count = ret;\n\n      if (ctx->ace_count == 0)\n        break;\n\n      ctx->ace_entries = (ace_t *) malloc (ctx->ace_count * sizeof (ace_t));\n      if (ctx->ace_entries == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n\n      if (desc != -1)\n\tret = facl (desc, ACE_GETACL, ctx->ace_count, ctx->ace_entries);\n      else\n\tret = acl (name, ACE_GETACL, ctx->ace_count, ctx->ace_entries);\n      if (ret < 0)\n        {\n          if (errno == ENOSYS || errno == EINVAL)\n            {\n\t      free (ctx->ace_entries);\n\t      ctx->ace_entries = NULL;\n              ctx->ace_count = 0;\n              break;\n            }\n          else\n            return -1;\n        }\n      if (ret <= ctx->ace_count)\n\t{\n\t  ctx->ace_count = ret;\n\t  break;\n\t}\n      /* Huh? The number of ACL entries has increased since the last call.\n         Repeat.  */\n      free (ctx->ace_entries);\n      ctx->ace_entries = NULL;\n    }\n# endif\n\n  for (;;)\n    {\n      int ret;\n\n      if (desc != -1)\n\tret = facl (desc, GETACLCNT, 0, NULL);\n      else\n\tret = acl (name, GETACLCNT, 0, NULL);\n      if (ret < 0)\n\t{\n\t  if (errno == ENOSYS || errno == ENOTSUP || errno == EOPNOTSUPP)\n\t    ret = 0;\n\t  else\n\t    return -1;\n\t}\n      ctx->count = ret;\n\n      if (ctx->count == 0)\n\tbreak;\n\n      ctx->entries = (aclent_t *) malloc (ctx->count * sizeof (aclent_t));\n      if (ctx->entries == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n\n      if (desc != -1)\n\tret = facl (desc, GETACL, ctx->count, ctx->entries);\n      else\n\tret = acl (name, GETACL, ctx->count, ctx->entries);\n      if (ret < 0)\n\t{\n\t  if (errno == ENOSYS || errno == ENOTSUP || errno == EOPNOTSUPP)\n\t    {\n\t      free (ctx->entries);\n\t      ctx->entries = NULL;\n\t      ctx->count = 0;\n\t      break;\n\t    }\n\t  else\n\t    return -1;\n\t}\n      if (ret <= ctx->count)\n\t{\n\t  ctx->count = ret;\n\t  break;\n\t}\n      /* Huh? The number of ACL entries has increased since the last call.\n         Repeat.  */\n      free (ctx->entries);\n      ctx->entries = NULL;\n    }\n\n#elif USE_ACL && HAVE_GETACL /* HP-UX */\n\n  {\n    int ret;\n\n    if (desc != -1)\n      ret = fgetacl (desc, NACLENTRIES, ctx->entries);\n    else\n      ret = getacl (name, NACLENTRIES, ctx->entries);\n    if (ret < 0)\n      {\n        if (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n          ret = 0;\n        else\n          return -1;\n      }\n    else if (ret > NACLENTRIES)\n      /* If NACLENTRIES cannot be trusted, use dynamic memory allocation.  */\n      abort ();\n    ctx->count = ret;\n\n# if HAVE_ACLV_H\n    ret = acl ((char *) name, ACL_GET, NACLVENTRIES, ctx->aclv_entries);\n    if (ret < 0)\n      {\n        if (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n          ret = 0;\n        else\n          return -2;\n      }\n    else if (ret > NACLVENTRIES)\n      /* If NACLVENTRIES cannot be trusted, use dynamic memory allocation.  */\n      abort ();\n    ctx->aclv_count = ret;\n# endif\n  }\n\n#elif USE_ACL && HAVE_ACLX_GET && ACL_AIX_WIP /* AIX */\n\n  /* TODO (see set_permissions). */\n\n#elif USE_ACL && HAVE_STATACL /* older AIX */\n\n  {\n    int ret;\n    if (desc != -1)\n      ret = fstatacl (desc, STX_NORMAL, &ctx->u.a, sizeof ctx->u);\n    else\n      ret = statacl ((char *) name, STX_NORMAL, &ctx->u.a, sizeof ctx->u);\n    if (ret == 0)\n      ctx->have_u = true;\n  }\n\n#elif USE_ACL && HAVE_ACLSORT /* NonStop Kernel */\n\n  {\n    int ret = acl ((char *) name, ACL_GET, NACLENTRIES, ctx->entries);\n    if (ret < 0)\n      return -1;\n    else if (ret > NACLENTRIES)\n      /* If NACLENTRIES cannot be trusted, use dynamic memory allocation.  */\n      abort ();\n    ctx->count = ret;\n  }\n\n#endif\n\n  return 0;\n\n}",
      "lines": 260,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/getcwd-lgpl.c": {
    "rpl_getcwd": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "char *\nrpl_getcwd (char *buf, size_t size)\n{\n  char *ptr;\n  char *result;\n\n  /* Handle single size operations.  */\n  if (buf)\n    {\n      if (!size)\n        {\n          errno = EINVAL;\n          return NULL;\n        }\n      return getcwd (buf, size);\n    }\n\n  if (size)\n    {\n      buf = malloc (size);\n      if (!buf)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n      result = getcwd (buf, size);\n      if (!result)\n        {\n          int saved_errno = errno;\n          free (buf);\n          errno = saved_errno;\n        }\n      return result;\n    }\n\n  /* Flexible sizing requested.  Avoid over-allocation for the common\n     case of a name that fits within a 4k page, minus some space for\n     local variables, to be sure we don't skip over a guard page.  */\n  {\n    char tmp[4032];\n    size = sizeof tmp;\n    ptr = getcwd (tmp, size);\n    if (ptr)\n      {\n        result = strdup (ptr);\n        if (!result)\n          errno = ENOMEM;\n        return result;\n      }\n    if (errno != ERANGE)\n      return NULL;\n  }\n\n  /* My what a large directory name we have.  */\n  do\n    {\n      size <<= 1;\n      ptr = realloc (buf, size);\n      if (ptr == NULL)\n        {\n          free (buf);\n          errno = ENOMEM;\n          return NULL;\n        }\n      buf = ptr;\n      result = getcwd (buf, size);\n    }\n  while (!result && errno == ERANGE);\n\n  if (!result)\n    {\n      int saved_errno = errno;\n      free (buf);\n      errno = saved_errno;\n    }\n  else\n    {\n      /* Trim to fit, if possible.  */\n      result = realloc (buf, strlen (buf) + 1);\n      if (!result)\n        result = buf;\n    }\n  return result;\n}",
      "lines": 84,
      "depth": 12,
      "decorators": [
        "char",
        "*\nrpl_getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/getcwd.c": {
    "__getcwd": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "char *\n__getcwd (char *buf, size_t size)\n{\n  /* Lengths of big file name components and entire file names, and a\n     deep level of file name nesting.  These numbers are not upper\n     bounds; they are merely large values suitable for initial\n     allocations, designed to be large enough for most real-world\n     uses.  */\n  enum\n    {\n      BIG_FILE_NAME_COMPONENT_LENGTH = 255,\n      BIG_FILE_NAME_LENGTH = MIN (4095, PATH_MAX - 1),\n      DEEP_NESTING = 100\n    };\n\n#if HAVE_OPENAT_SUPPORT\n  int fd = AT_FDCWD;\n  bool fd_needs_closing = false;\n#else\n  char dots[DEEP_NESTING * sizeof \"..\" + BIG_FILE_NAME_COMPONENT_LENGTH + 1];\n  char *dotlist = dots;\n  size_t dotsize = sizeof dots;\n  size_t dotlen = 0;\n#endif\n  DIR *dirstream = NULL;\n  dev_t rootdev, thisdev;\n  ino_t rootino, thisino;\n  char *dir;\n  register char *dirp;\n  struct stat st;\n  size_t allocated = size;\n  size_t used;\n\n#if HAVE_MINIMALLY_WORKING_GETCWD\n  /* If AT_FDCWD is not defined, the algorithm below is O(N**2) and\n     this is much slower than the system getcwd (at least on\n     GNU/Linux).  So trust the system getcwd's results unless they\n     look suspicious.\n\n     Use the system getcwd even if we have openat support, since the\n     system getcwd works even when a parent is unreadable, while the\n     openat-based approach does not.\n\n     But on AIX 5.1..7.1, the system getcwd is not even minimally\n     working: If the current directory name is slightly longer than\n     PATH_MAX, it omits the first directory component and returns\n     this wrong result with errno = 0.  */\n\n# undef getcwd\n  dir = getcwd (buf, size);\n  if (dir || (size && errno == ERANGE))\n    return dir;\n\n  /* Solaris getcwd (NULL, 0) fails with errno == EINVAL, but it has\n     internal magic that lets it work even if an ancestor directory is\n     inaccessible, which is better in many cases.  So in this case try\n     again with a buffer that's almost always big enough.  */\n  if (errno == EINVAL && buf == NULL && size == 0)\n    {\n      char big_buffer[BIG_FILE_NAME_LENGTH + 1];\n      dir = getcwd (big_buffer, sizeof big_buffer);\n      if (dir)\n        return strdup (dir);\n    }\n\n# if HAVE_PARTLY_WORKING_GETCWD\n  /* The system getcwd works, except it sometimes fails when it\n     shouldn't, setting errno to ERANGE, ENAMETOOLONG, or ENOENT.    */\n  if (errno != ERANGE && errno != ENAMETOOLONG && errno != ENOENT)\n    return NULL;\n# endif\n#endif\n\n  if (size == 0)\n    {\n      if (buf != NULL)\n        {\n          __set_errno (EINVAL);\n          return NULL;\n        }\n\n      allocated = BIG_FILE_NAME_LENGTH + 1;\n    }\n\n  if (buf == NULL)\n    {\n      dir = malloc (allocated);\n      if (dir == NULL)\n        return NULL;\n    }\n  else\n    dir = buf;\n\n  dirp = dir + allocated;\n  *--dirp = '\\0';\n\n  if (__lstat (\".\", &st) < 0)\n    goto lose;\n  thisdev = st.st_dev;\n  thisino = st.st_ino;\n\n  if (__lstat (\"/\", &st) < 0)\n    goto lose;\n  rootdev = st.st_dev;\n  rootino = st.st_ino;\n\n  while (!(thisdev == rootdev && thisino == rootino))\n    {\n      struct dirent *d;\n      dev_t dotdev;\n      ino_t dotino;\n      bool mount_point;\n      int parent_status;\n      size_t dirroom;\n      size_t namlen;\n      bool use_d_ino = true;\n\n      /* Look at the parent directory.  */\n#if HAVE_OPENAT_SUPPORT\n      fd = openat (fd, \"..\", O_RDONLY);\n      if (fd < 0)\n        goto lose;\n      fd_needs_closing = true;\n      parent_status = fstat (fd, &st);\n#else\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen] = '\\0';\n      parent_status = __lstat (dotlist, &st);\n#endif\n      if (parent_status != 0)\n        goto lose;\n\n      if (dirstream && __closedir (dirstream) != 0)\n        {\n          dirstream = NULL;\n          goto lose;\n        }\n\n      /* Figure out if this directory is a mount point.  */\n      dotdev = st.st_dev;\n      dotino = st.st_ino;\n      mount_point = dotdev != thisdev;\n\n      /* Search for the last directory.  */\n#if HAVE_OPENAT_SUPPORT\n      dirstream = fdopendir (fd);\n      if (dirstream == NULL)\n        goto lose;\n      fd_needs_closing = false;\n#else\n      dirstream = __opendir (dotlist);\n      if (dirstream == NULL)\n        goto lose;\n      dotlist[dotlen++] = '/';\n#endif\n      for (;;)\n        {\n          /* Clear errno to distinguish EOF from error if readdir returns\n             NULL.  */\n          __set_errno (0);\n          d = __readdir (dirstream);\n\n          /* When we've iterated through all directory entries without finding\n             one with a matching d_ino, rewind the stream and consider each\n             name again, but this time, using lstat.  This is necessary in a\n             chroot on at least one system (glibc-2.3.6 + linux 2.6.12), where\n             .., ../.., ../../.., etc. all had the same device number, yet the\n             d_ino values for entries in / did not match those obtained\n             via lstat.  */\n          if (d == NULL && errno == 0 && use_d_ino)\n            {\n              use_d_ino = false;\n              rewinddir (dirstream);\n              d = __readdir (dirstream);\n            }\n\n          if (d == NULL)\n            {\n              if (errno == 0)\n                /* EOF on dirstream, which can mean e.g., that the current\n                   directory has been removed.  */\n                __set_errno (ENOENT);\n              goto lose;\n            }\n          if (d->d_name[0] == '.' &&\n              (d->d_name[1] == '\\0' ||\n               (d->d_name[1] == '.' && d->d_name[2] == '\\0')))\n            continue;\n\n          if (use_d_ino)\n            {\n              bool match = (MATCHING_INO (d, thisino) || mount_point);\n              if (! match)\n                continue;\n            }\n\n          {\n            int entry_status;\n#if HAVE_OPENAT_SUPPORT\n            entry_status = fstatat (fd, d->d_name, &st, AT_SYMLINK_NOFOLLOW);\n#else\n            /* Compute size needed for this file name, or for the file\n               name \"..\" in the same directory, whichever is larger.\n               Room for \"..\" might be needed the next time through\n               the outer loop.  */\n            size_t name_alloc = _D_ALLOC_NAMLEN (d);\n            size_t filesize = dotlen + MAX (sizeof \"..\", name_alloc);\n\n            if (filesize < dotlen)\n              goto memory_exhausted;\n\n            if (dotsize < filesize)\n              {\n                /* My, what a deep directory tree you have, Grandma.  */\n                size_t newsize = MAX (filesize, dotsize * 2);\n                size_t i;\n                if (newsize < dotsize)\n                  goto memory_exhausted;\n                if (dotlist != dots)\n                  free (dotlist);\n                dotlist = malloc (newsize);\n                if (dotlist == NULL)\n                  goto lose;\n                dotsize = newsize;\n\n                i = 0;\n                do\n                  {\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '/';\n                  }\n                while (i < dotlen);\n              }\n\n            memcpy (dotlist + dotlen, d->d_name, _D_ALLOC_NAMLEN (d));\n            entry_status = __lstat (dotlist, &st);\n#endif\n            /* We don't fail here if we cannot stat() a directory entry.\n               This can happen when (network) file systems fail.  If this\n               entry is in fact the one we are looking for we will find\n               out soon as we reach the end of the directory without\n               having found anything.  */\n            if (entry_status == 0 && S_ISDIR (st.st_mode)\n                && st.st_dev == thisdev && st.st_ino == thisino)\n              break;\n          }\n        }\n\n      dirroom = dirp - dir;\n      namlen = _D_EXACT_NAMLEN (d);\n\n      if (dirroom <= namlen)\n        {\n          if (size != 0)\n            {\n              __set_errno (ERANGE);\n              goto lose;\n            }\n          else\n            {\n              char *tmp;\n              size_t oldsize = allocated;\n\n              allocated += MAX (allocated, namlen);\n              if (allocated < oldsize\n                  || ! (tmp = realloc (dir, allocated)))\n                goto memory_exhausted;\n\n              /* Move current contents up to the end of the buffer.\n                 This is guaranteed to be non-overlapping.  */\n              dirp = memcpy (tmp + allocated - (oldsize - dirroom),\n                             tmp + dirroom,\n                             oldsize - dirroom);\n              dir = tmp;\n            }\n        }\n      dirp -= namlen;\n      memcpy (dirp, d->d_name, namlen);\n      *--dirp = '/';\n\n      thisdev = dotdev;\n      thisino = dotino;\n    }\n\n  if (dirstream && __closedir (dirstream) != 0)\n    {\n      dirstream = NULL;\n      goto lose;\n    }\n\n  if (dirp == &dir[allocated - 1])\n    *--dirp = '/';\n\n#if ! HAVE_OPENAT_SUPPORT\n  if (dotlist != dots)\n    free (dotlist);\n#endif\n\n  used = dir + allocated - dirp;\n  memmove (dir, dirp, used);\n\n  if (size == 0)\n    /* Ensure that the buffer is only as large as necessary.  */\n    buf = realloc (dir, used);\n\n  if (buf == NULL)\n    /* Either buf was NULL all along, or 'realloc' failed but\n       we still have the original string.  */\n    buf = dir;\n\n  return buf;\n\n memory_exhausted:\n  __set_errno (ENOMEM);\n lose:\n  {\n    int save = errno;\n    if (dirstream)\n      __closedir (dirstream);\n#if HAVE_OPENAT_SUPPORT\n    if (fd_needs_closing)\n      close (fd);\n#else\n    if (dotlist != dots)\n      free (dotlist);\n#endif\n    if (buf == NULL)\n      free (dir);\n    __set_errno (save);\n  }\n  return NULL;\n}",
      "lines": 334,
      "depth": 18,
      "decorators": [
        "char",
        "*\n__getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/getdelim.c": {
    "alloc_failed": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\nalloc_failed (void)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Avoid errno problem without using the realloc module; see:\n     https://lists.gnu.org/r/bug-gnulib/2016-08/msg00025.html  */\n  errno = ENOMEM;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getdelim": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "ssize_t\ngetdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n{\n  ssize_t result;\n  size_t cur_len = 0;\n\n  if (lineptr == NULL || n == NULL || fp == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  flockfile (fp);\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      char *new_lineptr;\n      *n = 120;\n      new_lineptr = (char *) realloc (*lineptr, *n);\n      if (new_lineptr == NULL)\n        {\n          alloc_failed ();\n          result = -1;\n          goto unlock_return;\n        }\n      *lineptr = new_lineptr;\n    }\n\n  for (;;)\n    {\n      int i;\n\n      i = getc_maybe_unlocked (fp);\n      if (i == EOF)\n        {\n          result = -1;\n          break;\n        }\n\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      if (cur_len + 1 >= *n)\n        {\n          size_t needed_max =\n            SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n          size_t needed = 2 * *n + 1;   /* Be generous. */\n          char *new_lineptr;\n\n          if (needed_max < needed)\n            needed = needed_max;\n          if (cur_len + 1 >= needed)\n            {\n              result = -1;\n              errno = EOVERFLOW;\n              goto unlock_return;\n            }\n\n          new_lineptr = (char *) realloc (*lineptr, needed);\n          if (new_lineptr == NULL)\n            {\n              alloc_failed ();\n              result = -1;\n              goto unlock_return;\n            }\n\n          *lineptr = new_lineptr;\n          *n = needed;\n        }\n\n      (*lineptr)[cur_len] = i;\n      cur_len++;\n\n      if (i == delimiter)\n        break;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len ? cur_len : result;\n\n unlock_return:\n  funlockfile (fp); /* doesn't set errno */\n\n  return result;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/getdtablesize.c": {
    "_setmaxstdio_nothrow": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "static int\n_setmaxstdio_nothrow (int newmax)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _setmaxstdio (newmax);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getdtablesize": [
      {
        "start_point": [
          56,
          0
        ],
        "end_point": [
          87,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  if (dtablesize == 0)\n    {\n      /* We are looking for the number N such that the valid file descriptors\n         are 0..N-1.  It can be obtained through a loop as follows:\n           {\n             int fd;\n             for (fd = 3; fd < 65536; fd++)\n               if (dup2 (0, fd) == -1)\n                 break;\n             return fd;\n           }\n         On Windows XP, the result is 2048.\n         The drawback of this loop is that it allocates memory for a libc\n         internal array that is never freed.\n\n         The number N can also be obtained as the upper bound for\n         _getmaxstdio ().  _getmaxstdio () returns the maximum number of open\n         FILE objects.  The sanity check in _setmaxstdio reveals the maximum\n         number of file descriptors.  This too allocates memory, but it is\n         freed when we call _setmaxstdio with the original value.  */\n      int orig_max_stdio = _getmaxstdio ();\n      unsigned int bound;\n      for (bound = 0x10000; _setmaxstdio_nothrow (bound) < 0; bound = bound / 2)\n        ;\n      _setmaxstdio_nothrow (orig_max_stdio);\n      dtablesize = bound;\n    }\n  return dtablesize;\n}",
        "lines": 32,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          108,
          0
        ],
        "end_point": [
          121,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  struct rlimit lim;\n\n  if (getrlimit (RLIMIT_NOFILE, &lim) == 0\n      && 0 <= lim.rlim_cur && lim.rlim_cur <= INT_MAX\n      && lim.rlim_cur != RLIM_INFINITY\n      && lim.rlim_cur != RLIM_SAVED_CUR\n      && lim.rlim_cur != RLIM_SAVED_MAX)\n    return lim.rlim_cur;\n\n  return INT_MAX;\n}",
        "lines": 14,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "tar/tar-1.30/gnu/getfilecon.c": {
    "map_to_failure": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\nmap_to_failure (int ret, security_context_t *con)\n{\n  if (ret == 0)\n    {\n      errno = ENOTSUP;\n      return -1;\n    }\n\n  if (ret == 10 && strcmp (*con, \"unlabeled\") == 0)\n    {\n      freecon (*con);\n      *con = NULL;\n      errno = ENODATA;\n      return -1;\n    }\n\n  return ret;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_getfilecon": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nrpl_getfilecon (char const *file, security_context_t *con)\n{\n  int ret = getfilecon (file, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_lgetfilecon": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nrpl_lgetfilecon (char const *file, security_context_t *con)\n{\n  int ret = lgetfilecon (file, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_fgetfilecon": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nrpl_fgetfilecon (int fd, security_context_t *con)\n{\n  int ret = fgetfilecon (fd, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/getgroups.c": {
    "getgroups": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\ngetgroups (int n _GL_UNUSED, GETGROUPS_T *groups _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_getgroups": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nrpl_getgroups (int n, gid_t *group)\n{\n  int n_groups;\n  GETGROUPS_T *gbuf;\n  int saved_errno;\n\n  if (n < 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  if (n != 0 || !GETGROUPS_ZERO_BUG)\n    {\n      int result;\n      if (sizeof *group == sizeof *gbuf)\n        return getgroups (n, (GETGROUPS_T *) group);\n\n      if (SIZE_MAX / sizeof *gbuf <= n)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      gbuf = malloc (n * sizeof *gbuf);\n      if (!gbuf)\n        return -1;\n      result = getgroups (n, gbuf);\n      if (0 <= result)\n        {\n          n = result;\n          while (n--)\n            group[n] = gbuf[n];\n        }\n      saved_errno = errno;\n      free (gbuf);\n      errno = saved_errno;\n      return result;\n    }\n\n  n = 20;\n  while (1)\n    {\n      /* No need to worry about address arithmetic overflow here,\n         since the ancient systems that we're running on have low\n         limits on the number of secondary groups.  */\n      gbuf = malloc (n * sizeof *gbuf);\n      if (!gbuf)\n        return -1;\n      n_groups = getgroups (n, gbuf);\n      if (n_groups == -1 ? errno != EINVAL : n_groups < n)\n        break;\n      free (gbuf);\n      n *= 2;\n    }\n\n  saved_errno = errno;\n  free (gbuf);\n  errno = saved_errno;\n\n  return n_groups;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/getline.c": {
    "getline": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "ssize_t\ngetline (char **lineptr, size_t *n, FILE *stream)\n{\n  return getdelim (lineptr, n, '\\n', stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/getopt-cdefs.in.h": {},
  "tar/tar-1.30/gnu/getopt-core.h": {},
  "tar/tar-1.30/gnu/getopt-ext.h": {
    "struct": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "__BEGIN_DECLS\n\n/* Describe the long-named options requested by the application.\n   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector\n   of 'struct option' terminated by an element containing a name which is\n   zero.\n\n   The field 'has_arg' is:\n   no_argument\t\t(or 0) if the option does not take an argument,\n   required_argument\t(or 1) if the option requires an argument,\n   optional_argument \t(or 2) if the option takes an optional argument.\n\n   If the field 'flag' is not NULL, it points to a variable that is set\n   to the value given in the field 'val' when the option is found, but\n   left unchanged if the option is not found.\n\n   To have a long-named option do something other than set an 'int' to\n   a compiled-in constant, such as set a value from 'optarg', set the\n   option's 'flag' field to zero and its 'val' field to a nonzero\n   value (the equivalent single-letter option character, if there is\n   one).  For long options that have a zero 'flag' field, 'getopt'\n   returns the contents of the 'val' field.  */\n\nstruct option\n{\n  const char *name;\n  /* has_arg can't be an enum because some compilers complain about\n     type mismatches in all the code that assumes it is an int.  */\n  int has_arg;\n  int *flag;\n  int val;\n}",
      "lines": 32,
      "depth": 5,
      "decorators": null
    }
  },
  "tar/tar-1.30/gnu/getopt-pfx-core.h": {},
  "tar/tar-1.30/gnu/getopt-pfx-ext.h": {},
  "tar/tar-1.30/gnu/getopt.c": {
    "exchange": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n\t{\n\t  /* Bottom segment is the short one.  */\n\t  int len = middle - bottom;\n\t  int i;\n\n\t  /* Swap it with the top part of the top segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n\t      argv[top - (middle - bottom) + i] = tem;\n\t    }\n\t  /* Exclude the moved bottom segment from further swapping.  */\n\t  top -= len;\n\t}\n      else\n\t{\n\t  /* Top segment is the short one.  */\n\t  int len = top - middle;\n\t  int i;\n\n\t  /* Swap it with the bottom part of the bottom segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[middle + i];\n\t      argv[middle + i] = tem;\n\t    }\n\t  /* Exclude the moved top segment from further swapping.  */\n\t  bottom += len;\n\t}\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_long_option": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "static int\nprocess_long_option (int argc, char **argv, const char *optstring,\n\t\t     const struct option *longopts, int *longind,\n\t\t     int long_only, struct _getopt_data *d,\n\t\t     int print_errors, const char *prefix)\n{\n  char *nameend;\n  size_t namelen;\n  const struct option *p;\n  const struct option *pfound = NULL;\n  int n_options;\n  int option_index;\n\n  for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n    /* Do nothing.  */ ;\n  namelen = nameend - d->__nextchar;\n\n  /* First look for an exact match, counting the options as a side\n     effect.  */\n  for (p = longopts, n_options = 0; p->name; p++, n_options++)\n    if (!strncmp (p->name, d->__nextchar, namelen)\n\t&& namelen == strlen (p->name))\n      {\n\t/* Exact match found.  */\n\tpfound = p;\n\toption_index = n_options;\n\tbreak;\n      }\n\n  if (pfound == NULL)\n    {\n      /* Didn't find an exact match, so look for abbreviations.  */\n      unsigned char *ambig_set = NULL;\n      int ambig_malloced = 0;\n      int ambig_fallback = 0;\n      int indfound = -1;\n\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n\tif (!strncmp (p->name, d->__nextchar, namelen))\n\t  {\n\t    if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else if (long_only\n\t\t     || pfound->has_arg != p->has_arg\n\t\t     || pfound->flag != p->flag\n\t\t     || pfound->val != p->val)\n\t      {\n\t\t/* Second or later nonexact match found.  */\n\t\tif (!ambig_fallback)\n\t\t  {\n\t\t    if (!print_errors)\n\t\t      /* Don't waste effort tracking the ambig set if\n\t\t\t we're not going to print it anyway.  */\n\t\t      ambig_fallback = 1;\n\t\t    else if (!ambig_set)\n\t\t      {\n\t\t\tif (__libc_use_alloca (n_options))\n\t\t\t  ambig_set = alloca (n_options);\n\t\t\telse if ((ambig_set = malloc (n_options)) == NULL)\n\t\t\t  /* Fall back to simpler error message.  */\n\t\t\t  ambig_fallback = 1;\n\t\t\telse\n\t\t\t  ambig_malloced = 1;\n\n\t\t\tif (ambig_set)\n\t\t\t  {\n\t\t\t    memset (ambig_set, 0, n_options);\n\t\t\t    ambig_set[indfound] = 1;\n\t\t\t  }\n\t\t      }\n\t\t    if (ambig_set)\n\t\t      ambig_set[option_index] = 1;\n\t\t  }\n\t      }\n\t  }\n\n      if (ambig_set || ambig_fallback)\n\t{\n\t  if (print_errors)\n\t    {\n\t      if (ambig_fallback)\n\t\tfprintf (stderr, _(\"%s: option '%s%s' is ambiguous\\n\"),\n\t\t\t argv[0], prefix, d->__nextchar);\n\t      else\n\t\t{\n\t\t  flockfile (stderr);\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option '%s%s' is ambiguous; possibilities:\"),\n\t\t\t   argv[0], prefix, d->__nextchar);\n\n\t\t  for (option_index = 0; option_index < n_options; option_index++)\n\t\t    if (ambig_set[option_index])\n\t\t      fprintf (stderr, \" '%s%s'\",\n\t\t\t       prefix, longopts[option_index].name);\n\n\t\t  /* This must use 'fprintf' even though it's only\n\t\t     printing a single character, so that it goes through\n\t\t     __fxprintf_nocancel when compiled as part of glibc.  */\n\t\t  fprintf (stderr, \"\\n\");\n\t\t  funlockfile (stderr);\n\t\t}\n\t    }\n\t  if (ambig_malloced)\n\t    free (ambig_set);\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      option_index = indfound;\n    }\n\n  if (pfound == NULL)\n    {\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short option,\n\t then it's an error.  */\n      if (!long_only || argv[d->optind][1] == '-'\n\t  || strchr (optstring, *d->__nextchar) == NULL)\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr, _(\"%s: unrecognized option '%s%s'\\n\"),\n\t\t     argv[0], prefix, d->__nextchar);\n\n\t  d->__nextchar = NULL;\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      /* Otherwise interpret it as a short option.  */\n      return -1;\n    }\n\n  /* We have found a matching long option.  Consume it.  */\n  d->optind++;\n  d->__nextchar = NULL;\n  if (*nameend)\n    {\n      /* Don't test has_arg with >, because some C compilers don't\n\t allow it to be used on enums.  */\n      if (pfound->has_arg)\n\td->optarg = nameend + 1;\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' doesn't allow an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return '?';\n\t}\n    }\n  else if (pfound->has_arg == 1)\n    {\n      if (d->optind < argc)\n\td->optarg = argv[d->optind++];\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' requires an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return optstring[0] == ':' ? ':' : '?';\n\t}\n    }\n\n  if (longind != NULL)\n    *longind = option_index;\n  if (pfound->flag)\n    {\n      *(pfound->flag) = pfound->val;\n      return 0;\n    }\n  return pfound->val;\n}",
      "lines": 184,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n  if (d->optind == 0)\n    d->optind = 1;\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n  d->__nextchar = NULL;\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (posixly_correct || !!getenv (\"POSIXLY_CORRECT\"))\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n  d->__initialized = 1;\n  return optstring;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n\t\t    const struct option *longopts, int *longind,\n\t\t    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.  */\n#define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n\t moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n\td->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n\td->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__last_nonopt != d->optind)\n\t    d->__first_nonopt = d->optind;\n\n\t  /* Skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (d->optind < argc && NONOPTION_P)\n\t    d->optind++;\n\t  d->__last_nonopt = d->optind;\n\t}\n\n      /* The special ARGV-element '--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n\t{\n\t  d->optind++;\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__first_nonopt == d->__last_nonopt)\n\t    d->__first_nonopt = d->optind;\n\t  d->__last_nonopt = argc;\n\n\t  d->optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (d->__first_nonopt != d->__last_nonopt)\n\t    d->optind = d->__first_nonopt;\n\t  return -1;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n\t{\n\t  if (d->__ordering == REQUIRE_ORDER)\n\t    return -1;\n\t  d->optarg = argv[d->optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Check whether it might be a long option.  */\n      if (longopts)\n\t{\n\t  if (argv[d->optind][1] == '-')\n\t    {\n\t      /* \"--foo\" is always a long option.  The special option\n\t\t \"--\" was handled above.  */\n\t      d->__nextchar = argv[d->optind] + 2;\n\t      return process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"--\");\n\t    }\n\n\t  /* If long_only and the ARGV-element has the form \"-f\",\n\t     where f is a valid short option, don't consider it an\n\t     abbreviated form of a long option that starts with f.\n\t     Otherwise there would be no way to give the -f short\n\t     option.\n\n\t     On the other hand, if there's a long option \"fubar\" and\n\t     the ARGV-element is \"-fu\", do consider that an\n\t     abbreviation of the long option, just like \"--fu\", and\n\t     not \"-f\" with arg \"u\".\n\n\t     This distinction seems to be the most useful approach.  */\n\t  if (long_only && (argv[d->optind][2]\n\t\t\t    || !strchr (optstring, argv[d->optind][1])))\n\t    {\n\t      int code;\n\t      d->__nextchar = argv[d->optind] + 1;\n\t      code = process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"-\");\n\t      if (code != -1)\n\t\treturn code;\n\t    }\n\t}\n\n      /* It is not a long option.  Skip the initial punctuation.  */\n      d->__nextchar = argv[d->optind] + 1;\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n\tif (print_errors)\n\t  fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n\td->optopt = c;\n\treturn '?';\n      }\n\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';' && longopts != NULL)\n      {\n\t/* This is an option that requires an argument.  */\n\tif (*d->__nextchar != '\\0')\n\t  d->optarg = d->__nextchar;\n\telse if (d->optind == argc)\n\t  {\n\t    if (print_errors)\n\t      fprintf (stderr,\n\t\t       _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t       argv[0], c);\n\n\t    d->optopt = c;\n\t    if (optstring[0] == ':')\n\t      c = ':';\n\t    else\n\t      c = '?';\n\t    return c;\n\t  }\n\telse\n\t  d->optarg = argv[d->optind];\n\n\td->__nextchar = d->optarg;\n\td->optarg = NULL;\n\treturn process_long_option (argc, argv, optstring, longopts, longind,\n\t\t\t\t    0 /* long_only */, d, print_errors, \"-W \");\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\td->optind++;\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\td->optind++;\n\t      }\n\t    else if (d->optind == argc)\n\t      {\n\t\tif (print_errors)\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t   argv[0], c);\n\n\t\td->optopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented 'optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      d->optarg = argv[d->optind++];\n\t    d->__nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}",
      "lines": 231,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        701,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n\t\t  const struct option *longopts, int *longind, int long_only,\n\t\t  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n\t\t\t       longind, long_only, &getopt_data,\n\t\t\t       posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/getopt.in.h": {},
  "tar/tar-1.30/gnu/getopt1.c": {
    "getopt_long": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n\t     const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n\t\tconst struct option *long_options, int *opt_index,\n\t\tstruct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n\t\t  const char *options,\n\t\t  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n\t\t     const struct option *long_options, int *opt_index,\n\t\t     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n\t{\"add\", 1, 0, 0},\n\t{\"append\", 0, 0, 0},\n\t{\"delete\", 1, 0, 0},\n\t{\"verbose\", 0, 0, 0},\n\t{\"create\", 0, 0, 0},\n\t{\"file\", 1, 0, 0},\n\t{0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n\t\t       long_options, &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  printf (\"option %s\", long_options[option_index].name);\n\t  if (optarg)\n\t    printf (\" with arg %s\", optarg);\n\t  printf (\"\\n\");\n\t  break;\n\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase 'd':\n\t  printf (\"option d with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/getopt_int.h": {},
  "tar/tar-1.30/gnu/getpagesize.c": {
    "getpagesize": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\ngetpagesize (void)\n{\n  SYSTEM_INFO system_info;\n  GetSystemInfo (&system_info);\n  return system_info.dwPageSize;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/getprogname.c": {
    "getprogname": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "char const *\ngetprogname (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return program_invocation_short_name;\n# elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return last_component (program_invocation_name);\n# elif HAVE_GETEXECNAME                                     /* Solaris */\n  /* https://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n  const char *p = getexecname ();\n  if (!p)\n    p = \"?\";\n  return last_component (p);\n# elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n  /* https://msdn.microsoft.com/en-us/library/dn727674.aspx */\n  const char *p = __argv && __argv[0] ? __argv[0] : \"?\";\n  return last_component (p);\n# elif HAVE_VAR___PROGNAME                                  /* OpenBSD, QNX */\n  /* https://man.openbsd.org/style.9 */\n  /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n  /* Be careful to declare this only when we absolutely need it\n     (OpenBSD 5.1), rather than when it's available.  Otherwise,\n     its mere declaration makes program_invocation_short_name\n     malfunction (have zero length) with Fedora 25's glibc.  */\n  extern char *__progname;\n  const char *p = __progname;\n  return p && p[0] ? p : \"?\";\n# elif _AIX                                                 /* AIX */\n  /* Idea by Bastien ROUCARI\u00c3\u0088S,\n     https://lists.gnu.org/r/bug-gnulib/2010-12/msg00095.html\n     Reference: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.basetrf1/getprocs.htm\n  */\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct procentry64 procs;\n      p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n           ? strdup (procs.pi_comm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif defined __hpux\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct pst_status status;\n      p = (0 < pstat_getproc (&status, sizeof status, 0, pid)\n           ? strdup (status.pst_ucomm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif __MVS__                                              /* z/OS */\n  /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n  static char *p = \"?\";\n  static int first = 1;\n  if (first)\n    {\n      pid_t pid = getpid ();\n      int token;\n      W_PSPROC buf;\n      first = 0;\n      memset (&buf, 0, sizeof(buf));\n      buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n      buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n      buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n      if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n        {\n          for (token = 0; token >= 0;\n               token = w_getpsent (token, &buf, sizeof(buf)))\n            {\n              if (token > 0 && buf.ps_pid == pid)\n                {\n                  char *s = strdup (last_component (buf.ps_pathptr));\n                  if (s)\n                    p = s;\n                  break;\n                }\n            }\n        }\n      free (buf.ps_cmdptr);\n      free (buf.ps_conttyptr);\n      free (buf.ps_pathptr);\n    }\n  return p;\n# elif defined __sgi                                        /* IRIX */\n  char filename[50];\n  int fd;\n\n  sprintf (filename, \"/proc/pinfo/%d\", (int) getpid ());\n  fd = open (filename, O_RDONLY);\n  if (0 <= fd)\n    {\n      prpsinfo_t buf;\n      int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);\n      close (fd);\n      if (ioctl_ok)\n        {\n          char *name = buf.pr_fname;\n          size_t namesize = sizeof buf.pr_fname;\n          char *namenul = memchr (name, '\\0', namesize);\n          size_t namelen = namenul ? namenul - name : namesize;\n          char *namecopy = malloc (namelen + 1);\n          if (namecopy)\n            {\n              namecopy[namelen] = 0;\n              return memcpy (namecopy, name, namelen);\n            }\n        }\n    }\n  return NULL;\n# else\n#  error \"getprogname module not ported to this OS\"\n# endif\n}",
      "lines": 126,
      "depth": 26,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ngetprogname (void)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/getprogname.h": {},
  "tar/tar-1.30/gnu/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n      found_translation = (translation != msg_ctxt_id);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n      found_translation = !(translation == msg_ctxt_id || translation == msgid_plural);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/gettime.c": {
    "gettime": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\ngettime (struct timespec *ts)\n{\n#if HAVE_NANOTIME\n  nanotime (ts);\n#else\n\n# if defined CLOCK_REALTIME && HAVE_CLOCK_GETTIME\n  if (clock_gettime (CLOCK_REALTIME, ts) == 0)\n    return;\n# endif\n\n  {\n    struct timeval tv;\n    gettimeofday (&tv, NULL);\n    ts->tv_sec = tv.tv_sec;\n    ts->tv_nsec = tv.tv_usec * 1000;\n  }\n\n#endif\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/gettimeofday.c": {
    "initialize": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static void\ninitialize (void)\n{\n  HMODULE kernel32 = LoadLibrary (\"kernel32.dll\");\n  if (kernel32 != NULL)\n    {\n      GetSystemTimePreciseAsFileTimeFunc =\n\t(GetSystemTimePreciseAsFileTimeFuncType) GetProcAddress (kernel32, \"GetSystemTimePreciseAsFileTime\");\n    }\n  initialized = TRUE;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#ifdef WINDOWS_NATIVE\n\n  /* On native Windows, there are two ways to get the current time:\n     GetSystemTimeAsFileTime\n     <https://msdn.microsoft.com/en-us/library/ms724397.aspx>\n     or\n     GetSystemTimePreciseAsFileTime\n     <https://msdn.microsoft.com/en-us/library/hh706895.aspx>.\n     GetSystemTimeAsFileTime produces values that jump by increments of\n     15.627 milliseconds (!) on average.\n     Whereas GetSystemTimePreciseAsFileTime values usually jump by 1 or 2\n     microseconds.\n     More discussion on this topic:\n     <http://www.windowstimestamp.com/description>.  */\n  FILETIME current_time;\n\n  if (!initialized)\n    initialize ();\n  if (GetSystemTimePreciseAsFileTimeFunc != NULL)\n    GetSystemTimePreciseAsFileTimeFunc (&current_time);\n  else\n    GetSystemTimeAsFileTime (&current_time);\n\n  /* Convert from FILETIME to 'struct timeval'.  */\n  /* FILETIME: <https://msdn.microsoft.com/en-us/library/ms724284.aspx> */\n  ULONGLONG since_1601 =\n    ((ULONGLONG) current_time.dwHighDateTime << 32)\n    | (ULONGLONG) current_time.dwLowDateTime;\n  /* Between 1601-01-01 and 1970-01-01 there were 280 normal years and 89 leap\n     years, in total 134774 days.  */\n  ULONGLONG since_1970 =\n    since_1601 - (ULONGLONG) 134774 * (ULONGLONG) 86400 * (ULONGLONG) 10000000;\n  ULONGLONG microseconds_since_1970 = since_1970 / (ULONGLONG) 10;\n  tv->tv_sec = microseconds_since_1970 / (ULONGLONG) 1000000;\n  tv->tv_usec = microseconds_since_1970 % (ULONGLONG) 1000000;\n\n  return 0;\n\n#else\n\n# if HAVE_GETTIMEOFDAY\n#  if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n#  endif\n\n#  if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#   undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n#  else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n#  endif\n\n#  if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n#  endif\n\n  return result;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n  return 0;\n\n# endif\n#endif\n}",
      "lines": 84,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/group-member.c": {
    "free_group_info": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\nfree_group_info (struct group_info const *g)\n{\n  if (g->group != g->groupbuf)\n    free (g->group);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_group_info": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nget_group_info (struct group_info *gi)\n{\n  int n_groups = getgroups (GROUPBUF_SIZE, gi->groupbuf);\n  gi->group = gi->groupbuf;\n\n  if (n_groups < 0)\n    {\n      int n_group_slots = getgroups (0, NULL);\n      if (0 <= n_group_slots\n          && ! xalloc_oversized (n_group_slots, sizeof *gi->group))\n        {\n          gi->group = malloc (n_group_slots * sizeof *gi->group);\n          if (gi->group)\n            n_groups = getgroups (n_group_slots, gi->group);\n        }\n    }\n\n  /* In case of error, the user loses.  */\n  return n_groups;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "group_member": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\ngroup_member (gid_t gid)\n{\n  int i;\n  int found;\n  struct group_info gi;\n  int n_groups = get_group_info (&gi);\n\n  /* Search through the list looking for GID. */\n  found = 0;\n  for (i = 0; i < n_groups; i++)\n    {\n      if (gid == gi.group[i])\n        {\n          found = 1;\n          break;\n        }\n    }\n\n  free_group_info (&gi);\n\n  return found;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n\n  for (i = 1; i < argc; i++)\n    {\n      gid_t gid;\n\n      gid = atoi (argv[i]);\n      printf (\"%d: %s\\n\", gid, group_member (gid) ? \"yes\" : \"no\");\n    }\n  exit (0);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/hard-locale.c": {
    "hard_locale": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "bool\nhard_locale (int category)\n{\n  bool hard = true;\n  char const *p = setlocale (category, NULL);\n\n  if (p)\n    {\n      if (2 <= GLIBC_VERSION)\n        {\n          if (strcmp (p, \"C\") == 0 || strcmp (p, \"POSIX\") == 0)\n            hard = false;\n        }\n      else\n        {\n          char *locale = strdup (p);\n          if (locale)\n            {\n              /* Temporarily set the locale to the \"C\" and \"POSIX\" locales\n                 to find their names, so that we can determine whether one\n                 or the other is the caller's locale.  */\n              if (((p = setlocale (category, \"C\"))\n                   && strcmp (p, locale) == 0)\n                  || ((p = setlocale (category, \"POSIX\"))\n                      && strcmp (p, locale) == 0))\n                hard = false;\n\n              /* Restore the caller's locale.  */\n              setlocale (category, locale);\n              free (locale);\n            }\n        }\n    }\n\n  return hard;\n}",
      "lines": 36,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "tar/tar-1.30/gnu/hard-locale.h": {},
  "tar/tar-1.30/gnu/hash.c": {
    "hash_get_n_buckets": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "size_t\nhash_get_n_buckets (const Hash_table *table)\n{\n  return table->n_buckets;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_buckets_used": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "size_t\nhash_get_n_buckets_used (const Hash_table *table)\n{\n  return table->n_buckets_used;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_entries": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "size_t\nhash_get_n_entries (const Hash_table *table)\n{\n  return table->n_entries;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_max_bucket_length": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "size_t\nhash_get_max_bucket_length (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t max_bucket_length = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n          size_t bucket_length = 1;\n\n          while (cursor = cursor->next, cursor)\n            bucket_length++;\n\n          if (bucket_length > max_bucket_length)\n            max_bucket_length = bucket_length;\n        }\n    }\n\n  return max_bucket_length;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "hash_table_ok": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "bool\nhash_table_ok (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t n_buckets_used = 0;\n  size_t n_entries = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n\n          /* Count bucket head.  */\n          n_buckets_used++;\n          n_entries++;\n\n          /* Count bucket overflow.  */\n          while (cursor = cursor->next, cursor)\n            n_entries++;\n        }\n    }\n\n  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)\n    return true;\n\n  return false;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "hash_print_statistics": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\nhash_print_statistics (const Hash_table *table, FILE *stream)\n{\n  size_t n_entries = hash_get_n_entries (table);\n  size_t n_buckets = hash_get_n_buckets (table);\n  size_t n_buckets_used = hash_get_n_buckets_used (table);\n  size_t max_bucket_length = hash_get_max_bucket_length (table);\n\n  fprintf (stream, \"# entries:         %lu\\n\", (unsigned long int) n_entries);\n  fprintf (stream, \"# buckets:         %lu\\n\", (unsigned long int) n_buckets);\n  fprintf (stream, \"# buckets used:    %lu (%.2f%%)\\n\",\n           (unsigned long int) n_buckets_used,\n           (100.0 * n_buckets_used) / n_buckets);\n  fprintf (stream, \"max bucket length: %lu\\n\",\n           (unsigned long int) max_bucket_length);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "safe_hasher": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static struct hash_entry *\nsafe_hasher (const Hash_table *table, const void *key)\n{\n  size_t n = table->hasher (key, table->n_buckets);\n  if (! (n < table->n_buckets))\n    abort ();\n  return table->bucket + n;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nsafe_hasher (const Hash_table *table, const void *key)",
        "*"
      ]
    },
    "hash_lookup": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "void *\nhash_lookup (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  if (bucket->data == NULL)\n    return NULL;\n\n  for (cursor = bucket; cursor; cursor = cursor->next)\n    if (entry == cursor->data || table->comparator (entry, cursor->data))\n      return cursor->data;\n\n  return NULL;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_lookup (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_first": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "void *\nhash_get_first (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n\n  if (table->n_entries == 0)\n    return NULL;\n\n  for (bucket = table->bucket; ; bucket++)\n    if (! (bucket < table->bucket_limit))\n      abort ();\n    else if (bucket->data)\n      return bucket->data;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_first (const Hash_table *table)",
        "*"
      ]
    },
    "hash_get_next": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "void *\nhash_get_next (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  /* Find next entry in the same bucket.  */\n  cursor = bucket;\n  do\n    {\n      if (cursor->data == entry && cursor->next)\n        return cursor->next->data;\n      cursor = cursor->next;\n    }\n  while (cursor != NULL);\n\n  /* Find first entry in any subsequent bucket.  */\n  while (++bucket < table->bucket_limit)\n    if (bucket->data)\n      return bucket->data;\n\n  /* None found.  */\n  return NULL;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_next (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_entries": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "size_t\nhash_get_entries (const Hash_table *table, void **buffer,\n                  size_t buffer_size)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (counter >= buffer_size)\n                return counter;\n              buffer[counter++] = cursor->data;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    },
    "hash_do_for_each": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "size_t\nhash_do_for_each (const Hash_table *table, Hash_processor processor,\n                  void *processor_data)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (! processor (cursor->data, processor_data))\n                return counter;\n              counter++;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "hash_string": [
      {
        "start_point": [
          403,
          0
        ],
        "end_point": [
          417,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n# define HASH_ONE_CHAR(Value, Byte) \\\n  ((Byte) + rotl_sz (Value, 7))\n\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = HASH_ONE_CHAR (value, ch);\n  return value % n_buckets;\n\n# undef HASH_ONE_CHAR\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "size_t"
        ]
      },
      {
        "start_point": [
          426,
          0
        ],
        "end_point": [
          435,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = (value * 31 + ch) % n_buckets;\n  return value;\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "size_t"
        ]
      }
    ],
    "_GL_ATTRIBUTE_CONST": [
      {
        "start_point": [
          442,
          0
        ],
        "end_point": [
          456,
          1
        ],
        "content": "static bool _GL_ATTRIBUTE_CONST\nis_prime (size_t candidate)\n{\n  size_t divisor = 3;\n  size_t square = divisor * divisor;\n\n  while (square < candidate && (candidate % divisor))\n    {\n      divisor++;\n      square += 4 * divisor;\n      divisor++;\n    }\n\n  return (candidate % divisor ? true : false);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          461,
          0
        ],
        "end_point": [
          475,
          1
        ],
        "content": "static size_t _GL_ATTRIBUTE_CONST\nnext_prime (size_t candidate)\n{\n  /* Skip small primes.  */\n  if (candidate < 10)\n    candidate = 10;\n\n  /* Make it definitely odd.  */\n  candidate |= 1;\n\n  while (SIZE_MAX != candidate && !is_prime (candidate))\n    candidate += 2;\n\n  return candidate;\n}",
        "lines": 15,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "size_t"
        ]
      }
    ],
    "hash_reset_tuning": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "void\nhash_reset_tuning (Hash_tuning *tuning)\n{\n  *tuning = default_tuning;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "raw_hasher": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "static size_t\nraw_hasher (const void *data, size_t n)\n{\n  /* When hashing unique pointers, it is often the case that they were\n     generated by malloc and thus have the property that the low-order\n     bits are 0.  As this tends to give poorer performance with small\n     tables, we rotate the pointer value before performing division,\n     in an attempt to improve hash quality.  */\n  size_t val = rotr_sz ((size_t) data, 3);\n  return val % n;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "raw_comparator": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "static bool\nraw_comparator (const void *a, const void *b)\n{\n  return a == b;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_tuning": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        536,
        1
      ],
      "content": "static bool\ncheck_tuning (Hash_table *table)\n{\n  const Hash_tuning *tuning = table->tuning;\n  float epsilon;\n  if (tuning == &default_tuning)\n    return true;\n\n  /* Be a bit stricter than mathematics would require, so that\n     rounding errors in size calculations do not cause allocations to\n     fail to grow or shrink as they should.  The smallest allocation\n     is 11 (due to next_prime's algorithm), so an epsilon of 0.1\n     should be good enough.  */\n  epsilon = 0.1f;\n\n  if (epsilon < tuning->growth_threshold\n      && tuning->growth_threshold < 1 - epsilon\n      && 1 + epsilon < tuning->growth_factor\n      && 0 <= tuning->shrink_threshold\n      && tuning->shrink_threshold + epsilon < tuning->shrink_factor\n      && tuning->shrink_factor <= 1\n      && tuning->shrink_threshold + epsilon < tuning->growth_threshold)\n    return true;\n\n  table->tuning = &default_tuning;\n  return false;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "compute_bucket_size": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\ncompute_bucket_size (size_t candidate, const Hash_tuning *tuning)\n{\n  if (!tuning->is_n_buckets)\n    {\n      float new_candidate = candidate / tuning->growth_threshold;\n      if (SIZE_MAX <= new_candidate)\n        return 0;\n      candidate = new_candidate;\n    }\n  candidate = next_prime (candidate);\n  if (xalloc_oversized (candidate, sizeof (struct hash_entry *)))\n    return 0;\n  return candidate;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "hash_initialize": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "Hash_table *\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)\n{\n  Hash_table *table;\n\n  if (hasher == NULL)\n    hasher = raw_hasher;\n  if (comparator == NULL)\n    comparator = raw_comparator;\n\n  table = malloc (sizeof *table);\n  if (table == NULL)\n    return NULL;\n\n  if (!tuning)\n    tuning = &default_tuning;\n  table->tuning = tuning;\n  if (!check_tuning (table))\n    {\n      /* Fail if the tuning options are invalid.  This is the only occasion\n         when the user gets some feedback about it.  Once the table is created,\n         if the user provides invalid tuning options, we silently revert to\n         using the defaults, and ignore further request to change the tuning\n         options.  */\n      goto fail;\n    }\n\n  table->n_buckets = compute_bucket_size (candidate, tuning);\n  if (!table->n_buckets)\n    goto fail;\n\n  table->bucket = calloc (table->n_buckets, sizeof *table->bucket);\n  if (table->bucket == NULL)\n    goto fail;\n  table->bucket_limit = table->bucket + table->n_buckets;\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n\n  table->hasher = hasher;\n  table->comparator = comparator;\n  table->data_freer = data_freer;\n\n  table->free_entry_list = NULL;\n#if USE_OBSTACK\n  obstack_init (&table->entry_stack);\n#endif\n  return table;\n\n fail:\n  free (table);\n  return NULL;\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "Hash_table",
        "*\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)",
        "*"
      ]
    },
    "hash_clear": {
      "start_point": [
        651,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "void\nhash_clear (Hash_table *table)\n{\n  struct hash_entry *bucket;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry *cursor;\n          struct hash_entry *next;\n\n          /* Free the bucket overflow.  */\n          for (cursor = bucket->next; cursor; cursor = next)\n            {\n              if (table->data_freer)\n                table->data_freer (cursor->data);\n              cursor->data = NULL;\n\n              next = cursor->next;\n              /* Relinking is done one entry at a time, as it is to be expected\n                 that overflows are either rare or short.  */\n              cursor->next = table->free_entry_list;\n              table->free_entry_list = cursor;\n            }\n\n          /* Free the bucket head.  */\n          if (table->data_freer)\n            table->data_freer (bucket->data);\n          bucket->data = NULL;\n          bucket->next = NULL;\n        }\n    }\n\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "hash_free": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "void\nhash_free (Hash_table *table)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n\n  /* Call the user data_freer function.  */\n  if (table->data_freer && table->n_entries)\n    {\n      for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n        {\n          if (bucket->data)\n            {\n              for (cursor = bucket; cursor; cursor = cursor->next)\n                table->data_freer (cursor->data);\n            }\n        }\n    }\n\n#if USE_OBSTACK\n\n  obstack_free (&table->entry_stack, NULL);\n\n#else\n\n  /* Free all bucket overflowed entries.  */\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      for (cursor = bucket->next; cursor; cursor = next)\n        {\n          next = cursor->next;\n          free (cursor);\n        }\n    }\n\n  /* Also reclaim the internal list of previously freed entries.  */\n  for (cursor = table->free_entry_list; cursor; cursor = next)\n    {\n      next = cursor->next;\n      free (cursor);\n    }\n\n#endif\n\n  /* Free the remainder of the hash table structure.  */\n  free (table->bucket);\n  free (table);\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "allocate_entry": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "static struct hash_entry *\nallocate_entry (Hash_table *table)\n{\n  struct hash_entry *new;\n\n  if (table->free_entry_list)\n    {\n      new = table->free_entry_list;\n      table->free_entry_list = new->next;\n    }\n  else\n    {\n#if USE_OBSTACK\n      new = obstack_alloc (&table->entry_stack, sizeof *new);\n#else\n      new = malloc (sizeof *new);\n#endif\n    }\n\n  return new;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nallocate_entry (Hash_table *table)",
        "*"
      ]
    },
    "free_entry": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "static void\nfree_entry (Hash_table *table, struct hash_entry *entry)\n{\n  entry->data = NULL;\n  entry->next = table->free_entry_list;\n  table->free_entry_list = entry;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hash_find_entry": {
      "start_point": [
        788,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "static void *\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)\n{\n  struct hash_entry *bucket = safe_hasher (table, entry);\n  struct hash_entry *cursor;\n\n  *bucket_head = bucket;\n\n  /* Test for empty bucket.  */\n  if (bucket->data == NULL)\n    return NULL;\n\n  /* See if the entry is the first in the bucket.  */\n  if (entry == bucket->data || table->comparator (entry, bucket->data))\n    {\n      void *data = bucket->data;\n\n      if (delete)\n        {\n          if (bucket->next)\n            {\n              struct hash_entry *next = bucket->next;\n\n              /* Bump the first overflow entry into the bucket head, then save\n                 the previous first overflow entry for later recycling.  */\n              *bucket = *next;\n              free_entry (table, next);\n            }\n          else\n            {\n              bucket->data = NULL;\n            }\n        }\n\n      return data;\n    }\n\n  /* Scan the bucket overflow.  */\n  for (cursor = bucket; cursor->next; cursor = cursor->next)\n    {\n      if (entry == cursor->next->data\n          || table->comparator (entry, cursor->next->data))\n        {\n          void *data = cursor->next->data;\n\n          if (delete)\n            {\n              struct hash_entry *next = cursor->next;\n\n              /* Unlink the entry to delete, then save the freed entry for later\n                 recycling.  */\n              cursor->next = next->next;\n              free_entry (table, next);\n            }\n\n          return data;\n        }\n    }\n\n  /* No entry found.  */\n  return NULL;\n}",
      "lines": 63,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)",
        "*"
      ]
    },
    "transfer_entries": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "static bool\ntransfer_entries (Hash_table *dst, Hash_table *src, bool safe)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n  for (bucket = src->bucket; bucket < src->bucket_limit; bucket++)\n    if (bucket->data)\n      {\n        void *data;\n        struct hash_entry *new_bucket;\n\n        /* Within each bucket, transfer overflow entries first and\n           then the bucket head, to minimize memory pressure.  After\n           all, the only time we might allocate is when moving the\n           bucket head, but moving overflow entries first may create\n           free entries that can be recycled by the time we finally\n           get to the bucket head.  */\n        for (cursor = bucket->next; cursor; cursor = next)\n          {\n            data = cursor->data;\n            new_bucket = safe_hasher (dst, data);\n\n            next = cursor->next;\n\n            if (new_bucket->data)\n              {\n                /* Merely relink an existing entry, when moving from a\n                   bucket overflow into a bucket overflow.  */\n                cursor->next = new_bucket->next;\n                new_bucket->next = cursor;\n              }\n            else\n              {\n                /* Free an existing entry, when moving from a bucket\n                   overflow into a bucket header.  */\n                new_bucket->data = data;\n                dst->n_buckets_used++;\n                free_entry (dst, cursor);\n              }\n          }\n        /* Now move the bucket head.  Be sure that if we fail due to\n           allocation failure that the src table is in a consistent\n           state.  */\n        data = bucket->data;\n        bucket->next = NULL;\n        if (safe)\n          continue;\n        new_bucket = safe_hasher (dst, data);\n\n        if (new_bucket->data)\n          {\n            /* Allocate or recycle an entry, when moving from a bucket\n               header into a bucket overflow.  */\n            struct hash_entry *new_entry = allocate_entry (dst);\n\n            if (new_entry == NULL)\n              return false;\n\n            new_entry->data = data;\n            new_entry->next = new_bucket->next;\n            new_bucket->next = new_entry;\n          }\n        else\n          {\n            /* Move from one bucket header to another.  */\n            new_bucket->data = data;\n            dst->n_buckets_used++;\n          }\n        bucket->data = NULL;\n        src->n_buckets_used--;\n      }\n  return true;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "hash_rehash": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        1018,
        1
      ],
      "content": "bool\nhash_rehash (Hash_table *table, size_t candidate)\n{\n  Hash_table storage;\n  Hash_table *new_table;\n  size_t new_size = compute_bucket_size (candidate, table->tuning);\n\n  if (!new_size)\n    return false;\n  if (new_size == table->n_buckets)\n    return true;\n  new_table = &storage;\n  new_table->bucket = calloc (new_size, sizeof *new_table->bucket);\n  if (new_table->bucket == NULL)\n    return false;\n  new_table->n_buckets = new_size;\n  new_table->bucket_limit = new_table->bucket + new_size;\n  new_table->n_buckets_used = 0;\n  new_table->n_entries = 0;\n  new_table->tuning = table->tuning;\n  new_table->hasher = table->hasher;\n  new_table->comparator = table->comparator;\n  new_table->data_freer = table->data_freer;\n\n  /* In order for the transfer to successfully complete, we need\n     additional overflow entries when distinct buckets in the old\n     table collide into a common bucket in the new table.  The worst\n     case possible is a hasher that gives a good spread with the old\n     size, but returns a constant with the new size; if we were to\n     guarantee table->n_buckets_used-1 free entries in advance, then\n     the transfer would be guaranteed to not allocate memory.\n     However, for large tables, a guarantee of no further allocation\n     introduces a lot of extra memory pressure, all for an unlikely\n     corner case (most rehashes reduce, rather than increase, the\n     number of overflow entries needed).  So, we instead ensure that\n     the transfer process can be reversed if we hit a memory\n     allocation failure mid-transfer.  */\n\n  /* Merely reuse the extra old space into the new table.  */\n#if USE_OBSTACK\n  new_table->entry_stack = table->entry_stack;\n#endif\n  new_table->free_entry_list = table->free_entry_list;\n\n  if (transfer_entries (new_table, table, false))\n    {\n      /* Entries transferred successfully; tie up the loose ends.  */\n      free (table->bucket);\n      table->bucket = new_table->bucket;\n      table->bucket_limit = new_table->bucket_limit;\n      table->n_buckets = new_table->n_buckets;\n      table->n_buckets_used = new_table->n_buckets_used;\n      table->free_entry_list = new_table->free_entry_list;\n      /* table->n_entries and table->entry_stack already hold their value.  */\n      return true;\n    }\n\n  /* We've allocated new_table->bucket (and possibly some entries),\n     exhausted the free list, and moved some but not all entries into\n     new_table.  We must undo the partial move before returning\n     failure.  The only way to get into this situation is if new_table\n     uses fewer buckets than the old table, so we will reclaim some\n     free entries as overflows in the new table are put back into\n     distinct buckets in the old table.\n\n     There are some pathological cases where a single pass through the\n     table requires more intermediate overflow entries than using two\n     passes.  Two passes give worse cache performance and takes\n     longer, but at this point, we're already out of memory, so slow\n     and safe is better than failure.  */\n  table->free_entry_list = new_table->free_entry_list;\n  if (! (transfer_entries (table, new_table, true)\n         && transfer_entries (table, new_table, false)))\n    abort ();\n  /* table->n_entries already holds its value.  */\n  free (new_table->bucket);\n  return false;\n}",
      "lines": 78,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "hash_insert_if_absent": {
      "start_point": [
        1036,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "int\nhash_insert_if_absent (Hash_table *table, void const *entry,\n                       void const **matched_ent)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  /* The caller cannot insert a NULL entry, since hash_lookup returns NULL\n     to indicate \"not found\", and hash_find_entry uses \"bucket->data == NULL\"\n     to indicate an empty bucket.  */\n  if (! entry)\n    abort ();\n\n  /* If there's a matching entry already in the table, return that.  */\n  if ((data = hash_find_entry (table, entry, &bucket, false)) != NULL)\n    {\n      if (matched_ent)\n        *matched_ent = data;\n      return 0;\n    }\n\n  /* If the growth threshold of the buckets in use has been reached, increase\n     the table size and rehash.  There's no point in checking the number of\n     entries:  if the hashing function is ill-conditioned, rehashing is not\n     likely to improve it.  */\n\n  if (table->n_buckets_used\n      > table->tuning->growth_threshold * table->n_buckets)\n    {\n      /* Check more fully, before starting real work.  If tuning arguments\n         became invalid, the second check will rely on proper defaults.  */\n      check_tuning (table);\n      if (table->n_buckets_used\n          > table->tuning->growth_threshold * table->n_buckets)\n        {\n          const Hash_tuning *tuning = table->tuning;\n          float candidate =\n            (tuning->is_n_buckets\n             ? (table->n_buckets * tuning->growth_factor)\n             : (table->n_buckets * tuning->growth_factor\n                * tuning->growth_threshold));\n\n          if (SIZE_MAX <= candidate)\n            return -1;\n\n          /* If the rehash fails, arrange to return NULL.  */\n          if (!hash_rehash (table, candidate))\n            return -1;\n\n          /* Update the bucket we are interested in.  */\n          if (hash_find_entry (table, entry, &bucket, false) != NULL)\n            abort ();\n        }\n    }\n\n  /* ENTRY is not matched, it should be inserted.  */\n\n  if (bucket->data)\n    {\n      struct hash_entry *new_entry = allocate_entry (table);\n\n      if (new_entry == NULL)\n        return -1;\n\n      /* Add ENTRY in the overflow of the bucket.  */\n\n      new_entry->data = (void *) entry;\n      new_entry->next = bucket->next;\n      bucket->next = new_entry;\n      table->n_entries++;\n      return 1;\n    }\n\n  /* Add ENTRY right in the bucket head.  */\n\n  bucket->data = (void *) entry;\n  table->n_entries++;\n  table->n_buckets_used++;\n\n  return 1;\n}",
      "lines": 81,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "hash_insert": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1132,
        1
      ],
      "content": "void *\nhash_insert (Hash_table *table, void const *entry)\n{\n  void const *matched_ent;\n  int err = hash_insert_if_absent (table, entry, &matched_ent);\n  return (err == -1\n          ? NULL\n          : (void *) (err == 0 ? matched_ent : entry));\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_insert (Hash_table *table, void const *entry)",
        "*"
      ]
    },
    "hash_delete": {
      "start_point": [
        1138,
        0
      ],
      "end_point": [
        1196,
        1
      ],
      "content": "void *\nhash_delete (Hash_table *table, const void *entry)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  data = hash_find_entry (table, entry, &bucket, true);\n  if (!data)\n    return NULL;\n\n  table->n_entries--;\n  if (!bucket->data)\n    {\n      table->n_buckets_used--;\n\n      /* If the shrink threshold of the buckets in use has been reached,\n         rehash into a smaller table.  */\n\n      if (table->n_buckets_used\n          < table->tuning->shrink_threshold * table->n_buckets)\n        {\n          /* Check more fully, before starting real work.  If tuning arguments\n             became invalid, the second check will rely on proper defaults.  */\n          check_tuning (table);\n          if (table->n_buckets_used\n              < table->tuning->shrink_threshold * table->n_buckets)\n            {\n              const Hash_tuning *tuning = table->tuning;\n              size_t candidate =\n                (tuning->is_n_buckets\n                 ? table->n_buckets * tuning->shrink_factor\n                 : (table->n_buckets * tuning->shrink_factor\n                    * tuning->growth_threshold));\n\n              if (!hash_rehash (table, candidate))\n                {\n                  /* Failure to allocate memory in an attempt to\n                     shrink the table is not fatal.  But since memory\n                     is low, we can at least be kind and free any\n                     spare entries, rather than keeping them tied up\n                     in the free entry list.  */\n#if ! USE_OBSTACK\n                  struct hash_entry *cursor = table->free_entry_list;\n                  struct hash_entry *next;\n                  while (cursor)\n                    {\n                      next = cursor->next;\n                      free (cursor);\n                      cursor = next;\n                    }\n                  table->free_entry_list = NULL;\n#endif\n                }\n            }\n        }\n    }\n\n  return data;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "void",
        "*\nhash_delete (Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_print": {
      "start_point": [
        1202,
        0
      ],
      "end_point": [
        1222,
        1
      ],
      "content": "void\nhash_print (const Hash_table *table)\n{\n  struct hash_entry *bucket = (struct hash_entry *) table->bucket;\n\n  for ( ; bucket < table->bucket_limit; bucket++)\n    {\n      struct hash_entry *cursor;\n\n      if (bucket)\n        printf (\"%lu:\\n\", (unsigned long int) (bucket - table->bucket));\n\n      for (cursor = bucket; cursor; cursor = cursor->next)\n        {\n          char const *s = cursor->data;\n          /* FIXME */\n          if (s)\n            printf (\"  %s\\n\", s);\n        }\n    }\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/hash.h": {},
  "tar/tar-1.30/gnu/human.c": {
    "adjust_value": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static long double\nadjust_value (int inexact_style, long double value)\n{\n  /* Do not use the floorl or ceill functions, as that would mean\n     checking for their presence and possibly linking with the\n     standard math library, which is a porting pain.  So leave the\n     value alone if it is too large to easily round.  */\n  if (inexact_style != human_round_to_nearest && value < UINTMAX_MAX)\n    {\n      uintmax_t u = value;\n      value = u + (inexact_style == human_ceiling && u != value);\n    }\n\n  return value;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long double",
        "long",
        "double"
      ]
    },
    "group_number": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static char *\ngroup_number (char *number, size_t numberlen,\n              char const *grouping, char const *thousands_sep)\n{\n  register char *d;\n  size_t grouplen = SIZE_MAX;\n  size_t thousands_seplen = strlen (thousands_sep);\n  size_t i = numberlen;\n\n  /* The maximum possible value for NUMBERLEN is the number of digits\n     in the square of the largest uintmax_t, so double the size needed.  */\n  char buf[2 * INT_STRLEN_BOUND (uintmax_t) + 1];\n\n  memcpy (buf, number, numberlen);\n  d = number + numberlen;\n\n  for (;;)\n    {\n      unsigned char g = *grouping;\n\n      if (g)\n        {\n          grouplen = g < CHAR_MAX ? g : i;\n          grouping++;\n        }\n\n      if (i < grouplen)\n        grouplen = i;\n\n      d -= grouplen;\n      i -= grouplen;\n      memcpy (d, buf + i, grouplen);\n      if (i == 0)\n        return d;\n\n      d -= thousands_seplen;\n      memcpy (d, thousands_sep, thousands_seplen);\n    }\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ngroup_number (char *number, size_t numberlen,\n              char const *grouping, char const *thousands_sep)",
        "*"
      ]
    },
    "human_readable": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "char *\nhuman_readable (uintmax_t n, char *buf, int opts,\n                uintmax_t from_block_size, uintmax_t to_block_size)\n{\n  int inexact_style =\n    opts & (human_round_to_nearest | human_floor | human_ceiling);\n  unsigned int base = opts & human_base_1024 ? 1024 : 1000;\n  uintmax_t amt;\n  int tenths;\n  int exponent = -1;\n  int exponent_max = sizeof power_letter - 1;\n  char *p;\n  char *psuffix;\n  char const *integerlim;\n\n  /* 0 means adjusted N == AMT.TENTHS;\n     1 means AMT.TENTHS < adjusted N < AMT.TENTHS + 0.05;\n     2 means adjusted N == AMT.TENTHS + 0.05;\n     3 means AMT.TENTHS + 0.05 < adjusted N < AMT.TENTHS + 0.1.  */\n  int rounding;\n\n  char const *decimal_point = \".\";\n  size_t decimal_pointlen = 1;\n  char const *grouping = \"\";\n  char const *thousands_sep = \"\";\n  struct lconv const *l = localeconv ();\n  size_t pointlen = strlen (l->decimal_point);\n  if (0 < pointlen && pointlen <= MB_LEN_MAX)\n    {\n      decimal_point = l->decimal_point;\n      decimal_pointlen = pointlen;\n    }\n  grouping = l->grouping;\n  if (strlen (l->thousands_sep) <= MB_LEN_MAX)\n    thousands_sep = l->thousands_sep;\n\n  /* Leave room for a trailing space and following suffix.  */\n  psuffix = buf + LONGEST_HUMAN_READABLE - 1 - HUMAN_READABLE_SUFFIX_LENGTH_MAX;\n  p = psuffix;\n\n  /* Adjust AMT out of FROM_BLOCK_SIZE units and into TO_BLOCK_SIZE\n     units.  If this can be done exactly with integer arithmetic, do\n     not use floating point operations.  */\n  if (to_block_size <= from_block_size)\n    {\n      if (from_block_size % to_block_size == 0)\n        {\n          uintmax_t multiplier = from_block_size / to_block_size;\n          amt = n * multiplier;\n          if (amt / multiplier == n)\n            {\n              tenths = 0;\n              rounding = 0;\n              goto use_integer_arithmetic;\n            }\n        }\n    }\n  else if (from_block_size != 0 && to_block_size % from_block_size == 0)\n    {\n      uintmax_t divisor = to_block_size / from_block_size;\n      uintmax_t r10 = (n % divisor) * 10;\n      uintmax_t r2 = (r10 % divisor) * 2;\n      amt = n / divisor;\n      tenths = r10 / divisor;\n      rounding = r2 < divisor ? 0 < r2 : 2 + (divisor < r2);\n      goto use_integer_arithmetic;\n    }\n\n  {\n    /* Either the result cannot be computed easily using uintmax_t,\n       or from_block_size is zero.  Fall back on floating point.\n       FIXME: This can yield answers that are slightly off.  */\n\n    long double dto_block_size = to_block_size;\n    long double damt = n * (from_block_size / dto_block_size);\n    size_t buflen;\n    size_t nonintegerlen;\n\n    if (! (opts & human_autoscale))\n      {\n        sprintf (buf, \"%.0Lf\", adjust_value (inexact_style, damt));\n        buflen = strlen (buf);\n        nonintegerlen = 0;\n      }\n    else\n      {\n        long double e = 1;\n        exponent = 0;\n\n        do\n          {\n            e *= base;\n            exponent++;\n          }\n        while (e * base <= damt && exponent < exponent_max);\n\n        damt /= e;\n\n        sprintf (buf, \"%.1Lf\", adjust_value (inexact_style, damt));\n        buflen = strlen (buf);\n        nonintegerlen = decimal_pointlen + 1;\n\n        if (1 + nonintegerlen + ! (opts & human_base_1024) < buflen\n            || ((opts & human_suppress_point_zero)\n                && buf[buflen - 1] == '0'))\n          {\n            sprintf (buf, \"%.0Lf\",\n                     adjust_value (inexact_style, damt * 10) / 10);\n            buflen = strlen (buf);\n            nonintegerlen = 0;\n          }\n      }\n\n    p = psuffix - buflen;\n    memmove (p, buf, buflen);\n    integerlim = p + buflen - nonintegerlen;\n  }\n  goto do_grouping;\n\n use_integer_arithmetic:\n  {\n    /* The computation can be done exactly, with integer arithmetic.\n\n       Use power of BASE notation if requested and if adjusted AMT is\n       large enough.  */\n\n    if (opts & human_autoscale)\n      {\n        exponent = 0;\n\n        if (base <= amt)\n          {\n            do\n              {\n                unsigned int r10 = (amt % base) * 10 + tenths;\n                unsigned int r2 = (r10 % base) * 2 + (rounding >> 1);\n                amt /= base;\n                tenths = r10 / base;\n                rounding = (r2 < base\n                            ? (r2 + rounding) != 0\n                            : 2 + (base < r2 + rounding));\n                exponent++;\n              }\n            while (base <= amt && exponent < exponent_max);\n\n            if (amt < 10)\n              {\n                if (inexact_style == human_round_to_nearest\n                    ? 2 < rounding + (tenths & 1)\n                    : inexact_style == human_ceiling && 0 < rounding)\n                  {\n                    tenths++;\n                    rounding = 0;\n\n                    if (tenths == 10)\n                      {\n                        amt++;\n                        tenths = 0;\n                      }\n                  }\n\n                if (amt < 10\n                    && (tenths || ! (opts & human_suppress_point_zero)))\n                  {\n                    *--p = '0' + tenths;\n                    p -= decimal_pointlen;\n                    memcpy (p, decimal_point, decimal_pointlen);\n                    tenths = rounding = 0;\n                  }\n              }\n          }\n      }\n\n    if (inexact_style == human_round_to_nearest\n        ? 5 < tenths + (0 < rounding + (amt & 1))\n        : inexact_style == human_ceiling && 0 < tenths + rounding)\n      {\n        amt++;\n\n        if ((opts & human_autoscale)\n            && amt == base && exponent < exponent_max)\n          {\n            exponent++;\n            if (! (opts & human_suppress_point_zero))\n              {\n                *--p = '0';\n                p -= decimal_pointlen;\n                memcpy (p, decimal_point, decimal_pointlen);\n              }\n            amt = 1;\n          }\n      }\n\n    integerlim = p;\n\n    do\n      {\n        int digit = amt % 10;\n        *--p = digit + '0';\n      }\n    while ((amt /= 10) != 0);\n  }\n\n do_grouping:\n  if (opts & human_group_digits)\n    p = group_number (p, integerlim - p, grouping, thousands_sep);\n\n  if (opts & human_SI)\n    {\n      if (exponent < 0)\n        {\n          uintmax_t power;\n          exponent = 0;\n          for (power = 1; power < to_block_size; power *= base)\n            if (++exponent == exponent_max)\n              break;\n        }\n\n      if ((exponent | (opts & human_B)) && (opts & human_space_before_unit))\n        *psuffix++ = ' ';\n\n      if (exponent)\n        *psuffix++ = (! (opts & human_base_1024) && exponent == 1\n                      ? 'k'\n                      : power_letter[exponent]);\n\n      if (opts & human_B)\n        {\n          if ((opts & human_base_1024) && exponent)\n            *psuffix++ = 'i';\n          *psuffix++ = 'B';\n        }\n    }\n\n  *psuffix = '\\0';\n\n  return p;\n}",
      "lines": 238,
      "depth": 19,
      "decorators": [
        "char",
        "*\nhuman_readable (uintmax_t n, char *buf, int opts,\n                uintmax_t from_block_size, uintmax_t to_block_size)",
        "*"
      ]
    },
    "default_block_size": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "static uintmax_t\ndefault_block_size (void)\n{\n  return getenv (\"POSIXLY_CORRECT\") ? 512 : DEFAULT_BLOCK_SIZE;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "uintmax_t"
      ]
    },
    "humblock": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "static strtol_error\nhumblock (char const *spec, uintmax_t *block_size, int *options)\n{\n  int i;\n  int opts = 0;\n\n  if (! spec\n      && ! (spec = getenv (\"BLOCK_SIZE\"))\n      && ! (spec = getenv (\"BLOCKSIZE\")))\n    *block_size = default_block_size ();\n  else\n    {\n      if (*spec == '\\'')\n        {\n          opts |= human_group_digits;\n          spec++;\n        }\n\n      if (0 <= (i = ARGMATCH (spec, block_size_args, block_size_opts)))\n        {\n          opts |= block_size_opts[i];\n          *block_size = 1;\n        }\n      else\n        {\n          char *ptr;\n          strtol_error e = xstrtoumax (spec, &ptr, 0, block_size,\n                                       \"eEgGkKmMpPtTyYzZ0\");\n          if (e != LONGINT_OK)\n            {\n              *options = 0;\n              return e;\n            }\n          for (; ! ('0' <= *spec && *spec <= '9'); spec++)\n            if (spec == ptr)\n              {\n                opts |= human_SI;\n                if (ptr[-1] == 'B')\n                  opts |= human_B;\n                if (ptr[-1] != 'B' || ptr[-2] == 'i')\n                  opts |= human_base_1024;\n                break;\n              }\n        }\n    }\n\n  *options = opts;\n  return LONGINT_OK;\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "human_options": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        470,
        1
      ],
      "content": "enum strtol_error\nhuman_options (char const *spec, int *opts, uintmax_t *block_size)\n{\n  strtol_error e = humblock (spec, block_size, opts);\n  if (*block_size == 0)\n    {\n      *block_size = default_block_size ();\n      e = LONGINT_INVALID;\n    }\n  return e;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "enum strtol_error",
        "enum",
        "strtol_error"
      ]
    }
  },
  "tar/tar-1.30/gnu/human.h": {},
  "tar/tar-1.30/gnu/imaxtostr.c": {},
  "tar/tar-1.30/gnu/intprops.h": {},
  "tar/tar-1.30/gnu/inttostr.c": {},
  "tar/tar-1.30/gnu/inttostr.h": {},
  "tar/tar-1.30/gnu/inttypes.in.h": {},
  "tar/tar-1.30/gnu/iswblank.c": {
    "iswblank": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "int\niswblank (wint_t wc)\n{\n  return wc == ' ' || wc == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/langinfo.in.h": {},
  "tar/tar-1.30/gnu/lchown.c": {
    "lchown": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nlchown (const char *file, uid_t uid, gid_t gid)\n{\n# if HAVE_CHOWN\n#  if ! CHOWN_MODIFIES_SYMLINK\n  struct stat stats;\n\n  if (lstat (file, &stats) == 0 && S_ISLNK (stats.st_mode))\n    {\n      errno = EOPNOTSUPP;\n      return -1;\n    }\n#  endif\n\n  return chown (file, uid, gid);\n\n# else /* !HAVE_CHOWN */\n  errno = ENOSYS;\n  return -1;\n# endif\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "rpl_lchown": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nrpl_lchown (const char *file, uid_t uid, gid_t gid)\n{\n  bool stat_valid = false;\n  int result;\n\n# if CHOWN_CHANGE_TIME_BUG\n  struct stat st;\n\n  if (gid != (gid_t) -1 || uid != (uid_t) -1)\n    {\n      if (lstat (file, &st))\n        return -1;\n      stat_valid = true;\n      if (!S_ISLNK (st.st_mode))\n        return chown (file, uid, gid);\n    }\n# endif\n\n# if CHOWN_TRAILING_SLASH_BUG\n  if (!stat_valid)\n    {\n      size_t len = strlen (file);\n      if (len && file[len - 1] == '/')\n        return chown (file, uid, gid);\n    }\n# endif\n\n  result = lchown (file, uid, gid);\n\n# if CHOWN_CHANGE_TIME_BUG && HAVE_LCHMOD\n  if (result == 0 && stat_valid\n      && (uid == st.st_uid || uid == (uid_t) -1)\n      && (gid == st.st_gid || gid == (gid_t) -1))\n    {\n      /* No change in ownership, but at least one argument was not -1,\n         so we are required to update ctime.  Since lchown succeeded,\n         we assume that lchmod will do likewise.  But if the system\n         lacks lchmod and lutimes, we are out of luck.  Oh well.  */\n      result = lchmod (file, st.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO\n                                           | S_ISUID | S_ISGID | S_ISVTX));\n    }\n# endif\n\n  return result;\n}",
      "lines": 46,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/limits.in.h": {},
  "tar/tar-1.30/gnu/link.c": {
    "initialize": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static void\ninitialize (void)\n{\n  HMODULE kernel32 = GetModuleHandle (\"kernel32.dll\");\n  if (kernel32 != NULL)\n    {\n      CreateHardLinkFunc =\n        (CreateHardLinkFuncType) GetProcAddress (kernel32, \"CreateHardLinkA\");\n    }\n  initialized = TRUE;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "link": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "int\nlink (const char *file1, const char *file2)\n{\n  char *dir;\n  size_t len1 = strlen (file1);\n  size_t len2 = strlen (file2);\n  if (!initialized)\n    initialize ();\n  if (CreateHardLinkFunc == NULL)\n    {\n      /* System does not support hard links.  */\n      errno = EPERM;\n      return -1;\n    }\n  /* Reject trailing slashes on non-directories; mingw does not\n     support hard-linking directories.  */\n  if ((len1 && (file1[len1 - 1] == '/' || file1[len1 - 1] == '\\\\'))\n      || (len2 && (file2[len2 - 1] == '/' || file2[len2 - 1] == '\\\\')))\n    {\n      struct stat st;\n      if (stat (file1, &st) == 0 && S_ISDIR (st.st_mode))\n        errno = EPERM;\n      else\n        errno = ENOTDIR;\n      return -1;\n    }\n  /* CreateHardLink(\"b/.\",\"a\",NULL) creates file \"b\", so we must check\n     that dirname(file2) exists.  */\n  dir = strdup (file2);\n  if (!dir)\n    return -1;\n  {\n    struct stat st;\n    char *p = strchr (dir, '\\0');\n    while (dir < p && (*--p != '/' && *p != '\\\\'));\n    *p = '\\0';\n    if (p != dir && stat (dir, &st) == -1)\n      {\n        int saved_errno = errno;\n        free (dir);\n        errno = saved_errno;\n        return -1;\n      }\n    free (dir);\n  }\n  /* Now create the link.  */\n  if (CreateHardLinkFunc (file2, file1, NULL) == 0)\n    {\n      /* It is not documented which errors CreateHardLink() can produce.\n       * The following conversions are based on tests on a Windows XP SP2\n       * system. */\n      DWORD err = GetLastError ();\n      switch (err)\n        {\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          break;\n\n        case ERROR_INVALID_FUNCTION:    /* fs does not support hard links */\n          errno = EPERM;\n          break;\n\n        case ERROR_NOT_SAME_DEVICE:\n          errno = EXDEV;\n          break;\n\n        case ERROR_PATH_NOT_FOUND:\n        case ERROR_FILE_NOT_FOUND:\n          errno = ENOENT;\n          break;\n\n        case ERROR_INVALID_PARAMETER:\n          errno = ENAMETOOLONG;\n          break;\n\n        case ERROR_TOO_MANY_LINKS:\n          errno = EMLINK;\n          break;\n\n        case ERROR_ALREADY_EXISTS:\n          errno = EEXIST;\n          break;\n\n        default:\n          errno = EIO;\n        }\n      return -1;\n    }\n\n  return 0;\n}",
      "lines": 91,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "rpl_link": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "int\nrpl_link (char const *file1, char const *file2)\n{\n  size_t len1;\n  size_t len2;\n  struct stat st;\n\n  /* Don't allow IRIX to dereference dangling file2 symlink.  */\n  if (!lstat (file2, &st))\n    {\n      errno = EEXIST;\n      return -1;\n    }\n\n  /* Reject trailing slashes on non-directories.  */\n  len1 = strlen (file1);\n  len2 = strlen (file2);\n  if ((len1 && file1[len1 - 1] == '/')\n      || (len2 && file2[len2 - 1] == '/'))\n    {\n      /* Let link() decide whether hard-linking directories is legal.\n         If stat() fails, then link() should fail for the same reason\n         (although on Solaris 9, link(\"file/\",\"oops\") mistakenly\n         succeeds); if stat() succeeds, require a directory.  */\n      if (stat (file1, &st))\n        return -1;\n      if (!S_ISDIR (st.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n  else\n    {\n      /* Fix Cygwin 1.5.x bug where link(\"a\",\"b/.\") creates file \"b\".  */\n      char *dir = strdup (file2);\n      char *p;\n      if (!dir)\n        return -1;\n      /* We already know file2 does not end in slash.  Strip off the\n         basename, then check that the dirname exists.  */\n      p = strrchr (dir, '/');\n      if (p)\n        {\n          *p = '\\0';\n          if (stat (dir, &st) == -1)\n            {\n              int saved_errno = errno;\n              free (dir);\n              errno = saved_errno;\n              return -1;\n            }\n        }\n      free (dir);\n    }\n  return link (file1, file2);\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/linkat.c": {
    "link_immediate": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static int\nlink_immediate (char const *file1, char const *file2)\n{\n  char *target = areadlink (file1);\n  if (target)\n    {\n      /* A symlink cannot be modified in-place.  Therefore, creating\n         an identical symlink behaves like a hard link to a symlink,\n         except for incorrect st_ino and st_nlink.  However, we must\n         be careful of EXDEV.  */\n      struct stat st1;\n      struct stat st2;\n      char *dir = mdir_name (file2);\n      if (!dir)\n        {\n          free (target);\n          errno = ENOMEM;\n          return -1;\n        }\n      if (lstat (file1, &st1) == 0 && stat (dir, &st2) == 0)\n        {\n          if (st1.st_dev == st2.st_dev)\n            {\n              int result = symlink (target, file2);\n              int saved_errno = errno;\n              free (target);\n              free (dir);\n              errno = saved_errno;\n              return result;\n            }\n          free (target);\n          free (dir);\n          errno = EXDEV;\n          return -1;\n        }\n      free (target);\n      free (dir);\n    }\n  if (errno == ENOMEM)\n    return -1;\n  return link (file1, file2);\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "link_follow": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "static int\nlink_follow (char const *file1, char const *file2)\n{\n  char *name = (char *) file1;\n  char *target;\n  int result;\n  int i = MAXSYMLINKS;\n\n  /* Using realpath or canonicalize_file_name is too heavy-handed: we\n     don't need an absolute name, and we don't need to resolve\n     intermediate symlinks, just the basename of each iteration.  */\n  while (i-- && (target = areadlink (name)))\n    {\n      if (IS_ABSOLUTE_FILE_NAME (target))\n        {\n          if (name != file1)\n            free (name);\n          name = target;\n        }\n      else\n        {\n          char *dir = mdir_name (name);\n          if (name != file1)\n            free (name);\n          if (!dir)\n            {\n              free (target);\n              errno = ENOMEM;\n              return -1;\n            }\n          name = mfile_name_concat (dir, target, NULL);\n          free (dir);\n          free (target);\n          if (!name)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n    }\n  if (i < 0)\n    {\n      target = NULL;\n      errno = ELOOP;\n    }\n  if (!target && errno != EINVAL)\n    {\n      if (name != file1)\n        {\n          int saved_errno = errno;\n          free (name);\n          errno = saved_errno;\n        }\n      return -1;\n    }\n  result = link (name, file2);\n  if (name != file1)\n    {\n      int saved_errno = errno;\n      free (name);\n      errno = saved_errno;\n    }\n  return result;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "solaris_optimized_link_immediate": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static int\nsolaris_optimized_link_immediate (char const *file1, char const *file2)\n{\n  if (__xpg4 == 0)\n    return link (file1, file2);\n  return link_immediate (file1, file2);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "solaris_optimized_link_follow": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static int\nsolaris_optimized_link_follow (char const *file1, char const *file2)\n{\n  if (__xpg4 != 0)\n    return link (file1, file2);\n  return link_follow (file1, file2);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "linkat": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "int\nlinkat (int fd1, char const *file1, int fd2, char const *file2, int flag)\n{\n  if (flag & ~AT_SYMLINK_FOLLOW)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  return at_func2 (fd1, file1, fd2, file2,\n                   flag ? link_follow : link_immediate);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "linkat_follow": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "static int\nlinkat_follow (int fd1, char const *file1, int fd2, char const *file2)\n{\n  char *name = (char *) file1;\n  char *target;\n  int result;\n  int i = MAXSYMLINKS;\n\n  /* There is no realpathat.  */\n  while (i-- && (target = areadlinkat (fd1, name)))\n    {\n      if (IS_ABSOLUTE_FILE_NAME (target))\n        {\n          if (name != file1)\n            free (name);\n          name = target;\n        }\n      else\n        {\n          char *dir = mdir_name (name);\n          if (name != file1)\n            free (name);\n          if (!dir)\n            {\n              free (target);\n              errno = ENOMEM;\n              return -1;\n            }\n          name = mfile_name_concat (dir, target, NULL);\n          free (dir);\n          free (target);\n          if (!name)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n    }\n  if (i < 0)\n    {\n      target = NULL;\n      errno = ELOOP;\n    }\n  if (!target && errno != EINVAL)\n    {\n      if (name != file1)\n        {\n          int saved_errno = errno;\n          free (name);\n          errno = saved_errno;\n        }\n      return -1;\n    }\n  result = linkat (fd1, name, fd2, file2, 0);\n  if (name != file1)\n    {\n      int saved_errno = errno;\n      free (name);\n      errno = saved_errno;\n    }\n  return result;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_linkat": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "int\nrpl_linkat (int fd1, char const *file1, int fd2, char const *file2, int flag)\n{\n  if (flag & ~AT_SYMLINK_FOLLOW)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n# if LINKAT_TRAILING_SLASH_BUG\n  /* Reject trailing slashes on non-directories.  */\n  {\n    size_t len1 = strlen (file1);\n    size_t len2 = strlen (file2);\n    if ((len1 && file1[len1 - 1] == '/')\n        || (len2 && file2[len2 - 1] == '/'))\n      {\n        /* Let linkat() decide whether hard-linking directories is legal.\n           If fstatat() fails, then linkat() should fail for the same reason;\n           if fstatat() succeeds, require a directory.  */\n        struct stat st;\n        if (fstatat (fd1, file1, &st, flag ? 0 : AT_SYMLINK_NOFOLLOW))\n          return -1;\n        if (!S_ISDIR (st.st_mode))\n          {\n            errno = ENOTDIR;\n            return -1;\n          }\n      }\n  }\n# endif\n\n  if (!flag)\n    {\n      int result = linkat (fd1, file1, fd2, file2, flag);\n# if LINKAT_SYMLINK_NOTSUP\n      /* OS X 10.10 has linkat() but it doesn't support\n         hardlinks to symlinks.  Fallback to our emulation\n         in that case.  */\n      if (result == -1 && (errno == ENOTSUP || errno == EOPNOTSUPP))\n        return at_func2 (fd1, file1, fd2, file2, link_immediate);\n# endif\n      return result;\n    }\n\n  /* Cache the information on whether the system call really works.  */\n  {\n    static int have_follow_really; /* 0 = unknown, 1 = yes, -1 = no */\n    if (0 <= have_follow_really)\n    {\n      int result = linkat (fd1, file1, fd2, file2, flag);\n      if (!(result == -1 && errno == EINVAL))\n        {\n          have_follow_really = 1;\n          return result;\n        }\n      have_follow_really = -1;\n    }\n  }\n  return linkat_follow (fd1, file1, fd2, file2);\n}",
      "lines": 61,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      char *malloc_dir = NULL;\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate2 (LIBDIR, &malloc_dir);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      free (malloc_dir);\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <https://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 262,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/localcharset.h": {},
  "tar/tar-1.30/gnu/locale.in.h": {},
  "tar/tar-1.30/gnu/localeconv.c": {
    "localeconv": [
      {
        "start_point": [
          26,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static struct lconv result;\n# undef lconv\n# undef localeconv\n  struct lconv *sys_result = localeconv ();\n\n  result.decimal_point = sys_result->decimal_point;\n  result.thousands_sep = sys_result->thousands_sep;\n  result.grouping = sys_result->grouping;\n  result.mon_decimal_point = sys_result->mon_decimal_point;\n  result.mon_thousands_sep = sys_result->mon_thousands_sep;\n  result.mon_grouping = sys_result->mon_grouping;\n  result.positive_sign = sys_result->positive_sign;\n  result.negative_sign = sys_result->negative_sign;\n  result.currency_symbol = sys_result->currency_symbol;\n  result.frac_digits = sys_result->frac_digits;\n  result.p_cs_precedes = sys_result->p_cs_precedes;\n  result.p_sign_posn = sys_result->p_sign_posn;\n  result.p_sep_by_space = sys_result->p_sep_by_space;\n  result.n_cs_precedes = sys_result->n_cs_precedes;\n  result.n_sign_posn = sys_result->n_sign_posn;\n  result.n_sep_by_space = sys_result->n_sep_by_space;\n  result.int_curr_symbol = sys_result->int_curr_symbol;\n  result.int_frac_digits = sys_result->int_frac_digits;\n  result.int_p_cs_precedes = sys_result->p_cs_precedes;\n  result.int_p_sign_posn = sys_result->p_sign_posn;\n  result.int_p_sep_by_space = sys_result->p_sep_by_space;\n  result.int_n_cs_precedes = sys_result->n_cs_precedes;\n  result.int_n_sign_posn = sys_result->n_sign_posn;\n  result.int_n_sep_by_space = sys_result->n_sep_by_space;\n\n  return &result;\n}",
        "lines": 35,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      },
      {
        "start_point": [
          68,
          0
        ],
        "end_point": [
          100,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static /*const*/ struct lconv result =\n    {\n      /* decimal_point */ \".\",\n      /* thousands_sep */ \"\",\n      /* grouping */ \"\",\n      /* mon_decimal_point */ \"\",\n      /* mon_thousands_sep */ \"\",\n      /* mon_grouping */ \"\",\n      /* positive_sign */ \"\",\n      /* negative_sign */ \"\",\n      /* currency_symbol */ \"\",\n      /* frac_digits */ CHAR_MAX,\n      /* p_cs_precedes */ CHAR_MAX,\n      /* p_sign_posn */ CHAR_MAX,\n      /* p_sep_by_space */ CHAR_MAX,\n      /* n_cs_precedes */ CHAR_MAX,\n      /* n_sign_posn */ CHAR_MAX,\n      /* n_sep_by_space */ CHAR_MAX,\n      /* int_curr_symbol */ \"\",\n      /* int_frac_digits */ CHAR_MAX,\n      /* int_p_cs_precedes */ CHAR_MAX,\n      /* int_p_sign_posn */ CHAR_MAX,\n      /* int_p_sep_by_space */ CHAR_MAX,\n      /* int_n_cs_precedes */ CHAR_MAX,\n      /* int_n_sign_posn */ CHAR_MAX,\n      /* int_n_sep_by_space */ CHAR_MAX\n    };\n\n  return &result;\n}",
        "lines": 33,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      }
    ]
  },
  "tar/tar-1.30/gnu/localtime-buffer.c": {
    "rpl_localtime": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/localtime-buffer.h": {},
  "tar/tar-1.30/gnu/lseek.c": {
    "rpl_lseek": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "off_t\nrpl_lseek (int fd, off_t offset, int whence)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* mingw lseek mistakenly succeeds on pipes, sockets, and terminals.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (GetFileType (h) != FILE_TYPE_DISK)\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#else\n  /* BeOS lseek mistakenly succeeds on pipes...  */\n  struct stat statbuf;\n  if (fstat (fd, &statbuf) < 0)\n    return -1;\n  if (!S_ISREG (statbuf.st_mode))\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#endif\n#if _GL_WINDOWS_64_BIT_OFF_T\n  return _lseeki64 (fd, offset, whence);\n#else\n  return lseek (fd, offset, whence);\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "off_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/lstat.c": {
    "orig_lstat": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  size_t len;\n  int lstat_result = orig_lstat (file, sbuf);\n\n  if (lstat_result != 0)\n    return lstat_result;\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  len = strlen (file);\n  if (file[len - 1] != '/' || S_ISDIR (sbuf->st_mode))\n    return 0;\n\n  /* At this point, a trailing slash is only permitted on\n     symlink-to-dir; but it should have found information on the\n     directory, not the symlink.  Call stat() to get info about the\n     link's referent.  Our replacement stat guarantees valid results,\n     even if the symlink is not pointing to a directory.  */\n  if (!S_ISLNK (sbuf->st_mode))\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return stat (file, sbuf);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/malloca.c": {
    "mmalloca": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, that serves as an indicator for malloc()ed\n     memory, so that freea() of an alloca() result is fast.  */\n  size_t nplus = n + HEADER_SIZE;\n\n  if (nplus >= n)\n    {\n      void *p = malloc (nplus);\n\n      if (p != NULL)\n        {\n          size_t slot;\n          union header *h = p;\n\n          p = h + 1;\n\n          /* Put a magic number into the indicator word.  */\n          h->magic.word = MAGIC_NUMBER;\n\n          /* Enter p into the hash table.  */\n          slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          h->next = mmalloca_results[slot];\n          mmalloca_results[slot] = p;\n\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "NO_SANITIZE_MEMORY": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void NO_SANITIZE_MEMORY\nfreea (void *p)\n{\n  /* mmalloca() may have returned NULL.  */\n  if (p != NULL)\n    {\n      /* Attempt to quickly distinguish the mmalloca() result - which has\n         a magic indicator word - and the alloca() result - which has an\n         uninitialized indicator word.  It is for this test that sa_increment\n         additional bytes are allocated in the alloca() case.  */\n      if (((int *) p)[-1] == MAGIC_NUMBER)\n        {\n          /* Looks like a mmalloca() result.  To see whether it really is one,\n             perform a lookup in the hash table.  */\n          size_t slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          void **chain = &mmalloca_results[slot];\n          for (; *chain != NULL;)\n            {\n              union header *h = p;\n              if (*chain == p)\n                {\n                  /* Found it.  Remove it from the hash table and free it.  */\n                  union header *p_begin = h - 1;\n                  *chain = p_begin->next;\n                  free (p_begin);\n                  return;\n                }\n              h = *chain;\n              chain = &h[-1].next;\n            }\n        }\n      /* At this point, we know it was not a mmalloca() result.  */\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/malloca.h": {},
  "tar/tar-1.30/gnu/mbchar.c": {},
  "tar/tar-1.30/gnu/mbchar.h": {
    "mb_width_aux": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "MBCHAR_INLINE int\nmb_width_aux (wint_t wc)\n{\n  int w = wcwidth (wc);\n  /* For unprintable characters, arbitrarily return 0 for control characters\n     and MB_UNPRINTABLE_WIDTH otherwise.  */\n  return (w >= 0 ? w : iswcntrl (wc) ? 0 : MB_UNPRINTABLE_WIDTH);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "MBCHAR_INLINE",
        "int",
        "int"
      ]
    },
    "mb_copy": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "MBCHAR_INLINE void\nmb_copy (mbchar_t *new_mbc, const mbchar_t *old_mbc)\n{\n  if (old_mbc->ptr == &old_mbc->buf[0])\n    {\n      memcpy (&new_mbc->buf[0], &old_mbc->buf[0], old_mbc->bytes);\n      new_mbc->ptr = &new_mbc->buf[0];\n    }\n  else\n    new_mbc->ptr = old_mbc->ptr;\n  new_mbc->bytes = old_mbc->bytes;\n  if ((new_mbc->wc_valid = old_mbc->wc_valid))\n    new_mbc->wc = old_mbc->wc;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "MBCHAR_INLINE",
        "void",
        "void"
      ]
    },
    "is_basic": [
      {
        "start_point": [
          314,
          0
        ],
        "end_point": [
          319,
          1
        ],
        "content": "MBCHAR_INLINE bool\nis_basic (char c)\n{\n  return (is_basic_table [(unsigned char) c >> 5] >> ((unsigned char) c & 31))\n         & 1;\n}",
        "lines": 6,
        "depth": 12,
        "decorators": [
          "MBCHAR_INLINE",
          "bool",
          "bool"
        ]
      },
      {
        "start_point": [
          323,
          0
        ],
        "end_point": [
          353,
          1
        ],
        "content": "MBCHAR_INLINE bool\nis_basic (char c)\n{\n  switch (c)\n    {\n    case '\\t': case '\\v': case '\\f':\n    case ' ': case '!': case '\"': case '#': case '%':\n    case '&': case '\\'': case '(': case ')': case '*':\n    case '+': case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>':\n    case '?':\n    case 'A': case 'B': case 'C': case 'D': case 'E':\n    case 'F': case 'G': case 'H': case 'I': case 'J':\n    case 'K': case 'L': case 'M': case 'N': case 'O':\n    case 'P': case 'Q': case 'R': case 'S': case 'T':\n    case 'U': case 'V': case 'W': case 'X': case 'Y':\n    case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_':\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'i': case 'j':\n    case 'k': case 'l': case 'm': case 'n': case 'o':\n    case 'p': case 'q': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x': case 'y':\n    case 'z': case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n}",
        "lines": 31,
        "depth": 7,
        "decorators": [
          "MBCHAR_INLINE",
          "bool",
          "bool"
        ]
      }
    ]
  },
  "tar/tar-1.30/gnu/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        FALLTHROUGH;\n      case 2:\n        buf[1] = pstate[2];\n        FALLTHROUGH;\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <https://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  size_t ret;\n  wchar_t wc;\n\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_EMPTY_INPUT_BUG\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n  if (! pwc)\n    pwc = &wc;\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n  ret = mbrtowc (pwc, s, n, ps);\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  if (ret < (size_t) -2 && !*pwc)\n    return 0;\n# endif\n\n# if C_LOCALE_MAYBE_EILSEQ\n  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))\n    {\n      unsigned char uc = *s;\n      *pwc = uc;\n      return 1;\n    }\n# endif\n\n  return ret;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/mbscasecmp.c": {
    "mbscasecmp": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nmbscasecmp (const char *s1, const char *s2)\n{\n  if (s1 == s2)\n    return 0;\n\n  /* Be careful not to look at the entire extent of s1 or s2 until needed.\n     This is useful because when two strings differ, the difference is\n     most often already in the very few first characters.  */\n  if (MB_CUR_MAX > 1)\n    {\n      mbui_iterator_t iter1;\n      mbui_iterator_t iter2;\n\n      mbui_init (iter1, s1);\n      mbui_init (iter2, s2);\n\n      while (mbui_avail (iter1) && mbui_avail (iter2))\n        {\n          int cmp = mb_casecmp (mbui_cur (iter1), mbui_cur (iter2));\n\n          if (cmp != 0)\n            return cmp;\n\n          mbui_advance (iter1);\n          mbui_advance (iter2);\n        }\n      if (mbui_avail (iter1))\n        /* s2 terminated before s1.  */\n        return 1;\n      if (mbui_avail (iter2))\n        /* s1 terminated before s2.  */\n        return -1;\n      return 0;\n    }\n  else\n    {\n      const unsigned char *p1 = (const unsigned char *) s1;\n      const unsigned char *p2 = (const unsigned char *) s2;\n      unsigned char c1, c2;\n\n      do\n        {\n          c1 = TOLOWER (*p1);\n          c2 = TOLOWER (*p2);\n\n          if (c1 == '\\0')\n            break;\n\n          ++p1;\n          ++p2;\n        }\n      while (c1 == c2);\n\n      if (UCHAR_MAX <= INT_MAX)\n        return c1 - c2;\n      else\n        /* On machines where 'char' and 'int' are types of the same size, the\n           difference of two 'unsigned char' values - including the sign bit -\n           doesn't fit in an 'int'.  */\n        return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n    }\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          43,
          0
        ],
        "end_point": [
          49,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          70,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n# if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__\n  /* Native Windows.  */\n#  ifdef __MINGW32__\n  /* On mingw, 'mbstate_t' is defined as 'int'.  */\n  return ps == NULL || *ps == 0;\n#  else\n  /* MSVC defines 'mbstate_t' as an 8-byte struct; the first 4-bytes matter.  */\n  return ps == NULL || *(const unsigned int *)ps == 0;\n#  endif\n# else\n  /* Minix, HP-UX 11.00, Solaris 2.6, Interix, ...  */\n  /* Maybe this definition works, maybe not...  */\n  return ps == NULL || *(const char *)ps == 0;\n# endif\n}",
        "lines": 18,
        "depth": 13,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "tar/tar-1.30/gnu/mbsrtowcs-impl.h": {
    "mbsrtowcs": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "size_t\nmbsrtowcs (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps)\n{\n  if (ps == NULL)\n    ps = &_gl_mbsrtowcs_state;\n  {\n    const char *src = *srcp;\n\n    if (dest != NULL)\n      {\n        wchar_t *destptr = dest;\n\n        for (; len > 0; destptr++, len--)\n          {\n            size_t src_avail;\n            size_t ret;\n\n            /* An optimized variant of\n               src_avail = strnlen1 (src, MB_LEN_MAX);  */\n            if (src[0] == '\\0')\n              src_avail = 1;\n            else if (src[1] == '\\0')\n              src_avail = 2;\n            else if (src[2] == '\\0')\n              src_avail = 3;\n            else if (MB_LEN_MAX <= 4 || src[3] == '\\0')\n              src_avail = 4;\n            else\n              src_avail = 4 + strnlen1 (src + 4, MB_LEN_MAX - 4);\n\n            /* Parse the next multibyte character.  */\n            ret = mbrtowc (destptr, src, src_avail, ps);\n\n            if (ret == (size_t)(-2))\n              /* Encountered a multibyte character that extends past a '\\0' byte\n                 or that is longer than MB_LEN_MAX bytes.  Cannot happen.  */\n              abort ();\n\n            if (ret == (size_t)(-1))\n              goto bad_input;\n            if (ret == 0)\n              {\n                src = NULL;\n                /* Here mbsinit (ps).  */\n                break;\n              }\n            src += ret;\n          }\n\n        *srcp = src;\n        return destptr - dest;\n      }\n    else\n      {\n        /* Ignore dest and len, don't store *srcp at the end, and\n           don't clobber *ps.  */\n        mbstate_t state = *ps;\n        size_t totalcount = 0;\n\n        for (;; totalcount++)\n          {\n            size_t src_avail;\n            size_t ret;\n\n            /* An optimized variant of\n               src_avail = strnlen1 (src, MB_LEN_MAX);  */\n            if (src[0] == '\\0')\n              src_avail = 1;\n            else if (src[1] == '\\0')\n              src_avail = 2;\n            else if (src[2] == '\\0')\n              src_avail = 3;\n            else if (MB_LEN_MAX <= 4 || src[3] == '\\0')\n              src_avail = 4;\n            else\n              src_avail = 4 + strnlen1 (src + 4, MB_LEN_MAX - 4);\n\n            /* Parse the next multibyte character.  */\n            ret = mbrtowc (NULL, src, src_avail, &state);\n\n            if (ret == (size_t)(-2))\n              /* Encountered a multibyte character that extends past a '\\0' byte\n                 or that is longer than MB_LEN_MAX bytes.  Cannot happen.  */\n              abort ();\n\n            if (ret == (size_t)(-1))\n              goto bad_input2;\n            if (ret == 0)\n              {\n                /* Here mbsinit (&state).  */\n                break;\n              }\n            src += ret;\n          }\n\n        return totalcount;\n      }\n\n   bad_input:\n    *srcp = src;\n   bad_input2:\n    errno = EILSEQ;\n    return (size_t)(-1);\n  }\n}",
      "lines": 105,
      "depth": 18,
      "decorators": [
        "size_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/mbsrtowcs-state.c": {},
  "tar/tar-1.30/gnu/mbsrtowcs.c": {},
  "tar/tar-1.30/gnu/mbtowc-impl.h": {
    "mbtowc": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmbtowc (wchar_t *pwc, const char *s, size_t n)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      wchar_t wc;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = mbrtowc (&wc, s, n, &state);\n      if (result == (size_t)-1 || result == (size_t)-2)\n        {\n          errno = EILSEQ;\n          return -1;\n        }\n      if (pwc != NULL)\n        *pwc = wc;\n      return (wc == 0 ? 0 : result);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/mbtowc.c": {},
  "tar/tar-1.30/gnu/mbuiter.c": {},
  "tar/tar-1.30/gnu/mbuiter.h": {
    "mbuiter_multi_next": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_next (struct mbuiter_multi *iter)\n{\n  if (iter->next_done)\n    return;\n  if (iter->in_shift)\n    goto with_shift;\n  /* Handle most ASCII characters quickly, without calling mbrtowc().  */\n  if (is_basic (*iter->cur.ptr))\n    {\n      /* These characters are part of the basic character set.  ISO C 99\n         guarantees that their wide character code is identical to their\n         char code.  */\n      iter->cur.bytes = 1;\n      iter->cur.wc = *iter->cur.ptr;\n      iter->cur.wc_valid = true;\n    }\n  else\n    {\n      assert (mbsinit (&iter->state));\n      iter->in_shift = true;\n    with_shift:\n      iter->cur.bytes = mbrtowc (&iter->cur.wc, iter->cur.ptr,\n                                 strnlen1 (iter->cur.ptr, MB_CUR_MAX),\n                                 &iter->state);\n      if (iter->cur.bytes == (size_t) -1)\n        {\n          /* An invalid multibyte sequence was encountered.  */\n          iter->cur.bytes = 1;\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not very important; the string is bogus anyway.  */\n        }\n      else if (iter->cur.bytes == (size_t) -2)\n        {\n          /* An incomplete multibyte character at the end.  */\n          iter->cur.bytes = strlen (iter->cur.ptr);\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not important; the string end is reached anyway.  */\n        }\n      else\n        {\n          if (iter->cur.bytes == 0)\n            {\n              /* A null wide character was encountered.  */\n              iter->cur.bytes = 1;\n              assert (*iter->cur.ptr == '\\0');\n              assert (iter->cur.wc == 0);\n            }\n          iter->cur.wc_valid = true;\n\n          /* When in the initial state, we can go back treating ASCII\n             characters more quickly.  */\n          if (mbsinit (&iter->state))\n            iter->in_shift = false;\n        }\n    }\n  iter->next_done = true;\n}",
      "lines": 60,
      "depth": 17,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbuiter_multi_reloc": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_reloc (struct mbuiter_multi *iter, ptrdiff_t ptrdiff)\n{\n  iter->cur.ptr += ptrdiff;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbuiter_multi_copy": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_copy (struct mbuiter_multi *new_iter, const struct mbuiter_multi *old_iter)\n{\n  if ((new_iter->in_shift = old_iter->in_shift))\n    memcpy (&new_iter->state, &old_iter->state, sizeof (mbstate_t));\n  else\n    memset (&new_iter->state, 0, sizeof (mbstate_t));\n  new_iter->next_done = old_iter->next_done;\n  mb_copy (&new_iter->cur, &old_iter->cur);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/mempcpy.c": {
    "mempcpy": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void *\nmempcpy (void *dest, const void *src, size_t n)\n{\n  return (char *) memcpy (dest, src, n) + n;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nmempcpy (void *dest, const void *src, size_t n)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/memrchr.c": {
    "__memrchr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void *\n__memrchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the last few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s + n;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n)\n    if (*--char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *--longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        {\n          longword_ptr++;\n          break;\n        }\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  while (n-- > 0)\n    {\n      if (*--char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memrchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/minmax.h": {},
  "tar/tar-1.30/gnu/mkdir.c": {
    "rpl_mkdir": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\nrpl_mkdir (char const *dir, mode_t mode maybe_unused)\n{\n  int ret_val;\n  char *tmp_dir;\n  size_t len = strlen (dir);\n\n  if (len && dir[len - 1] == '/')\n    {\n      tmp_dir = strdup (dir);\n      if (!tmp_dir)\n        {\n          /* Rather than rely on strdup-posix, we set errno ourselves.  */\n          errno = ENOMEM;\n          return -1;\n        }\n      strip_trailing_slashes (tmp_dir);\n    }\n  else\n    {\n      tmp_dir = (char *) dir;\n    }\n#if FUNC_MKDIR_DOT_BUG\n  /* Additionally, cygwin 1.5 mistakenly creates a directory \"d/./\".  */\n  {\n    char *last = last_component (tmp_dir);\n    if (*last == '.' && (last[1] == '\\0'\n                         || (last[1] == '.' && last[2] == '\\0')))\n      {\n        struct stat st;\n        if (stat (tmp_dir, &st) == 0)\n          errno = EEXIST;\n        return -1;\n      }\n  }\n#endif /* FUNC_MKDIR_DOT_BUG */\n\n  ret_val = mkdir (tmp_dir, mode);\n\n  if (tmp_dir != dir)\n    free (tmp_dir);\n\n  return ret_val;\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/mkdirat.c": {},
  "tar/tar-1.30/gnu/mkdtemp.c": {
    "mkdtemp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "char *\nmkdtemp (char *xtemplate)\n{\n  if (gen_tempname (xtemplate, 0, 0, GT_DIR))\n    return NULL;\n  else\n    return xtemplate;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nmkdtemp (char *xtemplate)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/mkfifo.c": {
    "mkfifo": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmkfifo (char const *name _GL_UNUSED, mode_t mode _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_mkfifo": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\nrpl_mkfifo (char const *name, mode_t mode)\n{\n# if MKFIFO_TRAILING_SLASH_BUG\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      struct stat st;\n      if (stat (name, &st) == 0)\n        errno = EEXIST;\n      return -1;\n    }\n# endif\n  return mkfifo (name, mode);\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/mkfifoat.c": {
    "mkfifoat": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nmkfifoat (int fd _GL_UNUSED, char const *path _GL_UNUSED,\n          mode_t mode _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/mknod.c": {
    "mknod": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nmknod (char const *name _GL_UNUSED, mode_t mode _GL_UNUSED,\n       dev_t dev _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_mknod": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nrpl_mknod (char const *name, mode_t mode, dev_t dev)\n{\n# if MKFIFO_TRAILING_SLASH_BUG\n  /* Trailing slash only makes sense for directories.  Of course,\n     using mknod to create a directory is not very portable, so it may\n     still fail later on.  */\n  if (!S_ISDIR (mode))\n    {\n      size_t len = strlen (name);\n      if (len && name[len - 1] == '/')\n        {\n          struct stat st;\n          if (stat (name, &st) == 0)\n            errno = EEXIST;\n          return -1;\n        }\n    }\n# endif\n# if MKNOD_FIFO_BUG\n  /* POSIX requires mknod to create fifos for non-privileged\n     processes, but BSD implementations fail with EPERM.  */\n  if (S_ISFIFO (mode) && dev == 0)\n    return mkfifo (name, mode & ~S_IFIFO);\n# endif\n  return mknod (name, mode, dev);\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/mknodat.c": {
    "mknodat": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nmknodat (int fd _GL_UNUSED, char const *path _GL_UNUSED,\n         mode_t mode _GL_UNUSED, dev_t dev _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/mktime-internal.h": {},
  "tar/tar-1.30/gnu/mktime.c": {
    "shr": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static long_int\nshr (long_int a, int b)\n{\n  long_int one = 1;\n  return (-one >> 1 == -1\n\t  ? a >> b\n\t  : a / (one << b) - (a % (one << b) < 0));\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "long_int"
      ]
    },
    "leapyear": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static bool\nleapyear (long_int year)\n{\n  /* Don't add YEAR to TM_YEAR_BASE, as that might overflow.\n     Also, work even if YEAR is negative.  */\n  return\n    ((year & 3) == 0\n     && (year % 100 != 0\n\t || ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));\n}",
      "lines": 10,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "isdst_differ": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "static bool\nisdst_differ (int a, int b)\n{\n  return (!a != !b) && (0 <= a) && (0 <= b);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "ydhms_diff": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static long_int\nydhms_diff (long_int year1, long_int yday1, int hour1, int min1, int sec1,\n\t    int year0, int yday0, int hour0, int min0, int sec0)\n{\n  verify (-1 / 2 == 0);\n\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid integer overflow here.  */\n  int a4 = shr (year1, 2) + shr (TM_YEAR_BASE, 2) - ! (year1 & 3);\n  int b4 = shr (year0, 2) + shr (TM_YEAR_BASE, 2) - ! (year0 & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = shr (a100, 2);\n  int b400 = shr (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n\n  /* Compute the desired time without overflowing.  */\n  long_int years = year1 - year0;\n  long_int days = 365 * years + yday1 - yday0 + intervening_leap_days;\n  long_int hours = 24 * days + hour1 - hour0;\n  long_int minutes = 60 * hours + min1 - min0;\n  long_int seconds = 60 * minutes + sec1 - sec0;\n  return seconds;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long_int"
      ]
    },
    "long_int_avg": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static long_int\nlong_int_avg (long_int a, long_int b)\n{\n  return shr (a, 1) + shr (b, 1) + ((a | b) & 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long_int"
      ]
    },
    "guess_time_tm": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "static long_int\nguess_time_tm (long_int year, long_int yday, int hour, int min, int sec,\n\t       long_int t, const struct tm *tp)\n{\n  if (tp)\n    {\n      long_int result;\n      long_int d = ydhms_diff (year, yday, hour, min, sec,\n\t\t\t       tp->tm_year, tp->tm_yday,\n\t\t\t       tp->tm_hour, tp->tm_min, tp->tm_sec);\n      if (! INT_ADD_WRAPV (t, d, &result))\n\treturn result;\n    }\n\n  /* Overflow occurred one way or another.  Return the nearest result\n     that is actually in range, except don't report a zero difference\n     if the actual difference is nonzero, as that would cause a false\n     match; and don't oscillate between two values, as that would\n     confuse the spring-forward gap detector.  */\n  return (t < long_int_avg (mktime_min, mktime_max)\n\t  ? (t <= mktime_min + 1 ? t + 1 : mktime_min)\n\t  : (mktime_max - 1 <= t ? t - 1 : mktime_max));\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long_int"
      ]
    },
    "convert_time": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static struct tm *\nconvert_time (struct tm *(*convert) (const time_t *, struct tm *),\n\t      long_int t, struct tm *tm)\n{\n  time_t x = t;\n  return convert (&x, tm);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nconvert_time (struct tm *(*convert) (const time_t *, struct tm *),\n\t      long_int t, struct tm *tm)",
        "*"
      ]
    },
    "ranged_convert": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "static struct tm *\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\tlong_int *t, struct tm *tp)\n{\n  struct tm *r;\n  if (*t < mktime_min)\n    *t = mktime_min;\n  else if (mktime_max < *t)\n    *t = mktime_max;\n  r = convert_time (convert, *t, tp);\n\n  if (!r && *t)\n    {\n      long_int bad = *t;\n      long_int ok = 0;\n\n      /* BAD is a known unconvertible value, and OK is a known good one.\n\t Use binary search to narrow the range between BAD and OK until\n\t they differ by 1.  */\n      while (true)\n\t{\n\t  long_int mid = long_int_avg (ok, bad);\n\t  if (mid != ok && mid != bad)\n\t    break;\n\t  r = convert_time (convert, mid, tp);\n\t  if (r)\n\t    ok = mid;\n\t  else\n\t    bad = mid;\n\t}\n\n      if (!r && ok)\n\t{\n\t  /* The last conversion attempt failed;\n\t     revert to the most recent successful attempt.  */\n\t  r = convert_time (convert, ok, tp);\n\t}\n    }\n\n  return r;\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\tlong_int *t, struct tm *tp)",
        "*"
      ]
    },
    "__mktime_internal": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "time_t\n__mktime_internal (struct tm *tp,\n\t\t   struct tm *(*convert) (const time_t *, struct tm *),\n\t\t   mktime_offset_t *offset)\n{\n  long_int t, gt, t0, t1, t2, dt;\n  struct tm tm;\n\n  /* The maximum number of probes (calls to CONVERT) should be enough\n     to handle any combinations of time zone rule changes, solar time,\n     leap seconds, and oscillations around a spring-forward gap.\n     POSIX.1 prohibits leap seconds, but some hosts have them anyway.  */\n  int remaining_probes = 6;\n\n  /* Time requested.  Copy it in case CONVERT modifies *TP; this can\n     occur if TP is localtime's returned value and CONVERT is localtime.  */\n  int sec = tp->tm_sec;\n  int min = tp->tm_min;\n  int hour = tp->tm_hour;\n  int mday = tp->tm_mday;\n  int mon = tp->tm_mon;\n  int year_requested = tp->tm_year;\n  int isdst = tp->tm_isdst;\n\n  /* 1 if the previous probe was DST.  */\n  int dst2;\n\n  /* Ensure that mon is in range, and set year accordingly.  */\n  int mon_remainder = mon % 12;\n  int negative_mon_remainder = mon_remainder < 0;\n  int mon_years = mon / 12 - negative_mon_remainder;\n  long_int lyear_requested = year_requested;\n  long_int year = lyear_requested + mon_years;\n\n  /* The other values need not be in range:\n     the remaining code handles overflows correctly.  */\n\n  /* Calculate day of year from year, month, and day of month.\n     The result need not be in range.  */\n  int mon_yday = ((__mon_yday[leapyear (year)]\n\t\t   [mon_remainder + 12 * negative_mon_remainder])\n\t\t  - 1);\n  long_int lmday = mday;\n  long_int yday = mon_yday + lmday;\n\n  int negative_offset_guess;\n\n  int sec_requested = sec;\n\n  if (LEAP_SECONDS_POSSIBLE)\n    {\n      /* Handle out-of-range seconds specially,\n\t since ydhms_tm_diff assumes every minute has 60 seconds.  */\n      if (sec < 0)\n\tsec = 0;\n      if (59 < sec)\n\tsec = 59;\n    }\n\n  /* Invert CONVERT by probing.  First assume the same offset as last\n     time.  */\n\n  INT_SUBTRACT_WRAPV (0, *offset, &negative_offset_guess);\n  t0 = ydhms_diff (year, yday, hour, min, sec,\n\t\t   EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0, negative_offset_guess);\n\n  /* Repeatedly use the error to improve the guess.  */\n\n  for (t = t1 = t2 = t0, dst2 = 0;\n       (gt = guess_time_tm (year, yday, hour, min, sec, t,\n\t\t\t    ranged_convert (convert, &t, &tm)),\n\tt != gt);\n       t1 = t2, t2 = t, t = gt, dst2 = tm.tm_isdst != 0)\n    if (t == t1 && t != t2\n\t&& (tm.tm_isdst < 0\n\t    || (isdst < 0\n\t\t? dst2 <= (tm.tm_isdst != 0)\n\t\t: (isdst != 0) != (tm.tm_isdst != 0))))\n      /* We can't possibly find a match, as we are oscillating\n\t between two values.  The requested time probably falls\n\t within a spring-forward gap of size GT - T.  Follow the common\n\t practice in this case, which is to return a time that is GT - T\n\t away from the requested time, preferring a time whose\n\t tm_isdst differs from the requested value.  (If no tm_isdst\n\t was requested and only one of the two values has a nonzero\n\t tm_isdst, prefer that value.)  In practice, this is more\n\t useful than returning -1.  */\n      goto offset_found;\n    else if (--remaining_probes == 0)\n      return -1;\n\n  /* We have a match.  Check whether tm.tm_isdst has the requested\n     value, if any.  */\n  if (isdst_differ (isdst, tm.tm_isdst))\n    {\n      /* tm.tm_isdst has the wrong value.  Look for a neighboring\n\t time with the right value, and use its UTC offset.\n\n\t Heuristic: probe the adjacent timestamps in both directions,\n\t looking for the desired isdst.  This should work for all real\n\t time zone histories in the tz database.  */\n\n      /* Distance between probes when looking for a DST boundary.  In\n\t tzdata2003a, the shortest period of DST is 601200 seconds\n\t (e.g., America/Recife starting 2000-10-08 01:00), and the\n\t shortest period of non-DST surrounded by DST is 694800\n\t seconds (Africa/Tunis starting 1943-04-17 01:00).  Use the\n\t minimum of these two values, so we don't miss these short\n\t periods when probing.  */\n      int stride = 601200;\n\n      /* The longest period of DST in tzdata2003a is 536454000 seconds\n\t (e.g., America/Jujuy starting 1946-10-01 01:00).  The longest\n\t period of non-DST is much longer, but it makes no real sense\n\t to search for more than a year of non-DST, so use the DST\n\t max.  */\n      int duration_max = 536454000;\n\n      /* Search in both directions, so the maximum distance is half\n\t the duration; add the stride to avoid off-by-1 problems.  */\n      int delta_bound = duration_max / 2 + stride;\n\n      int delta, direction;\n\n      for (delta = stride; delta < delta_bound; delta += stride)\n\tfor (direction = -1; direction <= 1; direction += 2)\n\t  {\n\t    long_int ot;\n\t    if (! INT_ADD_WRAPV (t, delta * direction, &ot))\n\t      {\n\t\tstruct tm otm;\n\t\tranged_convert (convert, &ot, &otm);\n\t\tif (! isdst_differ (isdst, otm.tm_isdst))\n\t\t  {\n\t\t    /* We found the desired tm_isdst.\n\t\t       Extrapolate back to the desired time.  */\n\t\t    t = guess_time_tm (year, yday, hour, min, sec, ot, &otm);\n\t\t    ranged_convert (convert, &t, &tm);\n\t\t    goto offset_found;\n\t\t  }\n\t      }\n\t  }\n    }\n\n offset_found:\n  /* Set *OFFSET to the low-order bits of T - T0 - NEGATIVE_OFFSET_GUESS.\n     This is just a heuristic to speed up the next mktime call, and\n     correctness is unaffected if integer overflow occurs here.  */\n  INT_SUBTRACT_WRAPV (t, t0, &dt);\n  INT_SUBTRACT_WRAPV (dt, negative_offset_guess, offset);\n\n  if (LEAP_SECONDS_POSSIBLE && sec_requested != tm.tm_sec)\n    {\n      /* Adjust time to reflect the tm_sec requested, not the normalized value.\n\t Also, repair any damage from a false match due to a leap second.  */\n      long_int sec_adjustment = sec == 0 && tm.tm_sec == 60;\n      sec_adjustment -= sec;\n      sec_adjustment += sec_requested;\n      if (INT_ADD_WRAPV (t, sec_adjustment, &t)\n\t  || ! (mktime_min <= t && t <= mktime_max)\n\t  || ! convert_time (convert, t, &tm))\n\treturn -1;\n    }\n\n  *tp = tm;\n  return t;\n}",
      "lines": 167,
      "depth": 17,
      "decorators": [
        "time_t"
      ]
    },
    "mktime": {
      "start_point": [
        489,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "time_t\nmktime (struct tm *tp)\n{\n# if NEED_MKTIME_WINDOWS\n  /* Rectify the value of the environment variable TZ.\n     There are four possible kinds of such values:\n       - Traditional US time zone names, e.g. \"PST8PDT\".  Syntax: see\n         <https://msdn.microsoft.com/en-us/library/90s5c885.aspx>\n       - Time zone names based on geography, that contain one or more\n         slashes, e.g. \"Europe/Moscow\".\n       - Time zone names based on geography, without slashes, e.g.\n         \"Singapore\".\n       - Time zone names that contain explicit DST rules.  Syntax: see\n         <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08_03>\n     The Microsoft CRT understands only the first kind.  It produces incorrect\n     results if the value of TZ is of the other kinds.\n     But in a Cygwin environment, /etc/profile.d/tzset.sh sets TZ to a value\n     of the second kind for most geographies, or of the first kind in a few\n     other geographies.  If it is of the second kind, neutralize it.  For the\n     Microsoft CRT, an absent or empty TZ means the time zone that the user\n     has set in the Windows Control Panel.\n     If the value of TZ is of the third or fourth kind -- Cygwin programs\n     understand these syntaxes as well --, it does not matter whether we\n     neutralize it or not, since these values occur only when a Cygwin user\n     has set TZ explicitly; this case is 1. rare and 2. under the user's\n     responsibility.  */\n  const char *tz = getenv (\"TZ\");\n  if (tz != NULL && strchr (tz, '/') != NULL)\n    _putenv (\"TZ=\");\n# endif\n\n# if NEED_MKTIME_WORKING || DEBUG_MKTIME\n#  ifdef _LIBC\n  /* POSIX.1 8.1.1 requires that whenever mktime() is called, the\n     time zone names contained in the external variable 'tzname' shall\n     be set as if the tzset() function had been called.  */\n  __tzset ();\n#  elif HAVE_TZSET\n  tzset ();\n#  endif\n\n  return __mktime_internal (tp, __localtime_r, &localtime_offset);\n# else\n#  undef mktime\n  return mktime (tp);\n# endif\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "time_t"
      ]
    },
    "not_equal_tm": {
      "start_point": [
        550,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "static int\nnot_equal_tm (const struct tm *a, const struct tm *b)\n{\n  return ((a->tm_sec ^ b->tm_sec)\n\t  | (a->tm_min ^ b->tm_min)\n\t  | (a->tm_hour ^ b->tm_hour)\n\t  | (a->tm_mday ^ b->tm_mday)\n\t  | (a->tm_mon ^ b->tm_mon)\n\t  | (a->tm_year ^ b->tm_year)\n\t  | (a->tm_yday ^ b->tm_yday)\n\t  | isdst_differ (a->tm_isdst, b->tm_isdst));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_tm": {
      "start_point": [
        563,
        0
      ],
      "end_point": [
        573,
        1
      ],
      "content": "static void\nprint_tm (const struct tm *tp)\n{\n  if (tp)\n    printf (\"%04d-%02d-%02d %02d:%02d:%02d yday %03d wday %d isdst %d\",\n\t    tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,\n\t    tp->tm_hour, tp->tm_min, tp->tm_sec,\n\t    tp->tm_yday, tp->tm_wday, tp->tm_isdst);\n  else\n    printf (\"0\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_result": {
      "start_point": [
        575,
        0
      ],
      "end_point": [
        589,
        1
      ],
      "content": "static int\ncheck_result (time_t tk, struct tm tmk, time_t tl, const struct tm *lt)\n{\n  if (tk != tl || !lt || not_equal_tm (&tmk, lt))\n    {\n      printf (\"mktime (\");\n      print_tm (lt);\n      printf (\")\\nyields (\");\n      print_tm (&tmk);\n      printf (\") == %ld, should be %ld\\n\", (long int) tk, (long int) tl);\n      return 1;\n    }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        591,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int status = 0;\n  struct tm tm, tmk, tml;\n  struct tm *lt;\n  time_t tk, tl, tl1;\n  char trailer;\n\n  /* Sanity check, plus call tzset.  */\n  tl = 0;\n  if (! localtime (&tl))\n    {\n      printf (\"localtime (0) fails\\n\");\n      status = 1;\n    }\n\n  if ((argc == 3 || argc == 4)\n      && (sscanf (argv[1], \"%d-%d-%d%c\",\n\t\t  &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)\n\t  == 3)\n      && (sscanf (argv[2], \"%d:%d:%d%c\",\n\t\t  &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)\n\t  == 3))\n    {\n      tm.tm_year -= TM_YEAR_BASE;\n      tm.tm_mon--;\n      tm.tm_isdst = argc == 3 ? -1 : atoi (argv[3]);\n      tmk = tm;\n      tl = mktime (&tmk);\n      lt = localtime_r (&tl, &tml);\n      printf (\"mktime returns %ld == \", (long int) tl);\n      print_tm (&tmk);\n      printf (\"\\n\");\n      status = check_result (tl, tmk, tl, lt);\n    }\n  else if (argc == 4 || (argc == 5 && strcmp (argv[4], \"-\") == 0))\n    {\n      time_t from = atol (argv[1]);\n      time_t by = atol (argv[2]);\n      time_t to = atol (argv[3]);\n\n      if (argc == 4)\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    lt = localtime_r (&tl, &tml);\n\t    if (lt)\n\t      {\n\t\ttmk = tml;\n\t\ttk = mktime (&tmk);\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime_r (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n      else\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    /* Null benchmark.  */\n\t    lt = localtime_r (&tl, &tml);\n\t    if (lt)\n\t      {\n\t\ttmk = tml;\n\t\ttk = tl;\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime_r (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n    }\n  else\n    printf (\"Usage:\\\n\\t%s YYYY-MM-DD HH:MM:SS [ISDST] # Test given time.\\n\\\n\\t%s FROM BY TO # Test values FROM, FROM+BY, ..., TO.\\n\\\n\\t%s FROM BY TO - # Do not test those values (for benchmark).\\n\",\n\t    argv[0], argv[0], argv[0]);\n\n  return status;\n}",
      "lines": 91,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/modechange.c": {
    "octal_to_mode": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static mode_t\noctal_to_mode (unsigned int octal)\n{\n  /* Help the compiler optimize the usual case where mode_t uses\n     the traditional octal representation.  */\n  return ((S_ISUID == SUID && S_ISGID == SGID && S_ISVTX == SVTX\n           && S_IRUSR == RUSR && S_IWUSR == WUSR && S_IXUSR == XUSR\n           && S_IRGRP == RGRP && S_IWGRP == WGRP && S_IXGRP == XGRP\n           && S_IROTH == ROTH && S_IWOTH == WOTH && S_IXOTH == XOTH)\n          ? octal\n          : (mode_t) ((octal & SUID ? S_ISUID : 0)\n                      | (octal & SGID ? S_ISGID : 0)\n                      | (octal & SVTX ? S_ISVTX : 0)\n                      | (octal & RUSR ? S_IRUSR : 0)\n                      | (octal & WUSR ? S_IWUSR : 0)\n                      | (octal & XUSR ? S_IXUSR : 0)\n                      | (octal & RGRP ? S_IRGRP : 0)\n                      | (octal & WGRP ? S_IWGRP : 0)\n                      | (octal & XGRP ? S_IXGRP : 0)\n                      | (octal & ROTH ? S_IROTH : 0)\n                      | (octal & WOTH ? S_IWOTH : 0)\n                      | (octal & XOTH ? S_IXOTH : 0)));\n}",
      "lines": 23,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "mode_t"
      ]
    },
    "make_node_op_equals": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static struct mode_change *\nmake_node_op_equals (mode_t new_mode, mode_t mentioned)\n{\n  struct mode_change *p = xmalloc (2 * sizeof *p);\n  p->op = '=';\n  p->flag = MODE_ORDINARY_CHANGE;\n  p->affected = CHMOD_MODE_BITS;\n  p->value = new_mode;\n  p->mentioned = mentioned;\n  p[1].flag = MODE_DONE;\n  return p;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct mode_change",
        "struct",
        "mode_change",
        "*\nmake_node_op_equals (mode_t new_mode, mode_t mentioned)",
        "*"
      ]
    },
    "mode_compile": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "struct mode_change *\nmode_compile (char const *mode_string)\n{\n  /* The array of mode-change directives to be returned.  */\n  struct mode_change *mc;\n  size_t used = 0;\n  char const *p;\n\n  if ('0' <= *mode_string && *mode_string < '8')\n    {\n      unsigned int octal_mode = 0;\n      mode_t mode;\n      mode_t mentioned;\n\n      p = mode_string;\n      do\n        {\n          octal_mode = 8 * octal_mode + *p++ - '0';\n          if (ALLM < octal_mode)\n            return NULL;\n        }\n      while ('0' <= *p && *p < '8');\n\n      if (*p)\n        return NULL;\n\n      mode = octal_to_mode (octal_mode);\n      mentioned = (p - mode_string < 5\n                   ? (mode & (S_ISUID | S_ISGID)) | S_ISVTX | S_IRWXUGO\n                   : CHMOD_MODE_BITS);\n      return make_node_op_equals (mode, mentioned);\n    }\n\n  /* Allocate enough space to hold the result.  */\n  {\n    size_t needed = 1;\n    for (p = mode_string; *p; p++)\n      needed += (*p == '=' || *p == '+' || *p == '-');\n    mc = xnmalloc (needed, sizeof *mc);\n  }\n\n  /* One loop iteration for each\n     '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.  */\n  for (p = mode_string; ; p++)\n    {\n      /* Which bits in the mode are operated on.  */\n      mode_t affected = 0;\n\n      /* Turn on all the bits in 'affected' for each group given.  */\n      for (;; p++)\n        switch (*p)\n          {\n          default:\n            goto invalid;\n          case 'u':\n            affected |= S_ISUID | S_IRWXU;\n            break;\n          case 'g':\n            affected |= S_ISGID | S_IRWXG;\n            break;\n          case 'o':\n            affected |= S_ISVTX | S_IRWXO;\n            break;\n          case 'a':\n            affected |= CHMOD_MODE_BITS;\n            break;\n          case '=': case '+': case '-':\n            goto no_more_affected;\n          }\n    no_more_affected:;\n\n      do\n        {\n          char op = *p++;\n          mode_t value;\n          mode_t mentioned = 0;\n          char flag = MODE_COPY_EXISTING;\n          struct mode_change *change;\n\n          switch (*p)\n            {\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              {\n                unsigned int octal_mode = 0;\n\n                do\n                  {\n                    octal_mode = 8 * octal_mode + *p++ - '0';\n                    if (ALLM < octal_mode)\n                      goto invalid;\n                  }\n                while ('0' <= *p && *p < '8');\n\n                if (affected || (*p && *p != ','))\n                  goto invalid;\n                affected = mentioned = CHMOD_MODE_BITS;\n                value = octal_to_mode (octal_mode);\n                flag = MODE_ORDINARY_CHANGE;\n                break;\n              }\n\n            case 'u':\n              /* Set the affected bits to the value of the \"u\" bits\n                 on the same file.  */\n              value = S_IRWXU;\n              p++;\n              break;\n            case 'g':\n              /* Set the affected bits to the value of the \"g\" bits\n                 on the same file.  */\n              value = S_IRWXG;\n              p++;\n              break;\n            case 'o':\n              /* Set the affected bits to the value of the \"o\" bits\n                 on the same file.  */\n              value = S_IRWXO;\n              p++;\n              break;\n\n            default:\n              value = 0;\n              flag = MODE_ORDINARY_CHANGE;\n\n              for (;; p++)\n                switch (*p)\n                  {\n                  case 'r':\n                    value |= S_IRUSR | S_IRGRP | S_IROTH;\n                    break;\n                  case 'w':\n                    value |= S_IWUSR | S_IWGRP | S_IWOTH;\n                    break;\n                  case 'x':\n                    value |= S_IXUSR | S_IXGRP | S_IXOTH;\n                    break;\n                  case 'X':\n                    flag = MODE_X_IF_ANY_X;\n                    break;\n                  case 's':\n                    /* Set the setuid/gid bits if 'u' or 'g' is selected.  */\n                    value |= S_ISUID | S_ISGID;\n                    break;\n                  case 't':\n                    /* Set the \"save text image\" bit if 'o' is selected.  */\n                    value |= S_ISVTX;\n                    break;\n                  default:\n                    goto no_more_values;\n                  }\n            no_more_values:;\n            }\n\n          change = &mc[used++];\n          change->op = op;\n          change->flag = flag;\n          change->affected = affected;\n          change->value = value;\n          change->mentioned =\n            (mentioned ? mentioned : affected ? affected & value : value);\n        }\n      while (*p == '=' || *p == '+' || *p == '-');\n\n      if (*p != ',')\n        break;\n    }\n\n  if (*p == 0)\n    {\n      mc[used].flag = MODE_DONE;\n      return mc;\n    }\n\ninvalid:\n  free (mc);\n  return NULL;\n}",
      "lines": 178,
      "depth": 19,
      "decorators": [
        "struct mode_change",
        "struct",
        "mode_change",
        "*\nmode_compile (char const *mode_string)",
        "*"
      ]
    },
    "mode_create_from_ref": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "struct mode_change *\nmode_create_from_ref (const char *ref_file)\n{\n  struct stat ref_stats;\n\n  if (stat (ref_file, &ref_stats) != 0)\n    return NULL;\n  return make_node_op_equals (ref_stats.st_mode, CHMOD_MODE_BITS);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct mode_change",
        "struct",
        "mode_change",
        "*\nmode_create_from_ref (const char *ref_file)",
        "*"
      ]
    },
    "mode_adjust": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "mode_t\nmode_adjust (mode_t oldmode, bool dir, mode_t umask_value,\n             struct mode_change const *changes, mode_t *pmode_bits)\n{\n  /* The adjusted mode.  */\n  mode_t newmode = oldmode & CHMOD_MODE_BITS;\n\n  /* File mode bits that CHANGES cares about.  */\n  mode_t mode_bits = 0;\n\n  for (; changes->flag != MODE_DONE; changes++)\n    {\n      mode_t affected = changes->affected;\n      mode_t omit_change =\n        (dir ? S_ISUID | S_ISGID : 0) & ~ changes->mentioned;\n      mode_t value = changes->value;\n\n      switch (changes->flag)\n        {\n        case MODE_ORDINARY_CHANGE:\n          break;\n\n        case MODE_COPY_EXISTING:\n          /* Isolate in 'value' the bits in 'newmode' to copy.  */\n          value &= newmode;\n\n          /* Copy the isolated bits to the other two parts.  */\n          value |= ((value & (S_IRUSR | S_IRGRP | S_IROTH)\n                     ? S_IRUSR | S_IRGRP | S_IROTH : 0)\n                    | (value & (S_IWUSR | S_IWGRP | S_IWOTH)\n                       ? S_IWUSR | S_IWGRP | S_IWOTH : 0)\n                    | (value & (S_IXUSR | S_IXGRP | S_IXOTH)\n                       ? S_IXUSR | S_IXGRP | S_IXOTH : 0));\n          break;\n\n        case MODE_X_IF_ANY_X:\n          /* Affect the execute bits if execute bits are already set\n             or if the file is a directory.  */\n          if ((newmode & (S_IXUSR | S_IXGRP | S_IXOTH)) | dir)\n            value |= S_IXUSR | S_IXGRP | S_IXOTH;\n          break;\n        }\n\n      /* If WHO was specified, limit the change to the affected bits.\n         Otherwise, apply the umask.  Either way, omit changes as\n         requested.  */\n      value &= (affected ? affected : ~umask_value) & ~ omit_change;\n\n      switch (changes->op)\n        {\n        case '=':\n          /* If WHO was specified, preserve the previous values of\n             bits that are not affected by this change operation.\n             Otherwise, clear all the bits.  */\n          {\n            mode_t preserved = (affected ? ~affected : 0) | omit_change;\n            mode_bits |= CHMOD_MODE_BITS & ~preserved;\n            newmode = (newmode & preserved) | value;\n            break;\n          }\n\n        case '+':\n          mode_bits |= value;\n          newmode |= value;\n          break;\n\n        case '-':\n          mode_bits |= value;\n          newmode &= ~value;\n          break;\n        }\n    }\n\n  if (pmode_bits)\n    *pmode_bits = mode_bits;\n  return newmode;\n}",
      "lines": 77,
      "depth": 19,
      "decorators": [
        "mode_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/modechange.h": {},
  "tar/tar-1.30/gnu/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/msvc-inval.h": {},
  "tar/tar-1.30/gnu/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/msvc-nothrow.h": {},
  "tar/tar-1.30/gnu/nl_langinfo.c": {
    "ctype_codeset": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static char *\nctype_codeset (void)\n{\n  static char buf[2 + 10 + 1];\n  char const *locale = setlocale (LC_CTYPE, NULL);\n  char *codeset = buf;\n  size_t codesetlen;\n  codeset[0] = '\\0';\n\n  if (locale && locale[0])\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      char *dot = strchr (locale, '.');\n\n      if (dot)\n        {\n          /* Look for the possible @... trailer and remove it, if any.  */\n          char *codeset_start = dot + 1;\n          char const *modifier = strchr (codeset_start, '@');\n\n          if (! modifier)\n            codeset = codeset_start;\n          else\n            {\n              codesetlen = modifier - codeset_start;\n              if (codesetlen < sizeof buf)\n                {\n                  codeset = memcpy (buf, codeset_start, codesetlen);\n                  codeset[codesetlen] = '\\0';\n                }\n            }\n        }\n    }\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* If setlocale is successful, it returns the number of the\n     codepage, as a string.  Otherwise, fall back on Windows API\n     GetACP, which returns the locale's codepage as a number (although\n     this doesn't change according to what the 'setlocale' call specified).\n     Either way, prepend \"CP\" to make it a valid codeset name.  */\n  codesetlen = strlen (codeset);\n  if (0 < codesetlen && codesetlen < sizeof buf - 2)\n    memmove (buf + 2, codeset, codesetlen + 1);\n  else\n    sprintf (buf + 2, \"%u\", GetACP ());\n  codeset = memcpy (buf, \"CP\", 2);\n#endif\n  return codeset;\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nctype_codeset (void)",
        "*"
      ]
    },
    "rpl_nl_langinfo": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "char *\nrpl_nl_langinfo (nl_item item)\n{\n  switch (item)\n    {\n# if GNULIB_defined_CODESET\n    case CODESET:\n      return ctype_codeset ();\n# endif\n# if GNULIB_defined_T_FMT_AMPM\n    case T_FMT_AMPM:\n      return (char *) \"%I:%M:%S %p\";\n# endif\n# if GNULIB_defined_ERA\n    case ERA:\n      /* The format is not standardized.  In glibc it is a sequence of strings\n         of the form \"direction:offset:start_date:end_date:era_name:era_format\"\n         with an empty string at the end.  */\n      return (char *) \"\";\n    case ERA_D_FMT:\n      /* The %Ex conversion in strftime behaves like %x if the locale does not\n         have an alternative time format.  */\n      item = D_FMT;\n      break;\n    case ERA_D_T_FMT:\n      /* The %Ec conversion in strftime behaves like %c if the locale does not\n         have an alternative time format.  */\n      item = D_T_FMT;\n      break;\n    case ERA_T_FMT:\n      /* The %EX conversion in strftime behaves like %X if the locale does not\n         have an alternative time format.  */\n      item = T_FMT;\n      break;\n    case ALT_DIGITS:\n      /* The format is not standardized.  In glibc it is a sequence of 10\n         strings, appended in memory.  */\n      return (char *) \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n# endif\n# if GNULIB_defined_YESEXPR || !FUNC_NL_LANGINFO_YESEXPR_WORKS\n    case YESEXPR:\n      return (char *) \"^[yY]\";\n    case NOEXPR:\n      return (char *) \"^[nN]\";\n# endif\n    default:\n      break;\n    }\n  return nl_langinfo (item);\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "char",
        "*\nrpl_nl_langinfo (nl_item item)",
        "*"
      ]
    },
    "nl_langinfo": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "char *\nnl_langinfo (nl_item item)\n{\n  static char nlbuf[100];\n  struct tm tmm = { 0 };\n\n  switch (item)\n    {\n    /* nl_langinfo items of the LC_CTYPE category */\n    case CODESET:\n      {\n        char *codeset = ctype_codeset ();\n        if (*codeset)\n          return codeset;\n      }\n# ifdef __BEOS__\n      return (char *) \"UTF-8\";\n# else\n      return (char *) \"ISO-8859-1\";\n# endif\n    /* nl_langinfo items of the LC_NUMERIC category */\n    case RADIXCHAR:\n      return localeconv () ->decimal_point;\n    case THOUSEP:\n      return localeconv () ->thousands_sep;\n    case GROUPING:\n      return localeconv () ->grouping;\n    /* nl_langinfo items of the LC_TIME category.\n       TODO: Really use the locale.  */\n    case D_T_FMT:\n    case ERA_D_T_FMT:\n      return (char *) \"%a %b %e %H:%M:%S %Y\";\n    case D_FMT:\n    case ERA_D_FMT:\n      return (char *) \"%m/%d/%y\";\n    case T_FMT:\n    case ERA_T_FMT:\n      return (char *) \"%H:%M:%S\";\n    case T_FMT_AMPM:\n      return (char *) \"%I:%M:%S %p\";\n    case AM_STR:\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return (char *) \"AM\";\n      return nlbuf;\n    case PM_STR:\n      tmm.tm_hour = 12;\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return (char *) \"PM\";\n      return nlbuf;\n    case DAY_1:\n    case DAY_2:\n    case DAY_3:\n    case DAY_4:\n    case DAY_5:\n    case DAY_6:\n    case DAY_7:\n      {\n        static char const days[][sizeof \"Wednesday\"] = {\n          \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n          \"Friday\", \"Saturday\"\n        };\n        tmm.tm_wday = item - DAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%A\", &tmm))\n          return (char *) days[item - DAY_1];\n        return nlbuf;\n      }\n    case ABDAY_1:\n    case ABDAY_2:\n    case ABDAY_3:\n    case ABDAY_4:\n    case ABDAY_5:\n    case ABDAY_6:\n    case ABDAY_7:\n      {\n        static char const abdays[][sizeof \"Sun\"] = {\n          \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n        };\n        tmm.tm_wday = item - ABDAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%a\", &tmm))\n          return (char *) abdays[item - ABDAY_1];\n        return nlbuf;\n      }\n    case MON_1:\n    case MON_2:\n    case MON_3:\n    case MON_4:\n    case MON_5:\n    case MON_6:\n    case MON_7:\n    case MON_8:\n    case MON_9:\n    case MON_10:\n    case MON_11:\n    case MON_12:\n      {\n        static char const months[][sizeof \"September\"] = {\n          \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n          \"September\", \"October\", \"November\", \"December\"\n        };\n        tmm.tm_mon = item - MON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%B\", &tmm))\n          return (char *) months[item - MON_1];\n        return nlbuf;\n      }\n    case ABMON_1:\n    case ABMON_2:\n    case ABMON_3:\n    case ABMON_4:\n    case ABMON_5:\n    case ABMON_6:\n    case ABMON_7:\n    case ABMON_8:\n    case ABMON_9:\n    case ABMON_10:\n    case ABMON_11:\n    case ABMON_12:\n      {\n        static char const abmonths[][sizeof \"Jan\"] = {\n          \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\",\n          \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n        };\n        tmm.tm_mon = item - ABMON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%b\", &tmm))\n          return (char *) abmonths[item - ABMON_1];\n        return nlbuf;\n      }\n    case ERA:\n      return (char *) \"\";\n    case ALT_DIGITS:\n      return (char *) \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n    /* nl_langinfo items of the LC_MONETARY category.  */\n    case CRNCYSTR:\n      return localeconv () ->currency_symbol;\n    case INT_CURR_SYMBOL:\n      return localeconv () ->int_curr_symbol;\n    case MON_DECIMAL_POINT:\n      return localeconv () ->mon_decimal_point;\n    case MON_THOUSANDS_SEP:\n      return localeconv () ->mon_thousands_sep;\n    case MON_GROUPING:\n      return localeconv () ->mon_grouping;\n    case POSITIVE_SIGN:\n      return localeconv () ->positive_sign;\n    case NEGATIVE_SIGN:\n      return localeconv () ->negative_sign;\n    case FRAC_DIGITS:\n      return & localeconv () ->frac_digits;\n    case INT_FRAC_DIGITS:\n      return & localeconv () ->int_frac_digits;\n    case P_CS_PRECEDES:\n      return & localeconv () ->p_cs_precedes;\n    case N_CS_PRECEDES:\n      return & localeconv () ->n_cs_precedes;\n    case P_SEP_BY_SPACE:\n      return & localeconv () ->p_sep_by_space;\n    case N_SEP_BY_SPACE:\n      return & localeconv () ->n_sep_by_space;\n    case P_SIGN_POSN:\n      return & localeconv () ->p_sign_posn;\n    case N_SIGN_POSN:\n      return & localeconv () ->n_sign_posn;\n    /* nl_langinfo items of the LC_MESSAGES category\n       TODO: Really use the locale. */\n    case YESEXPR:\n      return (char *) \"^[yY]\";\n    case NOEXPR:\n      return (char *) \"^[nN]\";\n    default:\n      return (char *) \"\";\n    }\n}",
      "lines": 171,
      "depth": 13,
      "decorators": [
        "char",
        "*\nnl_langinfo (nl_item item)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/nstrftime.c": {
    "fwrite_lowcase": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static void\nfwrite_lowcase (FILE *fp, const CHAR_T *src, size_t len)\n{\n  while (len-- > 0)\n    {\n      fputc (TOLOWER ((UCHAR_T) *src, loc), fp);\n      ++src;\n    }\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fwrite_uppcase": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "static void\nfwrite_uppcase (FILE *fp, const CHAR_T *src, size_t len)\n{\n  while (len-- > 0)\n    {\n      fputc (TOUPPER ((UCHAR_T) *src, loc), fp);\n      ++src;\n    }\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "memcpy_lowcase": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "static CHAR_T *\nmemcpy_lowcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)\n{\n  while (len-- > 0)\n    dest[len] = TOLOWER ((UCHAR_T) src[len], loc);\n  return dest;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "CHAR_T",
        "*\nmemcpy_lowcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)",
        "*"
      ]
    },
    "memcpy_uppcase": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static CHAR_T *\nmemcpy_uppcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)\n{\n  while (len-- > 0)\n    dest[len] = TOUPPER ((UCHAR_T) src[len], loc);\n  return dest;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "CHAR_T",
        "*\nmemcpy_uppcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)",
        "*"
      ]
    },
    "tm_diff": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "static int\ntm_diff (const struct tm *a, const struct tm *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations,\n     but it's OK to assume that A and B are close to each other.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  int years = a->tm_year - b->tm_year;\n  int days = (365 * years + intervening_leap_days\n              + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso_week_days": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "static int\niso_week_days (int yday, int wday)\n{\n  /* Add enough to the first operand of % to make it nonnegative.  */\n  int big_enough_multiple_of_7 = (-YDAY_MINIMUM / 7 + 2) * 7;\n  return (yday\n          - (yday - wday + ISO_WEEK1_WDAY + big_enough_multiple_of_7) % 7\n          + ISO_WEEK1_WDAY - ISO_WEEK_START_WDAY);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "my_strftime": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "size_t\nmy_strftime (STREAM_OR_CHAR_T *s, STRFTIME_ARG (size_t maxsize)\n             const CHAR_T *format,\n             const struct tm *tp extra_args_spec LOCALE_PARAM)\n{\n  bool tzset_called = false;\n  return __strftime_internal (s, STRFTIME_ARG (maxsize) format, tp,\n                              false, &tzset_called extra_args LOCALE_ARG);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "__strftime_internal": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        1505,
        1
      ],
      "content": "static size_t\n__strftime_internal (STREAM_OR_CHAR_T *s, STRFTIME_ARG (size_t maxsize)\n                     const CHAR_T *format,\n                     const struct tm *tp, bool upcase, bool *tzset_called\n                     extra_args_spec LOCALE_PARAM)\n{\n#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL\n  struct __locale_data *const current = loc->__locales[LC_TIME];\n#endif\n#if FPRINTFTIME\n  size_t maxsize = (size_t) -1;\n#endif\n\n  int hour12 = tp->tm_hour;\n#ifdef _NL_CURRENT\n  /* We cannot make the following values variables since we must delay\n     the evaluation of these values until really needed since some\n     expressions might not be valid in every situation.  The 'struct tm'\n     might be generated by a strptime() call that initialized\n     only a few elements.  Dereference the pointers only if the format\n     requires this.  Then it is ok to fail if the pointers are invalid.  */\n# define a_wkday \\\n  ((const CHAR_T *) (tp->tm_wday < 0 || tp->tm_wday > 6                      \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday)))\n# define f_wkday \\\n  ((const CHAR_T *) (tp->tm_wday < 0 || tp->tm_wday > 6                      \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday)))\n# define a_month \\\n  ((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon)))\n# define f_month \\\n  ((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon)))\n# define ampm \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11                    \\\n                                 ? NLW(PM_STR) : NLW(AM_STR)))\n\n# define aw_len STRLEN (a_wkday)\n# define am_len STRLEN (a_month)\n# define ap_len STRLEN (ampm)\n#endif\n#if HAVE_TZNAME\n  char **tzname_vec = tzname;\n#endif\n  const char *zone;\n  size_t i = 0;\n  STREAM_OR_CHAR_T *p = s;\n  const CHAR_T *f;\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n  const char *format_end = NULL;\n#endif\n\n#if ! defined _LIBC && ! HAVE_RUN_TZSET_TEST\n  /* Solaris 2.5.x and 2.6 tzset sometimes modify the storage returned\n     by localtime.  On such systems, we must either use the tzset and\n     localtime wrappers to work around the bug (which sets\n     HAVE_RUN_TZSET_TEST) or make a copy of the structure.  */\n  struct tm copy = *tp;\n  tp = &copy;\n#endif\n\n  zone = NULL;\n#if HAVE_TM_ZONE\n  /* The POSIX test suite assumes that setting\n     the environment variable TZ to a new value before calling strftime()\n     will influence the result (the %Z format) even if the information in\n     TP is computed with a totally different time zone.\n     This is bogus: though POSIX allows bad behavior like this,\n     POSIX does not require it.  Do the right thing instead.  */\n  zone = (const char *) tp->tm_zone;\n#endif\n#if HAVE_TZNAME\n  if (!tz)\n    {\n      if (! (zone && *zone))\n        zone = \"GMT\";\n    }\n  else\n    {\n# if !HAVE_TM_ZONE\n      /* Infer the zone name from *TZ instead of from TZNAME.  */\n      tzname_vec = tz->tzname_copy;\n# endif\n    }\n  /* The tzset() call might have changed the value.  */\n  if (!(zone && *zone) && tp->tm_isdst >= 0)\n    {\n      /* POSIX.1 requires that local time zone information be used as\n         though strftime called tzset.  */\n# if HAVE_TZSET\n      if (!*tzset_called)\n        {\n          tzset ();\n          *tzset_called = true;\n        }\n# endif\n      zone = tzname_vec[tp->tm_isdst != 0];\n    }\n#endif\n  if (! zone)\n    zone = \"\";\n\n  if (hour12 > 12)\n    hour12 -= 12;\n  else\n    if (hour12 == 0)\n      hour12 = 12;\n\n  for (f = format; *f != '\\0'; ++f)\n    {\n      int pad = 0;              /* Padding for number ('-', '_', or 0).  */\n      int modifier;             /* Field modifier ('E', 'O', or 0).  */\n      int digits = 0;           /* Max digits for numeric format.  */\n      int number_value;         /* Numeric value to be printed.  */\n      unsigned int u_number_value; /* (unsigned int) number_value.  */\n      bool negative_number;     /* The number is negative.  */\n      bool always_output_a_sign; /* +/- should always be output.  */\n      int tz_colon_mask;        /* Bitmask of where ':' should appear.  */\n      const CHAR_T *subfmt;\n      CHAR_T sign_char;\n      CHAR_T *bufp;\n      CHAR_T buf[1\n                 + 2 /* for the two colons in a %::z or %:::z time zone */\n                 + (sizeof (int) < sizeof (time_t)\n                    ? INT_STRLEN_BOUND (time_t)\n                    : INT_STRLEN_BOUND (int))];\n      int width = -1;\n      bool to_lowcase = false;\n      bool to_uppcase = upcase;\n      size_t colons;\n      bool change_case = false;\n      int format_char;\n\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n      switch (*f)\n        {\n        case L_('%'):\n          break;\n\n        case L_('\\b'): case L_('\\t'): case L_('\\n'):\n        case L_('\\v'): case L_('\\f'): case L_('\\r'):\n        case L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n        case L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n        case L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n        case L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n        case L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n        case L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n        case L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n        case L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n        case L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n        case L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n        case L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n        case L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n        case L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n        case L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n        case L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n        case L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n        case L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n        case L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n        case L_('~'):\n          /* The C Standard requires these 98 characters (plus '%') to\n             be in the basic execution character set.  None of these\n             characters can start a multibyte sequence, so they need\n             not be analyzed further.  */\n          add1 (*f);\n          continue;\n\n        default:\n          /* Copy this multibyte sequence until we reach its end, find\n             an error, or come back to the initial shift state.  */\n          {\n            mbstate_t mbstate = mbstate_zero;\n            size_t len = 0;\n            size_t fsize;\n\n            if (! format_end)\n              format_end = f + strlen (f) + 1;\n            fsize = format_end - f;\n\n            do\n              {\n                size_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n                if (bytes == 0)\n                  break;\n\n                if (bytes == (size_t) -2)\n                  {\n                    len += strlen (f + len);\n                    break;\n                  }\n\n                if (bytes == (size_t) -1)\n                  {\n                    len++;\n                    break;\n                  }\n\n                len += bytes;\n              }\n            while (! mbsinit (&mbstate));\n\n            cpy (len, f);\n            f += len - 1;\n            continue;\n          }\n        }\n\n#else /* ! DO_MULTIBYTE */\n\n      /* Either multibyte encodings are not supported, they are\n         safe for formats, so any non-'%' byte can be copied through,\n         or this is the wide character version.  */\n      if (*f != L_('%'))\n        {\n          add1 (*f);\n          continue;\n        }\n\n#endif /* ! DO_MULTIBYTE */\n\n      /* Check for flags that can modify a format.  */\n      while (1)\n        {\n          switch (*++f)\n            {\n              /* This influences the number formats.  */\n            case L_('_'):\n            case L_('-'):\n            case L_('0'):\n              pad = *f;\n              continue;\n\n              /* This changes textual output.  */\n            case L_('^'):\n              to_uppcase = true;\n              continue;\n            case L_('#'):\n              change_case = true;\n              continue;\n\n            default:\n              break;\n            }\n          break;\n        }\n\n      /* As a GNU extension we allow the field width to be specified.  */\n      if (ISDIGIT (*f))\n        {\n          width = 0;\n          do\n            {\n              if (width > INT_MAX / 10\n                  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n                /* Avoid overflow.  */\n                width = INT_MAX;\n              else\n                {\n                  width *= 10;\n                  width += *f - L_('0');\n                }\n              ++f;\n            }\n          while (ISDIGIT (*f));\n        }\n\n      /* Check for modifiers.  */\n      switch (*f)\n        {\n        case L_('E'):\n        case L_('O'):\n          modifier = *f++;\n          break;\n\n        default:\n          modifier = 0;\n          break;\n        }\n\n      /* Now do the specified format.  */\n      format_char = *f;\n      switch (format_char)\n        {\n#define DO_NUMBER(d, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              number_value = v;                                               \\\n              goto do_number;                                                 \\\n            }                                                                 \\\n          while (0)\n#define DO_SIGNED_NUMBER(d, negative, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              negative_number = negative;                                     \\\n              u_number_value = v;                                             \\\n              goto do_signed_number;                                          \\\n            }                                                                 \\\n          while (0)\n\n          /* The mask is not what you might think.\n             When the ordinal i'th bit is set, insert a colon\n             before the i'th digit of the time zone representation.  */\n#define DO_TZ_OFFSET(d, mask, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              tz_colon_mask = mask;                                           \\\n              u_number_value = v;                                             \\\n              goto do_tz_offset;                                              \\\n            }                                                                 \\\n          while (0)\n#define DO_NUMBER_SPACEPAD(d, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              number_value = v;                                               \\\n              goto do_number_spacepad;                                        \\\n            }                                                                 \\\n          while (0)\n\n        case L_('%'):\n          if (modifier != 0)\n            goto bad_format;\n          add1 (*f);\n          break;\n\n        case L_('a'):\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (aw_len, a_wkday);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case 'A':\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (STRLEN (f_wkday), f_wkday);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('b'):\n        case L_('h'):\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n          if (modifier != 0)\n            goto bad_format;\n#ifdef _NL_CURRENT\n          cpy (am_len, a_month);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('B'):\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (STRLEN (f_month), f_month);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('c'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == 'E'\n                 && (*(subfmt =\n                       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n                                                     NLW(ERA_D_T_FMT)))\n                     != '\\0')))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n          goto underlying_strftime;\n#endif\n\n        subformat:\n          {\n            size_t len = __strftime_internal (NULL, STRFTIME_ARG ((size_t) -1)\n                                              subfmt,\n                                              tp, to_uppcase, tzset_called\n                                              extra_args LOCALE_ARG);\n            add (len, __strftime_internal (p,\n                                           STRFTIME_ARG (maxsize - i)\n                                           subfmt,\n                                           tp, to_uppcase, tzset_called\n                                           extra_args LOCALE_ARG));\n          }\n          break;\n\n#if !(defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n        underlying_strftime:\n          {\n            /* The relevant information is available only via the\n               underlying strftime implementation, so use that.  */\n            char ufmt[5];\n            char *u = ufmt;\n            char ubuf[1024]; /* enough for any single format in practice */\n            size_t len;\n            /* Make sure we're calling the actual underlying strftime.\n               In some cases, config.h contains something like\n               \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n            size_t strftime ();\n# endif\n\n            /* The space helps distinguish strftime failure from empty\n               output.  */\n            *u++ = ' ';\n            *u++ = '%';\n            if (modifier != 0)\n              *u++ = modifier;\n            *u++ = format_char;\n            *u = '\\0';\n            len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n            if (len != 0)\n              cpy (len - 1, ubuf + 1);\n          }\n          break;\n#endif\n\n        case L_('C'):\n          if (modifier == L_('E'))\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n# ifdef COMPILE_WIDE\n                  size_t len = __wcslen (era->era_wname);\n                  cpy (len, era->era_wname);\n# else\n                  size_t len = strlen (era->era_name);\n                  cpy (len, era->era_name);\n# endif\n                  break;\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          {\n            int century = tp->tm_year / 100 + TM_YEAR_BASE / 100;\n            century -= tp->tm_year % 100 < 0 && 0 < century;\n            DO_SIGNED_NUMBER (2, tp->tm_year < - TM_YEAR_BASE, century);\n          }\n\n        case L_('x'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == L_('E')\n                 && (*(subfmt =\n                       (const CHAR_T *)_NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n                     != L_('\\0'))))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n        case L_('D'):\n          if (modifier != 0)\n            goto bad_format;\n          subfmt = L_(\"%m/%d/%y\");\n          goto subformat;\n\n        case L_('d'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_mday);\n\n        case L_('e'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n          /* All numeric formats set DIGITS and NUMBER_VALUE (or U_NUMBER_VALUE)\n             and then jump to one of these labels.  */\n\n        do_tz_offset:\n          always_output_a_sign = true;\n          goto do_number_body;\n\n        do_number_spacepad:\n          /* Force '_' flag unless overridden by '0' or '-' flag.  */\n          if (pad != L_('0') && pad != L_('-'))\n            pad = L_('_');\n\n        do_number:\n          /* Format NUMBER_VALUE according to the MODIFIER flag.  */\n          negative_number = number_value < 0;\n          u_number_value = number_value;\n\n        do_signed_number:\n          always_output_a_sign = false;\n          tz_colon_mask = 0;\n\n        do_number_body:\n          /* Format U_NUMBER_VALUE according to the MODIFIER flag.\n             NEGATIVE_NUMBER is nonzero if the original number was\n             negative; in this case it was converted directly to\n             unsigned int (i.e., modulo (UINT_MAX + 1)) without\n             negating it.  */\n          if (modifier == L_('O') && !negative_number)\n            {\n#ifdef _NL_CURRENT\n              /* Get the locale specific alternate representation of\n                 the number.  If none exist NULL is returned.  */\n              const CHAR_T *cp = nl_get_alt_digit (u_number_value\n                                                   HELPER_LOCALE_ARG);\n\n              if (cp != NULL)\n                {\n                  size_t digitlen = STRLEN (cp);\n                  if (digitlen != 0)\n                    {\n                      cpy (digitlen, cp);\n                      break;\n                    }\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          bufp = buf + sizeof (buf) / sizeof (buf[0]);\n\n          if (negative_number)\n            u_number_value = - u_number_value;\n\n          do\n            {\n              if (tz_colon_mask & 1)\n                *--bufp = ':';\n              tz_colon_mask >>= 1;\n              *--bufp = u_number_value % 10 + L_('0');\n              u_number_value /= 10;\n            }\n          while (u_number_value != 0 || tz_colon_mask != 0);\n\n        do_number_sign_and_padding:\n          if (digits < width)\n            digits = width;\n\n          sign_char = (negative_number ? L_('-')\n                       : always_output_a_sign ? L_('+')\n                       : 0);\n\n          if (pad == L_('-'))\n            {\n              if (sign_char)\n                add1 (sign_char);\n            }\n          else\n            {\n              int padding = digits - (buf + (sizeof (buf) / sizeof (buf[0]))\n                                      - bufp) - !!sign_char;\n\n              if (padding > 0)\n                {\n                  if (pad == L_('_'))\n                    {\n                      if ((size_t) padding >= maxsize - i)\n                        return 0;\n\n                      if (p)\n                        memset_space (p, padding);\n                      i += padding;\n                      width = width > padding ? width - padding : 0;\n                      if (sign_char)\n                        add1 (sign_char);\n                    }\n                  else\n                    {\n                      if ((size_t) digits >= maxsize - i)\n                        return 0;\n\n                      if (sign_char)\n                        add1 (sign_char);\n\n                      if (p)\n                        memset_zero (p, padding);\n                      i += padding;\n                      width = 0;\n                    }\n                }\n              else\n                {\n                  if (sign_char)\n                    add1 (sign_char);\n                }\n            }\n\n          cpy (buf + sizeof (buf) / sizeof (buf[0]) - bufp, bufp);\n          break;\n\n        case L_('F'):\n          if (modifier != 0)\n            goto bad_format;\n          subfmt = L_(\"%Y-%m-%d\");\n          goto subformat;\n\n        case L_('H'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_hour);\n\n        case L_('I'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, hour12);\n\n        case L_('k'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n        case L_('l'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, hour12);\n\n        case L_('j'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (3, tp->tm_yday < -1, tp->tm_yday + 1U);\n\n        case L_('M'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_min);\n\n        case L_('m'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (2, tp->tm_mon < -1, tp->tm_mon + 1U);\n\n#ifndef _LIBC\n        case L_('N'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          number_value = ns;\n          if (width == -1)\n            width = 9;\n          else\n            {\n              /* Take an explicit width less than 9 as a precision.  */\n              int j;\n              for (j = width; j < 9; j++)\n                number_value /= 10;\n            }\n\n          DO_NUMBER (width, number_value);\n#endif\n\n        case L_('n'):\n          add1 (L_('\\n'));\n          break;\n\n        case L_('P'):\n          to_lowcase = true;\n#ifndef _NL_CURRENT\n          format_char = L_('p');\n#endif\n          FALLTHROUGH;\n        case L_('p'):\n          if (change_case)\n            {\n              to_uppcase = false;\n              to_lowcase = true;\n            }\n#ifdef _NL_CURRENT\n          cpy (ap_len, ampm);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('q'):           /* GNU extension.  */\n          DO_SIGNED_NUMBER (1, false, ((tp->tm_mon * 11) >> 5) + 1);\n          break;\n\n        case L_('R'):\n          subfmt = L_(\"%H:%M\");\n          goto subformat;\n\n        case L_('r'):\n#ifdef _NL_CURRENT\n          if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n                                                       NLW(T_FMT_AMPM)))\n              == L_('\\0'))\n            subfmt = L_(\"%I:%M:%S %p\");\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('S'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_sec);\n\n        case L_('s'):           /* GNU extension.  */\n          {\n            struct tm ltm;\n            time_t t;\n\n            ltm = *tp;\n            t = mktime_z (tz, &ltm);\n\n            /* Generate string value for T using time_t arithmetic;\n               this works even if sizeof (long) < sizeof (time_t).  */\n\n            bufp = buf + sizeof (buf) / sizeof (buf[0]);\n            negative_number = t < 0;\n\n            do\n              {\n                int d = t % 10;\n                t /= 10;\n                *--bufp = (negative_number ? -d : d) + L_('0');\n              }\n            while (t != 0);\n\n            digits = 1;\n            always_output_a_sign = false;\n            goto do_number_sign_and_padding;\n          }\n\n        case L_('X'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == L_('E')\n                 && (*(subfmt =\n                       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n                     != L_('\\0'))))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n        case L_('T'):\n          subfmt = L_(\"%H:%M:%S\");\n          goto subformat;\n\n        case L_('t'):\n          add1 (L_('\\t'));\n          break;\n\n        case L_('u'):\n          DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n        case L_('U'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n        case L_('V'):\n        case L_('g'):\n        case L_('G'):\n          if (modifier == L_('E'))\n            goto bad_format;\n          {\n            /* YEAR is a leap year if and only if (tp->tm_year + TM_YEAR_BASE)\n               is a leap year, except that YEAR and YEAR - 1 both work\n               correctly even when (tp->tm_year + TM_YEAR_BASE) would\n               overflow.  */\n            int year = (tp->tm_year\n                        + (tp->tm_year < 0\n                           ? TM_YEAR_BASE % 400\n                           : TM_YEAR_BASE % 400 - 400));\n            int year_adjust = 0;\n            int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n            if (days < 0)\n              {\n                /* This ISO week belongs to the previous year.  */\n                year_adjust = -1;\n                days = iso_week_days (tp->tm_yday + (365 + __isleap (year - 1)),\n                                      tp->tm_wday);\n              }\n            else\n              {\n                int d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n                                       tp->tm_wday);\n                if (0 <= d)\n                  {\n                    /* This ISO week belongs to the next year.  */\n                    year_adjust = 1;\n                    days = d;\n                  }\n              }\n\n            switch (*f)\n              {\n              case L_('g'):\n                {\n                  int yy = (tp->tm_year % 100 + year_adjust) % 100;\n                  DO_NUMBER (2, (0 <= yy\n                                 ? yy\n                                 : tp->tm_year < -TM_YEAR_BASE - year_adjust\n                                 ? -yy\n                                 : yy + 100));\n                }\n\n              case L_('G'):\n                DO_SIGNED_NUMBER (4, tp->tm_year < -TM_YEAR_BASE - year_adjust,\n                                  (tp->tm_year + (unsigned int) TM_YEAR_BASE\n                                   + year_adjust));\n\n              default:\n                DO_NUMBER (2, days / 7 + 1);\n              }\n          }\n\n        case L_('W'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n        case L_('w'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (1, tp->tm_wday);\n\n        case L_('Y'):\n          if (modifier == 'E')\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n# ifdef COMPILE_WIDE\n                  subfmt = era->era_wformat;\n# else\n                  subfmt = era->era_format;\n# endif\n                  goto subformat;\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n          if (modifier == L_('O'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (4, tp->tm_year < -TM_YEAR_BASE,\n                            tp->tm_year + (unsigned int) TM_YEAR_BASE);\n\n        case L_('y'):\n          if (modifier == L_('E'))\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n                  int delta = tp->tm_year - era->start_date[0];\n                  DO_NUMBER (1, (era->offset\n                                 + delta * era->absolute_direction));\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          {\n            int yy = tp->tm_year % 100;\n            if (yy < 0)\n              yy = tp->tm_year < - TM_YEAR_BASE ? -yy : yy + 100;\n            DO_NUMBER (2, yy);\n          }\n\n        case L_('Z'):\n          if (change_case)\n            {\n              to_uppcase = false;\n              to_lowcase = true;\n            }\n\n#ifdef COMPILE_WIDE\n          {\n            /* The zone string is always given in multibyte form.  We have\n               to transform it first.  */\n            wchar_t *wczone;\n            size_t len;\n            widen (zone, wczone, len);\n            cpy (len, wczone);\n          }\n#else\n          cpy (strlen (zone), zone);\n#endif\n          break;\n\n        case L_(':'):\n          /* :, ::, and ::: are valid only just before 'z'.\n             :::: etc. are rejected later.  */\n          for (colons = 1; f[colons] == L_(':'); colons++)\n            continue;\n          if (f[colons] != L_('z'))\n            goto bad_format;\n          f += colons;\n          goto do_z_conversion;\n\n        case L_('z'):\n          colons = 0;\n\n        do_z_conversion:\n          if (tp->tm_isdst < 0)\n            break;\n\n          {\n            int diff;\n            int hour_diff;\n            int min_diff;\n            int sec_diff;\n#if HAVE_TM_GMTOFF\n            diff = tp->tm_gmtoff;\n#else\n            if (!tz)\n              diff = 0;\n            else\n              {\n                struct tm gtm;\n                struct tm ltm;\n                time_t lt;\n\n                /* POSIX.1 requires that local time zone information be used as\n                   though strftime called tzset.  */\n# if HAVE_TZSET\n                if (!*tzset_called)\n                  {\n                    tzset ();\n                    *tzset_called = true;\n                  }\n# endif\n\n                ltm = *tp;\n                lt = mktime_z (tz, &ltm);\n\n                if (lt == (time_t) -1)\n                  {\n                    /* mktime returns -1 for errors, but -1 is also a\n                       valid time_t value.  Check whether an error really\n                       occurred.  */\n                    struct tm tm;\n\n                    if (! localtime_rz (tz, &lt, &tm)\n                        || ((ltm.tm_sec ^ tm.tm_sec)\n                            | (ltm.tm_min ^ tm.tm_min)\n                            | (ltm.tm_hour ^ tm.tm_hour)\n                            | (ltm.tm_mday ^ tm.tm_mday)\n                            | (ltm.tm_mon ^ tm.tm_mon)\n                            | (ltm.tm_year ^ tm.tm_year)))\n                      break;\n                  }\n\n                if (! localtime_rz (0, &lt, &gtm))\n                  break;\n\n                diff = tm_diff (&ltm, &gtm);\n              }\n#endif\n\n            negative_number = diff < 0 || (diff == 0 && *zone == '-');\n            hour_diff = diff / 60 / 60;\n            min_diff = diff / 60 % 60;\n            sec_diff = diff % 60;\n\n            switch (colons)\n              {\n              case 0: /* +hhmm */\n                DO_TZ_OFFSET (5, 0, hour_diff * 100 + min_diff);\n\n              case 1: tz_hh_mm: /* +hh:mm */\n                DO_TZ_OFFSET (6, 04, hour_diff * 100 + min_diff);\n\n              case 2: tz_hh_mm_ss: /* +hh:mm:ss */\n                DO_TZ_OFFSET (9, 024,\n                              hour_diff * 10000 + min_diff * 100 + sec_diff);\n\n              case 3: /* +hh if possible, else +hh:mm, else +hh:mm:ss */\n                if (sec_diff != 0)\n                  goto tz_hh_mm_ss;\n                if (min_diff != 0)\n                  goto tz_hh_mm;\n                DO_TZ_OFFSET (3, 0, hour_diff);\n\n              default:\n                goto bad_format;\n              }\n          }\n\n        case L_('\\0'):          /* GNU extension: % at end of format.  */\n            --f;\n            FALLTHROUGH;\n        default:\n          /* Unknown format; output the format, including the '%',\n             since this is most likely the right thing to do if a\n             multibyte string has been misparsed.  */\n        bad_format:\n          {\n            int flen;\n            for (flen = 1; f[1 - flen] != L_('%'); flen++)\n              continue;\n            cpy (flen, &f[1 - flen]);\n          }\n          break;\n        }\n    }\n\n#if ! FPRINTFTIME\n  if (p && maxsize != 0)\n    *p = L_('\\0');\n#endif\n\n  return i;\n}",
      "lines": 1062,
      "depth": 27,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/obstack.c": {
    "call_chunkfun": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void *\ncall_chunkfun (struct obstack *h, size_t size)\n{\n  if (h->use_extra_arg)\n    return h->chunkfun.extra (h->extra_arg, size);\n  else\n    return h->chunkfun.plain (size);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ncall_chunkfun (struct obstack *h, size_t size)",
        "*"
      ]
    },
    "call_freefun": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ncall_freefun (struct obstack *h, void *old_chunk)\n{\n  if (h->use_extra_arg)\n    h->freefun.extra (h->extra_arg, old_chunk);\n  else\n    h->freefun.plain (old_chunk);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_obstack_begin_worker": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static int\n_obstack_begin_worker (struct obstack *h,\n                       _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment)\n{\n  struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n         Use the values for range checking, because if range checking is off,\n         the extra bytes won't be missed terribly, but if range checking is on\n         and we used a larger request, a whole extra 4096 bytes would be\n         allocated.\n\n         These number are irrelevant to the new GNU malloc.  I suspect it is\n         less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n                    + 4 + DEFAULT_ROUNDING - 1)\n                   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n\n  chunk = h->chunk = call_chunkfun (h, h->chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n                                               alignment - 1);\n  h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
      "lines": 40,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_obstack_begin": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\n_obstack_begin (struct obstack *h,\n                _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n                void *(*chunkfun) (size_t),\n                void (*freefun) (void *))\n{\n  h->chunkfun.plain = chunkfun;\n  h->freefun.plain = freefun;\n  h->use_extra_arg = 0;\n  return _obstack_begin_worker (h, size, alignment);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_obstack_begin_1": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\n_obstack_begin_1 (struct obstack *h,\n                  _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n                  void *(*chunkfun) (void *, size_t),\n                  void (*freefun) (void *, void *),\n                  void *arg)\n{\n  h->chunkfun.extra = chunkfun;\n  h->freefun.extra = freefun;\n  h->extra_arg = arg;\n  h->use_extra_arg = 1;\n  return _obstack_begin_worker (h, size, alignment);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_obstack_newchunk": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "void\n_obstack_newchunk (struct obstack *h, _OBSTACK_SIZE_T length)\n{\n  struct _obstack_chunk *old_chunk = h->chunk;\n  struct _obstack_chunk *new_chunk = 0;\n  size_t obj_size = h->next_free - h->object_base;\n  char *object_base;\n\n  /* Compute size for new chunk.  */\n  size_t sum1 = obj_size + length;\n  size_t sum2 = sum1 + h->alignment_mask;\n  size_t new_size = sum2 + (obj_size >> 3) + 100;\n  if (new_size < sum2)\n    new_size = sum2;\n  if (new_size < h->chunk_size)\n    new_size = h->chunk_size;\n\n  /* Allocate and initialize the new chunk.  */\n  if (obj_size <= sum1 && sum1 <= sum2)\n    new_chunk = call_chunkfun (h, new_size);\n  if (!new_chunk)\n    (*obstack_alloc_failed_handler)();\n  h->chunk = new_chunk;\n  new_chunk->prev = old_chunk;\n  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n\n  /* Compute an aligned object_base in the new chunk */\n  object_base =\n    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);\n\n  /* Move the existing object to the new chunk.  */\n  memcpy (object_base, h->object_base, obj_size);\n\n  /* If the object just copied was the only data in OLD_CHUNK,\n     free that chunk and remove it from the chain.\n     But not if that chunk might contain an empty object.  */\n  if (!h->maybe_empty_object\n      && (h->object_base\n          == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,\n                          h->alignment_mask)))\n    {\n      new_chunk->prev = old_chunk->prev;\n      call_freefun (h, old_chunk);\n    }\n\n  h->object_base = object_base;\n  h->next_free = h->object_base + obj_size;\n  /* The new chunk certainly contains no empty object yet.  */\n  h->maybe_empty_object = 0;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_obstack_allocated_p": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "int\n_obstack_allocated_p (struct obstack *h, void *obj)\n{\n  struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n  struct _obstack_chunk *plp;   /* point to previous chunk if any */\n\n  lp = (h)->chunk;\n  /* We use >= rather than > since the object cannot be exactly at\n     the beginning of the chunk but might be an empty object exactly\n     at the end of an adjacent chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      lp = plp;\n    }\n  return lp != 0;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_obstack_free": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "void\n_obstack_free (struct obstack *h, void *obj)\n{\n  struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n  struct _obstack_chunk *plp;   /* point to previous chunk if any */\n\n  lp = h->chunk;\n  /* We use >= because there cannot be an object at the beginning of a chunk.\n     But there can be an empty object at that address\n     at the end of another chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      call_freefun (h, lp);\n      lp = plp;\n      /* If we switch chunks, we can't tell whether the new current\n         chunk contains an empty object, so assume that it may.  */\n      h->maybe_empty_object = 1;\n    }\n  if (lp)\n    {\n      h->object_base = h->next_free = (char *) (obj);\n      h->chunk_limit = lp->limit;\n      h->chunk = lp;\n    }\n  else if (obj != 0)\n    /* obj is not in any of the chunks! */\n    abort ();\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_obstack_memory_used": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "_OBSTACK_SIZE_T\n_obstack_memory_used (struct obstack *h)\n{\n  struct _obstack_chunk *lp;\n  _OBSTACK_SIZE_T nbytes = 0;\n\n  for (lp = h->chunk; lp != 0; lp = lp->prev)\n    {\n      nbytes += lp->limit - (char *) lp;\n    }\n  return nbytes;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "_OBSTACK_SIZE_T"
      ]
    },
    "print_and_abort": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static _Noreturn void\nprint_and_abort (void)\n{\n  /* Don't change any of these strings.  Yes, it would be possible to add\n     the newline to the string and use fputs or so.  But this must not\n     happen because the \"memory exhausted\" message appears in other places\n     like this and the translation should be reused instead of creating\n     a very similar string which requires a separate translation.  */\n#  ifdef _LIBC\n  (void) __fxprintf (NULL, \"%s\\n\", _(\"memory exhausted\"));\n#  else\n  fprintf (stderr, \"%s\\n\", _(\"memory exhausted\"));\n#  endif\n  exit (obstack_exit_failure);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/obstack.h": {},
  "tar/tar-1.30/gnu/offtostr.c": {},
  "tar/tar-1.30/gnu/open.c": {
    "orig_open": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\norig_open (const char *filename, int flags, mode_t mode)\n{\n  return open (filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nopen (const char *filename, int flags, ...)\n{\n  /* 0 = unknown, 1 = yes, -1 = no.  */\n#if GNULIB_defined_O_CLOEXEC\n  int have_cloexec = -1;\n#else\n  static int have_cloexec;\n#endif\n\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n#if GNULIB_defined_O_NONBLOCK\n  /* The only known platform that lacks O_NONBLOCK is mingw, but it\n     also lacks named pipes and Unix sockets, which are the only two\n     file types that require non-blocking handling in open().\n     Therefore, it is safe to ignore O_NONBLOCK here.  It is handy\n     that mingw also lacks openat(), so that is also covered here.  */\n  flags &= ~O_NONBLOCK;\n#endif\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n#endif\n\n  fd = orig_open (filename,\n                  flags & ~(have_cloexec <= 0 ? O_CLOEXEC : 0), mode);\n\n  if (flags & O_CLOEXEC)\n    {\n      if (! have_cloexec)\n        {\n          if (0 <= fd)\n            have_cloexec = 1;\n          else if (errno == EINVAL)\n            {\n              fd = orig_open (filename, flags & ~O_CLOEXEC, mode);\n              have_cloexec = -1;\n            }\n        }\n      if (have_cloexec < 0 && 0 <= fd)\n        set_cloexec_flag (fd, true);\n    }\n\n\n#if REPLACE_FCHDIR\n  /* Implementing fchdir and fdopendir requires the ability to open a\n     directory file descriptor.  If open doesn't support that (as on\n     mingw), we use a dummy file that behaves the same as directories\n     on Linux (ie. always reports EOF on attempts to read()), and\n     override fstat() in fchdir.c to hide the fact that we have a\n     dummy.  */\n  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES\n      && ((flags & O_ACCMODE) == O_RDONLY\n          || (O_SEARCH != O_RDONLY && (flags & O_ACCMODE) == O_SEARCH)))\n    {\n      struct stat statbuf;\n      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))\n        {\n          /* Maximum recursion depth of 1.  */\n          fd = open (\"/dev/null\", flags, mode);\n          if (0 <= fd)\n            fd = _gl_register_fd (fd, filename);\n        }\n      else\n        errno = EACCES;\n    }\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n#endif\n\n#if REPLACE_FCHDIR\n  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)\n    fd = _gl_register_fd (fd, filename);\n#endif\n\n  return fd;\n}",
      "lines": 155,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/openat-die.c": {
    "openat_save_fail": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "_Noreturn void\nopenat_save_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"unable to record current working directory\"));\n#endif\n  /* _Noreturn cannot be applied to error, since it returns\n     when its first argument is 0.  To help compilers understand that this\n     function does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "openat_restore_fail": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "_Noreturn void\nopenat_restore_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"failed to return to initial working directory\"));\n#endif\n\n  /* As above.  */\n  abort ();\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/openat-priv.h": {},
  "tar/tar-1.30/gnu/openat-proc.c": {
    "openat_proc_name": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "char *\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)\n{\n  char *result = buf;\n  int dirlen;\n\n  /* Make sure the caller gets ENOENT when appropriate.  */\n  if (!*file)\n    {\n      buf[0] = '\\0';\n      return buf;\n    }\n\n#ifndef __KLIBC__\n# define PROC_SELF_FD_FORMAT \"/proc/self/fd/%d/\"\n  {\n    enum {\n      PROC_SELF_FD_DIR_SIZE_BOUND\n        = (sizeof PROC_SELF_FD_FORMAT - (sizeof \"%d\" - 1)\n           + INT_STRLEN_BOUND (int))\n    };\n\n    static int proc_status = 0;\n    if (! proc_status)\n      {\n        /* Set PROC_STATUS to a positive value if /proc/self/fd is\n           reliable, and a negative value otherwise.  Solaris 10\n           /proc/self/fd mishandles \"..\", and any file name might expand\n           to \"..\" after symbolic link expansion, so avoid /proc/self/fd\n           if it mishandles \"..\".  Solaris 10 has openat, but this\n           problem is exhibited on code that built on Solaris 8 and\n           running on Solaris 10.  */\n\n        int proc_self_fd = open (\"/proc/self/fd\",\n                                 O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n        if (proc_self_fd < 0)\n          proc_status = -1;\n        else\n          {\n            /* Detect whether /proc/self/fd/%i/../fd exists, where %i is the\n               number of a file descriptor open on /proc/self/fd.  On Linux,\n               that name resolves to /proc/self/fd, which was opened above.\n               However, on Solaris, it may resolve to /proc/self/fd/fd, which\n               cannot exist, since all names in /proc/self/fd are numeric.  */\n            char dotdot_buf[PROC_SELF_FD_DIR_SIZE_BOUND + sizeof \"../fd\" - 1];\n            sprintf (dotdot_buf, PROC_SELF_FD_FORMAT \"../fd\", proc_self_fd);\n            proc_status = access (dotdot_buf, F_OK) ? -1 : 1;\n            close (proc_self_fd);\n          }\n      }\n\n    if (proc_status < 0)\n      return NULL;\n    else\n      {\n        size_t bufsize = PROC_SELF_FD_DIR_SIZE_BOUND + strlen (file);\n        if (OPENAT_BUFFER_SIZE < bufsize)\n          {\n            result = malloc (bufsize);\n            if (! result)\n              return NULL;\n          }\n\n        dirlen = sprintf (result, PROC_SELF_FD_FORMAT, fd);\n      }\n  }\n#else\n  /* OS/2 kLIBC provides a function to retrieve a path from a fd.  */\n  {\n    char dir[_MAX_PATH];\n    size_t bufsize;\n\n    if (__libc_Back_ioFHToPath (fd, dir, sizeof dir))\n      return NULL;\n\n    dirlen = strlen (dir);\n    bufsize = dirlen + 1 + strlen (file) + 1; /* 1 for '/', 1 for null */\n    if (OPENAT_BUFFER_SIZE < bufsize)\n      {\n        result = malloc (bufsize);\n        if (! result)\n          return NULL;\n      }\n\n    strcpy (result, dir);\n    result[dirlen++] = '/';\n  }\n#endif\n\n  strcpy (result + dirlen, file);\n  return result;\n}",
      "lines": 92,
      "depth": 16,
      "decorators": [
        "char",
        "*\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/openat.c": {
    "orig_openat": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static int\norig_openat (int fd, char const *filename, int flags, mode_t mode)\n{\n  return openat (fd, filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_openat": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nrpl_openat (int dfd, char const *filename, int flags, ...)\n{\n  /* 0 = unknown, 1 = yes, -1 = no.  */\n#if GNULIB_defined_O_CLOEXEC\n  int have_cloexec = -1;\n#else\n  static int have_cloexec;\n#endif\n\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n# endif\n\n  fd = orig_openat (dfd, filename,\n                    flags & ~(have_cloexec <= 0 ? O_CLOEXEC : 0), mode);\n\n  if (flags & O_CLOEXEC)\n    {\n      if (! have_cloexec)\n        {\n          if (0 <= fd)\n            have_cloexec = 1;\n          else if (errno == EINVAL)\n            {\n              fd = orig_openat (dfd, filename, flags & ~O_CLOEXEC, mode);\n              have_cloexec = -1;\n            }\n        }\n      if (have_cloexec < 0 && 0 <= fd)\n        set_cloexec_flag (fd, true);\n    }\n\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n# endif\n\n  return fd;\n}",
      "lines": 112,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "openat": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "int\nopenat (int fd, char const *file, int flags, ...)\n{\n  mode_t mode = 0;\n\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n  return openat_permissive (fd, file, flags, mode, NULL);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "openat_permissive": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\nopenat_permissive (int fd, char const *file, int flags, mode_t mode,\n                   int *cwd_errno)\n{\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  int err;\n  bool save_ok;\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return open (file, flags, mode);\n\n  {\n    char buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (buf, fd, file);\n    if (proc_file)\n      {\n        int open_result = open (proc_file, flags, mode);\n        int open_errno = errno;\n        if (proc_file != buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (0 <= open_result || ! EXPECTED_ERRNO (open_errno))\n          {\n            errno = open_errno;\n            return open_result;\n          }\n      }\n  }\n\n  save_ok = (save_cwd (&saved_cwd) == 0);\n  if (! save_ok)\n    {\n      if (! cwd_errno)\n        openat_save_fail (errno);\n      *cwd_errno = errno;\n    }\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return -1;\n    }\n\n  err = fchdir (fd);\n  saved_errno = errno;\n\n  if (! err)\n    {\n      err = open (file, flags, mode);\n      saved_errno = errno;\n      if (save_ok && restore_cwd (&saved_cwd) != 0)\n        {\n          if (! cwd_errno)\n            {\n              /* Don't write a message to just-created fd 2.  */\n              saved_errno = errno;\n              if (err == STDERR_FILENO)\n                close (err);\n              openat_restore_fail (saved_errno);\n            }\n          *cwd_errno = errno;\n        }\n    }\n\n  free_cwd (&saved_cwd);\n  errno = saved_errno;\n  return err;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "openat_needs_fchdir": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "bool\nopenat_needs_fchdir (void)\n{\n  bool needs_fchdir = true;\n  int fd = open (\"/\", O_SEARCH);\n\n  if (0 <= fd)\n    {\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          needs_fchdir = false;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n      close (fd);\n    }\n\n  return needs_fchdir;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "tar/tar-1.30/gnu/openat.h": {
    "chownat": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchownat": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nlchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "chmodat": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "FCHMODAT_INLINE int\nchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchmodat": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "FCHMODAT_INLINE int\nlchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "statat": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "STATAT_INLINE int\nstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    },
    "lstatat": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "STATAT_INLINE int\nlstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/opendir-safer.c": {
    "opendir_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "DIR *\nopendir_safer (char const *name)\n{\n  DIR *dp = opendir (name);\n\n  if (dp)\n    {\n      int fd = dirfd (dp);\n\n      if (0 <= fd && fd <= STDERR_FILENO)\n        {\n          /* If fdopendir is native (as on Linux), then it is safe to\n             assume dirfd(fdopendir(n))==n.  If we are using the\n             gnulib module fdopendir, then this guarantee is not met,\n             but fdopendir recursively calls opendir_safer up to 3\n             times to at least get a safe fd.  If fdopendir is not\n             present but dirfd is accurate (as on cygwin 1.5.x), then\n             we recurse up to 3 times ourselves.  Finally, if dirfd\n             always fails (as on mingw), then we are already safe.  */\n          DIR *newdp;\n          int e;\n#if HAVE_FDOPENDIR || GNULIB_FDOPENDIR\n          int f = fcntl (fd, F_DUPFD_CLOEXEC, STDERR_FILENO + 1);\n          if (f < 0)\n            {\n              e = errno;\n              newdp = NULL;\n            }\n          else\n            {\n              newdp = fdopendir (f);\n              e = errno;\n              if (! newdp)\n                close (f);\n            }\n#else /* !FDOPENDIR */\n          newdp = opendir_safer (name);\n          e = errno;\n#endif\n          closedir (dp);\n          errno = e;\n          dp = newdp;\n        }\n    }\n\n  return dp;\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "DIR",
        "*\nopendir_safer (char const *name)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/opendir.c": {
    "opendir": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "DIR *\nopendir (const char *dir_name)\n{\n#if HAVE_OPENDIR\n# undef opendir\n  DIR *dirp;\n\n  dirp = opendir (dir_name);\n  if (dirp == NULL)\n    return NULL;\n\n# ifdef __KLIBC__\n  {\n    int fd = open (dir_name, O_RDONLY);\n    if (fd == -1 || _gl_register_dirp_fd (fd, dirp))\n      {\n        int saved_errno = errno;\n\n        close (fd);\n        closedir (dirp);\n\n        errno = saved_errno;\n\n        return NULL;\n      }\n  }\n# endif\n#else\n\n  char dir_name_mask[MAX_PATH + 1 + 1 + 1];\n  int status;\n  HANDLE current;\n  WIN32_FIND_DATA entry;\n  struct gl_directory *dirp;\n\n  if (dir_name[0] == '\\0')\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n\n  /* Make the dir_name absolute, so that we continue reading the same\n     directory if the current directory changed between this opendir()\n     call and a subsequent rewinddir() call.  */\n  if (!GetFullPathName (dir_name, MAX_PATH, dir_name_mask, NULL))\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n  /* Append the mask.\n     \"*\" and \"*.*\" appear to be equivalent.  */\n  {\n    char *p;\n\n    p = dir_name_mask + strlen (dir_name_mask);\n    if (p > dir_name_mask && !ISSLASH (p[-1]))\n      *p++ = '\\\\';\n    *p++ = '*';\n    *p = '\\0';\n  }\n\n  /* Start searching the directory.  */\n  status = -1;\n  current = FindFirstFile (dir_name_mask, &entry);\n  if (current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          status = -2;\n          break;\n        case ERROR_PATH_NOT_FOUND:\n          errno = ENOENT;\n          return NULL;\n        case ERROR_DIRECTORY:\n          errno = ENOTDIR;\n          return NULL;\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          return NULL;\n        default:\n          errno = EIO;\n          return NULL;\n        }\n    }\n\n  /* Allocate the result.  */\n  dirp =\n    (struct gl_directory *)\n    malloc (offsetof (struct gl_directory, dir_name_mask[0])\n            + strlen (dir_name_mask) + 1);\n  if (dirp == NULL)\n    {\n      if (current != INVALID_HANDLE_VALUE)\n        FindClose (current);\n      errno = ENOMEM;\n      return NULL;\n    }\n  dirp->status = status;\n  dirp->current = current;\n  if (status == -1)\n    memcpy (&dirp->entry, &entry, sizeof (WIN32_FIND_DATA));\n  strcpy (dirp->dir_name_mask, dir_name_mask);\n\n#endif\n\n#if REPLACE_FCHDIR\n  {\n    int fd = dirfd (dirp);\n    if (0 <= fd && _gl_register_fd (fd, dir_name) != fd)\n      {\n        int saved_errno = errno;\n        closedir (dirp);\n        errno = saved_errno;\n        return NULL;\n      }\n  }\n#endif\n\n  return dirp;\n}",
      "lines": 122,
      "depth": 15,
      "decorators": [
        "DIR",
        "*\nopendir (const char *dir_name)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/parse-datetime.c": {
    "time_overflow": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static bool\ntime_overflow (intmax_t n)\n{\n  return ! ((TYPE_SIGNED (time_t) ? TYPE_MINIMUM (time_t) <= n : 0 <= n)\n            && n <= TYPE_MAXIMUM (time_t));\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "to_uchar": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        199,
        54
      ],
      "content": "static unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "_GL_ATTRIBUTE_FORMAT": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static void _GL_ATTRIBUTE_FORMAT ((__printf__, 1, 2))\ndbg_printf (char const *msg, ...)\n{\n  va_list args;\n  /* TODO: use gnulib's 'program_name' instead?  */\n  fputs (\"date: \", stderr);\n\n  va_start (args, msg);\n  vfprintf (stderr, msg, args);\n  va_end (args);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "digits_to_date_time": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "static void\ndigits_to_date_time (parser_control *pc, textint text_int)\n{\n  if (pc->dates_seen && ! pc->year.digits\n      && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n    {\n      pc->year_seen = true;\n      pc->year = text_int;\n    }\n  else\n    {\n      if (4 < text_int.digits)\n        {\n          pc->dates_seen++;\n          pc->day = text_int.value % 100;\n          pc->month = (text_int.value / 100) % 100;\n          pc->year.value = text_int.value / 10000;\n          pc->year.digits = text_int.digits - 4;\n        }\n      else\n        {\n          pc->times_seen++;\n          if (text_int.digits <= 2)\n            {\n              pc->hour = text_int.value;\n              pc->minutes = 0;\n            }\n          else\n            {\n              pc->hour = text_int.value / 100;\n              pc->minutes = text_int.value % 100;\n            }\n          pc->seconds.tv_sec = 0;\n          pc->seconds.tv_nsec = 0;\n          pc->meridian = MER24;\n        }\n    }\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_relative_time": {
      "start_point": [
        368,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "static bool\napply_relative_time (parser_control *pc, relative_time rel, int factor)\n{\n  if (factor < 0\n      ? (INT_SUBTRACT_WRAPV (pc->rel.ns, rel.ns, &pc->rel.ns)\n         | INT_SUBTRACT_WRAPV (pc->rel.seconds, rel.seconds, &pc->rel.seconds)\n         | INT_SUBTRACT_WRAPV (pc->rel.minutes, rel.minutes, &pc->rel.minutes)\n         | INT_SUBTRACT_WRAPV (pc->rel.hour, rel.hour, &pc->rel.hour)\n         | INT_SUBTRACT_WRAPV (pc->rel.day, rel.day, &pc->rel.day)\n         | INT_SUBTRACT_WRAPV (pc->rel.month, rel.month, &pc->rel.month)\n         | INT_SUBTRACT_WRAPV (pc->rel.year, rel.year, &pc->rel.year))\n      : (INT_ADD_WRAPV (pc->rel.ns, rel.ns, &pc->rel.ns)\n         | INT_ADD_WRAPV (pc->rel.seconds, rel.seconds, &pc->rel.seconds)\n         | INT_ADD_WRAPV (pc->rel.minutes, rel.minutes, &pc->rel.minutes)\n         | INT_ADD_WRAPV (pc->rel.hour, rel.hour, &pc->rel.hour)\n         | INT_ADD_WRAPV (pc->rel.day, rel.day, &pc->rel.day)\n         | INT_ADD_WRAPV (pc->rel.month, rel.month, &pc->rel.month)\n         | INT_ADD_WRAPV (pc->rel.year, rel.year, &pc->rel.year)))\n    return false;\n  pc->rels_seen = true;\n  return true;\n}",
      "lines": 22,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "set_hhmmss": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "static void\nset_hhmmss (parser_control *pc, intmax_t hour, intmax_t minutes,\n            time_t sec, int nsec)\n{\n  pc->hour = hour;\n  pc->minutes = minutes;\n  pc->seconds.tv_sec = sec;\n  pc->seconds.tv_nsec = nsec;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "str_days": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "static const char *\nstr_days (parser_control *pc, char *buffer, int n)\n{\n  /* TODO: use relative_time_table for reverse lookup.  */\n  static char const ordinal_values[][11] = {\n     \"last\",\n     \"this\",\n     \"next/first\",\n     \"(SECOND)\", /* SECOND is commented out in relative_time_table.  */\n     \"third\",\n     \"fourth\",\n     \"fifth\",\n     \"sixth\",\n     \"seventh\",\n     \"eight\",\n     \"ninth\",\n     \"tenth\",\n     \"eleventh\",\n     \"twelfth\"\n  };\n\n  static char const days_values[][4] = {\n     \"Sun\",\n     \"Mon\",\n     \"Tue\",\n     \"Wed\",\n     \"Thu\",\n     \"Fri\",\n     \"Sat\"\n  };\n\n  int len;\n\n  /* Don't add an ordinal prefix if the user didn't specify it\n     (e.g., \"this wed\" vs \"wed\").  */\n  if (pc->debug_ordinal_day_seen)\n    {\n      /* Use word description if possible (e.g., -1 = last, 3 = third).  */\n      len = (-1 <= pc->day_ordinal && pc->day_ordinal <= 12\n             ? snprintf (buffer, n, \"%s\", ordinal_values[pc->day_ordinal + 1])\n             : snprintf (buffer, n, \"%\"PRIdMAX, pc->day_ordinal));\n    }\n  else\n    {\n      buffer[0] = '\\0';\n      len = 0;\n    }\n\n  /* Add the day name */\n  if (0 <= pc->day_number && pc->day_number <= 6 && 0 <= len && len < n)\n    snprintf (buffer + len, n - len, &\" %s\"[len == 0],\n              days_values[pc->day_number]);\n  else\n    {\n      /* invalid day_number value - should never happen */\n    }\n  return buffer;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nstr_days (parser_control *pc, char *buffer, int n)",
        "*"
      ]
    },
    "time_zone_str": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "static char const *\ntime_zone_str (int time_zone, char time_zone_buf[TIME_ZONE_BUFSIZE])\n{\n  char *p = time_zone_buf;\n  char sign = time_zone < 0 ? '-' : '+';\n  int hour = abs (time_zone / (60 * 60));\n  p += sprintf (time_zone_buf, \"%c%02d\", sign, hour);\n  int offset_from_hour = abs (time_zone % (60 * 60));\n  if (offset_from_hour != 0)\n    {\n      int mm = offset_from_hour / 60;\n      int ss = offset_from_hour % 60;\n      *p++ = ':';\n      *p++ = '0' + mm / 10;\n      *p++ = '0' + mm % 10;\n      if (ss)\n        {\n          *p++ = ':';\n          *p++ = '0' + ss / 10;\n          *p++ = '0' + ss % 10;\n        }\n      *p = '\\0';\n    }\n  return time_zone_buf;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ntime_zone_str (int time_zone, char time_zone_buf[TIME_ZONE_BUFSIZE])",
        "*"
      ]
    },
    "debug_print_current_time": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        583,
        1
      ],
      "content": "static void\ndebug_print_current_time (char const *item, parser_control *pc)\n{\n  bool space = false;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  /* no newline, more items printed below */\n  dbg_printf (_(\"parsed %s part: \"), item);\n\n  if (pc->dates_seen && !pc->debug_dates_seen)\n    {\n      /*TODO: use pc->year.negative?  */\n      fprintf (stderr, \"(Y-M-D) %04\"PRIdMAX\"-%02\"PRIdMAX\"-%02\"PRIdMAX,\n              pc->year.value, pc->month, pc->day);\n      pc->debug_dates_seen = true;\n      space = true;\n    }\n\n  if (pc->year_seen != pc->debug_year_seen)\n    {\n      if (space)\n        fputc (' ', stderr);\n      fprintf (stderr, _(\"year: %04\"PRIdMAX), pc->year.value);\n\n      pc->debug_year_seen = pc->year_seen;\n      space = true;\n    }\n\n  if (pc->times_seen && !pc->debug_times_seen)\n    {\n      intmax_t sec = pc->seconds.tv_sec;\n      fprintf (stderr, &\" %02\"PRIdMAX\":%02\"PRIdMAX\":%02\"PRIdMAX[!space],\n               pc->hour, pc->minutes, sec);\n      if (pc->seconds.tv_nsec != 0)\n        {\n          int nsec = pc->seconds.tv_nsec;\n          fprintf (stderr, \".%09d\", nsec);\n        }\n      if (pc->meridian == MERpm)\n        fputs (\"pm\", stderr);\n\n      pc->debug_times_seen = true;\n      space = true;\n    }\n\n  if (pc->days_seen && !pc->debug_days_seen)\n    {\n      if (space)\n        fputc (' ', stderr);\n      char tmp[DBGBUFSIZE];\n      fprintf (stderr, _(\"%s (day ordinal=%\"PRIdMAX\" number=%d)\"),\n               str_days (pc, tmp, sizeof tmp),\n               pc->day_ordinal, pc->day_number);\n      pc->debug_days_seen = true;\n      space = true;\n    }\n\n  /* local zone strings only change the DST settings,\n     not the timezone value.  If seen, inform about the DST.  */\n  if (pc->local_zones_seen && !pc->debug_local_zones_seen)\n    {\n      fprintf (stderr, &\" isdst=%d%s\"[!space],\n\t       pc->local_isdst, pc->dsts_seen ? \" DST\" : \"\");\n      pc->debug_local_zones_seen = true;\n      space = true;\n    }\n\n  if (pc->zones_seen && !pc->debug_zones_seen)\n    {\n      char time_zone_buf[TIME_ZONE_BUFSIZE];\n      fprintf (stderr, &\" UTC%s\"[!space],\n               time_zone_str (pc->time_zone, time_zone_buf));\n      pc->debug_zones_seen = true;\n      space = true;\n    }\n\n  if (pc->timespec_seen)\n    {\n      intmax_t sec = pc->seconds.tv_sec;\n      if (space)\n        fputc (' ', stderr);\n      fprintf (stderr, _(\"number of seconds: %\"PRIdMAX), sec);\n    }\n\n  fputc ('\\n', stderr);\n}",
      "lines": 88,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_rel_part": {
      "start_point": [
        587,
        0
      ],
      "end_point": [
        594,
        1
      ],
      "content": "static bool\nprint_rel_part (bool space, intmax_t val, char const *name)\n{\n  if (val == 0)\n    return space;\n  fprintf (stderr, &\" %+\"PRIdMAX\" %s\"[!space], val, name);\n  return true;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "debug_print_relative_time": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "static void\ndebug_print_relative_time (char const *item, parser_control const *pc)\n{\n  bool space = false;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  /* no newline, more items printed below */\n  dbg_printf (_(\"parsed %s part: \"), item);\n\n  if (pc->rel.year == 0 && pc->rel.month == 0 && pc->rel.day == 0\n      && pc->rel.hour == 0 && pc->rel.minutes == 0 && pc->rel.seconds == 0\n      && pc->rel.ns == 0)\n    {\n      /* Special case: relative time of this/today/now */\n      fputs (_(\"today/this/now\\n\"), stderr);\n      return;\n    }\n\n  space = print_rel_part (space, pc->rel.year, \"year(s)\");\n  space = print_rel_part (space, pc->rel.month, \"month(s)\");\n  space = print_rel_part (space, pc->rel.day, \"day(s)\");\n  space = print_rel_part (space, pc->rel.hour, \"hour(s)\");\n  space = print_rel_part (space, pc->rel.minutes, \"minutes\");\n  space = print_rel_part (space, pc->rel.seconds, \"seconds\");\n  print_rel_part (space, pc->rel.ns, \"nanoseconds\");\n\n  fputc ('\\n', stderr);\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yytnamerr": {
      "start_point": [
        1568,
        0
      ],
      "end_point": [
        1605,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1616,
        0
      ],
      "end_point": [
        1745,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULL, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULL;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULL, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 130,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "time_zone_hhmm": {
      "start_point": [
        3105,
        0
      ],
      "end_point": [
        3130,
        1
      ],
      "content": "static bool\ntime_zone_hhmm (parser_control *pc, textint s, intmax_t mm)\n{\n  intmax_t n_minutes;\n  bool overflow = false;\n\n  /* If the length of S is 1 or 2 and no minutes are specified,\n     interpret it as a number of hours.  */\n  if (s.digits <= 2 && mm < 0)\n    s.value *= 100;\n\n  if (mm < 0)\n    n_minutes = (s.value / 100) * 60 + s.value % 100;\n  else\n    {\n      overflow |= INT_MULTIPLY_WRAPV (s.value, 60, &n_minutes);\n      overflow |= (s.negative\n                   ? INT_SUBTRACT_WRAPV (n_minutes, mm, &n_minutes)\n                   : INT_ADD_WRAPV (n_minutes, mm, &n_minutes));\n    }\n\n  if (overflow || ! (-24 * 60 <= n_minutes && n_minutes <= 24 * 60))\n    return false;\n  pc->time_zone = n_minutes * 60;\n  return true;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "to_hour": {
      "start_point": [
        3132,
        0
      ],
      "end_point": [
        3145,
        1
      ],
      "content": "static int\nto_hour (intmax_t hours, int meridian)\n{\n  switch (meridian)\n    {\n    default: /* Pacify GCC.  */\n    case MER24:\n      return 0 <= hours && hours < 24 ? hours : -1;\n    case MERam:\n      return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n    case MERpm:\n      return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tm_year_str": {
      "start_point": [
        3153,
        0
      ],
      "end_point": [
        3161,
        1
      ],
      "content": "static char const *\ntm_year_str (int tm_year, char buf[TM_YEAR_BUFSIZE])\n{\n  verify (TM_YEAR_BASE % 100 == 0);\n  sprintf (buf, &\"-%02d%02d\"[-TM_YEAR_BASE <= tm_year],\n           abs (tm_year / 100 + TM_YEAR_BASE / 100),\n           abs (tm_year % 100));\n  return buf;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ntm_year_str (int tm_year, char buf[TM_YEAR_BUFSIZE])",
        "*"
      ]
    },
    "to_tm_year": {
      "start_point": [
        3166,
        0
      ],
      "end_point": [
        3192,
        1
      ],
      "content": "static bool\nto_tm_year (textint textyear, bool debug, int *tm_year)\n{\n  intmax_t year = textyear.value;\n\n  /* XPG4 suggests that years 00-68 map to 2000-2068, and\n     years 69-99 map to 1969-1999.  */\n  if (0 <= year && textyear.digits == 2)\n    {\n      year += year < 69 ? 2000 : 1900;\n      if (debug)\n        dbg_printf (_(\"warning: adjusting year value %\"PRIdMAX\n                      \" to %\"PRIdMAX\"\\n\"),\n                    textyear.value, year);\n    }\n\n  if (year < 0\n      ? INT_SUBTRACT_WRAPV (-TM_YEAR_BASE, year, tm_year)\n      : INT_SUBTRACT_WRAPV (year, TM_YEAR_BASE, tm_year))\n    {\n      if (debug)\n        dbg_printf (_(\"error: out-of-range year %\"PRIdMAX\"\\n\"), year);\n      return false;\n    }\n\n  return true;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "lookup_zone": {
      "start_point": [
        3194,
        0
      ],
      "end_point": [
        3214,
        1
      ],
      "content": "static table const * _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)\n{\n  table const *tp;\n\n  for (tp = universal_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  /* Try local zone abbreviations before those in time_zone_table, as\n     the local ones are more likely to be right.  */\n  for (tp = pc->local_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  for (tp = time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "tm_diff": {
      "start_point": [
        3221,
        0
      ],
      "end_point": [
        3240,
        1
      ],
      "content": "static int\ntm_diff (const struct tm *a, const struct tm *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations,\n     but it's OK to assume that A and B are close to each other.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  int years = a->tm_year - b->tm_year;\n  int days = (365 * years + intervening_leap_days\n              + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lookup_word": {
      "start_point": [
        3243,
        0
      ],
      "end_point": [
        3309,
        1
      ],
      "content": "static table const *\nlookup_word (parser_control const *pc, char *word)\n{\n  char *p;\n  char *q;\n  ptrdiff_t wordlen;\n  table const *tp;\n  bool period_found;\n  bool abbrev;\n\n  /* Make it uppercase.  */\n  for (p = word; *p; p++)\n    *p = c_toupper (to_uchar (*p));\n\n  for (tp = meridian_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* See if we have an abbreviation for a month.  */\n  wordlen = strlen (word);\n  abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n\n  for (tp = month_and_day_table; tp->name; tp++)\n    if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n      return tp;\n\n  if ((tp = lookup_zone (pc, word)))\n    return tp;\n\n  if (strcmp (word, dst_table[0].name) == 0)\n    return dst_table;\n\n  for (tp = time_units_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Strip off any plural and try the units table again.  */\n  if (word[wordlen - 1] == 'S')\n    {\n      word[wordlen - 1] = '\\0';\n      for (tp = time_units_table; tp->name; tp++)\n        if (strcmp (word, tp->name) == 0)\n          return tp;\n      word[wordlen - 1] = 'S';  /* For \"this\" in relative_time_table.  */\n    }\n\n  for (tp = relative_time_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Military time zones.  */\n  if (wordlen == 1)\n    for (tp = military_table; tp->name; tp++)\n      if (word[0] == tp->name[0])\n        return tp;\n\n  /* Drop out any periods and try the time zone table again.  */\n  for (period_found = false, p = q = word; (*p = *q); q++)\n    if (*q == '.')\n      period_found = true;\n    else\n      p++;\n  if (period_found && (tp = lookup_zone (pc, word)))\n    return tp;\n\n  return NULL;\n}",
      "lines": 67,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "*\nlookup_word (parser_control const *pc, char *word)",
        "*"
      ]
    },
    "yylex": {
      "start_point": [
        3311,
        0
      ],
      "end_point": [
        3448,
        1
      ],
      "content": "static int\nyylex (union YYSTYPE *lvalp, parser_control *pc)\n{\n  unsigned char c;\n\n  for (;;)\n    {\n      while (c = *pc->input, c_isspace (c))\n        pc->input++;\n\n      if (c_isdigit (c) || c == '-' || c == '+')\n        {\n          char const *p;\n          int sign;\n          intmax_t value = 0;\n          if (c == '-' || c == '+')\n            {\n              sign = c == '-' ? -1 : 1;\n              while (c = *++pc->input, c_isspace (c))\n                continue;\n              if (! c_isdigit (c))\n                /* skip the '-' sign */\n                continue;\n            }\n          else\n            sign = 0;\n          p = pc->input;\n\n          do\n            {\n              if (INT_MULTIPLY_WRAPV (value, 10, &value))\n                return '?';\n              if (INT_ADD_WRAPV (value, sign < 0 ? '0' - c : c - '0', &value))\n                return '?';\n              c = *++p;\n            }\n          while (c_isdigit (c));\n\n          if ((c == '.' || c == ',') && c_isdigit (p[1]))\n            {\n              time_t s;\n              int ns;\n              int digits;\n\n              if (time_overflow (value))\n                return '?';\n              s = value;\n\n              /* Accumulate fraction, to ns precision.  */\n              p++;\n              ns = *p++ - '0';\n              for (digits = 2; digits <= LOG10_BILLION; digits++)\n                {\n                  ns *= 10;\n                  if (c_isdigit (*p))\n                    ns += *p++ - '0';\n                }\n\n              /* Skip excess digits, truncating toward -Infinity.  */\n              if (sign < 0)\n                for (; c_isdigit (*p); p++)\n                  if (*p != '0')\n                    {\n                      ns++;\n                      break;\n                    }\n              while (c_isdigit (*p))\n                p++;\n\n              /* Adjust to the timespec convention, which is that\n                 tv_nsec is always a positive offset even if tv_sec is\n                 negative.  */\n              if (sign < 0 && ns)\n                {\n                  if (s == TYPE_MINIMUM (time_t))\n                    return '?';\n                  s--;\n                  ns = BILLION - ns;\n                }\n\n              lvalp->timespec.tv_sec = s;\n              lvalp->timespec.tv_nsec = ns;\n              pc->input = p;\n              return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n            }\n          else\n            {\n              lvalp->textintval.negative = sign < 0;\n              lvalp->textintval.value = value;\n              lvalp->textintval.digits = p - pc->input;\n              pc->input = p;\n              return sign ? tSNUMBER : tUNUMBER;\n            }\n        }\n\n      if (c_isalpha (c))\n        {\n          char buff[20];\n          char *p = buff;\n          table const *tp;\n\n          do\n            {\n              if (p < buff + sizeof buff - 1)\n                *p++ = c;\n              c = *++pc->input;\n            }\n          while (c_isalpha (c) || c == '.');\n\n          *p = '\\0';\n          tp = lookup_word (pc, buff);\n          if (! tp)\n            {\n              if (pc->parse_datetime_debug)\n                dbg_printf (_(\"error: unknown word '%s'\\n\"), buff);\n              return '?';\n            }\n          lvalp->intval = tp->value;\n          return tp->type;\n        }\n\n      if (c != '(')\n        return to_uchar (*pc->input++);\n\n      ptrdiff_t count = 0;\n      do\n        {\n          c = *pc->input++;\n          if (c == '\\0')\n            return c;\n          if (c == '(')\n            count++;\n          else if (c == ')')\n            count--;\n        }\n      while (count != 0);\n    }\n}",
      "lines": 138,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        3451,
        0
      ],
      "end_point": [
        3456,
        1
      ],
      "content": "static int\nyyerror (parser_control const *pc _GL_UNUSED,\n         char const *s _GL_UNUSED)\n{\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mktime_ok": {
      "start_point": [
        3463,
        0
      ],
      "end_point": [
        3483,
        1
      ],
      "content": "static bool\nmktime_ok (timezone_t tz, struct tm const *tm0, struct tm const *tm1, time_t t)\n{\n  struct tm ltm;\n  if (t == (time_t) -1)\n    {\n      /* Guard against falsely reporting an error when parsing a\n         timestamp that happens to equal (time_t) -1, on a host that\n         supports such a timestamp.  */\n      tm1 = localtime_rz (tz, &t, &ltm);\n      if (!tm1)\n        return false;\n    }\n\n  return ! ((tm0->tm_sec ^ tm1->tm_sec)\n            | (tm0->tm_min ^ tm1->tm_min)\n            | (tm0->tm_hour ^ tm1->tm_hour)\n            | (tm0->tm_mday ^ tm1->tm_mday)\n            | (tm0->tm_mon ^ tm1->tm_mon)\n            | (tm0->tm_year ^ tm1->tm_year));\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "debug_strfdatetime": {
      "start_point": [
        3487,
        0
      ],
      "end_point": [
        3530,
        1
      ],
      "content": "static char const *\ndebug_strfdatetime (struct tm const *tm, parser_control const *pc,\n                    char *buf, int n)\n{\n  /* TODO:\n     1. find an optimal way to print date string in a clear and unambiguous\n        format.  Currently, always add '(Y-M-D)' prefix.\n        Consider '2016y01m10d'  or 'year(2016) month(01) day(10)'.\n\n        If the user needs debug printing, it means he/she already having\n        issues with the parsing - better to avoid formats that could\n        be mis-interpreted (e.g., just YYYY-MM-DD).\n\n     2. Can strftime be used instead?\n        depends if it is portable and can print invalid dates on all systems.\n\n     3. Print timezone information ?\n\n     4. Print DST information ?\n\n     5. Print nanosecond information ?\n\n     NOTE:\n     Printed date/time values might not be valid, e.g., '2016-02-31'\n     or '2016-19-2016' .  These are the values as parsed from the user\n     string, before validation.\n  */\n  int m = nstrftime (buf, n, \"(Y-M-D) %Y-%m-%d %H:%M:%S\", tm, 0, 0);\n\n  /* If parser_control information was provided (for timezone),\n     and there's enough space in the buffer, add timezone info.  */\n  if (pc && m < n && pc->zones_seen)\n    {\n      int tz = pc->time_zone;\n\n      /* Account for DST if tLOCAL_ZONE was seen.  */\n      if (pc->local_zones_seen && !pc->zones_seen && 0 < pc->local_isdst)\n        tz += 60 * 60;\n\n      char time_zone_buf[TIME_ZONE_BUFSIZE];\n      snprintf (&buf[m], n - m, \" TZ=%s\", time_zone_str (tz, time_zone_buf));\n    }\n  return buf;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strfdatetime (struct tm const *tm, parser_control const *pc,\n                    char *buf, int n)",
        "*"
      ]
    },
    "debug_strfdate": {
      "start_point": [
        3532,
        0
      ],
      "end_point": [
        3540,
        1
      ],
      "content": "static char const *\ndebug_strfdate (struct tm const *tm, char *buf, int n)\n{\n  char tm_year_buf[TM_YEAR_BUFSIZE];\n  snprintf (buf, n, \"(Y-M-D) %s-%02d-%02d\",\n            tm_year_str (tm->tm_year, tm_year_buf),\n            tm->tm_mon + 1, tm->tm_mday);\n  return buf;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strfdate (struct tm const *tm, char *buf, int n)",
        "*"
      ]
    },
    "debug_strftime": {
      "start_point": [
        3542,
        0
      ],
      "end_point": [
        3547,
        1
      ],
      "content": "static char const *\ndebug_strftime (struct tm const *tm, char *buf, int n)\n{\n  snprintf (buf, n, \"%02d:%02d:%02d\", tm->tm_hour, tm->tm_min, tm->tm_sec);\n  return buf;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strftime (struct tm const *tm, char *buf, int n)",
        "*"
      ]
    },
    "debug_mktime_not_ok": {
      "start_point": [
        3561,
        0
      ],
      "end_point": [
        3615,
        1
      ],
      "content": "static void\ndebug_mktime_not_ok (struct tm const *tm0, struct tm const *tm1,\n                     parser_control const *pc, bool time_zone_seen)\n{\n  /* TODO: handle t == -1 (as in 'mktime_ok').  */\n  char tmp[DBGBUFSIZE];\n  int i;\n  const bool eq_sec   = (tm0->tm_sec  == tm1->tm_sec);\n  const bool eq_min   = (tm0->tm_min  == tm1->tm_min);\n  const bool eq_hour  = (tm0->tm_hour == tm1->tm_hour);\n  const bool eq_mday  = (tm0->tm_mday == tm1->tm_mday);\n  const bool eq_month = (tm0->tm_mon  == tm1->tm_mon);\n  const bool eq_year  = (tm0->tm_year == tm1->tm_year);\n\n  const bool dst_shift = eq_sec && eq_min && !eq_hour\n                         && eq_mday && eq_month && eq_year;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  dbg_printf (_(\"error: invalid date/time value:\\n\"));\n  dbg_printf (_(\"    user provided time: '%s'\\n\"),\n              debug_strfdatetime (tm0, pc, tmp, sizeof tmp));\n  dbg_printf (_(\"       normalized time: '%s'\\n\"),\n              debug_strfdatetime (tm1, pc, tmp, sizeof tmp));\n  /* The format must be aligned with debug_strfdatetime and the two\n     DEBUG statements above.  This string is not translated.  */\n  i = snprintf (tmp, sizeof tmp,\n                \"                                 %4s %2s %2s %2s %2s %2s\",\n                eq_year ? \"\" : \"----\",\n                eq_month ? \"\" : \"--\",\n                eq_mday ? \"\" : \"--\",\n                eq_hour ? \"\" : \"--\",\n                eq_min ? \"\" : \"--\",\n                eq_sec ? \"\" : \"--\");\n  /* Trim trailing whitespace.  */\n  if (0 <= i)\n    {\n      if (sizeof tmp - 1 < i)\n        i = sizeof tmp - 1;\n      while (0 < i && tmp[i - 1] == ' ')\n        --i;\n      tmp[i] = '\\0';\n    }\n  dbg_printf (\"%s\\n\", tmp);\n\n  dbg_printf (_(\"     possible reasons:\\n\"));\n  if (dst_shift)\n    dbg_printf (_(\"       non-existing due to daylight-saving time;\\n\"));\n  if (!eq_mday && !eq_month)\n    dbg_printf (_(\"       invalid day/month combination;\\n\"));\n  dbg_printf (_(\"       numeric values overflow;\\n\"));\n  dbg_printf (\"       %s\\n\", (time_zone_seen ? _(\"incorrect timezone\")\n                              : _(\"missing timezone\")));\n}",
      "lines": 55,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_datetime": {
      "start_point": [
        3618,
        0
      ],
      "end_point": [
        3629,
        1
      ],
      "content": "bool\nparse_datetime (struct timespec *result, char const *p,\n                struct timespec const *now)\n{\n  char const *tzstring = getenv (\"TZ\");\n  timezone_t tz = tzalloc (tzstring);\n  if (!tz)\n    return false;\n  bool ok = parse_datetime2 (result, p, now, 0, tz, tzstring);\n  tzfree (tz);\n  return ok;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "parse_datetime2": {
      "start_point": [
        3636,
        0
      ],
      "end_point": [
        4291,
        1
      ],
      "content": "bool\nparse_datetime2 (struct timespec *result, char const *p,\n                 struct timespec const *now, unsigned int flags,\n                 timezone_t tzdefault, char const *tzstring)\n{\n  struct tm tm;\n  struct tm tm0;\n  char time_zone_buf[TIME_ZONE_BUFSIZE];\n  char dbg_tm[DBGBUFSIZE];\n  bool ok = false;\n  char const *input_sentinel = p + strlen (p);\n  char *tz1alloc = NULL;\n\n  /* A reasonable upper bound for the size of ordinary TZ strings.\n     Use heap allocation if TZ's length exceeds this.  */\n  enum { TZBUFSIZE = 100 };\n  char tz1buf[TZBUFSIZE];\n\n  struct timespec gettime_buffer;\n  if (! now)\n    {\n      gettime (&gettime_buffer);\n      now = &gettime_buffer;\n    }\n\n  time_t Start = now->tv_sec;\n  int Start_ns = now->tv_nsec;\n\n  unsigned char c;\n  while (c = *p, c_isspace (c))\n    p++;\n\n  timezone_t tz = tzdefault;\n\n  if (strncmp (p, \"TZ=\\\"\", 4) == 0)\n    {\n      char const *tzbase = p + 4;\n      ptrdiff_t tzsize = 1;\n      char const *s;\n\n      for (s = tzbase; *s; s++, tzsize++)\n        if (*s == '\\\\')\n          {\n            s++;\n            if (! (*s == '\\\\' || *s == '\"'))\n              break;\n          }\n        else if (*s == '\"')\n          {\n            timezone_t tz1;\n            char *tz1string = tz1buf;\n            char *z;\n            if (TZBUFSIZE < tzsize)\n              {\n                tz1alloc = malloc (tzsize);\n                if (!tz1alloc)\n                  goto fail;\n                tz1string = tz1alloc;\n              }\n            z = tz1string;\n            for (s = tzbase; *s != '\"'; s++)\n              *z++ = *(s += *s == '\\\\');\n            *z = '\\0';\n            tz1 = tzalloc (tz1string);\n            if (!tz1)\n              goto fail;\n            tz = tz1;\n            tzstring = tz1string;\n\n            p = s + 1;\n            while (c = *p, c_isspace (c))\n              p++;\n\n            break;\n          }\n    }\n\n  struct tm tmp;\n  if (! localtime_rz (tz, &now->tv_sec, &tmp))\n    goto fail;\n\n  /* As documented, be careful to treat the empty string just like\n     a date string of \"0\".  Without this, an empty string would be\n     declared invalid when parsed during a DST transition.  */\n  if (*p == '\\0')\n    p = \"0\";\n\n  parser_control pc;\n  pc.input = p;\n  pc.parse_datetime_debug = (flags & PARSE_DATETIME_DEBUG) != 0;\n  if (INT_ADD_WRAPV (tmp.tm_year, TM_YEAR_BASE, &pc.year.value))\n    {\n      if (pc.parse_datetime_debug)\n        dbg_printf (_(\"error: initial year out of range\\n\"));\n      goto fail;\n    }\n  pc.year.digits = 0;\n  pc.month = tmp.tm_mon + 1;\n  pc.day = tmp.tm_mday;\n  pc.hour = tmp.tm_hour;\n  pc.minutes = tmp.tm_min;\n  pc.seconds.tv_sec = tmp.tm_sec;\n  pc.seconds.tv_nsec = Start_ns;\n  tm.tm_isdst = tmp.tm_isdst;\n\n  pc.meridian = MER24;\n  pc.rel = RELATIVE_TIME_0;\n  pc.timespec_seen = false;\n  pc.rels_seen = false;\n  pc.dates_seen = 0;\n  pc.days_seen = 0;\n  pc.times_seen = 0;\n  pc.local_zones_seen = 0;\n  pc.dsts_seen = 0;\n  pc.zones_seen = 0;\n  pc.year_seen = false;\n  pc.debug_dates_seen = false;\n  pc.debug_days_seen = false;\n  pc.debug_times_seen = false;\n  pc.debug_local_zones_seen = false;\n  pc.debug_zones_seen = false;\n  pc.debug_year_seen = false;\n  pc.debug_ordinal_day_seen = false;\n\n#if HAVE_STRUCT_TM_TM_ZONE\n  pc.local_time_zone_table[0].name = tmp.tm_zone;\n  pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n  pc.local_time_zone_table[0].value = tmp.tm_isdst;\n  pc.local_time_zone_table[1].name = NULL;\n\n  /* Probe the names used in the next three calendar quarters, looking\n     for a tm_isdst different from the one we already have.  */\n  {\n    int quarter;\n    for (quarter = 1; quarter <= 3; quarter++)\n      {\n        intmax_t iprobe;\n        if (INT_ADD_WRAPV (Start, quarter * (90 * 24 * 60 * 60), &iprobe)\n            || time_overflow (iprobe))\n          break;\n        time_t probe = iprobe;\n        struct tm probe_tm;\n        if (localtime_rz (tz, &probe, &probe_tm) && probe_tm.tm_zone\n            && probe_tm.tm_isdst != pc.local_time_zone_table[0].value)\n          {\n              {\n                pc.local_time_zone_table[1].name = probe_tm.tm_zone;\n                pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n                pc.local_time_zone_table[1].value = probe_tm.tm_isdst;\n                pc.local_time_zone_table[2].name = NULL;\n              }\n            break;\n          }\n      }\n  }\n#else\n#if HAVE_TZNAME\n  {\n# if !HAVE_DECL_TZNAME\n    extern char *tzname[];\n# endif\n    int i;\n    for (i = 0; i < 2; i++)\n      {\n        pc.local_time_zone_table[i].name = tzname[i];\n        pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n        pc.local_time_zone_table[i].value = i;\n      }\n    pc.local_time_zone_table[i].name = NULL;\n  }\n#else\n  pc.local_time_zone_table[0].name = NULL;\n#endif\n#endif\n\n  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n      && ! strcmp (pc.local_time_zone_table[0].name,\n                   pc.local_time_zone_table[1].name))\n    {\n      /* This locale uses the same abbreviation for standard and\n         daylight times.  So if we see that abbreviation, we don't\n         know whether it's daylight time.  */\n      pc.local_time_zone_table[0].value = -1;\n      pc.local_time_zone_table[1].name = NULL;\n    }\n\n  if (yyparse (&pc) != 0)\n    {\n      if (pc.parse_datetime_debug)\n        dbg_printf ((input_sentinel <= pc.input\n                     ? _(\"error: parsing failed\\n\")\n                     : _(\"error: parsing failed, stopped at '%s'\\n\")),\n                    pc.input);\n      goto fail;\n    }\n\n\n  /* Determine effective timezone source.  */\n\n  if (pc.parse_datetime_debug)\n    {\n      dbg_printf (_(\"input timezone: \"));\n\n      if (pc.timespec_seen)\n        fprintf (stderr, _(\"'@timespec' - always UTC\"));\n      else if (pc.zones_seen)\n        fprintf (stderr, _(\"parsed date/time string\"));\n      else if (tzstring)\n        {\n          if (tz != tzdefault)\n            fprintf (stderr, _(\"TZ=\\\"%s\\\" in date string\"), tzstring);\n          else if (STREQ (tzstring, \"UTC0\"))\n            {\n              /* Special case: 'date -u' sets TZ=\"UTC0\".  */\n              fprintf (stderr, _(\"TZ=\\\"UTC0\\\" environment value or -u\"));\n            }\n          else\n            fprintf (stderr, _(\"TZ=\\\"%s\\\" environment value\"), tzstring);\n        }\n      else\n        fprintf (stderr, _(\"system default\"));\n\n      /* Account for DST changes if tLOCAL_ZONE was seen.\n         local timezone only changes DST and is relative to the\n         default timezone.*/\n      if (pc.local_zones_seen && !pc.zones_seen && 0 < pc.local_isdst)\n        fprintf (stderr, \", dst\");\n\n      if (pc.zones_seen)\n\tfprintf (stderr, \" (%s)\", time_zone_str (pc.time_zone, time_zone_buf));\n\n      fputc ('\\n', stderr);\n    }\n\n  if (pc.timespec_seen)\n    *result = pc.seconds;\n  else\n    {\n      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n               | (pc.local_zones_seen + pc.zones_seen)))\n        {\n          if (pc.parse_datetime_debug)\n            {\n              if (pc.times_seen > 1)\n                dbg_printf (\"error: seen multiple time parts\\n\");\n              if (pc.dates_seen > 1)\n                dbg_printf (\"error: seen multiple date parts\\n\");\n              if (pc.days_seen > 1)\n                dbg_printf (\"error: seen multiple days parts\\n\");\n              if (pc.dsts_seen > 1)\n                dbg_printf (\"error: seen multiple daylight-saving parts\\n\");\n              if ((pc.local_zones_seen + pc.zones_seen) > 1)\n                dbg_printf (\"error: seen multiple time-zone parts\\n\");\n            }\n          goto fail;\n        }\n\n      if (! to_tm_year (pc.year, pc.parse_datetime_debug, &tm.tm_year)\n          || INT_ADD_WRAPV (pc.month, -1, &tm.tm_mon)\n          || INT_ADD_WRAPV (pc.day, 0, &tm.tm_mday))\n        {\n          if (pc.parse_datetime_debug)\n            dbg_printf (_(\"error: year, month, or day overflow\\n\"));\n          goto fail;\n        }\n      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n        {\n          tm.tm_hour = to_hour (pc.hour, pc.meridian);\n          if (tm.tm_hour < 0)\n            {\n              char const *mrd = (pc.meridian == MERam ? \"am\"\n                                 : pc.meridian == MERpm ?\"pm\" : \"\");\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: invalid hour %\"PRIdMAX\"%s\\n\"),\n                            pc.hour, mrd);\n              goto fail;\n            }\n          tm.tm_min = pc.minutes;\n          tm.tm_sec = pc.seconds.tv_sec;\n          if (pc.parse_datetime_debug)\n            dbg_printf ((pc.times_seen\n                         ? _(\"using specified time as starting value: '%s'\\n\")\n                         : _(\"using current time as starting value: '%s'\\n\")),\n                        debug_strftime (&tm, dbg_tm, sizeof dbg_tm));\n        }\n      else\n        {\n          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n          pc.seconds.tv_nsec = 0;\n          if (pc.parse_datetime_debug)\n            dbg_printf (\"warning: using midnight as starting time: 00:00:00\\n\");\n        }\n\n      /* Let mktime deduce tm_isdst if we have an absolute timestamp.  */\n      if (pc.dates_seen | pc.days_seen | pc.times_seen)\n        tm.tm_isdst = -1;\n\n      /* But if the input explicitly specifies local time with or without\n         DST, give mktime that information.  */\n      if (pc.local_zones_seen)\n        tm.tm_isdst = pc.local_isdst;\n\n      tm0.tm_sec = tm.tm_sec;\n      tm0.tm_min = tm.tm_min;\n      tm0.tm_hour = tm.tm_hour;\n      tm0.tm_mday = tm.tm_mday;\n      tm0.tm_mon = tm.tm_mon;\n      tm0.tm_year = tm.tm_year;\n      tm0.tm_isdst = tm.tm_isdst;\n\n      Start = mktime_z (tz, &tm);\n\n      if (! mktime_ok (tz, &tm0, &tm, Start))\n        {\n          bool repaired = false;\n          bool time_zone_seen = pc.zones_seen != 0;\n          if (time_zone_seen)\n            {\n              /* Guard against falsely reporting errors near the time_t\n                 boundaries when parsing times in other time zones.  For\n                 example, suppose the input string \"1969-12-31 23:00:00 -0100\",\n                 the current time zone is 8 hours ahead of UTC, and the min\n                 time_t value is 1970-01-01 00:00:00 UTC.  Then the min\n                 localtime value is 1970-01-01 08:00:00, and mktime will\n                 therefore fail on 1969-12-31 23:00:00.  To work around the\n                 problem, set the time zone to 1 hour behind UTC temporarily\n                 by setting TZ=\"XXX1:00\" and try mktime again.  */\n\n              char tz2buf[sizeof \"XXX\" - 1 + TIME_ZONE_BUFSIZE];\n              tz2buf[0] = tz2buf[1] = tz2buf[2] = 'X';\n              time_zone_str (pc.time_zone, &tz2buf[3]);\n              timezone_t tz2 = tzalloc (tz2buf);\n              if (!tz2)\n                {\n                  if (pc.parse_datetime_debug)\n                    dbg_printf (_(\"error: tzalloc (\\\"%s\\\") failed\\n\"), tz2buf);\n                  goto fail;\n                }\n              tm.tm_sec = tm0.tm_sec;\n              tm.tm_min = tm0.tm_min;\n              tm.tm_hour = tm0.tm_hour;\n              tm.tm_mday = tm0.tm_mday;\n              tm.tm_mon = tm0.tm_mon;\n              tm.tm_year = tm0.tm_year;\n              tm.tm_isdst = tm0.tm_isdst;\n              Start = mktime_z (tz2, &tm);\n              repaired = mktime_ok (tz2, &tm0, &tm, Start);\n              tzfree (tz2);\n            }\n\n          if (! repaired)\n            {\n              debug_mktime_not_ok (&tm0, &tm, &pc, time_zone_seen);\n              goto fail;\n            }\n        }\n\n      char dbg_ord[DBGBUFSIZE];\n\n      if (pc.days_seen && ! pc.dates_seen)\n        {\n          intmax_t dayincr;\n          if (INT_MULTIPLY_WRAPV ((pc.day_ordinal\n                                   - (0 < pc.day_ordinal\n                                      && tm.tm_wday != pc.day_number)),\n                                  7, &dayincr)\n              || INT_ADD_WRAPV ((pc.day_number - tm.tm_wday + 7) % 7,\n                                dayincr, &dayincr)\n              || INT_ADD_WRAPV (dayincr, tm.tm_mday, &tm.tm_mday))\n            Start = -1;\n          else\n            {\n              tm.tm_isdst = -1;\n              Start = mktime_z (tz, &tm);\n            }\n\n          if (Start == (time_t) -1)\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: day '%s' \"\n                              \"(day ordinal=%\"PRIdMAX\" number=%d) \"\n                              \"resulted in an invalid date: '%s'\\n\"),\n                            str_days (&pc, dbg_ord, sizeof dbg_ord),\n                            pc.day_ordinal, pc.day_number,\n                            debug_strfdatetime (&tm, &pc, dbg_tm,\n                                                sizeof dbg_tm));\n              goto fail;\n            }\n\n          if (pc.parse_datetime_debug)\n            dbg_printf (_(\"new start date: '%s' is '%s'\\n\"),\n                        str_days (&pc, dbg_ord, sizeof dbg_ord),\n                        debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n\n        }\n\n      if (pc.parse_datetime_debug)\n        {\n          if (!pc.dates_seen && !pc.days_seen)\n            dbg_printf (_(\"using current date as starting value: '%s'\\n\"),\n                        debug_strfdate (&tm, dbg_tm, sizeof dbg_tm));\n\n          if (pc.days_seen && pc.dates_seen)\n            dbg_printf (_(\"warning: day (%s) ignored when explicit dates \"\n                          \"are given\\n\"),\n                        str_days (&pc, dbg_ord, sizeof dbg_ord));\n\n          dbg_printf (_(\"starting date/time: '%s'\\n\"),\n                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n        }\n\n      /* Add relative date.  */\n      if (pc.rel.year | pc.rel.month | pc.rel.day)\n        {\n          if (pc.parse_datetime_debug)\n            {\n              if ((pc.rel.year != 0 || pc.rel.month != 0) && tm.tm_mday != 15)\n                dbg_printf (_(\"warning: when adding relative months/years, \"\n                              \"it is recommended to specify the 15th of the \"\n                              \"months\\n\"));\n\n              if (pc.rel.day != 0 && tm.tm_hour != 12)\n                dbg_printf (_(\"warning: when adding relative days, \"\n                              \"it is recommended to specify noon\\n\"));\n            }\n\n          int year, month, day;\n          if (INT_ADD_WRAPV (tm.tm_year, pc.rel.year, &year)\n              || INT_ADD_WRAPV (tm.tm_mon, pc.rel.month, &month)\n              || INT_ADD_WRAPV (tm.tm_mday, pc.rel.day, &day))\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: %s:%d\\n\"), __FILE__, __LINE__);\n              goto fail;\n            }\n          tm.tm_year = year;\n          tm.tm_mon = month;\n          tm.tm_mday = day;\n          tm.tm_hour = tm0.tm_hour;\n          tm.tm_min = tm0.tm_min;\n          tm.tm_sec = tm0.tm_sec;\n          tm.tm_isdst = tm0.tm_isdst;\n          Start = mktime_z (tz, &tm);\n          if (Start == (time_t) -1)\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: adding relative date resulted \"\n                              \"in an invalid date: '%s'\\n\"),\n                            debug_strfdatetime (&tm, &pc, dbg_tm,\n                                                sizeof dbg_tm));\n              goto fail;\n            }\n\n          if (pc.parse_datetime_debug)\n            {\n              dbg_printf (_(\"after date adjustment \"\n                            \"(%+\"PRIdMAX\" years, %+\"PRIdMAX\" months, \"\n                            \"%+\"PRIdMAX\" days),\\n\"),\n                          pc.rel.year, pc.rel.month, pc.rel.day);\n              dbg_printf (_(\"    new date/time = '%s'\\n\"),\n                          debug_strfdatetime (&tm, &pc, dbg_tm,\n                                              sizeof dbg_tm));\n\n              /* Warn about crossing DST due to time adjustment.\n                 Example: https://bugs.gnu.org/8357\n                 env TZ=Europe/Helsinki \\\n                   date --debug \\\n                        -d 'Mon Mar 28 00:36:07 2011 EEST 1 day ago'\n\n                 This case is different than DST changes due to time adjustment,\n                 i.e., \"1 day ago\" vs \"24 hours ago\" are calculated in different\n                 places.\n\n                 'tm0.tm_isdst' contains the DST of the input date,\n                 'tm.tm_isdst' is the normalized result after calling\n                 mktime (&tm).\n              */\n              if (tm0.tm_isdst != -1 && tm.tm_isdst != tm0.tm_isdst)\n                dbg_printf (_(\"warning: daylight saving time changed after \"\n                              \"date adjustment\\n\"));\n\n              /* Warn if the user did not ask to adjust days but mday changed,\n                 or\n                 user did not ask to adjust months/days but the month changed.\n\n                 Example for first case:\n                 2016-05-31 + 1 month => 2016-06-31 => 2016-07-01.\n                 User asked to adjust month, but the day changed from 31 to 01.\n\n                 Example for second case:\n                 2016-02-29 + 1 year => 2017-02-29 => 2017-03-01.\n                 User asked to adjust year, but the month changed from 02 to 03.\n              */\n              if (pc.rel.day == 0\n                  && (tm.tm_mday != day\n                      || (pc.rel.month == 0 && tm.tm_mon != month)))\n                {\n                  dbg_printf (_(\"warning: month/year adjustment resulted in \"\n                                \"shifted dates:\\n\"));\n                  char tm_year_buf[TM_YEAR_BUFSIZE];\n                  dbg_printf (_(\"     adjusted Y M D: %s %02d %02d\\n\"),\n                              tm_year_str (year, tm_year_buf), month + 1, day);\n                  dbg_printf (_(\"   normalized Y M D: %s %02d %02d\\n\"),\n                              tm_year_str (tm.tm_year, tm_year_buf),\n                              tm.tm_mon + 1, tm.tm_mday);\n                }\n            }\n\n        }\n\n      /* The only \"output\" of this if-block is an updated Start value,\n         so this block must follow others that clobber Start.  */\n      if (pc.zones_seen)\n        {\n          intmax_t delta = pc.time_zone, t1;\n          bool overflow = false;\n#ifdef HAVE_TM_GMTOFF\n          long int utcoff = tm.tm_gmtoff;\n#else\n          time_t t = Start;\n          struct tm gmt;\n          int utcoff = (gmtime_r (&t, &gmt)\n                        ? tm_diff (&tm, &gmt)\n                        : (overflow = true, 0));\n#endif\n          overflow |= INT_SUBTRACT_WRAPV (delta, utcoff, &delta);\n          overflow |= INT_SUBTRACT_WRAPV (Start, delta, &t1);\n          if (overflow || time_overflow (t1))\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: timezone %d caused time_t overflow\\n\"),\n                            pc.time_zone);\n              goto fail;\n            }\n          Start = t1;\n        }\n\n      if (pc.parse_datetime_debug)\n        {\n          intmax_t Starti = Start;\n          dbg_printf (_(\"'%s' = %\"PRIdMAX\" epoch-seconds\\n\"),\n                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm),\n                      Starti);\n        }\n\n\n      /* Add relative hours, minutes, and seconds.  On hosts that support\n         leap seconds, ignore the possibility of leap seconds; e.g.,\n         \"+ 10 minutes\" adds 600 seconds, even if one of them is a\n         leap second.  Typically this is not what the user wants, but it's\n         too hard to do it the other way, because the time zone indicator\n         must be applied before relative times, and if mktime is applied\n         again the time zone will be lost.  */\n      {\n        intmax_t orig_ns = pc.seconds.tv_nsec;\n        intmax_t sum_ns = orig_ns + pc.rel.ns;\n        int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n        int d4 = (sum_ns - normalized_ns) / BILLION;\n        intmax_t d1, t1, d2, t2, t3, t4;\n        if (INT_MULTIPLY_WRAPV (pc.rel.hour, 60 * 60, &d1)\n            || INT_ADD_WRAPV (Start, d1, &t1)\n            || INT_MULTIPLY_WRAPV (pc.rel.minutes, 60, &d2)\n            || INT_ADD_WRAPV (t1, d2, &t2)\n            || INT_ADD_WRAPV (t2, pc.rel.seconds, &t3)\n            || INT_ADD_WRAPV (t3, d4, &t4)\n            || time_overflow (t4))\n          {\n            if (pc.parse_datetime_debug)\n              dbg_printf (_(\"error: adding relative time caused an \"\n                            \"overflow\\n\"));\n            goto fail;\n          }\n\n        result->tv_sec = t4;\n        result->tv_nsec = normalized_ns;\n\n        if (pc.parse_datetime_debug\n            && (pc.rel.hour | pc.rel.minutes | pc.rel.seconds | pc.rel.ns))\n          {\n            dbg_printf (_(\"after time adjustment (%+\"PRIdMAX\" hours, \"\n                          \"%+\"PRIdMAX\" minutes, \"\n                          \"%+\"PRIdMAX\" seconds, %+d ns),\\n\"),\n                        pc.rel.hour, pc.rel.minutes, pc.rel.seconds,\n                        pc.rel.ns);\n            dbg_printf (_(\"    new time = %\"PRIdMAX\" epoch-seconds\\n\"), t4);\n\n            /* Warn about crossing DST due to time adjustment.\n               Example: https://bugs.gnu.org/8357\n               env TZ=Europe/Helsinki           \\\n               date --debug                                             \\\n               -d 'Mon Mar 28 00:36:07 2011 EEST 24 hours ago'\n\n               This case is different than DST changes due to days adjustment,\n               i.e., \"1 day ago\" vs \"24 hours ago\" are calculated in different\n               places.\n\n               'tm.tm_isdst' contains the date after date adjustment.  */\n            struct tm lmt;\n            if (tm.tm_isdst != -1 && localtime_rz (tz, &result->tv_sec, &lmt)\n                && tm.tm_isdst != lmt.tm_isdst)\n              dbg_printf (_(\"warning: daylight saving time changed after \"\n                            \"time adjustment\\n\"));\n          }\n      }\n    }\n\n  if (pc.parse_datetime_debug)\n    {\n      /* Special case: using 'date -u' simply set TZ=UTC0 */\n      if (! tzstring)\n        dbg_printf (_(\"timezone: system default\\n\"));\n      else if (STREQ (tzstring, \"UTC0\"))\n        dbg_printf (_(\"timezone: Universal Time\\n\"));\n      else\n        dbg_printf (_(\"timezone: TZ=\\\"%s\\\" environment value\\n\"), tzstring);\n\n      intmax_t sec = result->tv_sec;\n      int nsec = result->tv_nsec;\n      dbg_printf (_(\"final: %\"PRIdMAX\".%09d (epoch-seconds)\\n\"),\n                  sec, nsec);\n\n      struct tm gmt, lmt;\n      bool got_utc = !!gmtime_r (&result->tv_sec, &gmt);\n      if (got_utc)\n        dbg_printf (_(\"final: %s (UTC)\\n\"),\n                    debug_strfdatetime (&gmt, NULL,\n                                        dbg_tm, sizeof dbg_tm));\n      if (localtime_rz (tz, &result->tv_sec, &lmt))\n        {\n#ifdef HAVE_TM_GMTOFF\n          bool got_utcoff = true;\n          long int utcoff = lmt.tm_gmtoff;\n#else\n          bool got_utcoff = got_utc;\n          int utcoff;\n          if (got_utcoff)\n            utcoff = tm_diff (&lmt, &gmt);\n#endif\n          if (got_utcoff)\n            dbg_printf (_(\"final: %s (UTC%s)\\n\"),\n                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm),\n                        time_zone_str (utcoff, time_zone_buf));\n          else\n            dbg_printf (_(\"final: %s (unknown time zone offset)\\n\"),\n                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm));\n        }\n    }\n\n  ok = true;\n\n fail:\n  if (tz != tzdefault)\n    tzfree (tz);\n  free (tz1alloc);\n  return ok;\n}",
      "lines": 656,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        4295,
        0
      ],
      "end_point": [
        4328,
        1
      ],
      "content": "int\nmain (int ac, char **av)\n{\n  char buff[BUFSIZ];\n\n  printf (\"Enter date, or blank line to exit.\\n\\t> \");\n  fflush (stdout);\n\n  buff[BUFSIZ - 1] = '\\0';\n  while (fgets (buff, BUFSIZ - 1, stdin) && buff[0])\n    {\n      struct timespec d;\n      struct tm const *tm;\n      if (! parse_datetime (&d, buff, NULL))\n        printf (\"Bad format - couldn't convert.\\n\");\n      else if (! (tm = localtime (&d.tv_sec)))\n        {\n          intmax_t sec = d.tv_sec;\n          printf (\"localtime (%\"PRIdMAX\") failed\\n\", sec);\n        }\n      else\n        {\n          int ns = d.tv_nsec;\n          char tm_year_buf[TM_YEAR_BUFSIZE];\n          printf (\"%s-%02d-%02d %02d:%02d:%02d.%09d\\n\",\n                  tm_year_str (tm->tm_year, tm_year_buf),\n                  tm->tm_mon + 1, tm->tm_mday,\n                  tm->tm_hour, tm->tm_min, tm->tm_sec, ns);\n        }\n      printf (\"\\t> \");\n      fflush (stdout);\n    }\n  return 0;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/parse-datetime.h": {},
  "tar/tar-1.30/gnu/parse-datetime.y": {
    "time_overflow": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static bool\ntime_overflow (intmax_t n)\n{\n  return ! ((TYPE_SIGNED (time_t) ? TYPE_MINIMUM (time_t) <= n : 0 <= n)\n            && n <= TYPE_MAXIMUM (time_t));\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "to_uchar": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        133,
        54
      ],
      "content": "static unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "_GL_ATTRIBUTE_FORMAT": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static void _GL_ATTRIBUTE_FORMAT ((__printf__, 1, 2))\ndbg_printf (char const *msg, ...)\n{\n  va_list args;\n  /* TODO: use gnulib's 'program_name' instead?  */\n  fputs (\"date: \", stderr);\n\n  va_start (args, msg);\n  vfprintf (stderr, msg, args);\n  va_end (args);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "digits_to_date_time": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static void\ndigits_to_date_time (parser_control *pc, textint text_int)\n{\n  if (pc->dates_seen && ! pc->year.digits\n      && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n    {\n      pc->year_seen = true;\n      pc->year = text_int;\n    }\n  else\n    {\n      if (4 < text_int.digits)\n        {\n          pc->dates_seen++;\n          pc->day = text_int.value % 100;\n          pc->month = (text_int.value / 100) % 100;\n          pc->year.value = text_int.value / 10000;\n          pc->year.digits = text_int.digits - 4;\n        }\n      else\n        {\n          pc->times_seen++;\n          if (text_int.digits <= 2)\n            {\n              pc->hour = text_int.value;\n              pc->minutes = 0;\n            }\n          else\n            {\n              pc->hour = text_int.value / 100;\n              pc->minutes = text_int.value % 100;\n            }\n          pc->seconds.tv_sec = 0;\n          pc->seconds.tv_nsec = 0;\n          pc->meridian = MER24;\n        }\n    }\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_relative_time": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "static bool\napply_relative_time (parser_control *pc, relative_time rel, int factor)\n{\n  if (factor < 0\n      ? (INT_SUBTRACT_WRAPV (pc->rel.ns, rel.ns, &pc->rel.ns)\n         | INT_SUBTRACT_WRAPV (pc->rel.seconds, rel.seconds, &pc->rel.seconds)\n         | INT_SUBTRACT_WRAPV (pc->rel.minutes, rel.minutes, &pc->rel.minutes)\n         | INT_SUBTRACT_WRAPV (pc->rel.hour, rel.hour, &pc->rel.hour)\n         | INT_SUBTRACT_WRAPV (pc->rel.day, rel.day, &pc->rel.day)\n         | INT_SUBTRACT_WRAPV (pc->rel.month, rel.month, &pc->rel.month)\n         | INT_SUBTRACT_WRAPV (pc->rel.year, rel.year, &pc->rel.year))\n      : (INT_ADD_WRAPV (pc->rel.ns, rel.ns, &pc->rel.ns)\n         | INT_ADD_WRAPV (pc->rel.seconds, rel.seconds, &pc->rel.seconds)\n         | INT_ADD_WRAPV (pc->rel.minutes, rel.minutes, &pc->rel.minutes)\n         | INT_ADD_WRAPV (pc->rel.hour, rel.hour, &pc->rel.hour)\n         | INT_ADD_WRAPV (pc->rel.day, rel.day, &pc->rel.day)\n         | INT_ADD_WRAPV (pc->rel.month, rel.month, &pc->rel.month)\n         | INT_ADD_WRAPV (pc->rel.year, rel.year, &pc->rel.year)))\n    return false;\n  pc->rels_seen = true;\n  return true;\n}",
      "lines": 22,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "set_hhmmss": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nset_hhmmss (parser_control *pc, intmax_t hour, intmax_t minutes,\n            time_t sec, int nsec)\n{\n  pc->hour = hour;\n  pc->minutes = minutes;\n  pc->seconds.tv_sec = sec;\n  pc->seconds.tv_nsec = nsec;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "str_days": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "static const char *\nstr_days (parser_control *pc, char *buffer, int n)\n{\n  /* TODO: use relative_time_table for reverse lookup.  */\n  static char const ordinal_values[][11] = {\n     \"last\",\n     \"this\",\n     \"next/first\",\n     \"(SECOND)\", /* SECOND is commented out in relative_time_table.  */\n     \"third\",\n     \"fourth\",\n     \"fifth\",\n     \"sixth\",\n     \"seventh\",\n     \"eight\",\n     \"ninth\",\n     \"tenth\",\n     \"eleventh\",\n     \"twelfth\"\n  };\n\n  static char const days_values[][4] = {\n     \"Sun\",\n     \"Mon\",\n     \"Tue\",\n     \"Wed\",\n     \"Thu\",\n     \"Fri\",\n     \"Sat\"\n  };\n\n  int len;\n\n  /* Don't add an ordinal prefix if the user didn't specify it\n     (e.g., \"this wed\" vs \"wed\").  */\n  if (pc->debug_ordinal_day_seen)\n    {\n      /* Use word description if possible (e.g., -1 = last, 3 = third).  */\n      len = (-1 <= pc->day_ordinal && pc->day_ordinal <= 12\n             ? snprintf (buffer, n, \"%s\", ordinal_values[pc->day_ordinal + 1])\n             : snprintf (buffer, n, \"%\"PRIdMAX, pc->day_ordinal));\n    }\n  else\n    {\n      buffer[0] = '\\0';\n      len = 0;\n    }\n\n  /* Add the day name */\n  if (0 <= pc->day_number && pc->day_number <= 6 && 0 <= len && len < n)\n    snprintf (buffer + len, n - len, &\" %s\"[len == 0],\n              days_values[pc->day_number]);\n  else\n    {\n      /* invalid day_number value - should never happen */\n    }\n  return buffer;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nstr_days (parser_control *pc, char *buffer, int n)",
        "*"
      ]
    },
    "time_zone_str": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "static char const *\ntime_zone_str (int time_zone, char time_zone_buf[TIME_ZONE_BUFSIZE])\n{\n  char *p = time_zone_buf;\n  char sign = time_zone < 0 ? '-' : '+';\n  int hour = abs (time_zone / (60 * 60));\n  p += sprintf (time_zone_buf, \"%c%02d\", sign, hour);\n  int offset_from_hour = abs (time_zone % (60 * 60));\n  if (offset_from_hour != 0)\n    {\n      int mm = offset_from_hour / 60;\n      int ss = offset_from_hour % 60;\n      *p++ = ':';\n      *p++ = '0' + mm / 10;\n      *p++ = '0' + mm % 10;\n      if (ss)\n        {\n          *p++ = ':';\n          *p++ = '0' + ss / 10;\n          *p++ = '0' + ss % 10;\n        }\n      *p = '\\0';\n    }\n  return time_zone_buf;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ntime_zone_str (int time_zone, char time_zone_buf[TIME_ZONE_BUFSIZE])",
        "*"
      ]
    },
    "debug_print_current_time": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "static void\ndebug_print_current_time (char const *item, parser_control *pc)\n{\n  bool space = false;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  /* no newline, more items printed below */\n  dbg_printf (_(\"parsed %s part: \"), item);\n\n  if (pc->dates_seen && !pc->debug_dates_seen)\n    {\n      /*TODO: use pc->year.negative?  */\n      fprintf (stderr, \"(Y-M-D) %04\"PRIdMAX\"-%02\"PRIdMAX\"-%02\"PRIdMAX,\n              pc->year.value, pc->month, pc->day);\n      pc->debug_dates_seen = true;\n      space = true;\n    }\n\n  if (pc->year_seen != pc->debug_year_seen)\n    {\n      if (space)\n        fputc (' ', stderr);\n      fprintf (stderr, _(\"year: %04\"PRIdMAX), pc->year.value);\n\n      pc->debug_year_seen = pc->year_seen;\n      space = true;\n    }\n\n  if (pc->times_seen && !pc->debug_times_seen)\n    {\n      intmax_t sec = pc->seconds.tv_sec;\n      fprintf (stderr, &\" %02\"PRIdMAX\":%02\"PRIdMAX\":%02\"PRIdMAX[!space],\n               pc->hour, pc->minutes, sec);\n      if (pc->seconds.tv_nsec != 0)\n        {\n          int nsec = pc->seconds.tv_nsec;\n          fprintf (stderr, \".%09d\", nsec);\n        }\n      if (pc->meridian == MERpm)\n        fputs (\"pm\", stderr);\n\n      pc->debug_times_seen = true;\n      space = true;\n    }\n\n  if (pc->days_seen && !pc->debug_days_seen)\n    {\n      if (space)\n        fputc (' ', stderr);\n      char tmp[DBGBUFSIZE];\n      fprintf (stderr, _(\"%s (day ordinal=%\"PRIdMAX\" number=%d)\"),\n               str_days (pc, tmp, sizeof tmp),\n               pc->day_ordinal, pc->day_number);\n      pc->debug_days_seen = true;\n      space = true;\n    }\n\n  /* local zone strings only change the DST settings,\n     not the timezone value.  If seen, inform about the DST.  */\n  if (pc->local_zones_seen && !pc->debug_local_zones_seen)\n    {\n      fprintf (stderr, &\" isdst=%d%s\"[!space],\n\t       pc->local_isdst, pc->dsts_seen ? \" DST\" : \"\");\n      pc->debug_local_zones_seen = true;\n      space = true;\n    }\n\n  if (pc->zones_seen && !pc->debug_zones_seen)\n    {\n      char time_zone_buf[TIME_ZONE_BUFSIZE];\n      fprintf (stderr, &\" UTC%s\"[!space],\n               time_zone_str (pc->time_zone, time_zone_buf));\n      pc->debug_zones_seen = true;\n      space = true;\n    }\n\n  if (pc->timespec_seen)\n    {\n      intmax_t sec = pc->seconds.tv_sec;\n      if (space)\n        fputc (' ', stderr);\n      fprintf (stderr, _(\"number of seconds: %\"PRIdMAX), sec);\n    }\n\n  fputc ('\\n', stderr);\n}",
      "lines": 88,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_rel_part": {
      "start_point": [
        521,
        0
      ],
      "end_point": [
        528,
        1
      ],
      "content": "static bool\nprint_rel_part (bool space, intmax_t val, char const *name)\n{\n  if (val == 0)\n    return space;\n  fprintf (stderr, &\" %+\"PRIdMAX\" %s\"[!space], val, name);\n  return true;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "debug_print_relative_time": {
      "start_point": [
        530,
        0
      ],
      "end_point": [
        559,
        1
      ],
      "content": "static void\ndebug_print_relative_time (char const *item, parser_control const *pc)\n{\n  bool space = false;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  /* no newline, more items printed below */\n  dbg_printf (_(\"parsed %s part: \"), item);\n\n  if (pc->rel.year == 0 && pc->rel.month == 0 && pc->rel.day == 0\n      && pc->rel.hour == 0 && pc->rel.minutes == 0 && pc->rel.seconds == 0\n      && pc->rel.ns == 0)\n    {\n      /* Special case: relative time of this/today/now */\n      fputs (_(\"today/this/now\\n\"), stderr);\n      return;\n    }\n\n  space = print_rel_part (space, pc->rel.year, \"year(s)\");\n  space = print_rel_part (space, pc->rel.month, \"month(s)\");\n  space = print_rel_part (space, pc->rel.day, \"day(s)\");\n  space = print_rel_part (space, pc->rel.hour, \"hour(s)\");\n  space = print_rel_part (space, pc->rel.minutes, \"minutes\");\n  space = print_rel_part (space, pc->rel.seconds, \"seconds\");\n  print_rel_part (space, pc->rel.ns, \"nanoseconds\");\n\n  fputc ('\\n', stderr);\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tZONE": [
      {
        "start_point": [
          684,
          30
        ],
        "end_point": [
          688,
          7
        ],
        "content": "unsigned_seconds tMERIDIAN\n      {\n        set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);\n        pc->meridian = $6;\n      }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          703,
          30
        ],
        "end_point": [
          707,
          7
        ],
        "content": "unsigned_seconds o_zone_offset\n      {\n        set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);\n        pc->meridian = MER24;\n      }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          743,
          4
        ],
        "end_point": [
          747,
          7
        ],
        "content": "tLOCAL_ZONE tDST\n      {\n        pc->local_isdst = 1;\n        pc->dsts_seen++;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          757,
          4
        ],
        "end_point": [
          761,
          7
        ],
        "content": "tZONE relunit_snumber\n      { pc->time_zone = $1;\n        if (! apply_relative_time (pc, $2, 1)) YYABORT;\n        debug_print_relative_time (_(\"relative\"), pc);\n      }",
        "lines": 5,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          767,
          4
        ],
        "end_point": [
          769,
          73
        ],
        "content": "tZONE tSNUMBER o_colon_minutes\n      { if (! time_zone_hhmm (pc, $2, $3)) YYABORT;\n        if (INT_ADD_WRAPV (pc->time_zone, $1, &pc->time_zone)) YYABORT; }",
        "lines": 3,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          772,
          4
        ],
        "end_point": [
          773,
          39
        ],
        "content": "tZONE tDST\n      { pc->time_zone = $1 + 60 * 60; }",
        "lines": 2,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          787,
          4
        ],
        "end_point": [
          792,
          7
        ],
        "content": "tORDINAL tDAY\n      {\n        pc->day_ordinal = $1;\n        pc->day_number = $2;\n        pc->debug_ordinal_day_seen = true;\n      }",
        "lines": 6,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          793,
          4
        ],
        "end_point": [
          798,
          7
        ],
        "content": "tUNUMBER tDAY\n      {\n        pc->day_ordinal = $1.value;\n        pc->day_number = $2;\n        pc->debug_ordinal_day_seen = true;\n      }",
        "lines": 6,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          840,
          4
        ],
        "end_point": [
          847,
          7
        ],
        "content": "tUNUMBER tMONTH tSNUMBER\n      {\n        /* E.g., 17-JUN-1992.  */\n        pc->day = $1.value;\n        pc->month = $2;\n        if (INT_SUBTRACT_WRAPV (0, $3.value, &pc->year.value)) YYABORT;\n        pc->year.digits = $3.digits;\n      }",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          848,
          4
        ],
        "end_point": [
          855,
          7
        ],
        "content": "tMONTH tSNUMBER tSNUMBER\n      {\n        /* E.g., JUN-17-1992.  */\n        pc->month = $1;\n        if (INT_SUBTRACT_WRAPV (0, $2.value, &pc->day)) YYABORT;\n        if (INT_SUBTRACT_WRAPV (0, $3.value, &pc->year.value)) YYABORT;\n        pc->year.digits = $3.digits;\n      }",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          856,
          4
        ],
        "end_point": [
          860,
          7
        ],
        "content": "tMONTH tUNUMBER\n      {\n        pc->month = $1;\n        pc->day = $2.value;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      }
    ],
    "tUNUMBER": [
      {
        "start_point": [
          867,
          4
        ],
        "end_point": [
          871,
          7
        ],
        "content": "tUNUMBER tMONTH\n      {\n        pc->day = $1.value;\n        pc->month = $2;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          872,
          4
        ],
        "end_point": [
          877,
          7
        ],
        "content": "tUNUMBER tMONTH tUNUMBER\n      {\n        pc->day = $1.value;\n        pc->month = $2;\n        pc->year = $3;\n      }",
        "lines": 6,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          882,
          13
        ],
        "end_point": [
          888,
          7
        ],
        "content": "tSNUMBER tSNUMBER\n      {\n        /* ISO 8601 format.  YYYY-MM-DD.  */\n        pc->year = $1;\n        if (INT_SUBTRACT_WRAPV (0, $2.value, &pc->month)) YYABORT;\n        if (INT_SUBTRACT_WRAPV (0, $3.value, &pc->day)) YYABORT;\n      }",
        "lines": 7,
        "depth": 9,
        "decorators": null
      }
    ],
    "tMONTH_UNIT": [
      {
        "start_point": [
          913,
          4
        ],
        "end_point": [
          915,
          60
        ],
        "content": "tORDINAL tDAY_UNIT\n      { $$ = RELATIVE_TIME_0;\n        if (INT_MULTIPLY_WRAPV ($1, $2, &$$.day)) YYABORT; }",
        "lines": 3,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          916,
          4
        ],
        "end_point": [
          918,
          66
        ],
        "content": "tUNUMBER tDAY_UNIT\n      { $$ = RELATIVE_TIME_0;\n        if (INT_MULTIPLY_WRAPV ($1.value, $2, &$$.day)) YYABORT; }",
        "lines": 3,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          951,
          4
        ],
        "end_point": [
          953,
          66
        ],
        "content": "tSNUMBER tDAY_UNIT\n      { $$ = RELATIVE_TIME_0;\n        if (INT_MULTIPLY_WRAPV ($1.value, $2, &$$.day)) YYABORT; }",
        "lines": 3,
        "depth": 9,
        "decorators": null
      }
    ],
    "time_zone_hhmm": {
      "start_point": [
        1203,
        0
      ],
      "end_point": [
        1228,
        1
      ],
      "content": "static bool\ntime_zone_hhmm (parser_control *pc, textint s, intmax_t mm)\n{\n  intmax_t n_minutes;\n  bool overflow = false;\n\n  /* If the length of S is 1 or 2 and no minutes are specified,\n     interpret it as a number of hours.  */\n  if (s.digits <= 2 && mm < 0)\n    s.value *= 100;\n\n  if (mm < 0)\n    n_minutes = (s.value / 100) * 60 + s.value % 100;\n  else\n    {\n      overflow |= INT_MULTIPLY_WRAPV (s.value, 60, &n_minutes);\n      overflow |= (s.negative\n                   ? INT_SUBTRACT_WRAPV (n_minutes, mm, &n_minutes)\n                   : INT_ADD_WRAPV (n_minutes, mm, &n_minutes));\n    }\n\n  if (overflow || ! (-24 * 60 <= n_minutes && n_minutes <= 24 * 60))\n    return false;\n  pc->time_zone = n_minutes * 60;\n  return true;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "to_hour": {
      "start_point": [
        1230,
        0
      ],
      "end_point": [
        1243,
        1
      ],
      "content": "static int\nto_hour (intmax_t hours, int meridian)\n{\n  switch (meridian)\n    {\n    default: /* Pacify GCC.  */\n    case MER24:\n      return 0 <= hours && hours < 24 ? hours : -1;\n    case MERam:\n      return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n    case MERpm:\n      return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tm_year_str": {
      "start_point": [
        1251,
        0
      ],
      "end_point": [
        1259,
        1
      ],
      "content": "static char const *\ntm_year_str (int tm_year, char buf[TM_YEAR_BUFSIZE])\n{\n  verify (TM_YEAR_BASE % 100 == 0);\n  sprintf (buf, &\"-%02d%02d\"[-TM_YEAR_BASE <= tm_year],\n           abs (tm_year / 100 + TM_YEAR_BASE / 100),\n           abs (tm_year % 100));\n  return buf;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ntm_year_str (int tm_year, char buf[TM_YEAR_BUFSIZE])",
        "*"
      ]
    },
    "to_tm_year": {
      "start_point": [
        1264,
        0
      ],
      "end_point": [
        1290,
        1
      ],
      "content": "static bool\nto_tm_year (textint textyear, bool debug, int *tm_year)\n{\n  intmax_t year = textyear.value;\n\n  /* XPG4 suggests that years 00-68 map to 2000-2068, and\n     years 69-99 map to 1969-1999.  */\n  if (0 <= year && textyear.digits == 2)\n    {\n      year += year < 69 ? 2000 : 1900;\n      if (debug)\n        dbg_printf (_(\"warning: adjusting year value %\"PRIdMAX\n                      \" to %\"PRIdMAX\"\\n\"),\n                    textyear.value, year);\n    }\n\n  if (year < 0\n      ? INT_SUBTRACT_WRAPV (-TM_YEAR_BASE, year, tm_year)\n      : INT_SUBTRACT_WRAPV (year, TM_YEAR_BASE, tm_year))\n    {\n      if (debug)\n        dbg_printf (_(\"error: out-of-range year %\"PRIdMAX\"\\n\"), year);\n      return false;\n    }\n\n  return true;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "lookup_zone": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1312,
        1
      ],
      "content": "static table const * _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)\n{\n  table const *tp;\n\n  for (tp = universal_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  /* Try local zone abbreviations before those in time_zone_table, as\n     the local ones are more likely to be right.  */\n  for (tp = pc->local_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  for (tp = time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "tm_diff": {
      "start_point": [
        1319,
        0
      ],
      "end_point": [
        1338,
        1
      ],
      "content": "static int\ntm_diff (const struct tm *a, const struct tm *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations,\n     but it's OK to assume that A and B are close to each other.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  int years = a->tm_year - b->tm_year;\n  int days = (365 * years + intervening_leap_days\n              + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lookup_word": {
      "start_point": [
        1341,
        0
      ],
      "end_point": [
        1407,
        1
      ],
      "content": "static table const *\nlookup_word (parser_control const *pc, char *word)\n{\n  char *p;\n  char *q;\n  ptrdiff_t wordlen;\n  table const *tp;\n  bool period_found;\n  bool abbrev;\n\n  /* Make it uppercase.  */\n  for (p = word; *p; p++)\n    *p = c_toupper (to_uchar (*p));\n\n  for (tp = meridian_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* See if we have an abbreviation for a month.  */\n  wordlen = strlen (word);\n  abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n\n  for (tp = month_and_day_table; tp->name; tp++)\n    if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n      return tp;\n\n  if ((tp = lookup_zone (pc, word)))\n    return tp;\n\n  if (strcmp (word, dst_table[0].name) == 0)\n    return dst_table;\n\n  for (tp = time_units_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Strip off any plural and try the units table again.  */\n  if (word[wordlen - 1] == 'S')\n    {\n      word[wordlen - 1] = '\\0';\n      for (tp = time_units_table; tp->name; tp++)\n        if (strcmp (word, tp->name) == 0)\n          return tp;\n      word[wordlen - 1] = 'S';  /* For \"this\" in relative_time_table.  */\n    }\n\n  for (tp = relative_time_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Military time zones.  */\n  if (wordlen == 1)\n    for (tp = military_table; tp->name; tp++)\n      if (word[0] == tp->name[0])\n        return tp;\n\n  /* Drop out any periods and try the time zone table again.  */\n  for (period_found = false, p = q = word; (*p = *q); q++)\n    if (*q == '.')\n      period_found = true;\n    else\n      p++;\n  if (period_found && (tp = lookup_zone (pc, word)))\n    return tp;\n\n  return NULL;\n}",
      "lines": 67,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "*\nlookup_word (parser_control const *pc, char *word)",
        "*"
      ]
    },
    "yylex": {
      "start_point": [
        1409,
        0
      ],
      "end_point": [
        1546,
        1
      ],
      "content": "static int\nyylex (union YYSTYPE *lvalp, parser_control *pc)\n{\n  unsigned char c;\n\n  for (;;)\n    {\n      while (c = *pc->input, c_isspace (c))\n        pc->input++;\n\n      if (c_isdigit (c) || c == '-' || c == '+')\n        {\n          char const *p;\n          int sign;\n          intmax_t value = 0;\n          if (c == '-' || c == '+')\n            {\n              sign = c == '-' ? -1 : 1;\n              while (c = *++pc->input, c_isspace (c))\n                continue;\n              if (! c_isdigit (c))\n                /* skip the '-' sign */\n                continue;\n            }\n          else\n            sign = 0;\n          p = pc->input;\n\n          do\n            {\n              if (INT_MULTIPLY_WRAPV (value, 10, &value))\n                return '?';\n              if (INT_ADD_WRAPV (value, sign < 0 ? '0' - c : c - '0', &value))\n                return '?';\n              c = *++p;\n            }\n          while (c_isdigit (c));\n\n          if ((c == '.' || c == ',') && c_isdigit (p[1]))\n            {\n              time_t s;\n              int ns;\n              int digits;\n\n              if (time_overflow (value))\n                return '?';\n              s = value;\n\n              /* Accumulate fraction, to ns precision.  */\n              p++;\n              ns = *p++ - '0';\n              for (digits = 2; digits <= LOG10_BILLION; digits++)\n                {\n                  ns *= 10;\n                  if (c_isdigit (*p))\n                    ns += *p++ - '0';\n                }\n\n              /* Skip excess digits, truncating toward -Infinity.  */\n              if (sign < 0)\n                for (; c_isdigit (*p); p++)\n                  if (*p != '0')\n                    {\n                      ns++;\n                      break;\n                    }\n              while (c_isdigit (*p))\n                p++;\n\n              /* Adjust to the timespec convention, which is that\n                 tv_nsec is always a positive offset even if tv_sec is\n                 negative.  */\n              if (sign < 0 && ns)\n                {\n                  if (s == TYPE_MINIMUM (time_t))\n                    return '?';\n                  s--;\n                  ns = BILLION - ns;\n                }\n\n              lvalp->timespec.tv_sec = s;\n              lvalp->timespec.tv_nsec = ns;\n              pc->input = p;\n              return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n            }\n          else\n            {\n              lvalp->textintval.negative = sign < 0;\n              lvalp->textintval.value = value;\n              lvalp->textintval.digits = p - pc->input;\n              pc->input = p;\n              return sign ? tSNUMBER : tUNUMBER;\n            }\n        }\n\n      if (c_isalpha (c))\n        {\n          char buff[20];\n          char *p = buff;\n          table const *tp;\n\n          do\n            {\n              if (p < buff + sizeof buff - 1)\n                *p++ = c;\n              c = *++pc->input;\n            }\n          while (c_isalpha (c) || c == '.');\n\n          *p = '\\0';\n          tp = lookup_word (pc, buff);\n          if (! tp)\n            {\n              if (pc->parse_datetime_debug)\n                dbg_printf (_(\"error: unknown word '%s'\\n\"), buff);\n              return '?';\n            }\n          lvalp->intval = tp->value;\n          return tp->type;\n        }\n\n      if (c != '(')\n        return to_uchar (*pc->input++);\n\n      ptrdiff_t count = 0;\n      do\n        {\n          c = *pc->input++;\n          if (c == '\\0')\n            return c;\n          if (c == '(')\n            count++;\n          else if (c == ')')\n            count--;\n        }\n      while (count != 0);\n    }\n}",
      "lines": 138,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        1549,
        0
      ],
      "end_point": [
        1554,
        1
      ],
      "content": "static int\nyyerror (parser_control const *pc _GL_UNUSED,\n         char const *s _GL_UNUSED)\n{\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mktime_ok": {
      "start_point": [
        1561,
        0
      ],
      "end_point": [
        1581,
        1
      ],
      "content": "static bool\nmktime_ok (timezone_t tz, struct tm const *tm0, struct tm const *tm1, time_t t)\n{\n  struct tm ltm;\n  if (t == (time_t) -1)\n    {\n      /* Guard against falsely reporting an error when parsing a\n         timestamp that happens to equal (time_t) -1, on a host that\n         supports such a timestamp.  */\n      tm1 = localtime_rz (tz, &t, &ltm);\n      if (!tm1)\n        return false;\n    }\n\n  return ! ((tm0->tm_sec ^ tm1->tm_sec)\n            | (tm0->tm_min ^ tm1->tm_min)\n            | (tm0->tm_hour ^ tm1->tm_hour)\n            | (tm0->tm_mday ^ tm1->tm_mday)\n            | (tm0->tm_mon ^ tm1->tm_mon)\n            | (tm0->tm_year ^ tm1->tm_year));\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "debug_strfdatetime": {
      "start_point": [
        1585,
        0
      ],
      "end_point": [
        1628,
        1
      ],
      "content": "static char const *\ndebug_strfdatetime (struct tm const *tm, parser_control const *pc,\n                    char *buf, int n)\n{\n  /* TODO:\n     1. find an optimal way to print date string in a clear and unambiguous\n        format.  Currently, always add '(Y-M-D)' prefix.\n        Consider '2016y01m10d'  or 'year(2016) month(01) day(10)'.\n\n        If the user needs debug printing, it means he/she already having\n        issues with the parsing - better to avoid formats that could\n        be mis-interpreted (e.g., just YYYY-MM-DD).\n\n     2. Can strftime be used instead?\n        depends if it is portable and can print invalid dates on all systems.\n\n     3. Print timezone information ?\n\n     4. Print DST information ?\n\n     5. Print nanosecond information ?\n\n     NOTE:\n     Printed date/time values might not be valid, e.g., '2016-02-31'\n     or '2016-19-2016' .  These are the values as parsed from the user\n     string, before validation.\n  */\n  int m = nstrftime (buf, n, \"(Y-M-D) %Y-%m-%d %H:%M:%S\", tm, 0, 0);\n\n  /* If parser_control information was provided (for timezone),\n     and there's enough space in the buffer, add timezone info.  */\n  if (pc && m < n && pc->zones_seen)\n    {\n      int tz = pc->time_zone;\n\n      /* Account for DST if tLOCAL_ZONE was seen.  */\n      if (pc->local_zones_seen && !pc->zones_seen && 0 < pc->local_isdst)\n        tz += 60 * 60;\n\n      char time_zone_buf[TIME_ZONE_BUFSIZE];\n      snprintf (&buf[m], n - m, \" TZ=%s\", time_zone_str (tz, time_zone_buf));\n    }\n  return buf;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strfdatetime (struct tm const *tm, parser_control const *pc,\n                    char *buf, int n)",
        "*"
      ]
    },
    "debug_strfdate": {
      "start_point": [
        1630,
        0
      ],
      "end_point": [
        1638,
        1
      ],
      "content": "static char const *\ndebug_strfdate (struct tm const *tm, char *buf, int n)\n{\n  char tm_year_buf[TM_YEAR_BUFSIZE];\n  snprintf (buf, n, \"(Y-M-D) %s-%02d-%02d\",\n            tm_year_str (tm->tm_year, tm_year_buf),\n            tm->tm_mon + 1, tm->tm_mday);\n  return buf;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strfdate (struct tm const *tm, char *buf, int n)",
        "*"
      ]
    },
    "debug_strftime": {
      "start_point": [
        1640,
        0
      ],
      "end_point": [
        1645,
        1
      ],
      "content": "static char const *\ndebug_strftime (struct tm const *tm, char *buf, int n)\n{\n  snprintf (buf, n, \"%02d:%02d:%02d\", tm->tm_hour, tm->tm_min, tm->tm_sec);\n  return buf;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ndebug_strftime (struct tm const *tm, char *buf, int n)",
        "*"
      ]
    },
    "debug_mktime_not_ok": {
      "start_point": [
        1659,
        0
      ],
      "end_point": [
        1713,
        1
      ],
      "content": "static void\ndebug_mktime_not_ok (struct tm const *tm0, struct tm const *tm1,\n                     parser_control const *pc, bool time_zone_seen)\n{\n  /* TODO: handle t == -1 (as in 'mktime_ok').  */\n  char tmp[DBGBUFSIZE];\n  int i;\n  const bool eq_sec   = (tm0->tm_sec  == tm1->tm_sec);\n  const bool eq_min   = (tm0->tm_min  == tm1->tm_min);\n  const bool eq_hour  = (tm0->tm_hour == tm1->tm_hour);\n  const bool eq_mday  = (tm0->tm_mday == tm1->tm_mday);\n  const bool eq_month = (tm0->tm_mon  == tm1->tm_mon);\n  const bool eq_year  = (tm0->tm_year == tm1->tm_year);\n\n  const bool dst_shift = eq_sec && eq_min && !eq_hour\n                         && eq_mday && eq_month && eq_year;\n\n  if (!pc->parse_datetime_debug)\n    return;\n\n  dbg_printf (_(\"error: invalid date/time value:\\n\"));\n  dbg_printf (_(\"    user provided time: '%s'\\n\"),\n              debug_strfdatetime (tm0, pc, tmp, sizeof tmp));\n  dbg_printf (_(\"       normalized time: '%s'\\n\"),\n              debug_strfdatetime (tm1, pc, tmp, sizeof tmp));\n  /* The format must be aligned with debug_strfdatetime and the two\n     DEBUG statements above.  This string is not translated.  */\n  i = snprintf (tmp, sizeof tmp,\n                \"                                 %4s %2s %2s %2s %2s %2s\",\n                eq_year ? \"\" : \"----\",\n                eq_month ? \"\" : \"--\",\n                eq_mday ? \"\" : \"--\",\n                eq_hour ? \"\" : \"--\",\n                eq_min ? \"\" : \"--\",\n                eq_sec ? \"\" : \"--\");\n  /* Trim trailing whitespace.  */\n  if (0 <= i)\n    {\n      if (sizeof tmp - 1 < i)\n        i = sizeof tmp - 1;\n      while (0 < i && tmp[i - 1] == ' ')\n        --i;\n      tmp[i] = '\\0';\n    }\n  dbg_printf (\"%s\\n\", tmp);\n\n  dbg_printf (_(\"     possible reasons:\\n\"));\n  if (dst_shift)\n    dbg_printf (_(\"       non-existing due to daylight-saving time;\\n\"));\n  if (!eq_mday && !eq_month)\n    dbg_printf (_(\"       invalid day/month combination;\\n\"));\n  dbg_printf (_(\"       numeric values overflow;\\n\"));\n  dbg_printf (\"       %s\\n\", (time_zone_seen ? _(\"incorrect timezone\")\n                              : _(\"missing timezone\")));\n}",
      "lines": 55,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_datetime": {
      "start_point": [
        1716,
        0
      ],
      "end_point": [
        1727,
        1
      ],
      "content": "bool\nparse_datetime (struct timespec *result, char const *p,\n                struct timespec const *now)\n{\n  char const *tzstring = getenv (\"TZ\");\n  timezone_t tz = tzalloc (tzstring);\n  if (!tz)\n    return false;\n  bool ok = parse_datetime2 (result, p, now, 0, tz, tzstring);\n  tzfree (tz);\n  return ok;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "parse_datetime2": {
      "start_point": [
        1734,
        0
      ],
      "end_point": [
        2389,
        1
      ],
      "content": "bool\nparse_datetime2 (struct timespec *result, char const *p,\n                 struct timespec const *now, unsigned int flags,\n                 timezone_t tzdefault, char const *tzstring)\n{\n  struct tm tm;\n  struct tm tm0;\n  char time_zone_buf[TIME_ZONE_BUFSIZE];\n  char dbg_tm[DBGBUFSIZE];\n  bool ok = false;\n  char const *input_sentinel = p + strlen (p);\n  char *tz1alloc = NULL;\n\n  /* A reasonable upper bound for the size of ordinary TZ strings.\n     Use heap allocation if TZ's length exceeds this.  */\n  enum { TZBUFSIZE = 100 };\n  char tz1buf[TZBUFSIZE];\n\n  struct timespec gettime_buffer;\n  if (! now)\n    {\n      gettime (&gettime_buffer);\n      now = &gettime_buffer;\n    }\n\n  time_t Start = now->tv_sec;\n  int Start_ns = now->tv_nsec;\n\n  unsigned char c;\n  while (c = *p, c_isspace (c))\n    p++;\n\n  timezone_t tz = tzdefault;\n\n  if (strncmp (p, \"TZ=\\\"\", 4) == 0)\n    {\n      char const *tzbase = p + 4;\n      ptrdiff_t tzsize = 1;\n      char const *s;\n\n      for (s = tzbase; *s; s++, tzsize++)\n        if (*s == '\\\\')\n          {\n            s++;\n            if (! (*s == '\\\\' || *s == '\"'))\n              break;\n          }\n        else if (*s == '\"')\n          {\n            timezone_t tz1;\n            char *tz1string = tz1buf;\n            char *z;\n            if (TZBUFSIZE < tzsize)\n              {\n                tz1alloc = malloc (tzsize);\n                if (!tz1alloc)\n                  goto fail;\n                tz1string = tz1alloc;\n              }\n            z = tz1string;\n            for (s = tzbase; *s != '\"'; s++)\n              *z++ = *(s += *s == '\\\\');\n            *z = '\\0';\n            tz1 = tzalloc (tz1string);\n            if (!tz1)\n              goto fail;\n            tz = tz1;\n            tzstring = tz1string;\n\n            p = s + 1;\n            while (c = *p, c_isspace (c))\n              p++;\n\n            break;\n          }\n    }\n\n  struct tm tmp;\n  if (! localtime_rz (tz, &now->tv_sec, &tmp))\n    goto fail;\n\n  /* As documented, be careful to treat the empty string just like\n     a date string of \"0\".  Without this, an empty string would be\n     declared invalid when parsed during a DST transition.  */\n  if (*p == '\\0')\n    p = \"0\";\n\n  parser_control pc;\n  pc.input = p;\n  pc.parse_datetime_debug = (flags & PARSE_DATETIME_DEBUG) != 0;\n  if (INT_ADD_WRAPV (tmp.tm_year, TM_YEAR_BASE, &pc.year.value))\n    {\n      if (pc.parse_datetime_debug)\n        dbg_printf (_(\"error: initial year out of range\\n\"));\n      goto fail;\n    }\n  pc.year.digits = 0;\n  pc.month = tmp.tm_mon + 1;\n  pc.day = tmp.tm_mday;\n  pc.hour = tmp.tm_hour;\n  pc.minutes = tmp.tm_min;\n  pc.seconds.tv_sec = tmp.tm_sec;\n  pc.seconds.tv_nsec = Start_ns;\n  tm.tm_isdst = tmp.tm_isdst;\n\n  pc.meridian = MER24;\n  pc.rel = RELATIVE_TIME_0;\n  pc.timespec_seen = false;\n  pc.rels_seen = false;\n  pc.dates_seen = 0;\n  pc.days_seen = 0;\n  pc.times_seen = 0;\n  pc.local_zones_seen = 0;\n  pc.dsts_seen = 0;\n  pc.zones_seen = 0;\n  pc.year_seen = false;\n  pc.debug_dates_seen = false;\n  pc.debug_days_seen = false;\n  pc.debug_times_seen = false;\n  pc.debug_local_zones_seen = false;\n  pc.debug_zones_seen = false;\n  pc.debug_year_seen = false;\n  pc.debug_ordinal_day_seen = false;\n\n#if HAVE_STRUCT_TM_TM_ZONE\n  pc.local_time_zone_table[0].name = tmp.tm_zone;\n  pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n  pc.local_time_zone_table[0].value = tmp.tm_isdst;\n  pc.local_time_zone_table[1].name = NULL;\n\n  /* Probe the names used in the next three calendar quarters, looking\n     for a tm_isdst different from the one we already have.  */\n  {\n    int quarter;\n    for (quarter = 1; quarter <= 3; quarter++)\n      {\n        intmax_t iprobe;\n        if (INT_ADD_WRAPV (Start, quarter * (90 * 24 * 60 * 60), &iprobe)\n            || time_overflow (iprobe))\n          break;\n        time_t probe = iprobe;\n        struct tm probe_tm;\n        if (localtime_rz (tz, &probe, &probe_tm) && probe_tm.tm_zone\n            && probe_tm.tm_isdst != pc.local_time_zone_table[0].value)\n          {\n              {\n                pc.local_time_zone_table[1].name = probe_tm.tm_zone;\n                pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n                pc.local_time_zone_table[1].value = probe_tm.tm_isdst;\n                pc.local_time_zone_table[2].name = NULL;\n              }\n            break;\n          }\n      }\n  }\n#else\n#if HAVE_TZNAME\n  {\n# if !HAVE_DECL_TZNAME\n    extern char *tzname[];\n# endif\n    int i;\n    for (i = 0; i < 2; i++)\n      {\n        pc.local_time_zone_table[i].name = tzname[i];\n        pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n        pc.local_time_zone_table[i].value = i;\n      }\n    pc.local_time_zone_table[i].name = NULL;\n  }\n#else\n  pc.local_time_zone_table[0].name = NULL;\n#endif\n#endif\n\n  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n      && ! strcmp (pc.local_time_zone_table[0].name,\n                   pc.local_time_zone_table[1].name))\n    {\n      /* This locale uses the same abbreviation for standard and\n         daylight times.  So if we see that abbreviation, we don't\n         know whether it's daylight time.  */\n      pc.local_time_zone_table[0].value = -1;\n      pc.local_time_zone_table[1].name = NULL;\n    }\n\n  if (yyparse (&pc) != 0)\n    {\n      if (pc.parse_datetime_debug)\n        dbg_printf ((input_sentinel <= pc.input\n                     ? _(\"error: parsing failed\\n\")\n                     : _(\"error: parsing failed, stopped at '%s'\\n\")),\n                    pc.input);\n      goto fail;\n    }\n\n\n  /* Determine effective timezone source.  */\n\n  if (pc.parse_datetime_debug)\n    {\n      dbg_printf (_(\"input timezone: \"));\n\n      if (pc.timespec_seen)\n        fprintf (stderr, _(\"'@timespec' - always UTC\"));\n      else if (pc.zones_seen)\n        fprintf (stderr, _(\"parsed date/time string\"));\n      else if (tzstring)\n        {\n          if (tz != tzdefault)\n            fprintf (stderr, _(\"TZ=\\\"%s\\\" in date string\"), tzstring);\n          else if (STREQ (tzstring, \"UTC0\"))\n            {\n              /* Special case: 'date -u' sets TZ=\"UTC0\".  */\n              fprintf (stderr, _(\"TZ=\\\"UTC0\\\" environment value or -u\"));\n            }\n          else\n            fprintf (stderr, _(\"TZ=\\\"%s\\\" environment value\"), tzstring);\n        }\n      else\n        fprintf (stderr, _(\"system default\"));\n\n      /* Account for DST changes if tLOCAL_ZONE was seen.\n         local timezone only changes DST and is relative to the\n         default timezone.*/\n      if (pc.local_zones_seen && !pc.zones_seen && 0 < pc.local_isdst)\n        fprintf (stderr, \", dst\");\n\n      if (pc.zones_seen)\n\tfprintf (stderr, \" (%s)\", time_zone_str (pc.time_zone, time_zone_buf));\n\n      fputc ('\\n', stderr);\n    }\n\n  if (pc.timespec_seen)\n    *result = pc.seconds;\n  else\n    {\n      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n               | (pc.local_zones_seen + pc.zones_seen)))\n        {\n          if (pc.parse_datetime_debug)\n            {\n              if (pc.times_seen > 1)\n                dbg_printf (\"error: seen multiple time parts\\n\");\n              if (pc.dates_seen > 1)\n                dbg_printf (\"error: seen multiple date parts\\n\");\n              if (pc.days_seen > 1)\n                dbg_printf (\"error: seen multiple days parts\\n\");\n              if (pc.dsts_seen > 1)\n                dbg_printf (\"error: seen multiple daylight-saving parts\\n\");\n              if ((pc.local_zones_seen + pc.zones_seen) > 1)\n                dbg_printf (\"error: seen multiple time-zone parts\\n\");\n            }\n          goto fail;\n        }\n\n      if (! to_tm_year (pc.year, pc.parse_datetime_debug, &tm.tm_year)\n          || INT_ADD_WRAPV (pc.month, -1, &tm.tm_mon)\n          || INT_ADD_WRAPV (pc.day, 0, &tm.tm_mday))\n        {\n          if (pc.parse_datetime_debug)\n            dbg_printf (_(\"error: year, month, or day overflow\\n\"));\n          goto fail;\n        }\n      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n        {\n          tm.tm_hour = to_hour (pc.hour, pc.meridian);\n          if (tm.tm_hour < 0)\n            {\n              char const *mrd = (pc.meridian == MERam ? \"am\"\n                                 : pc.meridian == MERpm ?\"pm\" : \"\");\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: invalid hour %\"PRIdMAX\"%s\\n\"),\n                            pc.hour, mrd);\n              goto fail;\n            }\n          tm.tm_min = pc.minutes;\n          tm.tm_sec = pc.seconds.tv_sec;\n          if (pc.parse_datetime_debug)\n            dbg_printf ((pc.times_seen\n                         ? _(\"using specified time as starting value: '%s'\\n\")\n                         : _(\"using current time as starting value: '%s'\\n\")),\n                        debug_strftime (&tm, dbg_tm, sizeof dbg_tm));\n        }\n      else\n        {\n          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n          pc.seconds.tv_nsec = 0;\n          if (pc.parse_datetime_debug)\n            dbg_printf (\"warning: using midnight as starting time: 00:00:00\\n\");\n        }\n\n      /* Let mktime deduce tm_isdst if we have an absolute timestamp.  */\n      if (pc.dates_seen | pc.days_seen | pc.times_seen)\n        tm.tm_isdst = -1;\n\n      /* But if the input explicitly specifies local time with or without\n         DST, give mktime that information.  */\n      if (pc.local_zones_seen)\n        tm.tm_isdst = pc.local_isdst;\n\n      tm0.tm_sec = tm.tm_sec;\n      tm0.tm_min = tm.tm_min;\n      tm0.tm_hour = tm.tm_hour;\n      tm0.tm_mday = tm.tm_mday;\n      tm0.tm_mon = tm.tm_mon;\n      tm0.tm_year = tm.tm_year;\n      tm0.tm_isdst = tm.tm_isdst;\n\n      Start = mktime_z (tz, &tm);\n\n      if (! mktime_ok (tz, &tm0, &tm, Start))\n        {\n          bool repaired = false;\n          bool time_zone_seen = pc.zones_seen != 0;\n          if (time_zone_seen)\n            {\n              /* Guard against falsely reporting errors near the time_t\n                 boundaries when parsing times in other time zones.  For\n                 example, suppose the input string \"1969-12-31 23:00:00 -0100\",\n                 the current time zone is 8 hours ahead of UTC, and the min\n                 time_t value is 1970-01-01 00:00:00 UTC.  Then the min\n                 localtime value is 1970-01-01 08:00:00, and mktime will\n                 therefore fail on 1969-12-31 23:00:00.  To work around the\n                 problem, set the time zone to 1 hour behind UTC temporarily\n                 by setting TZ=\"XXX1:00\" and try mktime again.  */\n\n              char tz2buf[sizeof \"XXX\" - 1 + TIME_ZONE_BUFSIZE];\n              tz2buf[0] = tz2buf[1] = tz2buf[2] = 'X';\n              time_zone_str (pc.time_zone, &tz2buf[3]);\n              timezone_t tz2 = tzalloc (tz2buf);\n              if (!tz2)\n                {\n                  if (pc.parse_datetime_debug)\n                    dbg_printf (_(\"error: tzalloc (\\\"%s\\\") failed\\n\"), tz2buf);\n                  goto fail;\n                }\n              tm.tm_sec = tm0.tm_sec;\n              tm.tm_min = tm0.tm_min;\n              tm.tm_hour = tm0.tm_hour;\n              tm.tm_mday = tm0.tm_mday;\n              tm.tm_mon = tm0.tm_mon;\n              tm.tm_year = tm0.tm_year;\n              tm.tm_isdst = tm0.tm_isdst;\n              Start = mktime_z (tz2, &tm);\n              repaired = mktime_ok (tz2, &tm0, &tm, Start);\n              tzfree (tz2);\n            }\n\n          if (! repaired)\n            {\n              debug_mktime_not_ok (&tm0, &tm, &pc, time_zone_seen);\n              goto fail;\n            }\n        }\n\n      char dbg_ord[DBGBUFSIZE];\n\n      if (pc.days_seen && ! pc.dates_seen)\n        {\n          intmax_t dayincr;\n          if (INT_MULTIPLY_WRAPV ((pc.day_ordinal\n                                   - (0 < pc.day_ordinal\n                                      && tm.tm_wday != pc.day_number)),\n                                  7, &dayincr)\n              || INT_ADD_WRAPV ((pc.day_number - tm.tm_wday + 7) % 7,\n                                dayincr, &dayincr)\n              || INT_ADD_WRAPV (dayincr, tm.tm_mday, &tm.tm_mday))\n            Start = -1;\n          else\n            {\n              tm.tm_isdst = -1;\n              Start = mktime_z (tz, &tm);\n            }\n\n          if (Start == (time_t) -1)\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: day '%s' \"\n                              \"(day ordinal=%\"PRIdMAX\" number=%d) \"\n                              \"resulted in an invalid date: '%s'\\n\"),\n                            str_days (&pc, dbg_ord, sizeof dbg_ord),\n                            pc.day_ordinal, pc.day_number,\n                            debug_strfdatetime (&tm, &pc, dbg_tm,\n                                                sizeof dbg_tm));\n              goto fail;\n            }\n\n          if (pc.parse_datetime_debug)\n            dbg_printf (_(\"new start date: '%s' is '%s'\\n\"),\n                        str_days (&pc, dbg_ord, sizeof dbg_ord),\n                        debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n\n        }\n\n      if (pc.parse_datetime_debug)\n        {\n          if (!pc.dates_seen && !pc.days_seen)\n            dbg_printf (_(\"using current date as starting value: '%s'\\n\"),\n                        debug_strfdate (&tm, dbg_tm, sizeof dbg_tm));\n\n          if (pc.days_seen && pc.dates_seen)\n            dbg_printf (_(\"warning: day (%s) ignored when explicit dates \"\n                          \"are given\\n\"),\n                        str_days (&pc, dbg_ord, sizeof dbg_ord));\n\n          dbg_printf (_(\"starting date/time: '%s'\\n\"),\n                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n        }\n\n      /* Add relative date.  */\n      if (pc.rel.year | pc.rel.month | pc.rel.day)\n        {\n          if (pc.parse_datetime_debug)\n            {\n              if ((pc.rel.year != 0 || pc.rel.month != 0) && tm.tm_mday != 15)\n                dbg_printf (_(\"warning: when adding relative months/years, \"\n                              \"it is recommended to specify the 15th of the \"\n                              \"months\\n\"));\n\n              if (pc.rel.day != 0 && tm.tm_hour != 12)\n                dbg_printf (_(\"warning: when adding relative days, \"\n                              \"it is recommended to specify noon\\n\"));\n            }\n\n          int year, month, day;\n          if (INT_ADD_WRAPV (tm.tm_year, pc.rel.year, &year)\n              || INT_ADD_WRAPV (tm.tm_mon, pc.rel.month, &month)\n              || INT_ADD_WRAPV (tm.tm_mday, pc.rel.day, &day))\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: %s:%d\\n\"), __FILE__, __LINE__);\n              goto fail;\n            }\n          tm.tm_year = year;\n          tm.tm_mon = month;\n          tm.tm_mday = day;\n          tm.tm_hour = tm0.tm_hour;\n          tm.tm_min = tm0.tm_min;\n          tm.tm_sec = tm0.tm_sec;\n          tm.tm_isdst = tm0.tm_isdst;\n          Start = mktime_z (tz, &tm);\n          if (Start == (time_t) -1)\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: adding relative date resulted \"\n                              \"in an invalid date: '%s'\\n\"),\n                            debug_strfdatetime (&tm, &pc, dbg_tm,\n                                                sizeof dbg_tm));\n              goto fail;\n            }\n\n          if (pc.parse_datetime_debug)\n            {\n              dbg_printf (_(\"after date adjustment \"\n                            \"(%+\"PRIdMAX\" years, %+\"PRIdMAX\" months, \"\n                            \"%+\"PRIdMAX\" days),\\n\"),\n                          pc.rel.year, pc.rel.month, pc.rel.day);\n              dbg_printf (_(\"    new date/time = '%s'\\n\"),\n                          debug_strfdatetime (&tm, &pc, dbg_tm,\n                                              sizeof dbg_tm));\n\n              /* Warn about crossing DST due to time adjustment.\n                 Example: https://bugs.gnu.org/8357\n                 env TZ=Europe/Helsinki \\\n                   date --debug \\\n                        -d 'Mon Mar 28 00:36:07 2011 EEST 1 day ago'\n\n                 This case is different than DST changes due to time adjustment,\n                 i.e., \"1 day ago\" vs \"24 hours ago\" are calculated in different\n                 places.\n\n                 'tm0.tm_isdst' contains the DST of the input date,\n                 'tm.tm_isdst' is the normalized result after calling\n                 mktime (&tm).\n              */\n              if (tm0.tm_isdst != -1 && tm.tm_isdst != tm0.tm_isdst)\n                dbg_printf (_(\"warning: daylight saving time changed after \"\n                              \"date adjustment\\n\"));\n\n              /* Warn if the user did not ask to adjust days but mday changed,\n                 or\n                 user did not ask to adjust months/days but the month changed.\n\n                 Example for first case:\n                 2016-05-31 + 1 month => 2016-06-31 => 2016-07-01.\n                 User asked to adjust month, but the day changed from 31 to 01.\n\n                 Example for second case:\n                 2016-02-29 + 1 year => 2017-02-29 => 2017-03-01.\n                 User asked to adjust year, but the month changed from 02 to 03.\n              */\n              if (pc.rel.day == 0\n                  && (tm.tm_mday != day\n                      || (pc.rel.month == 0 && tm.tm_mon != month)))\n                {\n                  dbg_printf (_(\"warning: month/year adjustment resulted in \"\n                                \"shifted dates:\\n\"));\n                  char tm_year_buf[TM_YEAR_BUFSIZE];\n                  dbg_printf (_(\"     adjusted Y M D: %s %02d %02d\\n\"),\n                              tm_year_str (year, tm_year_buf), month + 1, day);\n                  dbg_printf (_(\"   normalized Y M D: %s %02d %02d\\n\"),\n                              tm_year_str (tm.tm_year, tm_year_buf),\n                              tm.tm_mon + 1, tm.tm_mday);\n                }\n            }\n\n        }\n\n      /* The only \"output\" of this if-block is an updated Start value,\n         so this block must follow others that clobber Start.  */\n      if (pc.zones_seen)\n        {\n          intmax_t delta = pc.time_zone, t1;\n          bool overflow = false;\n#ifdef HAVE_TM_GMTOFF\n          long int utcoff = tm.tm_gmtoff;\n#else\n          time_t t = Start;\n          struct tm gmt;\n          int utcoff = (gmtime_r (&t, &gmt)\n                        ? tm_diff (&tm, &gmt)\n                        : (overflow = true, 0));\n#endif\n          overflow |= INT_SUBTRACT_WRAPV (delta, utcoff, &delta);\n          overflow |= INT_SUBTRACT_WRAPV (Start, delta, &t1);\n          if (overflow || time_overflow (t1))\n            {\n              if (pc.parse_datetime_debug)\n                dbg_printf (_(\"error: timezone %d caused time_t overflow\\n\"),\n                            pc.time_zone);\n              goto fail;\n            }\n          Start = t1;\n        }\n\n      if (pc.parse_datetime_debug)\n        {\n          intmax_t Starti = Start;\n          dbg_printf (_(\"'%s' = %\"PRIdMAX\" epoch-seconds\\n\"),\n                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm),\n                      Starti);\n        }\n\n\n      /* Add relative hours, minutes, and seconds.  On hosts that support\n         leap seconds, ignore the possibility of leap seconds; e.g.,\n         \"+ 10 minutes\" adds 600 seconds, even if one of them is a\n         leap second.  Typically this is not what the user wants, but it's\n         too hard to do it the other way, because the time zone indicator\n         must be applied before relative times, and if mktime is applied\n         again the time zone will be lost.  */\n      {\n        intmax_t orig_ns = pc.seconds.tv_nsec;\n        intmax_t sum_ns = orig_ns + pc.rel.ns;\n        int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n        int d4 = (sum_ns - normalized_ns) / BILLION;\n        intmax_t d1, t1, d2, t2, t3, t4;\n        if (INT_MULTIPLY_WRAPV (pc.rel.hour, 60 * 60, &d1)\n            || INT_ADD_WRAPV (Start, d1, &t1)\n            || INT_MULTIPLY_WRAPV (pc.rel.minutes, 60, &d2)\n            || INT_ADD_WRAPV (t1, d2, &t2)\n            || INT_ADD_WRAPV (t2, pc.rel.seconds, &t3)\n            || INT_ADD_WRAPV (t3, d4, &t4)\n            || time_overflow (t4))\n          {\n            if (pc.parse_datetime_debug)\n              dbg_printf (_(\"error: adding relative time caused an \"\n                            \"overflow\\n\"));\n            goto fail;\n          }\n\n        result->tv_sec = t4;\n        result->tv_nsec = normalized_ns;\n\n        if (pc.parse_datetime_debug\n            && (pc.rel.hour | pc.rel.minutes | pc.rel.seconds | pc.rel.ns))\n          {\n            dbg_printf (_(\"after time adjustment (%+\"PRIdMAX\" hours, \"\n                          \"%+\"PRIdMAX\" minutes, \"\n                          \"%+\"PRIdMAX\" seconds, %+d ns),\\n\"),\n                        pc.rel.hour, pc.rel.minutes, pc.rel.seconds,\n                        pc.rel.ns);\n            dbg_printf (_(\"    new time = %\"PRIdMAX\" epoch-seconds\\n\"), t4);\n\n            /* Warn about crossing DST due to time adjustment.\n               Example: https://bugs.gnu.org/8357\n               env TZ=Europe/Helsinki           \\\n               date --debug                                             \\\n               -d 'Mon Mar 28 00:36:07 2011 EEST 24 hours ago'\n\n               This case is different than DST changes due to days adjustment,\n               i.e., \"1 day ago\" vs \"24 hours ago\" are calculated in different\n               places.\n\n               'tm.tm_isdst' contains the date after date adjustment.  */\n            struct tm lmt;\n            if (tm.tm_isdst != -1 && localtime_rz (tz, &result->tv_sec, &lmt)\n                && tm.tm_isdst != lmt.tm_isdst)\n              dbg_printf (_(\"warning: daylight saving time changed after \"\n                            \"time adjustment\\n\"));\n          }\n      }\n    }\n\n  if (pc.parse_datetime_debug)\n    {\n      /* Special case: using 'date -u' simply set TZ=UTC0 */\n      if (! tzstring)\n        dbg_printf (_(\"timezone: system default\\n\"));\n      else if (STREQ (tzstring, \"UTC0\"))\n        dbg_printf (_(\"timezone: Universal Time\\n\"));\n      else\n        dbg_printf (_(\"timezone: TZ=\\\"%s\\\" environment value\\n\"), tzstring);\n\n      intmax_t sec = result->tv_sec;\n      int nsec = result->tv_nsec;\n      dbg_printf (_(\"final: %\"PRIdMAX\".%09d (epoch-seconds)\\n\"),\n                  sec, nsec);\n\n      struct tm gmt, lmt;\n      bool got_utc = !!gmtime_r (&result->tv_sec, &gmt);\n      if (got_utc)\n        dbg_printf (_(\"final: %s (UTC)\\n\"),\n                    debug_strfdatetime (&gmt, NULL,\n                                        dbg_tm, sizeof dbg_tm));\n      if (localtime_rz (tz, &result->tv_sec, &lmt))\n        {\n#ifdef HAVE_TM_GMTOFF\n          bool got_utcoff = true;\n          long int utcoff = lmt.tm_gmtoff;\n#else\n          bool got_utcoff = got_utc;\n          int utcoff;\n          if (got_utcoff)\n            utcoff = tm_diff (&lmt, &gmt);\n#endif\n          if (got_utcoff)\n            dbg_printf (_(\"final: %s (UTC%s)\\n\"),\n                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm),\n                        time_zone_str (utcoff, time_zone_buf));\n          else\n            dbg_printf (_(\"final: %s (unknown time zone offset)\\n\"),\n                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm));\n        }\n    }\n\n  ok = true;\n\n fail:\n  if (tz != tzdefault)\n    tzfree (tz);\n  free (tz1alloc);\n  return ok;\n}",
      "lines": 656,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        2393,
        0
      ],
      "end_point": [
        2426,
        1
      ],
      "content": "int\nmain (int ac, char **av)\n{\n  char buff[BUFSIZ];\n\n  printf (\"Enter date, or blank line to exit.\\n\\t> \");\n  fflush (stdout);\n\n  buff[BUFSIZ - 1] = '\\0';\n  while (fgets (buff, BUFSIZ - 1, stdin) && buff[0])\n    {\n      struct timespec d;\n      struct tm const *tm;\n      if (! parse_datetime (&d, buff, NULL))\n        printf (\"Bad format - couldn't convert.\\n\");\n      else if (! (tm = localtime (&d.tv_sec)))\n        {\n          intmax_t sec = d.tv_sec;\n          printf (\"localtime (%\"PRIdMAX\") failed\\n\", sec);\n        }\n      else\n        {\n          int ns = d.tv_nsec;\n          char tm_year_buf[TM_YEAR_BUFSIZE];\n          printf (\"%s-%02d-%02d %02d:%02d:%02d.%09d\\n\",\n                  tm_year_str (tm->tm_year, tm_year_buf),\n                  tm->tm_mon + 1, tm->tm_mday,\n                  tm->tm_hour, tm->tm_min, tm->tm_sec, ns);\n        }\n      printf (\"\\t> \");\n      fflush (stdout);\n    }\n  return 0;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/pathmax.h": {},
  "tar/tar-1.30/gnu/pipe-safer.c": {
    "pipe_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\npipe_safer (int fd[2])\n{\n#if HAVE_PIPE\n  if (pipe (fd) == 0)\n    {\n      int i;\n      for (i = 0; i < 2; i++)\n        {\n          fd[i] = fd_safer (fd[i]);\n          if (fd[i] < 0)\n            {\n              int e = errno;\n              close (fd[1 - i]);\n              errno = e;\n              return -1;\n            }\n        }\n\n      return 0;\n    }\n#else\n  errno = ENOSYS;\n#endif\n\n  return -1;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/printf-args.h": {},
  "tar/tar-1.30/gnu/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On Mac OS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/printf-parse.h": {},
  "tar/tar-1.30/gnu/priv-set.c": {
    "priv_set_initialize": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\npriv_set_initialize (void)\n{\n  if (! initialized)\n    {\n      eff_set = priv_allocset ();\n      if (!eff_set)\n        {\n          return -1;\n        }\n      rem_set = priv_allocset ();\n      if (!rem_set)\n        {\n          priv_freeset (eff_set);\n          return -1;\n        }\n      if (getppriv (PRIV_EFFECTIVE, eff_set) != 0)\n        {\n          priv_freeset (eff_set);\n          priv_freeset (rem_set);\n          return -1;\n        }\n      priv_emptyset (rem_set);\n      initialized = true;\n    }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "priv_set_ismember": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\npriv_set_ismember (const char *priv)\n{\n  if (! initialized && priv_set_initialize () != 0)\n    return -1;\n\n  return priv_ismember (eff_set, priv);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "priv_set_remove": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "int\npriv_set_remove (const char *priv)\n{\n  if (! initialized && priv_set_initialize () != 0)\n    return -1;\n\n  if (priv_ismember (eff_set, priv))\n    {\n      /* priv_addset/priv_delset can only fail if priv is invalid, which is\n         checked above by the priv_ismember call.  */\n      priv_delset (eff_set, priv);\n      if (setppriv (PRIV_SET, PRIV_EFFECTIVE, eff_set) != 0)\n        {\n          priv_addset (eff_set, priv);\n          return -1;\n        }\n      priv_addset (rem_set, priv);\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "priv_set_restore": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\npriv_set_restore (const char *priv)\n{\n  if (! initialized && priv_set_initialize () != 0)\n    return -1;\n\n  if (priv_ismember (rem_set, priv))\n    {\n      /* priv_addset/priv_delset can only fail if priv is invalid, which is\n         checked above by the priv_ismember call.  */\n      priv_addset (eff_set, priv);\n      if (setppriv (PRIV_SET, PRIV_EFFECTIVE, eff_set) != 0)\n        {\n          priv_delset (eff_set, priv);\n          return -1;\n        }\n      priv_delset (rem_set, priv);\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/priv-set.h": {
    "priv_set_remove_linkdir": [
      {
        "start_point": [
          35,
          0
        ],
        "end_point": [
          39,
          1
        ],
        "content": "PRIV_SET_INLINE int\npriv_set_remove_linkdir (void)\n{\n  return priv_set_remove (PRIV_SYS_LINKDIR);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "PRIV_SET_INLINE",
          "int",
          "int"
        ]
      },
      {
        "start_point": [
          49,
          0
        ],
        "end_point": [
          53,
          1
        ],
        "content": "PRIV_SET_INLINE int\npriv_set_remove_linkdir (void)\n{\n  return -1;\n}",
        "lines": 5,
        "depth": 5,
        "decorators": [
          "PRIV_SET_INLINE",
          "int",
          "int"
        ]
      }
    ],
    "priv_set_restore_linkdir": [
      {
        "start_point": [
          41,
          0
        ],
        "end_point": [
          45,
          1
        ],
        "content": "PRIV_SET_INLINE int\npriv_set_restore_linkdir (void)\n{\n  return priv_set_restore (PRIV_SYS_LINKDIR);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "PRIV_SET_INLINE",
          "int",
          "int"
        ]
      },
      {
        "start_point": [
          55,
          0
        ],
        "end_point": [
          59,
          1
        ],
        "content": "PRIV_SET_INLINE int\npriv_set_restore_linkdir (void)\n{\n  return -1;\n}",
        "lines": 5,
        "depth": 5,
        "decorators": [
          "PRIV_SET_INLINE",
          "int",
          "int"
        ]
      }
    ]
  },
  "tar/tar-1.30/gnu/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/progname.h": {},
  "tar/tar-1.30/gnu/quote.h": {},
  "tar/tar-1.30/gnu/quotearg.c": {
    "clone_quoting_options": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "struct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  int e = errno;\n  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n                                       sizeof *o);\n  errno = e;\n  return p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct quoting_options",
        "struct",
        "quoting_options",
        "*\nclone_quoting_options (struct quoting_options *o)",
        "*"
      ]
    },
    "get_quoting_style": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "enum quoting_style\nget_quoting_style (struct quoting_options const *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "enum quoting_style",
        "enum",
        "quoting_style"
      ]
    },
    "set_quoting_style": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_char_quoting": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "int\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  unsigned int *p =\n    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_quoting_flags": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\nset_quoting_flags (struct quoting_options *o, int i)\n{\n  int r;\n  if (!o)\n    o = &default_quoting_options;\n  r = o->flags;\n  o->flags = i;\n  return r;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_custom_quoting": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nset_custom_quoting (struct quoting_options *o,\n                    char const *left_quote, char const *right_quote)\n{\n  if (!o)\n    o = &default_quoting_options;\n  o->style = custom_quoting_style;\n  if (!left_quote || !right_quote)\n    abort ();\n  o->left_quote = left_quote;\n  o->right_quote = right_quote;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "quoting_options_from_style": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static struct quoting_options /* NOT PURE!! */\nquoting_options_from_style (enum quoting_style style)\n{\n  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };\n  if (style == custom_quoting_style)\n    abort ();\n  o.style = style;\n  return o;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct quoting_options",
        "struct",
        "quoting_options",
        "/* NOT PURE!! */"
      ]
    },
    "gettext_quote": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static char const *\ngettext_quote (char const *msgid, enum quoting_style s)\n{\n  char const *translation = _(msgid);\n  char const *locale_code;\n\n  if (translation != msgid)\n    return translation;\n\n  /* For UTF-8 and GB-18030, use single quotes U+2018 and U+2019.\n     Here is a list of other locales that include U+2018 and U+2019:\n\n        ISO-8859-7   0xA1                 KOI8-T       0x91\n        CP869        0x8B                 CP874        0x91\n        CP932        0x81 0x65            CP936        0xA1 0xAE\n        CP949        0xA1 0xAE            CP950        0xA1 0xA5\n        CP1250       0x91                 CP1251       0x91\n        CP1252       0x91                 CP1253       0x91\n        CP1254       0x91                 CP1255       0x91\n        CP1256       0x91                 CP1257       0x91\n        EUC-JP       0xA1 0xC6            EUC-KR       0xA1 0xAE\n        EUC-TW       0xA1 0xE4            BIG5         0xA1 0xA5\n        BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE\n        GBK          0xA1 0xAE            Georgian-PS  0x91\n        PT154        0x91\n\n     None of these is still in wide use; using iconv is overkill.  */\n  locale_code = locale_charset ();\n  if (STRCASEEQ (locale_code, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    return msgid[0] == '`' ? \"\\xe2\\x80\\x98\": \"\\xe2\\x80\\x99\";\n  if (STRCASEEQ (locale_code, \"GB18030\", 'G','B','1','8','0','3','0',0,0))\n    return msgid[0] == '`' ? \"\\xa1\\ae\": \"\\xa1\\xaf\";\n\n  return (s == clocale_quoting_style ? \"\\\"\" : \"'\");\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ngettext_quote (char const *msgid, enum quoting_style s)",
        "*"
      ]
    },
    "quotearg_buffer_restyled": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        771,
        1
      ],
      "content": "static size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n                          char const *arg, size_t argsize,\n                          enum quoting_style quoting_style, int flags,\n                          unsigned int const *quote_these_too,\n                          char const *left_quote,\n                          char const *right_quote)\n{\n  size_t i;\n  size_t len = 0;\n  size_t orig_buffersize = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  bool backslash_escapes = false;\n  bool unibyte_locale = MB_CUR_MAX == 1;\n  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n  bool pending_shell_escape_end = false;\n  bool encountered_single_quote = false;\n  bool all_c_and_shell_quote_compat = true;\n\n#define STORE(c) \\\n    do \\\n      { \\\n        if (len < buffersize) \\\n          buffer[len] = (c); \\\n        len++; \\\n      } \\\n    while (0)\n\n#define START_ESC() \\\n    do \\\n      { \\\n        if (elide_outer_quotes) \\\n          goto force_outer_quoting_style; \\\n        escaping = true; \\\n        if (quoting_style == shell_always_quoting_style \\\n            && ! pending_shell_escape_end) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('$'); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = true; \\\n          } \\\n        STORE ('\\\\'); \\\n      } \\\n    while (0)\n\n#define END_ESC() \\\n    do \\\n      { \\\n        if (pending_shell_escape_end && ! escaping) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = false; \\\n          } \\\n      } \\\n    while (0)\n\n process_input:\n\n  switch (quoting_style)\n    {\n    case c_maybe_quoting_style:\n      quoting_style = c_quoting_style;\n      elide_outer_quotes = true;\n      FALLTHROUGH;\n    case c_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\"');\n      backslash_escapes = true;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = true;\n      elide_outer_quotes = false;\n      break;\n\n    case locale_quoting_style:\n    case clocale_quoting_style:\n    case custom_quoting_style:\n      {\n        if (quoting_style != custom_quoting_style)\n          {\n            /* TRANSLATORS:\n               Get translations for open and closing quotation marks.\n               The message catalog should translate \"`\" to a left\n               quotation mark suitable for the locale, and similarly for\n               \"'\".  For example, a French Unicode local should translate\n               these to U+00AB (LEFT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), respectively.\n\n               If the catalog has no translation, we will try to\n               use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and\n               Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the\n               current locale is not Unicode, locale_quoting_style\n               will quote 'like this', and clocale_quoting_style will\n               quote \"like this\".  You should always include translations\n               for \"`\" and \"'\" even if U+2018 and U+2019 are appropriate\n               for your locale.\n\n               If you don't know what to put here, please see\n               <https://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>\n               and use glyphs suitable for your language.  */\n            left_quote = gettext_quote (N_(\"`\"), quoting_style);\n            right_quote = gettext_quote (N_(\"'\"), quoting_style);\n          }\n        if (!elide_outer_quotes)\n          for (quote_string = left_quote; *quote_string; quote_string++)\n            STORE (*quote_string);\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen (quote_string);\n      }\n      break;\n\n    case shell_escape_quoting_style:\n      backslash_escapes = true;\n      FALLTHROUGH;\n    case shell_quoting_style:\n      elide_outer_quotes = true;\n      FALLTHROUGH;\n    case shell_escape_always_quoting_style:\n      if (!elide_outer_quotes)\n        backslash_escapes = true;\n      FALLTHROUGH;\n    case shell_always_quoting_style:\n      quoting_style = shell_always_quoting_style;\n      if (!elide_outer_quotes)\n        STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    case literal_quoting_style:\n      elide_outer_quotes = false;\n      break;\n\n    default:\n      abort ();\n    }\n\n  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n      bool is_right_quote = false;\n      bool escaping = false;\n      bool c_and_shell_quote_compat = false;\n\n      if (backslash_escapes\n          && quoting_style != shell_always_quoting_style\n          && quote_string_len\n          && (i + quote_string_len\n              <= (argsize == SIZE_MAX && 1 < quote_string_len\n                  /* Use strlen only if we must: when argsize is SIZE_MAX,\n                     and when the quote string is more than 1 byte long.\n                     If we do call strlen, save the result.  */\n                  ? (argsize = strlen (arg)) : argsize))\n          && memcmp (arg + i, quote_string, quote_string_len) == 0)\n        {\n          if (elide_outer_quotes)\n            goto force_outer_quoting_style;\n          is_right_quote = true;\n        }\n\n      c = arg[i];\n      switch (c)\n        {\n        case '\\0':\n          if (backslash_escapes)\n            {\n              START_ESC ();\n              /* If quote_string were to begin with digits, we'd need to\n                 test for the end of the arg as well.  However, it's\n                 hard to imagine any locale that would use digits in\n                 quotes, and set_custom_quoting is documented not to\n                 accept them.  Use only a single \\0 with shell-escape\n                 as currently digits are not printed within $'...'  */\n              if (quoting_style != shell_always_quoting_style\n                  && i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n                {\n                  STORE ('0');\n                  STORE ('0');\n                }\n              c = '0';\n              /* We don't have to worry that this last '0' will be\n                 backslash-escaped because, again, quote_string should\n                 not start with it and because quote_these_too is\n                 documented as not accepting it.  */\n            }\n          else if (flags & QA_ELIDE_NULL_BYTES)\n            continue;\n          break;\n\n        case '?':\n          switch (quoting_style)\n            {\n            case shell_always_quoting_style:\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              break;\n\n            case c_quoting_style:\n              if ((flags & QA_SPLIT_TRIGRAPHS)\n                  && i + 2 < argsize && arg[i + 1] == '?')\n                switch (arg[i + 2])\n                  {\n                  case '!': case '\\'':\n                  case '(': case ')': case '-': case '/':\n                  case '<': case '=': case '>':\n                    /* Escape the second '?' in what would otherwise be\n                       a trigraph.  */\n                    if (elide_outer_quotes)\n                      goto force_outer_quoting_style;\n                    c = arg[i + 2];\n                    i += 2;\n                    STORE ('?');\n                    STORE ('\"');\n                    STORE ('\"');\n                    STORE ('?');\n                    break;\n\n                  default:\n                    break;\n                  }\n              break;\n\n            default:\n              break;\n            }\n          break;\n\n        case '\\a': esc = 'a'; goto c_escape;\n        case '\\b': esc = 'b'; goto c_escape;\n        case '\\f': esc = 'f'; goto c_escape;\n        case '\\n': esc = 'n'; goto c_and_shell_escape;\n        case '\\r': esc = 'r'; goto c_and_shell_escape;\n        case '\\t': esc = 't'; goto c_and_shell_escape;\n        case '\\v': esc = 'v'; goto c_escape;\n        case '\\\\': esc = c;\n          /* Never need to escape '\\' in shell case.  */\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              goto store_c;\n            }\n\n          /* No need to escape the escape if we are trying to elide\n             outer quotes and nothing else is problematic.  */\n          if (backslash_escapes && elide_outer_quotes && quote_string_len)\n            goto store_c;\n\n        c_and_shell_escape:\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          /* fall through */\n        c_escape:\n          if (backslash_escapes)\n            {\n              c = esc;\n              goto store_escape;\n            }\n          break;\n\n        case '{': case '}': /* sometimes special if isolated */\n          if (! (argsize == SIZE_MAX ? arg[1] == '\\0' : argsize == 1))\n            break;\n          FALLTHROUGH;\n        case '#': case '~':\n          if (i != 0)\n            break;\n          FALLTHROUGH;\n        case ' ':\n          c_and_shell_quote_compat = true;\n          FALLTHROUGH;\n        case '!': /* special in bash */\n        case '\"': case '$': case '&':\n        case '(': case ')': case '*': case ';':\n        case '<':\n        case '=': /* sometimes special in 0th or (with \"set -k\") later args */\n        case '>': case '[':\n        case '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */\n        case '`': case '|':\n          /* A shell special character.  In theory, '$' and '`' could\n             be the first bytes of multibyte characters, which means\n             we should check them with mbrtowc, but in practice this\n             doesn't happen so it's not worth worrying about.  */\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          break;\n\n        case '\\'':\n          encountered_single_quote = true;\n          c_and_shell_quote_compat = true;\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n\n              if (buffersize && ! orig_buffersize)\n                {\n                  /* Just scan string to see if supports a more concise\n                     representation, rather than writing a longer string\n                     but returning the length of the more concise form.  */\n                  orig_buffersize = buffersize;\n                  buffersize = 0;\n                }\n\n              STORE ('\\'');\n              STORE ('\\\\');\n              STORE ('\\'');\n              pending_shell_escape_end = false;\n            }\n          break;\n\n        case '%': case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': case ':':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n        case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n        case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n          /* These characters don't cause problems, no matter what the\n             quoting style is.  They cannot start multibyte sequences.\n             A digit or a special letter would cause trouble if it\n             appeared at the beginning of quote_string because we'd then\n             escape by prepending a backslash.  However, it's hard to\n             imagine any locale that would use digits or letters as\n             quotes, and set_custom_quoting is documented not to accept\n             them.  Also, a digit or a special letter would cause\n             trouble if it appeared in quote_these_too, but that's also\n             documented as not accepting them.  */\n          c_and_shell_quote_compat = true;\n          break;\n\n        default:\n          /* If we have a multibyte sequence, copy it until we reach\n             its end, find an error, or come back to the initial shift\n             state.  For C-like styles, if the sequence has\n             unprintable characters, escape the whole sequence, since\n             we can't easily escape single characters within it.  */\n          {\n            /* Length of multibyte sequence found so far.  */\n            size_t m;\n\n            bool printable;\n\n            if (unibyte_locale)\n              {\n                m = 1;\n                printable = isprint (c) != 0;\n              }\n            else\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n\n                m = 0;\n                printable = true;\n                if (argsize == SIZE_MAX)\n                  argsize = strlen (arg);\n\n                do\n                  {\n                    wchar_t w;\n                    size_t bytes = mbrtowc (&w, &arg[i + m],\n                                            argsize - (i + m), &mbstate);\n                    if (bytes == 0)\n                      break;\n                    else if (bytes == (size_t) -1)\n                      {\n                        printable = false;\n                        break;\n                      }\n                    else if (bytes == (size_t) -2)\n                      {\n                        printable = false;\n                        while (i + m < argsize && arg[i + m])\n                          m++;\n                        break;\n                      }\n                    else\n                      {\n                        /* Work around a bug with older shells that \"see\" a '\\'\n                           that is really the 2nd byte of a multibyte character.\n                           In practice the problem is limited to ASCII\n                           chars >= '@' that are shell special chars.  */\n                        if ('[' == 0x5b && elide_outer_quotes\n                            && quoting_style == shell_always_quoting_style)\n                          {\n                            size_t j;\n                            for (j = 1; j < bytes; j++)\n                              switch (arg[i + m + j])\n                                {\n                                case '[': case '\\\\': case '^':\n                                case '`': case '|':\n                                  goto force_outer_quoting_style;\n\n                                default:\n                                  break;\n                                }\n                          }\n\n                        if (! iswprint (w))\n                          printable = false;\n                        m += bytes;\n                      }\n                  }\n                while (! mbsinit (&mbstate));\n              }\n\n            c_and_shell_quote_compat = printable;\n\n            if (1 < m || (backslash_escapes && ! printable))\n              {\n                /* Output a multibyte sequence, or an escaped\n                   unprintable unibyte character.  */\n                size_t ilim = i + m;\n\n                for (;;)\n                  {\n                    if (backslash_escapes && ! printable)\n                      {\n                        START_ESC ();\n                        STORE ('0' + (c >> 6));\n                        STORE ('0' + ((c >> 3) & 7));\n                        c = '0' + (c & 7);\n                      }\n                    else if (is_right_quote)\n                      {\n                        STORE ('\\\\');\n                        is_right_quote = false;\n                      }\n                    if (ilim <= i + 1)\n                      break;\n                    END_ESC ();\n                    STORE (c);\n                    c = arg[++i];\n                  }\n\n                goto store_c;\n              }\n          }\n        }\n\n      if (! (((backslash_escapes && quoting_style != shell_always_quoting_style)\n              || elide_outer_quotes)\n             && quote_these_too\n             && quote_these_too[c / INT_BITS] >> (c % INT_BITS) & 1)\n          && !is_right_quote)\n        goto store_c;\n\n    store_escape:\n      START_ESC ();\n\n    store_c:\n      END_ESC ();\n      STORE (c);\n\n      if (! c_and_shell_quote_compat)\n        all_c_and_shell_quote_compat = false;\n    }\n\n  if (len == 0 && quoting_style == shell_always_quoting_style\n      && elide_outer_quotes)\n    goto force_outer_quoting_style;\n\n  /* Single shell quotes (') are commonly enough used as an apostrophe,\n     that we attempt to minimize the quoting in this case.  Note it\u00ca\u00bcs\n     better to use the apostrophe modifier \"\\u02BC\" if possible, as that\n     renders better and works with the word match regex \\W+ etc.  */\n  if (quoting_style == shell_always_quoting_style && ! elide_outer_quotes\n      && encountered_single_quote)\n    {\n      if (all_c_and_shell_quote_compat)\n        return quotearg_buffer_restyled (buffer, orig_buffersize, arg, argsize,\n                                         c_quoting_style,\n                                         flags, quote_these_too,\n                                         left_quote, right_quote);\n      else if (! buffersize && orig_buffersize)\n        {\n          /* Disable read-only scan, and reprocess to write quoted string.  */\n          buffersize = orig_buffersize;\n          len = 0;\n          goto process_input;\n        }\n    }\n\n  if (quote_string && !elide_outer_quotes)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n force_outer_quoting_style:\n  /* Don't reuse quote_these_too, since the addition of outer quotes\n     sufficiently quotes the specified characters.  */\n  if (quoting_style == shell_always_quoting_style && backslash_escapes)\n    quoting_style = shell_escape_always_quoting_style;\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                   quoting_style,\n                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n                                   left_quote, right_quote);\n}",
      "lines": 518,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "quotearg_buffer": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "size_t\nquotearg_buffer (char *buffer, size_t buffersize,\n                 char const *arg, size_t argsize,\n                 struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                       p->style, p->flags, p->quote_these_too,\n                                       p->left_quote, p->right_quote);\n  errno = e;\n  return r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "quotearg_alloc": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "char *\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)\n{\n  return quotearg_alloc_mem (arg, argsize, NULL, o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_alloc_mem": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "char *\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  /* Elide embedded null bytes if we can't return a size.  */\n  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n                                             flags, p->quote_these_too,\n                                             p->left_quote,\n                                             p->right_quote) + 1;\n  char *buf = xcharalloc (bufsize);\n  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n                            p->quote_these_too,\n                            p->left_quote, p->right_quote);\n  errno = e;\n  if (size)\n    *size = bufsize - 1;\n  return buf;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "char",
        "*\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_free": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "void\nquotearg_free (void)\n{\n  struct slotvec *sv = slotvec;\n  int i;\n  for (i = 1; i < nslots; i++)\n    free (sv[i].val);\n  if (sv[0].val != slot0)\n    {\n      free (sv[0].val);\n      slotvec0.size = sizeof slot0;\n      slotvec0.val = slot0;\n    }\n  if (sv != &slotvec0)\n    {\n      free (sv);\n      slotvec = &slotvec0;\n    }\n  nslots = 1;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quotearg_n_options": {
      "start_point": [
        875,
        0
      ],
      "end_point": [
        927,
        1
      ],
      "content": "static char *\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)\n{\n  int e = errno;\n\n  struct slotvec *sv = slotvec;\n\n  if (n < 0)\n    abort ();\n\n  if (nslots <= n)\n    {\n      bool preallocated = (sv == &slotvec0);\n      int nmax = MIN (INT_MAX, MIN (PTRDIFF_MAX, SIZE_MAX) / sizeof *sv) - 1;\n\n      if (nmax < n)\n        xalloc_die ();\n\n      slotvec = sv = xrealloc (preallocated ? NULL : sv, (n + 1) * sizeof *sv);\n      if (preallocated)\n        *sv = slotvec0;\n      memset (sv + nslots, 0, (n + 1 - nslots) * sizeof *sv);\n      nslots = n + 1;\n    }\n\n  {\n    size_t size = sv[n].size;\n    char *val = sv[n].val;\n    /* Elide embedded null bytes since we don't return a size.  */\n    int flags = options->flags | QA_ELIDE_NULL_BYTES;\n    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n                                             options->style, flags,\n                                             options->quote_these_too,\n                                             options->left_quote,\n                                             options->right_quote);\n\n    if (size <= qsize)\n      {\n        sv[n].size = size = qsize + 1;\n        if (val != slot0)\n          free (val);\n        sv[n].val = val = xcharalloc (size);\n        quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n                                  flags, options->quote_these_too,\n                                  options->left_quote,\n                                  options->right_quote);\n      }\n\n    errno = e;\n    return val;\n  }\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)",
        "*"
      ]
    },
    "quotearg_n": {
      "start_point": [
        929,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "char *\nquotearg_n (int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n (int n, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_mem": {
      "start_point": [
        935,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "char *\nquotearg_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "char *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg (char const *arg)",
        "*"
      ]
    },
    "quotearg_mem": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        951,
        1
      ],
      "content": "char *\nquotearg_mem (char const *arg, size_t argsize)\n{\n  return quotearg_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style": {
      "start_point": [
        953,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "char *\nquotearg_n_style (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, SIZE_MAX, &o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_style_mem": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        966,
        1
      ],
      "content": "char *\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_style": {
      "start_point": [
        968,
        0
      ],
      "end_point": [
        972,
        1
      ],
      "content": "char *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style (enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_style_mem": {
      "start_point": [
        974,
        0
      ],
      "end_point": [
        978,
        1
      ],
      "content": "char *\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n{\n  return quotearg_n_style_mem (0, s, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_char_mem": {
      "start_point": [
        980,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "char *\nquotearg_char_mem (char const *arg, size_t argsize, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, argsize, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char_mem (char const *arg, size_t argsize, char ch)",
        "*"
      ]
    },
    "quotearg_char": {
      "start_point": [
        989,
        0
      ],
      "end_point": [
        993,
        1
      ],
      "content": "char *\nquotearg_char (char const *arg, char ch)\n{\n  return quotearg_char_mem (arg, SIZE_MAX, ch);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char (char const *arg, char ch)",
        "*"
      ]
    },
    "quotearg_colon": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "char *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon (char const *arg)",
        "*"
      ]
    },
    "quotearg_colon_mem": {
      "start_point": [
        1001,
        0
      ],
      "end_point": [
        1005,
        1
      ],
      "content": "char *\nquotearg_colon_mem (char const *arg, size_t argsize)\n{\n  return quotearg_char_mem (arg, argsize, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style_colon": {
      "start_point": [
        1007,
        0
      ],
      "end_point": [
        1014,
        1
      ],
      "content": "char *\nquotearg_n_style_colon (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options options;\n  options = quoting_options_from_style (s);\n  set_char_quoting (&options, ':', 1);\n  return quotearg_n_options (n, arg, SIZE_MAX, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_colon (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom": {
      "start_point": [
        1016,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "char *\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)\n{\n  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n                                SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom_mem": {
      "start_point": [
        1024,
        0
      ],
      "end_point": [
        1032,
        1
      ],
      "content": "char *\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)\n{\n  struct quoting_options o = default_quoting_options;\n  set_custom_quoting (&o, left_quote, right_quote);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_custom": {
      "start_point": [
        1034,
        0
      ],
      "end_point": [
        1039,
        1
      ],
      "content": "char *\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)\n{\n  return quotearg_n_custom (0, left_quote, right_quote, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)",
        "*"
      ]
    },
    "quotearg_custom_mem": {
      "start_point": [
        1041,
        0
      ],
      "end_point": [
        1047,
        1
      ],
      "content": "char *\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)\n{\n  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n                                argsize);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n_mem": {
      "start_point": [
        1059,
        0
      ],
      "end_point": [
        1063,
        1
      ],
      "content": "char const *\nquote_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_mem": {
      "start_point": [
        1065,
        0
      ],
      "end_point": [
        1069,
        1
      ],
      "content": "char const *\nquote_mem (char const *arg, size_t argsize)\n{\n  return quote_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n": {
      "start_point": [
        1071,
        0
      ],
      "end_point": [
        1075,
        1
      ],
      "content": "char const *\nquote_n (int n, char const *arg)\n{\n  return quote_n_mem (n, arg, SIZE_MAX);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n (int n, char const *arg)",
        "*"
      ]
    },
    "quote": {
      "start_point": [
        1077,
        0
      ],
      "end_point": [
        1081,
        1
      ],
      "content": "char const *\nquote (char const *arg)\n{\n  return quote_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote (char const *arg)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/quotearg.h": {},
  "tar/tar-1.30/gnu/raise.c": {
    "raise_nothrow": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        5
      ],
      "content": "static int\nraise_nothrow (int sig)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = raise (sig);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_raise": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\nrpl_raise (int sig)\n{\n#if GNULIB_defined_signal_blocking && GNULIB_defined_SIGPIPE\n  if (sig == SIGPIPE)\n    return _gl_raise_SIGPIPE ();\n#endif\n\n#if HAVE_RAISE\n  return raise_nothrow (sig);\n#else\n  return kill (getpid (), sig);\n#endif\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/rawmemchr.c": {
    "rawmemchr": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void *\nrawmemchr (const void *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 is zero is equivalent\n     to testing whether tmp is nonzero.\n\n     This test can read beyond the end of a string, depending on where\n     C_IN is encountered.  However, this is considered safe since the\n     initialization phase ensured that the read will be aligned,\n     therefore, the read will not cross page boundaries and will not\n     cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == c.  On little-endian machines, we\n     could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr != c)\n    char_ptr++;\n  return (void *) char_ptr;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\nrawmemchr (const void *s, int c_in)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/read.c": {
    "read_nothrow": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        50,
        5
      ],
      "content": "static ssize_t\nread_nothrow (int fd, void *buf, size_t count)\n{\n  ssize_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = read (fd, buf, count);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "rpl_read": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "ssize_t\nrpl_read (int fd, void *buf, size_t count)\n{\n  ssize_t ret = read_nothrow (fd, buf, count);\n\n# if GNULIB_NONBLOCKING\n  if (ret < 0\n      && GetLastError () == ERROR_NO_DATA)\n    {\n      HANDLE h = (HANDLE) _get_osfhandle (fd);\n      if (GetFileType (h) == FILE_TYPE_PIPE)\n        {\n          /* h is a pipe or socket.  */\n          DWORD state;\n          if (GetNamedPipeHandleState (h, &state, NULL, NULL, NULL, NULL, 0)\n              && (state & PIPE_NOWAIT) != 0)\n            /* h is a pipe in non-blocking mode.\n               Change errno from EINVAL to EAGAIN.  */\n            errno = EAGAIN;\n        }\n    }\n# endif\n\n  return ret;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/readdir.c": {
    "readdir": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "struct dirent *\nreaddir (DIR *dirp)\n{\n  char type;\n  struct dirent *result;\n\n  /* There is no need to add code to produce entries for \".\" and \"..\".\n     According to the POSIX:2008 section \"4.12 Pathname Resolution\"\n     <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html>\n     \".\" and \"..\" are syntactic entities.\n     POSIX also says:\n       \"If entries for dot or dot-dot exist, one entry shall be returned\n        for dot and one entry shall be returned for dot-dot; otherwise,\n        they shall not be returned.\"  */\n\n  switch (dirp->status)\n    {\n    case -2:\n      /* End of directory already reached.  */\n      return NULL;\n    case -1:\n      break;\n    case 0:\n      if (!FindNextFile (dirp->current, &dirp->entry))\n        {\n          switch (GetLastError ())\n            {\n            case ERROR_NO_MORE_FILES:\n              dirp->status = -2;\n              return NULL;\n            default:\n              errno = EIO;\n              return NULL;\n            }\n        }\n      break;\n    default:\n      errno = dirp->status;\n      return NULL;\n    }\n\n  dirp->status = 0;\n\n  if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n    type = DT_DIR;\n  else if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)\n    type = DT_LNK;\n  else if ((dirp->entry.dwFileAttributes\n            & ~(FILE_ATTRIBUTE_READONLY\n                | FILE_ATTRIBUTE_HIDDEN\n                | FILE_ATTRIBUTE_SYSTEM\n                | FILE_ATTRIBUTE_ARCHIVE\n                | FILE_ATTRIBUTE_NORMAL\n                | FILE_ATTRIBUTE_TEMPORARY\n                | FILE_ATTRIBUTE_SPARSE_FILE\n                | FILE_ATTRIBUTE_COMPRESSED\n                | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED\n                | FILE_ATTRIBUTE_ENCRYPTED)) == 0)\n    /* Devices like COM1, LPT1, NUL would also have the attributes 0x20 but\n       they cannot occur here.  */\n    type = DT_REG;\n  else\n    type = DT_UNKNOWN;\n\n  /* Reuse the memory of dirp->entry for the result.  */\n  result =\n    (struct dirent *)\n    ((char *) dirp->entry.cFileName - offsetof (struct dirent, d_name[0]));\n  result->d_type = type;\n\n  return result;\n}",
      "lines": 72,
      "depth": 21,
      "decorators": [
        "struct dirent",
        "struct",
        "dirent",
        "*\nreaddir (DIR *dirp)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/readlink.c": {
    "readlink": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "ssize_t\nreadlink (const char *name, char *buf _GL_UNUSED,\n          size_t bufsize _GL_UNUSED)\n{\n  struct stat statbuf;\n\n  /* In general we should use lstat() here, not stat().  But on platforms\n     without symbolic links, lstat() - if it exists - would be equivalent to\n     stat(), therefore we can use stat().  This saves us a configure check.  */\n  if (stat (name, &statbuf) >= 0)\n    errno = EINVAL;\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "ssize_t"
      ]
    },
    "rpl_readlink": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "ssize_t\nrpl_readlink (const char *name, char *buf, size_t bufsize)\n{\n# if READLINK_TRAILING_SLASH_BUG\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      /* Even if name without the slash is a symlink to a directory,\n         both lstat() and stat() must resolve the trailing slash to\n         the directory rather than the symlink.  We can therefore\n         safely use stat() to distinguish between EINVAL and\n         ENOTDIR/ENOENT, avoiding extra overhead of rpl_lstat().  */\n      struct stat st;\n      if (stat (name, &st) == 0)\n        errno = EINVAL;\n      return -1;\n    }\n# endif /* READLINK_TRAILING_SLASH_BUG */\n  return readlink (name, buf, bufsize);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/readlinkat.c": {
    "rpl_readlinkat": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "ssize_t\nrpl_readlinkat (int fd, char const *file, char *buf, size_t len)\n{\n# if READLINK_TRAILING_SLASH_BUG\n  size_t file_len = strlen (file);\n  if (file_len && file[file_len - 1] == '/')\n    {\n      /* Even if FILE without the slash is a symlink to a directory,\n         both lstat() and stat() must resolve the trailing slash to\n         the directory rather than the symlink.  We can therefore\n         safely use stat() to distinguish between EINVAL and\n         ENOTDIR/ENOENT, avoiding extra overhead of rpl_lstat().  */\n      struct stat st;\n      if (stat (file, &st) == 0)\n        errno = EINVAL;\n      return -1;\n    }\n# endif /* READLINK_TRAILING_SLASH_BUG */\n  return readlinkat (fd, file, buf, len);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/regcomp.c": {
    "re_compile_pattern": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "const char *\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)\n{\n  reg_errcode_t ret;\n\n  /* And GNU code determines whether or not to get register information\n     by passing null for the REGS argument to re_match, etc., not by\n     setting no_sub, unless RE_NO_SUB is set.  */\n  bufp->no_sub = !!(re_syntax_options & RE_NO_SUB);\n\n  /* Match anchors at newline.  */\n  bufp->newline_anchor = 1;\n\n  ret = re_compile_internal (bufp, pattern, length, re_syntax_options);\n\n  if (!ret)\n    return NULL;\n  return gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)",
        "*"
      ]
    },
    "re_set_syntax": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "reg_syntax_t\nre_set_syntax (reg_syntax_t syntax)\n{\n  reg_syntax_t ret = re_syntax_options;\n\n  re_syntax_options = syntax;\n  return ret;\n}",
      "lines": 8,
      "depth": 5,
      "decorators": [
        "reg_syntax_t"
      ]
    },
    "re_compile_fastmap": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "int\nre_compile_fastmap (struct re_pattern_buffer *bufp)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  char *fastmap = bufp->fastmap;\n\n  memset (fastmap, '\\0', sizeof (char) * SBC_MAX);\n  re_compile_fastmap_iter (bufp, dfa->init_state, fastmap);\n  if (dfa->init_state != dfa->init_state_word)\n    re_compile_fastmap_iter (bufp, dfa->init_state_word, fastmap);\n  if (dfa->init_state != dfa->init_state_nl)\n    re_compile_fastmap_iter (bufp, dfa->init_state_nl, fastmap);\n  if (dfa->init_state != dfa->init_state_begbuf)\n    re_compile_fastmap_iter (bufp, dfa->init_state_begbuf, fastmap);\n  bufp->fastmap_accurate = 1;\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "re_set_fastmap": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static inline void\n__attribute__ ((always_inline))\nre_set_fastmap (char *fastmap, bool icase, int ch)\n{\n  fastmap[ch] = 1;\n  if (icase)\n    fastmap[tolower (ch)] = 1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "re_compile_fastmap_iter": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "static void\nre_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,\n\t\t\t char *fastmap)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  Idx node_cnt;\n  bool icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));\n  for (node_cnt = 0; node_cnt < init_state->nodes.nelem; ++node_cnt)\n    {\n      Idx node = init_state->nodes.elems[node_cnt];\n      re_token_type_t type = dfa->nodes[node].type;\n\n      if (type == CHARACTER)\n\t{\n\t  re_set_fastmap (fastmap, icase, dfa->nodes[node].opr.c);\n#ifdef RE_ENABLE_I18N\n\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t    {\n\t      unsigned char buf[MB_LEN_MAX];\n\t      unsigned char *p;\n\t      wchar_t wc;\n\t      mbstate_t state;\n\n\t      p = buf;\n\t      *p++ = dfa->nodes[node].opr.c;\n\t      while (++node < dfa->nodes_len\n\t\t     &&\tdfa->nodes[node].type == CHARACTER\n\t\t     && dfa->nodes[node].mb_partial)\n\t\t*p++ = dfa->nodes[node].opr.c;\n\t      memset (&state, '\\0', sizeof (state));\n\t      if (__mbrtowc (&wc, (const char *) buf, p - buf,\n\t\t\t     &state) == p - buf\n\t\t  && (__wcrtomb ((char *) buf, __towlower (wc), &state)\n\t\t      != (size_t) -1))\n\t\tre_set_fastmap (fastmap, false, buf[0]);\n\t    }\n#endif\n\t}\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  int i, ch;\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    {\n\t      int j;\n\t      bitset_word_t w = dfa->nodes[node].opr.sbcset[i];\n\t      for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t\tif (w & ((bitset_word_t) 1 << j))\n\t\t  re_set_fastmap (fastmap, icase, ch);\n\t    }\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == COMPLEX_BRACKET)\n\t{\n\t  re_charset_t *cset = dfa->nodes[node].opr.mbcset;\n\t  Idx i;\n\n# ifdef _LIBC\n\t  /* See if we have to try all bytes which start multiple collation\n\t     elements.\n\t     e.g. In da_DK, we want to catch 'a' since \"aa\" is a valid\n\t\t  collation element, and don't catch 'b' since 'b' is\n\t\t  the only collation element which starts from 'b' (and\n\t\t  it is caught by SIMPLE_BRACKET).  */\n\t      if (_NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES) != 0\n\t\t  && (cset->ncoll_syms || cset->nranges))\n\t\t{\n\t\t  const int32_t *table = (const int32_t *)\n\t\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t\t  for (i = 0; i < SBC_MAX; ++i)\n\t\t    if (table[i] < 0)\n\t\t      re_set_fastmap (fastmap, icase, i);\n\t\t}\n# endif /* _LIBC */\n\n\t  /* See if we have to start the match at all multibyte characters,\n\t     i.e. where we would not find an invalid sequence.  This only\n\t     applies to multibyte character sets; for single byte character\n\t     sets, the SIMPLE_BRACKET again suffices.  */\n\t  if (dfa->mb_cur_max > 1\n\t      && (cset->nchar_classes || cset->non_match || cset->nranges\n# ifdef _LIBC\n\t\t  || cset->nequiv_classes\n# endif /* _LIBC */\n\t\t ))\n\t    {\n\t      unsigned char c = 0;\n\t      do\n\t\t{\n\t\t  mbstate_t mbs;\n\t\t  memset (&mbs, 0, sizeof (mbs));\n\t\t  if (__mbrtowc (NULL, (char *) &c, 1, &mbs) == (size_t) -2)\n\t\t    re_set_fastmap (fastmap, false, (int) c);\n\t\t}\n\t      while (++c != 0);\n\t    }\n\n\t  else\n\t    {\n\t      /* ... Else catch all bytes which can start the mbchars.  */\n\t      for (i = 0; i < cset->nmbchars; ++i)\n\t\t{\n\t\t  char buf[256];\n\t\t  mbstate_t state;\n\t\t  memset (&state, '\\0', sizeof (state));\n\t\t  if (__wcrtomb (buf, cset->mbchars[i], &state) != (size_t) -1)\n\t\t    re_set_fastmap (fastmap, icase, *(unsigned char *) buf);\n\t\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t\t    {\n\t\t      if (__wcrtomb (buf, __towlower (cset->mbchars[i]), &state)\n\t\t\t  != (size_t) -1)\n\t\t\tre_set_fastmap (fastmap, false, *(unsigned char *) buf);\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      else if (type == OP_PERIOD\n#ifdef RE_ENABLE_I18N\n\t       || type == OP_UTF8_PERIOD\n#endif /* RE_ENABLE_I18N */\n\t       || type == END_OF_RE)\n\t{\n\t  memset (fastmap, '\\1', sizeof (char) * SBC_MAX);\n\t  if (type == END_OF_RE)\n\t    bufp->can_be_null = 1;\n\t  return;\n\t}\n    }\n}",
      "lines": 129,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regcomp": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "int\nregcomp (regex_t *_Restrict_ preg, const char *_Restrict_ pattern, int cflags)\n{\n  reg_errcode_t ret;\n  reg_syntax_t syntax = ((cflags & REG_EXTENDED) ? RE_SYNTAX_POSIX_EXTENDED\n\t\t\t : RE_SYNTAX_POSIX_BASIC);\n\n  preg->buffer = NULL;\n  preg->allocated = 0;\n  preg->used = 0;\n\n  /* Try to allocate space for the fastmap.  */\n  preg->fastmap = re_malloc (char, SBC_MAX);\n  if (BE (preg->fastmap == NULL, 0))\n    return REG_ESPACE;\n\n  syntax |= (cflags & REG_ICASE) ? RE_ICASE : 0;\n\n  /* If REG_NEWLINE is set, newlines are treated differently.  */\n  if (cflags & REG_NEWLINE)\n    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */\n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n      /* It also changes the matching behavior.  */\n      preg->newline_anchor = 1;\n    }\n  else\n    preg->newline_anchor = 0;\n  preg->no_sub = !!(cflags & REG_NOSUB);\n  preg->translate = NULL;\n\n  ret = re_compile_internal (preg, pattern, strlen (pattern), syntax);\n\n  /* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */\n  if (ret == REG_ERPAREN)\n    ret = REG_EPAREN;\n\n  /* We have already checked preg->fastmap != NULL.  */\n  if (BE (ret == REG_NOERROR, 1))\n    /* Compute the fastmap now, since regexec cannot modify the pattern\n       buffer.  This function never fails in this implementation.  */\n    (void) re_compile_fastmap (preg);\n  else\n    {\n      /* Some error occurred while compiling the expression.  */\n      re_free (preg->fastmap);\n      preg->fastmap = NULL;\n    }\n\n  return (int) ret;\n}",
      "lines": 52,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "regerror": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "size_t\nregerror (int errcode, const regex_t *_Restrict_ preg, char *_Restrict_ errbuf,\n\t  size_t errbuf_size)\n{\n  const char *msg;\n  size_t msg_size;\n\n  if (BE (errcode < 0\n\t  || errcode >= (int) (sizeof (__re_error_msgid_idx)\n\t\t\t       / sizeof (__re_error_msgid_idx[0])), 0))\n    /* Only error codes returned by the rest of the code should be passed\n       to this routine.  If we are given anything else, or if other regex\n       code generates an invalid error code, then the program has a bug.\n       Dump core so we can fix it.  */\n    abort ();\n\n  msg = gettext (__re_error_msgid + __re_error_msgid_idx[errcode]);\n\n  msg_size = strlen (msg) + 1; /* Includes the null.  */\n\n  if (BE (errbuf_size != 0, 1))\n    {\n      size_t cpy_size = msg_size;\n      if (BE (msg_size > errbuf_size, 0))\n\t{\n\t  cpy_size = errbuf_size - 1;\n\t  errbuf[cpy_size] = '\\0';\n\t}\n      memcpy (errbuf, msg, cpy_size);\n    }\n\n  return msg_size;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "free_dfa_content": {
      "start_point": [
        591,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "static void\nfree_dfa_content (re_dfa_t *dfa)\n{\n  Idx i, j;\n\n  if (dfa->nodes)\n    for (i = 0; i < dfa->nodes_len; ++i)\n      free_token (dfa->nodes + i);\n  re_free (dfa->nexts);\n  for (i = 0; i < dfa->nodes_len; ++i)\n    {\n      if (dfa->eclosures != NULL)\n\tre_node_set_free (dfa->eclosures + i);\n      if (dfa->inveclosures != NULL)\n\tre_node_set_free (dfa->inveclosures + i);\n      if (dfa->edests != NULL)\n\tre_node_set_free (dfa->edests + i);\n    }\n  re_free (dfa->edests);\n  re_free (dfa->eclosures);\n  re_free (dfa->inveclosures);\n  re_free (dfa->nodes);\n\n  if (dfa->state_table)\n    for (i = 0; i <= dfa->state_hash_mask; ++i)\n      {\n\tstruct re_state_table_entry *entry = dfa->state_table + i;\n\tfor (j = 0; j < entry->num; ++j)\n\t  {\n\t    re_dfastate_t *state = entry->array[j];\n\t    free_state (state);\n\t  }\n\tre_free (entry->array);\n      }\n  re_free (dfa->state_table);\n#ifdef RE_ENABLE_I18N\n  if (dfa->sb_char != utf8_sb_map)\n    re_free (dfa->sb_char);\n#endif\n  re_free (dfa->subexp_map);\n#ifdef DEBUG\n  re_free (dfa->re_str);\n#endif\n\n  re_free (dfa);\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regfree": {
      "start_point": [
        641,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "void\nregfree (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  if (BE (dfa != NULL, 1))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n    }\n  preg->buffer = NULL;\n  preg->allocated = 0;\n\n  re_free (preg->fastmap);\n  preg->fastmap = NULL;\n\n  re_free (preg->translate);\n  preg->translate = NULL;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "re_comp": {
      "start_point": [
        676,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "weak_function\n# endif\nre_comp (const char *s)\n{\n  reg_errcode_t ret;\n  char *fastmap;\n\n  if (!s)\n    {\n      if (!re_comp_buf.buffer)\n\treturn gettext (\"No previous regular expression\");\n      return 0;\n    }\n\n  if (re_comp_buf.buffer)\n    {\n      fastmap = re_comp_buf.fastmap;\n      re_comp_buf.fastmap = NULL;\n      __regfree (&re_comp_buf);\n      memset (&re_comp_buf, '\\0', sizeof (re_comp_buf));\n      re_comp_buf.fastmap = fastmap;\n    }\n\n  if (re_comp_buf.fastmap == NULL)\n    {\n      re_comp_buf.fastmap = (char *) malloc (SBC_MAX);\n      if (re_comp_buf.fastmap == NULL)\n\treturn (char *) gettext (__re_error_msgid\n\t\t\t\t + __re_error_msgid_idx[(int) REG_ESPACE]);\n    }\n\n  /* Since 're_exec' always passes NULL for the 'regs' argument, we\n     don't need to initialize the pattern buffer fields which affect it.  */\n\n  /* Match anchors at newlines.  */\n  re_comp_buf.newline_anchor = 1;\n\n  ret = re_compile_internal (&re_comp_buf, s, strlen (s), re_syntax_options);\n\n  if (!ret)\n    return NULL;\n\n  /* Yes, we're discarding 'const' here if !HAVE_LIBINTL.  */\n  return (char *) gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "weak_function",
        "# endif",
        "# endif"
      ]
    },
    "free_mem": {
      "start_point": [
        723,
        0
      ],
      "end_point": [
        726,
        1
      ],
      "content": "libc_freeres_fn (free_mem)\n{\n  __regfree (&re_comp_buf);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": null
    },
    "re_compile_internal": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        831,
        1
      ],
      "content": "static reg_errcode_t\nre_compile_internal (regex_t *preg, const char * pattern, size_t length,\n\t\t     reg_syntax_t syntax)\n{\n  reg_errcode_t err = REG_NOERROR;\n  re_dfa_t *dfa;\n  re_string_t regexp;\n\n  /* Initialize the pattern buffer.  */\n  preg->fastmap_accurate = 0;\n  preg->syntax = syntax;\n  preg->not_bol = preg->not_eol = 0;\n  preg->used = 0;\n  preg->re_nsub = 0;\n  preg->can_be_null = 0;\n  preg->regs_allocated = REGS_UNALLOCATED;\n\n  /* Initialize the dfa.  */\n  dfa = preg->buffer;\n  if (BE (preg->allocated < sizeof (re_dfa_t), 0))\n    {\n      /* If zero allocated, but buffer is non-null, try to realloc\n\t enough space.  This loses if buffer's address is bogus, but\n\t that is the user's responsibility.  If ->buffer is NULL this\n\t is a simple allocation.  */\n      dfa = re_realloc (preg->buffer, re_dfa_t, 1);\n      if (dfa == NULL)\n\treturn REG_ESPACE;\n      preg->allocated = sizeof (re_dfa_t);\n      preg->buffer = dfa;\n    }\n  preg->used = sizeof (re_dfa_t);\n\n  err = init_dfa (dfa, length);\n  if (BE (err == REG_NOERROR && lock_init (dfa->lock) != 0, 0))\n    err = REG_ESPACE;\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n#ifdef DEBUG\n  /* Note: length+1 will not overflow since it is checked in init_dfa.  */\n  dfa->re_str = re_malloc (char, length + 1);\n  strncpy (dfa->re_str, pattern, length + 1);\n#endif\n\n  err = re_string_construct (&regexp, pattern, length, preg->translate,\n\t\t\t     (syntax & RE_ICASE) != 0, dfa);\n  if (BE (err != REG_NOERROR, 0))\n    {\n    re_compile_internal_free_return:\n      free_workarea_compile (preg);\n      re_string_destruct (&regexp);\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n\n  /* Parse the regular expression, and build a structure tree.  */\n  preg->re_nsub = 0;\n  dfa->str_tree = parse (&regexp, preg, syntax, &err);\n  if (BE (dfa->str_tree == NULL, 0))\n    goto re_compile_internal_free_return;\n\n  /* Analyze the tree and create the nfa.  */\n  err = analyze (preg);\n  if (BE (err != REG_NOERROR, 0))\n    goto re_compile_internal_free_return;\n\n#ifdef RE_ENABLE_I18N\n  /* If possible, do searching in single byte encoding to speed things up.  */\n  if (dfa->is_utf8 && !(syntax & RE_ICASE) && preg->translate == NULL)\n    optimize_utf8 (dfa);\n#endif\n\n  /* Then create the initial state of the dfa.  */\n  err = create_initial_state (dfa);\n\n  /* Release work areas.  */\n  free_workarea_compile (preg);\n  re_string_destruct (&regexp);\n\n  if (BE (err != REG_NOERROR, 0))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n    }\n\n  return err;\n}",
      "lines": 97,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_dfa": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        930,
        1
      ],
      "content": "static reg_errcode_t\ninit_dfa (re_dfa_t *dfa, size_t pat_len)\n{\n  __re_size_t table_size;\n#ifndef _LIBC\n  const char *codeset_name;\n#endif\n#ifdef RE_ENABLE_I18N\n  size_t max_i18n_object_size = MAX (sizeof (wchar_t), sizeof (wctype_t));\n#else\n  size_t max_i18n_object_size = 0;\n#endif\n  size_t max_object_size =\n    MAX (sizeof (struct re_state_table_entry),\n\t MAX (sizeof (re_token_t),\n\t      MAX (sizeof (re_node_set),\n\t\t   MAX (sizeof (regmatch_t),\n\t\t\tmax_i18n_object_size))));\n\n  memset (dfa, '\\0', sizeof (re_dfa_t));\n\n  /* Force allocation of str_tree_storage the first time.  */\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n\n  /* Avoid overflows.  The extra \"/ 2\" is for the table_size doubling\n     calculation below, and for similar doubling calculations\n     elsewhere.  And it's <= rather than <, because some of the\n     doubling calculations add 1 afterwards.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) / 2 <= pat_len, 0))\n    return REG_ESPACE;\n\n  dfa->nodes_alloc = pat_len + 1;\n  dfa->nodes = re_malloc (re_token_t, dfa->nodes_alloc);\n\n  /*  table_size = 2 ^ ceil(log pat_len) */\n  for (table_size = 1; ; table_size <<= 1)\n    if (table_size > pat_len)\n      break;\n\n  dfa->state_table = calloc (sizeof (struct re_state_table_entry), table_size);\n  dfa->state_hash_mask = table_size - 1;\n\n  dfa->mb_cur_max = MB_CUR_MAX;\n#ifdef _LIBC\n  if (dfa->mb_cur_max == 6\n      && strcmp (_NL_CURRENT (LC_CTYPE, _NL_CTYPE_CODESET_NAME), \"UTF-8\") == 0)\n    dfa->is_utf8 = 1;\n  dfa->map_notascii = (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_MAP_TO_NONASCII)\n\t\t       != 0);\n#else\n  codeset_name = nl_langinfo (CODESET);\n  if ((codeset_name[0] == 'U' || codeset_name[0] == 'u')\n      && (codeset_name[1] == 'T' || codeset_name[1] == 't')\n      && (codeset_name[2] == 'F' || codeset_name[2] == 'f')\n      && strcmp (codeset_name + 3 + (codeset_name[3] == '-'), \"8\") == 0)\n    dfa->is_utf8 = 1;\n\n  /* We check exhaustively in the loop below if this charset is a\n     superset of ASCII.  */\n  dfa->map_notascii = 0;\n#endif\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      if (dfa->is_utf8)\n\tdfa->sb_char = (re_bitset_ptr_t) utf8_sb_map;\n      else\n\t{\n\t  int i, j, ch;\n\n\t  dfa->sb_char = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n\t  if (BE (dfa->sb_char == NULL, 0))\n\t    return REG_ESPACE;\n\n\t  /* Set the bits corresponding to single byte chars.  */\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t      {\n\t\twint_t wch = __btowc (ch);\n\t\tif (wch != WEOF)\n\t\t  dfa->sb_char[i] |= (bitset_word_t) 1 << j;\n# ifndef _LIBC\n\t\tif (isascii (ch) && wch != ch)\n\t\t  dfa->map_notascii = 1;\n# endif\n\t      }\n\t}\n    }\n#endif\n\n  if (BE (dfa->nodes == NULL || dfa->state_table == NULL, 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_word_char": {
      "start_point": [
        936,
        0
      ],
      "end_point": [
        980,
        1
      ],
      "content": "static void\ninternal_function\ninit_word_char (re_dfa_t *dfa)\n{\n  int i = 0;\n  int j;\n  int ch = 0;\n  dfa->word_ops_used = 1;\n  if (BE (dfa->map_notascii == 0, 1))\n    {\n      bitset_word_t bits0 = 0x00000000;\n      bitset_word_t bits1 = 0x03ff0000;\n      bitset_word_t bits2 = 0x87fffffe;\n      bitset_word_t bits3 = 0x07fffffe;\n      if (BITSET_WORD_BITS == 64)\n\t{\n\t  dfa->word_char[0] = bits1 << 31 << 1 | bits0;\n\t  dfa->word_char[1] = bits3 << 31 << 1 | bits2;\n\t  i = 2;\n\t}\n      else if (BITSET_WORD_BITS == 32)\n\t{\n\t  dfa->word_char[0] = bits0;\n\t  dfa->word_char[1] = bits1;\n\t  dfa->word_char[2] = bits2;\n\t  dfa->word_char[3] = bits3;\n\t  i = 4;\n\t}\n      else\n        goto general_case;\n      ch = 128;\n\n      if (BE (dfa->is_utf8, 1))\n\t{\n\t  memset (&dfa->word_char[i], '\\0', (SBC_MAX - ch) / 8);\n\t  return;\n\t}\n    }\n\n general_case:\n  for (; i < BITSET_WORDS; ++i)\n    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n      if (isalnum (ch) || ch == '_')\n\tdfa->word_char[i] |= (bitset_word_t) 1 << j;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "free_workarea_compile": {
      "start_point": [
        984,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "static void\nfree_workarea_compile (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_storage_t *storage, *next;\n  for (storage = dfa->str_tree_storage; storage; storage = next)\n    {\n      next = storage->next;\n      re_free (storage);\n    }\n  dfa->str_tree_storage = NULL;\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n  dfa->str_tree = NULL;\n  re_free (dfa->org_indices);\n  dfa->org_indices = NULL;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_initial_state": {
      "start_point": [
        1003,
        0
      ],
      "end_point": [
        1081,
        1
      ],
      "content": "static reg_errcode_t\ncreate_initial_state (re_dfa_t *dfa)\n{\n  Idx first, i;\n  reg_errcode_t err;\n  re_node_set init_nodes;\n\n  /* Initial states have the epsilon closure of the node which is\n     the first node of the regular expression.  */\n  first = dfa->str_tree->first->node_idx;\n  dfa->init_node = first;\n  err = re_node_set_init_copy (&init_nodes, dfa->eclosures + first);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* The back-references which are in initial states can epsilon transit,\n     since in this case all of the subexpressions can be null.\n     Then we add epsilon closures of the nodes which are the next nodes of\n     the back-references.  */\n  if (dfa->nbackref > 0)\n    for (i = 0; i < init_nodes.nelem; ++i)\n      {\n\tIdx node_idx = init_nodes.elems[i];\n\tre_token_type_t type = dfa->nodes[node_idx].type;\n\n\tIdx clexp_idx;\n\tif (type != OP_BACK_REF)\n\t  continue;\n\tfor (clexp_idx = 0; clexp_idx < init_nodes.nelem; ++clexp_idx)\n\t  {\n\t    re_token_t *clexp_node;\n\t    clexp_node = dfa->nodes + init_nodes.elems[clexp_idx];\n\t    if (clexp_node->type == OP_CLOSE_SUBEXP\n\t\t&& clexp_node->opr.idx == dfa->nodes[node_idx].opr.idx)\n\t      break;\n\t  }\n\tif (clexp_idx == init_nodes.nelem)\n\t  continue;\n\n\tif (type == OP_BACK_REF)\n\t  {\n\t    Idx dest_idx = dfa->edests[node_idx].elems[0];\n\t    if (!re_node_set_contains (&init_nodes, dest_idx))\n\t      {\n\t\treg_errcode_t merge_err\n                  = re_node_set_merge (&init_nodes, dfa->eclosures + dest_idx);\n\t\tif (merge_err != REG_NOERROR)\n\t\t  return merge_err;\n\t\ti = 0;\n\t      }\n\t  }\n      }\n\n  /* It must be the first time to invoke acquire_state.  */\n  dfa->init_state = re_acquire_state_context (&err, dfa, &init_nodes, 0);\n  /* We don't check ERR here, since the initial state must not be NULL.  */\n  if (BE (dfa->init_state == NULL, 0))\n    return err;\n  if (dfa->init_state->has_constraint)\n    {\n      dfa->init_state_word = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t       CONTEXT_WORD);\n      dfa->init_state_nl = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t     CONTEXT_NEWLINE);\n      dfa->init_state_begbuf = re_acquire_state_context (&err, dfa,\n\t\t\t\t\t\t\t &init_nodes,\n\t\t\t\t\t\t\t CONTEXT_NEWLINE\n\t\t\t\t\t\t\t | CONTEXT_BEGBUF);\n      if (BE (dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t      || dfa->init_state_begbuf == NULL, 0))\n\treturn err;\n    }\n  else\n    dfa->init_state_word = dfa->init_state_nl\n      = dfa->init_state_begbuf = dfa->init_state;\n\n  re_node_set_free (&init_nodes);\n  return REG_NOERROR;\n}",
      "lines": 79,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_utf8": {
      "start_point": [
        1088,
        0
      ],
      "end_point": [
        1162,
        1
      ],
      "content": "static void\noptimize_utf8 (re_dfa_t *dfa)\n{\n  Idx node;\n  int i;\n  bool mb_chars = false;\n  bool has_period = false;\n\n  for (node = 0; node < dfa->nodes_len; ++node)\n    switch (dfa->nodes[node].type)\n      {\n      case CHARACTER:\n\tif (dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  mb_chars = true;\n\tbreak;\n      case ANCHOR:\n\tswitch (dfa->nodes[node].opr.ctx_type)\n\t  {\n\t  case LINE_FIRST:\n\t  case LINE_LAST:\n\t  case BUF_FIRST:\n\t  case BUF_LAST:\n\t    break;\n\t  default:\n\t    /* Word anchors etc. cannot be handled.  It's okay to test\n\t       opr.ctx_type since constraints (for all DFA nodes) are\n\t       created by ORing one or more opr.ctx_type values.  */\n\t    return;\n\t  }\n\tbreak;\n      case OP_PERIOD:\n\thas_period = true;\n\tbreak;\n      case OP_BACK_REF:\n      case OP_ALT:\n      case END_OF_RE:\n      case OP_DUP_ASTERISK:\n      case OP_OPEN_SUBEXP:\n      case OP_CLOSE_SUBEXP:\n\tbreak;\n      case COMPLEX_BRACKET:\n\treturn;\n      case SIMPLE_BRACKET:\n\t/* Just double check.  */\n\t{\n\t  int rshift = (ASCII_CHARS % BITSET_WORD_BITS == 0\n\t\t\t? 0\n\t\t\t: BITSET_WORD_BITS - ASCII_CHARS % BITSET_WORD_BITS);\n\t  for (i = ASCII_CHARS / BITSET_WORD_BITS; i < BITSET_WORDS; ++i)\n\t    {\n\t      if (dfa->nodes[node].opr.sbcset[i] >> rshift != 0)\n\t\treturn;\n\t      rshift = 0;\n\t    }\n\t}\n\tbreak;\n      default:\n\tabort ();\n      }\n\n  if (mb_chars || has_period)\n    for (node = 0; node < dfa->nodes_len; ++node)\n      {\n\tif (dfa->nodes[node].type == CHARACTER\n\t    && dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  dfa->nodes[node].mb_partial = 0;\n\telse if (dfa->nodes[node].type == OP_PERIOD)\n\t  dfa->nodes[node].type = OP_UTF8_PERIOD;\n      }\n\n  /* The search can be in single byte locale.  */\n  dfa->mb_cur_max = 1;\n  dfa->is_utf8 = 0;\n  dfa->has_mb_node = dfa->nbackref > 0 || has_period;\n}",
      "lines": 75,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "analyze": {
      "start_point": [
        1168,
        0
      ],
      "end_point": [
        1226,
        1
      ],
      "content": "static reg_errcode_t\nanalyze (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  reg_errcode_t ret;\n\n  /* Allocate arrays.  */\n  dfa->nexts = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->org_indices = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);\n  dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);\n  if (BE (dfa->nexts == NULL || dfa->org_indices == NULL || dfa->edests == NULL\n\t  || dfa->eclosures == NULL, 0))\n    return REG_ESPACE;\n\n  dfa->subexp_map = re_malloc (Idx, preg->re_nsub);\n  if (dfa->subexp_map != NULL)\n    {\n      Idx i;\n      for (i = 0; i < preg->re_nsub; i++)\n\tdfa->subexp_map[i] = i;\n      preorder (dfa->str_tree, optimize_subexps, dfa);\n      for (i = 0; i < preg->re_nsub; i++)\n\tif (dfa->subexp_map[i] != i)\n\t  break;\n      if (i == preg->re_nsub)\n\t{\n\t  free (dfa->subexp_map);\n\t  dfa->subexp_map = NULL;\n\t}\n    }\n\n  ret = postorder (dfa->str_tree, lower_subexps, preg);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = postorder (dfa->str_tree, calc_first, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  preorder (dfa->str_tree, calc_next, dfa);\n  ret = preorder (dfa->str_tree, link_nfa_nodes, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = calc_eclosure (dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  /* We only need this during the prune_impossible_nodes pass in regexec.c;\n     skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */\n  if ((!preg->no_sub && preg->re_nsub > 0 && dfa->has_plural_match)\n      || dfa->nbackref)\n    {\n      dfa->inveclosures = re_malloc (re_node_set, dfa->nodes_len);\n      if (BE (dfa->inveclosures == NULL, 0))\n\treturn REG_ESPACE;\n      ret = calc_inveclosure (dfa);\n    }\n\n  return ret;\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "postorder": {
      "start_point": [
        1231,
        0
      ],
      "end_point": [
        1261,
        1
      ],
      "content": "static reg_errcode_t\npostorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t   void *extra)\n{\n  bin_tree_t *node, *prev;\n\n  for (node = root; ; )\n    {\n      /* Descend down the tree, preferably to the left (or to the right\n\t if that's the only child).  */\n      while (node->left || node->right)\n\tif (node->left)\n\t  node = node->left;\n\telse\n\t  node = node->right;\n\n      do\n\t{\n\t  reg_errcode_t err = fn (extra, node);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  if (node->parent == NULL)\n\t    return REG_NOERROR;\n\t  prev = node;\n\t  node = node->parent;\n\t}\n      /* Go up while we have a node that is reached from the right.  */\n      while (node->right == prev || node->right == NULL);\n      node = node->right;\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "preorder": {
      "start_point": [
        1263,
        0
      ],
      "end_point": [
        1291,
        1
      ],
      "content": "static reg_errcode_t\npreorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t  void *extra)\n{\n  bin_tree_t *node;\n\n  for (node = root; ; )\n    {\n      reg_errcode_t err = fn (extra, node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\tnode = node->left;\n      else\n\t{\n\t  bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      if (!node)\n\t\treturn REG_NOERROR;\n\t    }\n\t  node = node->right;\n\t}\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_subexps": {
      "start_point": [
        1296,
        0
      ],
      "end_point": [
        1323,
        1
      ],
      "content": "static reg_errcode_t\noptimize_subexps (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n\n  if (node->token.type == OP_BACK_REF && dfa->subexp_map)\n    {\n      int idx = node->token.opr.idx;\n      node->token.opr.idx = dfa->subexp_map[idx];\n      dfa->used_bkref_map |= 1 << node->token.opr.idx;\n    }\n\n  else if (node->token.type == SUBEXP\n\t   && node->left && node->left->token.type == SUBEXP)\n    {\n      Idx other_idx = node->left->token.opr.idx;\n\n      node->left = node->left->left;\n      if (node->left)\n\tnode->left->parent = node;\n\n      dfa->subexp_map[other_idx] = dfa->subexp_map[node->token.opr.idx];\n      if (other_idx < BITSET_WORD_BITS)\n\tdfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexps": {
      "start_point": [
        1327,
        0
      ],
      "end_point": [
        1347,
        1
      ],
      "content": "static reg_errcode_t\nlower_subexps (void *extra, bin_tree_t *node)\n{\n  regex_t *preg = (regex_t *) extra;\n  reg_errcode_t err = REG_NOERROR;\n\n  if (node->left && node->left->token.type == SUBEXP)\n    {\n      node->left = lower_subexp (&err, preg, node->left);\n      if (node->left)\n\tnode->left->parent = node;\n    }\n  if (node->right && node->right->token.type == SUBEXP)\n    {\n      node->right = lower_subexp (&err, preg, node->right);\n      if (node->right)\n\tnode->right->parent = node;\n    }\n\n  return err;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexp": {
      "start_point": [
        1349,
        0
      ],
      "end_point": [
        1382,
        1
      ],
      "content": "static bin_tree_t *\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *body = node->left;\n  bin_tree_t *op, *cls, *tree1, *tree;\n\n  if (preg->no_sub\n      /* We do not optimize empty subexpressions, because otherwise we may\n\t have bad CONCAT nodes with NULL children.  This is obviously not\n\t very common, so we do not lose much.  An example that triggers\n\t this case is the sed \"script\" /\\(\\)/x.  */\n      && node->left != NULL\n      && (node->token.opr.idx >= BITSET_WORD_BITS\n\t  || !(dfa->used_bkref_map\n\t       & ((bitset_word_t) 1 << node->token.opr.idx))))\n    return node->left;\n\n  /* Convert the SUBEXP node to the concatenation of an\n     OP_OPEN_SUBEXP, the contents, and an OP_CLOSE_SUBEXP.  */\n  op = create_tree (dfa, NULL, NULL, OP_OPEN_SUBEXP);\n  cls = create_tree (dfa, NULL, NULL, OP_CLOSE_SUBEXP);\n  tree1 = body ? create_tree (dfa, body, cls, CONCAT) : cls;\n  tree = create_tree (dfa, op, tree1, CONCAT);\n  if (BE (tree == NULL || tree1 == NULL || op == NULL || cls == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  op->token.opr.idx = cls->token.opr.idx = node->token.opr.idx;\n  op->token.opt_subexp = cls->token.opt_subexp = node->token.opt_subexp;\n  return tree;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)",
        "*"
      ]
    },
    "calc_first": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1405,
        1
      ],
      "content": "static reg_errcode_t\ncalc_first (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  if (node->token.type == CONCAT)\n    {\n      node->first = node->left->first;\n      node->node_idx = node->left->node_idx;\n    }\n  else\n    {\n      node->first = node;\n      node->node_idx = re_dfa_add_node (dfa, node->token);\n      if (BE (node->node_idx == -1, 0))\n\treturn REG_ESPACE;\n      if (node->token.type == ANCHOR)\n\tdfa->nodes[node->node_idx].constraint = node->token.opr.ctx_type;\n    }\n  return REG_NOERROR;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_next": {
      "start_point": [
        1408,
        0
      ],
      "end_point": [
        1428,
        1
      ],
      "content": "static reg_errcode_t\ncalc_next (void *extra, bin_tree_t *node)\n{\n  switch (node->token.type)\n    {\n    case OP_DUP_ASTERISK:\n      node->left->next = node;\n      break;\n    case CONCAT:\n      node->left->next = node->right->first;\n      node->right->next = node->next;\n      break;\n    default:\n      if (node->left)\n\tnode->left->next = node->next;\n      if (node->right)\n\tnode->right->next = node->next;\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "link_nfa_nodes": {
      "start_point": [
        1431,
        0
      ],
      "end_point": [
        1485,
        1
      ],
      "content": "static reg_errcode_t\nlink_nfa_nodes (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  Idx idx = node->node_idx;\n  reg_errcode_t err = REG_NOERROR;\n\n  switch (node->token.type)\n    {\n    case CONCAT:\n      break;\n\n    case END_OF_RE:\n      assert (node->next == NULL);\n      break;\n\n    case OP_DUP_ASTERISK:\n    case OP_ALT:\n      {\n\tIdx left, right;\n\tdfa->has_plural_match = 1;\n\tif (node->left != NULL)\n\t  left = node->left->first->node_idx;\n\telse\n\t  left = node->next->node_idx;\n\tif (node->right != NULL)\n\t  right = node->right->first->node_idx;\n\telse\n\t  right = node->next->node_idx;\n\tassert (left > -1);\n\tassert (right > -1);\n\terr = re_node_set_init_2 (dfa->edests + idx, left, right);\n      }\n      break;\n\n    case ANCHOR:\n    case OP_OPEN_SUBEXP:\n    case OP_CLOSE_SUBEXP:\n      err = re_node_set_init_1 (dfa->edests + idx, node->next->node_idx);\n      break;\n\n    case OP_BACK_REF:\n      dfa->nexts[idx] = node->next->node_idx;\n      if (node->token.type == OP_BACK_REF)\n\terr = re_node_set_init_1 (dfa->edests + idx, dfa->nexts[idx]);\n      break;\n\n    default:\n      assert (!IS_EPSILON_NODE (node->token.type));\n      dfa->nexts[idx] = node->next->node_idx;\n      break;\n    }\n\n  return err;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_node_closure": {
      "start_point": [
        1491,
        0
      ],
      "end_point": [
        1594,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nduplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,\n\t\t\tIdx root_node, unsigned int init_constraint)\n{\n  Idx org_node, clone_node;\n  bool ok;\n  unsigned int constraint = init_constraint;\n  for (org_node = top_org_node, clone_node = top_clone_node;;)\n    {\n      Idx org_dest, clone_dest;\n      if (dfa->nodes[org_node].type == OP_BACK_REF)\n\t{\n\t  /* If the back reference epsilon-transit, its destination must\n\t     also have the constraint.  Then duplicate the epsilon closure\n\t     of the destination of the back reference, and store it in\n\t     edests of the back reference.  */\n\t  org_dest = dfa->nexts[org_node];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else if (dfa->edests[org_node].nelem == 0)\n\t{\n\t  /* In case of the node can't epsilon-transit, don't duplicate the\n\t     destination and store the original destination as the\n\t     destination of the node.  */\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  break;\n\t}\n      else if (dfa->edests[org_node].nelem == 1)\n\t{\n\t  /* In case of the node can epsilon-transit, and it has only one\n\t     destination.  */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* If the node is root_node itself, it means the epsilon closure\n\t     has a loop.  Then tie it to the destination of the root_node.  */\n\t  if (org_node == root_node && clone_node != org_node)\n\t    {\n\t      ok = re_node_set_insert (dfa->edests + clone_node, org_dest);\n\t      if (BE (! ok, 0))\n\t        return REG_ESPACE;\n\t      break;\n\t    }\n\t  /* In case the node has another constraint, append it.  */\n\t  constraint |= dfa->nodes[org_node].constraint;\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else /* dfa->edests[org_node].nelem == 2 */\n\t{\n\t  /* In case of the node can epsilon-transit, and it has two\n\t     destinations. In the bin_tree_t and DFA, that's '|' and '*'.   */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* Search for a duplicated node which satisfies the constraint.  */\n\t  clone_dest = search_duplicated_node (dfa, org_dest, constraint);\n\t  if (clone_dest == -1)\n\t    {\n\t      /* There is no such duplicated node, create a new one.  */\n\t      reg_errcode_t err;\n\t      clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t      if (BE (clone_dest == -1, 0))\n\t\treturn REG_ESPACE;\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t      err = duplicate_node_closure (dfa, org_dest, clone_dest,\n\t\t\t\t\t    root_node, constraint);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  else\n\t    {\n\t      /* There is a duplicated node which satisfies the constraint,\n\t\t use it to avoid infinite loop.  */\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\n\t  org_dest = dfa->edests[org_node].elems[1];\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      org_node = org_dest;\n      clone_node = clone_dest;\n    }\n  return REG_NOERROR;\n}",
      "lines": 104,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "search_duplicated_node": {
      "start_point": [
        1599,
        0
      ],
      "end_point": [
        1611,
        1
      ],
      "content": "static Idx\nsearch_duplicated_node (const re_dfa_t *dfa, Idx org_node,\n\t\t\tunsigned int constraint)\n{\n  Idx idx;\n  for (idx = dfa->nodes_len - 1; dfa->nodes[idx].duplicated && idx > 0; --idx)\n    {\n      if (org_node == dfa->org_indices[idx]\n\t  && constraint == dfa->nodes[idx].constraint)\n\treturn idx; /* Found.  */\n    }\n  return -1; /* Not found.  */\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "duplicate_node": {
      "start_point": [
        1617,
        0
      ],
      "end_point": [
        1631,
        1
      ],
      "content": "static Idx\nduplicate_node (re_dfa_t *dfa, Idx org_idx, unsigned int constraint)\n{\n  Idx dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);\n  if (BE (dup_idx != -1, 1))\n    {\n      dfa->nodes[dup_idx].constraint = constraint;\n      dfa->nodes[dup_idx].constraint |= dfa->nodes[org_idx].constraint;\n      dfa->nodes[dup_idx].duplicated = 1;\n\n      /* Store the index of the original node.  */\n      dfa->org_indices[dup_idx] = org_idx;\n    }\n  return dup_idx;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "calc_inveclosure": {
      "start_point": [
        1633,
        0
      ],
      "end_point": [
        1653,
        1
      ],
      "content": "static reg_errcode_t\ncalc_inveclosure (re_dfa_t *dfa)\n{\n  Idx src, idx;\n  bool ok;\n  for (idx = 0; idx < dfa->nodes_len; ++idx)\n    re_node_set_init_empty (dfa->inveclosures + idx);\n\n  for (src = 0; src < dfa->nodes_len; ++src)\n    {\n      Idx *elems = dfa->eclosures[src].elems;\n      for (idx = 0; idx < dfa->eclosures[src].nelem; ++idx)\n\t{\n\t  ok = re_node_set_insert_last (dfa->inveclosures + elems[idx], src);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure": {
      "start_point": [
        1657,
        0
      ],
      "end_point": [
        1698,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure (re_dfa_t *dfa)\n{\n  Idx node_idx;\n  bool incomplete;\n#ifdef DEBUG\n  assert (dfa->nodes_len > 0);\n#endif\n  incomplete = false;\n  /* For each nodes, calculate epsilon closure.  */\n  for (node_idx = 0; ; ++node_idx)\n    {\n      reg_errcode_t err;\n      re_node_set eclosure_elem;\n      if (node_idx == dfa->nodes_len)\n\t{\n\t  if (!incomplete)\n\t    break;\n\t  incomplete = false;\n\t  node_idx = 0;\n\t}\n\n#ifdef DEBUG\n      assert (dfa->eclosures[node_idx].nelem != -1);\n#endif\n\n      /* If we have already calculated, skip it.  */\n      if (dfa->eclosures[node_idx].nelem != 0)\n\tcontinue;\n      /* Calculate epsilon closure of 'node_idx'.  */\n      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, true);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      if (dfa->eclosures[node_idx].nelem == 0)\n\t{\n\t  incomplete = true;\n\t  re_node_set_free (&eclosure_elem);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure_iter": {
      "start_point": [
        1702,
        0
      ],
      "end_point": [
        1776,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)\n{\n  reg_errcode_t err;\n  Idx i;\n  re_node_set eclosure;\n  bool ok;\n  bool incomplete = false;\n  err = re_node_set_alloc (&eclosure, dfa->edests[node].nelem + 1);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* This indicates that we are calculating this node now.\n     We reference this value to avoid infinite loop.  */\n  dfa->eclosures[node].nelem = -1;\n\n  /* If the current node has constraints, duplicate all nodes\n     since they must inherit the constraints.  */\n  if (dfa->nodes[node].constraint\n      && dfa->edests[node].nelem\n      && !dfa->nodes[dfa->edests[node].elems[0]].duplicated)\n    {\n      err = duplicate_node_closure (dfa, node, node, node,\n\t\t\t\t    dfa->nodes[node].constraint);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  /* Expand each epsilon destination nodes.  */\n  if (IS_EPSILON_NODE(dfa->nodes[node].type))\n    for (i = 0; i < dfa->edests[node].nelem; ++i)\n      {\n\tre_node_set eclosure_elem;\n\tIdx edest = dfa->edests[node].elems[i];\n\t/* If calculating the epsilon closure of 'edest' is in progress,\n\t   return intermediate result.  */\n\tif (dfa->eclosures[edest].nelem == -1)\n\t  {\n\t    incomplete = true;\n\t    continue;\n\t  }\n\t/* If we haven't calculated the epsilon closure of 'edest' yet,\n\t   calculate now. Otherwise use calculated epsilon closure.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, false);\n\t    if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  }\n\telse\n\t  eclosure_elem = dfa->eclosures[edest];\n\t/* Merge the epsilon closure of 'edest'.  */\n\terr = re_node_set_merge (&eclosure, &eclosure_elem);\n\tif (BE (err != REG_NOERROR, 0))\n\t  return err;\n\t/* If the epsilon closure of 'edest' is incomplete,\n\t   the epsilon closure of this node is also incomplete.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    incomplete = true;\n\t    re_node_set_free (&eclosure_elem);\n\t  }\n      }\n\n  /* An epsilon closure includes itself.  */\n  ok = re_node_set_insert (&eclosure, node);\n  if (BE (! ok, 0))\n    return REG_ESPACE;\n  if (incomplete && !root)\n    dfa->eclosures[node].nelem = 0;\n  else\n    dfa->eclosures[node] = eclosure;\n  *new_set = eclosure;\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "fetch_token": {
      "start_point": [
        1783,
        0
      ],
      "end_point": [
        1788,
        1
      ],
      "content": "static void\ninternal_function\nfetch_token (re_token_t *result, re_string_t *input, reg_syntax_t syntax)\n{\n  re_string_skip_bytes (input, peek_token (result, input, syntax));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "internal_function": {
      "start_point": [
        1793,
        0
      ],
      "end_point": [
        2027,
        1
      ],
      "content": "static int\ninternal_function\npeek_token (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n  token->word_char = 0;\n#ifdef RE_ENABLE_I18N\n  token->mb_partial = 0;\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      token->mb_partial = 1;\n      return 1;\n    }\n#endif\n  if (c == '\\\\')\n    {\n      unsigned char c2;\n      if (re_string_cur_idx (input) + 1 >= re_string_length (input))\n\t{\n\t  token->type = BACK_SLASH;\n\t  return 1;\n\t}\n\n      c2 = re_string_peek_byte_case (input, 1);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n      if (input->mb_cur_max > 1)\n\t{\n\t  wint_t wc = re_string_wchar_at (input,\n\t\t\t\t\t  re_string_cur_idx (input) + 1);\n\t  token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n\t}\n      else\n#endif\n\ttoken->word_char = IS_WORD_CHAR (c2) != 0;\n\n      switch (c2)\n\t{\n\tcase '|':\n\t  if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_NO_BK_VBAR))\n\t    token->type = OP_ALT;\n\t  break;\n\tcase '1': case '2': case '3': case '4': case '5':\n\tcase '6': case '7': case '8': case '9':\n\t  if (!(syntax & RE_NO_BK_REFS))\n\t    {\n\t      token->type = OP_BACK_REF;\n\t      token->opr.idx = c2 - '1';\n\t    }\n\t  break;\n\tcase '<':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_FIRST;\n\t    }\n\t  break;\n\tcase '>':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  break;\n\tcase 'b':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'B':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = NOT_WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'w':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_WORD;\n\t  break;\n\tcase 'W':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTWORD;\n\t  break;\n\tcase 's':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_SPACE;\n\t  break;\n\tcase 'S':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTSPACE;\n\t  break;\n\tcase '`':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_FIRST;\n\t    }\n\t  break;\n\tcase '\\'':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_LAST;\n\t    }\n\t  break;\n\tcase '(':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_OPEN_SUBEXP;\n\t  break;\n\tcase ')':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_CLOSE_SUBEXP;\n\t  break;\n\tcase '+':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_PLUS;\n\t  break;\n\tcase '?':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_QUESTION;\n\t  break;\n\tcase '{':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_OPEN_DUP_NUM;\n\t  break;\n\tcase '}':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_CLOSE_DUP_NUM;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      return 2;\n    }\n\n  token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc = re_string_wchar_at (input, re_string_cur_idx (input));\n      token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n    }\n  else\n#endif\n    token->word_char = IS_WORD_CHAR (token->opr.c);\n\n  switch (c)\n    {\n    case '\\n':\n      if (syntax & RE_NEWLINE_ALT)\n\ttoken->type = OP_ALT;\n      break;\n    case '|':\n      if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_NO_BK_VBAR))\n\ttoken->type = OP_ALT;\n      break;\n    case '*':\n      token->type = OP_DUP_ASTERISK;\n      break;\n    case '+':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_PLUS;\n      break;\n    case '?':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_QUESTION;\n      break;\n    case '{':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_OPEN_DUP_NUM;\n      break;\n    case '}':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_CLOSE_DUP_NUM;\n      break;\n    case '(':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_OPEN_SUBEXP;\n      break;\n    case ')':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_CLOSE_SUBEXP;\n      break;\n    case '[':\n      token->type = OP_OPEN_BRACKET;\n      break;\n    case '.':\n      token->type = OP_PERIOD;\n      break;\n    case '^':\n      if (!(syntax & (RE_CONTEXT_INDEP_ANCHORS | RE_CARET_ANCHORS_HERE)) &&\n\t  re_string_cur_idx (input) != 0)\n\t{\n\t  char prev = re_string_peek_byte (input, -1);\n\t  if (!(syntax & RE_NEWLINE_ALT) || prev != '\\n')\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_FIRST;\n      break;\n    case '$':\n      if (!(syntax & RE_CONTEXT_INDEP_ANCHORS) &&\n\t  re_string_cur_idx (input) + 1 != re_string_length (input))\n\t{\n\t  re_token_t next;\n\t  re_string_skip_bytes (input, 1);\n\t  peek_token (&next, input, syntax);\n\t  re_string_skip_bytes (input, -1);\n\t  if (next.type != OP_ALT && next.type != OP_CLOSE_SUBEXP)\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_LAST;\n      break;\n    default:\n      break;\n    }\n  return 1;\n}",
      "lines": 235,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "peek_token_bracket": {
      "start_point": [
        2032,
        0
      ],
      "end_point": [
        2115,
        1
      ],
      "content": "static int\ninternal_function\npeek_token_bracket (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      return 1;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  if (c == '\\\\' && (syntax & RE_BACKSLASH_ESCAPE_IN_LISTS)\n      && re_string_cur_idx (input) + 1 < re_string_length (input))\n    {\n      /* In this case, '\\' escape a character.  */\n      unsigned char c2;\n      re_string_skip_bytes (input, 1);\n      c2 = re_string_peek_byte (input, 0);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n      return 1;\n    }\n  if (c == '[') /* '[' is a special char in a bracket exps.  */\n    {\n      unsigned char c2;\n      int token_len;\n      if (re_string_cur_idx (input) + 1 < re_string_length (input))\n\tc2 = re_string_peek_byte (input, 1);\n      else\n\tc2 = 0;\n      token->opr.c = c2;\n      token_len = 2;\n      switch (c2)\n\t{\n\tcase '.':\n\t  token->type = OP_OPEN_COLL_ELEM;\n\t  break;\n\n\tcase '=':\n\t  token->type = OP_OPEN_EQUIV_CLASS;\n\t  break;\n\n\tcase ':':\n\t  if (syntax & RE_CHAR_CLASSES)\n\t    {\n\t      token->type = OP_OPEN_CHAR_CLASS;\n\t      break;\n\t    }\n\t  FALLTHROUGH;\n\tdefault:\n\t  token->type = CHARACTER;\n\t  token->opr.c = c;\n\t  token_len = 1;\n\t  break;\n\t}\n      return token_len;\n    }\n  switch (c)\n    {\n    case '-':\n      token->type = OP_CHARSET_RANGE;\n      break;\n    case ']':\n      token->type = OP_CLOSE_BRACKET;\n      break;\n    case '^':\n      token->type = OP_NON_MATCH_LIST;\n      break;\n    default:\n      token->type = CHARACTER;\n    }\n  return 1;\n}",
      "lines": 84,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "parse": {
      "start_point": [
        2131,
        0
      ],
      "end_point": [
        2154,
        1
      ],
      "content": "static bin_tree_t *\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *eor, *root;\n  re_token_t current_token;\n  dfa->syntax = syntax;\n  fetch_token (&current_token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n  tree = parse_reg_exp (regexp, preg, &current_token, syntax, 0, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  eor = create_tree (dfa, NULL, NULL, END_OF_RE);\n  if (tree != NULL)\n    root = create_tree (dfa, tree, eor, CONCAT);\n  else\n    root = eor;\n  if (BE (eor == NULL || root == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  return root;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_reg_exp": {
      "start_point": [
        2165,
        0
      ],
      "end_point": [
        2203,
        1
      ],
      "content": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_branch": {
      "start_point": [
        2214,
        0
      ],
      "end_point": [
        2251,
        1
      ],
      "content": "static bin_tree_t *\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  bin_tree_t *tree, *expr;\n  re_dfa_t *dfa = preg->buffer;\n  tree = parse_expression (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type != OP_ALT && token->type != END_OF_RE\n\t && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n    {\n      expr = parse_expression (regexp, preg, token, syntax, nest, err);\n      if (BE (*err != REG_NOERROR && expr == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      if (tree != NULL && expr != NULL)\n\t{\n\t  bin_tree_t *newtree = create_tree (dfa, tree, expr, CONCAT);\n\t  if (newtree == NULL)\n\t    {\n\t      postorder (expr, free_tree, NULL);\n\t      postorder (tree, free_tree, NULL);\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t  tree = newtree;\n\t}\n      else if (tree == NULL)\n\ttree = expr;\n      /* Otherwise expr == NULL, we don't need to create new tree.  */\n    }\n  return tree;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_expression": {
      "start_point": [
        2259,
        0
      ],
      "end_point": [
        2485,
        1
      ],
      "content": "static bin_tree_t *\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  switch (token->type)\n    {\n    case CHARACTER:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (!re_string_eoi (regexp)\n\t\t && !re_string_first_byte (regexp, re_string_cur_idx (regexp)))\n\t    {\n\t      bin_tree_t *mbc_remain;\n\t      fetch_token (token, regexp, syntax);\n\t      mbc_remain = create_token_tree (dfa, NULL, NULL, token);\n\t      tree = create_tree (dfa, tree, mbc_remain, CONCAT);\n\t      if (BE (mbc_remain == NULL || tree == NULL, 0))\n\t\t{\n\t\t  *err = REG_ESPACE;\n\t\t  return NULL;\n\t\t}\n\t    }\n\t}\n#endif\n      break;\n\n    case OP_OPEN_SUBEXP:\n      tree = parse_sub_exp (regexp, preg, token, syntax, nest + 1, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n\n    case OP_OPEN_BRACKET:\n      tree = parse_bracket_exp (regexp, dfa, token, syntax, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n\n    case OP_BACK_REF:\n      if (!BE (dfa->completed_bkref_map & (1 << token->opr.idx), 1))\n\t{\n\t  *err = REG_ESUBREG;\n\t  return NULL;\n\t}\n      dfa->used_bkref_map |= 1 << token->opr.idx;\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      ++dfa->nbackref;\n      dfa->has_mb_node = 1;\n      break;\n\n    case OP_OPEN_DUP_NUM:\n      if (syntax & RE_CONTEXT_INVALID_DUP)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      FALLTHROUGH;\n    case OP_DUP_ASTERISK:\n    case OP_DUP_PLUS:\n    case OP_DUP_QUESTION:\n      if (syntax & RE_CONTEXT_INVALID_OPS)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      else if (syntax & RE_CONTEXT_INDEP_OPS)\n\t{\n\t  fetch_token (token, regexp, syntax);\n\t  return parse_expression (regexp, preg, token, syntax, nest, err);\n\t}\n      FALLTHROUGH;\n    case OP_CLOSE_SUBEXP:\n      if ((token->type == OP_CLOSE_SUBEXP) &&\n\t  !(syntax & RE_UNMATCHED_RIGHT_PAREN_ORD))\n\t{\n\t  *err = REG_ERPAREN;\n\t  return NULL;\n\t}\n      FALLTHROUGH;\n    case OP_CLOSE_DUP_NUM:\n      /* We treat it as a normal character.  */\n\n      /* Then we can these characters as normal characters.  */\n      token->type = CHARACTER;\n      /* mb_partial and word_char bits should be initialized already\n\t by peek_token.  */\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      break;\n\n    case ANCHOR:\n      if ((token->opr.ctx_type\n\t   & (WORD_DELIM | NOT_WORD_DELIM | WORD_FIRST | WORD_LAST))\n\t  && dfa->word_ops_used == 0)\n\tinit_word_char (dfa);\n      if (token->opr.ctx_type == WORD_DELIM\n\t  || token->opr.ctx_type == NOT_WORD_DELIM)\n\t{\n\t  bin_tree_t *tree_first, *tree_last;\n\t  if (token->opr.ctx_type == WORD_DELIM)\n\t    {\n\t      token->opr.ctx_type = WORD_FIRST;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  else\n\t    {\n\t      token->opr.ctx_type = INSIDE_WORD;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = INSIDE_NOTWORD;\n\t    }\n\t  tree_last = create_token_tree (dfa, NULL, NULL, token);\n\t  tree = create_tree (dfa, tree_first, tree_last, OP_ALT);\n\t  if (BE (tree_first == NULL || tree_last == NULL || tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      else\n\t{\n\t  tree = create_token_tree (dfa, NULL, NULL, token);\n\t  if (BE (tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      /* We must return here, since ANCHORs can't be followed\n\t by repetition operators.\n\t eg. RE\"^*\" is invalid or \"<ANCHOR(^)><CHAR(*)>\",\n\t     it must not be \"<ANCHOR(^)><REPEAT(*)>\".  */\n      fetch_token (token, regexp, syntax);\n      return tree;\n\n    case OP_PERIOD:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      if (dfa->mb_cur_max > 1)\n\tdfa->has_mb_node = 1;\n      break;\n\n    case OP_WORD:\n    case OP_NOTWORD:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"alnum\",\n\t\t\t\t \"_\",\n\t\t\t\t token->type == OP_NOTWORD, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n\n    case OP_SPACE:\n    case OP_NOTSPACE:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"space\",\n\t\t\t\t \"\",\n\t\t\t\t token->type == OP_NOTSPACE, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n\n    case OP_ALT:\n    case END_OF_RE:\n      return NULL;\n\n    case BACK_SLASH:\n      *err = REG_EESCAPE;\n      return NULL;\n\n    default:\n      /* Must not happen?  */\n#ifdef DEBUG\n      assert (0);\n#endif\n      return NULL;\n    }\n  fetch_token (token, regexp, syntax);\n\n  while (token->type == OP_DUP_ASTERISK || token->type == OP_DUP_PLUS\n\t || token->type == OP_DUP_QUESTION || token->type == OP_OPEN_DUP_NUM)\n    {\n      bin_tree_t *dup_tree = parse_dup_op (tree, regexp, dfa, token,\n\t\t\t\t\t   syntax, err);\n      if (BE (*err != REG_NOERROR && dup_tree == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      tree = dup_tree;\n      /* In BRE consecutive duplications are not allowed.  */\n      if ((syntax & RE_CONTEXT_INVALID_DUP)\n\t  && (token->type == OP_DUP_ASTERISK\n\t      || token->type == OP_OPEN_DUP_NUM))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n    }\n\n  return tree;\n}",
      "lines": 227,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_sub_exp": {
      "start_point": [
        2494,
        0
      ],
      "end_point": [
        2532,
        1
      ],
      "content": "static bin_tree_t *\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  size_t cur_nsub;\n  cur_nsub = preg->re_nsub++;\n\n  fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n\n  /* The subexpression may be a null string.  */\n  if (token->type == OP_CLOSE_SUBEXP)\n    tree = NULL;\n  else\n    {\n      tree = parse_reg_exp (regexp, preg, token, syntax, nest, err);\n      if (BE (*err == REG_NOERROR && token->type != OP_CLOSE_SUBEXP, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_EPAREN;\n\t}\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n\n  if (cur_nsub <= '9' - '1')\n    dfa->completed_bkref_map |= 1 << cur_nsub;\n\n  tree = create_tree (dfa, tree, NULL, SUBEXP);\n  if (BE (tree == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  tree->token.opr.idx = cur_nsub;\n  return tree;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_dup_op": {
      "start_point": [
        2536,
        0
      ],
      "end_point": [
        2680,
        1
      ],
      "content": "static bin_tree_t *\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)\n{\n  bin_tree_t *tree = NULL, *old_tree = NULL;\n  Idx i, start, end, start_idx = re_string_cur_idx (regexp);\n  re_token_t start_token = *token;\n\n  if (token->type == OP_OPEN_DUP_NUM)\n    {\n      end = 0;\n      start = fetch_number (regexp, token, syntax);\n      if (start == -1)\n\t{\n\t  if (token->type == CHARACTER && token->opr.c == ',')\n\t    start = 0; /* We treat \"{,m}\" as \"{0,m}\".  */\n\t  else\n\t    {\n\t      *err = REG_BADBR; /* <re>{} is invalid.  */\n\t      return NULL;\n\t    }\n\t}\n      if (BE (start != -2, 1))\n\t{\n\t  /* We treat \"{n}\" as \"{n,n}\".  */\n\t  end = ((token->type == OP_CLOSE_DUP_NUM) ? start\n\t\t : ((token->type == CHARACTER && token->opr.c == ',')\n\t\t    ? fetch_number (regexp, token, syntax) : -2));\n\t}\n      if (BE (start == -2 || end == -2, 0))\n\t{\n\t  /* Invalid sequence.  */\n\t  if (BE (!(syntax & RE_INVALID_INTERVAL_ORD), 0))\n\t    {\n\t      if (token->type == END_OF_RE)\n\t\t*err = REG_EBRACE;\n\t      else\n\t\t*err = REG_BADBR;\n\n\t      return NULL;\n\t    }\n\n\t  /* If the syntax bit is set, rollback.  */\n\t  re_string_set_index (regexp, start_idx);\n\t  *token = start_token;\n\t  token->type = CHARACTER;\n\t  /* mb_partial and word_char bits should be already initialized by\n\t     peek_token.  */\n\t  return elem;\n\t}\n\n      if (BE ((end != -1 && start > end)\n\t      || token->type != OP_CLOSE_DUP_NUM, 0))\n\t{\n\t  /* First number greater than second.  */\n\t  *err = REG_BADBR;\n\t  return NULL;\n\t}\n\n      if (BE (RE_DUP_MAX < (end == -1 ? start : end), 0))\n\t{\n\t  *err = REG_ESIZE;\n\t  return NULL;\n\t}\n    }\n  else\n    {\n      start = (token->type == OP_DUP_PLUS) ? 1 : 0;\n      end = (token->type == OP_DUP_QUESTION) ? 1 : -1;\n    }\n\n  fetch_token (token, regexp, syntax);\n\n  if (BE (elem == NULL, 0))\n    return NULL;\n  if (BE (start == 0 && end == 0, 0))\n    {\n      postorder (elem, free_tree, NULL);\n      return NULL;\n    }\n\n  /* Extract \"<re>{n,m}\" to \"<re><re>...<re><re>{0,<m-n>}\".  */\n  if (BE (start > 0, 0))\n    {\n      tree = elem;\n      for (i = 2; i <= start; ++i)\n\t{\n\t  elem = duplicate_tree (elem, dfa);\n\t  tree = create_tree (dfa, tree, elem, CONCAT);\n\t  if (BE (elem == NULL || tree == NULL, 0))\n\t    goto parse_dup_op_espace;\n\t}\n\n      if (start == end)\n\treturn tree;\n\n      /* Duplicate ELEM before it is marked optional.  */\n      elem = duplicate_tree (elem, dfa);\n      if (BE (elem == NULL, 0))\n        goto parse_dup_op_espace;\n      old_tree = tree;\n    }\n  else\n    old_tree = NULL;\n\n  if (elem->token.type == SUBEXP)\n    {\n      uintptr_t subidx = elem->token.opr.idx;\n      postorder (elem, mark_opt_subexp, (void *) subidx);\n    }\n\n  tree = create_tree (dfa, elem, NULL,\n\t\t      (end == -1 ? OP_DUP_ASTERISK : OP_ALT));\n  if (BE (tree == NULL, 0))\n    goto parse_dup_op_espace;\n\n/* From gnulib's \"intprops.h\":\n   True if the arithmetic type T is signed.  */\n#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n\n  /* This loop is actually executed only when end != -1,\n     to rewrite <re>{0,n} as (<re>(<re>...<re>?)?)?...  We have\n     already created the start+1-th copy.  */\n  if (TYPE_SIGNED (Idx) || end != -1)\n    for (i = start + 2; i <= end; ++i)\n      {\n\telem = duplicate_tree (elem, dfa);\n\ttree = create_tree (dfa, tree, elem, CONCAT);\n\tif (BE (elem == NULL || tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n\n\ttree = create_tree (dfa, tree, NULL, OP_ALT);\n\tif (BE (tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n      }\n\n  if (old_tree)\n    tree = create_tree (dfa, old_tree, tree, CONCAT);\n\n  return tree;\n\n parse_dup_op_espace:\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 145,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_byte": {
      "start_point": [
        2692,
        0
      ],
      "end_point": [
        2697,
        1
      ],
      "content": "static wint_t\nparse_byte (unsigned char b, re_charset_t *mbcset)\n{\n  wint_t wc = __btowc (b);\n  return wc == WEOF && !mbcset ? b : wc;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "wint_t"
      ]
    },
    "start_elem": {
      "start_point": [
        2720,
        23
      ],
      "end_point": [
        2823,
        1
      ],
      "content": "bracket_elem_t *end_elem)\n# endif /* not RE_ENABLE_I18N */\n{\n  unsigned int start_ch, end_ch;\n  /* Equivalence Classes and Character Classes can't be a range start/end.  */\n  if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t  || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t  0))\n    return REG_ERANGE;\n\n  /* We can handle no multi character collating elements without libc\n     support.  */\n  if (BE ((start_elem->type == COLL_SYM\n\t   && strlen ((char *) start_elem->opr.name) > 1)\n\t  || (end_elem->type == COLL_SYM\n\t      && strlen ((char *) end_elem->opr.name) > 1), 0))\n    return REG_ECOLLATE;\n\n# ifdef RE_ENABLE_I18N\n  {\n    wchar_t wc;\n    wint_t start_wc;\n    wint_t end_wc;\n\n    start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)\n\t\t? parse_byte (start_ch, mbcset) : start_elem->opr.wch);\n    end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)\n\t      ? parse_byte (end_ch, mbcset) : end_elem->opr.wch);\n    if (start_wc == WEOF || end_wc == WEOF)\n      return REG_ECOLLATE;\n    else if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_wc > end_wc, 0))\n      return REG_ERANGE;\n\n    /* Got valid collation sequence values, add them as a new entry.\n       However, for !_LIBC we have no collation elements: if the\n       character set is single byte, the single byte character set\n       that we build below suffices.  parse_bracket_exp passes\n       no MBCSET if dfa->mb_cur_max == 1.  */\n    if (mbcset)\n      {\n\t/* Check the space of the arrays.  */\n\tif (BE (*range_alloc == mbcset->nranges, 0))\n\t  {\n\t    /* There is not enough space, need realloc.  */\n\t    wchar_t *new_array_start, *new_array_end;\n\t    Idx new_nranges;\n\n\t    /* +1 in case of mbcset->nranges is 0.  */\n\t    new_nranges = 2 * mbcset->nranges + 1;\n\t    /* Use realloc since mbcset->range_starts and mbcset->range_ends\n\t       are NULL if *range_alloc == 0.  */\n\t    new_array_start = re_realloc (mbcset->range_starts, wchar_t,\n\t\t\t\t\t  new_nranges);\n\t    new_array_end = re_realloc (mbcset->range_ends, wchar_t,\n\t\t\t\t\tnew_nranges);\n\n\t    if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t      {\n\t\tre_free (new_array_start);\n\t\tre_free (new_array_end);\n\t\treturn REG_ESPACE;\n\t      }\n\n\t    mbcset->range_starts = new_array_start;\n\t    mbcset->range_ends = new_array_end;\n\t    *range_alloc = new_nranges;\n\t  }\n\n\tmbcset->range_starts[mbcset->nranges] = start_wc;\n\tmbcset->range_ends[mbcset->nranges++] = end_wc;\n      }\n\n    /* Build the table for single byte characters.  */\n    for (wc = 0; wc < SBC_MAX; ++wc)\n      {\n\tif (start_wc <= wc && wc <= end_wc)\n\t  bitset_set (sbcset, wc);\n      }\n  }\n# else /* not RE_ENABLE_I18N */\n  {\n    unsigned int ch;\n    start_ch = ((start_elem->type == SB_CHAR ) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR ) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    if (start_ch > end_ch)\n      return REG_ERANGE;\n    /* Build the table for single byte characters.  */\n    for (ch = 0; ch < SBC_MAX; ++ch)\n      if (start_ch <= ch  && ch <= end_ch)\n\tbitset_set (sbcset, ch);\n  }\n# endif /* not RE_ENABLE_I18N */\n  return REG_NOERROR;\n}",
      "lines": 104,
      "depth": 16,
      "decorators": null
    },
    "parse_bracket_exp": {
      "start_point": [
        2856,
        0
      ],
      "end_point": [
        3401,
        1
      ],
      "content": "static bin_tree_t *\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)\n{\n#ifdef _LIBC\n  const unsigned char *collseqmb;\n  const char *collseqwc;\n  uint32_t nrules;\n  int32_t table_size;\n  const int32_t *symb_table;\n  const unsigned char *extra;\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Seek the collating symbol entry corresponding to NAME.\n     Return the index of the symbol in the SYMB_TABLE,\n     or -1 if not found.  */\n\n  auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Look up the collation sequence value of BR_ELEM.\n     Return the value if succeeded, UINT_MAX otherwise.  */\n\n  auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the range expression which starts from START_ELEM, and ends\n     at END_ELEM.  The result are written to MBCSET and SBCSET.\n     RANGE_ALLOC is the allocated size of mbcset->range_starts, and\n     mbcset->range_ends, is a pointer argument since we may\n     update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the collating element which is represented by NAME.\n     The result are written to MBCSET and SBCSET.\n     COLL_SYM_ALLOC is the allocated size of mbcset->coll_sym, is a\n     pointer argument since we may update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }\n#endif\n\n  re_token_t br_token;\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx coll_sym_alloc = 0, range_alloc = 0, mbchar_alloc = 0;\n  Idx equiv_class_alloc = 0, char_class_alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  bool non_match = false;\n  bin_tree_t *work_tree;\n  int token_len;\n  bool first_round = true;\n#ifdef _LIBC\n  collseqmb = (const unsigned char *)\n    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n  nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules)\n    {\n      /*\n      if (MB_CUR_MAX > 1)\n      */\n      collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n      table_size = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_SYMB_HASH_SIZEMB);\n      symb_table = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t  _NL_COLLATE_SYMB_TABLEMB);\n      extra = (const unsigned char *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t   _NL_COLLATE_SYMB_EXTRAMB);\n    }\n#endif\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else\n  if (BE (sbcset == NULL, 0))\n#endif /* RE_ENABLE_I18N */\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      re_free (mbcset);\n#endif\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  token_len = peek_token_bracket (token, regexp, syntax);\n  if (BE (token->type == END_OF_RE, 0))\n    {\n      *err = REG_BADPAT;\n      goto parse_bracket_exp_free_return;\n    }\n  if (token->type == OP_NON_MATCH_LIST)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n      non_match = true;\n      if (syntax & RE_HAT_LISTS_NOT_NEWLINE)\n\tbitset_set (sbcset, '\\n');\n      re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_BADPAT;\n\t  goto parse_bracket_exp_free_return;\n\t}\n    }\n\n  /* We treat the first ']' as a normal character.  */\n  if (token->type == OP_CLOSE_BRACKET)\n    token->type = CHARACTER;\n\n  while (1)\n    {\n      bracket_elem_t start_elem, end_elem;\n      unsigned char start_name_buf[BRACKET_NAME_BUF_SIZE];\n      unsigned char end_name_buf[BRACKET_NAME_BUF_SIZE];\n      reg_errcode_t ret;\n      int token_len2 = 0;\n      bool is_range_exp = false;\n      re_token_t token2;\n\n      start_elem.opr.name = start_name_buf;\n      start_elem.type = COLL_SYM;\n      ret = parse_bracket_element (&start_elem, regexp, token, token_len, dfa,\n\t\t\t\t   syntax, first_round);\n      if (BE (ret != REG_NOERROR, 0))\n\t{\n\t  *err = ret;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      first_round = false;\n\n      /* Get information about the next token.  We need it in any case.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n\n      /* Do not check for ranges if we know they are not allowed.  */\n      if (start_elem.type != CHAR_CLASS && start_elem.type != EQUIV_CLASS)\n\t{\n\t  if (BE (token->type == END_OF_RE, 0))\n\t    {\n\t      *err = REG_EBRACK;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\t  if (token->type == OP_CHARSET_RANGE)\n\t    {\n\t      re_string_skip_bytes (regexp, token_len); /* Skip '-'.  */\n\t      token_len2 = peek_token_bracket (&token2, regexp, syntax);\n\t      if (BE (token2.type == END_OF_RE, 0))\n\t\t{\n\t\t  *err = REG_EBRACK;\n\t\t  goto parse_bracket_exp_free_return;\n\t\t}\n\t      if (token2.type == OP_CLOSE_BRACKET)\n\t\t{\n\t\t  /* We treat the last '-' as a normal character.  */\n\t\t  re_string_skip_bytes (regexp, -token_len);\n\t\t  token->type = CHARACTER;\n\t\t}\n\t      else\n\t\tis_range_exp = true;\n\t    }\n\t}\n\n      if (is_range_exp == true)\n\t{\n\t  end_elem.opr.name = end_name_buf;\n\t  end_elem.type = COLL_SYM;\n\t  ret = parse_bracket_element (&end_elem, regexp, &token2, token_len2,\n\t\t\t\t       dfa, syntax, true);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    {\n\t      *err = ret;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\n\t  token_len = peek_token_bracket (token, regexp, syntax);\n\n#ifdef _LIBC\n\t  *err = build_range_exp (sbcset, mbcset, &range_alloc,\n\t\t\t\t  &start_elem, &end_elem);\n#else\n# ifdef RE_ENABLE_I18N\n\t  *err = build_range_exp (syntax, sbcset,\n\t\t\t\t  dfa->mb_cur_max > 1 ? mbcset : NULL,\n\t\t\t\t  &range_alloc, &start_elem, &end_elem);\n# else\n\t  *err = build_range_exp (syntax, sbcset, &start_elem, &end_elem);\n# endif\n#endif /* RE_ENABLE_I18N */\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    goto parse_bracket_exp_free_return;\n\t}\n      else\n\t{\n\t  switch (start_elem.type)\n\t    {\n\t    case SB_CHAR:\n\t      bitset_set (sbcset, start_elem.opr.ch);\n\t      break;\n#ifdef RE_ENABLE_I18N\n\t    case MB_CHAR:\n\t      /* Check whether the array has enough space.  */\n\t      if (BE (mbchar_alloc == mbcset->nmbchars, 0))\n\t\t{\n\t\t  wchar_t *new_mbchars;\n\t\t  /* Not enough, realloc it.  */\n\t\t  /* +1 in case of mbcset->nmbchars is 0.  */\n\t\t  mbchar_alloc = 2 * mbcset->nmbchars + 1;\n\t\t  /* Use realloc since array is NULL if *alloc == 0.  */\n\t\t  new_mbchars = re_realloc (mbcset->mbchars, wchar_t,\n\t\t\t\t\t    mbchar_alloc);\n\t\t  if (BE (new_mbchars == NULL, 0))\n\t\t    goto parse_bracket_exp_espace;\n\t\t  mbcset->mbchars = new_mbchars;\n\t\t}\n\t      mbcset->mbchars[mbcset->nmbchars++] = start_elem.opr.wch;\n\t      break;\n#endif /* RE_ENABLE_I18N */\n\t    case EQUIV_CLASS:\n\t      *err = build_equiv_class (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\tmbcset, &equiv_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\tstart_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case COLL_SYM:\n\t      *err = build_collating_symbol (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\t     mbcset, &coll_sym_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\t     start_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case CHAR_CLASS:\n\t      *err = build_charclass (regexp->trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t      mbcset, &char_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t      (const char *) start_elem.opr.name,\n\t\t\t\t      syntax);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t       goto parse_bracket_exp_free_return;\n\t      break;\n\t    default:\n\t      assert (0);\n\t      break;\n\t    }\n\t}\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_EBRACK;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      if (token->type == OP_CLOSE_BRACKET)\n\tbreak;\n    }\n\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n\n  if (mbcset->nmbchars || mbcset->ncoll_syms || mbcset->nequiv_classes\n      || mbcset->nranges || (dfa->mb_cur_max > 1 && (mbcset->nchar_classes\n\t\t\t\t\t\t     || mbcset->non_match)))\n    {\n      bin_tree_t *mbc_tree;\n      int sbc_idx;\n      /* Build a tree for complex bracket.  */\n      dfa->has_mb_node = 1;\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n      for (sbc_idx = 0; sbc_idx < BITSET_WORDS; ++sbc_idx)\n\tif (sbcset[sbc_idx])\n\t  break;\n      /* If there are no bits set in sbcset, there is no point\n\t of having both SIMPLE_BRACKET and COMPLEX_BRACKET.  */\n      if (sbc_idx < BITSET_WORDS)\n\t{\n\t  /* Build a tree for simple bracket.  */\n\t  br_token.type = SIMPLE_BRACKET;\n\t  br_token.opr.sbcset = sbcset;\n\t  work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\n\t  /* Then join them by ALT node.  */\n\t  work_tree = create_tree (dfa, work_tree, mbc_tree, OP_ALT);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\t}\n      else\n\t{\n\t  re_free (sbcset);\n\t  work_tree = mbc_tree;\n\t}\n    }\n  else\n#endif /* not RE_ENABLE_I18N */\n    {\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif\n      /* Build a tree for simple bracket.  */\n      br_token.type = SIMPLE_BRACKET;\n      br_token.opr.sbcset = sbcset;\n      work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (work_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n    }\n  return work_tree;\n\n parse_bracket_exp_espace:\n  *err = REG_ESPACE;\n parse_bracket_exp_free_return:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  return NULL;\n}",
      "lines": 546,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "seek_collating_symbol_entry": {
      "start_point": [
        2873,
        2
      ],
      "end_point": [
        2893,
        5
      ],
      "content": "auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "int32_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "lookup_collation_sequence_value": {
      "start_point": [
        2899,
        2
      ],
      "end_point": [
        2958,
        5
      ],
      "content": "auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }",
      "lines": 60,
      "depth": 22,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_range_exp": {
      "start_point": [
        2967,
        2
      ],
      "end_point": [
        3040,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_collating_symbol": {
      "start_point": [
        3048,
        2
      ],
      "end_point": [
        3104,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "parse_bracket_element": {
      "start_point": [
        3405,
        0
      ],
      "end_point": [
        3439,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_element (bracket_elem_t *elem, re_string_t *regexp,\n\t\t       re_token_t *token, int token_len, re_dfa_t *dfa,\n\t\t       reg_syntax_t syntax, bool accept_hyphen)\n{\n#ifdef RE_ENABLE_I18N\n  int cur_char_size;\n  cur_char_size = re_string_char_size_at (regexp, re_string_cur_idx (regexp));\n  if (cur_char_size > 1)\n    {\n      elem->type = MB_CHAR;\n      elem->opr.wch = re_string_wchar_at (regexp, re_string_cur_idx (regexp));\n      re_string_skip_bytes (regexp, cur_char_size);\n      return REG_NOERROR;\n    }\n#endif /* RE_ENABLE_I18N */\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n  if (token->type == OP_OPEN_COLL_ELEM || token->type == OP_OPEN_CHAR_CLASS\n      || token->type == OP_OPEN_EQUIV_CLASS)\n    return parse_bracket_symbol (elem, regexp, token);\n  if (BE (token->type == OP_CHARSET_RANGE, 0) && !accept_hyphen)\n    {\n      /* A '-' must only appear as anything but a range indicator before\n\t the closing bracket.  Everything else is an error.  */\n      re_token_t token2;\n      (void) peek_token_bracket (&token2, regexp, syntax);\n      if (token2.type != OP_CLOSE_BRACKET)\n\t/* The actual error value is not standardized since this whole\n\t   case is undefined.  But ERANGE makes good sense.  */\n\treturn REG_ERANGE;\n    }\n  elem->type = SB_CHAR;\n  elem->opr.ch = token->opr.c;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "parse_bracket_symbol": {
      "start_point": [
        3445,
        0
      ],
      "end_point": [
        3484,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_symbol (bracket_elem_t *elem, re_string_t *regexp,\n\t\t      re_token_t *token)\n{\n  unsigned char ch, delim = token->opr.c;\n  int i = 0;\n  if (re_string_eoi(regexp))\n    return REG_EBRACK;\n  for (;; ++i)\n    {\n      if (i >= BRACKET_NAME_BUF_SIZE)\n\treturn REG_EBRACK;\n      if (token->type == OP_OPEN_CHAR_CLASS)\n\tch = re_string_fetch_byte_case (regexp);\n      else\n\tch = re_string_fetch_byte (regexp);\n      if (re_string_eoi(regexp))\n\treturn REG_EBRACK;\n      if (ch == delim && re_string_peek_byte (regexp, 0) == ']')\n\tbreak;\n      elem->opr.name[i] = ch;\n    }\n  re_string_skip_bytes (regexp, 1);\n  elem->opr.name[i] = '\\0';\n  switch (token->type)\n    {\n    case OP_OPEN_COLL_ELEM:\n      elem->type = COLL_SYM;\n      break;\n    case OP_OPEN_EQUIV_CLASS:\n      elem->type = EQUIV_CLASS;\n      break;\n    case OP_OPEN_CHAR_CLASS:\n      elem->type = CHAR_CLASS;\n      break;\n    default:\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "build_charclass": {
      "start_point": [
        3592,
        9
      ],
      "end_point": [
        3666,
        1
      ],
      "content": "char *class_name, reg_syntax_t syntax)\n#endif /* not RE_ENABLE_I18N */\n{\n  int i;\n  const char *name = class_name;\n\n  /* In case of REG_ICASE \"upper\" and \"lower\" match the both of\n     upper and lower cases.  */\n  if ((syntax & RE_ICASE)\n      && (strcmp (name, \"upper\") == 0 || strcmp (name, \"lower\") == 0))\n    name = \"alpha\";\n\n#ifdef RE_ENABLE_I18N\n  /* Check the space of the arrays.  */\n  if (BE (*char_class_alloc == mbcset->nchar_classes, 0))\n    {\n      /* Not enough, realloc it.  */\n      /* +1 in case of mbcset->nchar_classes is 0.  */\n      Idx new_char_class_alloc = 2 * mbcset->nchar_classes + 1;\n      /* Use realloc since array is NULL if *alloc == 0.  */\n      wctype_t *new_char_classes = re_realloc (mbcset->char_classes, wctype_t,\n\t\t\t\t\t       new_char_class_alloc);\n      if (BE (new_char_classes == NULL, 0))\n\treturn REG_ESPACE;\n      mbcset->char_classes = new_char_classes;\n      *char_class_alloc = new_char_class_alloc;\n    }\n  mbcset->char_classes[mbcset->nchar_classes++] = __wctype (name);\n#endif /* RE_ENABLE_I18N */\n\n#define BUILD_CHARCLASS_LOOP(ctype_func)\t\\\n  do {\t\t\t\t\t\t\\\n    if (BE (trans != NULL, 0))\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, trans[i]);\t\\\n      }\t\t\t\t\t\t\\\n    else\t\t\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, i);\t\t\\\n      }\t\t\t\t\t\t\\\n  } while (0)\n\n  if (strcmp (name, \"alnum\") == 0)\n    BUILD_CHARCLASS_LOOP (isalnum);\n  else if (strcmp (name, \"cntrl\") == 0)\n    BUILD_CHARCLASS_LOOP (iscntrl);\n  else if (strcmp (name, \"lower\") == 0)\n    BUILD_CHARCLASS_LOOP (islower);\n  else if (strcmp (name, \"space\") == 0)\n    BUILD_CHARCLASS_LOOP (isspace);\n  else if (strcmp (name, \"alpha\") == 0)\n    BUILD_CHARCLASS_LOOP (isalpha);\n  else if (strcmp (name, \"digit\") == 0)\n    BUILD_CHARCLASS_LOOP (isdigit);\n  else if (strcmp (name, \"print\") == 0)\n    BUILD_CHARCLASS_LOOP (isprint);\n  else if (strcmp (name, \"upper\") == 0)\n    BUILD_CHARCLASS_LOOP (isupper);\n  else if (strcmp (name, \"blank\") == 0)\n    BUILD_CHARCLASS_LOOP (isblank);\n  else if (strcmp (name, \"graph\") == 0)\n    BUILD_CHARCLASS_LOOP (isgraph);\n  else if (strcmp (name, \"punct\") == 0)\n    BUILD_CHARCLASS_LOOP (ispunct);\n  else if (strcmp (name, \"xdigit\") == 0)\n    BUILD_CHARCLASS_LOOP (isxdigit);\n  else\n    return REG_ECTYPE;\n\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 20,
      "decorators": null
    },
    "build_charclass_op": {
      "start_point": [
        3668,
        0
      ],
      "end_point": [
        3772,
        1
      ],
      "content": "static bin_tree_t *\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)\n{\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  reg_errcode_t ret;\n  re_token_t br_token;\n  bin_tree_t *tree;\n\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n  if (BE (sbcset == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n  if (BE (mbcset == NULL, 0))\n    {\n      re_free (sbcset);\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  mbcset->non_match = non_match;\n#endif /* RE_ENABLE_I18N */\n\n  /* We don't care the syntax in this case.  */\n  ret = build_charclass (trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t mbcset, &alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t class_name, 0);\n\n  if (BE (ret != REG_NOERROR, 0))\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n      *err = ret;\n      return NULL;\n    }\n  /* \\w match '_' also.  */\n  for (; *extra; extra++)\n    bitset_set (sbcset, *extra);\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n#endif\n\n  /* Build a tree for simple bracket.  */\n#if defined GCC_LINT || defined lint\n  memset (&br_token, 0, sizeof br_token);\n#endif\n  br_token.type = SIMPLE_BRACKET;\n  br_token.opr.sbcset = sbcset;\n  tree = create_token_tree (dfa, NULL, NULL, &br_token);\n  if (BE (tree == NULL, 0))\n    goto build_word_op_espace;\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      bin_tree_t *mbc_tree;\n      /* Build a tree for complex bracket.  */\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      dfa->has_mb_node = 1;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto build_word_op_espace;\n      /* Then join them by ALT node.  */\n      tree = create_tree (dfa, tree, mbc_tree, OP_ALT);\n      if (BE (mbc_tree != NULL, 1))\n\treturn tree;\n    }\n  else\n    {\n      free_charset (mbcset);\n      return tree;\n    }\n#else /* not RE_ENABLE_I18N */\n  return tree;\n#endif /* not RE_ENABLE_I18N */\n\n build_word_op_espace:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 105,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)",
        "*"
      ]
    },
    "fetch_number": {
      "start_point": [
        3780,
        0
      ],
      "end_point": [
        3800,
        1
      ],
      "content": "static Idx\nfetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)\n{\n  Idx num = -1;\n  unsigned char c;\n  while (1)\n    {\n      fetch_token (token, input, syntax);\n      c = token->opr.c;\n      if (BE (token->type == END_OF_RE, 0))\n\treturn -2;\n      if (token->type == OP_CLOSE_DUP_NUM || c == ',')\n\tbreak;\n      num = ((token->type != CHARACTER || c < '0' || '9' < c || num == -2)\n\t     ? -2\n\t     : num == -1\n\t     ? c - '0'\n\t     : MIN (RE_DUP_MAX + 1, num * 10 + c - '0'));\n    }\n  return num;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "free_charset": {
      "start_point": [
        3803,
        0
      ],
      "end_point": [
        3815,
        1
      ],
      "content": "static void\nfree_charset (re_charset_t *cset)\n{\n  re_free (cset->mbchars);\n# ifdef _LIBC\n  re_free (cset->coll_syms);\n  re_free (cset->equiv_classes);\n  re_free (cset->range_starts);\n  re_free (cset->range_ends);\n# endif\n  re_free (cset->char_classes);\n  re_free (cset);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_tree": {
      "start_point": [
        3822,
        0
      ],
      "end_point": [
        3832,
        1
      ],
      "content": "static bin_tree_t *\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)\n{\n  re_token_t t;\n#if defined GCC_LINT || defined lint\n  memset (&t, 0, sizeof t);\n#endif\n  t.type = type;\n  return create_token_tree (dfa, left, right, &t);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)",
        "*"
      ]
    },
    "create_token_tree": {
      "start_point": [
        3834,
        0
      ],
      "end_point": [
        3866,
        1
      ],
      "content": "static bin_tree_t *\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)\n{\n  bin_tree_t *tree;\n  if (BE (dfa->str_tree_storage_idx == BIN_TREE_STORAGE_SIZE, 0))\n    {\n      bin_tree_storage_t *storage = re_malloc (bin_tree_storage_t, 1);\n\n      if (storage == NULL)\n\treturn NULL;\n      storage->next = dfa->str_tree_storage;\n      dfa->str_tree_storage = storage;\n      dfa->str_tree_storage_idx = 0;\n    }\n  tree = &dfa->str_tree_storage->data[dfa->str_tree_storage_idx++];\n\n  tree->parent = NULL;\n  tree->left = left;\n  tree->right = right;\n  tree->token = *token;\n  tree->token.duplicated = 0;\n  tree->token.opt_subexp = 0;\n  tree->first = NULL;\n  tree->next = NULL;\n  tree->node_idx = -1;\n\n  if (left != NULL)\n    left->parent = tree;\n  if (right != NULL)\n    right->parent = tree;\n  return tree;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)",
        "*"
      ]
    },
    "mark_opt_subexp": {
      "start_point": [
        3871,
        0
      ],
      "end_point": [
        3879,
        1
      ],
      "content": "static reg_errcode_t\nmark_opt_subexp (void *extra, bin_tree_t *node)\n{\n  Idx idx = (uintptr_t) extra;\n  if (node->token.type == SUBEXP && node->token.opr.idx == idx)\n    node->token.opt_subexp = 1;\n\n  return REG_NOERROR;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "free_token": {
      "start_point": [
        3883,
        0
      ],
      "end_point": [
        3893,
        1
      ],
      "content": "static void\nfree_token (re_token_t *node)\n{\n#ifdef RE_ENABLE_I18N\n  if (node->type == COMPLEX_BRACKET && node->duplicated == 0)\n    free_charset (node->opr.mbcset);\n  else\n#endif /* RE_ENABLE_I18N */\n    if (node->type == SIMPLE_BRACKET && node->duplicated == 0)\n      re_free (node->opr.sbcset);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_tree": {
      "start_point": [
        3898,
        0
      ],
      "end_point": [
        3903,
        1
      ],
      "content": "static reg_errcode_t\nfree_tree (void *extra, bin_tree_t *node)\n{\n  free_token (&node->token);\n  return REG_NOERROR;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_tree": {
      "start_point": [
        3911,
        0
      ],
      "end_point": [
        3949,
        1
      ],
      "content": "static bin_tree_t *\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)\n{\n  const bin_tree_t *node;\n  bin_tree_t *dup_root;\n  bin_tree_t **p_new = &dup_root, *dup_node = root->parent;\n\n  for (node = root; ; )\n    {\n      /* Create a new tree and link it back to the current parent.  */\n      *p_new = create_token_tree (dfa, NULL, NULL, &node->token);\n      if (*p_new == NULL)\n\treturn NULL;\n      (*p_new)->parent = dup_node;\n      (*p_new)->token.duplicated = 1;\n      dup_node = *p_new;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\t{\n\t  node = node->left;\n\t  p_new = &dup_node->left;\n\t}\n      else\n\t{\n\t  const bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      dup_node = dup_node->parent;\n\t      if (!node)\n\t\treturn dup_root;\n\t    }\n\t  node = node->right;\n\t  p_new = &dup_node->right;\n\t}\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/regex.c": {},
  "tar/tar-1.30/gnu/regex.h": {},
  "tar/tar-1.30/gnu/regexec.c": {
    "regexec": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "int\nregexec (const regex_t *_Restrict_ preg, const char *_Restrict_ string,\n\t size_t nmatch, regmatch_t pmatch[], int eflags)\n{\n  reg_errcode_t err;\n  Idx start, length;\n  re_dfa_t *dfa = preg->buffer;\n\n  if (eflags & ~(REG_NOTBOL | REG_NOTEOL | REG_STARTEND))\n    return REG_BADPAT;\n\n  if (eflags & REG_STARTEND)\n    {\n      start = pmatch[0].rm_so;\n      length = pmatch[0].rm_eo;\n    }\n  else\n    {\n      start = 0;\n      length = strlen (string);\n    }\n\n  lock_lock (dfa->lock);\n  if (preg->no_sub)\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, 0, NULL, eflags);\n  else\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, nmatch, pmatch, eflags);\n  lock_unlock (dfa->lock);\n  return err != REG_NOERROR;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__compat_regexec": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "int\nattribute_compat_text_section\n__compat_regexec (const regex_t *_Restrict_ preg,\n\t\t  const char *_Restrict_ string, size_t nmatch,\n\t\t  regmatch_t pmatch[], int eflags)\n{\n  return regexec (preg, string, nmatch, pmatch,\n\t\t  eflags & (REG_NOTBOL | REG_NOTEOL));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "re_match": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "regoff_t\nre_match (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t  Idx start, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, 0, length, regs, true);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "regoff_t\nre_search (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t   Idx start, regoff_t range, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, range, length, regs,\n\t\t\t false);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_match_2": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "regoff_t\nre_match_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t    const char *string2, Idx length2, Idx start,\n\t    struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, 0, regs, stop, true);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search_2": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "regoff_t\nre_search_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t     const char *string2, Idx length2, Idx start, regoff_t range,\n\t     struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, range, regs, stop, false);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search_2_stub": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "static regoff_t\ninternal_function\nre_search_2_stub (struct re_pattern_buffer *bufp, const char *string1,\n\t\t  Idx length1, const char *string2, Idx length2, Idx start,\n\t\t  regoff_t range, struct re_registers *regs,\n\t\t  Idx stop, bool ret_len)\n{\n  const char *str;\n  regoff_t rval;\n  Idx len;\n  char *s = NULL;\n\n  if (BE ((length1 < 0 || length2 < 0 || stop < 0\n           || INT_ADD_WRAPV (length1, length2, &len)),\n          0))\n    return -2;\n\n  /* Concatenate the strings.  */\n  if (length2 > 0)\n    if (length1 > 0)\n      {\n\ts = re_malloc (char, len);\n\n\tif (BE (s == NULL, 0))\n\t  return -2;\n#ifdef _LIBC\n\tmemcpy (__mempcpy (s, string1, length1), string2, length2);\n#else\n\tmemcpy (s, string1, length1);\n\tmemcpy (s + length1, string2, length2);\n#endif\n\tstr = s;\n      }\n    else\n      str = string2;\n  else\n    str = string1;\n\n  rval = re_search_stub (bufp, str, len, start, range, stop, regs,\n\t\t\t ret_len);\n  re_free (s);\n  return rval;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "regoff_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_search_stub": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "static regoff_t\ninternal_function\nre_search_stub (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t\tIdx start, regoff_t range, Idx stop, struct re_registers *regs,\n\t\tbool ret_len)\n{\n  reg_errcode_t result;\n  regmatch_t *pmatch;\n  Idx nregs;\n  regoff_t rval;\n  int eflags = 0;\n  re_dfa_t *dfa = bufp->buffer;\n  Idx last_start = start + range;\n\n  /* Check for out-of-range.  */\n  if (BE (start < 0 || start > length, 0))\n    return -1;\n  if (BE (length < last_start || (0 <= range && last_start < start), 0))\n    last_start = length;\n  else if (BE (last_start < 0 || (range < 0 && start <= last_start), 0))\n    last_start = 0;\n\n  lock_lock (dfa->lock);\n\n  eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;\n  eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;\n\n  /* Compile fastmap if we haven't yet.  */\n  if (start < last_start && bufp->fastmap != NULL && !bufp->fastmap_accurate)\n    re_compile_fastmap (bufp);\n\n  if (BE (bufp->no_sub, 0))\n    regs = NULL;\n\n  /* We need at least 1 register.  */\n  if (regs == NULL)\n    nregs = 1;\n  else if (BE (bufp->regs_allocated == REGS_FIXED\n\t       && regs->num_regs <= bufp->re_nsub, 0))\n    {\n      nregs = regs->num_regs;\n      if (BE (nregs < 1, 0))\n\t{\n\t  /* Nothing can be copied to regs.  */\n\t  regs = NULL;\n\t  nregs = 1;\n\t}\n    }\n  else\n    nregs = bufp->re_nsub + 1;\n  pmatch = re_malloc (regmatch_t, nregs);\n  if (BE (pmatch == NULL, 0))\n    {\n      rval = -2;\n      goto out;\n    }\n\n  result = re_search_internal (bufp, string, length, start, last_start, stop,\n\t\t\t       nregs, pmatch, eflags);\n\n  rval = 0;\n\n  /* I hope we needn't fill their regs with -1's when no match was found.  */\n  if (result != REG_NOERROR)\n    rval = result == REG_NOMATCH ? -1 : -2;\n  else if (regs != NULL)\n    {\n      /* If caller wants register contents data back, copy them.  */\n      bufp->regs_allocated = re_copy_regs (regs, pmatch, nregs,\n\t\t\t\t\t   bufp->regs_allocated);\n      if (BE (bufp->regs_allocated == REGS_UNALLOCATED, 0))\n\trval = -2;\n    }\n\n  if (BE (rval == 0, 1))\n    {\n      if (ret_len)\n\t{\n\t  assert (pmatch[0].rm_so == start);\n\t  rval = pmatch[0].rm_eo - start;\n\t}\n      else\n\trval = pmatch[0].rm_so;\n    }\n  re_free (pmatch);\n out:\n  lock_unlock (dfa->lock);\n  return rval;\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "regoff_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_copy_regs": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        550,
        1
      ],
      "content": "static unsigned\ninternal_function\nre_copy_regs (struct re_registers *regs, regmatch_t *pmatch, Idx nregs,\n\t      int regs_allocated)\n{\n  int rval = REGS_REALLOCATE;\n  Idx i;\n  Idx need_regs = nregs + 1;\n  /* We need one extra element beyond 'num_regs' for the '-1' marker GNU code\n     uses.  */\n\n  /* Have the register data arrays been allocated?  */\n  if (regs_allocated == REGS_UNALLOCATED)\n    { /* No.  So allocate them with malloc.  */\n      regs->start = re_malloc (regoff_t, need_regs);\n      if (BE (regs->start == NULL, 0))\n\treturn REGS_UNALLOCATED;\n      regs->end = re_malloc (regoff_t, need_regs);\n      if (BE (regs->end == NULL, 0))\n\t{\n\t  re_free (regs->start);\n\t  return REGS_UNALLOCATED;\n\t}\n      regs->num_regs = need_regs;\n    }\n  else if (regs_allocated == REGS_REALLOCATE)\n    { /* Yes.  If we need more elements than were already\n\t allocated, reallocate them.  If we need fewer, just\n\t leave it alone.  */\n      if (BE (need_regs > regs->num_regs, 0))\n\t{\n\t  regoff_t *new_start = re_realloc (regs->start, regoff_t, need_regs);\n\t  regoff_t *new_end;\n\t  if (BE (new_start == NULL, 0))\n\t    return REGS_UNALLOCATED;\n\t  new_end = re_realloc (regs->end, regoff_t, need_regs);\n\t  if (BE (new_end == NULL, 0))\n\t    {\n\t      re_free (new_start);\n\t      return REGS_UNALLOCATED;\n\t    }\n\t  regs->start = new_start;\n\t  regs->end = new_end;\n\t  regs->num_regs = need_regs;\n\t}\n    }\n  else\n    {\n      assert (regs_allocated == REGS_FIXED);\n      /* This function may not be called with REGS_FIXED and nregs too big.  */\n      assert (regs->num_regs >= nregs);\n      rval = REGS_FIXED;\n    }\n\n  /* Copy the regs.  */\n  for (i = 0; i < nregs; ++i)\n    {\n      regs->start[i] = pmatch[i].rm_so;\n      regs->end[i] = pmatch[i].rm_eo;\n    }\n  for ( ; i < regs->num_regs; ++i)\n    regs->start[i] = regs->end[i] = -1;\n\n  return rval;\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned\ninternal_function",
        "unsigned",
        "internal_function"
      ]
    },
    "re_set_registers": {
      "start_point": [
        565,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "void\nre_set_registers (struct re_pattern_buffer *bufp, struct re_registers *regs,\n\t\t  __re_size_t num_regs, regoff_t *starts, regoff_t *ends)\n{\n  if (num_regs)\n    {\n      bufp->regs_allocated = REGS_REALLOCATE;\n      regs->num_regs = num_regs;\n      regs->start = starts;\n      regs->end = ends;\n    }\n  else\n    {\n      bufp->regs_allocated = REGS_UNALLOCATED;\n      regs->num_regs = 0;\n      regs->start = regs->end = NULL;\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "re_exec": {
      "start_point": [
        593,
        0
      ],
      "end_point": [
        598,
        1
      ],
      "content": "weak_function\n# endif\nre_exec (const char *s)\n{\n  return 0 == regexec (&re_comp_buf, s, 0, NULL, 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "weak_function",
        "# endif",
        "# endif"
      ]
    },
    "re_search_internal": {
      "start_point": [
        613,
        33
      ],
      "end_point": [
        944,
        1
      ],
      "content": "internal_function\nre_search_internal (const regex_t *preg, const char *string, Idx length,\n\t\t    Idx start, Idx last_start, Idx stop, size_t nmatch,\n\t\t    regmatch_t pmatch[], int eflags)\n{\n  reg_errcode_t err;\n  const re_dfa_t *dfa = preg->buffer;\n  Idx left_lim, right_lim;\n  int incr;\n  bool fl_longest_match;\n  int match_kind;\n  Idx match_first;\n  Idx match_last = -1;\n  Idx extra_nmatch;\n  bool sb;\n  int ch;\n#if defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)\n  re_match_context_t mctx = { .dfa = dfa };\n#else\n  re_match_context_t mctx;\n#endif\n  char *fastmap = ((preg->fastmap != NULL && preg->fastmap_accurate\n\t\t    && start != last_start && !preg->can_be_null)\n\t\t   ? preg->fastmap : NULL);\n  RE_TRANSLATE_TYPE t = preg->translate;\n\n#if !(defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))\n  memset (&mctx, '\\0', sizeof (re_match_context_t));\n  mctx.dfa = dfa;\n#endif\n\n  extra_nmatch = (nmatch > preg->re_nsub) ? nmatch - (preg->re_nsub + 1) : 0;\n  nmatch -= extra_nmatch;\n\n  /* Check if the DFA haven't been compiled.  */\n  if (BE (preg->used == 0 || dfa->init_state == NULL\n\t  || dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t  || dfa->init_state_begbuf == NULL, 0))\n    return REG_NOMATCH;\n\n#ifdef DEBUG\n  /* We assume front-end functions already check them.  */\n  assert (0 <= last_start && last_start <= length);\n#endif\n\n  /* If initial states with non-begbuf contexts have no elements,\n     the regex must be anchored.  If preg->newline_anchor is set,\n     we'll never use init_state_nl, so do not check it.  */\n  if (dfa->init_state->nodes.nelem == 0\n      && dfa->init_state_word->nodes.nelem == 0\n      && (dfa->init_state_nl->nodes.nelem == 0\n\t  || !preg->newline_anchor))\n    {\n      if (start != 0 && last_start != 0)\n        return REG_NOMATCH;\n      start = last_start = 0;\n    }\n\n  /* We must check the longest matching, if nmatch > 0.  */\n  fl_longest_match = (nmatch != 0 || dfa->nbackref);\n\n  err = re_string_allocate (&mctx.input, string, length, dfa->nodes_len + 1,\n\t\t\t    preg->translate, (preg->syntax & RE_ICASE) != 0,\n\t\t\t    dfa);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n  mctx.input.stop = stop;\n  mctx.input.raw_stop = stop;\n  mctx.input.newline_anchor = preg->newline_anchor;\n\n  err = match_ctx_init (&mctx, eflags, dfa->nbackref * 2);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* We will log all the DFA states through which the dfa pass,\n     if nmatch > 1, or this dfa has \"multibyte node\", which is a\n     back-reference or a node which can accept multibyte character or\n     multi character collating element.  */\n  if (nmatch > 1 || dfa->has_mb_node)\n    {\n      /* Avoid overflow.  */\n      if (BE ((MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *))\n               <= mctx.input.bufs_len), 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n\n      mctx.state_log = re_malloc (re_dfastate_t *, mctx.input.bufs_len + 1);\n      if (BE (mctx.state_log == NULL, 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n    }\n  else\n    mctx.state_log = NULL;\n\n  match_first = start;\n  mctx.input.tip_context = (eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF;\n\n  /* Check incrementally whether the input string matches.  */\n  incr = (last_start < start) ? -1 : 1;\n  left_lim = (last_start < start) ? last_start : start;\n  right_lim = (last_start < start) ? start : last_start;\n  sb = dfa->mb_cur_max == 1;\n  match_kind =\n    (fastmap\n     ? ((sb || !(preg->syntax & RE_ICASE || t) ? 4 : 0)\n\t| (start <= last_start ? 2 : 0)\n\t| (t != NULL ? 1 : 0))\n     : 8);\n\n  for (;; match_first += incr)\n    {\n      err = REG_NOMATCH;\n      if (match_first < left_lim || right_lim < match_first)\n\tgoto free_return;\n\n      /* Advance as rapidly as possible through the string, until we\n\t find a plausible place to start matching.  This may be done\n\t with varying efficiency, so there are various possibilities:\n\t only the most common of them are specialized, in order to\n\t save on code size.  We use a switch statement for speed.  */\n      switch (match_kind)\n\t{\n\tcase 8:\n\t  /* No fastmap.  */\n\t  break;\n\n\tcase 7:\n\t  /* Fastmap with single-byte translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[t[(unsigned char) string[match_first]]])\n\t    ++match_first;\n\t  goto forward_match_found_start_or_reached_end;\n\n\tcase 6:\n\t  /* Fastmap without translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[(unsigned char) string[match_first]])\n\t    ++match_first;\n\n\tforward_match_found_start_or_reached_end:\n\t  if (BE (match_first == right_lim, 0))\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (!fastmap[t ? t[ch] : ch])\n\t\tgoto free_return;\n\t    }\n\t  break;\n\n\tcase 4:\n\tcase 5:\n\t  /* Fastmap without multi-byte translation, match backwards.  */\n\t  while (match_first >= left_lim)\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (fastmap[t ? t[ch] : ch])\n\t\tbreak;\n\t      --match_first;\n\t    }\n\t  if (match_first < left_lim)\n\t    goto free_return;\n\t  break;\n\n\tdefault:\n\t  /* In this case, we can't determine easily the current byte,\n\t     since it might be a component byte of a multibyte\n\t     character.  Then we use the constructed buffer instead.  */\n\t  for (;;)\n\t    {\n\t      /* If MATCH_FIRST is out of the valid range, reconstruct the\n\t\t buffers.  */\n\t      __re_size_t offset = match_first - mctx.input.raw_mbs_idx;\n\t      if (BE (offset >= (__re_size_t) mctx.input.valid_raw_len, 0))\n\t\t{\n\t\t  err = re_string_reconstruct (&mctx.input, match_first,\n\t\t\t\t\t       eflags);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    goto free_return;\n\n\t\t  offset = match_first - mctx.input.raw_mbs_idx;\n\t\t}\n\t      /* If MATCH_FIRST is out of the buffer, leave it as '\\0'.\n\t\t Note that MATCH_FIRST must not be smaller than 0.  */\n\t      ch = (match_first >= length\n\t\t    ? 0 : re_string_byte_at (&mctx.input, offset));\n\t      if (fastmap[ch])\n\t\tbreak;\n\t      match_first += incr;\n\t      if (match_first < left_lim || match_first > right_lim)\n\t\t{\n\t\t  err = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    }\n\t  break;\n\t}\n\n      /* Reconstruct the buffers so that the matcher can assume that\n\t the matching starts from the beginning of the buffer.  */\n      err = re_string_reconstruct (&mctx.input, match_first, eflags);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n#ifdef RE_ENABLE_I18N\n     /* Don't consider this char as a possible match start if it part,\n\tyet isn't the head, of a multibyte character.  */\n      if (!sb && !re_string_first_byte (&mctx.input, 0))\n\tcontinue;\n#endif\n\n      /* It seems to be appropriate one, then use the matcher.  */\n      /* We assume that the matching starts from 0.  */\n      mctx.state_log_top = mctx.nbkref_ents = mctx.max_mb_elem_len = 0;\n      match_last = check_matching (&mctx, fl_longest_match,\n\t\t\t\t   start <= last_start ? &match_first : NULL);\n      if (match_last != -1)\n\t{\n\t  if (BE (match_last == -2, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  else\n\t    {\n\t      mctx.match_last = match_last;\n\t      if ((!preg->no_sub && nmatch > 1) || dfa->nbackref)\n\t\t{\n\t\t  re_dfastate_t *pstate = mctx.state_log[match_last];\n\t\t  mctx.last_node = check_halt_state_context (&mctx, pstate,\n\t\t\t\t\t\t\t     match_last);\n\t\t}\n\t      if ((!preg->no_sub && nmatch > 1 && dfa->has_plural_match)\n\t\t  || dfa->nbackref)\n\t\t{\n\t\t  err = prune_impossible_nodes (&mctx);\n\t\t  if (err == REG_NOERROR)\n\t\t    break;\n\t\t  if (BE (err != REG_NOMATCH, 0))\n\t\t    goto free_return;\n\t\t  match_last = -1;\n\t\t}\n\t      else\n\t\tbreak; /* We found a match.  */\n\t    }\n\t}\n\n      match_ctx_clean (&mctx);\n    }\n\n#ifdef DEBUG\n  assert (match_last != -1);\n  assert (err == REG_NOERROR);\n#endif\n\n  /* Set pmatch[] if we need.  */\n  if (nmatch > 0)\n    {\n      Idx reg_idx;\n\n      /* Initialize registers.  */\n      for (reg_idx = 1; reg_idx < nmatch; ++reg_idx)\n\tpmatch[reg_idx].rm_so = pmatch[reg_idx].rm_eo = -1;\n\n      /* Set the points where matching start/end.  */\n      pmatch[0].rm_so = 0;\n      pmatch[0].rm_eo = mctx.match_last;\n      /* FIXME: This function should fail if mctx.match_last exceeds\n\t the maximum possible regoff_t value.  We need a new error\n\t code REG_OVERFLOW.  */\n\n      if (!preg->no_sub && nmatch > 1)\n\t{\n\t  err = set_regs (preg, &mctx, nmatch, pmatch,\n\t\t\t  dfa->has_plural_match && dfa->nbackref > 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* At last, add the offset to each register, since we slid\n\t the buffers so that we could assume that the matching starts\n\t from 0.  */\n      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\tif (pmatch[reg_idx].rm_so != -1)\n\t  {\n#ifdef RE_ENABLE_I18N\n\t    if (BE (mctx.input.offsets_needed != 0, 0))\n\t      {\n\t\tpmatch[reg_idx].rm_so =\n\t\t  (pmatch[reg_idx].rm_so == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_so]);\n\t\tpmatch[reg_idx].rm_eo =\n\t\t  (pmatch[reg_idx].rm_eo == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_eo]);\n\t      }\n#else\n\t    assert (mctx.input.offsets_needed == 0);\n#endif\n\t    pmatch[reg_idx].rm_so += match_first;\n\t    pmatch[reg_idx].rm_eo += match_first;\n\t  }\n      for (reg_idx = 0; reg_idx < extra_nmatch; ++reg_idx)\n\t{\n\t  pmatch[nmatch + reg_idx].rm_so = -1;\n\t  pmatch[nmatch + reg_idx].rm_eo = -1;\n\t}\n\n      if (dfa->subexp_map)\n\tfor (reg_idx = 0; reg_idx + 1 < nmatch; reg_idx++)\n\t  if (dfa->subexp_map[reg_idx] != reg_idx)\n\t    {\n\t      pmatch[reg_idx + 1].rm_so\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_so;\n\t      pmatch[reg_idx + 1].rm_eo\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_eo;\n\t    }\n    }\n\n free_return:\n  re_free (mctx.state_log);\n  if (dfa->nbackref)\n    match_ctx_free (&mctx);\n  re_string_destruct (&mctx.input);\n  return err;\n}",
      "lines": 332,
      "depth": 18,
      "decorators": [
        "internal_function"
      ]
    },
    "prune_impossible_nodes": {
      "start_point": [
        947,
        18
      ],
      "end_point": [
        1036,
        1
      ],
      "content": "__attribute_warn_unused_result__\nprune_impossible_nodes (re_match_context_t *mctx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx halt_node, match_last;\n  reg_errcode_t ret;\n  re_dfastate_t **sifted_states;\n  re_dfastate_t **lim_states = NULL;\n  re_sift_context_t sctx;\n#ifdef DEBUG\n  assert (mctx->state_log != NULL);\n#endif\n  match_last = mctx->match_last;\n  halt_node = mctx->last_node;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) <= match_last, 0))\n    return REG_ESPACE;\n\n  sifted_states = re_malloc (re_dfastate_t *, match_last + 1);\n  if (BE (sifted_states == NULL, 0))\n    {\n      ret = REG_ESPACE;\n      goto free_return;\n    }\n  if (dfa->nbackref)\n    {\n      lim_states = re_malloc (re_dfastate_t *, match_last + 1);\n      if (BE (lim_states == NULL, 0))\n\t{\n\t  ret = REG_ESPACE;\n\t  goto free_return;\n\t}\n      while (1)\n\t{\n\t  memset (lim_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * (match_last + 1));\n\t  sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,\n\t\t\t match_last);\n\t  ret = sift_states_backward (mctx, &sctx);\n\t  re_node_set_free (&sctx.limits);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t      goto free_return;\n\t  if (sifted_states[0] != NULL || lim_states[0] != NULL)\n\t    break;\n\t  do\n\t    {\n\t      --match_last;\n\t      if (match_last < 0)\n\t\t{\n\t\t  ret = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    } while (mctx->state_log[match_last] == NULL\n\t\t     || !mctx->state_log[match_last]->halt);\n\t  halt_node = check_halt_state_context (mctx,\n\t\t\t\t\t\tmctx->state_log[match_last],\n\t\t\t\t\t\tmatch_last);\n\t}\n      ret = merge_state_array (dfa, sifted_states, lim_states,\n\t\t\t       match_last + 1);\n      re_free (lim_states);\n      lim_states = NULL;\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  else\n    {\n      sift_ctx_init (&sctx, sifted_states, lim_states, halt_node, match_last);\n      ret = sift_states_backward (mctx, &sctx);\n      re_node_set_free (&sctx.limits);\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n      if (sifted_states[0] == NULL)\n\t{\n\t  ret = REG_NOMATCH;\n\t  goto free_return;\n\t}\n    }\n  re_free (mctx->state_log);\n  mctx->state_log = sifted_states;\n  sifted_states = NULL;\n  mctx->last_node = halt_node;\n  mctx->match_last = match_last;\n  ret = REG_NOERROR;\n free_return:\n  re_free (sifted_states);\n  re_free (lim_states);\n  return ret;\n}",
      "lines": 90,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "acquire_init_state_context": {
      "start_point": [
        1043,
        32
      ],
      "end_point": [
        1073,
        1
      ],
      "content": "internal_function\nacquire_init_state_context (reg_errcode_t *err, const re_match_context_t *mctx,\n\t\t\t    Idx idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  if (dfa->init_state->has_constraint)\n    {\n      unsigned int context;\n      context = re_string_context_at (&mctx->input, idx - 1, mctx->eflags);\n      if (IS_WORD_CONTEXT (context))\n\treturn dfa->init_state_word;\n      else if (IS_ORDINARY_CONTEXT (context))\n\treturn dfa->init_state;\n      else if (IS_BEGBUF_CONTEXT (context) && IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_begbuf;\n      else if (IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_nl;\n      else if (IS_BEGBUF_CONTEXT (context))\n\t{\n\t  /* It is relatively rare case, then calculate on demand.  */\n\t  return re_acquire_state_context (err, dfa,\n\t\t\t\t\t   dfa->init_state->entrance_nodes,\n\t\t\t\t\t   context);\n\t}\n      else\n\t/* Must not happen?  */\n\treturn dfa->init_state;\n    }\n  else\n    return dfa->init_state;\n}",
      "lines": 31,
      "depth": 16,
      "decorators": [
        "internal_function"
      ]
    },
    "check_matching": {
      "start_point": [
        1085,
        18
      ],
      "end_point": [
        1213,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_matching (re_match_context_t *mctx, bool fl_longest_match,\n\t\tIdx *p_match_first)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx match = 0;\n  Idx match_last = -1;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n  re_dfastate_t *cur_state;\n  bool at_init_state = p_match_first != NULL;\n  Idx next_start_idx = cur_str_idx;\n\n  err = REG_NOERROR;\n  cur_state = acquire_init_state_context (&err, mctx, cur_str_idx);\n  /* An initial state must not be NULL (invalid).  */\n  if (BE (cur_state == NULL, 0))\n    {\n      assert (err == REG_ESPACE);\n      return -2;\n    }\n\n  if (mctx->state_log != NULL)\n    {\n      mctx->state_log[cur_str_idx] = cur_state;\n\n      /* Check OP_OPEN_SUBEXP in the initial state in case that we use them\n\t later.  E.g. Processing back references.  */\n      if (BE (dfa->nbackref, 0))\n\t{\n\t  at_init_state = false;\n\t  err = check_subexp_matching_top (mctx, &cur_state->nodes, 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  if (cur_state->has_backref)\n\t    {\n\t      err = transit_state_bkref (mctx, &cur_state->nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n    }\n\n  /* If the RE accepts NULL string.  */\n  if (BE (cur_state->halt, 0))\n    {\n      if (!cur_state->has_constraint\n\t  || check_halt_state_context (mctx, cur_state, cur_str_idx))\n\t{\n\t  if (!fl_longest_match)\n\t    return cur_str_idx;\n\t  else\n\t    {\n\t      match_last = cur_str_idx;\n\t      match = 1;\n\t    }\n\t}\n    }\n\n  while (!re_string_eoi (&mctx->input))\n    {\n      re_dfastate_t *old_state = cur_state;\n      Idx next_char_idx = re_string_cur_idx (&mctx->input) + 1;\n\n      if ((BE (next_char_idx >= mctx->input.bufs_len, 0)\n\t   && mctx->input.bufs_len < mctx->input.len)\n\t  || (BE (next_char_idx >= mctx->input.valid_len, 0)\n\t      && mctx->input.valid_len < mctx->input.len))\n\t{\n\t  err = extend_buffers (mctx, next_char_idx + 1);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      assert (err == REG_ESPACE);\n\t      return -2;\n\t    }\n\t}\n\n      cur_state = transit_state (&err, mctx, cur_state);\n      if (mctx->state_log != NULL)\n\tcur_state = merge_state_with_log (&err, mctx, cur_state);\n\n      if (cur_state == NULL)\n\t{\n\t  /* Reached the invalid state or an error.  Try to recover a valid\n\t     state using the state log, if available and if we have not\n\t     already found a valid (even if not the longest) match.  */\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return -2;\n\n\t  if (mctx->state_log == NULL\n\t      || (match && !fl_longest_match)\n\t      || (cur_state = find_recover_state (&err, mctx)) == NULL)\n\t    break;\n\t}\n\n      if (BE (at_init_state, 0))\n\t{\n\t  if (old_state == cur_state)\n\t    next_start_idx = next_char_idx;\n\t  else\n\t    at_init_state = false;\n\t}\n\n      if (cur_state->halt)\n\t{\n\t  /* Reached a halt state.\n\t     Check the halt state can satisfy the current context.  */\n\t  if (!cur_state->has_constraint\n\t      || check_halt_state_context (mctx, cur_state,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input)))\n\t    {\n\t      /* We found an appropriate halt state.  */\n\t      match_last = re_string_cur_idx (&mctx->input);\n\t      match = 1;\n\n\t      /* We found a match, do not modify match_first below.  */\n\t      p_match_first = NULL;\n\t      if (!fl_longest_match)\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  if (p_match_first)\n    *p_match_first += next_start_idx;\n\n  return match_last;\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_halt_node_context": {
      "start_point": [
        1217,
        0
      ],
      "end_point": [
        1230,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_halt_node_context (const re_dfa_t *dfa, Idx node, unsigned int context)\n{\n  re_token_type_t type = dfa->nodes[node].type;\n  unsigned int constraint = dfa->nodes[node].constraint;\n  if (type != END_OF_RE)\n    return false;\n  if (!constraint)\n    return true;\n  if (NOT_SATISFY_NEXT_CONSTRAINT (constraint, context))\n    return false;\n  return true;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_halt_state_context": {
      "start_point": [
        1236,
        0
      ],
      "end_point": [
        1251,
        1
      ],
      "content": "static Idx\ninternal_function\ncheck_halt_state_context (const re_match_context_t *mctx,\n\t\t\t  const re_dfastate_t *state, Idx idx)\n{\n  Idx i;\n  unsigned int context;\n#ifdef DEBUG\n  assert (state->halt);\n#endif\n  context = re_string_context_at (&mctx->input, idx, mctx->eflags);\n  for (i = 0; i < state->nodes.nelem; ++i)\n    if (check_halt_node_context (mctx->dfa, state->nodes.elems[i], context))\n      return state->nodes.elems[i];\n  return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "proceed_next_node": {
      "start_point": [
        1258,
        0
      ],
      "end_point": [
        1358,
        1
      ],
      "content": "static Idx\ninternal_function\nproceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,\n\t\t   Idx *pidx, Idx node, re_node_set *eps_via_nodes,\n\t\t   struct re_fail_stack_t *fs)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx i;\n  bool ok;\n  if (IS_EPSILON_NODE (dfa->nodes[node].type))\n    {\n      re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;\n      re_node_set *edests = &dfa->edests[node];\n      Idx dest_node;\n      ok = re_node_set_insert (eps_via_nodes, node);\n      if (BE (! ok, 0))\n\treturn -2;\n      /* Pick up a valid destination, or return -1 if none\n\t is found.  */\n      for (dest_node = -1, i = 0; i < edests->nelem; ++i)\n\t{\n\t  Idx candidate = edests->elems[i];\n\t  if (!re_node_set_contains (cur_nodes, candidate))\n\t    continue;\n          if (dest_node == -1)\n\t    dest_node = candidate;\n\n\t  else\n\t    {\n\t      /* In order to avoid infinite loop like \"(a*)*\", return the second\n\t\t epsilon-transition if the first was already considered.  */\n\t      if (re_node_set_contains (eps_via_nodes, dest_node))\n\t\treturn candidate;\n\n\t      /* Otherwise, push the second epsilon-transition on the fail stack.  */\n\t      else if (fs != NULL\n\t\t       && push_fail_stack (fs, *pidx, candidate, nregs, regs,\n\t\t\t\t\t   eps_via_nodes))\n\t\treturn -2;\n\n\t      /* We know we are going to exit.  */\n\t      break;\n\t    }\n\t}\n      return dest_node;\n    }\n  else\n    {\n      Idx naccepted = 0;\n      re_token_type_t type = dfa->nodes[node].type;\n\n#ifdef RE_ENABLE_I18N\n      if (dfa->nodes[node].accept_mb)\n\tnaccepted = check_node_accept_bytes (dfa, node, &mctx->input, *pidx);\n      else\n#endif /* RE_ENABLE_I18N */\n      if (type == OP_BACK_REF)\n\t{\n\t  Idx subexp_idx = dfa->nodes[node].opr.idx + 1;\n\t  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;\n\t  if (fs != NULL)\n\t    {\n\t      if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)\n\t\treturn -1;\n\t      else if (naccepted)\n\t\t{\n\t\t  char *buf = (char *) re_string_get_buffer (&mctx->input);\n\t\t  if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,\n\t\t\t      naccepted) != 0)\n\t\t    return -1;\n\t\t}\n\t    }\n\n\t  if (naccepted == 0)\n\t    {\n\t      Idx dest_node;\n\t      ok = re_node_set_insert (eps_via_nodes, node);\n\t      if (BE (! ok, 0))\n\t\treturn -2;\n\t      dest_node = dfa->edests[node].elems[0];\n\t      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\tdest_node))\n\t\treturn dest_node;\n\t    }\n\t}\n\n      if (naccepted != 0\n\t  || check_node_accept (mctx, dfa->nodes + node, *pidx))\n\t{\n\t  Idx dest_node = dfa->nexts[node];\n\t  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;\n\t  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL\n\t\t     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\t       dest_node)))\n\t    return -1;\n\t  re_node_set_empty (eps_via_nodes);\n\t  return dest_node;\n\t}\n    }\n  return -1;\n}",
      "lines": 101,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "push_fail_stack": {
      "start_point": [
        1361,
        18
      ],
      "end_point": [
        1385,
        1
      ],
      "content": "__attribute_warn_unused_result__\npush_fail_stack (struct re_fail_stack_t *fs, Idx str_idx, Idx dest_node,\n\t\t Idx nregs, regmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  reg_errcode_t err;\n  Idx num = fs->num++;\n  if (fs->num == fs->alloc)\n    {\n      struct re_fail_stack_ent_t *new_array;\n      new_array = realloc (fs->stack, (sizeof (struct re_fail_stack_ent_t)\n\t\t\t\t       * fs->alloc * 2));\n      if (new_array == NULL)\n\treturn REG_ESPACE;\n      fs->alloc *= 2;\n      fs->stack = new_array;\n    }\n  fs->stack[num].idx = str_idx;\n  fs->stack[num].node = dest_node;\n  fs->stack[num].regs = re_malloc (regmatch_t, nregs);\n  if (fs->stack[num].regs == NULL)\n    return REG_ESPACE;\n  memcpy (fs->stack[num].regs, regs, sizeof (regmatch_t) * nregs);\n  err = re_node_set_init_copy (&fs->stack[num].eps_via_nodes, eps_via_nodes);\n  return err;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pop_fail_stack": {
      "start_point": [
        1387,
        0
      ],
      "end_point": [
        1400,
        1
      ],
      "content": "static Idx\ninternal_function\npop_fail_stack (struct re_fail_stack_t *fs, Idx *pidx, Idx nregs,\n\t\tregmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  Idx num = --fs->num;\n  assert (num >= 0);\n  *pidx = fs->stack[num].idx;\n  memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);\n  re_node_set_free (eps_via_nodes);\n  re_free (fs->stack[num].regs);\n  *eps_via_nodes = fs->stack[num].eps_via_nodes;\n  return fs->stack[num].node;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "set_regs": {
      "start_point": [
        1408,
        18
      ],
      "end_point": [
        1512,
        1
      ],
      "content": "__attribute_warn_unused_result__\nset_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,\n\t  regmatch_t *pmatch, bool fl_backtrack)\n{\n  const re_dfa_t *dfa = preg->buffer;\n  Idx idx, cur_node;\n  re_node_set eps_via_nodes;\n  struct re_fail_stack_t *fs;\n  struct re_fail_stack_t fs_body = { 0, 2, NULL };\n  regmatch_t *prev_idx_match;\n  bool prev_idx_match_malloced = false;\n\n#ifdef DEBUG\n  assert (nmatch > 1);\n  assert (mctx->state_log != NULL);\n#endif\n  if (fl_backtrack)\n    {\n      fs = &fs_body;\n      fs->stack = re_malloc (struct re_fail_stack_ent_t, fs->alloc);\n      if (fs->stack == NULL)\n\treturn REG_ESPACE;\n    }\n  else\n    fs = NULL;\n\n  cur_node = dfa->init_node;\n  re_node_set_init_empty (&eps_via_nodes);\n\n  if (__libc_use_alloca (nmatch * sizeof (regmatch_t)))\n    prev_idx_match = (regmatch_t *) alloca (nmatch * sizeof (regmatch_t));\n  else\n    {\n      prev_idx_match = re_malloc (regmatch_t, nmatch);\n      if (prev_idx_match == NULL)\n\t{\n\t  free_fail_stack_return (fs);\n\t  return REG_ESPACE;\n\t}\n      prev_idx_match_malloced = true;\n    }\n  memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\n  for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)\n    {\n      update_regs (dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);\n\n      if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)\n\t{\n\t  Idx reg_idx;\n\t  if (fs)\n\t    {\n\t      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\t\tif (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)\n\t\t  break;\n\t      if (reg_idx == nmatch)\n\t\t{\n\t\t  re_node_set_free (&eps_via_nodes);\n\t\t  if (prev_idx_match_malloced)\n\t\t    re_free (prev_idx_match);\n\t\t  return free_fail_stack_return (fs);\n\t\t}\n\t      cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t\t &eps_via_nodes);\n\t    }\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOERROR;\n\t    }\n\t}\n\n      /* Proceed to next node.  */\n      cur_node = proceed_next_node (mctx, nmatch, pmatch, &idx, cur_node,\n\t\t\t\t    &eps_via_nodes, fs);\n\n      if (BE (cur_node < 0, 0))\n\t{\n\t  if (BE (cur_node == -2, 0))\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      free_fail_stack_return (fs);\n\t      return REG_ESPACE;\n\t    }\n\t  if (fs)\n\t    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t       &eps_via_nodes);\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOMATCH;\n\t    }\n\t}\n    }\n  re_node_set_free (&eps_via_nodes);\n  if (prev_idx_match_malloced)\n    re_free (prev_idx_match);\n  return free_fail_stack_return (fs);\n}",
      "lines": 105,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "free_fail_stack_return": {
      "start_point": [
        1514,
        0
      ],
      "end_point": [
        1529,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nfree_fail_stack_return (struct re_fail_stack_t *fs)\n{\n  if (fs)\n    {\n      Idx fs_idx;\n      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)\n\t{\n\t  re_node_set_free (&fs->stack[fs_idx].eps_via_nodes);\n\t  re_free (fs->stack[fs_idx].regs);\n\t}\n      re_free (fs->stack);\n    }\n  return REG_NOERROR;\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_regs": {
      "start_point": [
        1531,
        0
      ],
      "end_point": [
        1578,
        1
      ],
      "content": "static void\ninternal_function\nupdate_regs (const re_dfa_t *dfa, regmatch_t *pmatch,\n\t     regmatch_t *prev_idx_match, Idx cur_node, Idx cur_idx, Idx nmatch)\n{\n  int type = dfa->nodes[cur_node].type;\n  if (type == OP_OPEN_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n\n      /* We are at the first node of this sub expression.  */\n      if (reg_num < nmatch)\n\t{\n\t  pmatch[reg_num].rm_so = cur_idx;\n\t  pmatch[reg_num].rm_eo = -1;\n\t}\n    }\n  else if (type == OP_CLOSE_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n      if (reg_num < nmatch)\n\t{\n\t  /* We are at the last node of this sub expression.  */\n\t  if (pmatch[reg_num].rm_so < cur_idx)\n\t    {\n\t      pmatch[reg_num].rm_eo = cur_idx;\n\t      /* This is a non-empty match or we are not inside an optional\n\t\t subexpression.  Accept this right away.  */\n\t      memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\t    }\n\t  else\n\t    {\n\t      if (dfa->nodes[cur_node].opt_subexp\n\t\t  && prev_idx_match[reg_num].rm_so != -1)\n\t\t/* We transited through an empty match for an optional\n\t\t   subexpression, like (a?)*, and this is not the subexp's\n\t\t   first match.  Copy back the old content of the registers\n\t\t   so that matches of an inner subexpression are undone as\n\t\t   well, like in ((a?))*.  */\n\t\tmemcpy (pmatch, prev_idx_match, sizeof (regmatch_t) * nmatch);\n\t      else\n\t\t/* We completed a subexpression, but it may be part of\n\t\t   an optional one, so do not update PREV_IDX_MATCH.  */\n\t\tpmatch[reg_num].rm_eo = cur_idx;\n\t    }\n\t}\n    }\n}",
      "lines": 48,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_backward": {
      "start_point": [
        1603,
        0
      ],
      "end_point": [
        1659,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsift_states_backward (const re_match_context_t *mctx, re_sift_context_t *sctx)\n{\n  reg_errcode_t err;\n  int null_cnt = 0;\n  Idx str_idx = sctx->last_str_idx;\n  re_node_set cur_dest;\n\n#ifdef DEBUG\n  assert (mctx->state_log != NULL && mctx->state_log[str_idx] != NULL);\n#endif\n\n  /* Build sifted state_log[str_idx].  It has the nodes which can epsilon\n     transit to the last_node and the last_node itself.  */\n  err = re_node_set_init_1 (&cur_dest, sctx->last_node);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* Then check each states in the state_log.  */\n  while (str_idx > 0)\n    {\n      /* Update counters.  */\n      null_cnt = (sctx->sifted_states[str_idx] == NULL) ? null_cnt + 1 : 0;\n      if (null_cnt > mctx->max_mb_elem_len)\n\t{\n\t  memset (sctx->sifted_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * str_idx);\n\t  re_node_set_free (&cur_dest);\n\t  return REG_NOERROR;\n\t}\n      re_node_set_empty (&cur_dest);\n      --str_idx;\n\n      if (mctx->state_log[str_idx])\n\t{\n\t  err = build_sifted_states (mctx, sctx, str_idx, &cur_dest);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* Add all the nodes which satisfy the following conditions:\n\t - It can epsilon transit to a node in CUR_DEST.\n\t - It is in CUR_SRC.\n\t And update state_log.  */\n      err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  err = REG_NOERROR;\n free_return:\n  re_node_set_free (&cur_dest);\n  return err;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "build_sifted_states": {
      "start_point": [
        1662,
        18
      ],
      "end_point": [
        1719,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_sifted_states (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx str_idx, re_node_set *cur_dest)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *cur_src = &mctx->state_log[str_idx]->non_eps_nodes;\n  Idx i;\n\n  /* Then build the next sifted state.\n     We build the next sifted state on 'cur_dest', and update\n     'sifted_states[str_idx]' with 'cur_dest'.\n     Note:\n     'cur_dest' is the sifted state from 'state_log[str_idx + 1]'.\n     'cur_src' points the node_set of the old 'state_log[str_idx]'\n     (with the epsilon nodes pre-filtered out).  */\n  for (i = 0; i < cur_src->nelem; i++)\n    {\n      Idx prev_node = cur_src->elems[i];\n      int naccepted = 0;\n      bool ok;\n\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[prev_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[prev_node].accept_mb)\n\tnaccepted = sift_states_iter_mb (mctx, sctx, prev_node,\n\t\t\t\t\t str_idx, sctx->last_str_idx);\n#endif /* RE_ENABLE_I18N */\n\n      /* We don't check backreferences here.\n\t See update_cur_sifted_state().  */\n      if (!naccepted\n\t  && check_node_accept (mctx, dfa->nodes + prev_node, str_idx)\n\t  && STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + 1],\n\t\t\t\t  dfa->nexts[prev_node]))\n\tnaccepted = 1;\n\n      if (naccepted == 0)\n\tcontinue;\n\n      if (sctx->limits.nelem)\n\t{\n\t  Idx to_idx = str_idx + naccepted;\n\t  if (check_dst_limits (mctx, &sctx->limits,\n\t\t\t\tdfa->nexts[prev_node], to_idx,\n\t\t\t\tprev_node, str_idx))\n\t    continue;\n\t}\n      ok = re_node_set_insert (cur_dest, prev_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "clean_state_log_if_needed": {
      "start_point": [
        1723,
        0
      ],
      "end_point": [
        1747,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nclean_state_log_if_needed (re_match_context_t *mctx, Idx next_state_log_idx)\n{\n  Idx top = mctx->state_log_top;\n\n  if ((next_state_log_idx >= mctx->input.bufs_len\n       && mctx->input.bufs_len < mctx->input.len)\n      || (next_state_log_idx >= mctx->input.valid_len\n\t  && mctx->input.valid_len < mctx->input.len))\n    {\n      reg_errcode_t err;\n      err = extend_buffers (mctx, next_state_log_idx + 1);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (top < next_state_log_idx)\n    {\n      memset (mctx->state_log + top + 1, '\\0',\n\t      sizeof (re_dfastate_t *) * (next_state_log_idx - top));\n      mctx->state_log_top = next_state_log_idx;\n    }\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "merge_state_array": {
      "start_point": [
        1749,
        0
      ],
      "end_point": [
        1774,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nmerge_state_array (const re_dfa_t *dfa, re_dfastate_t **dst,\n\t\t   re_dfastate_t **src, Idx num)\n{\n  Idx st_idx;\n  reg_errcode_t err;\n  for (st_idx = 0; st_idx < num; ++st_idx)\n    {\n      if (dst[st_idx] == NULL)\n\tdst[st_idx] = src[st_idx];\n      else if (src[st_idx] != NULL)\n\t{\n\t  re_node_set merged_set;\n\t  err = re_node_set_init_union (&merged_set, &dst[st_idx]->nodes,\n\t\t\t\t\t&src[st_idx]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  dst[st_idx] = re_acquire_state (&err, dfa, &merged_set);\n\t  re_node_set_free (&merged_set);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_cur_sifted_state": {
      "start_point": [
        1776,
        0
      ],
      "end_point": [
        1822,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nupdate_cur_sifted_state (const re_match_context_t *mctx,\n\t\t\t re_sift_context_t *sctx, Idx str_idx,\n\t\t\t re_node_set *dest_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  const re_node_set *candidates;\n  candidates = ((mctx->state_log[str_idx] == NULL) ? NULL\n\t\t: &mctx->state_log[str_idx]->nodes);\n\n  if (dest_nodes->nelem == 0)\n    sctx->sifted_states[str_idx] = NULL;\n  else\n    {\n      if (candidates)\n\t{\n\t  /* At first, add the nodes which can epsilon transit to a node in\n\t     DEST_NODE.  */\n\t  err = add_epsilon_src_nodes (dfa, dest_nodes, candidates);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  /* Then, check the limitations in the current sift_context.  */\n\t  if (sctx->limits.nelem)\n\t    {\n\t      err = check_subexp_limits (dfa, dest_nodes, candidates, &sctx->limits,\n\t\t\t\t\t mctx->bkref_ents, str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n\n      sctx->sifted_states[str_idx] = re_acquire_state (&err, dfa, dest_nodes);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (candidates && mctx->state_log[str_idx]->has_backref)\n    {\n      err = sift_states_bkref (mctx, sctx, str_idx, candidates);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "add_epsilon_src_nodes": {
      "start_point": [
        1825,
        18
      ],
      "end_point": [
        1851,
        1
      ],
      "content": "__attribute_warn_unused_result__\nadd_epsilon_src_nodes (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n  reg_errcode_t err = REG_NOERROR;\n  Idx i;\n\n  re_dfastate_t *state = re_acquire_state (&err, dfa, dest_nodes);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  if (!state->inveclosure.alloc)\n    {\n      err = re_node_set_alloc (&state->inveclosure, dest_nodes->nelem);\n      if (BE (err != REG_NOERROR, 0))\n\treturn REG_ESPACE;\n      for (i = 0; i < dest_nodes->nelem; i++)\n\t{\n\t  err = re_node_set_merge (&state->inveclosure,\n\t\t\t\t   dfa->inveclosures + dest_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n  return re_node_set_add_intersect (dest_nodes, candidates,\n\t\t\t\t    &state->inveclosure);\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sub_epsilon_src_nodes": {
      "start_point": [
        1853,
        0
      ],
      "end_point": [
        1900,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsub_epsilon_src_nodes (const re_dfa_t *dfa, Idx node, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n    Idx ecl_idx;\n    reg_errcode_t err;\n    re_node_set *inv_eclosure = dfa->inveclosures + node;\n    re_node_set except_nodes;\n    re_node_set_init_empty (&except_nodes);\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (cur_node == node)\n\t  continue;\n\tif (IS_EPSILON_NODE (dfa->nodes[cur_node].type))\n\t  {\n\t    Idx edst1 = dfa->edests[cur_node].elems[0];\n\t    Idx edst2 = ((dfa->edests[cur_node].nelem > 1)\n\t\t\t ? dfa->edests[cur_node].elems[1] : -1);\n\t    if ((!re_node_set_contains (inv_eclosure, edst1)\n\t\t && re_node_set_contains (dest_nodes, edst1))\n\t\t|| (edst2 > 0\n\t\t    && !re_node_set_contains (inv_eclosure, edst2)\n\t\t    && re_node_set_contains (dest_nodes, edst2)))\n\t      {\n\t\terr = re_node_set_add_intersect (&except_nodes, candidates,\n\t\t\t\t\t\t dfa->inveclosures + cur_node);\n\t\tif (BE (err != REG_NOERROR, 0))\n\t\t  {\n\t\t    re_node_set_free (&except_nodes);\n\t\t    return err;\n\t\t  }\n\t      }\n\t  }\n      }\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (!re_node_set_contains (&except_nodes, cur_node))\n\t  {\n\t    Idx idx = re_node_set_contains (dest_nodes, cur_node) - 1;\n\t    re_node_set_remove_at (dest_nodes, idx);\n\t  }\n      }\n    re_node_set_free (&except_nodes);\n    return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits": {
      "start_point": [
        1902,
        0
      ],
      "end_point": [
        1936,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_dst_limits (const re_match_context_t *mctx, const re_node_set *limits,\n\t\t  Idx dst_node, Idx dst_idx, Idx src_node, Idx src_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx lim_idx, src_pos, dst_pos;\n\n  Idx dst_bkref_idx = search_cur_bkref_entry (mctx, dst_idx);\n  Idx src_bkref_idx = search_cur_bkref_entry (mctx, src_idx);\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = mctx->bkref_ents + limits->elems[lim_idx];\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n\n      dst_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, dst_node, dst_idx,\n\t\t\t\t\t   dst_bkref_idx);\n      src_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, src_node, src_idx,\n\t\t\t\t\t   src_bkref_idx);\n\n      /* In case of:\n\t <src> <dst> ( <subexp> )\n\t ( <subexp> ) <src> <dst>\n\t ( <subexp1> <src> <subexp2> <dst> <subexp3> )  */\n      if (src_pos == dst_pos)\n\tcontinue; /* This is unrelated limitation.  */\n      else\n\treturn true;\n    }\n  return false;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos_1": {
      "start_point": [
        1938,
        0
      ],
      "end_point": [
        2018,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos_1 (const re_match_context_t *mctx, int boundaries,\n\t\t\t     Idx subexp_idx, Idx from_node, Idx bkref_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *eclosures = dfa->eclosures + from_node;\n  Idx node_idx;\n\n  /* Else, we are on the boundary: examine the nodes on the epsilon\n     closure.  */\n  for (node_idx = 0; node_idx < eclosures->nelem; ++node_idx)\n    {\n      Idx node = eclosures->elems[node_idx];\n      switch (dfa->nodes[node].type)\n\t{\n\tcase OP_BACK_REF:\n\t  if (bkref_idx != -1)\n\t    {\n\t      struct re_backref_cache_entry *ent = mctx->bkref_ents + bkref_idx;\n\t      do\n\t\t{\n\t\t  Idx dst;\n\t\t  int cpos;\n\n\t\t  if (ent->node != node)\n\t\t    continue;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS\n\t\t      && !(ent->eps_reachable_subexps_map\n\t\t\t   & ((bitset_word_t) 1 << subexp_idx)))\n\t\t    continue;\n\n\t\t  /* Recurse trying to reach the OP_OPEN_SUBEXP and\n\t\t     OP_CLOSE_SUBEXP cases below.  But, if the\n\t\t     destination node is the same node as the source\n\t\t     node, don't recurse because it would cause an\n\t\t     infinite loop: a regex that exhibits this behavior\n\t\t     is ()\\1*\\1*  */\n\t\t  dst = dfa->edests[node].elems[0];\n\t\t  if (dst == from_node)\n\t\t    {\n\t\t      if (boundaries & 1)\n\t\t\treturn -1;\n\t\t      else /* if (boundaries & 2) */\n\t\t\treturn 0;\n\t\t    }\n\n\t\t  cpos =\n\t\t    check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t\t\t dst, bkref_idx);\n\t\t  if (cpos == -1 /* && (boundaries & 1) */)\n\t\t    return -1;\n\t\t  if (cpos == 0 && (boundaries & 2))\n\t\t    return 0;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS)\n\t\t    ent->eps_reachable_subexps_map\n\t\t      &= ~((bitset_word_t) 1 << subexp_idx);\n\t\t}\n\t      while (ent++->more);\n\t    }\n\t  break;\n\n\tcase OP_OPEN_SUBEXP:\n\t  if ((boundaries & 1) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return -1;\n\t  break;\n\n\tcase OP_CLOSE_SUBEXP:\n\t  if ((boundaries & 2) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return 0;\n\t  break;\n\n\tdefault:\n\t    break;\n\t}\n    }\n\n  return (boundaries & 2) ? 1 : 0;\n}",
      "lines": 81,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos": {
      "start_point": [
        2020,
        0
      ],
      "end_point": [
        2045,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos (const re_match_context_t *mctx, Idx limit,\n\t\t\t   Idx subexp_idx, Idx from_node, Idx str_idx,\n\t\t\t   Idx bkref_idx)\n{\n  struct re_backref_cache_entry *lim = mctx->bkref_ents + limit;\n  int boundaries;\n\n  /* If we are outside the range of the subexpression, return -1 or 1.  */\n  if (str_idx < lim->subexp_from)\n    return -1;\n\n  if (lim->subexp_to < str_idx)\n    return 1;\n\n  /* If we are within the subexpression, return 0.  */\n  boundaries = (str_idx == lim->subexp_from);\n  boundaries |= (str_idx == lim->subexp_to) << 1;\n  if (boundaries == 0)\n    return 0;\n\n  /* Else, examine epsilon closure.  */\n  return check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t      from_node, bkref_idx);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_limits": {
      "start_point": [
        2050,
        0
      ],
      "end_point": [
        2136,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t     const re_node_set *candidates, re_node_set *limits,\n\t\t     struct re_backref_cache_entry *bkref_ents, Idx str_idx)\n{\n  reg_errcode_t err;\n  Idx node_idx, lim_idx;\n\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = bkref_ents + limits->elems[lim_idx];\n\n      if (str_idx <= ent->subexp_from || ent->str_idx < str_idx)\n\tcontinue; /* This is unrelated limitation.  */\n\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n      if (ent->subexp_to == str_idx)\n\t{\n\t  Idx ops_node = -1;\n\t  Idx cls_node = -1;\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_OPEN_SUBEXP\n\t\t  && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tops_node = node;\n\t      else if (type == OP_CLOSE_SUBEXP\n\t\t       && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tcls_node = node;\n\t    }\n\n\t  /* Check the limitation of the open subexpression.  */\n\t  /* Note that (ent->subexp_to = str_idx != ent->subexp_from).  */\n\t  if (ops_node >= 0)\n\t    {\n\t      err = sub_epsilon_src_nodes (dfa, ops_node, dest_nodes,\n\t\t\t\t\t   candidates);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\n\t  /* Check the limitation of the close subexpression.  */\n\t  if (cls_node >= 0)\n\t    for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t      {\n\t\tIdx node = dest_nodes->elems[node_idx];\n\t\tif (!re_node_set_contains (dfa->inveclosures + node,\n\t\t\t\t\t   cls_node)\n\t\t    && !re_node_set_contains (dfa->eclosures + node,\n\t\t\t\t\t      cls_node))\n\t\t  {\n\t\t    /* It is against this limitation.\n\t\t       Remove it form the current sifted state.  */\n\t\t    err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t\t candidates);\n\t\t    if (BE (err != REG_NOERROR, 0))\n\t\t      return err;\n\t\t    --node_idx;\n\t\t  }\n\t      }\n\t}\n      else /* (ent->subexp_to != str_idx)  */\n\t{\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_CLOSE_SUBEXP || type == OP_OPEN_SUBEXP)\n\t\t{\n\t\t  if (subexp_idx != dfa->nodes[node].opr.idx)\n\t\t    continue;\n\t\t  /* It is against this limitation.\n\t\t     Remove it form the current sifted state.  */\n\t\t  err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t       candidates);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t}\n\t    }\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 87,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_bkref": {
      "start_point": [
        2139,
        18
      ],
      "end_point": [
        2234,
        1
      ],
      "content": "__attribute_warn_unused_result__\nsift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t   Idx str_idx, const re_node_set *candidates)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx node_idx, node;\n  re_sift_context_t local_sctx;\n  Idx first_idx = search_cur_bkref_entry (mctx, str_idx);\n\n  if (first_idx == -1)\n    return REG_NOERROR;\n\n  local_sctx.sifted_states = NULL; /* Mark that it hasn't been initialized.  */\n\n  for (node_idx = 0; node_idx < candidates->nelem; ++node_idx)\n    {\n      Idx enabled_idx;\n      re_token_type_t type;\n      struct re_backref_cache_entry *entry;\n      node = candidates->elems[node_idx];\n      type = dfa->nodes[node].type;\n      /* Avoid infinite loop for the REs like \"()\\1+\".  */\n      if (node == sctx->last_node && str_idx == sctx->last_str_idx)\n\tcontinue;\n      if (type != OP_BACK_REF)\n\tcontinue;\n\n      entry = mctx->bkref_ents + first_idx;\n      enabled_idx = first_idx;\n      do\n\t{\n\t  Idx subexp_len;\n\t  Idx to_idx;\n\t  Idx dst_node;\n\t  bool ok;\n\t  re_dfastate_t *cur_state;\n\n\t  if (entry->node != node)\n\t    continue;\n\t  subexp_len = entry->subexp_to - entry->subexp_from;\n\t  to_idx = str_idx + subexp_len;\n\t  dst_node = (subexp_len ? dfa->nexts[node]\n\t\t      : dfa->edests[node].elems[0]);\n\n\t  if (to_idx > sctx->last_str_idx\n\t      || sctx->sifted_states[to_idx] == NULL\n\t      || !STATE_NODE_CONTAINS (sctx->sifted_states[to_idx], dst_node)\n\t      || check_dst_limits (mctx, &sctx->limits, node,\n\t\t\t\t   str_idx, dst_node, to_idx))\n\t    continue;\n\n\t  if (local_sctx.sifted_states == NULL)\n\t    {\n\t      local_sctx = *sctx;\n\t      err = re_node_set_init_copy (&local_sctx.limits, &sctx->limits);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.last_node = node;\n\t  local_sctx.last_str_idx = str_idx;\n\t  ok = re_node_set_insert (&local_sctx.limits, enabled_idx);\n\t  if (BE (! ok, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  cur_state = local_sctx.sifted_states[str_idx];\n\t  err = sift_states_backward (mctx, &local_sctx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t  if (sctx->limited_states != NULL)\n\t    {\n\t      err = merge_state_array (dfa, sctx->limited_states,\n\t\t\t\t       local_sctx.sifted_states,\n\t\t\t\t       str_idx + 1);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.sifted_states[str_idx] = cur_state;\n\t  re_node_set_remove (&local_sctx.limits, enabled_idx);\n\n\t  /* mctx->bkref_ents may have changed, reload the pointer.  */\n\t  entry = mctx->bkref_ents + enabled_idx;\n\t}\n      while (enabled_idx++, entry++->more);\n    }\n  err = REG_NOERROR;\n free_return:\n  if (local_sctx.sifted_states != NULL)\n    {\n      re_node_set_free (&local_sctx.limits);\n    }\n\n  return err;\n}",
      "lines": 96,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sift_states_iter_mb": {
      "start_point": [
        2238,
        0
      ],
      "end_point": [
        2257,
        1
      ],
      "content": "static int\ninternal_function\nsift_states_iter_mb (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx node_idx, Idx str_idx, Idx max_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int naccepted;\n  /* Check the node can accept \"multi byte\".  */\n  naccepted = check_node_accept_bytes (dfa, node_idx, &mctx->input, str_idx);\n  if (naccepted > 0 && str_idx + naccepted <= max_str_idx &&\n      !STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + naccepted],\n\t\t\t    dfa->nexts[node_idx]))\n    /* The node can't accept the \"multi byte\", or the\n       destination was already thrown away, then the node\n       could't accept the current input \"multi byte\".   */\n    naccepted = 0;\n  /* Otherwise, it is sure that the node could accept\n     'naccepted' bytes input.  */\n  return naccepted;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state": {
      "start_point": [
        2269,
        18
      ],
      "end_point": [
        2323,
        1
      ],
      "content": "__attribute_warn_unused_result__\ntransit_state (reg_errcode_t *err, re_match_context_t *mctx,\n\t       re_dfastate_t *state)\n{\n  re_dfastate_t **trtable;\n  unsigned char ch;\n\n#ifdef RE_ENABLE_I18N\n  /* If the current state can accept multibyte.  */\n  if (BE (state->accept_mb, 0))\n    {\n      *err = transit_state_mb (mctx, state);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  /* Then decide the next state with the single byte.  */\n#if 0\n  if (0)\n    /* don't use transition table  */\n    return transit_state_sb (err, mctx, state);\n#endif\n\n  /* Use transition table  */\n  ch = re_string_fetch_byte (&mctx->input);\n  for (;;)\n    {\n      trtable = state->trtable;\n      if (BE (trtable != NULL, 1))\n\treturn trtable[ch];\n\n      trtable = state->word_trtable;\n      if (BE (trtable != NULL, 1))\n\t{\n\t  unsigned int context;\n\t  context\n\t    = re_string_context_at (&mctx->input,\n\t\t\t\t    re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t    mctx->eflags);\n\t  if (IS_WORD_CONTEXT (context))\n\t    return trtable[ch + SBC_MAX];\n\t  else\n\t    return trtable[ch];\n\t}\n\n      if (!build_trtable (mctx->dfa, state))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n\n      /* Retry, we now have a transition table.  */\n    }\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "merge_state_with_log": {
      "start_point": [
        2326,
        0
      ],
      "end_point": [
        2400,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx cur_idx = re_string_cur_idx (&mctx->input);\n\n  if (cur_idx > mctx->state_log_top)\n    {\n      mctx->state_log[cur_idx] = next_state;\n      mctx->state_log_top = cur_idx;\n    }\n  else if (mctx->state_log[cur_idx] == 0)\n    {\n      mctx->state_log[cur_idx] = next_state;\n    }\n  else\n    {\n      re_dfastate_t *pstate;\n      unsigned int context;\n      re_node_set next_nodes, *log_nodes, *table_nodes = NULL;\n      /* If (state_log[cur_idx] != 0), it implies that cur_idx is\n\t the destination of a multibyte char/collating element/\n\t back reference.  Then the next state is the union set of\n\t these destinations and the results of the transition table.  */\n      pstate = mctx->state_log[cur_idx];\n      log_nodes = pstate->entrance_nodes;\n      if (next_state != NULL)\n\t{\n\t  table_nodes = next_state->entrance_nodes;\n\t  *err = re_node_set_init_union (&next_nodes, table_nodes,\n\t\t\t\t\t     log_nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t}\n      else\n\tnext_nodes = *log_nodes;\n      /* Note: We already add the nodes of the initial state,\n\t then we don't need to add them here.  */\n\n      context = re_string_context_at (&mctx->input,\n\t\t\t\t      re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t      mctx->eflags);\n      next_state = mctx->state_log[cur_idx]\n\t= re_acquire_state_context (err, dfa, &next_nodes, context);\n      /* We don't need to check errors here, since the return value of\n\t this function is next_state and ERR is already set.  */\n\n      if (table_nodes != NULL)\n\tre_node_set_free (&next_nodes);\n    }\n\n  if (BE (dfa->nbackref, 0) && next_state != NULL)\n    {\n      /* Check OP_OPEN_SUBEXP in the current state in case that we use them\n\t later.  We must check them here, since the back references in the\n\t next state might use them.  */\n      *err = check_subexp_matching_top (mctx, &next_state->nodes,\n\t\t\t\t\tcur_idx);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n\n      /* If the next state has back references.  */\n      if (next_state->has_backref)\n\t{\n\t  *err = transit_state_bkref (mctx, &next_state->nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t  next_state = mctx->state_log[cur_idx];\n\t}\n    }\n\n  return next_state;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "find_recover_state": {
      "start_point": [
        2405,
        0
      ],
      "end_point": [
        2427,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)\n{\n  re_dfastate_t *cur_state;\n  do\n    {\n      Idx max = mctx->state_log_top;\n      Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n      do\n\t{\n\t  if (++cur_str_idx > max)\n\t    return NULL;\n\t  re_string_skip_bytes (&mctx->input, 1);\n\t}\n      while (mctx->state_log[cur_str_idx] == NULL);\n\n      cur_state = merge_state_with_log (err, mctx, NULL);\n    }\n  while (*err == REG_NOERROR && cur_state == NULL);\n  return cur_state;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_matching_top": {
      "start_point": [
        2436,
        0
      ],
      "end_point": [
        2464,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_matching_top (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t\t   Idx str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx node_idx;\n  reg_errcode_t err;\n\n  /* TODO: This isn't efficient.\n\t   Because there might be more than one nodes whose types are\n\t   OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all\n\t   nodes.\n\t   E.g. RE: (a){2}  */\n  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)\n    {\n      Idx node = cur_nodes->elems[node_idx];\n      if (dfa->nodes[node].type == OP_OPEN_SUBEXP\n\t  && dfa->nodes[node].opr.idx < BITSET_WORD_BITS\n\t  && (dfa->used_bkref_map\n\t      & ((bitset_word_t) 1 << dfa->nodes[node].opr.idx)))\n\t{\n\t  err = match_ctx_add_subtop (mctx, node, str_idx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_sb": {
      "start_point": [
        2470,
        0
      ],
      "end_point": [
        2505,
        1
      ],
      "content": "static re_dfastate_t *\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  re_node_set next_nodes;\n  re_dfastate_t *next_state;\n  Idx node_cnt, cur_str_idx = re_string_cur_idx (&mctx->input);\n  unsigned int context;\n\n  *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);\n  if (BE (*err != REG_NOERROR, 0))\n    return NULL;\n  for (node_cnt = 0; node_cnt < state->nodes.nelem; ++node_cnt)\n    {\n      Idx cur_node = state->nodes.elems[node_cnt];\n      if (check_node_accept (mctx, dfa->nodes + cur_node, cur_str_idx))\n\t{\n\t  *err = re_node_set_merge (&next_nodes,\n\t\t\t\t    dfa->eclosures + dfa->nexts[cur_node]);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return NULL;\n\t    }\n\t}\n    }\n  context = re_string_context_at (&mctx->input, cur_str_idx, mctx->eflags);\n  next_state = re_acquire_state_context (err, dfa, &next_nodes, context);\n  /* We don't need to check errors here, since the return value of\n     this function is next_state and ERR is already set.  */\n\n  re_node_set_free (&next_nodes);\n  re_string_skip_bytes (&mctx->input, 1);\n  return next_state;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)",
        "*"
      ]
    },
    "transit_state_mb": {
      "start_point": [
        2509,
        0
      ],
      "end_point": [
        2577,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_mb (re_match_context_t *mctx, re_dfastate_t *pstate)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n\n  for (i = 0; i < pstate->nodes.nelem; ++i)\n    {\n      re_node_set dest_nodes, *new_nodes;\n      Idx cur_node_idx = pstate->nodes.elems[i];\n      int naccepted;\n      Idx dest_idx;\n      unsigned int context;\n      re_dfastate_t *dest_state;\n\n      if (!dfa->nodes[cur_node_idx].accept_mb)\n\tcontinue;\n\n      if (dfa->nodes[cur_node_idx].constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input,\n\t\t\t\t\t  re_string_cur_idx (&mctx->input),\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (dfa->nodes[cur_node_idx].constraint,\n\t\t\t\t\t   context))\n\t    continue;\n\t}\n\n      /* How many bytes the node can accept?  */\n      naccepted = check_node_accept_bytes (dfa, cur_node_idx, &mctx->input,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input));\n      if (naccepted == 0)\n\tcontinue;\n\n      /* The node can accepts 'naccepted' bytes.  */\n      dest_idx = re_string_cur_idx (&mctx->input) + naccepted;\n      mctx->max_mb_elem_len = ((mctx->max_mb_elem_len < naccepted) ? naccepted\n\t\t\t       : mctx->max_mb_elem_len);\n      err = clean_state_log_if_needed (mctx, dest_idx);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n#ifdef DEBUG\n      assert (dfa->nexts[cur_node_idx] != -1);\n#endif\n      new_nodes = dfa->eclosures + dfa->nexts[cur_node_idx];\n\n      dest_state = mctx->state_log[dest_idx];\n      if (dest_state == NULL)\n\tdest_nodes = *new_nodes;\n      else\n\t{\n\t  err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\tdest_state->entrance_nodes, new_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      context = re_string_context_at (&mctx->input, dest_idx - 1,\n\t\t\t\t      mctx->eflags);\n      mctx->state_log[dest_idx]\n\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n      if (dest_state != NULL)\n\tre_node_set_free (&dest_nodes);\n      if (BE (mctx->state_log[dest_idx] == NULL && err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 69,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_bkref": {
      "start_point": [
        2580,
        0
      ],
      "end_point": [
        2686,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n  for (i = 0; i < nodes->nelem; ++i)\n    {\n      Idx dest_str_idx, prev_nelem, bkc_idx;\n      Idx node_idx = nodes->elems[i];\n      unsigned int context;\n      const re_token_t *node = dfa->nodes + node_idx;\n      re_node_set *new_dest_nodes;\n\n      /* Check whether 'node' is a backreference or not.  */\n      if (node->type != OP_BACK_REF)\n\tcontinue;\n\n      if (node->constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input, cur_str_idx,\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\t    continue;\n\t}\n\n      /* 'node' is a backreference.\n\t Check the substring which the substring matched.  */\n      bkc_idx = mctx->nbkref_ents;\n      err = get_subexp (mctx, node_idx, cur_str_idx);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n      /* And add the epsilon closures (which is 'new_dest_nodes') of\n\t the backreference to appropriate state_log.  */\n#ifdef DEBUG\n      assert (dfa->nexts[node_idx] != -1);\n#endif\n      for (; bkc_idx < mctx->nbkref_ents; ++bkc_idx)\n\t{\n\t  Idx subexp_len;\n\t  re_dfastate_t *dest_state;\n\t  struct re_backref_cache_entry *bkref_ent;\n\t  bkref_ent = mctx->bkref_ents + bkc_idx;\n\t  if (bkref_ent->node != node_idx || bkref_ent->str_idx != cur_str_idx)\n\t    continue;\n\t  subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;\n\t  new_dest_nodes = (subexp_len == 0\n\t\t\t    ? dfa->eclosures + dfa->edests[node_idx].elems[0]\n\t\t\t    : dfa->eclosures + dfa->nexts[node_idx]);\n\t  dest_str_idx = (cur_str_idx + bkref_ent->subexp_to\n\t\t\t  - bkref_ent->subexp_from);\n\t  context = re_string_context_at (&mctx->input, dest_str_idx - 1,\n\t\t\t\t\t  mctx->eflags);\n\t  dest_state = mctx->state_log[dest_str_idx];\n\t  prev_nelem = ((mctx->state_log[cur_str_idx] == NULL) ? 0\n\t\t\t: mctx->state_log[cur_str_idx]->nodes.nelem);\n\t  /* Add 'new_dest_node' to state_log.  */\n\t  if (dest_state == NULL)\n\t    {\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, new_dest_nodes,\n\t\t\t\t\t    context);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  else\n\t    {\n\t      re_node_set dest_nodes;\n\t      err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\t    dest_state->entrance_nodes,\n\t\t\t\t\t    new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&dest_nodes);\n\t\t  goto free_return;\n\t\t}\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n\t      re_node_set_free (&dest_nodes);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  /* We need to check recursively if the backreference can epsilon\n\t     transit.  */\n\t  if (subexp_len == 0\n\t      && mctx->state_log[cur_str_idx]->nodes.nelem > prev_nelem)\n\t    {\n\t      err = check_subexp_matching_top (mctx, new_dest_nodes,\n\t\t\t\t\t       cur_str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t      err = transit_state_bkref (mctx, new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t}\n    }\n  err = REG_NOERROR;\n free_return:\n  return err;\n}",
      "lines": 107,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "get_subexp": {
      "start_point": [
        2695,
        18
      ],
      "end_point": [
        2836,
        1
      ],
      "content": "__attribute_warn_unused_result__\nget_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx subexp_num, sub_top_idx;\n  const char *buf = (const char *) re_string_get_buffer (&mctx->input);\n  /* Return if we have already checked BKREF_NODE at BKREF_STR_IDX.  */\n  Idx cache_idx = search_cur_bkref_entry (mctx, bkref_str_idx);\n  if (cache_idx != -1)\n    {\n      const struct re_backref_cache_entry *entry\n\t= mctx->bkref_ents + cache_idx;\n      do\n\tif (entry->node == bkref_node)\n\t  return REG_NOERROR; /* We already checked it.  */\n      while (entry++->more);\n    }\n\n  subexp_num = dfa->nodes[bkref_node].opr.idx;\n\n  /* For each sub expression  */\n  for (sub_top_idx = 0; sub_top_idx < mctx->nsub_tops; ++sub_top_idx)\n    {\n      reg_errcode_t err;\n      re_sub_match_top_t *sub_top = mctx->sub_tops[sub_top_idx];\n      re_sub_match_last_t *sub_last;\n      Idx sub_last_idx, sl_str, bkref_str_off;\n\n      if (dfa->nodes[sub_top->node].opr.idx != subexp_num)\n\tcontinue; /* It isn't related.  */\n\n      sl_str = sub_top->str_idx;\n      bkref_str_off = bkref_str_idx;\n      /* At first, check the last node of sub expressions we already\n\t evaluated.  */\n      for (sub_last_idx = 0; sub_last_idx < sub_top->nlasts; ++sub_last_idx)\n\t{\n\t  regoff_t sl_str_diff;\n\t  sub_last = sub_top->lasts[sub_last_idx];\n\t  sl_str_diff = sub_last->str_idx - sl_str;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_diff > 0)\n\t    {\n\t      if (BE (bkref_str_off + sl_str_diff > mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* Not enough chars for a successful match.  */\n\t\t  if (bkref_str_off + sl_str_diff > mctx->input.len)\n\t\t    break;\n\n\t\t  err = clean_state_log_if_needed (mctx,\n\t\t\t\t\t\t   bkref_str_off\n\t\t\t\t\t\t   + sl_str_diff);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (memcmp (buf + bkref_str_off, buf + sl_str, sl_str_diff) != 0)\n\t\t/* We don't need to search this sub expression any more.  */\n\t\tbreak;\n\t    }\n\t  bkref_str_off += sl_str_diff;\n\t  sl_str += sl_str_diff;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\n\t  /* Reload buf, since the preceding call might have reallocated\n\t     the buffer.  */\n\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n\n      if (sub_last_idx < sub_top->nlasts)\n\tcontinue;\n      if (sub_last_idx > 0)\n\t++sl_str;\n      /* Then, search for the other last nodes of the sub expression.  */\n      for (; sl_str <= bkref_str_idx; ++sl_str)\n\t{\n\t  Idx cls_node;\n\t  regoff_t sl_str_off;\n\t  const re_node_set *nodes;\n\t  sl_str_off = sl_str - sub_top->str_idx;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_off > 0)\n\t    {\n\t      if (BE (bkref_str_off >= mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* If we are at the end of the input, we cannot match.  */\n\t\t  if (bkref_str_off >= mctx->input.len)\n\t\t    break;\n\n\t\t  err = extend_buffers (mctx, bkref_str_off + 1);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (buf [bkref_str_off++] != buf[sl_str - 1])\n\t\tbreak; /* We don't need to search this sub expression\n\t\t\t  any more.  */\n\t    }\n\t  if (mctx->state_log[sl_str] == NULL)\n\t    continue;\n\t  /* Does this state have a ')' of the sub expression?  */\n\t  nodes = &mctx->state_log[sl_str]->nodes;\n\t  cls_node = find_subexp_node (dfa, nodes, subexp_num,\n\t\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (cls_node == -1)\n\t    continue; /* No.  */\n\t  if (sub_top->path == NULL)\n\t    {\n\t      sub_top->path = calloc (sizeof (state_array_t),\n\t\t\t\t      sl_str - sub_top->str_idx + 1);\n\t      if (sub_top->path == NULL)\n\t\treturn REG_ESPACE;\n\t    }\n\t  /* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node\n\t     in the current context?  */\n\t  err = check_arrival (mctx, sub_top->path, sub_top->node,\n\t\t\t       sub_top->str_idx, cls_node, sl_str,\n\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (err == REG_NOMATCH)\n\t      continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  sub_last = match_ctx_add_sublast (sub_top, cls_node, sl_str);\n\t  if (BE (sub_last == NULL, 0))\n\t    return REG_ESPACE;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 142,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "get_subexp_sub": {
      "start_point": [
        2844,
        0
      ],
      "end_point": [
        2863,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nget_subexp_sub (re_match_context_t *mctx, const re_sub_match_top_t *sub_top,\n\t\tre_sub_match_last_t *sub_last, Idx bkref_node, Idx bkref_str)\n{\n  reg_errcode_t err;\n  Idx to_idx;\n  /* Can the subexpression arrive the back reference?  */\n  err = check_arrival (mctx, &sub_last->path, sub_last->node,\n\t\t       sub_last->str_idx, bkref_node, bkref_str,\n\t\t       OP_OPEN_SUBEXP);\n  if (err != REG_NOERROR)\n    return err;\n  err = match_ctx_add_entry (mctx, bkref_node, bkref_str, sub_top->str_idx,\n\t\t\t     sub_last->str_idx);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  to_idx = bkref_str + sub_last->str_idx - sub_top->str_idx;\n  return clean_state_log_if_needed (mctx, to_idx);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "find_subexp_node": {
      "start_point": [
        2873,
        0
      ],
      "end_point": [
        2888,
        1
      ],
      "content": "static Idx\ninternal_function\nfind_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t  Idx subexp_idx, int type)\n{\n  Idx cls_idx;\n  for (cls_idx = 0; cls_idx < nodes->nelem; ++cls_idx)\n    {\n      Idx cls_node = nodes->elems[cls_idx];\n      const re_token_t *node = dfa->nodes + cls_node;\n      if (node->type == type\n\t  && node->opr.idx == subexp_idx)\n\treturn cls_node;\n    }\n  return -1;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival": {
      "start_point": [
        2896,
        18
      ],
      "end_point": [
        3050,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival (re_match_context_t *mctx, state_array_t *path, Idx top_node,\n\t       Idx top_str, Idx last_node, Idx last_str, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  Idx subexp_num, backup_cur_idx, str_idx, null_cnt;\n  re_dfastate_t *cur_state = NULL;\n  re_node_set *cur_nodes, next_nodes;\n  re_dfastate_t **backup_state_log;\n  unsigned int context;\n\n  subexp_num = dfa->nodes[top_node].opr.idx;\n  /* Extend the buffer if we need.  */\n  if (BE (path->alloc < last_str + mctx->max_mb_elem_len + 1, 0))\n    {\n      re_dfastate_t **new_array;\n      Idx old_alloc = path->alloc;\n      Idx incr_alloc = last_str + mctx->max_mb_elem_len + 1;\n      Idx new_alloc;\n      if (BE (IDX_MAX - old_alloc < incr_alloc, 0))\n\treturn REG_ESPACE;\n      new_alloc = old_alloc + incr_alloc;\n      if (BE (SIZE_MAX / sizeof (re_dfastate_t *) < new_alloc, 0))\n\treturn REG_ESPACE;\n      new_array = re_realloc (path->array, re_dfastate_t *, new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      path->array = new_array;\n      path->alloc = new_alloc;\n      memset (new_array + old_alloc, '\\0',\n\t      sizeof (re_dfastate_t *) * (path->alloc - old_alloc));\n    }\n\n  str_idx = path->next_idx ? path->next_idx : top_str;\n\n  /* Temporary modify MCTX.  */\n  backup_state_log = mctx->state_log;\n  backup_cur_idx = mctx->input.cur_idx;\n  mctx->state_log = path->array;\n  mctx->input.cur_idx = str_idx;\n\n  /* Setup initial node set.  */\n  context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n  if (str_idx == top_str)\n    {\n      err = re_node_set_init_1 (&next_nodes, top_node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n      err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n      if (BE (err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n    }\n  else\n    {\n      cur_state = mctx->state_log[str_idx];\n      if (cur_state && cur_state->has_backref)\n\t{\n\t  err = re_node_set_init_copy (&next_nodes, &cur_state->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      else\n\tre_node_set_init_empty (&next_nodes);\n    }\n  if (str_idx == top_str || (cur_state && cur_state->has_backref))\n    {\n      if (next_nodes.nelem)\n\t{\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n    }\n\n  for (null_cnt = 0; str_idx < last_str && null_cnt <= mctx->max_mb_elem_len;)\n    {\n      re_node_set_empty (&next_nodes);\n      if (mctx->state_log[str_idx + 1])\n\t{\n\t  err = re_node_set_merge (&next_nodes,\n\t\t\t\t   &mctx->state_log[str_idx + 1]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      if (cur_state)\n\t{\n\t  err = check_arrival_add_next_nodes (mctx, str_idx,\n\t\t\t\t\t      &cur_state->non_eps_nodes,\n\t\t\t\t\t      &next_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      ++str_idx;\n      if (next_nodes.nelem)\n\t{\n\t  err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n      null_cnt = cur_state == NULL ? null_cnt + 1 : 0;\n    }\n  re_node_set_free (&next_nodes);\n  cur_nodes = (mctx->state_log[last_str] == NULL ? NULL\n\t       : &mctx->state_log[last_str]->nodes);\n  path->next_idx = str_idx;\n\n  /* Fix MCTX.  */\n  mctx->state_log = backup_state_log;\n  mctx->input.cur_idx = backup_cur_idx;\n\n  /* Then check the current node set has the node LAST_NODE.  */\n  if (cur_nodes != NULL && re_node_set_contains (cur_nodes, last_node))\n    return REG_NOERROR;\n\n  return REG_NOMATCH;\n}",
      "lines": 155,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_add_next_nodes": {
      "start_point": [
        3061,
        18
      ],
      "end_point": [
        3133,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,\n\t\t\t      re_node_set *cur_nodes, re_node_set *next_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  bool ok;\n  Idx cur_idx;\n#ifdef RE_ENABLE_I18N\n  reg_errcode_t err = REG_NOERROR;\n#endif\n  re_node_set union_set;\n  re_node_set_init_empty (&union_set);\n  for (cur_idx = 0; cur_idx < cur_nodes->nelem; ++cur_idx)\n    {\n      int naccepted = 0;\n      Idx cur_node = cur_nodes->elems[cur_idx];\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[cur_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[cur_node].accept_mb)\n\t{\n\t  naccepted = check_node_accept_bytes (dfa, cur_node, &mctx->input,\n\t\t\t\t\t       str_idx);\n\t  if (naccepted > 1)\n\t    {\n\t      re_dfastate_t *dest_state;\n\t      Idx next_node = dfa->nexts[cur_node];\n\t      Idx next_idx = str_idx + naccepted;\n\t      dest_state = mctx->state_log[next_idx];\n\t      re_node_set_empty (&union_set);\n\t      if (dest_state)\n\t\t{\n\t\t  err = re_node_set_merge (&union_set, &dest_state->nodes);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    {\n\t\t      re_node_set_free (&union_set);\n\t\t      return err;\n\t\t    }\n\t\t}\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return REG_ESPACE;\n\t\t}\n\t      mctx->state_log[next_idx] = re_acquire_state (&err, dfa,\n\t\t\t\t\t\t\t    &union_set);\n\t      if (BE (mctx->state_log[next_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return err;\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      if (naccepted\n\t  || check_node_accept (mctx, dfa->nodes + cur_node, str_idx))\n\t{\n\t  ok = re_node_set_insert (next_nodes, dfa->nexts[cur_node]);\n\t  if (BE (! ok, 0))\n\t    {\n\t      re_node_set_free (&union_set);\n\t      return REG_ESPACE;\n\t    }\n\t}\n    }\n  re_node_set_free (&union_set);\n  return REG_NOERROR;\n}",
      "lines": 73,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_expand_ecl": {
      "start_point": [
        3141,
        0
      ],
      "end_point": [
        3188,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_arrival_expand_ecl (const re_dfa_t *dfa, re_node_set *cur_nodes,\n\t\t\t  Idx ex_subexp, int type)\n{\n  reg_errcode_t err;\n  Idx idx, outside_node;\n  re_node_set new_nodes;\n#ifdef DEBUG\n  assert (cur_nodes->nelem);\n#endif\n  err = re_node_set_alloc (&new_nodes, cur_nodes->nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  /* Create a new node set NEW_NODES with the nodes which are epsilon\n     closures of the node in CUR_NODES.  */\n\n  for (idx = 0; idx < cur_nodes->nelem; ++idx)\n    {\n      Idx cur_node = cur_nodes->elems[idx];\n      const re_node_set *eclosure = dfa->eclosures + cur_node;\n      outside_node = find_subexp_node (dfa, eclosure, ex_subexp, type);\n      if (outside_node == -1)\n\t{\n\t  /* There are no problematic nodes, just merge them.  */\n\t  err = re_node_set_merge (&new_nodes, eclosure);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n      else\n\t{\n\t  /* There are problematic nodes, re-calculate incrementally.  */\n\t  err = check_arrival_expand_ecl_sub (dfa, &new_nodes, cur_node,\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n    }\n  re_node_set_free (cur_nodes);\n  *cur_nodes = new_nodes;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival_expand_ecl_sub": {
      "start_point": [
        3195,
        18
      ],
      "end_point": [
        3232,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_expand_ecl_sub (const re_dfa_t *dfa, re_node_set *dst_nodes,\n\t\t\t      Idx target, Idx ex_subexp, int type)\n{\n  Idx cur_node;\n  for (cur_node = target; !re_node_set_contains (dst_nodes, cur_node);)\n    {\n      bool ok;\n\n      if (dfa->nodes[cur_node].type == type\n\t  && dfa->nodes[cur_node].opr.idx == ex_subexp)\n\t{\n\t  if (type == OP_CLOSE_SUBEXP)\n\t    {\n\t      ok = re_node_set_insert (dst_nodes, cur_node);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\t  break;\n\t}\n      ok = re_node_set_insert (dst_nodes, cur_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n      if (dfa->edests[cur_node].nelem == 0)\n\tbreak;\n      if (dfa->edests[cur_node].nelem == 2)\n\t{\n\t  reg_errcode_t err;\n\t  err = check_arrival_expand_ecl_sub (dfa, dst_nodes,\n\t\t\t\t\t      dfa->edests[cur_node].elems[1],\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      cur_node = dfa->edests[cur_node].elems[0];\n    }\n  return REG_NOERROR;\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "expand_bkref_cache": {
      "start_point": [
        3240,
        18
      ],
      "end_point": [
        3323,
        1
      ],
      "content": "__attribute_warn_unused_result__\nexpand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t    Idx cur_str, Idx subexp_num, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx cache_idx_start = search_cur_bkref_entry (mctx, cur_str);\n  struct re_backref_cache_entry *ent;\n\n  if (cache_idx_start == -1)\n    return REG_NOERROR;\n\n restart:\n  ent = mctx->bkref_ents + cache_idx_start;\n  do\n    {\n      Idx to_idx, next_node;\n\n      /* Is this entry ENT is appropriate?  */\n      if (!re_node_set_contains (cur_nodes, ent->node))\n\tcontinue; /* No.  */\n\n      to_idx = cur_str + ent->subexp_to - ent->subexp_from;\n      /* Calculate the destination of the back reference, and append it\n\t to MCTX->STATE_LOG.  */\n      if (to_idx == cur_str)\n\t{\n\t  /* The backreference did epsilon transit, we must re-check all the\n\t     node in the current state.  */\n\t  re_node_set new_dests;\n\t  reg_errcode_t err2, err3;\n\t  next_node = dfa->edests[ent->node].elems[0];\n\t  if (re_node_set_contains (cur_nodes, next_node))\n\t    continue;\n\t  err = re_node_set_init_1 (&new_dests, next_node);\n\t  err2 = check_arrival_expand_ecl (dfa, &new_dests, subexp_num, type);\n\t  err3 = re_node_set_merge (cur_nodes, &new_dests);\n\t  re_node_set_free (&new_dests);\n\t  if (BE (err != REG_NOERROR || err2 != REG_NOERROR\n\t\t  || err3 != REG_NOERROR, 0))\n\t    {\n\t      err = (err != REG_NOERROR ? err\n\t\t     : (err2 != REG_NOERROR ? err2 : err3));\n\t      return err;\n\t    }\n\t  /* TODO: It is still inefficient...  */\n\t  goto restart;\n\t}\n      else\n\t{\n\t  re_node_set union_set;\n\t  next_node = dfa->nexts[ent->node];\n\t  if (mctx->state_log[to_idx])\n\t    {\n\t      bool ok;\n\t      if (re_node_set_contains (&mctx->state_log[to_idx]->nodes,\n\t\t\t\t\tnext_node))\n\t\tcontinue;\n\t      err = re_node_set_init_copy (&union_set,\n\t\t\t\t\t   &mctx->state_log[to_idx]->nodes);\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR || ! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  err = err != REG_NOERROR ? err : REG_ESPACE;\n\t\t  return err;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      err = re_node_set_init_1 (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  mctx->state_log[to_idx] = re_acquire_state (&err, dfa, &union_set);\n\t  re_node_set_free (&union_set);\n\t  if (BE (mctx->state_log[to_idx] == NULL\n\t\t  && err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  while (ent++->more);\n  return REG_NOERROR;\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "build_trtable": {
      "start_point": [
        3328,
        0
      ],
      "end_point": [
        3559,
        1
      ],
      "content": "static bool\ninternal_function\nbuild_trtable (const re_dfa_t *dfa, re_dfastate_t *state)\n{\n  reg_errcode_t err;\n  Idx i, j;\n  int ch;\n  bool need_word_trtable = false;\n  bitset_word_t elem, mask;\n  bool dests_node_malloced = false;\n  bool dest_states_malloced = false;\n  Idx ndests; /* Number of the destination states from 'state'.  */\n  re_dfastate_t **trtable;\n  re_dfastate_t **dest_states = NULL, **dest_states_word, **dest_states_nl;\n  re_node_set follows, *dests_node;\n  bitset_t *dests_ch;\n  bitset_t acceptable;\n\n  struct dests_alloc\n  {\n    re_node_set dests_node[SBC_MAX];\n    bitset_t dests_ch[SBC_MAX];\n  } *dests_alloc;\n\n  /* We build DFA states which corresponds to the destination nodes\n     from 'state'.  'dests_node[i]' represents the nodes which i-th\n     destination state contains, and 'dests_ch[i]' represents the\n     characters which i-th destination state accepts.  */\n  if (__libc_use_alloca (sizeof (struct dests_alloc)))\n    dests_alloc = (struct dests_alloc *) alloca (sizeof (struct dests_alloc));\n  else\n    {\n      dests_alloc = re_malloc (struct dests_alloc, 1);\n      if (BE (dests_alloc == NULL, 0))\n\treturn false;\n      dests_node_malloced = true;\n    }\n  dests_node = dests_alloc->dests_node;\n  dests_ch = dests_alloc->dests_ch;\n\n  /* Initialize transition table.  */\n  state->word_trtable = state->trtable = NULL;\n\n  /* At first, group all nodes belonging to 'state' into several\n     destinations.  */\n  ndests = group_nodes_into_DFAstates (dfa, state, dests_node, dests_ch);\n  if (BE (ndests <= 0, 0))\n    {\n      if (dests_node_malloced)\n\tfree (dests_alloc);\n      /* Return false in case of an error, true otherwise.  */\n      if (ndests == 0)\n\t{\n\t  state->trtable = (re_dfastate_t **)\n\t    calloc (sizeof (re_dfastate_t *), SBC_MAX);\n          if (BE (state->trtable == NULL, 0))\n            return false;\n\t  return true;\n\t}\n      return false;\n    }\n\n  err = re_node_set_alloc (&follows, ndests + 1);\n  if (BE (err != REG_NOERROR, 0))\n    goto out_free;\n\n  /* Avoid arithmetic overflow in size calculation.  */\n  if (BE ((((SIZE_MAX - (sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX)\n\t    / (3 * sizeof (re_dfastate_t *)))\n\t   < ndests),\n\t  0))\n    goto out_free;\n\n  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX\n\t\t\t + ndests * 3 * sizeof (re_dfastate_t *)))\n    dest_states = (re_dfastate_t **)\n      alloca (ndests * 3 * sizeof (re_dfastate_t *));\n  else\n    {\n      dest_states = (re_dfastate_t **)\n\tmalloc (ndests * 3 * sizeof (re_dfastate_t *));\n      if (BE (dest_states == NULL, 0))\n\t{\nout_free:\n\t  if (dest_states_malloced)\n\t    free (dest_states);\n\t  re_node_set_free (&follows);\n\t  for (i = 0; i < ndests; ++i)\n\t    re_node_set_free (dests_node + i);\n\t  if (dests_node_malloced)\n\t    free (dests_alloc);\n\t  return false;\n\t}\n      dest_states_malloced = true;\n    }\n  dest_states_word = dest_states + ndests;\n  dest_states_nl = dest_states_word + ndests;\n  bitset_empty (acceptable);\n\n  /* Then build the states for all destinations.  */\n  for (i = 0; i < ndests; ++i)\n    {\n      Idx next_node;\n      re_node_set_empty (&follows);\n      /* Merge the follows of this destination states.  */\n      for (j = 0; j < dests_node[i].nelem; ++j)\n\t{\n\t  next_node = dfa->nexts[dests_node[i].elems[j]];\n\t  if (next_node != -1)\n\t    {\n\t      err = re_node_set_merge (&follows, dfa->eclosures + next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto out_free;\n\t    }\n\t}\n      dest_states[i] = re_acquire_state_context (&err, dfa, &follows, 0);\n      if (BE (dest_states[i] == NULL && err != REG_NOERROR, 0))\n\tgoto out_free;\n      /* If the new state has context constraint,\n\t build appropriate states for these contexts.  */\n      if (dest_states[i]->has_constraint)\n\t{\n\t  dest_states_word[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\t  CONTEXT_WORD);\n\t  if (BE (dest_states_word[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\n\t  if (dest_states[i] != dest_states_word[i] && dfa->mb_cur_max > 1)\n\t    need_word_trtable = true;\n\n\t  dest_states_nl[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\tCONTEXT_NEWLINE);\n\t  if (BE (dest_states_nl[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\t}\n      else\n\t{\n\t  dest_states_word[i] = dest_states[i];\n\t  dest_states_nl[i] = dest_states[i];\n\t}\n      bitset_merge (acceptable, dests_ch[i]);\n    }\n\n  if (!BE (need_word_trtable, 0))\n    {\n      /* We don't care about whether the following character is a word\n\t character, or we are in a single-byte character set so we can\n\t discern by looking at the character code: allocate a\n\t 256-entry transition table.  */\n      trtable = state->trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      if (dfa->word_char[i] & mask)\n\t\ttrtable[ch] = dest_states_word[j];\n\t      else\n\t\ttrtable[ch] = dest_states[j];\n\t    }\n    }\n  else\n    {\n      /* We care about whether the following character is a word\n\t character, and we are in a multi-byte character set: discern\n\t by looking at the character code: build two 256-entry\n\t transition tables, one starting at trtable[0] and one\n\t starting at trtable[SBC_MAX].  */\n      trtable = state->word_trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), 2 * SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      trtable[ch] = dest_states[j];\n\t      trtable[ch + SBC_MAX] = dest_states_word[j];\n\t    }\n    }\n\n  /* new line */\n  if (bitset_contain (acceptable, NEWLINE_CHAR))\n    {\n      /* The current state accepts newline character.  */\n      for (j = 0; j < ndests; ++j)\n\tif (bitset_contain (dests_ch[j], NEWLINE_CHAR))\n\t  {\n\t    /* k-th destination accepts newline character.  */\n\t    trtable[NEWLINE_CHAR] = dest_states_nl[j];\n\t    if (need_word_trtable)\n\t      trtable[NEWLINE_CHAR + SBC_MAX] = dest_states_nl[j];\n\t    /* There must be only one destination which accepts\n\t       newline.  See group_nodes_into_DFAstates.  */\n\t    break;\n\t  }\n    }\n\n  if (dest_states_malloced)\n    free (dest_states);\n\n  re_node_set_free (&follows);\n  for (i = 0; i < ndests; ++i)\n    re_node_set_free (dests_node + i);\n\n  if (dests_node_malloced)\n    free (dests_alloc);\n\n  return true;\n}",
      "lines": 232,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "group_nodes_into_DFAstates": {
      "start_point": [
        3566,
        0
      ],
      "end_point": [
        3748,
        1
      ],
      "content": "static Idx\ninternal_function\ngroup_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,\n\t\t\t    re_node_set *dests_node, bitset_t *dests_ch)\n{\n  reg_errcode_t err;\n  bool ok;\n  Idx i, j, k;\n  Idx ndests; /* Number of the destinations from 'state'.  */\n  bitset_t accepts; /* Characters a node can accept.  */\n  const re_node_set *cur_nodes = &state->nodes;\n  bitset_empty (accepts);\n  ndests = 0;\n\n  /* For all the nodes belonging to 'state',  */\n  for (i = 0; i < cur_nodes->nelem; ++i)\n    {\n      re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      /* Enumerate all single byte character this node can accept.  */\n      if (type == CHARACTER)\n\tbitset_set (accepts, node->opr.c);\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  bitset_merge (accepts, node->opr.sbcset);\n\t}\n      else if (type == OP_PERIOD)\n\t{\n#ifdef RE_ENABLE_I18N\n\t  if (dfa->mb_cur_max > 1)\n\t    bitset_merge (accepts, dfa->sb_char);\n\t  else\n#endif\n\t    bitset_set_all (accepts);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == OP_UTF8_PERIOD)\n\t{\n\t  if (ASCII_CHARS % BITSET_WORD_BITS == 0)\n\t    memset (accepts, -1, ASCII_CHARS / CHAR_BIT);\n\t  else\n\t    bitset_merge (accepts, utf8_sb_map);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#endif\n      else\n\tcontinue;\n\n      /* Check the 'accepts' and sift the characters which are not\n\t match it the context.  */\n      if (constraint)\n\t{\n\t  if (constraint & NEXT_NEWLINE_CONSTRAINT)\n\t    {\n\t      bool accepts_newline = bitset_contain (accepts, NEWLINE_CHAR);\n\t      bitset_empty (accepts);\n\t      if (accepts_newline)\n\t\tbitset_set (accepts, NEWLINE_CHAR);\n\t      else\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_ENDBUF_CONSTRAINT)\n\t    {\n\t      bitset_empty (accepts);\n\t      continue;\n\t    }\n\n\t  if (constraint & NEXT_WORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && !node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= (dfa->word_char[j] | ~dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_NOTWORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~(dfa->word_char[j] & dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t}\n\n      /* Then divide 'accepts' into DFA states, or create a new\n\t state.  Above, we make sure that accepts is not empty.  */\n      for (j = 0; j < ndests; ++j)\n\t{\n\t  bitset_t intersec; /* Intersection sets, see below.  */\n\t  bitset_t remains;\n\t  /* Flags, see below.  */\n\t  bitset_word_t has_intersec, not_subset, not_consumed;\n\n\t  /* Optimization, skip if this state doesn't accept the character.  */\n\t  if (type == CHARACTER && !bitset_contain (dests_ch[j], node->opr.c))\n\t    continue;\n\n\t  /* Enumerate the intersection set of this state and 'accepts'.  */\n\t  has_intersec = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    has_intersec |= intersec[k] = accepts[k] & dests_ch[j][k];\n\t  /* And skip if the intersection set is empty.  */\n\t  if (!has_intersec)\n\t    continue;\n\n\t  /* Then check if this state is a subset of 'accepts'.  */\n\t  not_subset = not_consumed = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    {\n\t      not_subset |= remains[k] = ~accepts[k] & dests_ch[j][k];\n\t      not_consumed |= accepts[k] = accepts[k] & ~dests_ch[j][k];\n\t    }\n\n\t  /* If this state isn't a subset of 'accepts', create a\n\t     new group state, which has the 'remains'. */\n\t  if (not_subset)\n\t    {\n\t      bitset_copy (dests_ch[ndests], remains);\n\t      bitset_copy (dests_ch[j], intersec);\n\t      err = re_node_set_init_copy (dests_node + ndests, &dests_node[j]);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto error_return;\n\t      ++ndests;\n\t    }\n\n\t  /* Put the position in the current group. */\n\t  ok = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);\n\t  if (BE (! ok, 0))\n\t    goto error_return;\n\n\t  /* If all characters are consumed, go to next node. */\n\t  if (!not_consumed)\n\t    break;\n\t}\n      /* Some characters remain, create a new group. */\n      if (j == ndests)\n\t{\n\t  bitset_copy (dests_ch[ndests], accepts);\n\t  err = re_node_set_init_1 (dests_node + ndests, cur_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto error_return;\n\t  ++ndests;\n\t  bitset_empty (accepts);\n\t}\n    }\n  return ndests;\n error_return:\n  for (j = 0; j < ndests; ++j)\n    re_node_set_free (dests_node + j);\n  return -1;\n}",
      "lines": 183,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept_bytes": {
      "start_point": [
        3763,
        0
      ],
      "end_point": [
        3990,
        1
      ],
      "content": "static int\ninternal_function\ncheck_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,\n\t\t\t const re_string_t *input, Idx str_idx)\n{\n  const re_token_t *node = dfa->nodes + node_idx;\n  int char_len, elem_len;\n  Idx i;\n\n  if (BE (node->type == OP_UTF8_PERIOD, 0))\n    {\n      unsigned char c = re_string_byte_at (input, str_idx), d;\n      if (BE (c < 0xc2, 1))\n\treturn 0;\n\n      if (str_idx + 2 > input->len)\n\treturn 0;\n\n      d = re_string_byte_at (input, str_idx + 1);\n      if (c < 0xe0)\n\treturn (d < 0x80 || d > 0xbf) ? 0 : 2;\n      else if (c < 0xf0)\n\t{\n\t  char_len = 3;\n\t  if (c == 0xe0 && d < 0xa0)\n\t    return 0;\n\t}\n      else if (c < 0xf8)\n\t{\n\t  char_len = 4;\n\t  if (c == 0xf0 && d < 0x90)\n\t    return 0;\n\t}\n      else if (c < 0xfc)\n\t{\n\t  char_len = 5;\n\t  if (c == 0xf8 && d < 0x88)\n\t    return 0;\n\t}\n      else if (c < 0xfe)\n\t{\n\t  char_len = 6;\n\t  if (c == 0xfc && d < 0x84)\n\t    return 0;\n\t}\n      else\n\treturn 0;\n\n      if (str_idx + char_len > input->len)\n\treturn 0;\n\n      for (i = 1; i < char_len; ++i)\n\t{\n\t  d = re_string_byte_at (input, str_idx + i);\n\t  if (d < 0x80 || d > 0xbf)\n\t    return 0;\n\t}\n      return char_len;\n    }\n\n  char_len = re_string_char_size_at (input, str_idx);\n  if (node->type == OP_PERIOD)\n    {\n      if (char_len <= 1)\n\treturn 0;\n      /* FIXME: I don't think this if is needed, as both '\\n'\n\t and '\\0' are char_len == 1.  */\n      /* '.' accepts any one character except the following two cases.  */\n      if ((!(dfa->syntax & RE_DOT_NEWLINE) &&\n\t   re_string_byte_at (input, str_idx) == '\\n') ||\n\t  ((dfa->syntax & RE_DOT_NOT_NULL) &&\n\t   re_string_byte_at (input, str_idx) == '\\0'))\n\treturn 0;\n      return char_len;\n    }\n\n  elem_len = re_string_elem_size_at (input, str_idx);\n  if ((elem_len <= 1 && char_len <= 1) || char_len == 0)\n    return 0;\n\n  if (node->type == COMPLEX_BRACKET)\n    {\n      const re_charset_t *cset = node->opr.mbcset;\n# ifdef _LIBC\n      const unsigned char *pin\n\t= ((const unsigned char *) re_string_get_buffer (input) + str_idx);\n      Idx j;\n      uint32_t nrules;\n# endif /* _LIBC */\n      int match_len = 0;\n      wchar_t wc = ((cset->nranges || cset->nchar_classes || cset->nmbchars)\n\t\t    ? re_string_wchar_at (input, str_idx) : 0);\n\n      /* match with multibyte character?  */\n      for (i = 0; i < cset->nmbchars; ++i)\n\tif (wc == cset->mbchars[i])\n\t  {\n\t    match_len = char_len;\n\t    goto check_node_accept_bytes_match;\n\t  }\n      /* match with character_class?  */\n      for (i = 0; i < cset->nchar_classes; ++i)\n\t{\n\t  wctype_t wt = cset->char_classes[i];\n\t  if (__iswctype (wc, wt))\n\t    {\n\t      match_len = char_len;\n\t      goto check_node_accept_bytes_match;\n\t    }\n\t}\n\n# ifdef _LIBC\n      nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n      if (nrules != 0)\n\t{\n\t  unsigned int in_collseq = 0;\n\t  const int32_t *table, *indirect;\n\t  const unsigned char *weights, *extra;\n\t  const char *collseqwc;\n\n\t  /* match with collating_symbol?  */\n\t  if (cset->ncoll_syms)\n\t    extra = (const unsigned char *)\n\t      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n\t  for (i = 0; i < cset->ncoll_syms; ++i)\n\t    {\n\t      const unsigned char *coll_sym = extra + cset->coll_syms[i];\n\t      /* Compare the length of input collating element and\n\t\t the length of current collating element.  */\n\t      if (*coll_sym != elem_len)\n\t\tcontinue;\n\t      /* Compare each bytes.  */\n\t      for (j = 0; j < *coll_sym; j++)\n\t\tif (pin[j] != coll_sym[1 + j])\n\t\t  break;\n\t      if (j == *coll_sym)\n\t\t{\n\t\t  /* Match if every bytes is equal.  */\n\t\t  match_len = j;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\n\t  if (cset->nranges)\n\t    {\n\t      if (elem_len <= char_len)\n\t\t{\n\t\t  collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n\t\t  in_collseq = __collseq_table_lookup (collseqwc, wc);\n\t\t}\n\t      else\n\t\tin_collseq = find_collation_sequence_value (pin, elem_len);\n\t    }\n\t  /* match with range expression?  */\n\t  /* FIXME: Implement rational ranges here, too.  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    if (cset->range_starts[i] <= in_collseq\n\t\t&& in_collseq <= cset->range_ends[i])\n\t      {\n\t\tmatch_len = elem_len;\n\t\tgoto check_node_accept_bytes_match;\n\t      }\n\n\t  /* match with equivalence_class?  */\n\t  if (cset->nequiv_classes)\n\t    {\n\t      const unsigned char *cp = pin;\n\t      table = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t      weights = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n\t      extra = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n\t      indirect = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n\t      int32_t idx = findidx (table, indirect, extra, &cp, elem_len);\n\t      if (idx > 0)\n\t\tfor (i = 0; i < cset->nequiv_classes; ++i)\n\t\t  {\n\t\t    int32_t equiv_class_idx = cset->equiv_classes[i];\n\t\t    size_t weight_len = weights[idx & 0xffffff];\n\t\t    if (weight_len == weights[equiv_class_idx & 0xffffff]\n\t\t\t&& (idx >> 24) == (equiv_class_idx >> 24))\n\t\t      {\n\t\t\tIdx cnt = 0;\n\n\t\t\tidx &= 0xffffff;\n\t\t\tequiv_class_idx &= 0xffffff;\n\n\t\t\twhile (cnt <= weight_len\n\t\t\t       && (weights[equiv_class_idx + 1 + cnt]\n\t\t\t\t   == weights[idx + 1 + cnt]))\n\t\t\t  ++cnt;\n\t\t\tif (cnt > weight_len)\n\t\t\t  {\n\t\t\t    match_len = elem_len;\n\t\t\t    goto check_node_accept_bytes_match;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t    }\n\t}\n      else\n# endif /* _LIBC */\n\t{\n\t  /* match with range expression?  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    {\n\t      if (cset->range_starts[i] <= wc && wc <= cset->range_ends[i])\n\t\t{\n\t\t  match_len = char_len;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\t}\n    check_node_accept_bytes_match:\n      if (!cset->non_match)\n\treturn match_len;\n      else\n\t{\n\t  if (match_len > 0)\n\t    return 0;\n\t  else\n\t    return (elem_len > char_len) ? elem_len : char_len;\n\t}\n    }\n  return 0;\n}",
      "lines": 228,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "find_collation_sequence_value": {
      "start_point": [
        3993,
        0
      ],
      "end_point": [
        4050,
        1
      ],
      "content": "static unsigned int\ninternal_function\nfind_collation_sequence_value (const unsigned char *mbs, size_t mbs_len)\n{\n  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules == 0)\n    {\n      if (mbs_len == 1)\n\t{\n\t  /* No valid character.  Match it as a single byte character.  */\n\t  const unsigned char *collseq = (const unsigned char *)\n\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n\t  return collseq[mbs[0]];\n\t}\n      return UINT_MAX;\n    }\n  else\n    {\n      int32_t idx;\n      const unsigned char *extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n      int32_t extrasize = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB + 1) - extra;\n\n      for (idx = 0; idx < extrasize;)\n\t{\n\t  int mbs_cnt;\n\t  bool found = false;\n\t  int32_t elem_mbs_len;\n\t  /* Skip the name of collating element name.  */\n\t  idx = idx + extra[idx] + 1;\n\t  elem_mbs_len = extra[idx++];\n\t  if (mbs_len == elem_mbs_len)\n\t    {\n\t      for (mbs_cnt = 0; mbs_cnt < elem_mbs_len; ++mbs_cnt)\n\t\tif (extra[idx + mbs_cnt] != mbs[mbs_cnt])\n\t\t  break;\n\t      if (mbs_cnt == elem_mbs_len)\n\t\t/* Found the entry.  */\n\t\tfound = true;\n\t    }\n\t  /* Skip the byte sequence of the collating element.  */\n\t  idx += elem_mbs_len;\n\t  /* Adjust for the alignment.  */\n\t  idx = (idx + 3) & ~3;\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t  /* Skip the wide char sequence of the collating element.  */\n\t  idx = idx + sizeof (uint32_t) * (*(int32_t *) (extra + idx) + 1);\n\t  /* If we found the entry, return the sequence value.  */\n\t  if (found)\n\t    return *(uint32_t *) (extra + idx);\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t}\n      return UINT_MAX;\n    }\n}",
      "lines": 58,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept": {
      "start_point": [
        4057,
        0
      ],
      "end_point": [
        4103,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_node_accept (const re_match_context_t *mctx, const re_token_t *node,\n\t\t   Idx idx)\n{\n  unsigned char ch;\n  ch = re_string_byte_at (&mctx->input, idx);\n  switch (node->type)\n    {\n    case CHARACTER:\n      if (node->opr.c != ch)\n        return false;\n      break;\n\n    case SIMPLE_BRACKET:\n      if (!bitset_contain (node->opr.sbcset, ch))\n        return false;\n      break;\n\n#ifdef RE_ENABLE_I18N\n    case OP_UTF8_PERIOD:\n      if (ch >= ASCII_CHARS)\n        return false;\n      FALLTHROUGH;\n#endif\n    case OP_PERIOD:\n      if ((ch == '\\n' && !(mctx->dfa->syntax & RE_DOT_NEWLINE))\n\t  || (ch == '\\0' && (mctx->dfa->syntax & RE_DOT_NOT_NULL)))\n\treturn false;\n      break;\n\n    default:\n      return false;\n    }\n\n  if (node->constraint)\n    {\n      /* The node has constraints.  Check whether the current context\n\t satisfies the constraints.  */\n      unsigned int context = re_string_context_at (&mctx->input, idx,\n\t\t\t\t\t\t   mctx->eflags);\n      if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\treturn false;\n    }\n\n  return true;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "extend_buffers": {
      "start_point": [
        4108,
        18
      ],
      "end_point": [
        4166,
        1
      ],
      "content": "__attribute_warn_unused_result__\nextend_buffers (re_match_context_t *mctx, int min_len)\n{\n  reg_errcode_t ret;\n  re_string_t *pstr = &mctx->input;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) / 2\n          <= pstr->bufs_len, 0))\n    return REG_ESPACE;\n\n  /* Double the lengths of the buffers, but allocate at least MIN_LEN.  */\n  ret = re_string_realloc_buffers (pstr,\n\t\t\t\t   MAX (min_len,\n\t\t\t\t\tMIN (pstr->len, pstr->bufs_len * 2)));\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  if (mctx->state_log != NULL)\n    {\n      /* And double the length of state_log.  */\n      /* XXX We have no indication of the size of this buffer.  If this\n\t allocation fail we have no indication that the state_log array\n\t does not have the right size.  */\n      re_dfastate_t **new_array = re_realloc (mctx->state_log, re_dfastate_t *,\n\t\t\t\t\t      pstr->bufs_len + 1);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->state_log = new_array;\n    }\n\n  /* Then reconstruct the buffers.  */\n  if (pstr->icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\t{\n\t  ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (pstr->trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_init": {
      "start_point": [
        4174,
        18
      ],
      "end_point": [
        4202,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_init (re_match_context_t *mctx, int eflags, Idx n)\n{\n  mctx->eflags = eflags;\n  mctx->match_last = -1;\n  if (n > 0)\n    {\n      /* Avoid overflow.  */\n      size_t max_object_size =\n\tMAX (sizeof (struct re_backref_cache_entry),\n\t     sizeof (re_sub_match_top_t *));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < n, 0))\n\treturn REG_ESPACE;\n\n      mctx->bkref_ents = re_malloc (struct re_backref_cache_entry, n);\n      mctx->sub_tops = re_malloc (re_sub_match_top_t *, n);\n      if (BE (mctx->bkref_ents == NULL || mctx->sub_tops == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  /* Already zero-ed by the caller.\n     else\n       mctx->bkref_ents = NULL;\n     mctx->nbkref_ents = 0;\n     mctx->nsub_tops = 0;  */\n  mctx->abkref_ents = n;\n  mctx->max_mb_elem_len = 1;\n  mctx->asub_tops = n;\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_clean": {
      "start_point": [
        4208,
        0
      ],
      "end_point": [
        4234,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_clean (re_match_context_t *mctx)\n{\n  Idx st_idx;\n  for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)\n    {\n      Idx sl_idx;\n      re_sub_match_top_t *top = mctx->sub_tops[st_idx];\n      for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)\n\t{\n\t  re_sub_match_last_t *last = top->lasts[sl_idx];\n\t  re_free (last->path.array);\n\t  re_free (last);\n\t}\n      re_free (top->lasts);\n      if (top->path)\n\t{\n\t  re_free (top->path->array);\n\t  re_free (top->path);\n\t}\n      free (top);\n    }\n\n  mctx->nsub_tops = 0;\n  mctx->nbkref_ents = 0;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_free": {
      "start_point": [
        4238,
        0
      ],
      "end_point": [
        4246,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_free (re_match_context_t *mctx)\n{\n  /* First, free all the memory associated with MCTX->SUB_TOPS.  */\n  match_ctx_clean (mctx);\n  re_free (mctx->sub_tops);\n  re_free (mctx->bkref_ents);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_entry": {
      "start_point": [
        4254,
        18
      ],
      "end_point": [
        4297,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,\n\t\t     Idx to)\n{\n  if (mctx->nbkref_ents >= mctx->abkref_ents)\n    {\n      struct re_backref_cache_entry* new_entry;\n      new_entry = re_realloc (mctx->bkref_ents, struct re_backref_cache_entry,\n\t\t\t      mctx->abkref_ents * 2);\n      if (BE (new_entry == NULL, 0))\n\t{\n\t  re_free (mctx->bkref_ents);\n\t  return REG_ESPACE;\n\t}\n      mctx->bkref_ents = new_entry;\n      memset (mctx->bkref_ents + mctx->nbkref_ents, '\\0',\n\t      sizeof (struct re_backref_cache_entry) * mctx->abkref_ents);\n      mctx->abkref_ents *= 2;\n    }\n  if (mctx->nbkref_ents > 0\n      && mctx->bkref_ents[mctx->nbkref_ents - 1].str_idx == str_idx)\n    mctx->bkref_ents[mctx->nbkref_ents - 1].more = 1;\n\n  mctx->bkref_ents[mctx->nbkref_ents].node = node;\n  mctx->bkref_ents[mctx->nbkref_ents].str_idx = str_idx;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_from = from;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_to = to;\n\n  /* This is a cache that saves negative results of check_dst_limits_calc_pos.\n     If bit N is clear, means that this entry won't epsilon-transition to\n     an OP_OPEN_SUBEXP or OP_CLOSE_SUBEXP for the N+1-th subexpression.  If\n     it is set, check_dst_limits_calc_pos_1 will recurse and try to find one\n     such node.\n\n     A backreference does not epsilon-transition unless it is empty, so set\n     to all zeros if FROM != TO.  */\n  mctx->bkref_ents[mctx->nbkref_ents].eps_reachable_subexps_map\n    = (from == to ? -1 : 0);\n\n  mctx->bkref_ents[mctx->nbkref_ents++].more = 0;\n  if (mctx->max_mb_elem_len < to - from)\n    mctx->max_mb_elem_len = to - from;\n  return REG_NOERROR;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "search_cur_bkref_entry": {
      "start_point": [
        4302,
        0
      ],
      "end_point": [
        4320,
        1
      ],
      "content": "static Idx\ninternal_function\nsearch_cur_bkref_entry (const re_match_context_t *mctx, Idx str_idx)\n{\n  Idx left, right, mid, last;\n  last = right = mctx->nbkref_ents;\n  for (left = 0; left < right;)\n    {\n      mid = (left + right) / 2;\n      if (mctx->bkref_ents[mid].str_idx < str_idx)\n\tleft = mid + 1;\n      else\n\tright = mid;\n    }\n  if (left < last && mctx->bkref_ents[left].str_idx == str_idx)\n    return left;\n  else\n    return -1;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_subtop": {
      "start_point": [
        4326,
        18
      ],
      "end_point": [
        4350,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_subtop (re_match_context_t *mctx, Idx node, Idx str_idx)\n{\n#ifdef DEBUG\n  assert (mctx->sub_tops != NULL);\n  assert (mctx->asub_tops > 0);\n#endif\n  if (BE (mctx->nsub_tops == mctx->asub_tops, 0))\n    {\n      Idx new_asub_tops = mctx->asub_tops * 2;\n      re_sub_match_top_t **new_array = re_realloc (mctx->sub_tops,\n\t\t\t\t\t\t   re_sub_match_top_t *,\n\t\t\t\t\t\t   new_asub_tops);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->sub_tops = new_array;\n      mctx->asub_tops = new_asub_tops;\n    }\n  mctx->sub_tops[mctx->nsub_tops] = calloc (1, sizeof (re_sub_match_top_t));\n  if (BE (mctx->sub_tops[mctx->nsub_tops] == NULL, 0))\n    return REG_ESPACE;\n  mctx->sub_tops[mctx->nsub_tops]->node = node;\n  mctx->sub_tops[mctx->nsub_tops++]->str_idx = str_idx;\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_add_sublast": {
      "start_point": [
        4355,
        0
      ],
      "end_point": [
        4380,
        1
      ],
      "content": "static re_sub_match_last_t *\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)\n{\n  re_sub_match_last_t *new_entry;\n  if (BE (subtop->nlasts == subtop->alasts, 0))\n    {\n      Idx new_alasts = 2 * subtop->alasts + 1;\n      re_sub_match_last_t **new_array = re_realloc (subtop->lasts,\n\t\t\t\t\t\t    re_sub_match_last_t *,\n\t\t\t\t\t\t    new_alasts);\n      if (BE (new_array == NULL, 0))\n\treturn NULL;\n      subtop->lasts = new_array;\n      subtop->alasts = new_alasts;\n    }\n  new_entry = calloc (1, sizeof (re_sub_match_last_t));\n  if (BE (new_entry != NULL, 1))\n    {\n      subtop->lasts[subtop->nlasts] = new_entry;\n      new_entry->node = node;\n      new_entry->str_idx = str_idx;\n      ++subtop->nlasts;\n    }\n  return new_entry;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "re_sub_match_last_t",
        "*\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_ctx_init": {
      "start_point": [
        4382,
        0
      ],
      "end_point": [
        4392,
        1
      ],
      "content": "static void\ninternal_function\nsift_ctx_init (re_sift_context_t *sctx, re_dfastate_t **sifted_sts,\n\t       re_dfastate_t **limited_sts, Idx last_node, Idx last_str_idx)\n{\n  sctx->sifted_states = sifted_sts;\n  sctx->limited_states = limited_sts;\n  sctx->last_node = last_node;\n  sctx->last_str_idx = last_str_idx;\n  re_node_set_init_empty (&sctx->limits);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "tar/tar-1.30/gnu/regex_internal.c": {
    "re_string_allocate": {
      "start_point": [
        37,
        18
      ],
      "end_point": [
        60,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_allocate (re_string_t *pstr, const char *str, Idx len, Idx init_len,\n\t\t    RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  Idx init_buf_len;\n\n  /* Ensure at least one character fits into the buffers.  */\n  if (init_len < dfa->mb_cur_max)\n    init_len = dfa->mb_cur_max;\n  init_buf_len = (len + 1 < init_len) ? len + 1: init_len;\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  ret = re_string_realloc_buffers (pstr, init_buf_len);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  pstr->word_char = dfa->word_char;\n  pstr->word_ops_used = dfa->word_ops_used;\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n  pstr->valid_len = (pstr->mbs_allocated || dfa->mb_cur_max > 1) ? 0 : len;\n  pstr->valid_raw_len = pstr->valid_len;\n  return REG_NOERROR;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct": {
      "start_point": [
        65,
        18
      ],
      "end_point": [
        123,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_construct (re_string_t *pstr, const char *str, Idx len,\n\t\t     RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  memset (pstr, '\\0', sizeof (re_string_t));\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  if (len > 0)\n    {\n      ret = re_string_realloc_buffers (pstr, len + 1);\n      if (BE (ret != REG_NOERROR, 0))\n\treturn ret;\n    }\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n\n  if (icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (1)\n\t    {\n\t      ret = build_wcs_upper_buffer (pstr);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t      if (pstr->valid_raw_len >= len)\n\t\tbreak;\n\t      if (pstr->bufs_len > pstr->valid_len + dfa->mb_cur_max)\n\t\tbreak;\n\t      ret = re_string_realloc_buffers (pstr, pstr->bufs_len * 2);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t    }\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t  else\n\t    {\n\t      pstr->valid_len = pstr->bufs_len;\n\t      pstr->valid_raw_len = pstr->bufs_len;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_realloc_buffers": {
      "start_point": [
        128,
        18
      ],
      "end_point": [
        164,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_realloc_buffers (re_string_t *pstr, Idx new_buf_len)\n{\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      wint_t *new_wcs;\n\n      /* Avoid overflow in realloc.  */\n      const size_t max_object_size = MAX (sizeof (wint_t), sizeof (Idx));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_buf_len, 0))\n\treturn REG_ESPACE;\n\n      new_wcs = re_realloc (pstr->wcs, wint_t, new_buf_len);\n      if (BE (new_wcs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->wcs = new_wcs;\n      if (pstr->offsets != NULL)\n\t{\n\t  Idx *new_offsets = re_realloc (pstr->offsets, Idx, new_buf_len);\n\t  if (BE (new_offsets == NULL, 0))\n\t    return REG_ESPACE;\n\t  pstr->offsets = new_offsets;\n\t}\n    }\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    {\n      unsigned char *new_mbs = re_realloc (pstr->mbs, unsigned char,\n\t\t\t\t\t   new_buf_len);\n      if (BE (new_mbs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->mbs = new_mbs;\n    }\n  pstr->bufs_len = new_buf_len;\n  return REG_NOERROR;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct_common": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static void\ninternal_function\nre_string_construct_common (const char *str, Idx len, re_string_t *pstr,\n\t\t\t    RE_TRANSLATE_TYPE trans, bool icase,\n\t\t\t    const re_dfa_t *dfa)\n{\n  pstr->raw_mbs = (const unsigned char *) str;\n  pstr->len = len;\n  pstr->raw_len = len;\n  pstr->trans = trans;\n  pstr->icase = icase;\n  pstr->mbs_allocated = (trans != NULL || icase);\n  pstr->mb_cur_max = dfa->mb_cur_max;\n  pstr->is_utf8 = dfa->is_utf8;\n  pstr->map_notascii = dfa->map_notascii;\n  pstr->stop = pstr->len;\n  pstr->raw_stop = pstr->stop;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_buffer": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void\ninternal_function\nbuild_wcs_buffer (re_string_t *pstr)\n{\n#ifdef _LIBC\n  unsigned char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  unsigned char buf[64];\n#endif\n  mbstate_t prev_st;\n  Idx byte_idx, end_idx, remain_len;\n  size_t mbclen;\n\n  /* Build the buffers from pstr->valid_len to either pstr->len or\n     pstr->bufs_len.  */\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n  for (byte_idx = pstr->valid_len; byte_idx < end_idx;)\n    {\n      wchar_t wc;\n      const char *p;\n\n      remain_len = end_idx - byte_idx;\n      prev_st = pstr->cur_state;\n      /* Apply the translation if we need.  */\n      if (BE (pstr->trans != NULL, 0))\n\t{\n\t  int i, ch;\n\n\t  for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t    {\n\t      ch = pstr->raw_mbs [pstr->raw_mbs_idx + byte_idx + i];\n\t      buf[i] = pstr->mbs[byte_idx + i] = pstr->trans[ch];\n\t    }\n\t  p = (const char *) buf;\n\t}\n      else\n\tp = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + byte_idx;\n      mbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -1 || mbclen == 0\n\t      || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len), 0))\n\t{\n\t  /* We treat these cases as a singlebyte character.  */\n\t  mbclen = 1;\n\t  wc = (wchar_t) pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t  if (BE (pstr->trans != NULL, 0))\n\t    wc = pstr->trans[wc];\n\t  pstr->cur_state = prev_st;\n\t}\n      else if (BE (mbclen == (size_t) -2, 0))\n\t{\n\t  /* The buffer doesn't have enough space, finish to build.  */\n\t  pstr->cur_state = prev_st;\n\t  break;\n\t}\n\n      /* Write wide character and padding.  */\n      pstr->wcs[byte_idx++] = wc;\n      /* Write paddings.  */\n      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\tpstr->wcs[byte_idx++] = WEOF;\n    }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = byte_idx;\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_upper_buffer": {
      "start_point": [
        269,
        18
      ],
      "end_point": [
        480,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_wcs_upper_buffer (re_string_t *pstr)\n{\n  mbstate_t prev_st;\n  Idx src_idx, byte_idx, end_idx, remain_len;\n  size_t mbclen;\n#ifdef _LIBC\n  char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  char buf[64];\n#endif\n\n  byte_idx = pstr->valid_len;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  /* The following optimization assumes that ASCII characters can be\n     mapped to wide characters with a simple cast.  */\n  if (! pstr->map_notascii && pstr->trans == NULL && !pstr->offsets_needed)\n    {\n      while (byte_idx < end_idx)\n\t{\n\t  wchar_t wc;\n\n\t  if (isascii (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx])\n\t      && mbsinit (&pstr->cur_state))\n\t    {\n\t      /* In case of a singlebyte character.  */\n\t      pstr->mbs[byte_idx]\n\t\t= toupper (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx]);\n\t      /* The next step uses the assumption that wchar_t is encoded\n\t\t ASCII-safe: all ASCII values can be converted like this.  */\n\t      pstr->wcs[byte_idx] = (wchar_t) pstr->mbs[byte_idx];\n\t      ++byte_idx;\n\t      continue;\n\t    }\n\n\t  remain_len = end_idx - byte_idx;\n\t  prev_st = pstr->cur_state;\n\t  mbclen = __mbrtowc (&wc,\n\t\t\t      ((const char *) pstr->raw_mbs + pstr->raw_mbs_idx\n\t\t\t       + byte_idx), remain_len, &pstr->cur_state);\n\t  if (BE (mbclen < (size_t) -2, 1))\n\t    {\n\t      wchar_t wcu = __towupper (wc);\n\t      if (wcu != wc)\n\t\t{\n\t\t  size_t mbcdlen;\n\n\t\t  mbcdlen = __wcrtomb (buf, wcu, &prev_st);\n\t\t  if (BE (mbclen == mbcdlen, 1))\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\t  else\n\t\t    {\n\t\t      src_idx = byte_idx;\n\t\t      goto offsets_needed;\n\t\t    }\n\t\t}\n\t      else\n\t\tmemcpy (pstr->mbs + byte_idx,\n\t\t\tpstr->raw_mbs + pstr->raw_mbs_idx + byte_idx, mbclen);\n\t      pstr->wcs[byte_idx++] = wcu;\n\t      /* Write paddings.  */\n\t      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t\tpstr->wcs[byte_idx++] = WEOF;\n\t    }\n\t  else if (mbclen == (size_t) -1 || mbclen == 0\n\t\t   || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t    {\n\t      /* It is an invalid character, an incomplete character\n\t\t at the end of the string, or '\\0'.  Just use the byte.  */\n\t      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t      pstr->mbs[byte_idx] = ch;\n\t      /* And also cast it to wide char.  */\n\t      pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t      if (BE (mbclen == (size_t) -1, 0))\n\t\tpstr->cur_state = prev_st;\n\t    }\n\t  else\n\t    {\n\t      /* The buffer doesn't have enough space, finish to build.  */\n\t      pstr->cur_state = prev_st;\n\t      break;\n\t    }\n\t}\n      pstr->valid_len = byte_idx;\n      pstr->valid_raw_len = byte_idx;\n      return REG_NOERROR;\n    }\n  else\n    for (src_idx = pstr->valid_raw_len; byte_idx < end_idx;)\n      {\n\twchar_t wc;\n\tconst char *p;\n      offsets_needed:\n\tremain_len = end_idx - byte_idx;\n\tprev_st = pstr->cur_state;\n\tif (BE (pstr->trans != NULL, 0))\n\t  {\n\t    int i, ch;\n\n\t    for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t      {\n\t\tch = pstr->raw_mbs [pstr->raw_mbs_idx + src_idx + i];\n\t\tbuf[i] = pstr->trans[ch];\n\t      }\n\t    p = (const char *) buf;\n\t  }\n\telse\n\t  p = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + src_idx;\n\tmbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n\tif (BE (mbclen < (size_t) -2, 1))\n\t  {\n\t    wchar_t wcu = __towupper (wc);\n\t    if (wcu != wc)\n\t      {\n\t\tsize_t mbcdlen;\n\n\t\tmbcdlen = wcrtomb ((char *) buf, wcu, &prev_st);\n\t\tif (BE (mbclen == mbcdlen, 1))\n\t\t  memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\telse if (mbcdlen != (size_t) -1)\n\t\t  {\n\t\t    size_t i;\n\n\t\t    if (byte_idx + mbcdlen > pstr->bufs_len)\n\t\t      {\n\t\t\tpstr->cur_state = prev_st;\n\t\t\tbreak;\n\t\t      }\n\n\t\t    if (pstr->offsets == NULL)\n\t\t      {\n\t\t\tpstr->offsets = re_malloc (Idx, pstr->bufs_len);\n\n\t\t\tif (pstr->offsets == NULL)\n\t\t\t  return REG_ESPACE;\n\t\t      }\n\t\t    if (!pstr->offsets_needed)\n\t\t      {\n\t\t\tfor (i = 0; i < (size_t) byte_idx; ++i)\n\t\t\t  pstr->offsets[i] = i;\n\t\t\tpstr->offsets_needed = 1;\n\t\t      }\n\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbcdlen);\n\t\t    pstr->wcs[byte_idx] = wcu;\n\t\t    pstr->offsets[byte_idx] = src_idx;\n\t\t    for (i = 1; i < mbcdlen; ++i)\n\t\t      {\n\t\t\tpstr->offsets[byte_idx + i]\n\t\t\t  = src_idx + (i < mbclen ? i : mbclen - 1);\n\t\t\tpstr->wcs[byte_idx + i] = WEOF;\n\t\t      }\n\t\t    pstr->len += mbcdlen - mbclen;\n\t\t    if (pstr->raw_stop > src_idx)\n\t\t      pstr->stop += mbcdlen - mbclen;\n\t\t    end_idx = (pstr->bufs_len > pstr->len)\n\t\t\t      ? pstr->len : pstr->bufs_len;\n\t\t    byte_idx += mbcdlen;\n\t\t    src_idx += mbclen;\n\t\t    continue;\n\t\t  }\n\t\telse\n\t\t  memcpy (pstr->mbs + byte_idx, p, mbclen);\n\t      }\n\t    else\n\t      memcpy (pstr->mbs + byte_idx, p, mbclen);\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      {\n\t\tsize_t i;\n\t\tfor (i = 0; i < mbclen; ++i)\n\t\t  pstr->offsets[byte_idx + i] = src_idx + i;\n\t      }\n\t    src_idx += mbclen;\n\n\t    pstr->wcs[byte_idx++] = wcu;\n\t    /* Write paddings.  */\n\t    for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t      pstr->wcs[byte_idx++] = WEOF;\n\t  }\n\telse if (mbclen == (size_t) -1 || mbclen == 0\n\t\t || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t  {\n\t    /* It is an invalid character or '\\0'.  Just use the byte.  */\n\t    int ch = pstr->raw_mbs[pstr->raw_mbs_idx + src_idx];\n\n\t    if (BE (pstr->trans != NULL, 0))\n\t      ch = pstr->trans [ch];\n\t    pstr->mbs[byte_idx] = ch;\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      pstr->offsets[byte_idx] = src_idx;\n\t    ++src_idx;\n\n\t    /* And also cast it to wide char.  */\n\t    pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t    if (BE (mbclen == (size_t) -1, 0))\n\t      pstr->cur_state = prev_st;\n\t  }\n\telse\n\t  {\n\t    /* The buffer doesn't have enough space, finish to build.  */\n\t    pstr->cur_state = prev_st;\n\t    break;\n\t  }\n      }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = src_idx;\n  return REG_NOERROR;\n}",
      "lines": 212,
      "depth": 21,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_skip_chars": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "static Idx\ninternal_function\nre_string_skip_chars (re_string_t *pstr, Idx new_raw_idx, wint_t *last_wc)\n{\n  mbstate_t prev_st;\n  Idx rawbuf_idx;\n  size_t mbclen;\n  wint_t wc = WEOF;\n\n  /* Skip the characters which are not necessary to check.  */\n  for (rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;\n       rawbuf_idx < new_raw_idx;)\n    {\n      wchar_t wc2;\n      Idx remain_len = pstr->raw_len - rawbuf_idx;\n      prev_st = pstr->cur_state;\n      mbclen = __mbrtowc (&wc2, (const char *) pstr->raw_mbs + rawbuf_idx,\n\t\t\t  remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -2 || mbclen == (size_t) -1 || mbclen == 0, 0))\n\t{\n\t  /* We treat these cases as a single byte character.  */\n\t  if (mbclen == 0 || remain_len == 0)\n\t    wc = L'\\0';\n\t  else\n\t    wc = *(unsigned char *) (pstr->raw_mbs + rawbuf_idx);\n\t  mbclen = 1;\n\t  pstr->cur_state = prev_st;\n\t}\n      else\n\twc = wc2;\n      /* Then proceed the next character.  */\n      rawbuf_idx += mbclen;\n    }\n  *last_wc = wc;\n  return rawbuf_idx;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "build_upper_buffer": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "static void\ninternal_function\nbuild_upper_buffer (re_string_t *pstr)\n{\n  Idx char_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (char_idx = pstr->valid_len; char_idx < end_idx; ++char_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + char_idx];\n      if (BE (pstr->trans != NULL, 0))\n\tch = pstr->trans[ch];\n      pstr->mbs[char_idx] = toupper (ch);\n    }\n  pstr->valid_len = char_idx;\n  pstr->valid_raw_len = char_idx;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_translate_buffer": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "static void\ninternal_function\nre_string_translate_buffer (re_string_t *pstr)\n{\n  Idx buf_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + buf_idx];\n      pstr->mbs[buf_idx] = pstr->trans[ch];\n    }\n\n  pstr->valid_len = buf_idx;\n  pstr->valid_raw_len = buf_idx;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_reconstruct": {
      "start_point": [
        568,
        18
      ],
      "end_point": [
        828,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)\n{\n  Idx offset;\n\n  if (BE (pstr->raw_mbs_idx <= idx, 0))\n    offset = idx - pstr->raw_mbs_idx;\n  else\n    {\n      /* Reset buffer.  */\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tmemset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n#endif /* RE_ENABLE_I18N */\n      pstr->len = pstr->raw_len;\n      pstr->stop = pstr->raw_stop;\n      pstr->valid_len = 0;\n      pstr->raw_mbs_idx = 0;\n      pstr->valid_raw_len = 0;\n      pstr->offsets_needed = 0;\n      pstr->tip_context = ((eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF);\n      if (!pstr->mbs_allocated)\n\tpstr->mbs = (unsigned char *) pstr->raw_mbs;\n      offset = idx;\n    }\n\n  if (BE (offset != 0, 1))\n    {\n      /* Should the already checked characters be kept?  */\n      if (BE (offset < pstr->valid_raw_len, 1))\n\t{\n\t  /* Yes, move them to the front of the buffer.  */\n#ifdef RE_ENABLE_I18N\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      Idx low = 0, high = pstr->valid_len, mid;\n\t      do\n\t\t{\n\t\t  mid = (high + low) / 2;\n\t\t  if (pstr->offsets[mid] > offset)\n\t\t    high = mid;\n\t\t  else if (pstr->offsets[mid] < offset)\n\t\t    low = mid + 1;\n\t\t  else\n\t\t    break;\n\t\t}\n\t      while (low < high);\n\t      if (pstr->offsets[mid] < offset)\n\t\t++mid;\n\t      pstr->tip_context = re_string_context_at (pstr, mid - 1,\n\t\t\t\t\t\t\teflags);\n\t      /* This can be quite complicated, so handle specially\n\t\t only the common and easy case where the character with\n\t\t different length representation of lower and upper\n\t\t case is present at or after offset.  */\n\t      if (pstr->valid_len > offset\n\t\t  && mid == offset && pstr->offsets[mid] == offset)\n\t\t{\n\t\t  memmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t   (pstr->valid_len - offset) * sizeof (wint_t));\n\t\t  memmove (pstr->mbs, pstr->mbs + offset, pstr->valid_len - offset);\n\t\t  pstr->valid_len -= offset;\n\t\t  pstr->valid_raw_len -= offset;\n\t\t  for (low = 0; low < pstr->valid_len; low++)\n\t\t    pstr->offsets[low] = pstr->offsets[low + offset] - offset;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Otherwise, just find out how long the partial multibyte\n\t\t     character at offset is and fill it with WEOF/255.  */\n\t\t  pstr->len = pstr->raw_len - idx + offset;\n\t\t  pstr->stop = pstr->raw_stop - idx + offset;\n\t\t  pstr->offsets_needed = 0;\n\t\t  while (mid > 0 && pstr->offsets[mid - 1] == offset)\n\t\t    --mid;\n\t\t  while (mid < pstr->valid_len)\n\t\t    if (pstr->wcs[mid] != WEOF)\n\t\t      break;\n\t\t    else\n\t\t      ++mid;\n\t\t  if (mid == pstr->valid_len)\n\t\t    pstr->valid_len = 0;\n\t\t  else\n\t\t    {\n\t\t      pstr->valid_len = pstr->offsets[mid] - offset;\n\t\t      if (pstr->valid_len)\n\t\t\t{\n\t\t\t  for (low = 0; low < pstr->valid_len; ++low)\n\t\t\t    pstr->wcs[low] = WEOF;\n\t\t\t  memset (pstr->mbs, 255, pstr->valid_len);\n\t\t\t}\n\t\t    }\n\t\t  pstr->valid_raw_len = pstr->valid_len;\n\t\t}\n\t    }\n\t  else\n#endif\n\t    {\n\t      pstr->tip_context = re_string_context_at (pstr, offset - 1,\n\t\t\t\t\t\t\teflags);\n#ifdef RE_ENABLE_I18N\n\t      if (pstr->mb_cur_max > 1)\n\t\tmemmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t (pstr->valid_len - offset) * sizeof (wint_t));\n#endif /* RE_ENABLE_I18N */\n\t      if (BE (pstr->mbs_allocated, 0))\n\t\tmemmove (pstr->mbs, pstr->mbs + offset,\n\t\t\t pstr->valid_len - offset);\n\t      pstr->valid_len -= offset;\n\t      pstr->valid_raw_len -= offset;\n#if defined DEBUG && DEBUG\n\t      assert (pstr->valid_len > 0);\n#endif\n\t    }\n\t}\n      else\n\t{\n#ifdef RE_ENABLE_I18N\n\t  /* No, skip all characters until IDX.  */\n\t  Idx prev_valid_len = pstr->valid_len;\n\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      pstr->len = pstr->raw_len - idx + offset;\n\t      pstr->stop = pstr->raw_stop - idx + offset;\n\t      pstr->offsets_needed = 0;\n\t    }\n#endif\n\t  pstr->valid_len = 0;\n#ifdef RE_ENABLE_I18N\n\t  if (pstr->mb_cur_max > 1)\n\t    {\n\t      Idx wcs_idx;\n\t      wint_t wc = WEOF;\n\n\t      if (pstr->is_utf8)\n\t\t{\n\t\t  const unsigned char *raw, *p, *end;\n\n\t\t  /* Special case UTF-8.  Multi-byte chars start with any\n\t\t     byte other than 0x80 - 0xbf.  */\n\t\t  raw = pstr->raw_mbs + pstr->raw_mbs_idx;\n\t\t  end = raw + (offset - pstr->mb_cur_max);\n\t\t  if (end < pstr->raw_mbs)\n\t\t    end = pstr->raw_mbs;\n\t\t  p = raw + offset - 1;\n#ifdef _LIBC\n\t\t  /* We know the wchar_t encoding is UCS4, so for the simple\n\t\t     case, ASCII characters, skip the conversion step.  */\n\t\t  if (isascii (*p) && BE (pstr->trans == NULL, 1))\n\t\t    {\n\t\t      memset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n\t\t      /* pstr->valid_len = 0; */\n\t\t      wc = (wchar_t) *p;\n\t\t    }\n\t\t  else\n#endif\n\t\t    for (; p >= end; --p)\n\t\t      if ((*p & 0xc0) != 0x80)\n\t\t\t{\n\t\t\t  mbstate_t cur_state;\n\t\t\t  wchar_t wc2;\n\t\t\t  Idx mlen = raw + pstr->len - p;\n\t\t\t  unsigned char buf[6];\n\t\t\t  size_t mbclen;\n\n\t\t\t  const unsigned char *pp = p;\n\t\t\t  if (BE (pstr->trans != NULL, 0))\n\t\t\t    {\n\t\t\t      int i = mlen < 6 ? mlen : 6;\n\t\t\t      while (--i >= 0)\n\t\t\t\tbuf[i] = pstr->trans[p[i]];\n\t\t\t      pp = buf;\n\t\t\t    }\n\t\t\t  /* XXX Don't use mbrtowc, we know which conversion\n\t\t\t     to use (UTF-8 -> UCS4).  */\n\t\t\t  memset (&cur_state, 0, sizeof (cur_state));\n\t\t\t  mbclen = __mbrtowc (&wc2, (const char *) pp, mlen,\n\t\t\t\t\t      &cur_state);\n\t\t\t  if (raw + offset - p <= mbclen\n\t\t\t      && mbclen < (size_t) -2)\n\t\t\t    {\n\t\t\t      memset (&pstr->cur_state, '\\0',\n\t\t\t\t      sizeof (mbstate_t));\n\t\t\t      pstr->valid_len = mbclen - (raw + offset - p);\n\t\t\t      wc = wc2;\n\t\t\t    }\n\t\t\t  break;\n\t\t\t}\n\t\t}\n\n\t      if (wc == WEOF)\n\t\tpstr->valid_len = re_string_skip_chars (pstr, idx, &wc) - idx;\n\t      if (wc == WEOF)\n\t\tpstr->tip_context\n\t\t  = re_string_context_at (pstr, prev_valid_len - 1, eflags);\n\t      else\n\t\tpstr->tip_context = ((BE (pstr->word_ops_used != 0, 0)\n\t\t\t\t      && IS_WIDE_WORD_CHAR (wc))\n\t\t\t\t     ? CONTEXT_WORD\n\t\t\t\t     : ((IS_WIDE_NEWLINE (wc)\n\t\t\t\t\t && pstr->newline_anchor)\n\t\t\t\t\t? CONTEXT_NEWLINE : 0));\n\t      if (BE (pstr->valid_len, 0))\n\t\t{\n\t\t  for (wcs_idx = 0; wcs_idx < pstr->valid_len; ++wcs_idx)\n\t\t    pstr->wcs[wcs_idx] = WEOF;\n\t\t  if (pstr->mbs_allocated)\n\t\t    memset (pstr->mbs, 255, pstr->valid_len);\n\t\t}\n\t      pstr->valid_raw_len = pstr->valid_len;\n\t    }\n\t  else\n#endif /* RE_ENABLE_I18N */\n\t    {\n\t      int c = pstr->raw_mbs[pstr->raw_mbs_idx + offset - 1];\n\t      pstr->valid_raw_len = 0;\n\t      if (pstr->trans)\n\t\tc = pstr->trans[c];\n\t      pstr->tip_context = (bitset_contain (pstr->word_char, c)\n\t\t\t\t   ? CONTEXT_WORD\n\t\t\t\t   : ((IS_NEWLINE (c) && pstr->newline_anchor)\n\t\t\t\t      ? CONTEXT_NEWLINE : 0));\n\t    }\n\t}\n      if (!BE (pstr->mbs_allocated, 0))\n\tpstr->mbs += offset;\n    }\n  pstr->raw_mbs_idx = idx;\n  pstr->len -= offset;\n  pstr->stop -= offset;\n\n  /* Then build the buffers.  */\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      if (pstr->icase)\n\t{\n\t  reg_errcode_t ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n\tbuild_wcs_buffer (pstr);\n    }\n  else\n#endif /* RE_ENABLE_I18N */\n    if (BE (pstr->mbs_allocated, 0))\n      {\n\tif (pstr->icase)\n\t  build_upper_buffer (pstr);\n\telse if (pstr->trans != NULL)\n\t  re_string_translate_buffer (pstr);\n      }\n    else\n      pstr->valid_len = pstr->len;\n\n  pstr->cur_idx = 0;\n  return REG_NOERROR;\n}",
      "lines": 261,
      "depth": 23,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "internal_function": {
      "start_point": [
        831,
        18
      ],
      "end_point": [
        865,
        1
      ],
      "content": "__attribute__ ((pure))\nre_string_peek_byte_case (const re_string_t *pstr, Idx idx)\n{\n  int ch;\n  Idx off;\n\n  /* Handle the common (easiest) cases first.  */\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_peek_byte (pstr, idx);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1\n      && ! re_string_is_single_byte_char (pstr, pstr->cur_idx + idx))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  off = pstr->cur_idx + idx;\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    off = pstr->offsets[off];\n#endif\n\n  ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure that e.g. for tr_TR.UTF-8 BACKSLASH DOTLESS SMALL LETTER I\n     this function returns CAPITAL LETTER I instead of first byte of\n     DOTLESS SMALL LETTER I.  The latter would confuse the parser,\n     since peek_byte_case doesn't advance cur_idx in any way.  */\n  if (pstr->offsets_needed && !isascii (ch))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  return ch;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": null
    },
    "re_string_fetch_byte_case": {
      "start_point": [
        867,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "static unsigned char\ninternal_function\nre_string_fetch_byte_case (re_string_t *pstr)\n{\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_fetch_byte (pstr);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    {\n      Idx off;\n      int ch;\n\n      /* For tr_TR.UTF-8 [[:islower:]] there is\n\t [[: CAPITAL LETTER I WITH DOT lower:]] in mbs.  Skip\n\t in that case the whole multi-byte character and return\n\t the original letter.  On the other side, with\n\t [[: DOTLESS SMALL LETTER I return [[:I, as doing\n\t anything else would complicate things too much.  */\n\n      if (!re_string_first_byte (pstr, pstr->cur_idx))\n\treturn re_string_fetch_byte (pstr);\n\n      off = pstr->offsets[pstr->cur_idx];\n      ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n      if (! isascii (ch))\n\treturn re_string_fetch_byte (pstr);\n\n      re_string_skip_bytes (pstr,\n\t\t\t    re_string_char_size_at (pstr, pstr->cur_idx));\n      return ch;\n    }\n#endif\n\n  return pstr->raw_mbs[pstr->raw_mbs_idx + pstr->cur_idx++];\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_destruct": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "static void\ninternal_function\nre_string_destruct (re_string_t *pstr)\n{\n#ifdef RE_ENABLE_I18N\n  re_free (pstr->wcs);\n  re_free (pstr->offsets);\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    re_free (pstr->mbs);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_context_at": {
      "start_point": [
        919,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "static unsigned int\ninternal_function\nre_string_context_at (const re_string_t *input, Idx idx, int eflags)\n{\n  int c;\n  if (BE (idx < 0, 0))\n    /* In this case, we use the value stored in input->tip_context,\n       since we can't know the character in input->mbs[-1] here.  */\n    return input->tip_context;\n  if (BE (idx == input->len, 0))\n    return ((eflags & REG_NOTEOL) ? CONTEXT_ENDBUF\n\t    : CONTEXT_NEWLINE | CONTEXT_ENDBUF);\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc;\n      Idx wc_idx = idx;\n      while(input->wcs[wc_idx] == WEOF)\n\t{\n#if defined DEBUG && DEBUG\n\t  /* It must not happen.  */\n\t  assert (wc_idx >= 0);\n#endif\n\t  --wc_idx;\n\t  if (wc_idx < 0)\n\t    return input->tip_context;\n\t}\n      wc = input->wcs[wc_idx];\n      if (BE (input->word_ops_used != 0, 0) && IS_WIDE_WORD_CHAR (wc))\n\treturn CONTEXT_WORD;\n      return (IS_WIDE_NEWLINE (wc) && input->newline_anchor\n\t      ? CONTEXT_NEWLINE : 0);\n    }\n  else\n#endif\n    {\n      c = re_string_byte_at (input, idx);\n      if (bitset_contain (input->word_char, c))\n\treturn CONTEXT_WORD;\n      return IS_NEWLINE (c) && input->newline_anchor ? CONTEXT_NEWLINE : 0;\n    }\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "re_node_set_alloc": {
      "start_point": [
        965,
        18
      ],
      "end_point": [
        974,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_alloc (re_node_set *set, Idx size)\n{\n  set->alloc = size;\n  set->nelem = 0;\n  set->elems = re_malloc (Idx, size);\n  if (BE (set->elems == NULL, 0) && (MALLOC_0_IS_NONNULL || size != 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_1": {
      "start_point": [
        977,
        18
      ],
      "end_point": [
        990,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_1 (re_node_set *set, Idx elem)\n{\n  set->alloc = 1;\n  set->nelem = 1;\n  set->elems = re_malloc (Idx, 1);\n  if (BE (set->elems == NULL, 0))\n    {\n      set->alloc = set->nelem = 0;\n      return REG_ESPACE;\n    }\n  set->elems[0] = elem;\n  return REG_NOERROR;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_2": {
      "start_point": [
        993,
        18
      ],
      "end_point": [
        1020,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_2 (re_node_set *set, Idx elem1, Idx elem2)\n{\n  set->alloc = 2;\n  set->elems = re_malloc (Idx, 2);\n  if (BE (set->elems == NULL, 0))\n    return REG_ESPACE;\n  if (elem1 == elem2)\n    {\n      set->nelem = 1;\n      set->elems[0] = elem1;\n    }\n  else\n    {\n      set->nelem = 2;\n      if (elem1 < elem2)\n\t{\n\t  set->elems[0] = elem1;\n\t  set->elems[1] = elem2;\n\t}\n      else\n\t{\n\t  set->elems[0] = elem2;\n\t  set->elems[1] = elem1;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_copy": {
      "start_point": [
        1023,
        18
      ],
      "end_point": [
        1041,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_copy (re_node_set *dest, const re_node_set *src)\n{\n  dest->nelem = src->nelem;\n  if (src->nelem > 0)\n    {\n      dest->alloc = dest->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\t{\n\t  dest->alloc = dest->nelem = 0;\n\t  return REG_ESPACE;\n\t}\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n    }\n  else\n    re_node_set_init_empty (dest);\n  return REG_NOERROR;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_add_intersect": {
      "start_point": [
        1048,
        18
      ],
      "end_point": [
        1133,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,\n\t\t\t   const re_node_set *src2)\n{\n  Idx i1, i2, is, id, delta, sbase;\n  if (src1->nelem == 0 || src2->nelem == 0)\n    return REG_NOERROR;\n\n  /* We need dest->nelem + 2 * elems_in_intersection; this is a\n     conservative estimate.  */\n  if (src1->nelem + src2->nelem + dest->nelem > dest->alloc)\n    {\n      Idx new_alloc = src1->nelem + src2->nelem + dest->alloc;\n      Idx *new_elems = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_elems;\n      dest->alloc = new_alloc;\n    }\n\n  /* Find the items in the intersection of SRC1 and SRC2, and copy\n     into the top of DEST those that are not already in DEST itself.  */\n  sbase = dest->nelem + src1->nelem + src2->nelem;\n  i1 = src1->nelem - 1;\n  i2 = src2->nelem - 1;\n  id = dest->nelem - 1;\n  for (;;)\n    {\n      if (src1->elems[i1] == src2->elems[i2])\n\t{\n\t  /* Try to find the item in DEST.  Maybe we could binary search?  */\n\t  while (id >= 0 && dest->elems[id] > src1->elems[i1])\n\t    --id;\n\n\t  if (id < 0 || dest->elems[id] != src1->elems[i1])\n            dest->elems[--sbase] = src1->elems[i1];\n\n\t  if (--i1 < 0 || --i2 < 0)\n\t    break;\n\t}\n\n      /* Lower the highest of the two items.  */\n      else if (src1->elems[i1] < src2->elems[i2])\n\t{\n\t  if (--i2 < 0)\n\t    break;\n\t}\n      else\n\t{\n\t  if (--i1 < 0)\n\t    break;\n\t}\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + src1->nelem + src2->nelem - 1;\n  delta = is - sbase + 1;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place; this is more or\n     less the same loop that is in re_node_set_merge.  */\n  dest->nelem += delta;\n  if (delta > 0 && id >= 0)\n    for (;;)\n      {\n\tif (dest->elems[is] > dest->elems[id])\n\t  {\n\t    /* Copy from the top.  */\n\t    dest->elems[id + delta--] = dest->elems[is--];\n\t    if (delta == 0)\n\t      break;\n\t  }\n\telse\n\t  {\n\t    /* Slide from the bottom.  */\n\t    dest->elems[id + delta] = dest->elems[id];\n\t    if (--id < 0)\n\t      break;\n\t  }\n      }\n\n  /* Copy remaining SRC elements.  */\n  memcpy (dest->elems, dest->elems + sbase, delta * sizeof (Idx));\n\n  return REG_NOERROR;\n}",
      "lines": 86,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_union": {
      "start_point": [
        1139,
        18
      ],
      "end_point": [
        1186,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_union (re_node_set *dest, const re_node_set *src1,\n\t\t\tconst re_node_set *src2)\n{\n  Idx i1, i2, id;\n  if (src1 != NULL && src1->nelem > 0 && src2 != NULL && src2->nelem > 0)\n    {\n      dest->alloc = src1->nelem + src2->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  else\n    {\n      if (src1 != NULL && src1->nelem > 0)\n\treturn re_node_set_init_copy (dest, src1);\n      else if (src2 != NULL && src2->nelem > 0)\n\treturn re_node_set_init_copy (dest, src2);\n      else\n\tre_node_set_init_empty (dest);\n      return REG_NOERROR;\n    }\n  for (i1 = i2 = id = 0 ; i1 < src1->nelem && i2 < src2->nelem ;)\n    {\n      if (src1->elems[i1] > src2->elems[i2])\n\t{\n\t  dest->elems[id++] = src2->elems[i2++];\n\t  continue;\n\t}\n      if (src1->elems[i1] == src2->elems[i2])\n\t++i2;\n      dest->elems[id++] = src1->elems[i1++];\n    }\n  if (i1 < src1->nelem)\n    {\n      memcpy (dest->elems + id, src1->elems + i1,\n\t     (src1->nelem - i1) * sizeof (Idx));\n      id += src1->nelem - i1;\n    }\n  else if (i2 < src2->nelem)\n    {\n      memcpy (dest->elems + id, src2->elems + i2,\n\t     (src2->nelem - i2) * sizeof (Idx));\n      id += src2->nelem - i2;\n    }\n  dest->nelem = id;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_merge": {
      "start_point": [
        1192,
        18
      ],
      "end_point": [
        1268,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_merge (re_node_set *dest, const re_node_set *src)\n{\n  Idx is, id, sbase, delta;\n  if (src == NULL || src->nelem == 0)\n    return REG_NOERROR;\n  if (dest->alloc < 2 * src->nelem + dest->nelem)\n    {\n      Idx new_alloc = 2 * (src->nelem + dest->alloc);\n      Idx *new_buffer = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_buffer == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_buffer;\n      dest->alloc = new_alloc;\n    }\n\n  if (BE (dest->nelem == 0, 0))\n    {\n      dest->nelem = src->nelem;\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n      return REG_NOERROR;\n    }\n\n  /* Copy into the top of DEST the items of SRC that are not\n     found in DEST.  Maybe we could binary search in DEST?  */\n  for (sbase = dest->nelem + 2 * src->nelem,\n       is = src->nelem - 1, id = dest->nelem - 1; is >= 0 && id >= 0; )\n    {\n      if (dest->elems[id] == src->elems[is])\n\tis--, id--;\n      else if (dest->elems[id] < src->elems[is])\n\tdest->elems[--sbase] = src->elems[is--];\n      else /* if (dest->elems[id] > src->elems[is]) */\n\t--id;\n    }\n\n  if (is >= 0)\n    {\n      /* If DEST is exhausted, the remaining items of SRC must be unique.  */\n      sbase -= is + 1;\n      memcpy (dest->elems + sbase, src->elems, (is + 1) * sizeof (Idx));\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + 2 * src->nelem - 1;\n  delta = is - sbase + 1;\n  if (delta == 0)\n    return REG_NOERROR;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place.  */\n  dest->nelem += delta;\n  for (;;)\n    {\n      if (dest->elems[is] > dest->elems[id])\n\t{\n\t  /* Copy from the top.  */\n\t  dest->elems[id + delta--] = dest->elems[is--];\n\t  if (delta == 0)\n\t    break;\n\t}\n      else\n\t{\n\t  /* Slide from the bottom.  */\n\t  dest->elems[id + delta] = dest->elems[id];\n\t  if (--id < 0)\n\t    {\n\t      /* Copy remaining SRC elements.  */\n\t      memcpy (dest->elems, dest->elems + sbase,\n\t\t      delta * sizeof (Idx));\n\t      break;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert": {
      "start_point": [
        1275,
        18
      ],
      "end_point": [
        1320,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert (re_node_set *set, Idx elem)\n{\n  Idx idx;\n  /* In case the set is empty.  */\n  if (set->alloc == 0)\n    return BE (re_node_set_init_1 (set, elem) == REG_NOERROR, 1);\n\n  if (BE (set->nelem, 0) == 0)\n    {\n      /* We already guaranteed above that set->alloc != 0.  */\n      set->elems[0] = elem;\n      ++set->nelem;\n      return true;\n    }\n\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = set->alloc * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Move the elements which follows the new element.  Test the\n     first element separately to skip a check in the inner loop.  */\n  if (elem < set->elems[0])\n    {\n      idx = 0;\n      for (idx = set->nelem; idx > 0; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n  else\n    {\n      for (idx = set->nelem; set->elems[idx - 1] > elem; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n\n  /* Insert the new element.  */\n  set->elems[idx] = elem;\n  ++set->nelem;\n  return true;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert_last": {
      "start_point": [
        1327,
        18
      ],
      "end_point": [
        1344,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert_last (re_node_set *set, Idx elem)\n{\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = (set->alloc + 1) * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Insert the new element.  */\n  set->elems[set->nelem++] = elem;\n  return true;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pure": {
      "start_point": [
        1351,
        52
      ],
      "end_point": [
        1360,
        1
      ],
      "content": "re_node_set *set2)\n{\n  Idx i;\n  if (set1 == NULL || set2 == NULL || set1->nelem != set2->nelem)\n    return false;\n  for (i = set1->nelem ; --i >= 0 ; )\n    if (set1->elems[i] != set2->elems[i])\n      return false;\n  return true;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": null
    },
    "re_node_set_remove_at": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1395,
        1
      ],
      "content": "static void\ninternal_function\nre_node_set_remove_at (re_node_set *set, Idx idx)\n{\n  if (idx < 0 || idx >= set->nelem)\n    return;\n  --set->nelem;\n  for (; idx < set->nelem; idx++)\n    set->elems[idx] = set->elems[idx + 1];\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_dfa_add_node": {
      "start_point": [
        1401,
        0
      ],
      "end_point": [
        1453,
        1
      ],
      "content": "static Idx\ninternal_function\nre_dfa_add_node (re_dfa_t *dfa, re_token_t token)\n{\n  if (BE (dfa->nodes_len >= dfa->nodes_alloc, 0))\n    {\n      size_t new_nodes_alloc = dfa->nodes_alloc * 2;\n      Idx *new_nexts, *new_indices;\n      re_node_set *new_edests, *new_eclosures;\n      re_token_t *new_nodes;\n\n      /* Avoid overflows in realloc.  */\n      const size_t max_object_size = MAX (sizeof (re_token_t),\n\t\t\t\t\t  MAX (sizeof (re_node_set),\n\t\t\t\t\t       sizeof (Idx)));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_nodes_alloc, 0))\n\treturn -1;\n\n      new_nodes = re_realloc (dfa->nodes, re_token_t, new_nodes_alloc);\n      if (BE (new_nodes == NULL, 0))\n\treturn -1;\n      dfa->nodes = new_nodes;\n      new_nexts = re_realloc (dfa->nexts, Idx, new_nodes_alloc);\n      new_indices = re_realloc (dfa->org_indices, Idx, new_nodes_alloc);\n      new_edests = re_realloc (dfa->edests, re_node_set, new_nodes_alloc);\n      new_eclosures = re_realloc (dfa->eclosures, re_node_set, new_nodes_alloc);\n      if (BE (new_nexts == NULL || new_indices == NULL\n\t      || new_edests == NULL || new_eclosures == NULL, 0))\n\t{\n\t   re_free (new_nexts);\n\t   re_free (new_indices);\n\t   re_free (new_edests);\n\t   re_free (new_eclosures);\n\t   return -1;\n\t}\n      dfa->nexts = new_nexts;\n      dfa->org_indices = new_indices;\n      dfa->edests = new_edests;\n      dfa->eclosures = new_eclosures;\n      dfa->nodes_alloc = new_nodes_alloc;\n    }\n  dfa->nodes[dfa->nodes_len] = token;\n  dfa->nodes[dfa->nodes_len].constraint = 0;\n#ifdef RE_ENABLE_I18N\n  dfa->nodes[dfa->nodes_len].accept_mb =\n    ((token.type == OP_PERIOD && dfa->mb_cur_max > 1)\n     || token.type == COMPLEX_BRACKET);\n#endif\n  dfa->nexts[dfa->nodes_len] = -1;\n  re_node_set_init_empty (dfa->edests + dfa->nodes_len);\n  re_node_set_init_empty (dfa->eclosures + dfa->nodes_len);\n  return dfa->nodes_len++;\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "calc_state_hash": {
      "start_point": [
        1455,
        0
      ],
      "end_point": [
        1464,
        1
      ],
      "content": "static re_hashval_t\ninternal_function\ncalc_state_hash (const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash = nodes->nelem + context;\n  Idx i;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    hash += nodes->elems[i];\n  return hash;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "re_hashval_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_acquire_state": {
      "start_point": [
        1476,
        18
      ],
      "end_point": [
        1511,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t  const re_node_set *nodes)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#if defined GCC_LINT || defined lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (BE (nodes->nelem == 0, 0))\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, 0);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (hash != state->hash)\n\tcontinue;\n      if (re_node_set_compare (&state->nodes, nodes))\n\treturn state;\n    }\n\n  /* There are no appropriate state in the dfa, create the new one.  */\n  new_state = create_ci_newstate (dfa, nodes, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_acquire_state_context": {
      "start_point": [
        1524,
        18
      ],
      "end_point": [
        1558,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t\t  const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#if defined GCC_LINT || defined lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (nodes->nelem == 0)\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, context);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (state->hash == hash\n\t  && state->context == context\n\t  && re_node_set_compare (state->entrance_nodes, nodes))\n\treturn state;\n    }\n  /* There are no appropriate state in 'dfa', create the new one.  */\n  new_state = create_cd_newstate (dfa, nodes, context, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "register_state": {
      "start_point": [
        1564,
        0
      ],
      "end_point": [
        1598,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tre_hashval_t hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  Idx i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      Idx elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      Idx new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "free_state": {
      "start_point": [
        1600,
        0
      ],
      "end_point": [
        1614,
        1
      ],
      "content": "static void\nfree_state (re_dfastate_t *state)\n{\n  re_node_set_free (&state->non_eps_nodes);\n  re_node_set_free (&state->inveclosure);\n  if (state->entrance_nodes != &state->nodes)\n    {\n      re_node_set_free (state->entrance_nodes);\n      re_free (state->entrance_nodes);\n    }\n  re_node_set_free (&state->nodes);\n  re_free (state->word_trtable);\n  re_free (state->trtable);\n  re_free (state);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_ci_newstate": {
      "start_point": [
        1620,
        18
      ],
      "end_point": [
        1664,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    re_hashval_t hash)\n{\n  Idx i;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->entrance_nodes = &newstate->nodes;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      if (type == CHARACTER && !node->constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n      else if (type == ANCHOR || node->constraint)\n\tnewstate->has_constraint = 1;\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return newstate;\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "create_cd_newstate": {
      "start_point": [
        1670,
        18
      ],
      "end_point": [
        1740,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_cd_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int context, re_hashval_t hash)\n{\n  Idx i, nctx_nodes = 0;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->context = context;\n  newstate->entrance_nodes = &newstate->nodes;\n\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      if (type == CHARACTER && !constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n\n      if (constraint)\n\t{\n\t  if (newstate->entrance_nodes == &newstate->nodes)\n\t    {\n\t      newstate->entrance_nodes = re_malloc (re_node_set, 1);\n\t      if (BE (newstate->entrance_nodes == NULL, 0))\n\t\t{\n\t\t  free_state (newstate);\n\t\t  return NULL;\n\t\t}\n\t      if (re_node_set_init_copy (newstate->entrance_nodes, nodes)\n\t\t  != REG_NOERROR)\n\t\treturn NULL;\n\t      nctx_nodes = 0;\n\t      newstate->has_constraint = 1;\n\t    }\n\n\t  if (NOT_SATISFY_PREV_CONSTRAINT (constraint,context))\n\t    {\n\t      re_node_set_remove_at (&newstate->nodes, i - nctx_nodes);\n\t      ++nctx_nodes;\n\t    }\n\t}\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return  newstate;\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    }
  },
  "tar/tar-1.30/gnu/regex_internal.h": {
    "bitset_set": {
      "start_point": [
        763,
        0
      ],
      "end_point": [
        767,
        1
      ],
      "content": "static void\nbitset_set (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 << i % BITSET_WORD_BITS;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_clear": {
      "start_point": [
        769,
        0
      ],
      "end_point": [
        773,
        1
      ],
      "content": "static void\nbitset_clear (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] &= ~ ((bitset_word_t) 1 << i % BITSET_WORD_BITS);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_contain": {
      "start_point": [
        775,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "static bool\nbitset_contain (const bitset_t set, Idx i)\n{\n  return (set[i / BITSET_WORD_BITS] >> i % BITSET_WORD_BITS) & 1;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "bitset_empty": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        785,
        1
      ],
      "content": "static void\nbitset_empty (bitset_t set)\n{\n  memset (set, '\\0', sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_set_all": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "static void\nbitset_set_all (bitset_t set)\n{\n  memset (set, -1, sizeof (bitset_word_t) * (SBC_MAX / BITSET_WORD_BITS));\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_copy": {
      "start_point": [
        796,
        0
      ],
      "end_point": [
        800,
        1
      ],
      "content": "static void\nbitset_copy (bitset_t dest, const bitset_t src)\n{\n  memcpy (dest, src, sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_not": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        812,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_not (bitset_t set)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < SBC_MAX / BITSET_WORD_BITS; ++bitset_i)\n    set[bitset_i] = ~set[bitset_i];\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1)\n       & ~set[BITSET_WORDS - 1]);\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_merge": {
      "start_point": [
        814,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_merge (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] |= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_mask": {
      "start_point": [
        822,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_mask (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] &= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "internal_function": [
      {
        "start_point": [
          833,
          18
        ],
        "end_point": [
          843,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_char_size_at (const re_string_t *pstr, Idx idx)\n{\n  int byte_idx;\n  if (pstr->mb_cur_max == 1)\n    return 1;\n  for (byte_idx = 1; idx + byte_idx < pstr->valid_len; ++byte_idx)\n    if (pstr->wcs[idx + byte_idx] != WEOF)\n      break;\n  return byte_idx;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          846,
          18
        ],
        "end_point": [
          852,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_wchar_at (const re_string_t *pstr, Idx idx)\n{\n  if (pstr->mb_cur_max == 1)\n    return (wint_t) pstr->mbs[idx];\n  return (wint_t) pstr->wcs[idx];\n}",
        "lines": 7,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          859,
          18
        ],
        "end_point": [
          881,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_elem_size_at (const re_string_t *pstr, Idx idx)\n{\n# ifdef _LIBC\n  const unsigned char *p, *extra;\n  const int32_t *table, *indirect;\n  uint_fast32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n\n  if (nrules != 0)\n    {\n      table = (const int32_t *) _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n      extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n      indirect = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t_NL_COLLATE_INDIRECTMB);\n      p = pstr->mbs + idx;\n      findidx (table, indirect, extra, &p, pstr->len - idx);\n      return p - pstr->mbs - idx;\n    }\n  else\n# endif /* _LIBC */\n    return 1;\n}",
        "lines": 23,
        "depth": 11,
        "decorators": null
      }
    ]
  },
  "tar/tar-1.30/gnu/rename.c": {
    "rpl_rename": [
      {
        "start_point": [
          44,
          0
        ],
        "end_point": [
          262,
          1
        ],
        "content": "int\nrpl_rename (char const *src, char const *dst)\n{\n  int error;\n  size_t src_len = strlen (src);\n  size_t dst_len = strlen (dst);\n  char *src_base = last_component (src);\n  char *dst_base = last_component (dst);\n  bool src_slash;\n  bool dst_slash;\n  bool dst_exists;\n  struct stat src_st;\n  struct stat dst_st;\n\n  /* Filter out dot as last component.  */\n  if (!src_len || !dst_len)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n  if (*src_base == '.')\n    {\n      size_t len = base_len (src_base);\n      if (len == 1 || (len == 2 && src_base[1] == '.'))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n    }\n  if (*dst_base == '.')\n    {\n      size_t len = base_len (dst_base);\n      if (len == 1 || (len == 2 && dst_base[1] == '.'))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n    }\n\n  /* Presence of a trailing slash requires directory semantics.  If\n     the source does not exist, or if the destination cannot be turned\n     into a directory, give up now.  Otherwise, strip trailing slashes\n     before calling rename.  There are no symlinks on mingw, so stat\n     works instead of lstat.  */\n  src_slash = ISSLASH (src[src_len - 1]);\n  dst_slash = ISSLASH (dst[dst_len - 1]);\n  if (stat (src, &src_st))\n    return -1;\n  if (stat (dst, &dst_st))\n    {\n      if (errno != ENOENT || (!S_ISDIR (src_st.st_mode) && dst_slash))\n        return -1;\n      dst_exists = false;\n    }\n  else\n    {\n      if (S_ISDIR (dst_st.st_mode) != S_ISDIR (src_st.st_mode))\n        {\n          errno = S_ISDIR (dst_st.st_mode) ? EISDIR : ENOTDIR;\n          return -1;\n        }\n      dst_exists = true;\n    }\n\n  /* There are no symlinks, so if a file existed with a trailing\n     slash, it must be a directory, and we don't have to worry about\n     stripping strip trailing slash.  However, mingw refuses to\n     replace an existing empty directory, so we have to help it out.\n     And canonicalize_file_name is not yet ported to mingw; however,\n     for directories, getcwd works as a viable alternative.  Ensure\n     that we can get back to where we started before using it; later\n     attempts to return are fatal.  Note that we can end up losing a\n     directory if rename then fails, but it was empty, so not much\n     damage was done.  */\n  if (dst_exists && S_ISDIR (dst_st.st_mode))\n    {\n      char *cwd = getcwd (NULL, 0);\n      char *src_temp;\n      char *dst_temp;\n      if (!cwd || chdir (cwd))\n        return -1;\n      if (IS_ABSOLUTE_FILE_NAME (src))\n        {\n          dst_temp = chdir (dst) ? NULL : getcwd (NULL, 0);\n          src_temp = chdir (src) ? NULL : getcwd (NULL, 0);\n        }\n      else\n        {\n          src_temp = chdir (src) ? NULL : getcwd (NULL, 0);\n          if (!IS_ABSOLUTE_FILE_NAME (dst) && chdir (cwd))\n            abort ();\n          dst_temp = chdir (dst) ? NULL : getcwd (NULL, 0);\n        }\n      if (chdir (cwd))\n        abort ();\n      free (cwd);\n      if (!src_temp || !dst_temp)\n        {\n          free (src_temp);\n          free (dst_temp);\n          errno = ENOMEM;\n          return -1;\n        }\n      src_len = strlen (src_temp);\n      if (strncmp (src_temp, dst_temp, src_len) == 0\n          && (ISSLASH (dst_temp[src_len]) || dst_temp[src_len] == '\\0'))\n        {\n          error = dst_temp[src_len];\n          free (src_temp);\n          free (dst_temp);\n          if (error)\n            {\n              errno = EINVAL;\n              return -1;\n            }\n          return 0;\n        }\n      if (rmdir (dst))\n        {\n          error = errno;\n          free (src_temp);\n          free (dst_temp);\n          errno = error;\n          return -1;\n        }\n      free (src_temp);\n      free (dst_temp);\n    }\n\n  /* MoveFileEx works if SRC is a directory without any flags, but\n     fails with MOVEFILE_REPLACE_EXISTING, so try without flags first.\n     Thankfully, MoveFileEx handles hard links correctly, even though\n     rename() does not.  */\n  if (MoveFileEx (src, dst, 0))\n    return 0;\n\n  /* Retry with MOVEFILE_REPLACE_EXISTING if the move failed\n     due to the destination already existing.  */\n  error = GetLastError ();\n  if (error == ERROR_FILE_EXISTS || error == ERROR_ALREADY_EXISTS)\n    {\n      if (MoveFileEx (src, dst, MOVEFILE_REPLACE_EXISTING))\n        return 0;\n\n      error = GetLastError ();\n    }\n\n  switch (error)\n    {\n    case ERROR_FILE_NOT_FOUND:\n    case ERROR_PATH_NOT_FOUND:\n    case ERROR_BAD_PATHNAME:\n    case ERROR_DIRECTORY:\n      errno = ENOENT;\n      break;\n\n    case ERROR_ACCESS_DENIED:\n    case ERROR_SHARING_VIOLATION:\n      errno = EACCES;\n      break;\n\n    case ERROR_OUTOFMEMORY:\n      errno = ENOMEM;\n      break;\n\n    case ERROR_CURRENT_DIRECTORY:\n      errno = EBUSY;\n      break;\n\n    case ERROR_NOT_SAME_DEVICE:\n      errno = EXDEV;\n      break;\n\n    case ERROR_WRITE_PROTECT:\n      errno = EROFS;\n      break;\n\n    case ERROR_WRITE_FAULT:\n    case ERROR_READ_FAULT:\n    case ERROR_GEN_FAILURE:\n      errno = EIO;\n      break;\n\n    case ERROR_HANDLE_DISK_FULL:\n    case ERROR_DISK_FULL:\n    case ERROR_DISK_TOO_FRAGMENTED:\n      errno = ENOSPC;\n      break;\n\n    case ERROR_FILE_EXISTS:\n    case ERROR_ALREADY_EXISTS:\n      errno = EEXIST;\n      break;\n\n    case ERROR_BUFFER_OVERFLOW:\n    case ERROR_FILENAME_EXCED_RANGE:\n      errno = ENAMETOOLONG;\n      break;\n\n    case ERROR_INVALID_NAME:\n    case ERROR_DELETE_PENDING:\n      errno = EPERM;        /* ? */\n      break;\n\n# ifndef ERROR_FILE_TOO_LARGE\n/* This value is documented but not defined in all versions of windows.h.  */\n#  define ERROR_FILE_TOO_LARGE 223\n# endif\n    case ERROR_FILE_TOO_LARGE:\n      errno = EFBIG;\n      break;\n\n    default:\n      errno = EINVAL;\n      break;\n    }\n\n  return -1;\n}",
        "lines": 219,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          278,
          0
        ],
        "end_point": [
          473,
          1
        ],
        "content": "int\nrpl_rename (char const *src, char const *dst)\n{\n  size_t src_len = strlen (src);\n  size_t dst_len = strlen (dst);\n  char *src_temp = (char *) src;\n  char *dst_temp = (char *) dst;\n  bool src_slash;\n  bool dst_slash;\n  bool dst_exists _GL_UNUSED;\n  int ret_val = -1;\n  int rename_errno = ENOTDIR;\n  struct stat src_st;\n  struct stat dst_st;\n\n  if (!src_len || !dst_len)\n    return rename (src, dst); /* Let strace see the ENOENT failure.  */\n\n# if RENAME_DEST_EXISTS_BUG\n  {\n    char *src_base = last_component (src);\n    char *dst_base = last_component (dst);\n    if (*src_base == '.')\n      {\n        size_t len = base_len (src_base);\n        if (len == 1 || (len == 2 && src_base[1] == '.'))\n          {\n            errno = EINVAL;\n            return -1;\n          }\n      }\n    if (*dst_base == '.')\n      {\n        size_t len = base_len (dst_base);\n        if (len == 1 || (len == 2 && dst_base[1] == '.'))\n          {\n            errno = EINVAL;\n            return -1;\n          }\n      }\n  }\n# endif /* RENAME_DEST_EXISTS_BUG */\n\n  src_slash = src[src_len - 1] == '/';\n  dst_slash = dst[dst_len - 1] == '/';\n\n# if !RENAME_HARD_LINK_BUG && !RENAME_DEST_EXISTS_BUG\n  /* If there are no trailing slashes, then trust the native\n     implementation unless we also suspect issues with hard link\n     detection or file/directory conflicts.  */\n  if (!src_slash && !dst_slash)\n    return rename (src, dst);\n# endif /* !RENAME_HARD_LINK_BUG && !RENAME_DEST_EXISTS_BUG */\n\n  /* Presence of a trailing slash requires directory semantics.  If\n     the source does not exist, or if the destination cannot be turned\n     into a directory, give up now.  Otherwise, strip trailing slashes\n     before calling rename.  */\n  if (lstat (src, &src_st))\n    return -1;\n  if (lstat (dst, &dst_st))\n    {\n      if (errno != ENOENT || (!S_ISDIR (src_st.st_mode) && dst_slash))\n        return -1;\n      dst_exists = false;\n    }\n  else\n    {\n      if (S_ISDIR (dst_st.st_mode) != S_ISDIR (src_st.st_mode))\n        {\n          errno = S_ISDIR (dst_st.st_mode) ? EISDIR : ENOTDIR;\n          return -1;\n        }\n# if RENAME_HARD_LINK_BUG\n      if (SAME_INODE (src_st, dst_st))\n        return 0;\n# endif /* RENAME_HARD_LINK_BUG */\n      dst_exists = true;\n    }\n\n# if (RENAME_TRAILING_SLASH_SOURCE_BUG || RENAME_DEST_EXISTS_BUG        \\\n      || RENAME_HARD_LINK_BUG)\n  /* If the only bug was that a trailing slash was allowed on a\n     non-existing file destination, as in Solaris 10, then we've\n     already covered that situation.  But if there is any problem with\n     a trailing slash on an existing source or destination, as in\n     Solaris 9, or if a directory can overwrite a symlink, as on\n     Cygwin 1.5, or if directories cannot be created with trailing\n     slash, as on NetBSD 1.6, then we must strip the offending slash\n     and check that we have not encountered a symlink instead of a\n     directory.\n\n     Stripping a trailing slash interferes with POSIX semantics, where\n     rename behavior on a symlink with a trailing slash operates on\n     the corresponding target directory.  We prefer the GNU semantics\n     of rejecting any use of a symlink with trailing slash, but do not\n     enforce them, since Solaris 10 is able to obey POSIX semantics\n     and there might be clients expecting it, as counter-intuitive as\n     those semantics are.\n\n     Technically, we could also follow the POSIX behavior by chasing a\n     readlink trail, but that is harder to implement.  */\n  if (src_slash)\n    {\n      src_temp = strdup (src);\n      if (!src_temp)\n        {\n          /* Rather than rely on strdup-posix, we set errno ourselves.  */\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (src_temp);\n      if (lstat (src_temp, &src_st))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n      if (S_ISLNK (src_st.st_mode))\n        goto out;\n    }\n  if (dst_slash)\n    {\n      dst_temp = strdup (dst);\n      if (!dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (dst_temp);\n      if (lstat (dst_temp, &dst_st))\n        {\n          if (errno != ENOENT)\n            {\n              rename_errno = errno;\n              goto out;\n            }\n        }\n      else if (S_ISLNK (dst_st.st_mode))\n        goto out;\n    }\n# endif /* RENAME_TRAILING_SLASH_SOURCE_BUG || RENAME_DEST_EXISTS_BUG\n           || RENAME_HARD_LINK_BUG */\n\n# if RENAME_DEST_EXISTS_BUG\n  /* Cygwin 1.5 sometimes behaves oddly when moving a non-empty\n     directory on top of an empty one (the old directory name can\n     reappear if the new directory tree is removed).  Work around this\n     by removing the target first, but don't remove the target if it\n     is a subdirectory of the source.  Note that we can end up losing\n     a directory if rename then fails, but it was empty, so not much\n     damage was done.  */\n  if (dst_exists && S_ISDIR (dst_st.st_mode))\n    {\n      if (src_st.st_dev != dst_st.st_dev)\n        {\n          rename_errno = EXDEV;\n          goto out;\n        }\n      if (src_temp != src)\n        free (src_temp);\n      src_temp = canonicalize_file_name (src);\n      if (dst_temp != dst)\n        free (dst_temp);\n      dst_temp = canonicalize_file_name (dst);\n      if (!src_temp || !dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      src_len = strlen (src_temp);\n      if (strncmp (src_temp, dst_temp, src_len) == 0\n          && dst_temp[src_len] == '/')\n        {\n          rename_errno = EINVAL;\n          goto out;\n        }\n      if (rmdir (dst))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n    }\n# endif /* RENAME_DEST_EXISTS_BUG */\n\n  ret_val = rename (src_temp, dst_temp);\n  rename_errno = errno;\n\n out: _GL_UNUSED_LABEL;\n\n  if (src_temp != src)\n    free (src_temp);\n  if (dst_temp != dst)\n    free (dst_temp);\n  errno = rename_errno;\n  return ret_val;\n}",
        "lines": 196,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "tar/tar-1.30/gnu/renameat.c": {
    "renameat": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        24,
        1
      ],
      "content": "int\nrenameat (int fd1, char const *src, int fd2, char const *dst)\n{\n  return renameat2 (fd1, src, fd2, dst, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/renameat2.c": {
    "errno_fail": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nerrno_fail (int e)\n{\n  errno = e;\n  return -1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rename_noreplace": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\nrename_noreplace (char const *src, char const *dst)\n{\n  /* This has a race between the call to lstat and the call to rename.  */\n  struct stat st;\n  return (lstat (dst, &st) == 0 || errno == EOVERFLOW ? errno_fail (EEXIST)\n          : errno == ENOENT ? rename (src, dst)\n          : -1);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "renameat2": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "int\nrenameat2 (int fd1, char const *src, int fd2, char const *dst,\n           unsigned int flags)\n{\n  int ret_val = -1;\n  int err = EINVAL;\n\n#ifdef SYS_renameat2\n  ret_val = syscall (SYS_renameat2, fd1, src, fd2, dst, flags);\n  err = errno;\n#elif defined RENAME_EXCL\n  if (! (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE)))\n    {\n      ret_val = renameatx_np (fd1, src, fd2, dst,\n                             ((flags & RENAME_EXCHANGE ? RENAME_SWAP : 0)\n                              | (flags & RENAME_NOREPLACE ? RENAME_EXCL : 0)));\n      err = errno;\n    }\n#endif\n\n  if (! (ret_val < 0 && (err == EINVAL || err == ENOSYS || err == ENOTSUP)))\n    return ret_val;\n\n#if HAVE_RENAMEAT\n  {\n  size_t src_len;\n  size_t dst_len;\n  char *src_temp = (char *) src;\n  char *dst_temp = (char *) dst;\n  bool src_slash;\n  bool dst_slash;\n  int rename_errno = ENOTDIR;\n  struct stat src_st;\n  struct stat dst_st;\n  bool dst_found_nonexistent = false;\n\n  if (flags != 0)\n    {\n      /* RENAME_NOREPLACE is the only flag currently supported.  */\n      if (flags & ~RENAME_NOREPLACE)\n        return errno_fail (ENOTSUP);\n      else\n        {\n          /* This has a race between the call to lstatat and the calls to\n             renameat below.  */\n          if (lstatat (fd2, dst, &dst_st) == 0 || errno == EOVERFLOW)\n            return errno_fail (EEXIST);\n          if (errno != ENOENT)\n            return -1;\n          dst_found_nonexistent = true;\n        }\n    }\n\n  /* Let strace see any ENOENT failure.  */\n  src_len = strlen (src);\n  dst_len = strlen (dst);\n  if (!src_len || !dst_len)\n    return renameat (fd1, src, fd2, dst);\n\n  src_slash = src[src_len - 1] == '/';\n  dst_slash = dst[dst_len - 1] == '/';\n  if (!src_slash && !dst_slash)\n    return renameat (fd1, src, fd2, dst);\n\n  /* Presence of a trailing slash requires directory semantics.  If\n     the source does not exist, or if the destination cannot be turned\n     into a directory, give up now.  Otherwise, strip trailing slashes\n     before calling rename.  */\n  if (lstatat (fd1, src, &src_st))\n    return -1;\n  if (dst_found_nonexistent)\n    {\n      if (!S_ISDIR (src_st.st_mode))\n        return errno_fail (ENOENT);\n    }\n  else if (lstatat (fd2, dst, &dst_st))\n    {\n      if (errno != ENOENT || !S_ISDIR (src_st.st_mode))\n        return -1;\n    }\n  else if (!S_ISDIR (dst_st.st_mode))\n    return errno_fail (ENOTDIR);\n  else if (!S_ISDIR (src_st.st_mode))\n    return errno_fail (EISDIR);\n\n# if RENAME_TRAILING_SLASH_SOURCE_BUG\n  /* See the lengthy comment in rename.c why Solaris 9 is forced to\n     GNU behavior, while Solaris 10 is left with POSIX behavior,\n     regarding symlinks with trailing slash.  */\n  ret_val = -1;\n  if (src_slash)\n    {\n      src_temp = strdup (src);\n      if (!src_temp)\n        {\n          /* Rather than rely on strdup-posix, we set errno ourselves.  */\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (src_temp);\n      if (lstatat (fd1, src_temp, &src_st))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n      if (S_ISLNK (src_st.st_mode))\n        goto out;\n    }\n  if (dst_slash)\n    {\n      dst_temp = strdup (dst);\n      if (!dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (dst_temp);\n      if (lstatat (fd2, dst_temp, &dst_st))\n        {\n          if (errno != ENOENT)\n            {\n              rename_errno = errno;\n              goto out;\n            }\n        }\n      else if (S_ISLNK (dst_st.st_mode))\n        goto out;\n    }\n# endif /* RENAME_TRAILING_SLASH_SOURCE_BUG */\n\n  /* renameat does not honor trailing / on Solaris 10.  Solve it in a\n     similar manner to rename.  No need to worry about bugs not present\n     on Solaris, since all other systems either lack renameat or honor\n     trailing slash correctly.  */\n\n  ret_val = renameat (fd1, src_temp, fd2, dst_temp);\n  rename_errno = errno;\n  goto out;\n out:\n  if (src_temp != src)\n    free (src_temp);\n  if (dst_temp != dst)\n    free (dst_temp);\n  errno = rename_errno;\n  return ret_val;\n  }\n#else /* !HAVE_RENAMEAT */\n\n  /* RENAME_NOREPLACE is the only flag currently supported.  */\n  if (flags & ~RENAME_NOREPLACE)\n    return errno_fail (ENOTSUP);\n  return at_func2 (fd1, src, fd2, dst, flags ? rename_noreplace : rename);\n\n#endif /* !HAVE_RENAMEAT */\n}",
      "lines": 155,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/renameat2.h": {},
  "tar/tar-1.30/gnu/rewinddir.c": {
    "rewinddir": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nrewinddir (DIR *dirp)\n{\n  /* Like in closedir().  */\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n\n  /* Like in opendir().  */\n  dirp->status = -1;\n  dirp->current = FindFirstFile (dirp->dir_name_mask, &dirp->entry);\n  if (dirp->current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          dirp->status = -2;\n          break;\n        default:\n          /* Save the error code for the next readdir() call.  */\n          dirp->status = ENOENT;\n          break;\n        }\n    }\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/rmdir.c": {
    "rpl_rmdir": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nrpl_rmdir (char const *dir)\n{\n  /* Work around cygwin 1.5.x bug where rmdir(\"dir/./\") succeeds.  */\n  size_t len = strlen (dir);\n  int result;\n  while (len && ISSLASH (dir[len - 1]))\n    len--;\n  if (len && dir[len - 1] == '.' && (1 == len || ISSLASH (dir[len - 2])))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  result = rmdir (dir);\n  /* Work around mingw bug, where rmdir(\"file/\") fails with EINVAL\n     instead of ENOTDIR.  We've already filtered out trailing ., the\n     only reason allowed by POSIX for EINVAL.  */\n  if (result == -1 && errno == EINVAL)\n    errno = ENOTDIR;\n  return result;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/root-uid.h": {},
  "tar/tar-1.30/gnu/rpmatch.c": {
    "localized_pattern": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static const char *\nlocalized_pattern (const char *english_pattern, nl_item nl_index,\n                   bool posixly_correct)\n{\n  const char *translated_pattern;\n\n  /* We prefer to get the patterns from a PO file.  It would be possible to\n     always use nl_langinfo (YESEXPR) instead of _(\"^[yY]\"), and\n     nl_langinfo (NOEXPR) instead of _(\"^[nN]\"), if we could assume that the\n     system's locale support is good.  But this is not the case e.g. on Cygwin.\n     The localizations of gnulib.pot are of better quality in general.\n     Also, if we use locale info from non-free systems that don't have a\n     'localedef' command, we deprive the users of the freedom to localize\n     this pattern for their preferred language.\n     But some programs, such as 'cp', 'mv', 'rm', 'find', 'xargs', are\n     specified by POSIX to use nl_langinfo (YESEXPR).  We implement this\n     behaviour if POSIXLY_CORRECT is set, for the sake of these programs.  */\n\n  /* If the user wants strict POSIX compliance, use nl_langinfo.  */\n  if (posixly_correct)\n    {\n      translated_pattern = nl_langinfo (nl_index);\n      /* Check against a broken system return value.  */\n      if (translated_pattern != NULL && translated_pattern[0] != '\\0')\n        return translated_pattern;\n   }\n\n  /* Look in the gnulib message catalog.  */\n  translated_pattern = _(english_pattern);\n  if (translated_pattern == english_pattern)\n    {\n      /* The gnulib message catalog provides no translation.\n         Try the system's message catalog.  */\n      translated_pattern = nl_langinfo (nl_index);\n      /* Check against a broken system return value.  */\n      if (translated_pattern != NULL && translated_pattern[0] != '\\0')\n        return translated_pattern;\n      /* Fall back to English.  */\n      translated_pattern = english_pattern;\n    }\n  return translated_pattern;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nlocalized_pattern (const char *english_pattern, nl_item nl_index,\n                   bool posixly_correct)",
        "*"
      ]
    },
    "try": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static int\ntry (const char *response, const char *pattern, char **lastp, regex_t *re)\n{\n  if (*lastp == NULL || strcmp (pattern, *lastp) != 0)\n    {\n      char *safe_pattern;\n\n      /* The pattern has changed.  */\n      if (*lastp != NULL)\n        {\n          /* Free the old compiled pattern.  */\n          regfree (re);\n          free (*lastp);\n          *lastp = NULL;\n        }\n      /* Put the PATTERN into safe memory before calling regcomp.\n         (regcomp may call nl_langinfo, overwriting PATTERN's storage.  */\n      safe_pattern = strdup (pattern);\n      if (safe_pattern == NULL)\n        return -1;\n      /* Compile the pattern and cache it for future runs.  */\n      if (regcomp (re, safe_pattern, REG_EXTENDED) != 0)\n        {\n          free (safe_pattern);\n          return -1;\n        }\n      *lastp = safe_pattern;\n    }\n\n  /* See if the regular expression matches RESPONSE.  */\n  return regexec (re, response, 0, NULL, 0) == 0;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpmatch": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\nrpmatch (const char *response)\n{\n#if ENABLE_NLS\n  /* Match against one of the response patterns, compiling the pattern\n     first if necessary.  */\n\n  /* We cache the response patterns and compiled regexps here.  */\n  static char *last_yesexpr, *last_noexpr;\n  static regex_t cached_yesre, cached_nore;\n\n# if HAVE_LANGINFO_YESEXPR\n  bool posixly_correct = (getenv (\"POSIXLY_CORRECT\") != NULL);\n# endif\n\n  const char *yesexpr, *noexpr;\n  int result;\n\n  /* TRANSLATORS: A regular expression testing for an affirmative answer\n     (english: \"yes\").  Testing the first character may be sufficient.\n     Take care to consider upper and lower case.\n     To enquire the regular expression that your system uses for this\n     purpose, you can use the command\n       locale -k LC_MESSAGES | grep '^yesexpr='  */\n  yesexpr = localized_pattern (N_(\"^[yY]\"), YESEXPR, posixly_correct);\n  result = try (response, yesexpr, &last_yesexpr, &cached_yesre);\n  if (result < 0)\n    return -1;\n  if (result)\n    return 1;\n\n  /* TRANSLATORS: A regular expression testing for a negative answer\n     (english: \"no\").  Testing the first character may be sufficient.\n     Take care to consider upper and lower case.\n     To enquire the regular expression that your system uses for this\n     purpose, you can use the command\n       locale -k LC_MESSAGES | grep '^noexpr='  */\n  noexpr = localized_pattern (N_(\"^[nN]\"), NOEXPR, posixly_correct);\n  result = try (response, noexpr, &last_noexpr, &cached_nore);\n  if (result < 0)\n    return -1;\n  if (result)\n    return 0;\n\n  return -1;\n#else\n  /* Test against \"^[yY]\" and \"^[nN]\", hardcoded to avoid requiring regex */\n  return (*response == 'y' || *response == 'Y' ? 1\n          : *response == 'n' || *response == 'N' ? 0 : -1);\n#endif\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/safe-read.c": {
    "safe_rw": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "size_t\nsafe_rw (int fd, void const *buf, size_t count)\n{\n  /* Work around a bug in Tru64 5.1.  Attempting to read more than\n     INT_MAX bytes fails with errno == EINVAL.  See\n     <https://lists.gnu.org/r/bug-gnu-utils/2002-04/msg00010.html>.\n     When decreasing COUNT, keep it block-aligned.  */\n  enum { BUGGY_READ_MAXIMUM = INT_MAX & ~8191 };\n\n  for (;;)\n    {\n      ssize_t result = rw (fd, buf, count);\n\n      if (0 <= result)\n        return result;\n      else if (IS_EINTR (errno))\n        continue;\n      else if (errno == EINVAL && BUGGY_READ_MAXIMUM < count)\n        count = BUGGY_READ_MAXIMUM;\n      else\n        return result;\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/safe-read.h": {},
  "tar/tar-1.30/gnu/safe-write.c": {},
  "tar/tar-1.30/gnu/safe-write.h": {},
  "tar/tar-1.30/gnu/same-inode.h": {},
  "tar/tar-1.30/gnu/save-cwd.c": {
    "save_cwd": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\nsave_cwd (struct saved_cwd *cwd)\n{\n  cwd->name = NULL;\n\n  cwd->desc = open (\".\", O_SEARCH | O_CLOEXEC);\n  if (!GNULIB_FCNTL_SAFER)\n    cwd->desc = fd_safer_flag (cwd->desc, O_CLOEXEC);\n  if (cwd->desc < 0)\n    {\n      cwd->name = getcwd (NULL, 0);\n      return cwd->name ? 0 : -1;\n    }\n\n  return 0;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "restore_cwd": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nrestore_cwd (const struct saved_cwd *cwd)\n{\n  if (0 <= cwd->desc)\n    return fchdir (cwd->desc);\n  else\n    return chdir_long (cwd->name);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_cwd": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nfree_cwd (struct saved_cwd *cwd)\n{\n  if (cwd->desc >= 0)\n    close (cwd->desc);\n  free (cwd->name);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/save-cwd.h": {},
  "tar/tar-1.30/gnu/savedir.c": {
    "direntry_cmp_name": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\ndirentry_cmp_name (void const *a, void const *b)\n{\n  direntry_t const *dea = a;\n  direntry_t const *deb = b;\n\n  return strcmp (dea->name, deb->name);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "direntry_cmp_inode": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\ndirentry_cmp_inode (void const *a, void const *b)\n{\n  direntry_t const *dea = a;\n  direntry_t const *deb = b;\n\n  return dea->ino < deb->ino ? -1 : dea->ino > deb->ino;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "streamsavedir": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "char *\nstreamsavedir (DIR *dirp, enum savedir_option option)\n{\n  char *name_space = NULL;\n  size_t allocated = 0;\n  direntry_t *entries = NULL;\n  size_t entries_allocated = 0;\n  size_t entries_used = 0;\n  size_t used = 0;\n  int readdir_errno;\n  comparison_function cmp = comparison_function_table[option];\n\n  if (dirp == NULL)\n    return NULL;\n\n  for (;;)\n    {\n      struct dirent const *dp;\n      char const *entry;\n\n      errno = 0;\n      dp = readdir (dirp);\n      if (! dp)\n        break;\n\n      /* Skip \"\", \".\", and \"..\".  \"\" is returned by at least one buggy\n         implementation: Solaris 2.4 readdir on NFS file systems.  */\n      entry = dp->d_name;\n      if (entry[entry[0] != '.' ? 0 : entry[1] != '.' ? 1 : 2] != '\\0')\n        {\n          size_t entry_size = _D_EXACT_NAMLEN (dp) + 1;\n          if (cmp)\n            {\n              if (entries_allocated == entries_used)\n                {\n                  size_t n = entries_allocated;\n                  entries = x2nrealloc (entries, &n, sizeof *entries);\n                  entries_allocated = n;\n                }\n              entries[entries_used].name = xstrdup (entry);\n#if D_INO_IN_DIRENT\n              entries[entries_used].ino = dp->d_ino;\n#endif\n              entries_used++;\n            }\n          else\n            {\n              if (allocated - used <= entry_size)\n                {\n                  size_t n = used + entry_size;\n                  if (n < used)\n                    xalloc_die ();\n                  name_space = x2nrealloc (name_space, &n, 1);\n                  allocated = n;\n                }\n              memcpy (name_space + used, entry, entry_size);\n            }\n          used += entry_size;\n        }\n    }\n\n  readdir_errno = errno;\n  if (readdir_errno != 0)\n    {\n      free (entries);\n      free (name_space);\n      errno = readdir_errno;\n      return NULL;\n    }\n\n  if (cmp)\n    {\n      size_t i;\n\n      if (entries_used)\n        qsort (entries, entries_used, sizeof *entries, cmp);\n      name_space = xmalloc (used + 1);\n      used = 0;\n      for (i = 0; i < entries_used; i++)\n        {\n          char *dest = name_space + used;\n          used += stpcpy (dest, entries[i].name) - dest + 1;\n          free (entries[i].name);\n        }\n      free (entries);\n    }\n  else if (used == allocated)\n    name_space = xrealloc (name_space, used + 1);\n\n  name_space[used] = '\\0';\n  return name_space;\n}",
      "lines": 92,
      "depth": 17,
      "decorators": [
        "char",
        "*\nstreamsavedir (DIR *dirp, enum savedir_option option)",
        "*"
      ]
    },
    "savedir": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "char *\nsavedir (char const *dir, enum savedir_option option)\n{\n  DIR *dirp = opendir (dir);\n  if (! dirp)\n    return NULL;\n  else\n    {\n      char *name_space = streamsavedir (dirp, option);\n      if (closedir (dirp) != 0)\n        {\n          int closedir_errno = errno;\n          free (name_space);\n          errno = closedir_errno;\n          return NULL;\n        }\n      return name_space;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "char",
        "*\nsavedir (char const *dir, enum savedir_option option)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/savedir.h": {},
  "tar/tar-1.30/gnu/se-context.c": {},
  "tar/tar-1.30/gnu/se-context.in.h": {
    "context_new": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        17,
        32
      ],
      "content": "SE_CONTEXT_INLINE context_t context_new (char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "context_t",
        "context_t"
      ]
    },
    "context_str": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        19,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_str (context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_str (context_t con _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_free": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        20,
        73
      ],
      "content": "SE_CONTEXT_INLINE void context_free (context_t c _GL_UNUSED_PARAMETER) {}",
      "lines": 1,
      "depth": 6,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "void",
        "void"
      ]
    },
    "context_user_set": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        24,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_user_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_role_set": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        27,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_role_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_range_set": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        30,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_range_set (context_t sc _GL_UNUSED_PARAMETER,\n                                         char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_type_set": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        33,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_type_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_type_get": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        35,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_type_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_type_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_range_get": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        37,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_range_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_range_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_role_get": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        39,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_role_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_role_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_user_get": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        41,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_user_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_user_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/se-selinux.c": {},
  "tar/tar-1.30/gnu/se-selinux.in.h": {
    "getcon": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        50,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetcon (security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "freecon": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        52,
        56
      ],
      "content": "SE_SELINUX_INLINE void\nfreecon (security_context_t con _GL_UNUSED_PARAMETER) {}",
      "lines": 2,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "void",
        "void"
      ]
    },
    "getfscreatecon": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        56,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetfscreatecon (security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setfscreatecon": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        59,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetfscreatecon (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "matchpathcon": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nmatchpathcon (char const *file _GL_UNUSED_PARAMETER,\n              mode_t m _GL_UNUSED_PARAMETER,\n  security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "getfilecon": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        68,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetfilecon (char const *file _GL_UNUSED_PARAMETER,\n            security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "lgetfilecon": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        72,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nlgetfilecon (char const *file _GL_UNUSED_PARAMETER,\n             security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "fgetfilecon": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        75,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nfgetfilecon (int fd, security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setfilecon": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        79,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetfilecon (char const *file _GL_UNUSED_PARAMETER,\n            security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "lsetfilecon": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        83,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nlsetfilecon (char const *file _GL_UNUSED_PARAMETER,\n             security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "fsetfilecon": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        87,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nfsetfilecon (int fd _GL_UNUSED_PARAMETER,\n             security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_check_context": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        91,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_check_context (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_check_context_raw": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        94,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_check_context_raw (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setexeccon": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        97,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetexeccon (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_compute_create": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        103,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_compute_create (security_context_t scon _GL_UNUSED_PARAMETER,\n                         security_context_t tcon _GL_UNUSED_PARAMETER,\n                         security_class_t tclass _GL_UNUSED_PARAMETER,\n                         security_context_t *newcon _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "string_to_security_class": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        106,
        32
      ],
      "content": "SE_SELINUX_INLINE security_class_t\nstring_to_security_class (char const *name)\n  { errno = ENOTSUP; return 0; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "security_class_t",
        "security_class_t"
      ]
    },
    "matchpathcon_init_prefix": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        110,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nmatchpathcon_init_prefix (char const *path _GL_UNUSED_PARAMETER,\n                          char const *prefix _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/selinux-at.c": {},
  "tar/tar-1.30/gnu/selinux-at.h": {},
  "tar/tar-1.30/gnu/set-permissions.c": {
    "acl_from_mode": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static acl_t\nacl_from_mode (mode_t mode)\n{\n#  if HAVE_ACL_FREE_TEXT /* Tru64 */\n  char acl_text[] = \"u::---,g::---,o::---,\";\n#  else /* FreeBSD, IRIX */\n  char acl_text[] = \"u::---,g::---,o::---\";\n#  endif\n\n  if (mode & S_IRUSR) acl_text[ 3] = 'r';\n  if (mode & S_IWUSR) acl_text[ 4] = 'w';\n  if (mode & S_IXUSR) acl_text[ 5] = 'x';\n  if (mode & S_IRGRP) acl_text[10] = 'r';\n  if (mode & S_IWGRP) acl_text[11] = 'w';\n  if (mode & S_IXGRP) acl_text[12] = 'x';\n  if (mode & S_IROTH) acl_text[17] = 'r';\n  if (mode & S_IWOTH) acl_text[18] = 'w';\n  if (mode & S_IXOTH) acl_text[19] = 'x';\n\n  return acl_from_text (acl_text);\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "acl_t"
      ]
    },
    "set_acls_from_mode": [
      {
        "start_point": [
          54,
          0
        ],
        "end_point": [
          273,
          1
        ],
        "content": "static int\nset_acls_from_mode (const char *name, int desc, mode_t mode, bool *must_chmod)\n{\n#  ifdef ACE_GETACL\n  /* Solaris also has a different variant of ACLs, used in ZFS and NFSv4\n     file systems (whereas the other ones are used in UFS file systems).  */\n\n  /* The flags in the ace_t structure changed in a binary incompatible way\n     when ACL_NO_TRIVIAL etc. were introduced in <sys/acl.h> version 1.15.\n     How to distinguish the two conventions at runtime?\n     We fetch the existing ACL.  In the old convention, usually three ACEs have\n     a_flags = ACE_OWNER / ACE_GROUP / ACE_OTHER, in the range 0x0100..0x0400.\n     In the new convention, these values are not used.  */\n  int convention;\n\n  {\n    /* Initially, try to read the entries into a stack-allocated buffer.\n       Use malloc if it does not fit.  */\n    enum\n      {\n        alloc_init = 4000 / sizeof (ace_t), /* >= 3 */\n        alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (ace_t))\n      };\n    ace_t buf[alloc_init];\n    size_t alloc = alloc_init;\n    ace_t *entries = buf;\n    ace_t *malloced = NULL;\n    int count;\n\n    for (;;)\n      {\n        count = (desc != -1\n                 ? facl (desc, ACE_GETACL, alloc, entries)\n                 : acl (name, ACE_GETACL, alloc, entries));\n        if (count < 0 && errno == ENOSPC)\n          {\n            /* Increase the size of the buffer.  */\n            free (malloced);\n            if (alloc > alloc_max / 2)\n              {\n                errno = ENOMEM;\n                return -1;\n              }\n            alloc = 2 * alloc; /* <= alloc_max */\n            entries = malloced = (ace_t *) malloc (alloc * sizeof (ace_t));\n            if (entries == NULL)\n              {\n                errno = ENOMEM;\n                return -1;\n              }\n            continue;\n          }\n        break;\n      }\n\n    if (count <= 0)\n      convention = -1;\n    else\n      {\n        int i;\n\n        convention = 0;\n        for (i = 0; i < count; i++)\n          if (entries[i].a_flags & (OLD_ACE_OWNER | OLD_ACE_GROUP | OLD_ACE_OTHER))\n            {\n              convention = 1;\n              break;\n            }\n      }\n    free (malloced);\n  }\n\n  if (convention >= 0)\n    {\n      ace_t entries[6];\n      int count;\n      int ret;\n\n      if (convention)\n        {\n          /* Running on Solaris 10.  */\n          entries[0].a_type = OLD_ALLOW;\n          entries[0].a_flags = OLD_ACE_OWNER;\n          entries[0].a_who = 0; /* irrelevant */\n          entries[0].a_access_mask = (mode >> 6) & 7;\n          entries[1].a_type = OLD_ALLOW;\n          entries[1].a_flags = OLD_ACE_GROUP;\n          entries[1].a_who = 0; /* irrelevant */\n          entries[1].a_access_mask = (mode >> 3) & 7;\n          entries[2].a_type = OLD_ALLOW;\n          entries[2].a_flags = OLD_ACE_OTHER;\n          entries[2].a_who = 0;\n          entries[2].a_access_mask = mode & 7;\n          count = 3;\n        }\n      else\n        {\n          /* Running on Solaris 10 (newer version) or Solaris 11.\n             The details here were found through \"/bin/ls -lvd somefiles\".  */\n          entries[0].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[0].a_flags = NEW_ACE_OWNER;\n          entries[0].a_who = 0; /* irrelevant */\n          entries[0].a_access_mask = 0;\n          entries[1].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[1].a_flags = NEW_ACE_OWNER;\n          entries[1].a_who = 0; /* irrelevant */\n          entries[1].a_access_mask = NEW_ACE_WRITE_NAMED_ATTRS\n                                     | NEW_ACE_WRITE_ATTRIBUTES\n                                     | NEW_ACE_WRITE_ACL\n                                     | NEW_ACE_WRITE_OWNER;\n          if (mode & 0400)\n            entries[1].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[0].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0200)\n            entries[1].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[0].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0100)\n            entries[1].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[0].a_access_mask |= NEW_ACE_EXECUTE;\n          entries[2].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[2].a_flags = NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP;\n          entries[2].a_who = 0; /* irrelevant */\n          entries[2].a_access_mask = 0;\n          entries[3].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[3].a_flags = NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP;\n          entries[3].a_who = 0; /* irrelevant */\n          entries[3].a_access_mask = 0;\n          if (mode & 0040)\n            entries[3].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[2].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0020)\n            entries[3].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[2].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0010)\n            entries[3].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[2].a_access_mask |= NEW_ACE_EXECUTE;\n          entries[4].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[4].a_flags = NEW_ACE_EVERYONE;\n          entries[4].a_who = 0;\n          entries[4].a_access_mask = NEW_ACE_WRITE_NAMED_ATTRS\n                                     | NEW_ACE_WRITE_ATTRIBUTES\n                                     | NEW_ACE_WRITE_ACL\n                                     | NEW_ACE_WRITE_OWNER;\n          entries[5].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[5].a_flags = NEW_ACE_EVERYONE;\n          entries[5].a_who = 0;\n          entries[5].a_access_mask = NEW_ACE_READ_NAMED_ATTRS\n                                     | NEW_ACE_READ_ATTRIBUTES\n                                     | NEW_ACE_READ_ACL\n                                     | NEW_ACE_SYNCHRONIZE;\n          if (mode & 0004)\n            entries[5].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[4].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0002)\n            entries[5].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[4].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0001)\n            entries[5].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[4].a_access_mask |= NEW_ACE_EXECUTE;\n          count = 6;\n        }\n      if (desc != -1)\n        ret = facl (desc, ACE_SETACL, count, entries);\n      else\n        ret = acl (name, ACE_SETACL, count, entries);\n      if (ret < 0 && errno != EINVAL && errno != ENOTSUP)\n        {\n          if (errno == ENOSYS)\n\t    {\n\t      *must_chmod = true;\n\t      return 0;\n\t    }\n          return -1;\n        }\n      if (ret == 0)\n\treturn 0;\n    }\n#  endif\n\n  {\n    aclent_t entries[3];\n    int ret;\n\n    entries[0].a_type = USER_OBJ;\n    entries[0].a_id = 0; /* irrelevant */\n    entries[0].a_perm = (mode >> 6) & 7;\n    entries[1].a_type = GROUP_OBJ;\n    entries[1].a_id = 0; /* irrelevant */\n    entries[1].a_perm = (mode >> 3) & 7;\n    entries[2].a_type = OTHER_OBJ;\n    entries[2].a_id = 0;\n    entries[2].a_perm = mode & 7;\n\n    if (desc != -1)\n      ret = facl (desc, SETACL,\n\t\t  sizeof (entries) / sizeof (aclent_t), entries);\n    else\n      ret = acl (name, SETACL,\n\t\t sizeof (entries) / sizeof (aclent_t), entries);\n    if (ret < 0)\n      {\n\tif (errno == ENOSYS || errno == EOPNOTSUPP)\n\t  {\n\t    *must_chmod = true;\n\t    return 0;\n\t  }\n\treturn -1;\n      }\n    return 0;\n  }\n}",
        "lines": 220,
        "depth": 18,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          330,
          0
        ],
        "end_point": [
          441,
          1
        ],
        "content": "static int\nset_acls_from_mode (const char *name, int desc, mode_t mode, bool *must_chmod)\n{\n  acl_type_list_t types;\n  size_t types_size = sizeof (types);\n  acl_type_t type;\n\n  if (aclx_gettypes (name, &types, &types_size) < 0\n      || types.num_entries == 0)\n    {\n      *must_chmod = true;\n      return 0;\n    }\n\n  /* XXX Do we need to clear all types of ACLs for the given file, or is it\n     sufficient to clear the first one?  */\n  type = types.entries[0];\n  if (type.u64 == ACL_AIXC)\n    {\n      union { struct acl a; char room[128]; } u;\n      int ret;\n\n      u.a.acl_len = (char *) &u.a.acl_ext[0] - (char *) &u.a; /* no entries */\n      u.a.acl_mode = mode & ~(S_IXACL | 0777);\n      u.a.u_access = (mode >> 6) & 7;\n      u.a.g_access = (mode >> 3) & 7;\n      u.a.o_access = mode & 7;\n\n      if (desc != -1)\n        ret = aclx_fput (desc, SET_ACL | SET_MODE_S_BITS,\n                         type, &u.a, u.a.acl_len, mode);\n      else\n        ret = aclx_put (name, SET_ACL | SET_MODE_S_BITS,\n                        type, &u.a, u.a.acl_len, mode);\n      if (!(ret < 0 && errno == ENOSYS))\n        return ret;\n    }\n  else if (type.u64 == ACL_NFS4)\n    {\n      union { nfs4_acl_int_t a; char room[128]; } u;\n      nfs4_ace_int_t *ace;\n      int ret;\n\n      u.a.aclVersion = NFS4_ACL_INT_STRUCT_VERSION;\n      u.a.aclEntryN = 0;\n      ace = &u.a.aclEntry[0];\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_OWNER;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0400 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0200\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0100 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_GROUP;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0040 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0020\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0010 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_EVERYONE;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0004 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0002\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0001 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      u.a.aclLength = (char *) ace - (char *) &u.a;\n\n      if (desc != -1)\n        ret = aclx_fput (desc, SET_ACL | SET_MODE_S_BITS,\n                         type, &u.a, u.a.aclLength, mode);\n      else\n        ret = aclx_put (name, SET_ACL | SET_MODE_S_BITS,\n                        type, &u.a, u.a.aclLength, mode);\n      if (!(ret < 0 && errno == ENOSYS))\n        return ret;\n    }\n\n  *must_chmod = true;\n  return 0;\n}",
        "lines": 112,
        "depth": 16,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "context_acl_from_mode": [
      {
        "start_point": [
          276,
          0
        ],
        "end_point": [
          300,
          1
        ],
        "content": "static int\ncontext_acl_from_mode (struct permission_context *ctx, const char *name, int desc)\n{\n  struct stat statbuf;\n  int ret;\n\n  if (desc != -1)\n    ret = fstat (desc, &statbuf);\n  else\n    ret = stat (name, &statbuf);\n  if (ret < 0)\n    return -1;\n\n  ctx->entries[0].uid = statbuf.st_uid;\n  ctx->entries[0].gid = ACL_NSGROUP;\n  ctx->entries[0].mode = (ctx->mode >> 6) & 7;\n  ctx->entries[1].uid = ACL_NSUSER;\n  ctx->entries[1].gid = statbuf.st_gid;\n  ctx->entries[1].mode = (ctx->mode >> 3) & 7;\n  ctx->entries[2].uid = ACL_NSUSER;\n  ctx->entries[2].gid = ACL_NSGROUP;\n  ctx->entries[2].mode = ctx->mode & 7;\n  ctx->count = 3;\n  return 0;\n}",
        "lines": 25,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          444,
          0
        ],
        "end_point": [
          454,
          1
        ],
        "content": "static int\ncontext_acl_from_mode (struct permission_context *ctx)\n{\n  ctx->u.a.acl_len = (char *) &ctx->u.a.acl_ext[0] - (char *) &ctx->u.a; /* no entries */\n  ctx->u.a.acl_mode = ctx->mode & ~(S_IXACL | 0777);\n  ctx->u.a.u_access = (ctx->mode >> 6) & 7;\n  ctx->u.a.g_access = (ctx->mode >> 3) & 7;\n  ctx->u.a.o_access = ctx->mode & 7;\n  ctx->have_u = true;\n  return 0;\n}",
        "lines": 11,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          457,
          0
        ],
        "end_point": [
          480,
          1
        ],
        "content": "static int\ncontext_acl_from_mode (struct permission_context *ctx)\n{\n  int ret;\n\n  ctx->entries[0].a_type = USER_OBJ;\n  ctx->entries[0].a_id = 0; /* irrelevant */\n  ctx->entries[0].a_perm = (ctx->mode >> 6) & 7;\n  ctx->entries[1].a_type = GROUP_OBJ;\n  ctx->entries[1].a_id = 0; /* irrelevant */\n  ctx->entries[1].a_perm = (ctx->mode >> 3) & 7;\n  ctx->entries[2].a_type = CLASS_OBJ;\n  ctx->entries[2].a_id = 0;\n  ctx->entries[2].a_perm = (ctx->mode >> 3) & 7;\n  ctx->entries[3].a_type = OTHER_OBJ;\n  ctx->entries[3].a_id = 0;\n  ctx->entries[3].a_perm = ctx->mode & 7;\n  ctx->count = 4;\n\n  ret = aclsort (ctx->count, 1, entries);\n  if (ret > 0)\n    abort ();\n  return ret;\n}",
        "lines": 24,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "context_aclv_from_mode": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static int\ncontext_aclv_from_mode (struct permission_context *ctx)\n{\n  int ret;\n\n  ctx->aclv_entries[0].a_type = USER_OBJ;\n  ctx->aclv_entries[0].a_id = 0; /* irrelevant */\n  ctx->aclv_entries[0].a_perm = (ctx->mode >> 6) & 7;\n  ctx->aclv_entries[1].a_type = GROUP_OBJ;\n  ctx->aclv_entries[1].a_id = 0; /* irrelevant */\n  ctx->aclv_entries[1].a_perm = (ctx->mode >> 3) & 7;\n  ctx->aclv_entries[2].a_type = CLASS_OBJ;\n  ctx->aclv_entries[2].a_id = 0;\n  ctx->aclv_entries[2].a_perm = (ctx->mode >> 3) & 7;\n  ctx->aclv_entries[3].a_type = OTHER_OBJ;\n  ctx->aclv_entries[3].a_id = 0;\n  ctx->aclv_entries[3].a_perm = ctx->mode & 7;\n  ctx->aclv_count = 4;\n\n  ret = aclsort (ctx->aclv_count, 1, ctx->aclv_entries);\n  if (ret > 0)\n    abort ();\n  return ret;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_acls": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        749,
        1
      ],
      "content": "static int\nset_acls (struct permission_context *ctx, const char *name, int desc,\n\t  int from_mode, bool *must_chmod, bool *acls_set)\n{\n  int ret = 0;\n\n# if HAVE_ACL_GET_FILE\n  /* POSIX 1003.1e (draft 17 -- abandoned) specific version.  */\n  /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n#  if !HAVE_ACL_TYPE_EXTENDED\n  /* Linux, FreeBSD, IRIX, Tru64 */\n\n#   ifndef HAVE_ACL_FROM_TEXT\n#    error Must have acl_from_text (see POSIX 1003.1e draft 17).\n#   endif\n#   ifndef HAVE_ACL_DELETE_DEF_FILE\n#    error Must have acl_delete_def_file (see POSIX 1003.1e draft 17).\n#   endif\n\n  if (! ctx->acls_not_supported)\n    {\n      if (ret == 0 && from_mode)\n\t{\n\t  if (ctx->acl)\n\t    acl_free (ctx->acl);\n\t  ctx->acl = acl_from_mode (ctx->mode);\n\t  if (ctx->acl == NULL)\n\t    ret = -1;\n\t}\n\n      if (ret == 0 && ctx->acl)\n\t{\n\t  if (HAVE_ACL_SET_FD && desc != -1)\n\t    ret = acl_set_fd (desc, ctx->acl);\n\t  else\n\t    ret = acl_set_file (name, ACL_TYPE_ACCESS, ctx->acl);\n\t  if (ret != 0)\n\t    {\n\t      if (! acl_errno_valid (errno))\n\t\t{\n\t\t  ctx->acls_not_supported = true;\n\t\t  if (from_mode || acl_access_nontrivial (ctx->acl) == 0)\n\t\t    ret = 0;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      *acls_set = true;\n\t      if (S_ISDIR(ctx->mode))\n\t\t{\n\t\t  if (! from_mode && ctx->default_acl &&\n\t\t      acl_default_nontrivial (ctx->default_acl))\n\t\t    ret = acl_set_file (name, ACL_TYPE_DEFAULT,\n\t\t\t\t\tctx->default_acl);\n\t\t  else\n\t\t    ret = acl_delete_def_file (name);\n\t\t}\n\t    }\n\t}\n    }\n\n# if HAVE_ACL_TYPE_NFS4  /* FreeBSD */\n\n  /* File systems either support POSIX ACLs (for example, ufs) or NFS4 ACLs\n     (for example, zfs). */\n\n  /* TODO: Implement setting ACLs once get_permissions() reads them. */\n\n# endif\n\n#  else /* HAVE_ACL_TYPE_EXTENDED */\n  /* Mac OS X */\n\n  /* On Mac OS X,  acl_get_file (name, ACL_TYPE_ACCESS)\n     and           acl_get_file (name, ACL_TYPE_DEFAULT)\n     always return NULL / EINVAL.  You have to use\n                   acl_get_file (name, ACL_TYPE_EXTENDED)\n     or            acl_get_fd (open (name, ...))\n     to retrieve an ACL.\n     On the other hand,\n                   acl_set_file (name, ACL_TYPE_ACCESS, acl)\n     and           acl_set_file (name, ACL_TYPE_DEFAULT, acl)\n     have the same effect as\n                   acl_set_file (name, ACL_TYPE_EXTENDED, acl):\n     Each of these calls sets the file's ACL.  */\n\n  if (ctx->acl == NULL)\n    {\n      acl_t acl;\n\n      /* Remove ACLs if the file has ACLs.  */\n      if (HAVE_ACL_GET_FD && desc != -1)\n\tacl = acl_get_fd (desc);\n      else\n\tacl = acl_get_file (name, ACL_TYPE_EXTENDED);\n      if (acl)\n\t{\n\t  acl_free (acl);\n\n\t  acl = acl_init (0);\n\t  if (acl)\n\t    {\n\t      if (HAVE_ACL_SET_FD && desc != -1)\n\t\tret = acl_set_fd (desc, acl);\n\t      else\n\t\tret = acl_set_file (name, ACL_TYPE_EXTENDED, acl);\n\t      acl_free (acl);\n\t    }\n\t  else\n\t    ret = -1;\n\t}\n    }\n  else\n    {\n      if (HAVE_ACL_SET_FD && desc != -1)\n\tret = acl_set_fd (desc, ctx->acl);\n      else\n\tret = acl_set_file (name, ACL_TYPE_EXTENDED, ctx->acl);\n      if (ret != 0)\n\t{\n\t  if (! acl_errno_valid (errno)\n\t      && ! acl_extended_nontrivial (ctx->acl))\n\t    ret = 0;\n\t}\n    }\n  *acls_set = true;\n\n#  endif\n\n# elif defined GETACL /* Solaris, Cygwin, not HP-UX */\n\n  /* Solaris 2.5 through Solaris 10, Cygwin, and contemporaneous versions\n     of Unixware.  The acl() call returns the access and default ACL both\n     at once.  */\n\n  /* If both ace_entries and entries are available, try SETACL before\n     ACE_SETACL, because SETACL cannot fail with ENOTSUP whereas ACE_SETACL\n     can.  */\n\n  if (from_mode)\n    return set_acls_from_mode (name, desc, ctx->mode, must_chmod);\n\n  if (ret == 0 && ctx->count)\n    {\n      if (desc != -1)\n\tret = facl (desc, SETACL, ctx->count, ctx->entries);\n      else\n\tret = acl (name, SETACL, ctx->count, ctx->entries);\n      if (ret < 0)\n\t{\n\t  if ((errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n\t      && acl_nontrivial (ctx->count, ctx->entries) == 0)\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n\n#  ifdef ACE_GETACL\n  if (ret == 0 && ctx->ace_count)\n    {\n      if (desc != -1)\n\tret = facl (desc, ACE_SETACL, ctx->ace_count, ctx->ace_entries);\n      else\n\tret = acl (name, ACE_SETACL, ctx->ace_count, ctx->ace_entries);\n      if (ret < 0)\n\t{\n\t  if ((errno == ENOSYS || errno == EINVAL || errno == ENOTSUP)\n\t      && acl_ace_nontrivial (ctx->ace_count, ctx->ace_entries) == 0)\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n#  endif\n\n# elif HAVE_GETACL /* HP-UX */\n\n  if (from_mode)\n    ret = context_acl_from_mode (ctx, name, desc);\n\n  if (ret == 0 && ctx->count > 0)\n    {\n      if (desc != -1)\n\tret = fsetacl (desc, ctx->count, ctx->entries);\n      else\n\tret = setacl (name, ctx->count, ctx->entries);\n      if (ret < 0)\n\t{\n\t  if ((errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n\t      && (from_mode || !acl_nontrivial (ctx->count, ctx->entries)))\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n\n#  if HAVE_ACLV_H\n  if (from_mode)\n    ret = context_aclv_from_mode (ctx);\n\n  if (ret == 0 && ctx->aclv_count > 0)\n    {\n      ret = acl ((char *) name, ACL_SET, ctx->aclv_count, ctx->aclv_entries);\n      if (ret < 0)\n\t{\n\t  if ((errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n\t      && (from_mode || !aclv_nontrivial (ctx->aclv_count, ctx->aclv_entries)))\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n#  endif\n\n# elif HAVE_ACLX_GET && ACL_AIX_WIP /* AIX */\n\n  /* TODO: Implement setting ACLs once get_permissions() reads them. */\n\n  if (from_mode)\n    ret = set_acls_from_mode (name, desc, mode, must_chmod);\n\n# elif HAVE_STATACL /* older AIX */\n\n  if (from_mode)\n    ret = context_acl_from_mode (ctx);\n\n  if (ret == 0 && ctx->have_u)\n    {\n      if (desc != -1)\n\tret = fchacl (desc, &ctx->u.a, ctx->u.a.acl_len);\n      else\n\tret = chacl ((char *) name, &ctx->u.a, ctx->u.a.acl_len);\n      if (ret < 0)\n\t{\n\t  if (errno == ENOSYS && from_mode)\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n\n# elif HAVE_ACLSORT /* NonStop Kernel */\n\n  if (from_mode)\n    ret = context_acl_from_mode (ctx);\n\n  if (ret == 0 && ctx->count)\n    {\n      ret = acl ((char *) name, ACL_SET, ctx->count, ctx->entries);\n      if (ret != 0)\n\t{\n\t  if (!acl_nontrivial (ctx->count, ctx->entries))\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n\n# else  /* No ACLs */\n\n  /* Nothing to do. */\n\n# endif\n\n  return ret;\n}",
      "lines": 267,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "chmod_or_fchmod": {
      "start_point": [
        758,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "int\nchmod_or_fchmod (const char *name, int desc, mode_t mode)\n{\n  if (HAVE_FCHMOD && desc != -1)\n    return fchmod (desc, mode);\n  else\n    return chmod (name, mode);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_permissions": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "int\nset_permissions (struct permission_context *ctx, const char *name, int desc)\n{\n  bool acls_set _GL_UNUSED = false;\n  bool early_chmod;\n  bool must_chmod = false;\n  int ret = 0;\n\n#if USE_ACL\n# if HAVE_STATACL\n  /* older AIX */\n  /* There is no need to call chmod_or_fchmod, since the mode\n     bits S_ISUID, S_ISGID, S_ISVTX are also stored in the ACL.  */\n\n  early_chmod = false;\n# else\n  /* All other platforms */\n  /* On Cygwin, it is necessary to call chmod before acl, because\n     chmod can change the contents of the ACL (in ways that don't\n     change the allowed accesses, but still visible).  */\n\n  early_chmod = (! MODE_INSIDE_ACL || (ctx->mode & (S_ISUID | S_ISGID | S_ISVTX)));\n# endif\n#else\n  /* No ACLs */\n\n  early_chmod = true;\n#endif\n\n  if (early_chmod)\n    {\n      ret = chmod_or_fchmod (name, desc, ctx->mode);\n      if (ret != 0)\n\treturn -1;\n    }\n\n#if USE_ACL\n  ret = set_acls (ctx, name, desc, false, &must_chmod, &acls_set);\n  if (! acls_set)\n    {\n      int saved_errno = ret ? errno : 0;\n\n      /* If we can't set an acl which we expect to be able to set, try setting\n\t the permissions to ctx->mode. Due to possible inherited permissions,\n\t we cannot simply chmod.  */\n\n      ret = set_acls (ctx, name, desc, true, &must_chmod, &acls_set);\n      if (! acls_set)\n\tmust_chmod = true;\n\n      if (saved_errno)\n\t{\n\t  errno = saved_errno;\n\t  ret = -1;\n\t}\n    }\n#endif\n\n  if (must_chmod && ! early_chmod)\n    {\n      int saved_errno = ret ? errno : 0;\n\n      ret = chmod_or_fchmod (name, desc, ctx->mode);\n\n      if (saved_errno)\n\t{\n\t  errno = saved_errno;\n\t  ret = -1;\n\t}\n    }\n\n  return ret;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/setenv.c": {
    "__add_to_environ": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\n__add_to_environ (const char *name, const char *value, const char *combined,\n                  int replace)\n{\n  char **ep;\n  size_t size;\n  const size_t namelen = strlen (name);\n  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;\n\n  LOCK;\n\n  /* We have to get the pointer now that we have the lock and not earlier\n     since another thread might have created a new environment.  */\n  ep = __environ;\n\n  size = 0;\n  if (ep != NULL)\n    {\n      for (; *ep != NULL; ++ep)\n        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')\n          break;\n        else\n          ++size;\n    }\n\n  if (ep == NULL || *ep == NULL)\n    {\n      char **new_environ;\n#ifdef USE_TSEARCH\n      char *new_value;\n#endif\n\n      /* We allocated this space; we can extend it.  */\n      new_environ =\n        (char **) (last_environ == NULL\n                   ? malloc ((size + 2) * sizeof (char *))\n                   : realloc (last_environ, (size + 2) * sizeof (char *)));\n      if (new_environ == NULL)\n        {\n          /* It's easier to set errno to ENOMEM than to rely on the\n             'malloc-posix' and 'realloc-posix' gnulib modules.  */\n          __set_errno (ENOMEM);\n          UNLOCK;\n          return -1;\n        }\n\n      /* If the whole entry is given add it.  */\n      if (combined != NULL)\n        /* We must not add the string to the search tree since it belongs\n           to the user.  */\n        new_environ[size] = (char *) combined;\n      else\n        {\n          /* See whether the value is already known.  */\n#ifdef USE_TSEARCH\n# ifdef _LIBC\n          new_value = (char *) alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = (char *) malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          new_environ[size] = KNOWN_VALUE (new_value);\n          if (new_environ[size] == NULL)\n#endif\n            {\n              new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n              if (new_environ[size] == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (new_environ[size], new_value, namelen + 1 + vallen);\n#else\n              memcpy (new_environ[size], name, namelen);\n              new_environ[size][namelen] = '=';\n              memcpy (&new_environ[size][namelen + 1], value, vallen);\n#endif\n              /* And save the value now.  We cannot do this when we remove\n                 the string since then we cannot decide whether it is a\n                 user string or not.  */\n              STORE_VALUE (new_environ[size]);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      if (__environ != last_environ)\n        memcpy ((char *) new_environ, (char *) __environ,\n                size * sizeof (char *));\n\n      new_environ[size + 1] = NULL;\n\n      last_environ = __environ = new_environ;\n    }\n  else if (replace)\n    {\n      char *np;\n\n      /* Use the user string if given.  */\n      if (combined != NULL)\n        np = (char *) combined;\n      else\n        {\n#ifdef USE_TSEARCH\n          char *new_value;\n# ifdef _LIBC\n          new_value = alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          np = KNOWN_VALUE (new_value);\n          if (np == NULL)\n#endif\n            {\n              np = (char *) malloc (namelen + 1 + vallen);\n              if (np == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (np, new_value, namelen + 1 + vallen);\n#else\n              memcpy (np, name, namelen);\n              np[namelen] = '=';\n              memcpy (&np[namelen + 1], value, vallen);\n#endif\n              /* And remember the value.  */\n              STORE_VALUE (np);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      *ep = np;\n    }\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 177,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "setenv": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "clearenv": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_mem": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nfree_mem (void)\n{\n  /* Remove all traces.  */\n  clearenv ();\n\n  /* Now remove the search tree.  */\n  __tdestroy (known_values, free);\n  known_values = NULL;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_setenv": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\nrpl_setenv (const char *name, const char *value, int replace)\n{\n  int result;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Call the real setenv even if replace is 0, in case implementation\n     has underlying data to update, such as when environ changes.  */\n  result = setenv (name, value, replace);\n  if (result == 0 && replace && *value == '=')\n    {\n      char *tmp = getenv (name);\n      if (!STREQ (tmp, value))\n        {\n          int saved_errno;\n          size_t len = strlen (value);\n          tmp = malloca (len + 2);\n          /* Since leading '=' is eaten, double it up.  */\n          *tmp = '=';\n          memcpy (tmp + 1, value, len + 1);\n          result = setenv (name, tmp, replace);\n          saved_errno = errno;\n          freea (tmp);\n          errno = saved_errno;\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/signal.in.h": {},
  "tar/tar-1.30/gnu/size_max.h": {},
  "tar/tar-1.30/gnu/sleep.c": {
    "sleep": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "unsigned int\nsleep (unsigned int seconds)\n{\n  unsigned int remaining;\n\n  /* Sleep for 1 second many times, because\n       1. Sleep is not interruptible by Ctrl-C,\n       2. we want to avoid arithmetic overflow while multiplying with 1000.  */\n  for (remaining = seconds; remaining > 0; remaining--)\n    Sleep (1000);\n\n  return remaining;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "rpl_sleep": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "unsigned int\nrpl_sleep (unsigned int seconds)\n{\n  /* This requires int larger than 16 bits.  */\n  verify (UINT_MAX / 24 / 24 / 60 / 60);\n  const unsigned int limit = 24 * 24 * 60 * 60;\n  while (limit < seconds)\n    {\n      unsigned int result;\n      seconds -= limit;\n      result = sleep (limit);\n      if (result)\n        return seconds + result;\n    }\n  return sleep (seconds);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/snprintf.c": {
    "snprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nsnprintf (char *str, size_t size, const char *format, ...)\n{\n  char *output;\n  size_t len;\n  size_t lenbuf = size;\n  va_list args;\n\n  va_start (args, format);\n  output = vasnprintf (str, &lenbuf, format, args);\n  len = lenbuf;\n  va_end (args);\n\n  if (!output)\n    return -1;\n\n  if (output != str)\n    {\n      if (size)\n        {\n          size_t pruned_len = (len < size ? len : size - 1);\n          memcpy (str, output, pruned_len);\n          str[pruned_len] = '\\0';\n        }\n\n      free (output);\n    }\n\n  if (INT_MAX < len)\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/stat-macros.h": {},
  "tar/tar-1.30/gnu/stat-time.c": {},
  "tar/tar-1.30/gnu/stat-time.h": {
    "get_stat_atime_ns": {
      "start_point": [
        60,
        26
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_atime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_atim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_atim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_ctime_ns": {
      "start_point": [
        73,
        26
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_ctime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_ctim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_ctim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_mtime_ns": {
      "start_point": [
        86,
        26
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_mtime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_mtim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_mtim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_birthtime_ns": {
      "start_point": [
        99,
        26
      ],
      "end_point": [
        111,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_birthtime_ns (struct stat const *st)\n{\n# if defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC\n  return STAT_TIMESPEC (st, st_birthtim).tv_nsec;\n# elif defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC\n  return STAT_TIMESPEC_NS (st, st_birthtim);\n# else\n  /* Avoid a \"parameter unused\" warning.  */\n  (void) st;\n  return 0;\n# endif\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_atime": {
      "start_point": [
        114,
        28
      ],
      "end_point": [
        125,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_atime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_atim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_atime;\n  t.tv_nsec = get_stat_atime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_ctime": {
      "start_point": [
        128,
        28
      ],
      "end_point": [
        139,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_ctime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_ctim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_ctime;\n  t.tv_nsec = get_stat_ctime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_mtime": {
      "start_point": [
        142,
        28
      ],
      "end_point": [
        153,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_mtime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_mtim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_mtime;\n  t.tv_nsec = get_stat_mtime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_birthtime": {
      "start_point": [
        157,
        28
      ],
      "end_point": [
        202,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_birthtime (struct stat const *st)\n{\n  struct timespec t;\n\n#if (defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC)\n  t = STAT_TIMESPEC (st, st_birthtim);\n#elif defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC\n  t.tv_sec = st->st_birthtime;\n  t.tv_nsec = st->st_birthtimensec;\n#elif (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Native Windows platforms (but not Cygwin) put the \"file creation\n     time\" in st_ctime (!).  See\n     <https://msdn.microsoft.com/en-us/library/14h5k7ff(VS.80).aspx>.  */\n# if _GL_WINDOWS_STAT_TIMESPEC\n  t = st->st_ctim;\n# else\n  t.tv_sec = st->st_ctime;\n  t.tv_nsec = 0;\n# endif\n#else\n  /* Birth time is not supported.  */\n  t.tv_sec = -1;\n  t.tv_nsec = -1;\n  /* Avoid a \"parameter unused\" warning.  */\n  (void) st;\n#endif\n\n#if (defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC)\n  /* FreeBSD and NetBSD sometimes signal the absence of knowledge by\n     using zero.  Attempt to work around this problem.  Alas, this can\n     report failure even for valid timestamps.  Also, NetBSD\n     sometimes returns junk in the birth time fields; work around this\n     bug if it is detected.  */\n  if (! (t.tv_sec && 0 <= t.tv_nsec && t.tv_nsec < 1000000000))\n    {\n      t.tv_sec = -1;\n      t.tv_nsec = -1;\n    }\n#endif\n\n  return t;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    }
  },
  "tar/tar-1.30/gnu/stat-w32.c": {
    "initialize": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\ninitialize (void)\n{\n  HMODULE kernel32 = LoadLibrary (\"kernel32.dll\");\n  if (kernel32 != NULL)\n    {\n#if _GL_WINDOWS_STAT_INODES == 2\n      GetFileInformationByHandleExFunc =\n        (GetFileInformationByHandleExFuncType) GetProcAddress (kernel32, \"GetFileInformationByHandleEx\");\n#endif\n      GetFinalPathNameByHandleFunc =\n        (GetFinalPathNameByHandleFuncType) GetProcAddress (kernel32, \"GetFinalPathNameByHandleA\");\n    }\n  initialized = TRUE;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_gl_convert_FILETIME_to_timespec": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "struct timespec\n_gl_convert_FILETIME_to_timespec (const FILETIME *ft)\n{\n  struct timespec result;\n  /* FILETIME: <https://msdn.microsoft.com/en-us/library/ms724284.aspx> */\n  unsigned long long since_1601 =\n    ((unsigned long long) ft->dwHighDateTime << 32)\n    | (unsigned long long) ft->dwLowDateTime;\n  if (since_1601 == 0)\n    {\n      result.tv_sec = 0;\n      result.tv_nsec = 0;\n    }\n  else\n    {\n      /* Between 1601-01-01 and 1970-01-01 there were 280 normal years and 89\n         leap years, in total 134774 days.  */\n      unsigned long long since_1970 =\n        since_1601 - (unsigned long long) 134774 * (unsigned long long) 86400 * (unsigned long long) 10000000;\n      result.tv_sec = since_1970 / (unsigned long long) 10000000;\n      result.tv_nsec = (unsigned long) (since_1970 % (unsigned long long) 10000000) * 100;\n    }\n  return result;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "struct timespec",
        "struct",
        "timespec"
      ]
    },
    "_gl_convert_FILETIME_to_POSIX": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "time_t\n_gl_convert_FILETIME_to_POSIX (const FILETIME *ft)\n{\n  /* FILETIME: <https://msdn.microsoft.com/en-us/library/ms724284.aspx> */\n  unsigned long long since_1601 =\n    ((unsigned long long) ft->dwHighDateTime << 32)\n    | (unsigned long long) ft->dwLowDateTime;\n  if (since_1601 == 0)\n    return 0;\n  else\n    {\n      /* Between 1601-01-01 and 1970-01-01 there were 280 normal years and 89\n         leap years, in total 134774 days.  */\n      unsigned long long since_1970 =\n        since_1601 - (unsigned long long) 134774 * (unsigned long long) 86400 * (unsigned long long) 10000000;\n      return since_1970 / (unsigned long long) 10000000;\n    }\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "time_t"
      ]
    },
    "_gl_fstat_by_handle": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "int\n_gl_fstat_by_handle (HANDLE h, const char *path, struct stat *buf)\n{\n  /* GetFileType\n     <https://msdn.microsoft.com/en-us/library/aa364960.aspx> */\n  DWORD type = GetFileType (h);\n  if (type == FILE_TYPE_DISK)\n    {\n      if (!initialized)\n        initialize ();\n\n      /* st_mode can be determined through\n         GetFileAttributesEx\n         <https://msdn.microsoft.com/en-us/library/aa364946.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365739.aspx>\n         or through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileBasicInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364217.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n      BY_HANDLE_FILE_INFORMATION info;\n      if (! GetFileInformationByHandle (h, &info))\n        goto failed;\n\n      /* Test for error conditions before starting to fill *buf.  */\n      if (sizeof (buf->st_size) <= 4 && info.nFileSizeHigh > 0)\n        {\n          errno = EOVERFLOW;\n          return -1;\n        }\n\n#if _GL_WINDOWS_STAT_INODES\n      /* st_ino can be determined through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         as 64 bits, or through\n         GetFileInformationByHandleEx with argument FileIdInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/hh802691.aspx>\n         as 128 bits.\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_WIN8 or higher.  */\n      /* Experiments show that GetFileInformationByHandleEx does not provide\n         much more information than GetFileInformationByHandle:\n           * The dwVolumeSerialNumber from GetFileInformationByHandle is equal\n             to the low 32 bits of the 64-bit VolumeSerialNumber from\n             GetFileInformationByHandleEx, and is apparently sufficient for\n             identifying the device.\n           * The nFileIndex from GetFileInformationByHandle is equal to the low\n             64 bits of the 128-bit FileId from GetFileInformationByHandleEx,\n             and the high 64 bits of this 128-bit FileId are zero.\n           * On a FAT file system, GetFileInformationByHandleEx fails with error\n             ERROR_INVALID_PARAMETER, whereas GetFileInformationByHandle\n             succeeds.\n           * On a CIFS/SMB file system, GetFileInformationByHandleEx fails with\n             error ERROR_INVALID_LEVEL, whereas GetFileInformationByHandle\n             succeeds.  */\n# if _GL_WINDOWS_STAT_INODES == 2\n      if (GetFileInformationByHandleExFunc != NULL)\n        {\n          FILE_ID_INFO id;\n          if (GetFileInformationByHandleExFunc (h, FileIdInfo, &id, sizeof (id)))\n            {\n              buf->st_dev = id.VolumeSerialNumber;\n              verify (sizeof (ino_t) == sizeof (id.FileId));\n              memcpy (&buf->st_ino, &id.FileId, sizeof (ino_t));\n              goto ino_done;\n            }\n          else\n            {\n              switch (GetLastError ())\n                {\n                case ERROR_INVALID_PARAMETER: /* older Windows version, or FAT */\n                case ERROR_INVALID_LEVEL: /* CIFS/SMB file system */\n                  goto fallback;\n                default:\n                  goto failed;\n                }\n            }\n        }\n     fallback: ;\n      /* Fallback for older Windows versions.  */\n      buf->st_dev = info.dwVolumeSerialNumber;\n      buf->st_ino._gl_ino[0] = ((ULONGLONG) info.nFileIndexHigh << 32) | (ULONGLONG) info.nFileIndexLow;\n      buf->st_ino._gl_ino[1] = 0;\n     ino_done: ;\n# else /* _GL_WINDOWS_STAT_INODES == 1 */\n      buf->st_dev = info.dwVolumeSerialNumber;\n      buf->st_ino = ((ULONGLONG) info.nFileIndexHigh << 32) | (ULONGLONG) info.nFileIndexLow;\n# endif\n#else\n      /* st_ino is not wide enough for identifying a file on a device.\n         Without st_ino, st_dev is pointless.  */\n      buf->st_dev = 0;\n      buf->st_ino = 0;\n#endif\n\n      /* st_mode.  */\n      unsigned int mode =\n        /* XXX How to handle FILE_ATTRIBUTE_REPARSE_POINT ?  */\n        ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : _S_IFREG)\n        | S_IREAD_UGO\n        | ((info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? 0 : S_IWRITE_UGO);\n      if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))\n        {\n          /* Determine whether the file is executable by looking at the file\n             name suffix.\n             If the file name is already known, use it. Otherwise, for\n             non-empty files, it can be determined through\n             GetFinalPathNameByHandle\n             <https://msdn.microsoft.com/en-us/library/aa364962.aspx>\n             or through\n             GetFileInformationByHandleEx with argument FileNameInfo\n             <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n             <https://msdn.microsoft.com/en-us/library/aa364388.aspx>\n             Both require -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n          if (info.nFileSizeHigh > 0 || info.nFileSizeLow > 0)\n            {\n              char fpath[PATH_MAX];\n              if (path != NULL\n                  || (GetFinalPathNameByHandleFunc != NULL\n                      && GetFinalPathNameByHandleFunc (h, fpath, sizeof (fpath), VOLUME_NAME_NONE)\n                         < sizeof (fpath)\n                      && (path = fpath, 1)))\n                {\n                  const char *last_dot = NULL;\n                  const char *p;\n                  for (p = path; *p != '\\0'; p++)\n                    if (*p == '.')\n                      last_dot = p;\n                  if (last_dot != NULL)\n                    {\n                      const char *suffix = last_dot + 1;\n                      if (_stricmp (suffix, \"exe\") == 0\n                          || _stricmp (suffix, \"bat\") == 0\n                          || _stricmp (suffix, \"cmd\") == 0\n                          || _stricmp (suffix, \"com\") == 0)\n                        mode |= S_IEXEC_UGO;\n                    }\n                }\n              else\n                /* Cannot determine file name.  Pretend that it is executable.  */\n                mode |= S_IEXEC_UGO;\n            }\n        }\n      buf->st_mode = mode;\n\n      /* st_nlink can be determined through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileStandardInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364401.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n      buf->st_nlink = (info.nNumberOfLinks > SHRT_MAX ? SHRT_MAX : info.nNumberOfLinks);\n\n      /* There's no easy way to map the Windows SID concept to an integer.  */\n      buf->st_uid = 0;\n      buf->st_gid = 0;\n\n      /* st_rdev is irrelevant for normal files and directories.  */\n      buf->st_rdev = 0;\n\n      /* st_size can be determined through\n         GetFileSizeEx\n         <https://msdn.microsoft.com/en-us/library/aa364957.aspx>\n         or through\n         GetFileAttributesEx\n         <https://msdn.microsoft.com/en-us/library/aa364946.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365739.aspx>\n         or through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileStandardInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364401.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n      if (sizeof (buf->st_size) <= 4)\n        /* Range check already done above.  */\n        buf->st_size = info.nFileSizeLow;\n      else\n        buf->st_size = ((long long) info.nFileSizeHigh << 32) | (long long) info.nFileSizeLow;\n\n      /* st_atime, st_mtime, st_ctime can be determined through\n         GetFileTime\n         <https://msdn.microsoft.com/en-us/library/ms724320.aspx>\n         or through\n         GetFileAttributesEx\n         <https://msdn.microsoft.com/en-us/library/aa364946.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365739.aspx>\n         or through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileBasicInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364217.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n#if _GL_WINDOWS_STAT_TIMESPEC\n      buf->st_atim = _gl_convert_FILETIME_to_timespec (&info.ftLastAccessTime);\n      buf->st_mtim = _gl_convert_FILETIME_to_timespec (&info.ftLastWriteTime);\n      buf->st_ctim = _gl_convert_FILETIME_to_timespec (&info.ftCreationTime);\n#else\n      buf->st_atime = _gl_convert_FILETIME_to_POSIX (&info.ftLastAccessTime);\n      buf->st_mtime = _gl_convert_FILETIME_to_POSIX (&info.ftLastWriteTime);\n      buf->st_ctime = _gl_convert_FILETIME_to_POSIX (&info.ftCreationTime);\n#endif\n\n      return 0;\n    }\n  else if (type == FILE_TYPE_CHAR || type == FILE_TYPE_PIPE)\n    {\n      buf->st_dev = 0;\n#if _GL_WINDOWS_STAT_INODES == 2\n      buf->st_ino._gl_ino[0] = buf->st_ino._gl_ino[1] = 0;\n#else\n      buf->st_ino = 0;\n#endif\n      buf->st_mode = (type == FILE_TYPE_PIPE ? _S_IFIFO : _S_IFCHR);\n      buf->st_nlink = 1;\n      buf->st_uid = 0;\n      buf->st_gid = 0;\n      buf->st_rdev = 0;\n      if (type == FILE_TYPE_PIPE)\n        {\n          /* PeekNamedPipe\n             <https://msdn.microsoft.com/en-us/library/aa365779.aspx> */\n          DWORD bytes_available;\n          if (PeekNamedPipe (h, NULL, 0, NULL, &bytes_available, NULL))\n            buf->st_size = bytes_available;\n          else\n            buf->st_size = 0;\n        }\n      else\n        buf->st_size = 0;\n#if _GL_WINDOWS_STAT_TIMESPEC\n      buf->st_atim.tv_sec = 0; buf->st_atim.tv_nsec = 0;\n      buf->st_mtim.tv_sec = 0; buf->st_mtim.tv_nsec = 0;\n      buf->st_ctim.tv_sec = 0; buf->st_ctim.tv_nsec = 0;\n#else\n      buf->st_atime = 0;\n      buf->st_mtime = 0;\n      buf->st_ctime = 0;\n#endif\n      return 0;\n    }\n  else\n    {\n      errno = ENOENT;\n      return -1;\n    }\n\n failed:\n  {\n    DWORD error = GetLastError ();\n    #if 0\n    fprintf (stderr, \"_gl_fstat_by_handle error 0x%x\\n\", (unsigned int) error);\n    #endif\n    switch (error)\n      {\n      case ERROR_ACCESS_DENIED:\n      case ERROR_SHARING_VIOLATION:\n        errno = EACCES;\n        break;\n\n      case ERROR_OUTOFMEMORY:\n        errno = ENOMEM;\n        break;\n\n      case ERROR_WRITE_FAULT:\n      case ERROR_READ_FAULT:\n      case ERROR_GEN_FAILURE:\n        errno = EIO;\n        break;\n\n      default:\n        errno = EINVAL;\n        break;\n      }\n    return -1;\n  }\n}",
      "lines": 291,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/stat-w32.h": {},
  "tar/tar-1.30/gnu/stat.c": {
    "orig_stat": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_unc_root": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static BOOL\nis_unc_root (const char *rname)\n{\n  /* Test whether it has the syntax '\\\\server\\share'.  */\n  if (ISSLASH (rname[0]) && ISSLASH (rname[1]))\n    {\n      /* It starts with two slashes.  Find the next slash.  */\n      const char *p = rname + 2;\n      const char *q = p;\n      while (*q != '\\0' && !ISSLASH (*q))\n        q++;\n      if (q > p && *q != '\\0')\n        {\n          /* Found the next slash at q.  */\n          q++;\n          const char *r = q;\n          while (*r != '\\0' && !ISSLASH (*r))\n            r++;\n          if (r > q && *r == '\\0')\n            return TRUE;\n        }\n    }\n  return FALSE;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "rpl_stat": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *buf)\n{\n#ifdef WINDOWS_NATIVE\n  /* Fill the fields ourselves, because the original stat function returns\n     values for st_atime, st_mtime, st_ctime that depend on the current time\n     zone.  See\n     <https://lists.gnu.org/r/bug-gnulib/2017-04/msg00134.html>  */\n  /* XXX Should we convert to wchar_t* and prepend '\\\\?\\', in order to work\n     around length limitations\n     <https://msdn.microsoft.com/en-us/library/aa365247.aspx> ?  */\n\n  /* POSIX <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>\n     specifies: \"More than two leading <slash> characters shall be treated as\n     a single <slash> character.\"  */\n  if (ISSLASH (name[0]) && ISSLASH (name[1]) && ISSLASH (name[2]))\n    {\n      name += 2;\n      while (ISSLASH (name[1]))\n        name++;\n    }\n\n  size_t len = strlen (name);\n  size_t drive_prefix_len = (HAS_DEVICE (name) ? 2 : 0);\n\n  /* Remove trailing slashes (except the very first one, at position\n     drive_prefix_len), but remember their presence.  */\n  size_t rlen;\n  bool check_dir = false;\n\n  rlen = len;\n  while (rlen > drive_prefix_len && ISSLASH (name[rlen-1]))\n    {\n      check_dir = true;\n      if (rlen == drive_prefix_len + 1)\n        break;\n      rlen--;\n    }\n\n  /* Handle '' and 'C:'.  */\n  if (!check_dir && rlen == drive_prefix_len)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n\n  /* Handle '\\\\'.  */\n  if (rlen == 1 && ISSLASH (name[0]) && len >= 2)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n\n  const char *rname;\n  char *malloca_rname;\n  if (rlen == len)\n    {\n      rname = name;\n      malloca_rname = NULL;\n    }\n  else\n    {\n      malloca_rname = malloca (rlen + 1);\n      if (malloca_rname == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      memcpy (malloca_rname, name, rlen);\n      malloca_rname[rlen] = '\\0';\n      rname = malloca_rname;\n    }\n\n  /* There are two ways to get at the requested information:\n       - by scanning the parent directory and examining the relevant\n         directory entry,\n       - by opening the file directly.\n     The first approach fails for root directories (e.g. 'C:\\') and\n     UNC root directories (e.g. '\\\\server\\share').\n     The second approach fails for some system files (e.g. 'C:\\pagefile.sys'\n     and 'C:\\hiberfil.sys'): ERROR_SHARING_VIOLATION.\n     The second approach gives more information (in particular, correct\n     st_dev, st_ino, st_nlink fields).\n     So we use the second approach and, as a fallback except for root and\n     UNC root directories, also the first approach.  */\n  {\n    int ret;\n\n    {\n      /* Approach based on the file.  */\n\n      /* Open a handle to the file.\n         CreateFile\n         <https://msdn.microsoft.com/en-us/library/aa363858.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363874.aspx>  */\n      HANDLE h =\n        CreateFile (rname,\n                    FILE_READ_ATTRIBUTES,\n                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                    NULL,\n                    OPEN_EXISTING,\n                    /* FILE_FLAG_POSIX_SEMANTICS (treat file names that differ only\n                       in case as different) makes sense only when applied to *all*\n                       filesystem operations.  */\n                    FILE_FLAG_BACKUP_SEMANTICS /* | FILE_FLAG_POSIX_SEMANTICS */,\n                    NULL);\n      if (h != INVALID_HANDLE_VALUE)\n        {\n          ret = _gl_fstat_by_handle (h, rname, buf);\n          CloseHandle (h);\n          goto done;\n        }\n    }\n\n    /* Test for root and UNC root directories.  */\n    if ((rlen == drive_prefix_len + 1 && ISSLASH (rname[drive_prefix_len]))\n        || is_unc_root (rname))\n      goto failed;\n\n    /* Fallback.  */\n    {\n      /* Approach based on the directory entry.  */\n\n      if (strchr (rname, '?') != NULL || strchr (rname, '*') != NULL)\n        {\n          /* Other Windows API functions would fail with error\n             ERROR_INVALID_NAME.  */\n          if (malloca_rname != NULL)\n            freea (malloca_rname);\n          errno = ENOENT;\n          return -1;\n        }\n\n      /* Get the details about the directory entry.  This can be done through\n         FindFirstFile\n         <https://msdn.microsoft.com/en-us/library/aa364418.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365740.aspx>\n         or through\n         FindFirstFileEx with argument FindExInfoBasic\n         <https://msdn.microsoft.com/en-us/library/aa364419.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364415.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365740.aspx>  */\n      WIN32_FIND_DATA info;\n      HANDLE h = FindFirstFile (rname, &info);\n      if (h == INVALID_HANDLE_VALUE)\n        goto failed;\n\n      /* Test for error conditions before starting to fill *buf.  */\n      if (sizeof (buf->st_size) <= 4 && info.nFileSizeHigh > 0)\n        {\n          FindClose (h);\n          if (malloca_rname != NULL)\n            freea (malloca_rname);\n          errno = EOVERFLOW;\n          return -1;\n        }\n\n# if _GL_WINDOWS_STAT_INODES\n      buf->st_dev = 0;\n#  if _GL_WINDOWS_STAT_INODES == 2\n      buf->st_ino._gl_ino[0] = buf->st_ino._gl_ino[1] = 0;\n#  else /* _GL_WINDOWS_STAT_INODES == 1 */\n      buf->st_ino = 0;\n#  endif\n# else\n      /* st_ino is not wide enough for identifying a file on a device.\n         Without st_ino, st_dev is pointless.  */\n      buf->st_dev = 0;\n      buf->st_ino = 0;\n# endif\n\n      /* st_mode.  */\n      unsigned int mode =\n        /* XXX How to handle FILE_ATTRIBUTE_REPARSE_POINT ?  */\n        ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : _S_IFREG)\n        | S_IREAD_UGO\n        | ((info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? 0 : S_IWRITE_UGO);\n      if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))\n        {\n          /* Determine whether the file is executable by looking at the file\n             name suffix.  */\n          if (info.nFileSizeHigh > 0 || info.nFileSizeLow > 0)\n            {\n              const char *last_dot = NULL;\n              const char *p;\n              for (p = info.cFileName; *p != '\\0'; p++)\n                if (*p == '.')\n                  last_dot = p;\n              if (last_dot != NULL)\n                {\n                  const char *suffix = last_dot + 1;\n                  if (_stricmp (suffix, \"exe\") == 0\n                      || _stricmp (suffix, \"bat\") == 0\n                      || _stricmp (suffix, \"cmd\") == 0\n                      || _stricmp (suffix, \"com\") == 0)\n                    mode |= S_IEXEC_UGO;\n                }\n            }\n        }\n      buf->st_mode = mode;\n\n      /* st_nlink.  Ignore hard links here.  */\n      buf->st_nlink = 1;\n\n      /* There's no easy way to map the Windows SID concept to an integer.  */\n      buf->st_uid = 0;\n      buf->st_gid = 0;\n\n      /* st_rdev is irrelevant for normal files and directories.  */\n      buf->st_rdev = 0;\n\n      /* st_size.  */\n      if (sizeof (buf->st_size) <= 4)\n        /* Range check already done above.  */\n        buf->st_size = info.nFileSizeLow;\n      else\n        buf->st_size = ((long long) info.nFileSizeHigh << 32) | (long long) info.nFileSizeLow;\n\n      /* st_atime, st_mtime, st_ctime.  */\n# if _GL_WINDOWS_STAT_TIMESPEC\n      buf->st_atim = _gl_convert_FILETIME_to_timespec (&info.ftLastAccessTime);\n      buf->st_mtim = _gl_convert_FILETIME_to_timespec (&info.ftLastWriteTime);\n      buf->st_ctim = _gl_convert_FILETIME_to_timespec (&info.ftCreationTime);\n# else\n      buf->st_atime = _gl_convert_FILETIME_to_POSIX (&info.ftLastAccessTime);\n      buf->st_mtime = _gl_convert_FILETIME_to_POSIX (&info.ftLastWriteTime);\n      buf->st_ctime = _gl_convert_FILETIME_to_POSIX (&info.ftCreationTime);\n# endif\n\n      FindClose (h);\n\n      ret = 0;\n    }\n\n   done:\n    if (ret >= 0 && check_dir && !S_ISDIR (buf->st_mode))\n      {\n        errno = ENOTDIR;\n        ret = -1;\n      }\n    if (malloca_rname != NULL)\n      {\n        int saved_errno = errno;\n        freea (malloca_rname);\n        errno = saved_errno;\n      }\n    return ret;\n  }\n\n failed:\n  {\n    DWORD error = GetLastError ();\n    #if 0\n    fprintf (stderr, \"rpl_stat error 0x%x\\n\", (unsigned int) error);\n    #endif\n\n    if (malloca_rname != NULL)\n      freea (malloca_rname);\n\n    switch (error)\n      {\n      /* Some of these errors probably cannot happen with the specific flags\n         that we pass to CreateFile.  But who knows...  */\n      case ERROR_FILE_NOT_FOUND: /* The last component of rname does not exist.  */\n      case ERROR_PATH_NOT_FOUND: /* Some directory component in rname does not exist.  */\n      case ERROR_BAD_PATHNAME:   /* rname is such as '\\\\server'.  */\n      case ERROR_BAD_NET_NAME:   /* rname is such as '\\\\server\\nonexistentshare'.  */\n      case ERROR_INVALID_NAME:   /* rname contains wildcards, misplaced colon, etc.  */\n      case ERROR_DIRECTORY:\n        errno = ENOENT;\n        break;\n\n      case ERROR_ACCESS_DENIED:  /* rname is such as 'C:\\System Volume Information\\foo'.  */\n      case ERROR_SHARING_VIOLATION: /* rname is such as 'C:\\pagefile.sys' (second approach only).  */\n                                    /* XXX map to EACCESS or EPERM? */\n        errno = EACCES;\n        break;\n\n      case ERROR_OUTOFMEMORY:\n        errno = ENOMEM;\n        break;\n\n      case ERROR_WRITE_PROTECT:\n        errno = EROFS;\n        break;\n\n      case ERROR_WRITE_FAULT:\n      case ERROR_READ_FAULT:\n      case ERROR_GEN_FAILURE:\n        errno = EIO;\n        break;\n\n      case ERROR_BUFFER_OVERFLOW:\n      case ERROR_FILENAME_EXCED_RANGE:\n        errno = ENAMETOOLONG;\n        break;\n\n      case ERROR_DELETE_PENDING: /* XXX map to EACCESS or EPERM? */\n        errno = EPERM;\n        break;\n\n      default:\n        errno = EINVAL;\n        break;\n      }\n\n    return -1;\n  }\n#else\n  int result = orig_stat (name, buf);\n# if REPLACE_FUNC_STAT_FILE\n  /* Solaris 9 mistakenly succeeds when given a non-directory with a\n     trailing slash.  */\n  if (result == 0 && !S_ISDIR (buf->st_mode))\n    {\n      size_t len = strlen (name);\n      if (ISSLASH (name[len - 1]))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n# endif /* REPLACE_FUNC_STAT_FILE */\n  return result;\n#endif\n}",
      "lines": 326,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/statat.c": {},
  "tar/tar-1.30/gnu/stdalign.in.h": {},
  "tar/tar-1.30/gnu/stdarg.in.h": {},
  "tar/tar-1.30/gnu/stdbool.in.h": {},
  "tar/tar-1.30/gnu/stddef.in.h": {},
  "tar/tar-1.30/gnu/stdint.in.h": {},
  "tar/tar-1.30/gnu/stdio-impl.h": {},
  "tar/tar-1.30/gnu/stdio.in.h": {},
  "tar/tar-1.30/gnu/stdlib.in.h": {},
  "tar/tar-1.30/gnu/stpcpy.c": {
    "__stpcpy": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "char *\n__stpcpy (char *dest, const char *src)\n{\n  register char *d = dest;\n  register const char *s = src;\n\n  do\n    *d++ = *s;\n  while (*s++ != '\\0');\n\n  return d - 1;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__stpcpy (char *dest, const char *src)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/strcasecmp.c": {
    "strcasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrcasecmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/strchrnul.c": {
    "strchrnul": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "char *\nstrchrnul (const char *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n  if (!c)\n    return rawmemchr (s, 0);\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (!*char_ptr || *char_ptr == c)\n      return (char *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 or\n     longword2 is zero.\n\n     Let's consider longword1.  We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 or longword2 is zero is equivalent\n     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine\n     this into a single test, whether (tmp1 | tmp2) is nonzero.\n\n     This test can read more than one byte beyond the end of a string,\n     depending on where the terminating NUL is encountered.  However,\n     this is considered safe since the initialization phase ensured\n     that the read will be aligned, therefore, the read will not cross\n     page boundaries and will not cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n      longword longword2 = *longword_ptr;\n\n      if (((((longword1 - repeated_one) & ~longword1)\n            | ((longword2 - repeated_one) & ~longword2))\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == 0 or == c.  On little-endian machines,\n     we could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr && (*char_ptr != c))\n    char_ptr++;\n  return (char *) char_ptr;\n}",
      "lines": 120,
      "depth": 16,
      "decorators": [
        "char",
        "*\nstrchrnul (const char *s, int c_in)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/strdup.c": {
    "__strdup": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "char *\n__strdup (const char *s)\n{\n  size_t len = strlen (s) + 1;\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (char *) memcpy (new, s, len);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__strdup (const char *s)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/strerror-override.h": {},
  "tar/tar-1.30/gnu/strerror.c": {},
  "tar/tar-1.30/gnu/strftime.h": {},
  "tar/tar-1.30/gnu/string.in.h": {},
  "tar/tar-1.30/gnu/strings.in.h": {},
  "tar/tar-1.30/gnu/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "tar/tar-1.30/gnu/strncasecmp.c": {
    "strncasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/strndup.c": {
    "strndup": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nstrndup (char const *s, size_t n)\n{\n  size_t len = strnlen (s, n);\n  char *new = malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return memcpy (new, s, len);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrndup (char const *s, size_t n)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/strnlen.c": {
    "strnlen": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\nstrnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/strnlen1.c": {
    "strnlen1": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "size_t\nstrnlen1 (const char *string, size_t maxlen)\n{\n  const char *end = (const char *) memchr (string, '\\0', maxlen);\n  if (end != NULL)\n    return end - string + 1;\n  else\n    return maxlen;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/strnlen1.h": {},
  "tar/tar-1.30/gnu/strtoimax.c": {
    "Strtoimax": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "Int\nStrtoimax (char const *ptr, char **endptr, int base)\n{\n#if Have_long_long\n  verify (sizeof (Int) == sizeof (Unsigned long int)\n          || sizeof (Int) == sizeof (Unsigned long long int));\n\n  if (sizeof (Int) != sizeof (Unsigned long int))\n    return Strtoll (ptr, endptr, base);\n#else\n  verify (sizeof (Int) == sizeof (Unsigned long int));\n#endif\n\n  return Strtol (ptr, endptr, base);\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "Int"
      ]
    }
  },
  "tar/tar-1.30/gnu/strtol.c": {
    "INTERNAL": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "INT\nINTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n                   int base, int group LOCALE_PARAM_PROTO)\n{\n  int negative;\n  register unsigned LONG int cutoff;\n  register unsigned int cutlim;\n  register unsigned LONG int i;\n  register const STRING_TYPE *s;\n  register UCHAR_TYPE c;\n  const STRING_TYPE *save, *end;\n  int overflow;\n\n#ifdef USE_NUMBER_GROUPING\n# ifdef USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *current = loc->__locales[LC_NUMERIC];\n# endif\n  /* The thousands character of the current locale.  */\n  wchar_t thousands = L'\\0';\n  /* The numeric grouping specification of the current locale,\n     in the format described in <locale.h>.  */\n  const char *grouping;\n\n  if (group)\n    {\n      grouping = _NL_CURRENT (LC_NUMERIC, GROUPING);\n      if (*grouping <= 0 || *grouping == CHAR_MAX)\n        grouping = NULL;\n      else\n        {\n          /* Figure out the thousands separator character.  */\n# if defined _LIBC || defined _HAVE_BTOWC\n          thousands = __btowc (*_NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP));\n          if (thousands == WEOF)\n            thousands = L'\\0';\n# endif\n          if (thousands == L'\\0')\n            grouping = NULL;\n        }\n    }\n  else\n    grouping = NULL;\n#endif\n\n  if (base < 0 || base == 1 || base > 36)\n    {\n      __set_errno (EINVAL);\n      return 0;\n    }\n\n  save = s = nptr;\n\n  /* Skip white space.  */\n  while (ISSPACE (*s))\n    ++s;\n  if (*s == L_('\\0'))\n    goto noconv;\n\n  /* Check for a sign.  */\n  if (*s == L_('-'))\n    {\n      negative = 1;\n      ++s;\n    }\n  else if (*s == L_('+'))\n    {\n      negative = 0;\n      ++s;\n    }\n  else\n    negative = 0;\n\n  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */\n  if (*s == L_('0'))\n    {\n      if ((base == 0 || base == 16) && TOUPPER (s[1]) == L_('X'))\n        {\n          s += 2;\n          base = 16;\n        }\n      else if (base == 0)\n        base = 8;\n    }\n  else if (base == 0)\n    base = 10;\n\n  /* Save the pointer so we can check later if anything happened.  */\n  save = s;\n\n#ifdef USE_NUMBER_GROUPING\n  if (group)\n    {\n      /* Find the end of the digit string and check its grouping.  */\n      end = s;\n      for (c = *end; c != L_('\\0'); c = *++end)\n        if ((wchar_t) c != thousands\n            && ((wchar_t) c < L_('0') || (wchar_t) c > L_('9'))\n            && (!ISALPHA (c) || (int) (TOUPPER (c) - L_('A') + 10) >= base))\n          break;\n      if (*s == thousands)\n        end = s;\n      else\n        end = correctly_grouped_prefix (s, end, thousands, grouping);\n    }\n  else\n#endif\n    end = NULL;\n\n  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;\n  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;\n\n  overflow = 0;\n  i = 0;\n  for (c = *s; c != L_('\\0'); c = *++s)\n    {\n      if (s == end)\n        break;\n      if (c >= L_('0') && c <= L_('9'))\n        c -= L_('0');\n      else if (ISALPHA (c))\n        c = TOUPPER (c) - L_('A') + 10;\n      else\n        break;\n      if ((int) c >= base)\n        break;\n      /* Check for overflow.  */\n      if (i > cutoff || (i == cutoff && c > cutlim))\n        overflow = 1;\n      else\n        {\n          i *= (unsigned LONG int) base;\n          i += c;\n        }\n    }\n\n  /* Check if anything actually happened.  */\n  if (s == save)\n    goto noconv;\n\n  /* Store in ENDPTR the address of one character\n     past the last character we converted.  */\n  if (endptr != NULL)\n    *endptr = (STRING_TYPE *) s;\n\n#if !UNSIGNED\n  /* Check for a value that is within the range of\n     'unsigned LONG int', but outside the range of 'LONG int'.  */\n  if (overflow == 0\n      && i > (negative\n              ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1\n              : (unsigned LONG int) STRTOL_LONG_MAX))\n    overflow = 1;\n#endif\n\n  if (overflow)\n    {\n      __set_errno (ERANGE);\n#if UNSIGNED\n      return STRTOL_ULONG_MAX;\n#else\n      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;\n#endif\n    }\n\n  /* Return the result of the appropriate sign.  */\n  return negative ? -i : i;\n\nnoconv:\n  /* We must handle a special case here: the base is 0 or 16 and the\n     first two characters are '0' and 'x', but the rest are no\n     hexadecimal digits.  This is no error case.  We return 0 and\n     ENDPTR points to the 'x'.  */\n  if (endptr != NULL)\n    {\n      if (save - nptr >= 2 && TOUPPER (save[-1]) == L_('X')\n          && save[-2] == L_('0'))\n        *endptr = (STRING_TYPE *) &save[-1];\n      else\n        /*  There was no number to convert.  */\n        *endptr = (STRING_TYPE *) nptr;\n    }\n\n  return 0L;\n}",
      "lines": 184,
      "depth": 20,
      "decorators": [
        "INT"
      ]
    },
    "strtol": {
      "start_point": [
        415,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "weak_function\n#endif\nstrtol (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n        int base LOCALE_PARAM_PROTO)\n{\n  return INTERNAL (strtol) (nptr, endptr, base, 0 LOCALE_PARAM);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "weak_function",
        "#endif",
        "#endif"
      ]
    }
  },
  "tar/tar-1.30/gnu/strtoll.c": {},
  "tar/tar-1.30/gnu/strtoul.c": {},
  "tar/tar-1.30/gnu/strtoull.c": {},
  "tar/tar-1.30/gnu/strtoumax.c": {},
  "tar/tar-1.30/gnu/symlink.c": {
    "rpl_symlink": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nrpl_symlink (char const *contents, char const *name)\n{\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      struct stat st;\n      if (lstat (name, &st) == 0)\n        errno = EEXIST;\n      return -1;\n    }\n  return symlink (contents, name);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "symlink": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nsymlink (char const *contents _GL_UNUSED,\n         char const *name _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/symlinkat.c": {
    "rpl_symlinkat": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nrpl_symlinkat (char const *contents, int fd, char const *name)\n{\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      struct stat st;\n      if (fstatat (fd, name, &st, 0) == 0)\n        errno = EEXIST;\n      return -1;\n    }\n  return symlinkat (contents, fd, name);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "symlinkat": [
      {
        "start_point": [
          48,
          0
        ],
        "end_point": [
          54,
          1
        ],
        "content": "int\nsymlinkat (char const *path1 _GL_UNUSED, int fd _GL_UNUSED,\n           char const *path2 _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          93,
          1
        ],
        "content": "int\nsymlinkat (char const *contents, int fd, char const *file)\n{\n  return symlinkat_reversed (fd, file, contents);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "symlink_reversed": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nsymlink_reversed (char const *file, char const *contents)\n{\n  return symlink (contents, file);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/sysexits.in.h": {},
  "tar/tar-1.30/gnu/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/sys_time.in.h": {
    "GNULIB_NAMESPACE": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "namespace GNULIB_NAMESPACE {\n  typedef ::timeval\n#undef timeval\n    timeval;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": null
    }
  },
  "tar/tar-1.30/gnu/sys_types.in.h": {},
  "tar/tar-1.30/gnu/tempname.c": {
    "direxists": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\ndirexists (const char *dir)\n{\n  struct_stat64 buf;\n  return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__path_search": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\n__path_search (char *tmpl, size_t tmpl_len, const char *dir, const char *pfx,\n               int try_tmpdir)\n{\n  const char *d;\n  size_t dlen, plen;\n\n  if (!pfx || !pfx[0])\n    {\n      pfx = \"file\";\n      plen = 4;\n    }\n  else\n    {\n      plen = strlen (pfx);\n      if (plen > 5)\n        plen = 5;\n    }\n\n  if (try_tmpdir)\n    {\n      d = __secure_getenv (\"TMPDIR\");\n      if (d != NULL && direxists (d))\n        dir = d;\n      else if (dir != NULL && direxists (dir))\n        /* nothing */ ;\n      else\n        dir = NULL;\n    }\n  if (dir == NULL)\n    {\n      if (direxists (P_tmpdir))\n        dir = P_tmpdir;\n      else if (strcmp (P_tmpdir, \"/tmp\") != 0 && direxists (\"/tmp\"))\n        dir = \"/tmp\";\n      else\n        {\n          __set_errno (ENOENT);\n          return -1;\n        }\n    }\n\n  dlen = strlen (dir);\n  while (dlen > 1 && dir[dlen - 1] == '/')\n    dlen--;                     /* remove trailing slashes */\n\n  /* check we have room for \"${dir}/${pfx}XXXXXX\\0\" */\n  if (tmpl_len < dlen + 1 + plen + 6 + 1)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  sprintf (tmpl, \"%.*s/%.*sXXXXXX\", (int) dlen, dir, (int) plen, pfx);\n  return 0;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "__try_tempname": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "int\n__try_tempname (char *tmpl, int suffixlen, void *args,\n                int (*tryfunc) (char *, void *))\n{\n  int len;\n  char *XXXXXX;\n  static uint64_t value;\n  uint64_t random_time_bits;\n  unsigned int count;\n  int fd = -1;\n  int save_errno = errno;\n\n  /* A lower bound on the number of temporary files to attempt to\n     generate.  The maximum total number of temporary file names that\n     can exist for a given template is 62**6.  It should never be\n     necessary to try all of these combinations.  Instead if a reasonable\n     number of names is tried (we define reasonable as 62**3) fail to\n     give the system administrator the chance to remove the problems.  */\n#define ATTEMPTS_MIN (62 * 62 * 62)\n\n  /* The number of times to attempt to generate a temporary file.  To\n     conform to POSIX, this must be no smaller than TMP_MAX.  */\n#if ATTEMPTS_MIN < TMP_MAX\n  unsigned int attempts = TMP_MAX;\n#else\n  unsigned int attempts = ATTEMPTS_MIN;\n#endif\n\n  len = strlen (tmpl);\n  if (len < 6 + suffixlen || memcmp (&tmpl[len - 6 - suffixlen], \"XXXXXX\", 6))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* This is where the Xs start.  */\n  XXXXXX = &tmpl[len - 6 - suffixlen];\n\n  /* Get some more or less random data.  */\n#ifdef RANDOM_BITS\n  RANDOM_BITS (random_time_bits);\n#else\n  {\n    struct timeval tv;\n    __gettimeofday (&tv, NULL);\n    random_time_bits = ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec;\n  }\n#endif\n  value += random_time_bits ^ __getpid ();\n\n  for (count = 0; count < attempts; value += 7777, ++count)\n    {\n      uint64_t v = value;\n\n      /* Fill in the random bits.  */\n      XXXXXX[0] = letters[v % 62];\n      v /= 62;\n      XXXXXX[1] = letters[v % 62];\n      v /= 62;\n      XXXXXX[2] = letters[v % 62];\n      v /= 62;\n      XXXXXX[3] = letters[v % 62];\n      v /= 62;\n      XXXXXX[4] = letters[v % 62];\n      v /= 62;\n      XXXXXX[5] = letters[v % 62];\n\n      fd = tryfunc (tmpl, args);\n      if (fd >= 0)\n        {\n          __set_errno (save_errno);\n          return fd;\n        }\n      else if (errno != EEXIST)\n        return -1;\n    }\n\n  /* We got out of the loop because we ran out of combinations to try.  */\n  __set_errno (EEXIST);\n  return -1;\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "try_file": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static int\ntry_file (char *tmpl, void *flags)\n{\n  int *openflags = flags;\n  return __open (tmpl,\n                 (*openflags & ~O_ACCMODE)\n                 | O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_dir": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static int\ntry_dir (char *tmpl, void *flags _GL_UNUSED)\n{\n  return __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_nocreate": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static int\ntry_nocreate (char *tmpl, void *flags _GL_UNUSED)\n{\n  struct_stat64 st;\n\n  if (__lxstat64 (_STAT_VER, tmpl, &st) == 0 || errno == EOVERFLOW)\n    __set_errno (EEXIST);\n  return errno == ENOENT ? 0 : -1;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__gen_tempname": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\n__gen_tempname (char *tmpl, int suffixlen, int flags, int kind)\n{\n  int (*tryfunc) (char *, void *);\n\n  switch (kind)\n    {\n    case __GT_FILE:\n      tryfunc = try_file;\n      break;\n\n    case __GT_DIR:\n      tryfunc = try_dir;\n      break;\n\n    case __GT_NOCREATE:\n      tryfunc = try_nocreate;\n      break;\n\n    default:\n      assert (! \"invalid KIND in __gen_tempname\");\n      abort ();\n    }\n  return __try_tempname (tmpl, suffixlen, &flags, tryfunc);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/tempname.h": {},
  "tar/tar-1.30/gnu/time-internal.h": {},
  "tar/tar-1.30/gnu/time.in.h": {},
  "tar/tar-1.30/gnu/timegm.c": {
    "timegm": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "time_t\ntimegm (struct tm *tmp)\n{\n  static mktime_offset_t gmtime_offset;\n  tmp->tm_isdst = 0;\n  return __mktime_internal (tmp, __gmtime_r, &gmtime_offset);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "time_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/timespec-sub.c": {
    "timespec_sub": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "struct timespec\ntimespec_sub (struct timespec a, struct timespec b)\n{\n  time_t rs = a.tv_sec;\n  time_t bs = b.tv_sec;\n  int ns = a.tv_nsec - b.tv_nsec;\n  int rns = ns;\n  time_t tmin = TYPE_MINIMUM (time_t);\n  time_t tmax = TYPE_MAXIMUM (time_t);\n\n  if (ns < 0)\n    {\n      rns = ns + TIMESPEC_RESOLUTION;\n      if (bs < tmax)\n        bs++;\n      else if (- TYPE_SIGNED (time_t) < rs)\n        rs--;\n      else\n        goto low_overflow;\n    }\n\n  /* INT_SUBTRACT_WRAPV is not appropriate since time_t might be unsigned.\n     In theory time_t might be narrower than int, so plain\n     INT_SUBTRACT_OVERFLOW does not suffice.  */\n  if (! INT_SUBTRACT_OVERFLOW (rs, bs) && tmin <= rs - bs && rs - bs <= tmax)\n    rs -= bs;\n  else\n    {\n      if (rs < 0)\n        {\n        low_overflow:\n          rs = tmin;\n          rns = 0;\n        }\n      else\n        {\n          rs = tmax;\n          rns = TIMESPEC_RESOLUTION - 1;\n        }\n    }\n\n  return make_timespec (rs, rns);\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "struct timespec",
        "struct",
        "timespec"
      ]
    }
  },
  "tar/tar-1.30/gnu/timespec.c": {},
  "tar/tar-1.30/gnu/timespec.h": {
    "make_timespec": {
      "start_point": [
        45,
        27
      ],
      "end_point": [
        52,
        1
      ],
      "content": "timespec\nmake_timespec (time_t s, long int ns)\n{\n  struct timespec r;\n  r.tv_sec = s;\n  r.tv_nsec = ns;\n  return r;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "timespec"
      ]
    },
    "timespec_cmp": {
      "start_point": [
        80,
        24
      ],
      "end_point": [
        94,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\ntimespec_cmp (struct timespec a, struct timespec b)\n{\n  if (a.tv_sec < b.tv_sec)\n    return -1;\n  if (a.tv_sec > b.tv_sec)\n    return 1;\n\n  /* Pacify gcc -Wstrict-overflow (bleeding-edge circa 2017-10-02).  See:\n     http://lists.gnu.org/r/bug-gnulib/2017-10/msg00006.html  */\n  assume (-1 <= a.tv_nsec && a.tv_nsec <= 2 * TIMESPEC_RESOLUTION);\n  assume (-1 <= b.tv_nsec && b.tv_nsec <= 2 * TIMESPEC_RESOLUTION);\n\n  return a.tv_nsec - b.tv_nsec;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "timespec_sign": {
      "start_point": [
        98,
        24
      ],
      "end_point": [
        102,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\ntimespec_sign (struct timespec a)\n{\n  return a.tv_sec < 0 ? -1 : a.tv_sec || a.tv_nsec;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "timespectod": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "_GL_TIMESPEC_INLINE double\ntimespectod (struct timespec a)\n{\n  return a.tv_sec + a.tv_nsec / 1e9;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_TIMESPEC_INLINE",
        "double",
        "double"
      ]
    }
  },
  "tar/tar-1.30/gnu/time_r.c": {
    "copy_tm_result": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static struct tm *\ncopy_tm_result (struct tm *dest, struct tm const *src)\n{\n  if (! src)\n    return 0;\n  *dest = *src;\n  return dest;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\ncopy_tm_result (struct tm *dest, struct tm const *src)",
        "*"
      ]
    },
    "gmtime_r": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "struct tm *\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, gmtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    },
    "localtime_r": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "struct tm *\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, localtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/time_rz.c": {
    "isdst_differ": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static bool\nisdst_differ (int a, int b)\n{\n  return !a != !b && 0 <= a && 0 <= b;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "equal_tm": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static int\nequal_tm (const struct tm *a, const struct tm *b)\n{\n  return ! ((a->tm_sec ^ b->tm_sec)\n            | (a->tm_min ^ b->tm_min)\n            | (a->tm_hour ^ b->tm_hour)\n            | (a->tm_mday ^ b->tm_mday)\n            | (a->tm_mon ^ b->tm_mon)\n            | (a->tm_year ^ b->tm_year)\n            | isdst_differ (a->tm_isdst, b->tm_isdst));\n}",
      "lines": 11,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extend_abbrs": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\nextend_abbrs (char *abbrs, char const *abbr, size_t abbr_size)\n{\n  memcpy (abbrs, abbr, abbr_size);\n  abbrs[abbr_size] = '\\0';\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tzalloc": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "timezone_t\ntzalloc (char const *name)\n{\n  size_t name_size = name ? strlen (name) + 1 : 0;\n  size_t abbr_size = name_size < ABBR_SIZE_MIN ? ABBR_SIZE_MIN : name_size + 1;\n  timezone_t tz = malloc (FLEXSIZEOF (struct tm_zone, abbrs, abbr_size));\n  if (tz)\n    {\n      tz->next = NULL;\n#if HAVE_TZNAME && !HAVE_TM_ZONE\n      tz->tzname_copy[0] = tz->tzname_copy[1] = NULL;\n#endif\n      tz->tz_is_set = !!name;\n      tz->abbrs[0] = '\\0';\n      if (name)\n        extend_abbrs (tz->abbrs, name, name_size);\n    }\n  return tz;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "timezone_t"
      ]
    },
    "save_abbr": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static bool\nsave_abbr (timezone_t tz, struct tm *tm)\n{\n#if HAVE_TM_ZONE || HAVE_TZNAME\n  char const *zone = NULL;\n  char *zone_copy = (char *) \"\";\n\n# if HAVE_TZNAME\n  int tzname_index = -1;\n# endif\n\n# if HAVE_TM_ZONE\n  zone = tm->tm_zone;\n# endif\n\n# if HAVE_TZNAME\n  if (! (zone && *zone) && 0 <= tm->tm_isdst)\n    {\n      tzname_index = tm->tm_isdst != 0;\n      zone = tzname[tzname_index];\n    }\n# endif\n\n  /* No need to replace null zones, or zones within the struct tm.  */\n  if (!zone || ((char *) tm <= zone && zone < (char *) (tm + 1)))\n    return true;\n\n  if (*zone)\n    {\n      zone_copy = tz->abbrs;\n\n      while (strcmp (zone_copy, zone) != 0)\n        {\n          if (! (*zone_copy || (zone_copy == tz->abbrs && tz->tz_is_set)))\n            {\n              size_t zone_size = strlen (zone) + 1;\n              size_t zone_used = zone_copy - tz->abbrs;\n              if (SIZE_MAX - zone_used < zone_size)\n                {\n                  errno = ENOMEM;\n                  return false;\n                }\n              if (zone_used + zone_size < ABBR_SIZE_MIN)\n                extend_abbrs (zone_copy, zone, zone_size);\n              else\n                {\n                  tz = tz->next = tzalloc (zone);\n                  if (!tz)\n                    return false;\n                  tz->tz_is_set = 0;\n                  zone_copy = tz->abbrs;\n                }\n              break;\n            }\n\n          zone_copy += strlen (zone_copy) + 1;\n          if (!*zone_copy && tz->next)\n            {\n              tz = tz->next;\n              zone_copy = tz->abbrs;\n            }\n        }\n    }\n\n  /* Replace the zone name so that its lifetime matches that of TZ.  */\n# if HAVE_TM_ZONE\n  tm->tm_zone = zone_copy;\n# else\n  if (0 <= tzname_index)\n    tz->tzname_copy[tzname_index] = zone_copy;\n# endif\n#endif\n\n  return true;\n}",
      "lines": 75,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tzfree": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "void\ntzfree (timezone_t tz)\n{\n  if (tz != local_tz)\n    while (tz)\n      {\n        timezone_t next = tz->next;\n        free (tz);\n        tz = next;\n      }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "getenv_TZ": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "static char *\ngetenv_TZ (void)\n{\n  return getenv (\"TZ\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ngetenv_TZ (void)",
        "*"
      ]
    },
    "setenv_TZ": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "static int\nsetenv_TZ (char const *tz)\n{\n  return tz ? setenv (\"TZ\", tz, 1) : unsetenv (\"TZ\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "change_env": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static bool\nchange_env (timezone_t tz)\n{\n  if (setenv_TZ (tz->tz_is_set ? tz->abbrs : NULL) != 0)\n    return false;\n  tzset ();\n  return true;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "set_tz": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static timezone_t\nset_tz (timezone_t tz)\n{\n  char *env_tz = getenv_TZ ();\n  if (env_tz\n      ? tz->tz_is_set && strcmp (tz->abbrs, env_tz) == 0\n      : !tz->tz_is_set)\n    return local_tz;\n  else\n    {\n      timezone_t old_tz = tzalloc (env_tz);\n      if (!old_tz)\n        return old_tz;\n      if (! change_env (tz))\n        {\n          int saved_errno = errno;\n          tzfree (old_tz);\n          errno = saved_errno;\n          return NULL;\n        }\n      return old_tz;\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "timezone_t"
      ]
    },
    "revert_tz": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static bool\nrevert_tz (timezone_t tz)\n{\n  if (tz == local_tz)\n    return true;\n  else\n    {\n      int saved_errno = errno;\n      bool ok = change_env (tz);\n      if (!ok)\n        saved_errno = errno;\n      tzfree (tz);\n      errno = saved_errno;\n      return ok;\n    }\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "localtime_rz": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "struct tm *\nlocaltime_rz (timezone_t tz, time_t const *t, struct tm *tm)\n{\n  if (!tz)\n    return gmtime_r (t, tm);\n  else\n    {\n      timezone_t old_tz = set_tz (tz);\n      if (old_tz)\n        {\n          bool abbr_saved = localtime_r (t, tm) && save_abbr (tz, tm);\n          if (revert_tz (old_tz) && abbr_saved)\n            return tm;\n        }\n      return NULL;\n    }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nlocaltime_rz (timezone_t tz, time_t const *t, struct tm *tm)",
        "*"
      ]
    },
    "mktime_z": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "time_t\nmktime_z (timezone_t tz, struct tm *tm)\n{\n  if (!tz)\n    return timegm (tm);\n  else\n    {\n      timezone_t old_tz = set_tz (tz);\n      if (old_tz)\n        {\n          time_t t = mktime (tm);\n#if HAVE_TM_ZONE || HAVE_TZNAME\n          time_t badtime = -1;\n          struct tm tm_1;\n          if ((t != badtime\n               || (localtime_r (&t, &tm_1) && equal_tm (tm, &tm_1)))\n              && !save_abbr (tz, tm))\n            t = badtime;\n#endif\n          if (revert_tz (old_tz))\n            return t;\n        }\n      return -1;\n    }\n}",
      "lines": 25,
      "depth": 18,
      "decorators": [
        "time_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/tzset.c": {},
  "tar/tar-1.30/gnu/uinttostr.c": {},
  "tar/tar-1.30/gnu/umaxtostr.c": {},
  "tar/tar-1.30/gnu/unistd--.h": {},
  "tar/tar-1.30/gnu/unistd-safer.h": {},
  "tar/tar-1.30/gnu/unistd.c": {},
  "tar/tar-1.30/gnu/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        909,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/unitypes.in.h": {},
  "tar/tar-1.30/gnu/uniwidth.in.h": {},
  "tar/tar-1.30/gnu/unlink.c": {
    "rpl_unlink": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\nrpl_unlink (char const *name)\n{\n  /* Work around Solaris 9 bug where unlink(\"file/\") succeeds.  */\n  size_t len = strlen (name);\n  int result = 0;\n  if (len && ISSLASH (name[len - 1]))\n    {\n      /* We can't unlink(2) something if it doesn't exist.  If it does\n         exist, then it resolved to a directory, due to the trailing\n         slash, and POSIX requires that the unlink attempt to remove\n         that directory (which would leave the symlink dangling).\n         Unfortunately, Solaris 9 is one of the platforms where the\n         root user can unlink directories, and we don't want to\n         cripple this behavior on real directories, even if it is\n         seldom needed (at any rate, it's nicer to let coreutils'\n         unlink(1) give the correct errno for non-root users).  But we\n         don't know whether name was an actual directory, or a symlink\n         to a directory; and due to the bug of ignoring trailing\n         slash, Solaris 9 would end up successfully unlinking the\n         symlink instead of the directory.  Technically, we could use\n         realpath to find the canonical directory name to attempt\n         deletion on.  But that is a lot of work for a corner case; so\n         we instead just use an lstat on the shortened name, and\n         reject symlinks with trailing slashes.  The root user of\n         unlink(1) will just have to live with the rule that they\n         can't delete a directory via a symlink.  */\n      struct stat st;\n      result = lstat (name, &st);\n      if (result == 0)\n        {\n          /* Trailing NUL will overwrite the trailing slash.  */\n          char *short_name = malloc (len);\n          if (!short_name)\n            {\n              errno = EPERM;\n              return -1;\n            }\n          memcpy (short_name, name, len);\n          while (len && ISSLASH (short_name[len - 1]))\n            short_name[--len] = '\\0';\n          if (len && (lstat (short_name, &st) || S_ISLNK (st.st_mode)))\n            {\n              free (short_name);\n              errno = EPERM;\n              return -1;\n            }\n          free (short_name);\n        }\n    }\n  if (!result)\n    {\n#if UNLINK_PARENT_BUG\n      if (len >= 2 && name[len - 1] == '.' && name[len - 2] == '.'\n          && (len == 2 || ISSLASH (name[len - 3])))\n        {\n          errno = EISDIR; /* could also use EPERM */\n          return -1;\n        }\n#endif\n      result = unlink (name);\n    }\n  return result;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/unlinkat.c": {
    "rpl_unlinkat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\nrpl_unlinkat (int fd, char const *name, int flag)\n{\n  size_t len;\n  int result = 0;\n  /* rmdir behavior has no problems with trailing slash.  */\n  if (flag & AT_REMOVEDIR)\n    return unlinkat (fd, name, flag);\n\n  len = strlen (name);\n  if (len && ISSLASH (name[len - 1]))\n    {\n      /* See the lengthy comment in unlink.c why we disobey the POSIX\n         rule of letting unlink(\"link-to-dir/\") attempt to unlink a\n         directory.  */\n      struct stat st;\n      result = lstatat (fd, name, &st);\n      if (result == 0)\n        {\n          /* Trailing NUL will overwrite the trailing slash.  */\n          char *short_name = malloc (len);\n          if (!short_name)\n            {\n              errno = EPERM;\n              return -1;\n            }\n          memcpy (short_name, name, len);\n          while (len && ISSLASH (short_name[len - 1]))\n            short_name[--len] = '\\0';\n          if (len && (lstatat (fd, short_name, &st) || S_ISLNK (st.st_mode)))\n            {\n              free (short_name);\n              errno = EPERM;\n              return -1;\n            }\n          free (short_name);\n        }\n    }\n  if (!result)\n    {\n# if UNLINK_PARENT_BUG\n      if (len >= 2 && name[len - 1] == '.' && name[len - 2] == '.'\n          && (len == 2 || ISSLASH (name[len - 3])))\n        {\n          errno = EISDIR; /* could also use EPERM */\n          return -1;\n        }\n# endif\n      result = unlinkat (fd, name, flag);\n    }\n  return result;\n}",
      "lines": 52,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/unlinkdir.c": {
    "cannot_unlink_dir": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "bool\ncannot_unlink_dir (void)\n{\n  static bool initialized;\n  static bool cannot;\n\n  if (! initialized)\n    {\n# if defined PRIV_SYS_LINKDIR\n      /* We might be able to unlink directories if we cannot\n         determine our privileges, or if we have the\n         PRIV_SYS_LINKDIR privilege.  */\n      cannot = (priv_set_ismember (PRIV_SYS_LINKDIR) == 0);\n# else\n      /* In traditional Unix, only root can unlink directories.  */\n      cannot = (geteuid () != ROOT_UID);\n# endif\n      initialized = true;\n    }\n\n  return cannot;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    }
  },
  "tar/tar-1.30/gnu/unlinkdir.h": {},
  "tar/tar-1.30/gnu/unlocked-io.h": {},
  "tar/tar-1.30/gnu/unsetenv.c": {
    "unsetenv": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nunsetenv (const char *name)\n{\n  size_t len;\n  char **ep;\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n  LOCK;\n\n  ep = __environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rpl_unsetenv": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nrpl_unsetenv (const char *name)\n{\n  int result = 0;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  while (getenv (name))\n# if !VOID_UNSETENV\n    result =\n# endif\n      unsetenv (name);\n  return result;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/unused-parameter.h": {},
  "tar/tar-1.30/gnu/utime.c": {
    "_gl_utimens_windows": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "int\n_gl_utimens_windows (const char *name, struct timespec ts[2])\n{\n  /* POSIX <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>\n     specifies: \"More than two leading <slash> characters shall be treated as\n     a single <slash> character.\"  */\n  if (ISSLASH (name[0]) && ISSLASH (name[1]) && ISSLASH (name[2]))\n    {\n      name += 2;\n      while (ISSLASH (name[1]))\n        name++;\n    }\n\n  size_t len = strlen (name);\n  size_t drive_prefix_len = (HAS_DEVICE (name) ? 2 : 0);\n\n  /* Remove trailing slashes (except the very first one, at position\n     drive_prefix_len), but remember their presence.  */\n  size_t rlen;\n  bool check_dir = false;\n\n  rlen = len;\n  while (rlen > drive_prefix_len && ISSLASH (name[rlen-1]))\n    {\n      check_dir = true;\n      if (rlen == drive_prefix_len + 1)\n        break;\n      rlen--;\n    }\n\n  const char *rname;\n  char *malloca_rname;\n  if (rlen == len)\n    {\n      rname = name;\n      malloca_rname = NULL;\n    }\n  else\n    {\n      malloca_rname = malloca (rlen + 1);\n      if (malloca_rname == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      memcpy (malloca_rname, name, rlen);\n      malloca_rname[rlen] = '\\0';\n      rname = malloca_rname;\n    }\n\n  DWORD error;\n\n  /* Open a handle to the file.\n     CreateFile\n     <https://msdn.microsoft.com/en-us/library/aa363858.aspx>\n     <https://msdn.microsoft.com/en-us/library/aa363874.aspx>  */\n  HANDLE handle =\n    CreateFile (rname,\n                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,\n                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                NULL,\n                OPEN_EXISTING,\n                /* FILE_FLAG_POSIX_SEMANTICS (treat file names that differ only\n                   in case as different) makes sense only when applied to *all*\n                   filesystem operations.  */\n                FILE_FLAG_BACKUP_SEMANTICS /* | FILE_FLAG_POSIX_SEMANTICS */,\n                NULL);\n  if (handle == INVALID_HANDLE_VALUE)\n    {\n      error = GetLastError ();\n      goto failed;\n    }\n\n  if (check_dir)\n    {\n      /* GetFileAttributes\n         <https://msdn.microsoft.com/en-us/library/aa364944.aspx>  */\n      DWORD attributes = GetFileAttributes (rname);\n      if (attributes == INVALID_FILE_ATTRIBUTES)\n        {\n          error = GetLastError ();\n          CloseHandle (handle);\n          goto failed;\n        }\n      if ((attributes & FILE_ATTRIBUTE_DIRECTORY) == 0)\n        {\n          CloseHandle (handle);\n          if (malloca_rname != NULL)\n            freea (malloca_rname);\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n\n  {\n    /* Use SetFileTime(). See\n       <https://msdn.microsoft.com/en-us/library/ms724933.aspx>\n       <https://msdn.microsoft.com/en-us/library/ms724284.aspx>  */\n    FILETIME last_access_time;\n    FILETIME last_write_time;\n    if (ts == NULL)\n      {\n        /* GetSystemTimeAsFileTime is the same as\n           GetSystemTime followed by SystemTimeToFileTime.\n           <https://msdn.microsoft.com/en-us/library/ms724397.aspx>.\n           It would be overkill to use\n           GetSystemTimePreciseAsFileTime\n           <https://msdn.microsoft.com/en-us/library/hh706895.aspx>.  */\n        FILETIME current_time;\n        GetSystemTimeAsFileTime (&current_time);\n        last_access_time = current_time;\n        last_write_time = current_time;\n      }\n    else\n      {\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[0].tv_sec * 10000000 + ts[0].tv_nsec / 100 + 116444736000000000LL;\n          last_access_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_access_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[1].tv_sec * 10000000 + ts[1].tv_nsec / 100 + 116444736000000000LL;\n          last_write_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_write_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n      }\n    if (SetFileTime (handle, NULL, &last_access_time, &last_write_time))\n      {\n        CloseHandle (handle);\n        if (malloca_rname != NULL)\n          freea (malloca_rname);\n        return 0;\n      }\n    else\n      {\n        #if 0\n        DWORD sft_error = GetLastError ();\n        fprintf (stderr, \"utimens SetFileTime error 0x%x\\n\", (unsigned int) sft_error);\n        #endif\n        CloseHandle (handle);\n        if (malloca_rname != NULL)\n          freea (malloca_rname);\n        errno = EINVAL;\n        return -1;\n      }\n  }\n\n failed:\n  {\n    #if 0\n    fprintf (stderr, \"utimens CreateFile/GetFileAttributes error 0x%x\\n\", (unsigned int) error);\n    #endif\n    if (malloca_rname != NULL)\n      freea (malloca_rname);\n\n    switch (error)\n      {\n      /* Some of these errors probably cannot happen with the specific flags\n         that we pass to CreateFile.  But who knows...  */\n      case ERROR_FILE_NOT_FOUND: /* The last component of rname does not exist.  */\n      case ERROR_PATH_NOT_FOUND: /* Some directory component in rname does not exist.  */\n      case ERROR_BAD_PATHNAME:   /* rname is such as '\\\\server'.  */\n      case ERROR_BAD_NETPATH:    /* rname is such as '\\\\nonexistentserver\\share'.  */\n      case ERROR_BAD_NET_NAME:   /* rname is such as '\\\\server\\nonexistentshare'.  */\n      case ERROR_INVALID_NAME:   /* rname contains wildcards, misplaced colon, etc.  */\n      case ERROR_DIRECTORY:\n        errno = ENOENT;\n        break;\n\n      case ERROR_ACCESS_DENIED:  /* rname is such as 'C:\\System Volume Information\\foo'.  */\n      case ERROR_SHARING_VIOLATION: /* rname is such as 'C:\\pagefile.sys'.  */\n        errno = (ts != NULL ? EPERM : EACCES);\n        break;\n\n      case ERROR_OUTOFMEMORY:\n        errno = ENOMEM;\n        break;\n\n      case ERROR_WRITE_PROTECT:\n        errno = EROFS;\n        break;\n\n      case ERROR_WRITE_FAULT:\n      case ERROR_READ_FAULT:\n      case ERROR_GEN_FAILURE:\n        errno = EIO;\n        break;\n\n      case ERROR_BUFFER_OVERFLOW:\n      case ERROR_FILENAME_EXCED_RANGE:\n        errno = ENAMETOOLONG;\n        break;\n\n      case ERROR_DELETE_PENDING: /* XXX map to EACCESS or EPERM? */\n        errno = EPERM;\n        break;\n\n      default:\n        errno = EINVAL;\n        break;\n      }\n\n    return -1;\n  }\n}",
      "lines": 207,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "utime": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "int\nutime (const char *name, const struct utimbuf *ts)\n{\n  if (ts == NULL)\n    return _gl_utimens_windows (name, NULL);\n  else\n    {\n      struct timespec ts_with_nanoseconds[2];\n      ts_with_nanoseconds[0].tv_sec = ts->actime;\n      ts_with_nanoseconds[0].tv_nsec = 0;\n      ts_with_nanoseconds[1].tv_sec = ts->modtime;\n      ts_with_nanoseconds[1].tv_nsec = 0;\n      return _gl_utimens_windows (name, ts_with_nanoseconds);\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/utime.in.h": {},
  "tar/tar-1.30/gnu/utimens.c": {
    "validate_timespec": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static int\nvalidate_timespec (struct timespec timespec[2])\n{\n  int result = 0;\n  int utime_omit_count = 0;\n  if ((timespec[0].tv_nsec != UTIME_NOW\n       && timespec[0].tv_nsec != UTIME_OMIT\n       && ! (0 <= timespec[0].tv_nsec\n             && timespec[0].tv_nsec < TIMESPEC_RESOLUTION))\n      || (timespec[1].tv_nsec != UTIME_NOW\n          && timespec[1].tv_nsec != UTIME_OMIT\n          && ! (0 <= timespec[1].tv_nsec\n                && timespec[1].tv_nsec < TIMESPEC_RESOLUTION)))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Work around Linux kernel 2.6.25 bug, where utimensat fails with\n     EINVAL if tv_sec is not 0 when using the flag values of tv_nsec.\n     Flag a Linux kernel 2.6.32 bug, where an mtime of UTIME_OMIT\n     fails to bump ctime.  */\n  if (timespec[0].tv_nsec == UTIME_NOW\n      || timespec[0].tv_nsec == UTIME_OMIT)\n    {\n      timespec[0].tv_sec = 0;\n      result = 1;\n      if (timespec[0].tv_nsec == UTIME_OMIT)\n        utime_omit_count++;\n    }\n  if (timespec[1].tv_nsec == UTIME_NOW\n      || timespec[1].tv_nsec == UTIME_OMIT)\n    {\n      timespec[1].tv_sec = 0;\n      result = 1;\n      if (timespec[1].tv_nsec == UTIME_OMIT)\n        utime_omit_count++;\n    }\n  return result + (utime_omit_count == 1);\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "update_timespec": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static bool\nupdate_timespec (struct stat const *statbuf, struct timespec *ts[2])\n{\n  struct timespec *timespec = *ts;\n  if (timespec[0].tv_nsec == UTIME_OMIT\n      && timespec[1].tv_nsec == UTIME_OMIT)\n    return true;\n  if (timespec[0].tv_nsec == UTIME_NOW\n      && timespec[1].tv_nsec == UTIME_NOW)\n    {\n      *ts = NULL;\n      return false;\n    }\n\n  if (timespec[0].tv_nsec == UTIME_OMIT)\n    timespec[0] = get_stat_atime (statbuf);\n  else if (timespec[0].tv_nsec == UTIME_NOW)\n    gettime (&timespec[0]);\n\n  if (timespec[1].tv_nsec == UTIME_OMIT)\n    timespec[1] = get_stat_mtime (statbuf);\n  else if (timespec[1].tv_nsec == UTIME_NOW)\n    gettime (&timespec[1]);\n\n  return false;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "fdutimens": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "int\nfdutimens (int fd, char const *file, struct timespec const timespec[2])\n{\n  struct timespec adjusted_timespec[2];\n  struct timespec *ts = timespec ? adjusted_timespec : NULL;\n  int adjustment_needed = 0;\n  struct stat st;\n\n  if (ts)\n    {\n      adjusted_timespec[0] = timespec[0];\n      adjusted_timespec[1] = timespec[1];\n      adjustment_needed = validate_timespec (ts);\n    }\n  if (adjustment_needed < 0)\n    return -1;\n\n  /* Require that at least one of FD or FILE are potentially valid, to avoid\n     a Linux bug where futimens (AT_FDCWD, NULL) changes \".\" rather\n     than failing.  */\n  if (fd < 0 && !file)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  /* Some Linux-based NFS clients are buggy, and mishandle timestamps\n     of files in NFS file systems in some cases.  We have no\n     configure-time test for this, but please see\n     <https://bugs.gentoo.org/show_bug.cgi?id=132673> for references to\n     some of the problems with Linux 2.6.16.  If this affects you,\n     compile with -DHAVE_BUGGY_NFS_TIME_STAMPS; this is reported to\n     help in some cases, albeit at a cost in performance.  But you\n     really should upgrade your kernel to a fixed version, since the\n     problem affects many applications.  */\n\n#if HAVE_BUGGY_NFS_TIME_STAMPS\n  if (fd < 0)\n    sync ();\n  else\n    fsync (fd);\n#endif\n\n  /* POSIX 2008 added two interfaces to set file timestamps with\n     nanosecond resolution; newer Linux implements both functions via\n     a single syscall.  We provide a fallback for ENOSYS (for example,\n     compiling against Linux 2.6.25 kernel headers and glibc 2.7, but\n     running on Linux 2.6.18 kernel).  */\n#if HAVE_UTIMENSAT || HAVE_FUTIMENS\n  if (0 <= utimensat_works_really)\n    {\n      int result;\n# if __linux__ || __sun\n      /* As recently as Linux kernel 2.6.32 (Dec 2009), several file\n         systems (xfs, ntfs-3g) have bugs with a single UTIME_OMIT,\n         but work if both times are either explicitly specified or\n         UTIME_NOW.  Work around it with a preparatory [f]stat prior\n         to calling futimens/utimensat; fortunately, there is not much\n         timing impact due to the extra syscall even on file systems\n         where UTIME_OMIT would have worked.\n\n         The same bug occurs in Solaris 11.1 (Apr 2013).\n\n         FIXME: Simplify this for Linux in 2016 and for Solaris in\n         2024, when file system bugs are no longer common.  */\n      if (adjustment_needed == 2)\n        {\n          if (fd < 0 ? stat (file, &st) : fstat (fd, &st))\n            return -1;\n          if (ts[0].tv_nsec == UTIME_OMIT)\n            ts[0] = get_stat_atime (&st);\n          else if (ts[1].tv_nsec == UTIME_OMIT)\n            ts[1] = get_stat_mtime (&st);\n          /* Note that st is good, in case utimensat gives ENOSYS.  */\n          adjustment_needed++;\n        }\n# endif\n# if HAVE_UTIMENSAT\n      if (fd < 0)\n        {\n          result = utimensat (AT_FDCWD, file, ts, 0);\n#  ifdef __linux__\n          /* Work around a kernel bug:\n             https://bugzilla.redhat.com/show_bug.cgi?id=442352\n             https://bugzilla.redhat.com/show_bug.cgi?id=449910\n             It appears that utimensat can mistakenly return 280 rather\n             than -1 upon ENOSYS failure.\n             FIXME: remove in 2010 or whenever the offending kernels\n             are no longer in common use.  */\n          if (0 < result)\n            errno = ENOSYS;\n#  endif /* __linux__ */\n          if (result == 0 || errno != ENOSYS)\n            {\n              utimensat_works_really = 1;\n              return result;\n            }\n        }\n# endif /* HAVE_UTIMENSAT */\n# if HAVE_FUTIMENS\n      if (0 <= fd)\n        {\n          result = futimens (fd, ts);\n#  ifdef __linux__\n          /* Work around the same bug as above.  */\n          if (0 < result)\n            errno = ENOSYS;\n#  endif /* __linux__ */\n          if (result == 0 || errno != ENOSYS)\n            {\n              utimensat_works_really = 1;\n              return result;\n            }\n        }\n# endif /* HAVE_FUTIMENS */\n    }\n  utimensat_works_really = -1;\n  lutimensat_works_really = -1;\n#endif /* HAVE_UTIMENSAT || HAVE_FUTIMENS */\n\n#ifdef USE_SETFILETIME\n  /* On native Windows, use SetFileTime(). See\n     <https://msdn.microsoft.com/en-us/library/ms724933.aspx>\n     <https://msdn.microsoft.com/en-us/library/ms724284.aspx>  */\n  if (0 <= fd)\n    {\n      HANDLE handle;\n      FILETIME current_time;\n      FILETIME last_access_time;\n      FILETIME last_write_time;\n\n      handle = (HANDLE) _get_osfhandle (fd);\n      if (handle == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n\n      if (ts == NULL || ts[0].tv_nsec == UTIME_NOW || ts[1].tv_nsec == UTIME_NOW)\n        {\n          /* GetSystemTimeAsFileTime\n             <https://msdn.microsoft.com/en-us/library/ms724397.aspx>.\n             It would be overkill to use\n             GetSystemTimePreciseAsFileTime\n             <https://msdn.microsoft.com/en-us/library/hh706895.aspx>.  */\n          GetSystemTimeAsFileTime (&current_time);\n        }\n\n      if (ts == NULL || ts[0].tv_nsec == UTIME_NOW)\n        {\n          last_access_time = current_time;\n        }\n      else if (ts[0].tv_nsec == UTIME_OMIT)\n        {\n          last_access_time.dwLowDateTime = 0;\n          last_access_time.dwHighDateTime = 0;\n        }\n      else\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[0].tv_sec * 10000000 + ts[0].tv_nsec / 100 + 116444736000000000LL;\n          last_access_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_access_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n\n      if (ts == NULL || ts[1].tv_nsec == UTIME_NOW)\n        {\n          last_write_time = current_time;\n        }\n      else if (ts[1].tv_nsec == UTIME_OMIT)\n        {\n          last_write_time.dwLowDateTime = 0;\n          last_write_time.dwHighDateTime = 0;\n        }\n      else\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[1].tv_sec * 10000000 + ts[1].tv_nsec / 100 + 116444736000000000LL;\n          last_write_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_write_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n\n      if (SetFileTime (handle, NULL, &last_access_time, &last_write_time))\n        return 0;\n      else\n        {\n          DWORD sft_error = GetLastError ();\n          #if 0\n          fprintf (stderr, \"fdutimens SetFileTime error 0x%x\\n\", (unsigned int) sft_error);\n          #endif\n          switch (sft_error)\n            {\n            case ERROR_ACCESS_DENIED: /* fd was opened without O_RDWR */\n              errno = EACCES; /* not specified by POSIX */\n              break;\n            default:\n              errno = EINVAL;\n              break;\n            }\n          return -1;\n        }\n    }\n#endif\n\n  /* The platform lacks an interface to set file timestamps with\n     nanosecond resolution, so do the best we can, discarding any\n     fractional part of the timestamp.  */\n\n  if (adjustment_needed || (REPLACE_FUNC_STAT_FILE && fd < 0))\n    {\n      if (adjustment_needed != 3\n          && (fd < 0 ? stat (file, &st) : fstat (fd, &st)))\n        return -1;\n      if (ts && update_timespec (&st, &ts))\n        return 0;\n    }\n\n  {\n#if HAVE_FUTIMESAT || HAVE_WORKING_UTIMES\n    struct timeval timeval[2];\n    struct timeval *t;\n    if (ts)\n      {\n        timeval[0].tv_sec = ts[0].tv_sec;\n        timeval[0].tv_usec = ts[0].tv_nsec / 1000;\n        timeval[1].tv_sec = ts[1].tv_sec;\n        timeval[1].tv_usec = ts[1].tv_nsec / 1000;\n        t = timeval;\n      }\n    else\n      t = NULL;\n\n    if (fd < 0)\n      {\n# if HAVE_FUTIMESAT\n        return futimesat (AT_FDCWD, file, t);\n# endif\n      }\n    else\n      {\n        /* If futimesat or futimes fails here, don't try to speed things\n           up by returning right away.  glibc can incorrectly fail with\n           errno == ENOENT if /proc isn't mounted.  Also, Mandrake 10.0\n           in high security mode doesn't allow ordinary users to read\n           /proc/self, so glibc incorrectly fails with errno == EACCES.\n           If errno == EIO, EPERM, or EROFS, it's probably safe to fail\n           right away, but these cases are rare enough that they're not\n           worth optimizing, and who knows what other messed-up systems\n           are out there?  So play it safe and fall back on the code\n           below.  */\n\n# if (HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG) || HAVE_FUTIMES\n#  if HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG\n#   undef futimes\n#   define futimes(fd, t) futimesat (fd, NULL, t)\n#  endif\n        if (futimes (fd, t) == 0)\n          {\n#  if __linux__ && __GLIBC__\n            /* Work around a longstanding glibc bug, still present as\n               of 2010-12-27.  On older Linux kernels that lack both\n               utimensat and utimes, glibc's futimes rounds instead of\n               truncating when falling back on utime.  The same bug\n               occurs in futimesat with a null 2nd arg.  */\n            if (t)\n              {\n                bool abig = 500000 <= t[0].tv_usec;\n                bool mbig = 500000 <= t[1].tv_usec;\n                if ((abig | mbig) && fstat (fd, &st) == 0)\n                  {\n                    /* If these two subtractions overflow, they'll\n                       track the overflows inside the buggy glibc.  */\n                    time_t adiff = st.st_atime - t[0].tv_sec;\n                    time_t mdiff = st.st_mtime - t[1].tv_sec;\n\n                    struct timeval *tt = NULL;\n                    struct timeval truncated_timeval[2];\n                    truncated_timeval[0] = t[0];\n                    truncated_timeval[1] = t[1];\n                    if (abig && adiff == 1 && get_stat_atime_ns (&st) == 0)\n                      {\n                        tt = truncated_timeval;\n                        tt[0].tv_usec = 0;\n                      }\n                    if (mbig && mdiff == 1 && get_stat_mtime_ns (&st) == 0)\n                      {\n                        tt = truncated_timeval;\n                        tt[1].tv_usec = 0;\n                      }\n                    if (tt)\n                      futimes (fd, tt);\n                  }\n              }\n#  endif\n\n            return 0;\n          }\n# endif\n      }\n#endif /* HAVE_FUTIMESAT || HAVE_WORKING_UTIMES */\n\n    if (!file)\n      {\n#if ! ((HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG)          \\\n        || (HAVE_WORKING_UTIMES && HAVE_FUTIMES))\n        errno = ENOSYS;\n#endif\n        return -1;\n      }\n\n#ifdef USE_SETFILETIME\n    return _gl_utimens_windows (file, ts);\n#elif HAVE_WORKING_UTIMES\n    return utimes (file, t);\n#else\n    {\n      struct utimbuf utimbuf;\n      struct utimbuf *ut;\n      if (ts)\n        {\n          utimbuf.actime = ts[0].tv_sec;\n          utimbuf.modtime = ts[1].tv_sec;\n          ut = &utimbuf;\n        }\n      else\n        ut = NULL;\n\n      return utime (file, ut);\n    }\n#endif /* !HAVE_WORKING_UTIMES */\n  }\n}",
      "lines": 332,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "utimens": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        508,
        1
      ],
      "content": "int\nutimens (char const *file, struct timespec const timespec[2])\n{\n  return fdutimens (-1, file, timespec);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lutimens": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "int\nlutimens (char const *file, struct timespec const timespec[2])\n{\n  struct timespec adjusted_timespec[2];\n  struct timespec *ts = timespec ? adjusted_timespec : NULL;\n  int adjustment_needed = 0;\n  struct stat st;\n\n  if (ts)\n    {\n      adjusted_timespec[0] = timespec[0];\n      adjusted_timespec[1] = timespec[1];\n      adjustment_needed = validate_timespec (ts);\n    }\n  if (adjustment_needed < 0)\n    return -1;\n\n  /* The Linux kernel did not support symlink timestamps until\n     utimensat, in version 2.6.22, so we don't need to mimic\n     fdutimens' worry about buggy NFS clients.  But we do have to\n     worry about bogus return values.  */\n\n#if HAVE_UTIMENSAT\n  if (0 <= lutimensat_works_really)\n    {\n      int result;\n# if __linux__ || __sun\n      /* As recently as Linux kernel 2.6.32 (Dec 2009), several file\n         systems (xfs, ntfs-3g) have bugs with a single UTIME_OMIT,\n         but work if both times are either explicitly specified or\n         UTIME_NOW.  Work around it with a preparatory lstat prior to\n         calling utimensat; fortunately, there is not much timing\n         impact due to the extra syscall even on file systems where\n         UTIME_OMIT would have worked.\n\n         The same bug occurs in Solaris 11.1 (Apr 2013).\n\n         FIXME: Simplify this for Linux in 2016 and for Solaris in\n         2024, when file system bugs are no longer common.  */\n      if (adjustment_needed == 2)\n        {\n          if (lstat (file, &st))\n            return -1;\n          if (ts[0].tv_nsec == UTIME_OMIT)\n            ts[0] = get_stat_atime (&st);\n          else if (ts[1].tv_nsec == UTIME_OMIT)\n            ts[1] = get_stat_mtime (&st);\n          /* Note that st is good, in case utimensat gives ENOSYS.  */\n          adjustment_needed++;\n        }\n# endif\n      result = utimensat (AT_FDCWD, file, ts, AT_SYMLINK_NOFOLLOW);\n# ifdef __linux__\n      /* Work around a kernel bug:\n         https://bugzilla.redhat.com/show_bug.cgi?id=442352\n         https://bugzilla.redhat.com/show_bug.cgi?id=449910\n         It appears that utimensat can mistakenly return 280 rather\n         than -1 upon ENOSYS failure.\n         FIXME: remove in 2010 or whenever the offending kernels\n         are no longer in common use.  */\n      if (0 < result)\n        errno = ENOSYS;\n# endif\n      if (result == 0 || errno != ENOSYS)\n        {\n          utimensat_works_really = 1;\n          lutimensat_works_really = 1;\n          return result;\n        }\n    }\n  lutimensat_works_really = -1;\n#endif /* HAVE_UTIMENSAT */\n\n  /* The platform lacks an interface to set file timestamps with\n     nanosecond resolution, so do the best we can, discarding any\n     fractional part of the timestamp.  */\n\n  if (adjustment_needed || REPLACE_FUNC_STAT_FILE)\n    {\n      if (adjustment_needed != 3 && lstat (file, &st))\n        return -1;\n      if (ts && update_timespec (&st, &ts))\n        return 0;\n    }\n\n  /* On Linux, lutimes is a thin wrapper around utimensat, so there is\n     no point trying lutimes if utimensat failed with ENOSYS.  */\n#if HAVE_LUTIMES && !HAVE_UTIMENSAT\n  {\n    struct timeval timeval[2];\n    struct timeval *t;\n    int result;\n    if (ts)\n      {\n        timeval[0].tv_sec = ts[0].tv_sec;\n        timeval[0].tv_usec = ts[0].tv_nsec / 1000;\n        timeval[1].tv_sec = ts[1].tv_sec;\n        timeval[1].tv_usec = ts[1].tv_nsec / 1000;\n        t = timeval;\n      }\n    else\n      t = NULL;\n\n    result = lutimes (file, t);\n    if (result == 0 || errno != ENOSYS)\n      return result;\n  }\n#endif /* HAVE_LUTIMES && !HAVE_UTIMENSAT */\n\n  /* Out of luck for symlinks, but we still handle regular files.  */\n  if (!(adjustment_needed || REPLACE_FUNC_STAT_FILE) && lstat (file, &st))\n    return -1;\n  if (!S_ISLNK (st.st_mode))\n    return fdutimens (-1, file, ts);\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 117,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/utimens.h": {
    "lutimensat": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "_GL_UTIMENS_INLINE int\nlutimensat (int dir, char const *file, struct timespec const times[2])\n{\n  return utimensat (dir, file, times, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UTIMENS_INLINE",
        "int",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/utimensat.c": {
    "rpl_utimensat": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\nrpl_utimensat (int fd, char const *file, struct timespec const times[2],\n               int flag)\n{\n# if defined __linux__ || defined __sun\n  struct timespec ts[2];\n# endif\n\n  /* See comments in utimens.c for details.  */\n  static int utimensat_works_really; /* 0 = unknown, 1 = yes, -1 = no.  */\n  if (0 <= utimensat_works_really)\n    {\n      int result;\n# if defined __linux__ || defined __sun\n      struct stat st;\n      /* As recently as Linux kernel 2.6.32 (Dec 2009), several file\n         systems (xfs, ntfs-3g) have bugs with a single UTIME_OMIT,\n         but work if both times are either explicitly specified or\n         UTIME_NOW.  Work around it with a preparatory [l]stat prior\n         to calling utimensat; fortunately, there is not much timing\n         impact due to the extra syscall even on file systems where\n         UTIME_OMIT would have worked.\n\n         The same bug occurs in Solaris 11.1 (Apr 2013).\n\n         FIXME: Simplify this in 2024, when these file system bugs are\n         no longer common on Gnulib target platforms.  */\n      if (times && (times[0].tv_nsec == UTIME_OMIT\n                    || times[1].tv_nsec == UTIME_OMIT))\n        {\n          if (fstatat (fd, file, &st, flag))\n            return -1;\n          if (times[0].tv_nsec == UTIME_OMIT && times[1].tv_nsec == UTIME_OMIT)\n            return 0;\n          if (times[0].tv_nsec == UTIME_OMIT)\n            ts[0] = get_stat_atime (&st);\n          else\n            ts[0] = times[0];\n          if (times[1].tv_nsec == UTIME_OMIT)\n            ts[1] = get_stat_mtime (&st);\n          else\n            ts[1] = times[1];\n          times = ts;\n        }\n#  ifdef __hppa__\n      /* Linux kernel 2.6.22.19 on hppa does not reject invalid tv_nsec\n         values.  */\n      else if (times\n               && ((times[0].tv_nsec != UTIME_NOW\n                    && ! (0 <= times[0].tv_nsec\n                          && times[0].tv_nsec < TIMESPEC_RESOLUTION))\n                   || (times[1].tv_nsec != UTIME_NOW\n                       && ! (0 <= times[1].tv_nsec\n                             && times[1].tv_nsec < TIMESPEC_RESOLUTION))))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n#  endif\n# endif\n      result = utimensat (fd, file, times, flag);\n      /* Linux kernel 2.6.25 has a bug where it returns EINVAL for\n         UTIME_NOW or UTIME_OMIT with non-zero tv_sec, which\n         local_utimensat works around.  Meanwhile, EINVAL for a bad\n         flag is indeterminate whether the native utimensat works, but\n         local_utimensat will also reject it.  */\n      if (result == -1 && errno == EINVAL && (flag & ~AT_SYMLINK_NOFOLLOW))\n        return result;\n      if (result == 0 || (errno != ENOSYS && errno != EINVAL))\n        {\n          utimensat_works_really = 1;\n          return result;\n        }\n    }\n  /* No point in trying openat/futimens, since on Linux, futimens is\n     implemented with the same syscall as utimensat.  Only avoid the\n     native utimensat due to an ENOSYS failure; an EINVAL error was\n     data-dependent, and the next caller may pass valid data.  */\n  if (0 <= utimensat_works_really && errno == ENOSYS)\n    utimensat_works_really = -1;\n  return local_utimensat (fd, file, times, flag);\n}",
      "lines": 82,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and Mac OS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        847,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        901,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        909,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        997,
        0
      ],
      "end_point": [
        1072,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1081,
        0
      ],
      "end_point": [
        1294,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1303,
        0
      ],
      "end_point": [
        1310,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1321,
        0
      ],
      "end_point": [
        1328,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1337,
        0
      ],
      "end_point": [
        1419,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1510,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1516,
        0
      ],
      "end_point": [
        1526,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1543,
        0
      ],
      "end_point": [
        1778,
        1
      ],
      "content": "static size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4625,
        16
      ],
      "end_point": [
        5554,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 930,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = -width;",
        "width = -width",
        "width",
        "=",
        "-width",
        "-",
        "width",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "#endif",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "# endif",
        "#endif",
        "FALLTHROUGH;",
        "FALLTHROUGH",
        ";",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "(defined __APPLE__ && defined __MACH__)",
        "(",
        "defined __APPLE__ && defined __MACH__",
        "defined __APPLE__",
        "defined",
        "__APPLE__",
        "&&",
        "defined __MACH__",
        "defined",
        "__MACH__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "if",
        "(saved_errno == 0)",
        "(",
        "saved_errno == 0",
        "saved_errno",
        "==",
        "0",
        ")",
        "{\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "{",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "saved_errno = EILSEQ;",
        "saved_errno = EILSEQ",
        "saved_errno",
        "=",
        "EILSEQ",
        ";",
        "else",
        "saved_errno = EINVAL;",
        "saved_errno = EINVAL",
        "saved_errno",
        "=",
        "EINVAL",
        ";",
        "}",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "tar/tar-1.30/gnu/vasnprintf.h": {},
  "tar/tar-1.30/gnu/vasprintf.c": {
    "vasprintf": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nvasprintf (char **resultp, const char *format, va_list args)\n{\n  size_t length;\n  char *result = vasnprintf (NULL, &length, format, args);\n  if (result == NULL)\n    return -1;\n\n  if (length > INT_MAX)\n    {\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  *resultp = result;\n  /* Return the number of resulting bytes, excluding the trailing NUL.  */\n  return length;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/verify.h": {},
  "tar/tar-1.30/gnu/version-etc-fsf.c": {},
  "tar/tar-1.30/gnu/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <https://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/version-etc.h": {},
  "tar/tar-1.30/gnu/vsnprintf.c": {
    "vsnprintf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nvsnprintf (char *str, size_t size, const char *format, va_list args)\n{\n  char *output;\n  size_t len;\n  size_t lenbuf = size;\n\n  output = vasnprintf (str, &lenbuf, format, args);\n  len = lenbuf;\n\n  if (!output)\n    return -1;\n\n  if (output != str)\n    {\n      if (size)\n        {\n          size_t pruned_len = (len < size ? len : size - 1);\n          memcpy (str, output, pruned_len);\n          str[pruned_len] = '\\0';\n        }\n\n      free (output);\n    }\n\n  if (len > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/warn-on-use.h": {},
  "tar/tar-1.30/gnu/wchar.in.h": {},
  "tar/tar-1.30/gnu/wcrtomb.c": {
    "wcrtomb": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\nwcrtomb (char *s, wchar_t wc, mbstate_t *ps)\n{\n  /* This implementation of wcrtomb on top of wctomb() supports only\n     stateless encodings.  ps must be in the initial state.  */\n  if (ps != NULL && !mbsinit (ps))\n    {\n      errno = EINVAL;\n      return (size_t)(-1);\n    }\n\n  if (s == NULL)\n    /* We know the NUL wide character corresponds to the NUL character.  */\n    return 1;\n  else\n    {\n      int ret = wctomb (s, wc);\n\n      if (ret >= 0)\n        return ret;\n      else\n        {\n          errno = EILSEQ;\n          return (size_t)(-1);\n        }\n    }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/wctype-h.c": {},
  "tar/tar-1.30/gnu/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/wcwidth.c": {},
  "tar/tar-1.30/gnu/write.c": {
    "write_nothrow": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        56,
        5
      ],
      "content": "static ssize_t\nwrite_nothrow (int fd, const void *buf, size_t count)\n{\n  ssize_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = write (fd, buf, count);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "rpl_write": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "ssize_t\nrpl_write (int fd, const void *buf, size_t count)\n{\n  for (;;)\n    {\n      ssize_t ret = write_nothrow (fd, buf, count);\n\n      if (ret < 0)\n        {\n# if GNULIB_NONBLOCKING\n          if (errno == ENOSPC)\n            {\n              HANDLE h = (HANDLE) _get_osfhandle (fd);\n              if (GetFileType (h) == FILE_TYPE_PIPE)\n                {\n                  /* h is a pipe or socket.  */\n                  DWORD state;\n                  if (GetNamedPipeHandleState (h, &state, NULL, NULL, NULL,\n                                               NULL, 0)\n                      && (state & PIPE_NOWAIT) != 0)\n                    {\n                      /* h is a pipe in non-blocking mode.\n                         We can get here in four situations:\n                           1. When the pipe buffer is full.\n                           2. When count <= pipe_buf_size and the number of\n                              free bytes in the pipe buffer is < count.\n                           3. When count > pipe_buf_size and the number of free\n                              bytes in the pipe buffer is > 0, < pipe_buf_size.\n                           4. When count > pipe_buf_size and the pipe buffer is\n                              entirely empty.\n                         The cases 1 and 2 are POSIX compliant.  In cases 3 and\n                         4 POSIX specifies that write() must split the request\n                         and succeed with a partial write.  We fix case 4.\n                         We don't fix case 3 because it is not essential for\n                         programs.  */\n                      DWORD out_size; /* size of the buffer for outgoing data */\n                      DWORD in_size;  /* size of the buffer for incoming data */\n                      if (GetNamedPipeInfo (h, NULL, &out_size, &in_size, NULL))\n                        {\n                          size_t reduced_count = count;\n                          /* In theory we need only one of out_size, in_size.\n                             But I don't know which of the two.  The description\n                             is ambiguous.  */\n                          if (out_size != 0 && out_size < reduced_count)\n                            reduced_count = out_size;\n                          if (in_size != 0 && in_size < reduced_count)\n                            reduced_count = in_size;\n                          if (reduced_count < count)\n                            {\n                              /* Attempt to write only the first part.  */\n                              count = reduced_count;\n                              continue;\n                            }\n                        }\n                      /* Change errno from ENOSPC to EAGAIN.  */\n                      errno = EAGAIN;\n                    }\n                }\n            }\n          else\n# endif\n            {\n# if GNULIB_SIGPIPE\n              if (GetLastError () == ERROR_NO_DATA\n                  && GetFileType ((HANDLE) _get_osfhandle (fd))\n                     == FILE_TYPE_PIPE)\n                {\n                  /* Try to raise signal SIGPIPE.  */\n                  raise (SIGPIPE);\n                  /* If it is currently blocked or ignored, change errno from\n                     EINVAL to EPIPE.  */\n                  errno = EPIPE;\n                }\n# endif\n            }\n        }\n      return ret;\n    }\n}",
      "lines": 79,
      "depth": 20,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "tar/tar-1.30/gnu/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/xalloc-oversized.h": {},
  "tar/tar-1.30/gnu/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          122,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          239,
          29
        ],
        "end_point": [
          243,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          178,
          0
        ],
        "end_point": [
          213,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n      if (xalloc_oversized (n, s))\n        xalloc_die ();\n    }\n  else\n    {\n      /* Set N = floor (1.5 * N) + 1 so that progress is made even if N == 0.\n         Check for overflow, so that N * S stays in both ptrdiff_t and\n         size_t range.  The check may be slightly conservative, but an\n         exact check isn't worth the trouble.  */\n      if ((PTRDIFF_MAX < SIZE_MAX ? PTRDIFF_MAX : SIZE_MAX) / 3 * 2 / s\n          <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 36,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          251,
          29
        ],
        "end_point": [
          255,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        233,
        29
      ],
      "end_point": [
        237,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        245,
        29
      ],
      "end_point": [
        249,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        257,
        29
      ],
      "end_point": [
        261,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/xasprintf.c": {
    "xasprintf": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nxasprintf (const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = xvasprintf (format, args);\n  va_end (args);\n\n  return result;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxasprintf (const char *format, ...)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/xgetcwd.c": {
    "xgetcwd": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "char *\nxgetcwd (void)\n{\n  char *cwd = getcwd (NULL, 0);\n  if (! cwd && errno == ENOMEM)\n    xalloc_die ();\n  return cwd;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxgetcwd (void)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/xgetcwd.h": {},
  "tar/tar-1.30/gnu/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since objects with size greater than\n     PTRDIFF_MAX cause pointer subtraction to go awry.  Omit size-zero\n     tests if HAVE_GNU_CALLOC, since GNU calloc never returns NULL if\n     successful.  */\n  if (xalloc_oversized (n, s)\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/xsize.c": {},
  "tar/tar-1.30/gnu/xsize.h": {
    "size_t": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "__pure__": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    }
  },
  "tar/tar-1.30/gnu/xstrndup.c": {
    "xstrndup": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nxstrndup (const char *string, size_t n)\n{\n  char *s = strndup (string, n);\n  if (! s)\n    xalloc_die ();\n  return s;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxstrndup (const char *string, size_t n)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/xstrndup.h": {},
  "tar/tar-1.30/gnu/xstrtol-error.c": {
    "xstrtol_error": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\nxstrtol_error (enum strtol_error err,\n               int opt_idx, char c, struct option const *long_options,\n               char const *arg,\n               int exit_status)\n{\n  char const *hyphens = \"--\";\n  char const *msgid;\n  char const *option;\n  char option_buffer[2];\n\n  switch (err)\n    {\n    default:\n      abort ();\n\n    case LONGINT_INVALID:\n      msgid = N_(\"invalid %s%s argument '%s'\");\n      break;\n\n    case LONGINT_INVALID_SUFFIX_CHAR:\n    case LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW:\n      msgid = N_(\"invalid suffix in %s%s argument '%s'\");\n      break;\n\n    case LONGINT_OVERFLOW:\n      msgid = N_(\"%s%s argument '%s' too large\");\n      break;\n    }\n\n  if (opt_idx < 0)\n    {\n      hyphens -= opt_idx;\n      option_buffer[0] = c;\n      option_buffer[1] = '\\0';\n      option = option_buffer;\n    }\n  else\n    option = long_options[opt_idx].name;\n\n  error (exit_status, 0, gettext (msgid), hyphens, option, arg);\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xstrtol_fatal": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\nxstrtol_fatal (enum strtol_error err,\n               int opt_idx, char c, struct option const *long_options,\n               char const *arg)\n{\n  xstrtol_error (err, opt_idx, c, long_options, arg, exit_failure);\n  abort ();\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/gnu/xstrtol.c": {
    "bkm_scale": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static strtol_error\nbkm_scale (__strtol_t *x, int scale_factor)\n{\n  if (TYPE_SIGNED (__strtol_t) && *x < STRTOL_T_MINIMUM / scale_factor)\n    {\n      *x = STRTOL_T_MINIMUM;\n      return LONGINT_OVERFLOW;\n    }\n  if (STRTOL_T_MAXIMUM / scale_factor < *x)\n    {\n      *x = STRTOL_T_MAXIMUM;\n      return LONGINT_OVERFLOW;\n    }\n  *x *= scale_factor;\n  return LONGINT_OK;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "bkm_scale_by_power": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static strtol_error\nbkm_scale_by_power (__strtol_t *x, int base, int power)\n{\n  strtol_error err = LONGINT_OK;\n  while (power--)\n    err |= bkm_scale (x, base);\n  return err;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "__xstrtol": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "strtol_error\n__xstrtol (const char *s, char **ptr, int strtol_base,\n           __strtol_t *val, const char *valid_suffixes)\n{\n  char *t_ptr;\n  char **p;\n  __strtol_t tmp;\n  strtol_error err = LONGINT_OK;\n\n  assure (0 <= strtol_base && strtol_base <= 36);\n\n  p = (ptr ? ptr : &t_ptr);\n\n  errno = 0;\n\n  if (! TYPE_SIGNED (__strtol_t))\n    {\n      const char *q = s;\n      unsigned char ch = *q;\n      while (isspace (ch))\n        ch = *++q;\n      if (ch == '-')\n        return LONGINT_INVALID;\n    }\n\n  tmp = __strtol (s, p, strtol_base);\n\n  if (*p == s)\n    {\n      /* If there is no number but there is a valid suffix, assume the\n         number is 1.  The string is invalid otherwise.  */\n      if (valid_suffixes && **p && strchr (valid_suffixes, **p))\n        tmp = 1;\n      else\n        return LONGINT_INVALID;\n    }\n  else if (errno != 0)\n    {\n      if (errno != ERANGE)\n        return LONGINT_INVALID;\n      err = LONGINT_OVERFLOW;\n    }\n\n  /* Let valid_suffixes == NULL mean \"allow any suffix\".  */\n  /* FIXME: update all callers except the ones that allow suffixes\n     after the number, changing last parameter NULL to \"\".  */\n  if (!valid_suffixes)\n    {\n      *val = tmp;\n      return err;\n    }\n\n  if (**p != '\\0')\n    {\n      int base = 1024;\n      int suffixes = 1;\n      strtol_error overflow;\n\n      if (!strchr (valid_suffixes, **p))\n        {\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      switch (**p)\n        {\n        case 'E': case 'G': case 'g': case 'k': case 'K': case 'M': case 'm':\n        case 'P': case 'T': case 't': case 'Y': case 'Z':\n\n          /* The \"valid suffix\" '0' is a special flag meaning that\n             an optional second suffix is allowed, which can change\n             the base.  A suffix \"B\" (e.g. \"100MB\") stands for a power\n             of 1000, whereas a suffix \"iB\" (e.g. \"100MiB\") stands for\n             a power of 1024.  If no suffix (e.g. \"100M\"), assume\n             power-of-1024.  */\n\n          if (strchr (valid_suffixes, '0'))\n            switch (p[0][1])\n              {\n              case 'i':\n                if (p[0][2] == 'B')\n                  suffixes += 2;\n                break;\n\n              case 'B':\n              case 'D': /* 'D' is obsolescent */\n                base = 1000;\n                suffixes++;\n                break;\n              }\n        }\n\n      switch (**p)\n        {\n        case 'b':\n          overflow = bkm_scale (&tmp, 512);\n          break;\n\n        case 'B':\n          /* This obsolescent first suffix is distinct from the 'B'\n             second suffix above.  E.g., 'tar -L 1000B' means change\n             the tape after writing 1000 KiB of data.  */\n          overflow = bkm_scale (&tmp, 1024);\n          break;\n\n        case 'c':\n          overflow = LONGINT_OK;\n          break;\n\n        case 'E': /* exa or exbi */\n          overflow = bkm_scale_by_power (&tmp, base, 6);\n          break;\n\n        case 'G': /* giga or gibi */\n        case 'g': /* 'g' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 3);\n          break;\n\n        case 'k': /* kilo */\n        case 'K': /* kibi */\n          overflow = bkm_scale_by_power (&tmp, base, 1);\n          break;\n\n        case 'M': /* mega or mebi */\n        case 'm': /* 'm' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 2);\n          break;\n\n        case 'P': /* peta or pebi */\n          overflow = bkm_scale_by_power (&tmp, base, 5);\n          break;\n\n        case 'T': /* tera or tebi */\n        case 't': /* 't' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 4);\n          break;\n\n        case 'w':\n          overflow = bkm_scale (&tmp, 2);\n          break;\n\n        case 'Y': /* yotta or 2**80 */\n          overflow = bkm_scale_by_power (&tmp, base, 8);\n          break;\n\n        case 'Z': /* zetta or 2**70 */\n          overflow = bkm_scale_by_power (&tmp, base, 7);\n          break;\n\n        default:\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      err |= overflow;\n      *p += suffixes;\n      if (**p)\n        err |= LONGINT_INVALID_SUFFIX_CHAR;\n    }\n\n  *val = tmp;\n  return err;\n}",
      "lines": 163,
      "depth": 17,
      "decorators": [
        "strtol_error"
      ]
    }
  },
  "tar/tar-1.30/gnu/xstrtol.h": {},
  "tar/tar-1.30/gnu/xstrtoul.c": {},
  "tar/tar-1.30/gnu/xstrtoumax.c": {},
  "tar/tar-1.30/gnu/xvasprintf.c": {
    "xstrcat": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static char *\nxstrcat (size_t argcount, va_list args)\n{\n  char *result;\n  va_list ap;\n  size_t totalsize;\n  size_t i;\n  char *p;\n\n  /* Determine the total size.  */\n  totalsize = 0;\n  va_copy (ap, args);\n  for (i = argcount; i > 0; i--)\n    {\n      const char *next = va_arg (ap, const char *);\n      totalsize = xsum (totalsize, strlen (next));\n    }\n  va_end (ap);\n\n  /* Test for overflow in the summing pass above or in (totalsize + 1) below.\n     Also, don't return a string longer than INT_MAX, for consistency with\n     vasprintf().  */\n  if (totalsize == SIZE_MAX || totalsize > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      return NULL;\n    }\n\n  /* Allocate and fill the result string.  */\n  result = XNMALLOC (totalsize + 1, char);\n  p = result;\n  for (i = argcount; i > 0; i--)\n    {\n      const char *next = va_arg (args, const char *);\n      size_t len = strlen (next);\n      memcpy (p, next, len);\n      p += len;\n    }\n  *p = '\\0';\n\n  return result;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nxstrcat (size_t argcount, va_list args)",
        "*"
      ]
    },
    "xvasprintf": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "char *\nxvasprintf (const char *format, va_list args)\n{\n  char *result;\n\n  /* Recognize the special case format = \"%s...%s\".  It is a frequently used\n     idiom for string concatenation and needs to be fast.  We don't want to\n     have a separate function xstrcat() for this purpose.  */\n  {\n    size_t argcount = 0;\n    const char *f;\n\n    for (f = format;;)\n      {\n        if (*f == '\\0')\n          /* Recognized the special case of string concatenation.  */\n          return xstrcat (argcount, args);\n        if (*f != '%')\n          break;\n        f++;\n        if (*f != 's')\n          break;\n        f++;\n        argcount++;\n      }\n  }\n\n  if (vasprintf (&result, format, args) < 0)\n    {\n      if (errno == ENOMEM)\n        xalloc_die ();\n      return NULL;\n    }\n\n  return result;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "char",
        "*\nxvasprintf (const char *format, va_list args)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/gnu/xvasprintf.h": {},
  "tar/tar-1.30/gnu/_Noreturn.h": {},
  "tar/tar-1.30/gnu/uniwidth/cjk.h": {
    "is_cjk_encoding": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nis_cjk_encoding (const char *encoding)\n{\n  if (0\n      /* Legacy Japanese encodings */\n      || STREQ_OPT (encoding, \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0)\n      /* Legacy Chinese encodings */\n      || STREQ_OPT (encoding, \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n      || STREQ_OPT (encoding, \"GBK\", 'G', 'B', 'K', 0, 0, 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0)\n      || STREQ_OPT (encoding, \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0)\n      /* Legacy Korean encodings */\n      || STREQ_OPT (encoding, \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n      || STREQ_OPT (encoding, \"CP949\", 'C', 'P', '9', '4', '9', 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"JOHAB\", 'J', 'O', 'H', 'A', 'B', 0, 0, 0, 0))\n    return 1;\n  return 0;\n}",
      "lines": 18,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "tar/tar-1.30/gnu/uniwidth/width.c": {
    "uc_width": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "int\nuc_width (ucs4_t uc, const char *encoding)\n{\n  /* Test for non-spacing or control character.  */\n  if ((uc >> 9) < 248)\n    {\n      int ind = nonspacing_table_ind[uc >> 9];\n      if (ind >= 0)\n        if ((nonspacing_table_data[64*ind + ((uc >> 3) & 63)] >> (uc & 7)) & 1)\n          {\n            if (uc > 0 && uc < 0xa0)\n              return -1;\n            else\n              return 0;\n          }\n    }\n  else if ((uc >> 9) == (0xe0000 >> 9))\n    {\n      if (uc >= 0xe0100)\n        {\n          if (uc <= 0xe01ef)\n            return 0;\n        }\n      else\n        {\n          if (uc >= 0xe0020 ? uc <= 0xe007f : uc == 0xe0001)\n            return 0;\n        }\n    }\n  /* Test for double-width character.\n   * Generated from \"grep '^[^;]\\{4,5\\};[WF]' EastAsianWidth.txt\"\n   * and            \"grep '^[^;]\\{4,5\\};[^WF]' EastAsianWidth.txt\"\n   */\n  if (uc >= 0x1100\n      && ((uc < 0x1160) /* Hangul Jamo */\n          || (uc >= 0x2329 && uc < 0x232b) /* Angle Brackets */\n          || (uc >= 0x2e80 && uc < 0xa4d0  /* CJK ... Yi */\n              && !(uc == 0x303f) && !(uc >= 0x4dc0 && uc < 0x4e00))\n          || (uc >= 0xac00 && uc < 0xd7a4) /* Hangul Syllables */\n          || (uc >= 0xf900 && uc < 0xfb00) /* CJK Compatibility Ideographs */\n          || (uc >= 0xfe10 && uc < 0xfe20) /* Presentation Forms for Vertical */\n          || (uc >= 0xfe30 && uc < 0xfe70) /* CJK Compatibility Forms */\n          || (uc >= 0xff00 && uc < 0xff61) /* Fullwidth Forms */\n          || (uc >= 0xffe0 && uc < 0xffe7) /* Fullwidth Signs */\n          || (uc >= 0x20000 && uc <= 0x2ffff) /* Supplementary Ideographic Plane */\n          || (uc >= 0x30000 && uc <= 0x3ffff) /* Tertiary Ideographic Plane */\n     )   )\n    return 2;\n  /* In ancient CJK encodings, Cyrillic and most other characters are\n     double-width as well.  */\n  if (uc >= 0x00A1 && uc < 0xFF61 && uc != 0x20A9\n      && is_cjk_encoding (encoding))\n    return 2;\n  return 1;\n}",
      "lines": 55,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/lib/attr-xattr.in.h": {
    "setxattr": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        26,
        31
      ],
      "content": "static inline int setxattr (const char *path, const char *name, const void\n                            *value, size_t size, int flags)\n{ errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "lsetxattr": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        30,
        31
      ],
      "content": "static inline int lsetxattr (const char *path, const char *name, const void\n                             *value, size_t size, int flags)\n{ errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "fsetxattr": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        34,
        31
      ],
      "content": "static inline int fsetxattr (int filedes, const char *name, const void *value,\n                             size_t size, int flags)\n{ errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "getxattr": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        40,
        31
      ],
      "content": "static inline ssize_t getxattr (const char *path, const char *name, void *value,\n                                size_t size)\n{ errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "ssize_t"
      ]
    },
    "lgetxattr": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        43,
        31
      ],
      "content": "static inline ssize_t lgetxattr (const char *path, const char *name, void\n                                 *value, size_t size)\n{ errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "ssize_t"
      ]
    },
    "fgetxattr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        46,
        31
      ],
      "content": "static inline ssize_t fgetxattr (int filedes, const char *name, void *value,\n                                 size_t size)\n{ errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "ssize_t"
      ]
    },
    "listxattr": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        51,
        31
      ],
      "content": "static inline ssize_t listxattr (const char *path, char *list, size_t size)\n{ errno = ENOTSUP; return -1; }",
      "lines": 2,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "ssize_t"
      ]
    },
    "llistxattr": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        54,
        31
      ],
      "content": "static inline ssize_t llistxattr (const char *path, char *list, size_t size)\n{ errno = ENOTSUP; return -1; }",
      "lines": 2,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "ssize_t"
      ]
    },
    "flistxattr": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        57,
        31
      ],
      "content": "static inline ssize_t flistxattr (int filedes, char *list, size_t size)\n{ errno = ENOTSUP; return -1; }",
      "lines": 2,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "ssize_t"
      ]
    }
  },
  "tar/tar-1.30/lib/paxerror.c": {
    "pax_decode_mode": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\npax_decode_mode (mode_t mode, char *string)\n{\n  *string++ = mode & S_IRUSR ? 'r' : '-';\n  *string++ = mode & S_IWUSR ? 'w' : '-';\n  *string++ = (mode & S_ISUID\n\t       ? (mode & S_IXUSR ? 's' : 'S')\n\t       : (mode & S_IXUSR ? 'x' : '-'));\n  *string++ = mode & S_IRGRP ? 'r' : '-';\n  *string++ = mode & S_IWGRP ? 'w' : '-';\n  *string++ = (mode & S_ISGID\n\t       ? (mode & S_IXGRP ? 's' : 'S')\n\t       : (mode & S_IXGRP ? 'x' : '-'));\n  *string++ = mode & S_IROTH ? 'r' : '-';\n  *string++ = mode & S_IWOTH ? 'w' : '-';\n  *string++ = (mode & S_ISVTX\n\t       ? (mode & S_IXOTH ? 't' : 'T')\n\t       : (mode & S_IXOTH ? 'x' : '-'));\n  *string = '\\0';\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "call_arg_error": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\ncall_arg_error (char const *call, char const *name)\n{\n  int e = errno;\n  /* TRANSLATORS: %s after `Cannot' is a function name, e.g. `Cannot open'.\n     Directly translating this to another language will not work, first because\n     %s itself is not translated.\n     Translate it as `%s: Function %s failed'. */\n  ERROR ((0, e, _(\"%s: Cannot %s\"), quotearg_colon (name), call));\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "call_arg_fatal": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\ncall_arg_fatal (char const *call, char const *name)\n{\n  int e = errno;\n  /* TRANSLATORS: %s after `Cannot' is a function name, e.g. `Cannot open'.\n     Directly translating this to another language will not work, first because\n     %s itself is not translated.\n     Translate it as `%s: Function %s failed'. */\n  FATAL_ERROR ((0, e, _(\"%s: Cannot %s\"), quotearg_colon (name),  call));\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "call_arg_warn": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void\ncall_arg_warn (char const *call, char const *name)\n{\n  int e = errno;\n  /* TRANSLATORS: %s after `Cannot' is a function name, e.g. `Cannot open'.\n     Directly translating this to another language will not work, first because\n     %s itself is not translated.\n     Translate it as `%s: Function %s failed'. */\n  WARN ((0, e, _(\"%s: Warning: Cannot %s\"), quotearg_colon (name), call));\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "chmod_error_details": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nchmod_error_details (char const *name, mode_t mode)\n{\n  int e = errno;\n  char buf[10];\n  pax_decode_mode (mode, buf);\n  ERROR ((0, e, _(\"%s: Cannot change mode to %s\"),\n\t  quotearg_colon (name), buf));\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "chown_error_details": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void\nchown_error_details (char const *name, uid_t uid, gid_t gid)\n{\n  int e = errno;\n  ERROR ((0, e, _(\"%s: Cannot change ownership to uid %lu, gid %lu\"),\n\t  quotearg_colon (name), (unsigned long) uid, (unsigned long) gid));\n}",
      "lines": 7,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "close_error": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\nclose_error (char const *name)\n{\n  call_arg_error (\"close\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "close_warn": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\nclose_warn (char const *name)\n{\n  call_arg_warn (\"close\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "exec_fatal": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\nexec_fatal (char const *name)\n{\n  call_arg_fatal (\"exec\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "link_error": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void\nlink_error (char const *target, char const *source)\n{\n  int e = errno;\n  ERROR ((0, e, _(\"%s: Cannot hard link to %s\"),\n\t  quotearg_colon (source), quote_n (1, target)));\n}",
      "lines": 7,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mkdir_error": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\nmkdir_error (char const *name)\n{\n  call_arg_error (\"mkdir\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mkfifo_error": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "void\nmkfifo_error (char const *name)\n{\n  call_arg_error (\"mkfifo\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mknod_error": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void\nmknod_error (char const *name)\n{\n  call_arg_error (\"mknod\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "open_error": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void\nopen_error (char const *name)\n{\n  call_arg_error (\"open\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "open_fatal": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "void\nopen_fatal (char const *name)\n{\n  call_arg_fatal (\"open\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "open_warn": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\nopen_warn (char const *name)\n{\n  call_arg_warn (\"open\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "read_error": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nread_error (char const *name)\n{\n  call_arg_error (\"read\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "read_error_details": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "void\nread_error_details (char const *name, off_t offset, size_t size)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  int e = errno;\n  ERROR ((0, e,\n\t  ngettext (\"%s: Read error at byte %s, while reading %lu byte\",\n\t\t    \"%s: Read error at byte %s, while reading %lu bytes\",\n\t\t    size),\n\t  quotearg_colon (name), STRINGIFY_BIGINT (offset, buf),\n\t  (unsigned long) size));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "read_warn_details": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "void\nread_warn_details (char const *name, off_t offset, size_t size)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  int e = errno;\n  WARN ((0, e,\n\t ngettext (\"%s: Warning: Read error at byte %s, while reading %lu byte\",\n\t\t   \"%s: Warning: Read error at byte %s, while reading %lu bytes\",\n\t\t   size),\n\t quotearg_colon (name), STRINGIFY_BIGINT (offset, buf),\n\t (unsigned long) size));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "read_fatal": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "void\nread_fatal (char const *name)\n{\n  call_arg_fatal (\"read\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "read_fatal_details": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "void\nread_fatal_details (char const *name, off_t offset, size_t size)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  int e = errno;\n  FATAL_ERROR ((0, e,\n\t\tngettext (\"%s: Read error at byte %s, while reading %lu byte\",\n\t\t\t  \"%s: Read error at byte %s, while reading %lu bytes\",\n\t\t\t  size),\n\t\tquotearg_colon (name), STRINGIFY_BIGINT (offset, buf),\n\t\t(unsigned long) size));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "readlink_error": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "void\nreadlink_error (char const *name)\n{\n  call_arg_error (\"readlink\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "readlink_warn": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "void\nreadlink_warn (char const *name)\n{\n  call_arg_warn (\"readlink\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rmdir_error": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nrmdir_error (char const *name)\n{\n  call_arg_error (\"rmdir\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "savedir_error": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "void\nsavedir_error (char const *name)\n{\n  call_arg_error (\"savedir\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "savedir_warn": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "void\nsavedir_warn (char const *name)\n{\n  call_arg_warn (\"savedir\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "seek_error": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "void\nseek_error (char const *name)\n{\n  call_arg_error (\"seek\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "seek_error_details": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "void\nseek_error_details (char const *name, off_t offset)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  int e = errno;\n  ERROR ((0, e, _(\"%s: Cannot seek to %s\"),\n\t  quotearg_colon (name),\n\t  STRINGIFY_BIGINT (offset, buf)));\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "seek_warn": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "void\nseek_warn (char const *name)\n{\n  call_arg_warn (\"seek\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "seek_warn_details": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "void\nseek_warn_details (char const *name, off_t offset)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  int e = errno;\n  WARN ((0, e, _(\"%s: Warning: Cannot seek to %s\"),\n\t quotearg_colon (name),\n\t STRINGIFY_BIGINT (offset, buf)));\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "symlink_error": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "void\nsymlink_error (char const *contents, char const *name)\n{\n  int e = errno;\n  ERROR ((0, e, _(\"%s: Cannot create symlink to %s\"),\n\t  quotearg_colon (name), quote_n (1, contents)));\n}",
      "lines": 7,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "stat_fatal": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "void\nstat_fatal (char const *name)\n{\n  call_arg_fatal (\"stat\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "stat_error": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "void\nstat_error (char const *name)\n{\n  call_arg_error (\"stat\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "stat_warn": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "void\nstat_warn (char const *name)\n{\n  call_arg_warn (\"stat\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "truncate_error": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "void\ntruncate_error (char const *name)\n{\n  call_arg_error (\"truncate\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "truncate_warn": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\ntruncate_warn (char const *name)\n{\n  call_arg_warn (\"truncate\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "unlink_error": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "void\nunlink_error (char const *name)\n{\n  call_arg_error (\"unlink\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "utime_error": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "void\nutime_error (char const *name)\n{\n  call_arg_error (\"utime\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "waitpid_error": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "void\nwaitpid_error (char const *name)\n{\n  call_arg_error (\"waitpid\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "write_error": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "void\nwrite_error (char const *name)\n{\n  call_arg_error (\"write\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "write_error_details": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "void\nwrite_error_details (char const *name, size_t status, size_t size)\n{\n  if (status == 0)\n    write_error (name);\n  else\n    ERROR ((0, 0,\n\t    ngettext (\"%s: Wrote only %lu of %lu byte\",\n\t\t      \"%s: Wrote only %lu of %lu bytes\",\n\t\t      size),\n\t    name, (unsigned long int) status, (unsigned long int) size));\n}",
      "lines": 12,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "chdir_fatal": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "void\nchdir_fatal (char const *name)\n{\n  call_arg_fatal (\"chdir\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/lib/paxexit-status.c": {},
  "tar/tar-1.30/lib/paxlib.h": {},
  "tar/tar-1.30/lib/paxnames.c": {
    "hash_string_hasher": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static size_t\nhash_string_hasher (void const *name, size_t n_buckets)\n{\n  return hash_string (name, n_buckets);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "hash_string_compare": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static bool\nhash_string_compare (void const *name1, void const *name2)\n{\n  return strcmp (name1, name2) == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "hash_string_insert_prefix": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static bool\nhash_string_insert_prefix (Hash_table **table, char const *string, size_t len,\n\t\t\t   const char **return_prefix)\n{\n  Hash_table *t = *table;\n  char *s;\n  char *e;\n\n  if (len)\n    {\n      s = xmalloc (len + 1);\n      memcpy (s, string, len);\n      s[len] = 0;\n    }\n  else\n    s = xstrdup (string);\n\n  if (! ((t\n\t  || (*table = t = hash_initialize (0, 0, hash_string_hasher,\n\t\t\t\t\t    hash_string_compare, 0)))\n\t && (e = hash_insert (t, s))))\n    xalloc_die ();\n\n  if (e == s)\n    {\n      if (return_prefix)\n\t*return_prefix = s;\n      return 1;\n    }\n  else\n    {\n      free (s);\n      return 0;\n    }\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "removed_prefixes_p": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "bool\nremoved_prefixes_p (void)\n{\n  return (prefix_table[0] && hash_get_n_entries (prefix_table[0]) != 0)\n         || (prefix_table[1] && hash_get_n_entries (prefix_table[1]) != 0);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "safer_name_suffix": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "char *\nsafer_name_suffix (char const *file_name, bool link_target,\n\t\t   bool absolute_names)\n{\n  char const *p;\n\n  if (absolute_names)\n    p = file_name;\n  else\n    {\n      /* Skip file system prefixes, leading file name components that contain\n\t \"..\", and leading slashes.  */\n\n      size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (file_name);\n\n      for (p = file_name + prefix_len; *p; )\n\t{\n          if (p[0] == '.' && p[1] == '.' && (ISSLASH (p[2]) || !p[2]))\n\t    prefix_len = p + 2 - file_name;\n\n\t  do\n\t    {\n\t      char c = *p++;\n\t      if (ISSLASH (c))\n\t\tbreak;\n\t    }\n\t  while (*p);\n\t}\n\n      for (p = file_name + prefix_len; ISSLASH (*p); p++)\n\tcontinue;\n      prefix_len = p - file_name;\n\n      if (prefix_len)\n\t{\n\t  const char *prefix;\n\t  if (hash_string_insert_prefix (&prefix_table[link_target], file_name,\n\t\t\t\t\t prefix_len, &prefix))\n\t    {\n\t      static char const *const diagnostic[] =\n\t      {\n\t\tN_(\"Removing leading `%s' from member names\"),\n\t\tN_(\"Removing leading `%s' from hard link targets\")\n\t      };\n\t      WARN ((0, 0, _(diagnostic[link_target]), prefix));\n\t    }\n\t}\n    }\n\n  if (! *p)\n    {\n      if (p == file_name)\n\t{\n\t  static char const *const diagnostic[] =\n\t  {\n\t    N_(\"Substituting `.' for empty member name\"),\n\t    N_(\"Substituting `.' for empty hard link target\")\n\t  };\n\t  WARN ((0, 0, \"%s\", _(diagnostic[link_target])));\n\t}\n\n      p = \".\";\n    }\n\n  return (char *) p;\n}",
      "lines": 66,
      "depth": 19,
      "decorators": [
        "char",
        "*\nsafer_name_suffix (char const *file_name, bool link_target,\n\t\t   bool absolute_names)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/lib/rmt.h": {},
  "tar/tar-1.30/lib/rtapelib.c": {
    "_rmt_shutdown": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static void\n_rmt_shutdown (int handle, int errno_value)\n{\n  close (READ_SIDE (handle));\n  close (WRITE_SIDE (handle));\n  READ_SIDE (handle) = -1;\n  WRITE_SIDE (handle) = -1;\n  errno = errno_value;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_command": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static int\ndo_command (int handle, const char *buffer)\n{\n  /* Save the current pipe handler and try to make the request.  */\n\n  size_t length = strlen (buffer);\n  RETSIGTYPE (*pipe_handler) (int) = signal (SIGPIPE, SIG_IGN);\n  ssize_t written = full_write (WRITE_SIDE (handle), buffer, length);\n  signal (SIGPIPE, pipe_handler);\n\n  if (written == length)\n    return 0;\n\n  /* Something went wrong.  Close down and go home.  */\n\n  _rmt_shutdown (handle, EIO);\n  return -1;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_status_string": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static char *\nget_status_string (int handle, char *command_buffer)\n{\n  char *cursor;\n  int counter;\n\n  /* Read the reply command line.  */\n\n  for (counter = 0, cursor = command_buffer;\n       counter < COMMAND_BUFFER_SIZE;\n       counter++, cursor++)\n    {\n      if (safe_read (READ_SIDE (handle), cursor, 1) != 1)\n\t{\n\t  _rmt_shutdown (handle, EIO);\n\t  return 0;\n\t}\n      if (*cursor == '\\n')\n\t{\n\t  *cursor = '\\0';\n\t  break;\n\t}\n    }\n\n  if (counter == COMMAND_BUFFER_SIZE)\n    {\n      _rmt_shutdown (handle, EIO);\n      return 0;\n    }\n\n  /* Check the return status.  */\n\n  for (cursor = command_buffer; *cursor; cursor++)\n    if (*cursor != ' ')\n      break;\n\n  if (*cursor == 'E' || *cursor == 'F')\n    {\n      /* Skip the error message line.  */\n\n      /* FIXME: there is better to do than merely ignoring error messages\n\t coming from the remote end.  Translate them, too...  */\n\n      {\n\tchar character;\n\n\twhile (safe_read (READ_SIDE (handle), &character, 1) == 1)\n\t  if (character == '\\n')\n\t    break;\n      }\n\n      errno = atoi (cursor + 1);\n\n      if (*cursor == 'F')\n\t_rmt_shutdown (handle, errno);\n\n      return 0;\n    }\n\n  /* Check for mis-synced pipes.  */\n\n  if (*cursor != 'A')\n    {\n      _rmt_shutdown (handle, EIO);\n      return 0;\n    }\n\n  /* Got an `A' (success) response.  */\n\n  return cursor + 1;\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_status_string (int handle, char *command_buffer)",
        "*"
      ]
    },
    "get_status": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static long int\nget_status (int handle)\n{\n  char command_buffer[COMMAND_BUFFER_SIZE];\n  const char *status = get_status_string (handle, command_buffer);\n  if (status)\n    {\n      long int result = atol (status);\n      if (0 <= result)\n\treturn result;\n      errno = EIO;\n    }\n  return -1;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "get_status_off": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "static off_t\nget_status_off (int handle)\n{\n  char command_buffer[COMMAND_BUFFER_SIZE];\n  const char *status = get_status_string (handle, command_buffer);\n\n  if (! status)\n    return -1;\n  else\n    {\n      /* Parse status, taking care to check for overflow.\n\t We can't use standard functions,\n\t since off_t might be longer than long.  */\n\n      off_t count = 0;\n      int negative;\n\n      for (;  *status == ' ' || *status == '\\t';  status++)\n\tcontinue;\n\n      negative = *status == '-';\n      status += negative || *status == '+';\n\n      for (;;)\n\t{\n\t  int digit = *status++ - '0';\n\t  if (9 < (unsigned) digit)\n\t    break;\n\t  else\n\t    {\n\t      off_t c10 = 10 * count;\n\t      off_t nc = negative ? c10 - digit : c10 + digit;\n\t      if (c10 / 10 != count || (negative ? c10 < nc : nc < c10))\n\t\treturn -1;\n\t      count = nc;\n\t    }\n\t}\n\n      return count;\n    }\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "off_t"
      ]
    },
    "_rmt_rexec": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "static int\n_rmt_rexec (char *host, char *user)\n{\n  int saved_stdin = dup (STDIN_FILENO);\n  int saved_stdout = dup (STDOUT_FILENO);\n  struct servent *rexecserv;\n  int result;\n\n  /* When using cpio -o < filename, stdin is no longer the tty.  But the\n     rexec subroutine reads the login and the passwd on stdin, to allow\n     remote execution of the command.  So, reopen stdin and stdout on\n     /dev/tty before the rexec and give them back their original value\n     after.  */\n\n  if (! freopen (\"/dev/tty\", \"r\", stdin))\n    freopen (\"/dev/null\", \"r\", stdin);\n  if (! freopen (\"/dev/tty\", \"w\", stdout))\n    freopen (\"/dev/null\", \"w\", stdout);\n\n  if (rexecserv = getservbyname (\"exec\", \"tcp\"), !rexecserv)\n    error (EXIT_ON_EXEC_ERROR, 0, _(\"exec/tcp: Service not available\"));\n\n  result = rexec (&host, rexecserv->s_port, user, 0, rmt_command, 0);\n  if (fclose (stdin) == EOF)\n    error (0, errno, _(\"stdin\"));\n  fdopen (saved_stdin, \"r\");\n  if (fclose (stdout) == EOF)\n    error (0, errno, _(\"stdout\"));\n  fdopen (saved_stdout, \"w\");\n\n  return result;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "encode_oflag": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "static void\nencode_oflag (char *buf, int oflag)\n{\n  sprintf (buf, \"%d \", oflag);\n\n  switch (oflag & O_ACCMODE)\n    {\n    case O_RDONLY: strcat (buf, \"O_RDONLY\"); break;\n    case O_RDWR: strcat (buf, \"O_RDWR\"); break;\n    case O_WRONLY: strcat (buf, \"O_WRONLY\"); break;\n    default: abort ();\n    }\n\n#ifdef O_APPEND\n  if (oflag & O_APPEND) strcat (buf, \"|O_APPEND\");\n#endif\n  if (oflag & O_CREAT) strcat (buf, \"|O_CREAT\");\n#ifdef O_DSYNC\n  if (oflag & O_DSYNC) strcat (buf, \"|O_DSYNC\");\n#endif\n  if (oflag & O_EXCL) strcat (buf, \"|O_EXCL\");\n#ifdef O_LARGEFILE\n  if (oflag & O_LARGEFILE) strcat (buf, \"|O_LARGEFILE\");\n#endif\n#ifdef O_NOCTTY\n  if (oflag & O_NOCTTY) strcat (buf, \"|O_NOCTTY\");\n#endif\n  if (oflag & O_NONBLOCK) strcat (buf, \"|O_NONBLOCK\");\n#ifdef O_RSYNC\n  if (oflag & O_RSYNC) strcat (buf, \"|O_RSYNC\");\n#endif\n#ifdef O_SYNC\n  if (oflag & O_SYNC) strcat (buf, \"|O_SYNC\");\n#endif\n  if (oflag & O_TRUNC) strcat (buf, \"|O_TRUNC\");\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rmt_open__": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "int\nrmt_open__ (const char *file_name, int open_mode, int bias,\n            const char *remote_shell)\n{\n  int remote_pipe_number;\t/* pseudo, biased file descriptor */\n  char *file_name_copy;\t\t/* copy of file_name string */\n  char *remote_host;\t\t/* remote host name */\n  char *remote_file;\t\t/* remote file name (often a device) */\n  char *remote_user;\t\t/* remote user name */\n\n  /* Find an unused pair of file descriptors.  */\n\n  for (remote_pipe_number = 0;\n       remote_pipe_number < MAXUNIT;\n       remote_pipe_number++)\n    if (READ_SIDE (remote_pipe_number) == -1\n\t&& WRITE_SIDE (remote_pipe_number) == -1)\n      break;\n\n  if (remote_pipe_number == MAXUNIT)\n    {\n      errno = EMFILE;\n      return -1;\n    }\n\n  /* Pull apart the system and device, and optional user.  */\n\n  {\n    char *cursor;\n\n    file_name_copy = xstrdup (file_name);\n    remote_host = file_name_copy;\n    remote_user = 0;\n    remote_file = 0;\n\n    for (cursor = file_name_copy; *cursor; cursor++)\n      switch (*cursor)\n\t{\n\tdefault:\n\t  break;\n\n\tcase '\\n':\n\t  /* Do not allow newlines in the file_name, since the protocol\n\t     uses newline delimiters.  */\n\t  free (file_name_copy);\n\t  errno = ENOENT;\n\t  return -1;\n\n\tcase '@':\n\t  if (!remote_user)\n\t    {\n\t      remote_user = remote_host;\n\t      *cursor = '\\0';\n\t      remote_host = cursor + 1;\n\t    }\n\t  break;\n\n\tcase ':':\n\t  if (!remote_file)\n\t    {\n\t      *cursor = '\\0';\n\t      remote_file = cursor + 1;\n\t    }\n\t  break;\n\t}\n  }\n\n  /* FIXME: Should somewhat validate the decoding, here.  */\n  if (gethostbyname (remote_host) == NULL)\n    error (EXIT_ON_EXEC_ERROR, 0, _(\"Cannot connect to %s: resolve failed\"),\n\t   remote_host);\n\n  if (remote_user && *remote_user == '\\0')\n    remote_user = 0;\n\n#if WITH_REXEC\n\n  /* Execute the remote command using rexec.  */\n\n  READ_SIDE (remote_pipe_number) = _rmt_rexec (remote_host, remote_user);\n  if (READ_SIDE (remote_pipe_number) < 0)\n    {\n      int e = errno;\n      free (file_name_copy);\n      errno = e;\n      return -1;\n    }\n\n  WRITE_SIDE (remote_pipe_number) = READ_SIDE (remote_pipe_number);\n\n#else /* not WITH_REXEC */\n  {\n    const char *remote_shell_basename;\n    pid_t status;\n\n    /* Identify the remote command to be executed.  */\n\n    if (!remote_shell)\n      {\n#ifdef REMOTE_SHELL\n\tremote_shell = REMOTE_SHELL;\n#else\n\tfree (file_name_copy);\n\terrno = EIO;\n\treturn -1;\n#endif\n      }\n    remote_shell_basename = last_component (remote_shell);\n\n    /* Set up the pipes for the `rsh' command, and fork.  */\n\n    if (pipe (to_remote[remote_pipe_number]) == -1\n\t|| pipe (from_remote[remote_pipe_number]) == -1)\n      {\n\tint e = errno;\n\tfree (file_name_copy);\n\terrno = e;\n\treturn -1;\n      }\n\n    status = fork ();\n    if (status == -1)\n      {\n\tint e = errno;\n\tfree (file_name_copy);\n\terrno = e;\n\treturn -1;\n      }\n\n    if (status == 0)\n      {\n\t/* Child.  */\n\n\tif (dup2 (to_remote[remote_pipe_number][PREAD], STDIN_FILENO) < 0\n\t    || (to_remote[remote_pipe_number][PREAD] != STDIN_FILENO\n\t\t&& close (to_remote[remote_pipe_number][PREAD]) != 0)\n\t    || (to_remote[remote_pipe_number][PWRITE] != STDIN_FILENO\n\t\t&& close (to_remote[remote_pipe_number][PWRITE]) != 0)\n\t    || dup2 (from_remote[remote_pipe_number][PWRITE], STDOUT_FILENO) < 0\n\t    || close (from_remote[remote_pipe_number][PREAD]) != 0\n\t    || close (from_remote[remote_pipe_number][PWRITE]) != 0)\n\t  error (EXIT_ON_EXEC_ERROR, errno,\n\t\t _(\"Cannot redirect files for remote shell\"));\n\n\tsys_reset_uid_gid ();\n\n\tif (remote_user)\n\t  execl (remote_shell, remote_shell_basename, remote_host,\n\t\t \"-l\", remote_user, rmt_command, (char *) 0);\n\telse\n\t  execl (remote_shell, remote_shell_basename, remote_host,\n\t\t rmt_command, (char *) 0);\n\n\t/* Bad problems if we get here.  */\n\n\t/* In a previous version, _exit was used here instead of exit.  */\n\terror (EXIT_ON_EXEC_ERROR, errno, _(\"Cannot execute remote shell\"));\n      }\n\n    /* Parent.  */\n\n    close (from_remote[remote_pipe_number][PWRITE]);\n    close (to_remote[remote_pipe_number][PREAD]);\n  }\n#endif /* not WITH_REXEC */\n\n  /* Attempt to open the tape device.  */\n\n  {\n    size_t remote_file_len = strlen (remote_file);\n    char *command_buffer = xmalloc (remote_file_len + 1000);\n    sprintf (command_buffer, \"O%s\\n\", remote_file);\n    encode_oflag (command_buffer + remote_file_len + 2, open_mode);\n    strcat (command_buffer, \"\\n\");\n    if (do_command (remote_pipe_number, command_buffer) == -1\n\t|| get_status (remote_pipe_number) == -1)\n      {\n\tint e = errno;\n\tfree (command_buffer);\n\tfree (file_name_copy);\n\t_rmt_shutdown (remote_pipe_number, e);\n\treturn -1;\n      }\n    free (command_buffer);\n  }\n\n  free (file_name_copy);\n  return remote_pipe_number + bias;\n}",
      "lines": 189,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "rmt_close__": {
      "start_point": [
        551,
        0
      ],
      "end_point": [
        562,
        1
      ],
      "content": "int\nrmt_close__ (int handle)\n{\n  long int status;\n\n  if (do_command (handle, \"C\\n\") == -1)\n    return -1;\n\n  status = get_status (handle);\n  _rmt_shutdown (handle, errno);\n  return status;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "rmt_read__": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "size_t\nrmt_read__ (int handle, char *buffer, size_t length)\n{\n  char command_buffer[COMMAND_BUFFER_SIZE];\n  size_t status;\n  size_t rlen;\n  size_t counter;\n\n  sprintf (command_buffer, \"R%lu\\n\", (unsigned long) length);\n  if (do_command (handle, command_buffer) == -1\n      || (status = get_status (handle)) == SAFE_READ_ERROR\n      || status > length)\n    return SAFE_READ_ERROR;\n\n  for (counter = 0; counter < status; counter += rlen, buffer += rlen)\n    {\n      rlen = safe_read (READ_SIDE (handle), buffer, status - counter);\n      if (rlen == SAFE_READ_ERROR || rlen == 0)\n\t{\n\t  _rmt_shutdown (handle, EIO);\n\t  return SAFE_READ_ERROR;\n\t}\n    }\n\n  return status;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "rmt_write__": {
      "start_point": [
        595,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "size_t\nrmt_write__ (int handle, char *buffer, size_t length)\n{\n  char command_buffer[COMMAND_BUFFER_SIZE];\n  RETSIGTYPE (*pipe_handler) (int);\n  size_t written;\n\n  sprintf (command_buffer, \"W%lu\\n\", (unsigned long) length);\n  if (do_command (handle, command_buffer) == -1)\n    return 0;\n\n  pipe_handler = signal (SIGPIPE, SIG_IGN);\n  written = full_write (WRITE_SIDE (handle), buffer, length);\n  signal (SIGPIPE, pipe_handler);\n  if (written == length)\n    {\n      long int r = get_status (handle);\n      if (r < 0)\n\treturn 0;\n      if (r == length)\n\treturn length;\n      written = r;\n    }\n\n  /* Write error.  */\n\n  _rmt_shutdown (handle, EIO);\n  return written;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    },
    "rmt_lseek__": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "off_t\nrmt_lseek__ (int handle, off_t offset, int whence)\n{\n  char command_buffer[COMMAND_BUFFER_SIZE];\n  char operand_buffer[UINTMAX_STRSIZE_BOUND];\n  uintmax_t u = offset < 0 ? - (uintmax_t) offset : (uintmax_t) offset;\n  char *p = operand_buffer + sizeof operand_buffer;\n\n  *--p = 0;\n  do\n    *--p = '0' + (int) (u % 10);\n  while ((u /= 10) != 0);\n  if (offset < 0)\n    *--p = '-';\n\n  switch (whence)\n    {\n    case SEEK_SET: whence = 0; break;\n    case SEEK_CUR: whence = 1; break;\n    case SEEK_END: whence = 2; break;\n    default: abort ();\n    }\n\n  sprintf (command_buffer, \"L%s\\n%d\\n\", p, whence);\n\n  if (do_command (handle, command_buffer) == -1)\n    return -1;\n\n  return get_status_off (handle);\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "off_t"
      ]
    },
    "rmt_ioctl__": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        750,
        1
      ],
      "content": "int\nrmt_ioctl__ (int handle, int operation, char *argument)\n{\n  switch (operation)\n    {\n    default:\n      errno = EOPNOTSUPP;\n      return -1;\n\n#ifdef MTIOCTOP\n    case MTIOCTOP:\n      {\n\tchar command_buffer[COMMAND_BUFFER_SIZE];\n\tchar operand_buffer[UINTMAX_STRSIZE_BOUND];\n\tuintmax_t u = (((struct mtop *) argument)->mt_count < 0\n\t\t       ? - (uintmax_t) ((struct mtop *) argument)->mt_count\n\t\t       : (uintmax_t) ((struct mtop *) argument)->mt_count);\n\tchar *p = operand_buffer + sizeof operand_buffer;\n\n        *--p = 0;\n\tdo\n\t  *--p = '0' + (int) (u % 10);\n\twhile ((u /= 10) != 0);\n\tif (((struct mtop *) argument)->mt_count < 0)\n\t  *--p = '-';\n\n\t/* MTIOCTOP is the easy one.  Nothing is transferred in binary.  */\n\n\tsprintf (command_buffer, \"I%d\\n%s\\n\",\n\t\t ((struct mtop *) argument)->mt_op, p);\n\tif (do_command (handle, command_buffer) == -1)\n\t  return -1;\n\n\treturn get_status (handle);\n      }\n#endif /* MTIOCTOP */\n\n#ifdef MTIOCGET\n    case MTIOCGET:\n      {\n\tssize_t status;\n\tsize_t counter;\n\n\t/* Grab the status and read it directly into the structure.  This\n\t   assumes that the status buffer is not padded and that 2 shorts\n\t   fit in a long without any word alignment problems; i.e., the\n\t   whole struct is contiguous.  NOTE - this is probably NOT a good\n\t   assumption.  */\n\n\tif (do_command (handle, \"S\") == -1\n\t    || (status = get_status (handle), status == -1))\n\t  return -1;\n\n\tif (status > sizeof (struct mtop))\n\t  {\n\t    errno = EOVERFLOW;\n\t    return -1;\n\t  }\n\n\tfor (; status > 0; status -= counter, argument += counter)\n\t  {\n\t    counter = safe_read (READ_SIDE (handle), argument, status);\n\t    if (counter == SAFE_READ_ERROR || counter == 0)\n\t      {\n\t\t_rmt_shutdown (handle, EIO);\n\t\treturn -1;\n\t      }\n\t  }\n\n\t/* Check for byte position.  mt_type (or mt_model) is a small integer\n\t   field (normally) so we will check its magnitude.  If it is larger\n\t   than 256, we will assume that the bytes are swapped and go through\n\t   and reverse all the bytes.  */\n\n\tif (((struct mtget *) argument)->MTIO_CHECK_FIELD < 256)\n\t  return 0;\n\n\tfor (counter = 0; counter < status; counter += 2)\n\t  {\n\t    char copy = argument[counter];\n\n\t    argument[counter] = argument[counter + 1];\n\t    argument[counter + 1] = copy;\n\t  }\n\n\treturn 0;\n      }\n#endif /* MTIOCGET */\n\n    }\n}",
      "lines": 91,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/lib/stdopen.c": {
    "stdopen": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "bool\nstdopen (void)\n{\n  int fd;\n  bool ok = true;\n\n  for (fd = 0; fd <= 2; fd++)\n    {\n      if (fcntl (fd, F_GETFD) < 0)\n        {\n          if (errno != EBADF)\n            ok = false;\n          else\n            {\n              static const int contrary_mode[]\n                = { O_WRONLY, O_RDONLY, O_RDONLY };\n              int mode = contrary_mode[fd];\n              int new_fd;\n              /* Open /dev/null with the contrary mode so that the typical\n                 read (stdin) or write (stdout, stderr) operation will fail.\n                 With descriptor 0, we can do even better on systems that\n                 have /dev/full, by opening that write-only instead of\n                 /dev/null.  The only drawback is that a write-provoked\n                 failure comes with a misleading errno value, ENOSPC.  */\n              if (mode == O_RDONLY\n                  || (new_fd = open (\"/dev/full\", mode) != fd))\n                new_fd = open (\"/dev/null\", mode);\n              if (new_fd != fd)\n                {\n                  if (0 <= new_fd)\n                    close (new_fd);\n                  ok = false;\n                }\n            }\n        }\n    }\n\n  return ok;\n}",
      "lines": 39,
      "depth": 18,
      "decorators": [
        "bool"
      ]
    }
  },
  "tar/tar-1.30/lib/stdopen.h": {},
  "tar/tar-1.30/lib/system-ioctl.h": {},
  "tar/tar-1.30/lib/system.h": {},
  "tar/tar-1.30/lib/wordsplit.c": {
    "_wsplt_alloc_die": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static void\n_wsplt_alloc_die (struct wordsplit *wsp)\n{\n  wsp->ws_error (_(\"memory exhausted\"));\n  abort ();\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__WORDSPLIT_ATTRIBUTE_FORMAT": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static void __WORDSPLIT_ATTRIBUTE_FORMAT ((__printf__, 1, 2))\n_wsplt_error (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n  fputc ('\\n', stderr);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_wsplt_nomem": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static int\n_wsplt_nomem (struct wordsplit *wsp)\n{\n  errno = ENOMEM;\n  wsp->ws_errno = WRDSE_NOSPACE;\n  if (wsp->ws_flags & WRDSF_ENOMEMABRT)\n    wsp->ws_alloc_die (wsp);\n  if (wsp->ws_flags & WRDSF_SHOWERR)\n    wordsplit_perror (wsp);\n  if (!(wsp->ws_flags & WRDSF_REUSE))\n    wordsplit_free (wsp);\n  wordsplit_free_nodes (wsp);\n  return wsp->ws_errno;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_init0": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static void\nwordsplit_init0 (struct wordsplit *wsp)\n{\n  if (wsp->ws_flags & WRDSF_REUSE)\n    {\n      if (!(wsp->ws_flags & WRDSF_APPEND))\n\twordsplit_free_words (wsp);\n    }\n  else\n    {\n      wsp->ws_wordv = NULL;\n      wsp->ws_wordc = 0;\n      wsp->ws_wordn = 0;\n    }\n\n  wsp->ws_errno = 0;\n  wsp->ws_head = wsp->ws_tail = NULL;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_init": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static int\nwordsplit_init (struct wordsplit *wsp, const char *input, size_t len,\n\t\tint flags)\n{\n  wsp->ws_flags = flags;\n\n  if (!(wsp->ws_flags & WRDSF_ALLOC_DIE))\n    wsp->ws_alloc_die = _wsplt_alloc_die;\n  if (!(wsp->ws_flags & WRDSF_ERROR))\n    wsp->ws_error = _wsplt_error;\n\n  if (!(wsp->ws_flags & WRDSF_NOVAR)\n      && !(wsp->ws_flags & (WRDSF_ENV | WRDSF_GETVAR)))\n    {\n      errno = EINVAL;\n      wsp->ws_errno = WRDSE_USAGE;\n      if (wsp->ws_flags & WRDSF_SHOWERR)\n\twordsplit_perror (wsp);\n      return wsp->ws_errno;\n    }\n\n  if (!(wsp->ws_flags & WRDSF_NOCMD))\n    {\n      errno = EINVAL;\n      wsp->ws_errno = WRDSE_NOSUPP;\n      if (wsp->ws_flags & WRDSF_SHOWERR)\n\twordsplit_perror (wsp);\n      return wsp->ws_errno;\n    }\n\n  if (wsp->ws_flags & WRDSF_SHOWDBG)\n    {\n      if (!(wsp->ws_flags & WRDSF_DEBUG))\n\t{\n\t  if (wsp->ws_flags & WRDSF_ERROR)\n\t    wsp->ws_debug = wsp->ws_error;\n\t  else if (wsp->ws_flags & WRDSF_SHOWERR)\n\t    wsp->ws_debug = _wsplt_error;\n\t  else\n\t    wsp->ws_flags &= ~WRDSF_SHOWDBG;\n\t}\n    }\n\n  wsp->ws_input = input;\n  wsp->ws_len = len;\n\n  if (!(wsp->ws_flags & WRDSF_DOOFFS))\n    wsp->ws_offs = 0;\n\n  if (!(wsp->ws_flags & WRDSF_DELIM))\n    wsp->ws_delim = \" \\t\\n\";\n\n  if (!(wsp->ws_flags & WRDSF_COMMENT))\n    wsp->ws_comment = NULL;\n\n  if (!(wsp->ws_flags & WRDSF_CLOSURE))\n    wsp->ws_closure = NULL;\n\n  wsp->ws_endp = 0;\n\n  wordsplit_init0 (wsp);\n\n  return 0;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloc_space": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "static int\nalloc_space (struct wordsplit *wsp, size_t count)\n{\n  size_t offs = (wsp->ws_flags & WRDSF_DOOFFS) ? wsp->ws_offs : 0;\n  char **ptr;\n  size_t newalloc;\n\n  if (wsp->ws_wordv == NULL)\n    {\n      newalloc = offs + count > ALLOC_INIT ? count : ALLOC_INIT;\n      ptr = calloc (newalloc, sizeof (ptr[0]));\n    }\n  else if (wsp->ws_wordn < offs + wsp->ws_wordc + count)\n    {\n      newalloc = offs + wsp->ws_wordc +\n\t(count > ALLOC_INCR ? count : ALLOC_INCR);\n      ptr = realloc (wsp->ws_wordv, newalloc * sizeof (ptr[0]));\n    }\n  else\n    return 0;\n\n  if (ptr)\n    {\n      wsp->ws_wordn = newalloc;\n      wsp->ws_wordv = ptr;\n    }\n  else\n    return _wsplt_nomem (wsp);\n  return 0;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "the": {
      "start_point": [
        217,
        7
      ],
      "end_point": [
        233,
        1
      ],
      "content": "segment even if it is empty */\n\nstruct wordsplit_node\n{\n  struct wordsplit_node *prev;\t/* Previous element */\n  struct wordsplit_node *next;\t/* Next element */\n  unsigned flags;\t\t/* Node flags */\n  union\n  {\n    struct\n    {\n      size_t beg;\t\t/* Start of word in ws_input */\n      size_t end;\t\t/* End of word in ws_input */\n    } segm;\n    char *word;\n  } v;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": null
    },
    "wsnode_flagstr": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "static const char *\nwsnode_flagstr (int flags)\n{\n  static char retbuf[6];\n  char *p = retbuf;\n\n  if (flags & _WSNF_WORD)\n    *p++ = 'w';\n  else if (flags & _WSNF_NULL)\n    *p++ = 'n';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_QUOTE)\n    *p++ = 'q';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_NOEXPAND)\n    *p++ = 'E';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_JOIN)\n    *p++ = 'j';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_SEXP)\n    *p++ = 's';\n  else\n    *p++ = '-';\n  *p = 0;\n  return retbuf;\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nwsnode_flagstr (int flags)",
        "*"
      ]
    },
    "wsnode_ptr": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "static const char *\nwsnode_ptr (struct wordsplit *wsp, struct wordsplit_node *p)\n{\n  if (p->flags & _WSNF_NULL)\n    return \"\";\n  else if (p->flags & _WSNF_WORD)\n    return p->v.word;\n  else\n    return wsp->ws_input + p->v.segm.beg;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nwsnode_ptr (struct wordsplit *wsp, struct wordsplit_node *p)",
        "*"
      ]
    },
    "wsnode_len": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "static size_t\nwsnode_len (struct wordsplit_node *p)\n{\n  if (p->flags & _WSNF_NULL)\n    return 0;\n  else if (p->flags & _WSNF_WORD)\n    return strlen (p->v.word);\n  else\n    return p->v.segm.end - p->v.segm.beg;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "wsnode_new": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "static int\nwsnode_new (struct wordsplit *wsp, struct wordsplit_node **pnode)\n{\n  struct wordsplit_node *node = calloc (1, sizeof (*node));\n  if (!node)\n    return _wsplt_nomem (wsp);\n  *pnode = node;\n  return 0;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_free": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "static void\nwsnode_free (struct wordsplit_node *p)\n{\n  if (p->flags & _WSNF_WORD)\n    free (p->v.word);\n  free (p);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wsnode_append": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "static void\nwsnode_append (struct wordsplit *wsp, struct wordsplit_node *node)\n{\n  node->next = NULL;\n  node->prev = wsp->ws_tail;\n  if (wsp->ws_tail)\n    wsp->ws_tail->next = node;\n  else\n    wsp->ws_head = node;\n  wsp->ws_tail = node;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wsnode_remove": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "static void\nwsnode_remove (struct wordsplit *wsp, struct wordsplit_node *node)\n{\n  struct wordsplit_node *p;\n\n  p = node->prev;\n  if (p)\n    {\n      p->next = node->next;\n      if (!node->next)\n\tp->flags &= ~_WSNF_JOIN;\n    }\n  else\n    wsp->ws_head = node->next;\n\n  p = node->next;\n  if (p)\n    p->prev = node->prev;\n  else\n    wsp->ws_tail = node->prev;\n\n  node->next = node->prev = NULL;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wsnode_insert": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "static void\nwsnode_insert (struct wordsplit *wsp, struct wordsplit_node *node,\n\t       struct wordsplit_node *anchor, int before)\n{\n  if (!wsp->ws_head)\n    {\n      node->next = node->prev = NULL;\n      wsp->ws_head = wsp->ws_tail = node;\n    }\n  else if (before)\n    {\n      if (anchor->prev)\n\twsnode_insert (wsp, node, anchor->prev, 0);\n      else\n\t{\n\t  node->prev = NULL;\n\t  node->next = anchor;\n\t  anchor->prev = node;\n\t  wsp->ws_head = node;\n\t}\n    }\n  else\n    {\n      struct wordsplit_node *p;\n\n      p = anchor->next;\n      if (p)\n\tp->prev = node;\n      else\n\twsp->ws_tail = node;\n      node->next = p;\n      node->prev = anchor;\n      anchor->next = node;\n    }\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_add_segm": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "static int\nwordsplit_add_segm (struct wordsplit *wsp, size_t beg, size_t end, int flg)\n{\n  struct wordsplit_node *node;\n  int rc;\n\n  if (end == beg && !(flg & _WSNF_EMPTYOK))\n    return 0;\n  rc = wsnode_new (wsp, &node);\n  if (rc)\n    return rc;\n  node->flags = flg & ~(_WSNF_WORD | _WSNF_EMPTYOK);\n  node->v.segm.beg = beg;\n  node->v.segm.end = end;\n  wsnode_append (wsp, node);\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_free_nodes": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "static void\nwordsplit_free_nodes (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p;)\n    {\n      struct wordsplit_node *next = p->next;\n      wsnode_free (p);\n      p = next;\n    }\n  wsp->ws_head = wsp->ws_tail = NULL;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_dump_nodes": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "static void\nwordsplit_dump_nodes (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n  int n = 0;\n\n  for (p = wsp->ws_head, n = 0; p; p = p->next, n++)\n    {\n      if (p->flags & _WSNF_WORD)\n\twsp->ws_debug (\"%4d: %p: %#04x (%s):%s;\",\n\t\t       n, p, p->flags, wsnode_flagstr (p->flags), p->v.word);\n      else\n\twsp->ws_debug (\"%4d: %p: %#04x (%s):%.*s;\",\n\t\t       n, p, p->flags, wsnode_flagstr (p->flags),\n\t\t       (int) (p->v.segm.end - p->v.segm.beg),\n\t\t       wsp->ws_input + p->v.segm.beg);\n    }\n}",
      "lines": 18,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "coalesce_segment": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "static int\ncoalesce_segment (struct wordsplit *wsp, struct wordsplit_node *node)\n{\n  struct wordsplit_node *p, *end;\n  size_t len = 0;\n  char *buf, *cur;\n  int stop;\n\n  for (p = node; p && (p->flags & _WSNF_JOIN); p = p->next)\n    {\n      len += wsnode_len (p);\n    }\n  len += wsnode_len (p);\n  end = p;\n\n  buf = malloc (len + 1);\n  if (!buf)\n    return _wsplt_nomem (wsp);\n  cur = buf;\n\n  p = node;\n  for (stop = 0; !stop;)\n    {\n      struct wordsplit_node *next = p->next;\n      const char *str = wsnode_ptr (wsp, p);\n      size_t slen = wsnode_len (p);\n\n      memcpy (cur, str, slen);\n      cur += slen;\n      if (p != node)\n\t{\n\t  wsnode_remove (wsp, p);\n\t  stop = p == end;\n\t  wsnode_free (p);\n\t}\n      p = next;\n    }\n\n  *cur = 0;\n\n  node->flags &= ~_WSNF_JOIN;\n\n  if (node->flags & _WSNF_WORD)\n    free (node->v.word);\n  else\n    node->flags |= _WSNF_WORD;\n  node->v.word = buf;\n  return 0;\n}",
      "lines": 49,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_quoteremoval": {
      "start_point": [
        480,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "static int\nwsnode_quoteremoval (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n  void (*uqfn) (char *, const char *, size_t) =\n    (wsp->ws_flags & WRDSF_CESCAPES) ?\n    wordsplit_c_unquote_copy : wordsplit_sh_unquote_copy;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      const char *str = wsnode_ptr (wsp, p);\n      size_t slen = wsnode_len (p);\n      int unquote;\n\n      if (wsp->ws_flags & WRDSF_QUOTE)\n\t{\n\t  unquote = !(p->flags & _WSNF_NOEXPAND);\n\t}\n      else\n\tunquote = 0;\n\n      if (unquote)\n\t{\n\t  if (!(p->flags & _WSNF_WORD))\n\t    {\n\t      char *newstr = malloc (slen + 1);\n\t      if (!newstr)\n\t\treturn _wsplt_nomem (wsp);\n\t      memcpy (newstr, str, slen);\n\t      newstr[slen] = 0;\n\t      p->v.word = newstr;\n\t      p->flags |= _WSNF_WORD;\n\t    }\n\n\t  if (wsp->ws_flags & WRDSF_ESCAPE)\n\t    wordsplit_general_unquote_copy (p->v.word, str, slen,\n\t\t\t\t            wsp->ws_escape);\n\t  else\n\t    uqfn (p->v.word, str, slen);\n\t}\n    }\n  return 0;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_coalesce": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        536,
        1
      ],
      "content": "static int\nwsnode_coalesce (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      if (p->flags & _WSNF_JOIN)\n\tif (coalesce_segment (wsp, p))\n\t  return 1;\n    }\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_finish": {
      "start_point": [
        538,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "static int\nwordsplit_finish (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n  size_t n;\n\n  n = 0;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    n++;\n\n  if (alloc_space (wsp, n + 1))\n    return 1;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      const char *str = wsnode_ptr (wsp, p);\n      size_t slen = wsnode_len (p);\n      char *newstr = malloc (slen + 1);\n\n      /* Assign newstr first, even if it is NULL.  This way\n         wordsplit_free will work even if we return\n         nomem later. */\n      wsp->ws_wordv[wsp->ws_offs + wsp->ws_wordc] = newstr;\n      if (!newstr)\n\treturn _wsplt_nomem (wsp);\n      memcpy (newstr, str, slen);\n      newstr[slen] = 0;\n\n      wsp->ws_wordc++;\n\n    }\n  wsp->ws_wordv[wsp->ws_offs + wsp->ws_wordc] = NULL;\n  return 0;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "node_split_prefix": {
      "start_point": [
        576,
        0
      ],
      "end_point": [
        608,
        1
      ],
      "content": "static int\nnode_split_prefix (struct wordsplit *wsp,\n\t\t   struct wordsplit_node **ptail,\n\t\t   struct wordsplit_node *node,\n\t\t   size_t beg, size_t len, int flg)\n{\n  struct wordsplit_node *newnode;\n\n  if (len == 0)\n    return 0;\n  if (wsnode_new (wsp, &newnode))\n    return 1;\n  wsnode_insert (wsp, newnode, *ptail, 0);\n  if (node->flags & _WSNF_WORD)\n    {\n      const char *str = wsnode_ptr (wsp, node);\n      char *newstr = malloc (len + 1);\n      if (!newstr)\n\treturn _wsplt_nomem (wsp);\n      memcpy (newstr, str + beg, len);\n      newstr[len] = 0;\n      newnode->flags = _WSNF_WORD;\n      newnode->v.word = newstr;\n    }\n  else\n    {\n      newnode->v.segm.beg = node->v.segm.beg + beg;\n      newnode->v.segm.end = newnode->v.segm.beg + len;\n    }\n  newnode->flags |= flg;\n  *ptail = newnode;\n  return 0;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_closing_cbrace": {
      "start_point": [
        610,
        0
      ],
      "end_point": [
        660,
        1
      ],
      "content": "static int\nfind_closing_cbrace (const char *str, size_t i, size_t len, size_t * poff)\n{\n  enum\n  { st_init, st_squote, st_dquote } state = st_init;\n  size_t level = 1;\n\n  for (; i < len; i++)\n    {\n      switch (state)\n\t{\n\tcase st_init:\n\t  switch (str[i])\n\t    {\n\t    case '{':\n\t      level++;\n\t      break;\n\n\t    case '}':\n\t      if (--level == 0)\n\t\t{\n\t\t  *poff = i;\n\t\t  return 0;\n\t\t}\n\t      break;\n\n\t    case '\"':\n\t      state = st_dquote;\n\t      break;\n\n\t    case '\\'':\n\t      state = st_squote;\n\t      break;\n\t    }\n\t  break;\n\n\tcase st_squote:\n\t  if (str[i] == '\\'')\n\t    state = st_init;\n\t  break;\n\n\tcase st_dquote:\n\t  if (str[i] == '\\\\')\n\t    i++;\n\t  else if (str[i] == '\"')\n\t    state = st_init;\n\t  break;\n\t}\n    }\n  return 1;\n}",
      "lines": 51,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_find_env": {
      "start_point": [
        662,
        0
      ],
      "end_point": [
        700,
        1
      ],
      "content": "static const char *\nwordsplit_find_env (struct wordsplit *wsp, const char *name, size_t len)\n{\n  size_t i;\n\n  if (!(wsp->ws_flags & WRDSF_ENV))\n    return NULL;\n\n  if (wsp->ws_flags & WRDSF_ENV_KV)\n    {\n      /* A key-value pair environment */\n      for (i = 0; wsp->ws_env[i]; i++)\n\t{\n\t  size_t elen = strlen (wsp->ws_env[i]);\n\t  if (elen == len && memcmp (wsp->ws_env[i], name, elen) == 0)\n\t    return wsp->ws_env[i + 1];\n\t  /* Skip the value.  Break the loop if it is NULL. */\n\t  i++;\n\t  if (wsp->ws_env[i] == NULL)\n\t    break;\n\t}\n    }\n  else\n    {\n      /* Usual (A=B) environment. */\n      for (i = 0; wsp->ws_env[i]; i++)\n\t{\n\t  size_t j;\n\t  const char *var = wsp->ws_env[i];\n\n\t  for (j = 0; j < len; j++)\n\t    if (name[j] != var[j])\n\t      break;\n\t  if (j == len && var[j] == '=')\n\t    return var + j + 1;\n\t}\n    }\n  return NULL;\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nwordsplit_find_env (struct wordsplit *wsp, const char *name, size_t len)",
        "*"
      ]
    },
    "expvar": {
      "start_point": [
        702,
        0
      ],
      "end_point": [
        875,
        1
      ],
      "content": "static int\nexpvar (struct wordsplit *wsp, const char *str, size_t len,\n\tstruct wordsplit_node **ptail, const char **pend, int flg)\n{\n  size_t i = 0;\n  const char *defstr = NULL;\n  const char *value;\n  const char *vptr;\n  struct wordsplit_node *newnode;\n  const char *start = str - 1;\n\n  if (ISALPHA (str[0]) || str[0] == '_')\n    {\n      for (i = 1; i < len; i++)\n\tif (!(ISALNUM (str[i]) || str[i] == '_'))\n\t  break;\n      *pend = str + i - 1;\n    }\n  else if (str[0] == '{')\n    {\n      str++;\n      len--;\n      for (i = 1; i < len; i++)\n\tif (str[i] == '}' || str[i] == ':')\n\t  break;\n      if (str[i] == ':')\n\t{\n\t  size_t j;\n\n\t  defstr = str + i + 1;\n\t  if (find_closing_cbrace (str, i + 1, len, &j))\n\t    {\n\t      wsp->ws_errno = WRDSE_CBRACE;\n\t      return 1;\n\t    }\n\t  *pend = str + j;\n\t}\n      else if (str[i] == '}')\n\t{\n\t  defstr = NULL;\n\t  *pend = str + i;\n\t}\n      else\n\t{\n\t  wsp->ws_errno = WRDSE_CBRACE;\n\t  return 1;\n\t}\n    }\n  else\n    {\n      if (wsnode_new (wsp, &newnode))\n\treturn 1;\n      wsnode_insert (wsp, newnode, *ptail, 0);\n      *ptail = newnode;\n      newnode->flags = _WSNF_WORD | flg;\n      newnode->v.word = malloc (3);\n      if (!newnode->v.word)\n\treturn _wsplt_nomem (wsp);\n      newnode->v.word[0] = '$';\n      newnode->v.word[1] = str[0];\n      newnode->v.word[2] = 0;\n      *pend = str;\n      return 0;\n    }\n\n  /* Actually expand the variable */\n  /* str - start of the variable name\n     i   - its length\n     defstr - default replacement str */\n\n  vptr = wordsplit_find_env (wsp, str, i);\n  if (vptr)\n    {\n      value = strdup (vptr);\n      if (!value)\n\treturn _wsplt_nomem (wsp);\n    }\n  else if (wsp->ws_flags & WRDSF_GETVAR)\n    value = wsp->ws_getvar (str, i, wsp->ws_closure);\n  else if (wsp->ws_flags & WRDSF_UNDEF)\n    {\n      wsp->ws_errno = WRDSE_UNDEF;\n      if (wsp->ws_flags & WRDSF_SHOWERR)\n\twordsplit_perror (wsp);\n      return 1;\n    }\n  else\n    {\n      if (wsp->ws_flags & WRDSF_WARNUNDEF)\n\twsp->ws_error (_(\"warning: undefined variable `%.*s'\"), (int) i, str);\n      if (wsp->ws_flags & WRDSF_KEEPUNDEF)\n\tvalue = NULL;\n      else\n\tvalue = \"\";\n    }\n\n  /* FIXME: handle defstr */\n  (void) defstr;\n\n  if (value)\n    {\n      if (flg & _WSNF_QUOTE)\n\t{\n\t  if (wsnode_new (wsp, &newnode))\n\t    return 1;\n\t  wsnode_insert (wsp, newnode, *ptail, 0);\n\t  *ptail = newnode;\n\t  newnode->flags = _WSNF_WORD | _WSNF_NOEXPAND | flg;\n\t  newnode->v.word = strdup (value);\n\t  if (!newnode->v.word)\n\t    return _wsplt_nomem (wsp);\n\t}\n      else if (*value == 0)\n\t{\n\t  /* Empty string is a special case */\n\t  if (wsnode_new (wsp, &newnode))\n\t    return 1;\n\t  wsnode_insert (wsp, newnode, *ptail, 0);\n\t  *ptail = newnode;\n\t  newnode->flags = _WSNF_NULL;\n\t}\n      else\n\t{\n\t  struct wordsplit ws;\n\t  int i;\n\n\t  ws.ws_delim = wsp->ws_delim;\n\t  if (wordsplit (value, &ws,\n\t\t\t WRDSF_NOVAR | WRDSF_NOCMD | WRDSF_DELIM | WRDSF_WS))\n\t    {\n\t      wordsplit_free (&ws);\n\t      return 1;\n\t    }\n\t  for (i = 0; i < ws.ws_wordc; i++)\n\t    {\n\t      if (wsnode_new (wsp, &newnode))\n\t\treturn 1;\n\t      wsnode_insert (wsp, newnode, *ptail, 0);\n\t      *ptail = newnode;\n\t      newnode->flags = _WSNF_WORD |\n\t\t_WSNF_NOEXPAND |\n\t\t(i + 1 < ws.ws_wordc ? (flg & ~_WSNF_JOIN) : flg);\n\t      newnode->v.word = strdup (ws.ws_wordv[i]);\n\t      if (!newnode->v.word)\n\t\treturn _wsplt_nomem (wsp);\n\t    }\n\t  wordsplit_free (&ws);\n\t}\n    }\n  else if (wsp->ws_flags & WRDSF_KEEPUNDEF)\n    {\n      size_t size = *pend - start + 1;\n\n      if (wsnode_new (wsp, &newnode))\n\treturn 1;\n      wsnode_insert (wsp, newnode, *ptail, 0);\n      *ptail = newnode;\n      newnode->flags = _WSNF_WORD | _WSNF_NOEXPAND | flg;\n      newnode->v.word = malloc (size + 1);\n      if (!newnode->v.word)\n\treturn _wsplt_nomem (wsp);\n      memcpy (newnode->v.word, start, size);\n      newnode->v.word[size] = 0;\n    }\n  else\n    {\n      if (wsnode_new (wsp, &newnode))\n\treturn 1;\n      wsnode_insert (wsp, newnode, *ptail, 0);\n      *ptail = newnode;\n      newnode->flags = _WSNF_NULL;\n    }\n  return 0;\n}",
      "lines": 174,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "node_expand_vars": {
      "start_point": [
        877,
        0
      ],
      "end_point": [
        924,
        1
      ],
      "content": "static int\nnode_expand_vars (struct wordsplit *wsp, struct wordsplit_node *node)\n{\n  const char *str = wsnode_ptr (wsp, node);\n  size_t slen = wsnode_len (node);\n  const char *end = str + slen;\n  const char *p;\n  size_t off = 0;\n  struct wordsplit_node *tail = node;\n\n  for (p = str; p < end; p++)\n    {\n      if (*p == '\\\\')\n\t{\n\t  p++;\n\t  continue;\n\t}\n      if (*p == '$')\n\t{\n\t  size_t n = p - str;\n\n\t  if (tail != node)\n\t    tail->flags |= _WSNF_JOIN;\n\t  if (node_split_prefix (wsp, &tail, node, off, n, _WSNF_JOIN))\n\t    return 1;\n\t  p++;\n\t  if (expvar (wsp, p, slen - n, &tail, &p,\n\t\t      node->flags & (_WSNF_JOIN | _WSNF_QUOTE)))\n\t    return 1;\n\t  off += p - str + 1;\n\t  str = p + 1;\n\t}\n    }\n  if (p > str)\n    {\n      if (tail != node)\n\ttail->flags |= _WSNF_JOIN;\n      if (node_split_prefix (wsp, &tail, node, off, p - str,\n\t\t\t     node->flags & _WSNF_JOIN))\n\treturn 1;\n    }\n  if (tail != node)\n    {\n      wsnode_remove (wsp, node);\n      wsnode_free (node);\n    }\n  return 0;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_nullelim": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        942,
        1
      ],
      "content": "static void\nwsnode_nullelim (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p;)\n    {\n      struct wordsplit_node *next = p->next;\n      if (p->flags & _WSNF_NULL)\n\t{\n\t  wsnode_remove (wsp, p);\n\t  wsnode_free (p);\n\t}\n      p = next;\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_varexp": {
      "start_point": [
        944,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "static int\nwordsplit_varexp (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p;)\n    {\n      struct wordsplit_node *next = p->next;\n      if (!(p->flags & _WSNF_NOEXPAND))\n\tif (node_expand_vars (wsp, p))\n\t  return 1;\n      p = next;\n    }\n\n  wsnode_nullelim (wsp);\n  return 0;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_trimws": {
      "start_point": [
        965,
        0
      ],
      "end_point": [
        991,
        1
      ],
      "content": "static void\nwordsplit_trimws (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      size_t n;\n\n      if (p->flags & _WSNF_QUOTE)\n\tcontinue;\n\n      /* Skip leading whitespace: */\n      for (n = p->v.segm.beg; n < p->v.segm.end && ISWS (wsp->ws_input[n]);\n\t   n++)\n\t;\n      p->v.segm.beg = n;\n      /* Trim trailing whitespace */\n      for (n = p->v.segm.end;\n\t   n > p->v.segm.beg && ISWS (wsp->ws_input[n - 1]); n--);\n      p->v.segm.end = n;\n      if (p->v.segm.beg == p->v.segm.end)\n\tp->flags |= _WSNF_NULL;\n    }\n\n  wsnode_nullelim (wsp);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "skip_sed_expr": {
      "start_point": [
        993,
        0
      ],
      "end_point": [
        1024,
        1
      ],
      "content": "static int\nskip_sed_expr (const char *command, size_t i, size_t len)\n{\n  int state;\n\n  do\n    {\n      int delim;\n\n      if (command[i] == ';')\n\ti++;\n      if (!(command[i] == 's' && i + 3 < len && ISPUNCT (command[i + 1])))\n\tbreak;\n\n      delim = command[++i];\n      state = 1;\n      for (i++; i < len; i++)\n\t{\n\t  if (state == 3)\n\t    {\n\t      if (command[i] == delim || !ISALNUM (command[i]))\n\t\tbreak;\n\t    }\n\t  else if (command[i] == '\\\\')\n\t    i++;\n\t  else if (command[i] == delim)\n\t    state++;\n\t}\n    }\n  while (state == 3 && i < len && command[i] == ';');\n  return i;\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "skip_delim": {
      "start_point": [
        1026,
        0
      ],
      "end_point": [
        1053,
        1
      ],
      "content": "static size_t\nskip_delim (struct wordsplit *wsp)\n{\n  size_t start = wsp->ws_endp;\n  if (wsp->ws_flags & WRDSF_SQUEEZE_DELIMS)\n    {\n      if ((wsp->ws_flags & WRDSF_RETURN_DELIMS) &&\n\t  ISDELIM (wsp, wsp->ws_input[start]))\n\t{\n\t  int delim = wsp->ws_input[start];\n\t  do\n\t    start++;\n\t  while (start < wsp->ws_len && delim == wsp->ws_input[start]);\n\t}\n      else\n\t{\n\t  do\n\t    start++;\n\t  while (start < wsp->ws_len && ISDELIM (wsp, wsp->ws_input[start]));\n\t}\n      start--;\n    }\n\n  if (!(wsp->ws_flags & WRDSF_RETURN_DELIMS))\n    start++;\n\n  return start;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "scan_qstring": {
      "start_point": [
        1059,
        0
      ],
      "end_point": [
        1088,
        1
      ],
      "content": "static int\nscan_qstring (struct wordsplit *wsp, size_t start, size_t * end)\n{\n  size_t j;\n  const char *command = wsp->ws_input;\n  size_t len = wsp->ws_len;\n  char q = command[start];\n\n  for (j = start + 1; j < len && command[j] != q; j++)\n    if (q == '\"' && command[j] == '\\\\')\n      j++;\n  if (j < len && command[j] == q)\n    {\n      int flags = _WSNF_QUOTE | _WSNF_EMPTYOK;\n      if (q == '\\'')\n\tflags |= _WSNF_NOEXPAND;\n      if (wordsplit_add_segm (wsp, start + 1, j, flags))\n\treturn _WRDS_ERR;\n      *end = j;\n    }\n  else\n    {\n      wsp->ws_endp = start;\n      wsp->ws_errno = WRDSE_QUOTE;\n      if (wsp->ws_flags & WRDSF_SHOWERR)\n\twordsplit_perror (wsp);\n      return _WRDS_ERR;\n    }\n  return 0;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_word": {
      "start_point": [
        1090,
        0
      ],
      "end_point": [
        1175,
        1
      ],
      "content": "static int\nscan_word (struct wordsplit *wsp, size_t start)\n{\n  size_t len = wsp->ws_len;\n  const char *command = wsp->ws_input;\n  const char *comment = wsp->ws_comment;\n  int join = 0;\n  int flags = 0;\n\n  size_t i = start;\n\n  if (i >= len)\n    {\n      wsp->ws_errno = WRDSE_EOF;\n      return _WRDS_EOF;\n    }\n\n  start = i;\n\n  if (wsp->ws_flags & WRDSF_SED_EXPR\n      && command[i] == 's' && i + 3 < len && ISPUNCT (command[i + 1]))\n    {\n      flags = _WSNF_SEXP;\n      i = skip_sed_expr (command, i, len);\n    }\n  else if (!ISDELIM (wsp, command[i]))\n    {\n      while (i < len)\n\t{\n\t  if (comment && strchr (comment, command[i]) != NULL)\n\t    {\n\t      size_t j;\n\t      for (j = i + 1; j < len && command[j] != '\\n'; j++)\n\t\t;\n\t      if (wordsplit_add_segm (wsp, start, i, 0))\n\t\treturn _WRDS_ERR;\n\t      wsp->ws_endp = j;\n\t      return _WRDS_OK;\n\t    }\n\n\t  if (wsp->ws_flags & WRDSF_QUOTE)\n\t    {\n\t      if (command[i] == '\\\\')\n\t\t{\n\t\t  if (++i == len)\n\t\t    break;\n\t\t  i++;\n\t\t  continue;\n\t\t}\n\n\t      if (((wsp->ws_flags & WRDSF_SQUOTE) && command[i] == '\\'') ||\n\t\t  ((wsp->ws_flags & WRDSF_DQUOTE) && command[i] == '\"'))\n\t\t{\n\t\t  if (join && wsp->ws_tail)\n\t\t    wsp->ws_tail->flags |= _WSNF_JOIN;\n\t\t  if (wordsplit_add_segm (wsp, start, i, _WSNF_JOIN))\n\t\t    return _WRDS_ERR;\n\t\t  if (scan_qstring (wsp, i, &i))\n\t\t    return _WRDS_ERR;\n\t\t  start = i + 1;\n\t\t  join = 1;\n\t\t}\n\t    }\n\n\t  if (ISDELIM (wsp, command[i]))\n\t    break;\n\t  else\n\t    i++;\n\t}\n    }\n  else if (wsp->ws_flags & WRDSF_RETURN_DELIMS)\n    {\n      i++;\n    }\n  else if (!(wsp->ws_flags & WRDSF_SQUEEZE_DELIMS))\n    flags |= _WSNF_EMPTYOK;\n\n  if (join && i > start && wsp->ws_tail)\n    wsp->ws_tail->flags |= _WSNF_JOIN;\n  if (wordsplit_add_segm (wsp, start, i, flags))\n    return _WRDS_ERR;\n  wsp->ws_endp = i;\n  if (wsp->ws_flags & WRDSF_INCREMENTAL)\n    return _WRDS_EOF;\n  return _WRDS_OK;\n}",
      "lines": 86,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_c_unquote_char": {
      "start_point": [
        1179,
        0
      ],
      "end_point": [
        1190,
        1
      ],
      "content": "int\nwordsplit_c_unquote_char (int c)\n{\n  char *p;\n\n  for (p = quote_transtab; *p; p += 2)\n    {\n      if (*p == c)\n\treturn p[1];\n    }\n  return c;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "wordsplit_c_quote_char": {
      "start_point": [
        1192,
        0
      ],
      "end_point": [
        1204,
        1
      ],
      "content": "int\nwordsplit_c_quote_char (int c)\n{\n  char *p;\n\n  for (p = quote_transtab + sizeof (quote_transtab) - 2;\n       p > quote_transtab; p -= 2)\n    {\n      if (*p == c)\n\treturn p[-1];\n    }\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "xtonum": {
      "start_point": [
        1209,
        0
      ],
      "end_point": [
        1223,
        1
      ],
      "content": "static int\nxtonum (int *pval, const char *src, int base, int cnt)\n{\n  int i, val;\n\n  for (i = 0, val = 0; i < cnt; i++, src++)\n    {\n      int n = *(unsigned char *) src;\n      if (n > 127 || (n = to_num (n)) >= base)\n\tbreak;\n      val = val * base + n;\n    }\n  *pval = val;\n  return i;\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_c_quoted_length": {
      "start_point": [
        1225,
        0
      ],
      "end_point": [
        1253,
        1
      ],
      "content": "size_t\nwordsplit_c_quoted_length (const char *str, int quote_hex, int *quote)\n{\n  size_t len = 0;\n\n  *quote = 0;\n  for (; *str; str++)\n    {\n      if (strchr (\" \\\"\", *str))\n\t*quote = 1;\n\n      if (*str == ' ')\n\tlen++;\n      else if (*str == '\"')\n\tlen += 2;\n      else if (*str != '\\t' && *str != '\\\\' && ISPRINT (*str))\n\tlen++;\n      else if (quote_hex)\n\tlen += 3;\n      else\n\t{\n\t  if (wordsplit_c_quote_char (*str) != -1)\n\t    len += 2;\n\t  else\n\t    len += 4;\n\t}\n    }\n  return len;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "size_t"
      ]
    },
    "wordsplit_general_unquote_copy": {
      "start_point": [
        1255,
        0
      ],
      "end_point": [
        1268,
        1
      ],
      "content": "void\nwordsplit_general_unquote_copy (char *dst, const char *src, size_t n,\n\t\t\t\t   const char *escapable)\n{\n  int i;\n\n  for (i = 0; i < n;)\n    {\n      if (src[i] == '\\\\' && i < n && strchr (escapable, src[i + 1]))\n\ti++;\n      *dst++ = src[i++];\n    }\n  *dst = 0;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_sh_unquote_copy": {
      "start_point": [
        1270,
        0
      ],
      "end_point": [
        1282,
        1
      ],
      "content": "void\nwordsplit_sh_unquote_copy (char *dst, const char *src, size_t n)\n{\n  int i;\n\n  for (i = 0; i < n;)\n    {\n      if (src[i] == '\\\\')\n\ti++;\n      *dst++ = src[i++];\n    }\n  *dst = 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_c_unquote_copy": {
      "start_point": [
        1284,
        0
      ],
      "end_point": [
        1347,
        1
      ],
      "content": "void\nwordsplit_c_unquote_copy (char *dst, const char *src, size_t n)\n{\n  int i = 0;\n  int c;\n\n  while (i < n)\n    {\n      if (src[i] == '\\\\')\n\t{\n\t  ++i;\n\t  if (src[i] == 'x' || src[i] == 'X')\n\t    {\n\t      if (n - i < 2)\n\t\t{\n\t\t  *dst++ = '\\\\';\n\t\t  *dst++ = src[i++];\n\t\t}\n\t      else\n\t\t{\n\t\t  int off = xtonum (&c, src + i + 1,\n\t\t\t\t    16, 2);\n\t\t  if (off == 0)\n\t\t    {\n\t\t      *dst++ = '\\\\';\n\t\t      *dst++ = src[i++];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst++ = c;\n\t\t      i += off + 1;\n\t\t    }\n\t\t}\n\t    }\n\t  else if ((unsigned char) src[i] < 128 && ISDIGIT (src[i]))\n\t    {\n\t      if (n - i < 1)\n\t\t{\n\t\t  *dst++ = '\\\\';\n\t\t  *dst++ = src[i++];\n\t\t}\n\t      else\n\t\t{\n\t\t  int off = xtonum (&c, src + i, 8, 3);\n\t\t  if (off == 0)\n\t\t    {\n\t\t      *dst++ = '\\\\';\n\t\t      *dst++ = src[i++];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst++ = c;\n\t\t      i += off;\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    *dst++ = wordsplit_c_unquote_char (src[i++]);\n\t}\n      else\n\t*dst++ = src[i++];\n    }\n  *dst = 0;\n}",
      "lines": 64,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_c_quote_copy": {
      "start_point": [
        1349,
        0
      ],
      "end_point": [
        1386,
        1
      ],
      "content": "void\nwordsplit_c_quote_copy (char *dst, const char *src, int quote_hex)\n{\n  for (; *src; src++)\n    {\n      if (*src == '\"')\n\t{\n\t  *dst++ = '\\\\';\n\t  *dst++ = *src;\n\t}\n      else if (*src != '\\t' && *src != '\\\\' && ISPRINT (*src))\n\t*dst++ = *src;\n      else\n\t{\n\t  char tmp[4];\n\n\t  if (quote_hex)\n\t    {\n\t      snprintf (tmp, sizeof tmp, \"%%%02X\", *(unsigned char *) src);\n\t      memcpy (dst, tmp, 3);\n\t      dst += 3;\n\t    }\n\t  else\n\t    {\n\t      int c = wordsplit_c_quote_char (*src);\n\t      *dst++ = '\\\\';\n\t      if (c != -1)\n\t\t*dst++ = c;\n\t      else\n\t\t{\n\t\t  snprintf (tmp, sizeof tmp, \"%03o\", *(unsigned char *) src);\n\t\t  memcpy (dst, tmp, 3);\n\t\t  dst += 3;\n\t\t}\n\t    }\n\t}\n    }\n}",
      "lines": 38,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_process_list": {
      "start_point": [
        1388,
        0
      ],
      "end_point": [
        1463,
        1
      ],
      "content": "static int\nwordsplit_process_list (struct wordsplit *wsp, size_t start)\n{\n  if (wsp->ws_flags & WRDSF_NOSPLIT)\n    {\n      /* Treat entire input as a quoted argument */\n      if (wordsplit_add_segm (wsp, start, wsp->ws_len, _WSNF_QUOTE))\n\treturn wsp->ws_errno;\n    }\n  else\n    {\n      int rc;\n\n      while ((rc = scan_word (wsp, start)) == _WRDS_OK)\n\tstart = skip_delim (wsp);\n      /* Make sure tail element is not joinable */\n      if (wsp->ws_tail)\n\twsp->ws_tail->flags &= ~_WSNF_JOIN;\n      if (rc == _WRDS_ERR)\n\treturn wsp->ws_errno;\n    }\n\n  if (wsp->ws_flags & WRDSF_SHOWDBG)\n    {\n      wsp->ws_debug (\"Initial list:\");\n      wordsplit_dump_nodes (wsp);\n    }\n\n  if (wsp->ws_flags & WRDSF_WS)\n    {\n      /* Trim leading and trailing whitespace */\n      wordsplit_trimws (wsp);\n      if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t{\n\t  wsp->ws_debug (\"After WS trimming:\");\n\t  wordsplit_dump_nodes (wsp);\n\t}\n    }\n\n  /* Expand variables (FIXME: & commands) */\n  if (!(wsp->ws_flags & WRDSF_NOVAR))\n    {\n      if (wordsplit_varexp (wsp))\n\t{\n\t  wordsplit_free_nodes (wsp);\n\t  return wsp->ws_errno;\n\t}\n      if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t{\n\t  wsp->ws_debug (\"Expanded list:\");\n\t  wordsplit_dump_nodes (wsp);\n\t}\n    }\n\n  do\n    {\n      if (wsnode_quoteremoval (wsp))\n\tbreak;\n      if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t{\n\t  wsp->ws_debug (\"After quote removal:\");\n\t  wordsplit_dump_nodes (wsp);\n\t}\n\n      if (wsnode_coalesce (wsp))\n\tbreak;\n\n      if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t{\n\t  wsp->ws_debug (\"Coalesced list:\");\n\t  wordsplit_dump_nodes (wsp);\n\t}\n    }\n  while (0);\n  return wsp->ws_errno;\n}",
      "lines": 76,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_len": {
      "start_point": [
        1465,
        0
      ],
      "end_point": [
        1531,
        1
      ],
      "content": "int\nwordsplit_len (const char *command, size_t length, struct wordsplit *wsp,\n               int flags)\n{\n  int rc;\n  size_t start;\n  const char *cmdptr;\n  size_t cmdlen;\n\n  if (!command)\n    {\n      if (!(flags & WRDSF_INCREMENTAL))\n\treturn EINVAL;\n\n      start = skip_delim (wsp);\n      if (wsp->ws_endp == wsp->ws_len)\n\t{\n\t  wsp->ws_errno = WRDSE_NOINPUT;\n\t  if (wsp->ws_flags & WRDSF_SHOWERR)\n\t    wordsplit_perror (wsp);\n\t  return wsp->ws_errno;\n\t}\n\n      cmdptr = wsp->ws_input + wsp->ws_endp;\n      cmdlen = wsp->ws_len - wsp->ws_endp;\n      wsp->ws_flags |= WRDSF_REUSE;\n      wordsplit_init0 (wsp);\n    }\n  else\n    {\n      cmdptr = command;\n      cmdlen = length;\n      start = 0;\n      rc = wordsplit_init (wsp, cmdptr, cmdlen, flags);\n      if (rc)\n\treturn rc;\n    }\n\n  if (wsp->ws_flags & WRDSF_SHOWDBG)\n    wsp->ws_debug (\"Input:%.*s;\", (int) cmdlen, cmdptr);\n\n  rc = wordsplit_process_list (wsp, start);\n  if (rc == 0 && (flags & WRDSF_INCREMENTAL))\n    {\n      while (!wsp->ws_head && wsp->ws_endp < wsp->ws_len)\n\t{\n\t  start = skip_delim (wsp);\n\t  if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t    {\n\t      cmdptr = wsp->ws_input + wsp->ws_endp;\n\t      cmdlen = wsp->ws_len - wsp->ws_endp;\n\t      wsp->ws_debug (\"Restart:%.*s;\", (int) cmdlen, cmdptr);\n\t    }\n\t  rc = wordsplit_process_list (wsp, start);\n\t  if (rc)\n\t    break;\n\t}\n    }\n  if (rc)\n    {\n      wordsplit_free_nodes (wsp);\n      return rc;\n    }\n  wordsplit_finish (wsp);\n  wordsplit_free_nodes (wsp);\n  return wsp->ws_errno;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "wordsplit": {
      "start_point": [
        1533,
        0
      ],
      "end_point": [
        1538,
        1
      ],
      "content": "int\nwordsplit (const char *command, struct wordsplit *ws, int flags)\n{\n  return wordsplit_len (command, command ? strlen (command) : 0, ws,\n\t\t\t   flags);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "wordsplit_free_words": {
      "start_point": [
        1540,
        0
      ],
      "end_point": [
        1555,
        1
      ],
      "content": "void\nwordsplit_free_words (struct wordsplit *ws)\n{\n  size_t i;\n\n  for (i = 0; i < ws->ws_wordc; i++)\n    {\n      char *p = ws->ws_wordv[ws->ws_offs + i];\n      if (p)\n\t{\n\t  free (p);\n\t  ws->ws_wordv[ws->ws_offs + i] = NULL;\n\t}\n    }\n  ws->ws_wordc = 0;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_free": {
      "start_point": [
        1557,
        0
      ],
      "end_point": [
        1563,
        1
      ],
      "content": "void\nwordsplit_free (struct wordsplit *ws)\n{\n  wordsplit_free_words (ws);\n  free (ws->ws_wordv);\n  ws->ws_wordv = NULL;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_perror": {
      "start_point": [
        1565,
        0
      ],
      "end_point": [
        1607,
        1
      ],
      "content": "void\nwordsplit_perror (struct wordsplit *wsp)\n{\n  switch (wsp->ws_errno)\n    {\n    case WRDSE_EOF:\n      wsp->ws_error (_(\"no error\"));\n      break;\n\n    case WRDSE_QUOTE:\n      wsp->ws_error (_(\"missing closing %c (start near #%lu)\"),\n\t\t     wsp->ws_input[wsp->ws_endp],\n\t\t     (unsigned long) wsp->ws_endp);\n      break;\n\n    case WRDSE_NOSPACE:\n      wsp->ws_error (_(\"memory exhausted\"));\n      break;\n\n    case WRDSE_NOSUPP:\n      wsp->ws_error (_(\"command substitution is not yet supported\"));\n      break;\n\n    case WRDSE_USAGE:\n      wsp->ws_error (_(\"invalid wordsplit usage\"));\n      break;\n\n    case WRDSE_CBRACE:\n      wsp->ws_error (_(\"unbalanced curly brace\"));\n      break;\n\n    case WRDSE_UNDEF:\n      wsp->ws_error (_(\"undefined variable\"));\n      break;\n\n    case WRDSE_NOINPUT:\n      wsp->ws_error (_(\"input exhausted\"));\n      break;\n\n    default:\n      wsp->ws_error (_(\"unknown error\"));\n    }\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_strerror": {
      "start_point": [
        1622,
        0
      ],
      "end_point": [
        1628,
        1
      ],
      "content": "const char *\nwordsplit_strerror (struct wordsplit *ws)\n{\n  if (ws->ws_errno < _wordsplit_nerrs)\n    return _wordsplit_errstr[ws->ws_errno];\n  return N_(\"unknown error\");\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nwordsplit_strerror (struct wordsplit *ws)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/lib/wordsplit.h": {},
  "tar/tar-1.30/lib/xattr-at.c": {},
  "tar/tar-1.30/lib/xattr-at.h": {},
  "tar/tar-1.30/rmt/rmt.c": {
    "trimnl": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static void\ntrimnl (char *str)\n{\n  if (str)\n    {\n      size_t len = strlen (str);\n      if (len > 1 && str[len-1] == '\\n')\n\tstr[len-1] = 0;\n    }\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rmt_read": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static char *\nrmt_read (void)\n{\n  ssize_t rc = getline (&input_buf_ptr, &input_buf_size, stdin);\n  if (rc > 0)\n    {\n      DEBUG1 (10, \"C: %s\", input_buf_ptr);\n      trimnl (input_buf_ptr);\n      return input_buf_ptr;\n    }\n  DEBUG (10, \"reached EOF\");\n  return NULL;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nrmt_read (void)",
        "*"
      ]
    },
    "rmt_write": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static void\nrmt_write (const char *fmt, ...)\n{\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (stdout, fmt, ap);\n  fflush (stdout);\n  VDEBUG (10, \"S: \", fmt, ap);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rmt_reply": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "static void\nrmt_reply (uintmax_t code)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  rmt_write (\"A%s\\n\", umaxtostr (code, buf));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rmt_error_message": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static void\nrmt_error_message (int code, const char *msg)\n{\n  DEBUG1 (10, \"S: E%d\\n\", code);\n  DEBUG1 (10, \"S: %s\\n\", msg);\n  DEBUG1 (1, \"error: %s\\n\", msg);\n  fprintf (stdout, \"E%d\\n%s\\n\", code, msg);\n  fflush (stdout);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rmt_error": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static void\nrmt_error (int code)\n{\n  rmt_error_message (code, strerror (code));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prepare_record_buffer": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static void\nprepare_record_buffer (size_t size)\n{\n  if (size > record_buffer_size)\n    {\n      record_buffer_ptr = xrealloc (record_buffer_ptr, size);\n      record_buffer_size = size;\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xlat_kw": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static int\nxlat_kw (const char *s, const char *pfx,\n\t struct rmt_kw const *kw, int *valp, const char **endp)\n{\n  size_t slen = strlen (s);\n\n  if (pfx)\n    {\n      size_t pfxlen = strlen (pfx);\n      if (slen > pfxlen && memcmp (s, pfx, pfxlen) == 0)\n\t{\n\t  s += pfxlen;\n\t  slen -= pfxlen;\n\t}\n    }\n\n  for (; kw->name; kw++)\n    {\n      if (slen >= kw->len\n\t  && memcmp (kw->name, s, kw->len) == 0\n\t  && !(s[kw->len] && c_isalnum (s[kw->len])))\n\t{\n\t  *valp = kw->value;\n\t  *endp = s + kw->len;\n\t  return 0;\n\t}\n    }\n  return 1;\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "skip_ws": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "static const char *\nskip_ws (const char *s)\n{\n  while (*s && c_isblank (*s))\n    s++;\n  return s;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nskip_ws (const char *s)",
        "*"
      ]
    },
    "decode_open_flag": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static int\ndecode_open_flag (const char *mstr, int *pmode)\n{\n  int numeric_mode = 0;\n  int mode = 0;\n  const char *p;\n\n  mstr = skip_ws (mstr);\n  if (c_isdigit (*mstr))\n    {\n      numeric_mode = strtol (mstr, (char**) &p, 10);\n      mstr = skip_ws (p);\n    }\n\n  if (*mstr)\n    {\n      while (mstr)\n\t{\n\t  int v;\n\t  \n\t  mstr = skip_ws (mstr);\n\t  if (*mstr == 0)\n\t    break;\n\t  else if (c_isdigit (*mstr))\n\t    v = strtol (mstr, (char**) &p, 10);\n\t  else if (xlat_kw (mstr, \"O_\", open_flag_kw, &v, &p))\n\t    {\n\t      rmt_error_message (EINVAL, \"invalid open mode\");\n\t      return 1;\n\t    }\n\n\t  mode |= v;\n\t  \n\t  if (*p && c_isblank (*p))\n\t    p = skip_ws (p);\n\t  if (*p == 0)\n\t    break;\n\t  else if (*p == '|')\n\t    {\n\t      /* FIXMEL\n\t\t if (p[1] == 0)\n\t\t rmt_error_message (EINVAL, \"invalid open mode\");\n\t      */\n\t      mstr = p + 1;\n\t    }\n\t  else\n\t    {\n\t      rmt_error_message (EINVAL, \"invalid open mode\");\n\t      return 1;\n\t    }\n\t}\n    }\n  else\n    mode = numeric_mode;\n  *pmode = mode;\n  return 0;\n}",
      "lines": 57,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open_device": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "static void\nopen_device (char *str)\n{\n  char *device = xstrdup (str);\n  char *flag_str;\n  int flag;\n\n  flag_str = rmt_read ();\n  if (!flag_str)\n    {\n      DEBUG (1, \"unexpected EOF\");\n      exit (EXIT_FAILURE);\n    }\n  if (decode_open_flag (flag_str, &flag) == 0)\n    {\n      if (device_fd >= 0)\n\tclose (device_fd);\n\n      device_fd = open (device, flag, MODE_RW);\n      if (device_fd < 0)\n\trmt_error (errno);\n      else\n\trmt_reply (0);\n    }\n  free (device);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "close_device": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "static void\nclose_device (void)\n{\n  if (close (device_fd) < 0)\n    rmt_error (errno);\n  else\n    {\n      device_fd = -1;\n      rmt_reply (0);\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lseek_device": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "static void\nlseek_device (const char *str)\n{\n  char *p;\n  int whence;\n  off_t off;\n  uintmax_t n;\n\n  if (str[0] && str[1] == 0)\n    {\n      switch (str[0])\n\t{\n\tcase '0':\n\t  whence = SEEK_SET;\n\t  break;\n\n\tcase '1':\n\t  whence = SEEK_CUR;\n\t  break;\n\n\tcase '2':\n\t  whence = SEEK_END;\n\t  break;\n\n\tdefault:\n\t  rmt_error_message (EINVAL, N_(\"Seek direction out of range\"));\n\t  return;\n\t}\n    }\n  else if (xlat_kw (str, \"SEEK_\", seek_whence_kw, &whence, (const char **) &p))\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid seek direction\"));\n      return;\n    }\n\n  str = rmt_read ();\n  n = off = strtoumax (str, &p, 10);\n  if (*p)\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid seek offset\"));\n      return;\n    }\n\n  if (n != off || errno == ERANGE)\n    {\n      rmt_error_message (EINVAL, N_(\"Seek offset out of range\"));\n      return;\n    }\n\n  off = lseek (device_fd, off, whence);\n  if (off < 0)\n    rmt_error (errno);\n  else\n    rmt_reply (off);\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_device": {
      "start_point": [
        481,
        0
      ],
      "end_point": [
        511,
        1
      ],
      "content": "static void\nread_device (const char *str)\n{\n  char *p;\n  size_t size;\n  uintmax_t n;\n  size_t status;\n\n  n = size = strtoumax (str, &p, 10);\n  if (*p)\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid byte count\"));\n      return;\n    }\n\n  if (n != size || errno == ERANGE)\n    {\n      rmt_error_message (EINVAL, N_(\"Byte count out of range\"));\n      return;\n    }\n\n  prepare_record_buffer (size);\n  status = safe_read (device_fd, record_buffer_ptr, size);\n  if (status == SAFE_READ_ERROR)\n    rmt_error (errno);\n  else\n    {\n      rmt_reply (status);\n      full_write (STDOUT_FILENO, record_buffer_ptr, status);\n    }\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_device": {
      "start_point": [
        532,
        0
      ],
      "end_point": [
        568,
        1
      ],
      "content": "static void\nwrite_device (const char *str)\n{\n  char *p;\n  size_t size;\n  uintmax_t n;\n  size_t status;\n\n  n = size = strtoumax (str, &p, 10);\n  if (*p)\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid byte count\"));\n      return;\n    }\n\n  if (n != size || errno == ERANGE)\n    {\n      rmt_error_message (EINVAL, N_(\"Byte count out of range\"));\n      return;\n    }\n\n  prepare_record_buffer (size);\n  if (fread (record_buffer_ptr, size, 1, stdin) != 1)\n    {\n      if (feof (stdin))\n\trmt_error_message (EIO, N_(\"Premature eof\"));\n      else\n\trmt_error (errno);\n      return;\n    }\n\n  status = full_write (device_fd, record_buffer_ptr, size);\n  if (status != size)\n    rmt_error (errno);\n  else\n    rmt_reply (status);\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "iocop_device": {
      "start_point": [
        589,
        0
      ],
      "end_point": [
        637,
        1
      ],
      "content": "static void\niocop_device (const char *str)\n{\n  char *p;\n  long opcode;\n  off_t count;\n  uintmax_t n;\n\n  opcode = strtol (str, &p, 10);\n  if (*p)\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid operation code\"));\n      return;\n    }\n  str = rmt_read ();\n  n = count = strtoumax (str, &p, 10);\n  if (*p)\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid byte count\"));\n      return;\n    }\n\n  if (n != count || errno == ERANGE)\n    {\n      rmt_error_message (EINVAL, N_(\"Byte count out of range\"));\n      return;\n    }\n\n#ifdef MTIOCTOP\n  {\n    struct mtop mtop;\n\n    mtop.mt_count = count;\n    if (mtop.mt_count != count)\n      {\n\trmt_error_message (EINVAL, N_(\"Byte count out of range\"));\n\treturn;\n      }\n\n    mtop.mt_op = opcode;\n    if (ioctl (device_fd, MTIOCTOP, (char *) &mtop) < 0)\n      rmt_error (errno);\n    else\n      rmt_reply (0);\n  }\n#else\n  rmt_error_message (ENOSYS, N_(\"Operation not supported\"));\n#endif\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "status_device": {
      "start_point": [
        658,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "static void\nstatus_device (const char *str)\n{\n  if (*str)\n    {\n      rmt_error_message (EINVAL, N_(\"Unexpected arguments\"));\n      return;\n    }\n#ifdef MTIOCGET\n  {\n    struct mtget mtget;\n\n    if (ioctl (device_fd, MTIOCGET, (char *) &mtget) < 0)\n      rmt_error (errno);\n    else\n      {\n\trmt_reply (sizeof (mtget));\n\tfull_write (STDOUT_FILENO, (char *) &mtget, sizeof (mtget));\n      }\n  }\n#else\n  rmt_error_message (ENOSYS, N_(\"Operation not supported\"));\n#endif\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_opt": {
      "start_point": [
        702,
        0
      ],
      "end_point": [
        731,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case 'd':\n      dbglev = strtol (arg, NULL, 0);\n      break;\n\n    case DEBUG_FILE_OPTION:\n      dbgout = fopen (arg, \"w\");\n      if (!dbgout)\n\terror (EXIT_FAILURE, errno, _(\"cannot open %s\"), arg);\n      break;\n\n    case ARGP_KEY_FINI:\n      if (dbglev)\n\t{\n\t  if (!dbgout)\n\t    dbgout = stderr;\n\t}\n      else if (dbgout)\n\tdbglev = 1;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "xalloc_die": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        754,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  rmt_error (ENOMEM);\n  exit (EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        757,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *buf;\n  int idx;\n  int stop = 0;\n\n  set_program_name (argv[0]);\n  argp_version_setup (\"rmt\", rmt_authors);\n\n  if (isatty (STDOUT_FILENO))\n    {\n      setlocale (LC_ALL, \"\");\n      bindtextdomain (PACKAGE, LOCALEDIR);\n      textdomain (PACKAGE);\n    }\n\n  if (argp_parse (&argp, argc, argv, ARGP_IN_ORDER, &idx, NULL))\n    exit (EXIT_FAILURE);\n  if (idx != argc)\n    {\n      if (idx != argc - 1)\n\terror (EXIT_FAILURE, 0, _(\"too many arguments\"));\n      dbgout = fopen (argv[idx], \"w\");\n      if (!dbgout)\n\terror (EXIT_FAILURE, errno, _(\"cannot open %s\"), argv[idx]);\n      dbglev = 1;\n    }\n\n  while (!stop && (buf = rmt_read ()) != NULL)\n    {\n      switch (buf[0])\n\t{\n\tcase 'C':\n\t  close_device ();\n\t  stop = 1;\n\t  break;\n\n\tcase 'I':\n\t  iocop_device (buf + 1);\n\t  break;\n\n\tcase 'L':\n\t  lseek_device (buf + 1);\n\t  break;\n\n\tcase 'O':\n\t  open_device (buf + 1);\n\t  break;\n\n\tcase 'R':\n\t  read_device (buf + 1);\n\t  break;\n\n\tcase 'S':\n\t  status_device (buf + 1);\n\t  break;\n\n\tcase 'W':\n\t  write_device (buf + 1);\n\t  break;\n\n\tdefault:\n\t  DEBUG1 (1, \"garbage input %s\\n\", buf);\n\t  rmt_error_message (EINVAL, N_(\"Garbage command\"));\n\t  return EXIT_FAILURE;\t/* exit status used to be 3 */\n\t}\n    }\n  if (device_fd >= 0)\n    close_device ();\n  free (input_buf_ptr);\n  free (record_buffer_ptr);\n  return EXIT_SUCCESS;\n}",
      "lines": 74,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/src/arith.h": {},
  "tar/tar-1.30/src/buffer.c": {
    "mv_begin_write": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void\nmv_begin_write (const char *file_name, off_t totsize, off_t sizeleft)\n{\n  if (multi_volume_option)\n    {\n      struct bufmap *bp = xmalloc (sizeof bp[0]);\n      if (bufmap_tail)\n\tbufmap_tail->next = bp;\n      else\n\tbufmap_head = bp;\n      bufmap_tail = bp;\n\n      bp->next = NULL;\n      bp->start = current_block - record_start;\n      bp->file_name = xstrdup (file_name);\n      bp->sizetotal = totsize;\n      bp->sizeleft = sizeleft;\n      bp->nblocks = 0;\n    }\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "bufmap_locate": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static struct bufmap *\nbufmap_locate (size_t off)\n{\n  struct bufmap *map;\n\n  for (map = bufmap_head; map; map = map->next)\n    {\n      if (!map->next || off < map->next->start * BLOCKSIZE)\n\tbreak;\n    }\n  return map;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct bufmap",
        "struct",
        "bufmap",
        "*\nbufmap_locate (size_t off)",
        "*"
      ]
    },
    "bufmap_free": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "static void\nbufmap_free (struct bufmap *mark)\n{\n  struct bufmap *map;\n  for (map = bufmap_head; map && map != mark; )\n    {\n      struct bufmap *next = map->next;\n      free (map->file_name);\n      free (map);\n      map = next;\n    }\n  bufmap_head = map;\n  if (!bufmap_head)\n    bufmap_tail = bufmap_head;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bufmap_reset": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "static void\nbufmap_reset (struct bufmap *map, ssize_t fixup)\n{\n  bufmap_free (map);\n  if (map)\n    {\n      for (; map; map = map->next)\n\t{\n\t  map->start += fixup;\n\t  map->nblocks = 0;\n\t}\n    }\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "buffer_write_global_xheader": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nbuffer_write_global_xheader (void)\n{\n  xheader_write_global (&dummy.xhdr);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mv_begin_read": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "void\nmv_begin_read (struct tar_stat_info *st)\n{\n  mv_begin_write (st->orig_file_name, st->stat.st_size, st->stat.st_size);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mv_end": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "void\nmv_end (void)\n{\n  if (multi_volume_option)\n    bufmap_free (NULL);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mv_size_left": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "void\nmv_size_left (off_t size)\n{\n  if (bufmap_head)\n    bufmap_head->sizeleft = size;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clear_read_error_count": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\nclear_read_error_count (void)\n{\n  read_error_count = 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "set_start_time": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "void\nset_start_time (void)\n{\n  gettime (&start_time);\n  volume_start_time = start_time;\n  last_stat_time = start_time;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "set_volume_start_time": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static void\nset_volume_start_time (void)\n{\n  gettime (&volume_start_time);\n  last_stat_time = volume_start_time;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compute_duration": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "double\ncompute_duration (void)\n{\n  struct timespec now;\n  gettime (&now);\n  duration += ((now.tv_sec - last_stat_time.tv_sec)\n               + (now.tv_nsec - last_stat_time.tv_nsec) / 1e9);\n  gettime (&last_stat_time);\n  return duration;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "find_zip_program": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "static struct zip_program const *\nfind_zip_program (enum compress_type type, int *pstate)\n{\n  int i;\n\n  for (i = *pstate; zip_program[i].type != ct_none; i++)\n    {\n      if (zip_program[i].type == type)\n\t{\n\t  *pstate = i + 1;\n\t  return zip_program + i;\n\t}\n    }\n  *pstate = i;\n  return NULL;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct zip_program",
        "struct",
        "zip_program",
        "const",
        "const",
        "*\nfind_zip_program (enum compress_type type, int *pstate)",
        "*"
      ]
    },
    "first_decompress_program": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "const char *\nfirst_decompress_program (int *pstate)\n{\n  struct zip_program const *zp;\n\n  if (use_compress_program_option)\n    return use_compress_program_option;\n\n  if (archive_compression_type == ct_none)\n    return NULL;\n\n  *pstate = 0;\n  zp = find_zip_program (archive_compression_type, pstate);\n  return zp ? zp->program : NULL;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nfirst_decompress_program (int *pstate)",
        "*"
      ]
    },
    "next_decompress_program": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "const char *\nnext_decompress_program (int *pstate)\n{\n  struct zip_program const *zp;\n\n  if (use_compress_program_option)\n    return NULL;\n  zp = find_zip_program (archive_compression_type, pstate);\n  return zp ? zp->program : NULL;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nnext_decompress_program (int *pstate)",
        "*"
      ]
    },
    "compress_option": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "static const char *\ncompress_option (enum compress_type type)\n{\n  struct zip_program const *zp;\n  int i = 0;\n  zp = find_zip_program (type, &i);\n  return zp ? zp->option : NULL;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ncompress_option (enum compress_type type)",
        "*"
      ]
    },
    "check_compressed_archive": {
      "start_point": [
        384,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "static enum compress_type\ncheck_compressed_archive (bool *pshort)\n{\n  struct zip_magic const *p;\n  bool sfr;\n  bool temp;\n\n  if (!pshort)\n    pshort = &temp;\n\n  /* Prepare global data needed for find_next_block: */\n  record_end = record_start; /* set up for 1st record = # 0 */\n  sfr = read_full_records;\n  read_full_records = true; /* Suppress fatal error on reading a partial\n                               record */\n  *pshort = find_next_block () == 0;\n\n  /* Restore global values */\n  read_full_records = sfr;\n\n  if (record_start != record_end /* no files smaller than BLOCKSIZE */\n      && (strcmp (record_start->header.magic, TMAGIC) == 0\n          || strcmp (record_start->buffer + offsetof (struct posix_header,\n                                                      magic),\n                     OLDGNU_MAGIC) == 0)\n      && tar_checksum (record_start, true) == HEADER_SUCCESS)\n    /* Probably a valid header */\n    return ct_tar;\n\n  for (p = magic + 2; p < magic + NMAGIC; p++)\n    if (memcmp (record_start->buffer, p->magic, p->length) == 0)\n      return p->type;\n\n  return ct_none;\n}",
      "lines": 35,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "enum compress_type",
        "enum",
        "compress_type"
      ]
    },
    "guess_seekable_archive": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "static void\nguess_seekable_archive (void)\n{\n  struct stat st;\n\n  if (subcommand_option == DELETE_SUBCOMMAND)\n    {\n      /* The current code in delete.c is based on the assumption that\n\t skip_member() reads all data from the archive. So, we should\n\t make sure it won't use seeks. On the other hand, the same code\n\t depends on the ability to backspace a record in the archive,\n\t so setting seekable_archive to false is technically incorrect.\n         However, it is tested only in skip_member(), so it's not a\n\t problem. */\n      seekable_archive = false;\n    }\n\n  if (seek_option != -1)\n    {\n      seekable_archive = !!seek_option;\n      return;\n    }\n\n  if (!multi_volume_option && !use_compress_program_option\n      && fstat (archive, &st) == 0)\n    seekable_archive = S_ISREG (st.st_mode);\n  else\n    seekable_archive = false;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_compressed_archive": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        505,
        1
      ],
      "content": "static int\nopen_compressed_archive (void)\n{\n  archive = rmtopen (archive_name_array[0], O_RDONLY | O_BINARY,\n                     MODE_RW, rsh_command_option);\n  if (archive == -1)\n    return archive;\n\n  if (!multi_volume_option)\n    {\n      if (!use_compress_program_option)\n        {\n          bool shortfile;\n          enum compress_type type = check_compressed_archive (&shortfile);\n\n          switch (type)\n            {\n            case ct_tar:\n              if (shortfile)\n                ERROR ((0, 0, _(\"This does not look like a tar archive\")));\n              return archive;\n\n            case ct_none:\n              if (shortfile)\n                ERROR ((0, 0, _(\"This does not look like a tar archive\")));\n              set_compression_program_by_suffix (archive_name_array[0], NULL);\n              if (!use_compress_program_option)\n\t\treturn archive;\n              break;\n\n            default:\n              archive_compression_type = type;\n              break;\n            }\n        }\n\n      /* FD is not needed any more */\n      rmtclose (archive);\n\n      hit_eof = false; /* It might have been set by find_next_block in\n                          check_compressed_archive */\n\n      /* Open compressed archive */\n      child_pid = sys_child_open_for_uncompress ();\n      read_full_records = true;\n    }\n\n  records_read = 0;\n  record_end = record_start; /* set up for 1st record = # 0 */\n\n  return archive;\n}",
      "lines": 52,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_stats": {
      "start_point": [
        507,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "static int\nprint_stats (FILE *fp, const char *text, tarlong numbytes)\n{\n  char abbr[LONGEST_HUMAN_READABLE + 1];\n  char rate[LONGEST_HUMAN_READABLE + 1];\n  int n = 0;\n\n  int human_opts = human_autoscale | human_base_1024 | human_SI | human_B;\n\n  if (text && text[0])\n    n += fprintf (fp, \"%s: \", gettext (text));\n  return n + fprintf (fp, TARLONG_FORMAT \" (%s, %s/s)\",\n\t\t      numbytes,\n\t\t      human_readable (numbytes, abbr, human_opts, 1, 1),\n\t\t      (0 < duration && numbytes / duration < (uintmax_t) -1\n\t\t       ? human_readable (numbytes / duration, rate, human_opts, 1, 1)\n\t\t       : \"?\"));\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "format_total_stats": {
      "start_point": [
        531,
        0
      ],
      "end_point": [
        586,
        1
      ],
      "content": "int\nformat_total_stats (FILE *fp, char const *const *formats, int eor, int eol)\n{\n  int n;\n\n  switch (subcommand_option)\n    {\n    case CREATE_SUBCOMMAND:\n    case CAT_SUBCOMMAND:\n    case UPDATE_SUBCOMMAND:\n    case APPEND_SUBCOMMAND:\n      n = print_stats (fp, formats[TF_WRITE],\n\t\t       prev_written + bytes_written);\n      break;\n\n    case DELETE_SUBCOMMAND:\n      {\n        char buf[UINTMAX_STRSIZE_BOUND];\n        n = print_stats (fp, formats[TF_READ],\n\t\t\t records_read * record_size);\n\n\tfputc (eor, fp);\n\tn++;\n\n        n += print_stats (fp, formats[TF_WRITE],\n\t\t\t  prev_written + bytes_written);\n\n\tfputc (eor, fp);\n\tn++;\n\n\tif (formats[TF_DELETED] && formats[TF_DELETED][0])\n\t  n += fprintf (fp, \"%s: \", gettext (formats[TF_DELETED]));\n        n += fprintf (fp, \"%s\",\n\t\t      STRINGIFY_BIGINT ((records_read - records_skipped)\n\t\t\t\t\t* record_size\n\t\t\t\t\t- (prev_written + bytes_written), buf));\n      }\n      break;\n\n    case EXTRACT_SUBCOMMAND:\n    case LIST_SUBCOMMAND:\n    case DIFF_SUBCOMMAND:\n      n = print_stats (fp, _(formats[TF_READ]),\n\t\t       records_read * record_size);\n      break;\n\n    default:\n      abort ();\n    }\n  if (eol)\n    {\n      fputc (eol, fp);\n      n++;\n    }\n  return n;\n}",
      "lines": 56,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "print_total_stats": {
      "start_point": [
        595,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "void\nprint_total_stats (void)\n{\n  format_total_stats (stderr, default_total_format, '\\n', '\\n');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "current_block_ordinal": {
      "start_point": [
        602,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "off_t\ncurrent_block_ordinal (void)\n{\n  return record_start_block + (current_block - record_start);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "off_t"
      ]
    },
    "reset_eof": {
      "start_point": [
        609,
        0
      ],
      "end_point": [
        619,
        1
      ],
      "content": "void\nreset_eof (void)\n{\n  if (hit_eof)\n    {\n      hit_eof = false;\n      current_block = record_start;\n      record_end = record_start + blocking_factor;\n      access_mode = ACCESS_WRITE;\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "find_next_block": {
      "start_point": [
        624,
        0
      ],
      "end_point": [
        639,
        1
      ],
      "content": "union block *\nfind_next_block (void)\n{\n  if (current_block == record_end)\n    {\n      if (hit_eof)\n        return 0;\n      flush_archive ();\n      if (current_block == record_end)\n        {\n          hit_eof = true;\n          return 0;\n        }\n    }\n  return current_block;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "union block",
        "union",
        "block",
        "*\nfind_next_block (void)",
        "*"
      ]
    },
    "set_next_block_after": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "void\nset_next_block_after (union block *block)\n{\n  while (block >= current_block)\n    current_block++;\n\n  /* Do *not* flush the archive here.  If we do, the same argument to\n     set_next_block_after could mean the next block (if the input record\n     is exactly one block long), which is not what is intended.  */\n\n  if (current_block > record_end)\n    abort ();\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "available_space_after": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        664,
        1
      ],
      "content": "size_t\navailable_space_after (union block *pointer)\n{\n  return record_end->buffer - pointer->buffer;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "xclose": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        672,
        1
      ],
      "content": "void\nxclose (int fd)\n{\n  if (close (fd) != 0)\n    close_error (_(\"(pipe)\"));\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "init_buffer": {
      "start_point": [
        674,
        0
      ],
      "end_point": [
        684,
        1
      ],
      "content": "static void\ninit_buffer (void)\n{\n  if (! record_buffer_aligned[record_index])\n    record_buffer_aligned[record_index] =\n      page_aligned_alloc (&record_buffer[record_index], record_size);\n\n  record_start = record_buffer_aligned[record_index];\n  current_block = record_start;\n  record_end = record_start + blocking_factor;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_tty": {
      "start_point": [
        686,
        0
      ],
      "end_point": [
        700,
        1
      ],
      "content": "static void\ncheck_tty (enum access_mode mode)\n{\n  /* Refuse to read archive from and write it to a tty. */\n  if (strcmp (archive_name_array[0], \"-\") == 0\n      && isatty (mode == ACCESS_READ ? STDIN_FILENO : STDOUT_FILENO))\n    {\n      FATAL_ERROR ((0, 0,\n\t\t    mode == ACCESS_READ\n\t\t    ? _(\"Refusing to read archive contents from terminal \"\n\t\t\t\"(missing -f option?)\")\n\t\t    : _(\"Refusing to write archive contents to terminal \"\n\t\t\t\"(missing -f option?)\")));\n    }\n}",
      "lines": 15,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_open_archive": {
      "start_point": [
        704,
        0
      ],
      "end_point": [
        858,
        1
      ],
      "content": "static void\n_open_archive (enum access_mode wanted_access)\n{\n  int backed_up_flag = 0;\n\n  if (record_size == 0)\n    FATAL_ERROR ((0, 0, _(\"Invalid value for record_size\")));\n\n  if (archive_names == 0)\n    FATAL_ERROR ((0, 0, _(\"No archive name given\")));\n\n  tar_stat_destroy (&current_stat_info);\n\n  record_index = 0;\n  init_buffer ();\n\n  /* When updating the archive, we start with reading.  */\n  access_mode = wanted_access == ACCESS_UPDATE ? ACCESS_READ : wanted_access;\n  check_tty (access_mode);\n\n  read_full_records = read_full_records_option;\n\n  records_read = 0;\n\n  if (use_compress_program_option)\n    {\n      switch (wanted_access)\n        {\n        case ACCESS_READ:\n          child_pid = sys_child_open_for_uncompress ();\n          read_full_records = true;\n          record_end = record_start; /* set up for 1st record = # 0 */\n          break;\n\n        case ACCESS_WRITE:\n          child_pid = sys_child_open_for_compress ();\n          break;\n\n        case ACCESS_UPDATE:\n          abort (); /* Should not happen */\n          break;\n        }\n\n      if (!index_file_name\n          && wanted_access == ACCESS_WRITE\n          && strcmp (archive_name_array[0], \"-\") == 0)\n        stdlis = stderr;\n    }\n  else if (strcmp (archive_name_array[0], \"-\") == 0)\n    {\n      read_full_records = true; /* could be a pipe, be safe */\n      if (verify_option)\n        FATAL_ERROR ((0, 0, _(\"Cannot verify stdin/stdout archive\")));\n\n      switch (wanted_access)\n        {\n        case ACCESS_READ:\n          {\n            bool shortfile;\n            enum compress_type type;\n\n            archive = STDIN_FILENO;\n            type = check_compressed_archive (&shortfile);\n            if (type != ct_tar && type != ct_none)\n              FATAL_ERROR ((0, 0,\n                            _(\"Archive is compressed. Use %s option\"),\n                            compress_option (type)));\n            if (shortfile)\n              ERROR ((0, 0, _(\"This does not look like a tar archive\")));\n          }\n          break;\n\n        case ACCESS_WRITE:\n          archive = STDOUT_FILENO;\n          if (!index_file_name)\n            stdlis = stderr;\n          break;\n\n        case ACCESS_UPDATE:\n          archive = STDIN_FILENO;\n          write_archive_to_stdout = true;\n          record_end = record_start; /* set up for 1st record = # 0 */\n          if (!index_file_name)\n            stdlis = stderr;\n          break;\n        }\n    }\n  else\n    switch (wanted_access)\n      {\n      case ACCESS_READ:\n        archive = open_compressed_archive ();\n\tif (archive >= 0)\n\t  guess_seekable_archive ();\n        break;\n\n      case ACCESS_WRITE:\n        if (backup_option)\n          {\n            maybe_backup_file (archive_name_array[0], 1);\n            backed_up_flag = 1;\n          }\n\tif (verify_option)\n\t  archive = rmtopen (archive_name_array[0], O_RDWR | O_CREAT | O_BINARY,\n\t\t\t     MODE_RW, rsh_command_option);\n\telse\n\t  archive = rmtcreat (archive_name_array[0], MODE_RW,\n\t\t\t      rsh_command_option);\n        break;\n\n      case ACCESS_UPDATE:\n        archive = rmtopen (archive_name_array[0],\n                           O_RDWR | O_CREAT | O_BINARY,\n                           MODE_RW, rsh_command_option);\n\n        switch (check_compressed_archive (NULL))\n          {\n          case ct_none:\n          case ct_tar:\n            break;\n\n          default:\n            FATAL_ERROR ((0, 0,\n                          _(\"Cannot update compressed archives\")));\n          }\n        break;\n      }\n\n  if (archive < 0\n      || (! _isrmt (archive) && !sys_get_archive_stat ()))\n    {\n      int saved_errno = errno;\n\n      if (backed_up_flag)\n        undo_last_backup ();\n      errno = saved_errno;\n      open_fatal (archive_name_array[0]);\n    }\n\n  sys_detect_dev_null_output ();\n  sys_save_archive_dev_ino ();\n  SET_BINARY_MODE (archive);\n\n  switch (wanted_access)\n    {\n    case ACCESS_READ:\n      find_next_block ();       /* read it in, check for EOF */\n      break;\n\n    case ACCESS_UPDATE:\n    case ACCESS_WRITE:\n      records_written = 0;\n      break;\n    }\n}",
      "lines": 155,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_flush_write": {
      "start_point": [
        861,
        0
      ],
      "end_point": [
        899,
        1
      ],
      "content": "static ssize_t\n_flush_write (void)\n{\n  ssize_t status;\n\n  checkpoint_run (true);\n  if (tape_length_option && tape_length_option <= bytes_written)\n    {\n      errno = ENOSPC;\n      status = 0;\n    }\n  else if (dev_null_output)\n    status = record_size;\n  else\n    status = sys_write_archive_buffer ();\n\n  if (status && multi_volume_option && !inhibit_map)\n    {\n      struct bufmap *map = bufmap_locate (status);\n      if (map)\n\t{\n\t  size_t delta = status - map->start * BLOCKSIZE;\n\t  ssize_t diff;\n\t  map->nblocks += delta / BLOCKSIZE;\n\t  if (delta > map->sizeleft)\n\t    delta = map->sizeleft;\n\t  map->sizeleft -= delta;\n\t  if (map->sizeleft == 0)\n\t    {\n\t      diff = map->start + map->nblocks;\n\t      map = map->next;\n\t    }\n\t  else\n\t    diff = map->start;\n\t  bufmap_reset (map, - diff);\n\t}\n    }\n  return status;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "archive_write_error": {
      "start_point": [
        904,
        0
      ],
      "end_point": [
        917,
        1
      ],
      "content": "void\narchive_write_error (ssize_t status)\n{\n  /* It might be useful to know how much was written before the error\n     occurred.  */\n  if (totals_option)\n    {\n      int e = errno;\n      print_total_stats ();\n      errno = e;\n    }\n\n  write_fatal_details (*archive_name_cursor, status, record_size);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "archive_read_error": {
      "start_point": [
        921,
        0
      ],
      "end_point": [
        935,
        1
      ],
      "content": "void\narchive_read_error (void)\n{\n  read_error (*archive_name_cursor);\n\n  if (record_start_block == 0)\n    FATAL_ERROR ((0, 0, _(\"At beginning of tape, quitting now\")));\n\n  /* Read error in mid archive.  We retry up to READ_ERROR_MAX times and\n     then give up on reading the archive.  */\n\n  if (read_error_count++ > READ_ERROR_MAX)\n    FATAL_ERROR ((0, 0, _(\"Too many errors, quitting\")));\n  return;\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "archive_is_dev": {
      "start_point": [
        937,
        0
      ],
      "end_point": [
        948,
        1
      ],
      "content": "static bool\narchive_is_dev (void)\n{\n  struct stat st;\n\n  if (fstat (archive, &st))\n    {\n      stat_diag (*archive_name_cursor);\n      return false;\n    }\n  return S_ISBLK (st.st_mode) || S_ISCHR (st.st_mode);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "short_read": {
      "start_point": [
        950,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "static void\nshort_read (size_t status)\n{\n  size_t left;                  /* bytes left */\n  char *more;                   /* pointer to next byte to read */\n\n  more = record_start->buffer + status;\n  left = record_size - status;\n\n  if (left && left % BLOCKSIZE == 0\n      && (warning_option & WARN_RECORD_SIZE)\n      && record_start_block == 0 && status != 0\n      && archive_is_dev ())\n    {\n      unsigned long rsize = status / BLOCKSIZE;\n      WARN ((0, 0,\n\t     ngettext (\"Record size = %lu block\",\n\t\t       \"Record size = %lu blocks\",\n\t\t       rsize),\n\t     rsize));\n    }\n\n  while (left % BLOCKSIZE != 0\n         || (left && status && read_full_records))\n    {\n      if (status)\n        while ((status = rmtread (archive, more, left)) == SAFE_READ_ERROR)\n          archive_read_error ();\n\n      if (status == 0)\n        break;\n\n      if (! read_full_records)\n        {\n          unsigned long rest = record_size - left;\n\n          FATAL_ERROR ((0, 0,\n                        ngettext (\"Unaligned block (%lu byte) in archive\",\n                                  \"Unaligned block (%lu bytes) in archive\",\n                                  rest),\n                        rest));\n        }\n\n      left -= status;\n      more += status;\n    }\n\n  record_end = record_start + (record_size - left) / BLOCKSIZE;\n  records_read++;\n}",
      "lines": 50,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "flush_archive": {
      "start_point": [
        1002,
        0
      ],
      "end_point": [
        1040,
        1
      ],
      "content": "void\nflush_archive (void)\n{\n  size_t buffer_level;\n\n  if (access_mode == ACCESS_READ && time_to_start_writing)\n    {\n      access_mode = ACCESS_WRITE;\n      time_to_start_writing = false;\n      backspace_output ();\n      if (record_end - record_start < blocking_factor)\n\t{\n\t  memset (record_end, 0,\n\t\t  (blocking_factor - (record_end - record_start))\n\t\t  * BLOCKSIZE);\n\t  record_end = record_start + blocking_factor;\n\t  return;\n\t}\n    }\n\n  buffer_level = current_block->buffer - record_start->buffer;\n  record_start_block += record_end - record_start;\n  current_block = record_start;\n  record_end = record_start + blocking_factor;\n\n  switch (access_mode)\n    {\n    case ACCESS_READ:\n      flush_read ();\n      break;\n\n    case ACCESS_WRITE:\n      flush_write_ptr (buffer_level);\n      break;\n\n    case ACCESS_UPDATE:\n      abort ();\n    }\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "backspace_output": {
      "start_point": [
        1045,
        0
      ],
      "end_point": [
        1083,
        1
      ],
      "content": "static void\nbackspace_output (void)\n{\n#ifdef MTIOCTOP\n  {\n    struct mtop operation;\n\n    operation.mt_op = MTBSR;\n    operation.mt_count = 1;\n    if (rmtioctl (archive, MTIOCTOP, (char *) &operation) >= 0)\n      return;\n    if (errno == EIO && rmtioctl (archive, MTIOCTOP, (char *) &operation) >= 0)\n      return;\n  }\n#endif\n\n  {\n    off_t position = rmtlseek (archive, (off_t) 0, SEEK_CUR);\n\n    /* Seek back to the beginning of this record and start writing there.  */\n\n    position -= record_end->buffer - record_start->buffer;\n    if (position < 0)\n      position = 0;\n    if (rmtlseek (archive, position, SEEK_SET) != position)\n      {\n        /* Lseek failed.  Try a different method.  */\n\n        WARN ((0, 0,\n               _(\"Cannot backspace archive file; it may be unreadable without -i\")));\n\n        /* Replace the first part of the record with NULs.  */\n\n        if (record_start->buffer != output_start)\n          memset (record_start->buffer, 0,\n                  output_start - record_start->buffer);\n      }\n  }\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "seek_archive": {
      "start_point": [
        1085,
        0
      ],
      "end_point": [
        1119,
        1
      ],
      "content": "off_t\nseek_archive (off_t size)\n{\n  off_t start = current_block_ordinal ();\n  off_t offset;\n  off_t nrec, nblk;\n  off_t skipped = (blocking_factor - (current_block - record_start))\n                  * BLOCKSIZE;\n\n  if (size <= skipped)\n    return 0;\n\n  /* Compute number of records to skip */\n  nrec = (size - skipped) / record_size;\n  if (nrec == 0)\n    return 0;\n  offset = rmtlseek (archive, nrec * record_size, SEEK_CUR);\n  if (offset < 0)\n    return offset;\n\n  if (offset % record_size)\n    FATAL_ERROR ((0, 0, _(\"rmtlseek not stopped at a record boundary\")));\n\n  /* Convert to number of records */\n  offset /= BLOCKSIZE;\n  /* Compute number of skipped blocks */\n  nblk = offset - start;\n\n  /* Update buffering info */\n  records_read += nblk / blocking_factor;\n  record_start_block = offset - blocking_factor;\n  current_block = record_end;\n\n  return nblk;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "off_t"
      ]
    },
    "close_archive": {
      "start_point": [
        1122,
        0
      ],
      "end_point": [
        1145,
        1
      ],
      "content": "void\nclose_archive (void)\n{\n  if (time_to_start_writing || access_mode == ACCESS_WRITE)\n    {\n      do\n\tflush_archive ();\n      while (current_block > record_start);\n    }\n\n  compute_duration ();\n  if (verify_option)\n    verify_volume ();\n\n  if (rmtclose (archive) != 0)\n    close_error (*archive_name_cursor);\n\n  sys_wait_for_child (child_pid, hit_eof);\n\n  tar_stat_destroy (&current_stat_info);\n  free (record_buffer[0]);\n  free (record_buffer[1]);\n  bufmap_free (NULL);\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "write_fatal_details": {
      "start_point": [
        1147,
        0
      ],
      "end_point": [
        1155,
        1
      ],
      "content": "void\nwrite_fatal_details (char const *name, ssize_t status, size_t size)\n{\n  write_error_details (name, status, size);\n  if (rmtclose (archive) != 0)\n    close_error (*archive_name_cursor);\n  sys_wait_for_child (child_pid, false);\n  fatal_exit ();\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "init_volume_number": {
      "start_point": [
        1158,
        0
      ],
      "end_point": [
        1176,
        1
      ],
      "content": "void\ninit_volume_number (void)\n{\n  FILE *file = fopen (volno_file_option, \"r\");\n\n  if (file)\n    {\n      if (fscanf (file, \"%d\", &global_volno) != 1\n          || global_volno < 0)\n        FATAL_ERROR ((0, 0, _(\"%s: contains invalid volume number\"),\n                      quotearg_colon (volno_file_option)));\n      if (ferror (file))\n        read_error (volno_file_option);\n      if (fclose (file) != 0)\n        close_error (volno_file_option);\n    }\n  else if (errno != ENOENT)\n    open_error (volno_file_option);\n}",
      "lines": 19,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "closeout_volume_number": {
      "start_point": [
        1179,
        0
      ],
      "end_point": [
        1194,
        1
      ],
      "content": "void\ncloseout_volume_number (void)\n{\n  FILE *file = fopen (volno_file_option, \"w\");\n\n  if (file)\n    {\n      fprintf (file, \"%d\\n\", global_volno);\n      if (ferror (file))\n        write_error (volno_file_option);\n      if (fclose (file) != 0)\n        close_error (volno_file_option);\n    }\n  else\n    open_error (volno_file_option);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "increase_volume_number": {
      "start_point": [
        1197,
        0
      ],
      "end_point": [
        1204,
        1
      ],
      "content": "static void\nincrease_volume_number (void)\n{\n  global_volno++;\n  if (global_volno < 0)\n    FATAL_ERROR ((0, 0, _(\"Volume number overflow\")));\n  volno++;\n}",
      "lines": 8,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "change_tape_menu": {
      "start_point": [
        1206,
        0
      ],
      "end_point": [
        1304,
        1
      ],
      "content": "static void\nchange_tape_menu (FILE *read_file)\n{\n  char *input_buffer = NULL;\n  size_t size = 0;\n  bool stop = false;\n\n  while (!stop)\n    {\n      fputc ('\\007', stderr);\n      fprintf (stderr,\n               _(\"Prepare volume #%d for %s and hit return: \"),\n               global_volno + 1, quote (*archive_name_cursor));\n      fflush (stderr);\n\n      if (getline (&input_buffer, &size, read_file) <= 0)\n        {\n          WARN ((0, 0, _(\"EOF where user reply was expected\")));\n\n          if (subcommand_option != EXTRACT_SUBCOMMAND\n              && subcommand_option != LIST_SUBCOMMAND\n              && subcommand_option != DIFF_SUBCOMMAND)\n            WARN ((0, 0, _(\"WARNING: Archive is incomplete\")));\n\n          fatal_exit ();\n        }\n\n      if (input_buffer[0] == '\\n'\n          || input_buffer[0] == 'y'\n          || input_buffer[0] == 'Y')\n        break;\n\n      switch (input_buffer[0])\n        {\n        case '?':\n          {\n            fprintf (stderr, _(\"\\\n n name        Give a new file name for the next (and subsequent) volume(s)\\n\\\n q             Abort tar\\n\\\n y or newline  Continue operation\\n\"));\n            if (!restrict_option)\n              fprintf (stderr, _(\" !             Spawn a subshell\\n\"));\n            fprintf (stderr, _(\" ?             Print this list\\n\"));\n          }\n          break;\n\n        case 'q':\n          /* Quit.  */\n\n          WARN ((0, 0, _(\"No new volume; exiting.\\n\")));\n\n          if (subcommand_option != EXTRACT_SUBCOMMAND\n              && subcommand_option != LIST_SUBCOMMAND\n              && subcommand_option != DIFF_SUBCOMMAND)\n            WARN ((0, 0, _(\"WARNING: Archive is incomplete\")));\n\n          fatal_exit ();\n\n        case 'n':\n          /* Get new file name.  */\n\n          {\n            char *name;\n            char *cursor;\n\n            for (name = input_buffer + 1;\n                 *name == ' ' || *name == '\\t';\n                 name++)\n              ;\n\n            for (cursor = name; *cursor && *cursor != '\\n'; cursor++)\n              ;\n            *cursor = '\\0';\n\n            if (name[0])\n              {\n                /* FIXME: the following allocation is never reclaimed.  */\n                *archive_name_cursor = xstrdup (name);\n                stop = true;\n              }\n            else\n              fprintf (stderr, \"%s\",\n                       _(\"File name not specified. Try again.\\n\"));\n          }\n          break;\n\n        case '!':\n          if (!restrict_option)\n            {\n              sys_spawn_shell ();\n              break;\n            }\n\t  FALLTHROUGH;\n        default:\n          fprintf (stderr, _(\"Invalid input. Type ? for help.\\n\"));\n        }\n    }\n  free (input_buffer);\n}",
      "lines": 99,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "new_volume": {
      "start_point": [
        1309,
        0
      ],
      "end_point": [
        1400,
        1
      ],
      "content": "static bool\nnew_volume (enum access_mode mode)\n{\n  static FILE *read_file;\n  static int looped;\n  int prompt;\n\n  if (!read_file && !info_script_option)\n    /* FIXME: if fopen is used, it will never be closed.  */\n    read_file = archive == STDIN_FILENO ? fopen (TTY_NAME, \"r\") : stdin;\n\n  if (now_verifying)\n    return false;\n  if (verify_option)\n    verify_volume ();\n\n  assign_string (&volume_label, NULL);\n  assign_string (&continued_file_name, NULL);\n  continued_file_size = continued_file_offset = 0;\n  current_block = record_start;\n\n  if (rmtclose (archive) != 0)\n    close_error (*archive_name_cursor);\n\n  archive_name_cursor++;\n  if (archive_name_cursor == archive_name_array + archive_names)\n    {\n      archive_name_cursor = archive_name_array;\n      looped = 1;\n    }\n  prompt = looped;\n\n tryagain:\n  if (prompt)\n    {\n      /* We have to prompt from now on.  */\n\n      if (info_script_option)\n        {\n          if (volno_file_option)\n            closeout_volume_number ();\n          if (sys_exec_info_script (archive_name_cursor, global_volno+1))\n            FATAL_ERROR ((0, 0, _(\"%s command failed\"),\n                          quote (info_script_option)));\n        }\n      else\n        change_tape_menu (read_file);\n    }\n\n  if (strcmp (archive_name_cursor[0], \"-\") == 0)\n    {\n      read_full_records = true;\n      archive = STDIN_FILENO;\n    }\n  else if (verify_option)\n    archive = rmtopen (*archive_name_cursor, O_RDWR | O_CREAT, MODE_RW,\n                       rsh_command_option);\n  else\n    switch (mode)\n      {\n      case ACCESS_READ:\n        archive = rmtopen (*archive_name_cursor, O_RDONLY, MODE_RW,\n                           rsh_command_option);\n\tguess_seekable_archive ();\n        break;\n\n      case ACCESS_WRITE:\n        if (backup_option)\n          maybe_backup_file (*archive_name_cursor, 1);\n        archive = rmtcreat (*archive_name_cursor, MODE_RW,\n                            rsh_command_option);\n        break;\n\n      case ACCESS_UPDATE:\n        archive = rmtopen (*archive_name_cursor, O_RDWR | O_CREAT, MODE_RW,\n                           rsh_command_option);\n        break;\n      }\n\n  if (archive < 0)\n    {\n      open_warn (*archive_name_cursor);\n      if (!verify_option && mode == ACCESS_WRITE && backup_option)\n        undo_last_backup ();\n      prompt = 1;\n      goto tryagain;\n    }\n\n  SET_BINARY_MODE (archive);\n\n  return true;\n}",
      "lines": 92,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "read_header0": {
      "start_point": [
        1402,
        0
      ],
      "end_point": [
        1416,
        1
      ],
      "content": "static bool\nread_header0 (struct tar_stat_info *info)\n{\n  enum read_header rc;\n\n  tar_stat_init (info);\n  rc = read_header (&current_header, info, read_header_auto);\n  if (rc == HEADER_SUCCESS)\n    {\n      set_next_block_after (current_header);\n      return true;\n    }\n  ERROR ((0, 0, _(\"This does not look like a tar archive\")));\n  return false;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "try_new_volume": {
      "start_point": [
        1418,
        0
      ],
      "end_point": [
        1584,
        1
      ],
      "content": "static bool\ntry_new_volume (void)\n{\n  size_t status;\n  union block *header;\n  enum access_mode acc;\n\n  switch (subcommand_option)\n    {\n    case APPEND_SUBCOMMAND:\n    case CAT_SUBCOMMAND:\n    case UPDATE_SUBCOMMAND:\n      acc = ACCESS_UPDATE;\n      break;\n\n    default:\n      acc = ACCESS_READ;\n      break;\n    }\n\n  if (!new_volume (acc))\n    return true;\n\n  while ((status = rmtread (archive, record_start->buffer, record_size))\n         == SAFE_READ_ERROR)\n    archive_read_error ();\n\n  if (status != record_size)\n    short_read (status);\n\n  header = find_next_block ();\n  if (!header)\n    {\n      WARN ((0, 0, _(\"This does not look like a tar archive\")));\n      return false;\n    }\n\n  switch (header->header.typeflag)\n    {\n    case XGLTYPE:\n      {\n\ttar_stat_init (&dummy);\n\tif (read_header (&header, &dummy, read_header_x_global)\n\t    != HEADER_SUCCESS_EXTENDED)\n\t  {\n\t    WARN ((0, 0, _(\"This does not look like a tar archive\")));\n\t    return false;\n\t  }\n\n        xheader_decode (&dummy); /* decodes values from the global header */\n        tar_stat_destroy (&dummy);\n\n\t/* The initial global header must be immediately followed by\n\t   an extended PAX header for the first member in this volume.\n\t   However, in some cases tar may split volumes in the middle\n\t   of a PAX header. This is incorrect, and should be fixed\n           in the future versions. In the meantime we must be\n\t   prepared to correctly list and extract such archives.\n\n\t   If this happens, the following call to read_header returns\n\t   HEADER_FAILURE, which is ignored.\n\n\t   See also tests/multiv07.at */\n\n\tswitch (read_header (&header, &dummy, read_header_auto))\n\t  {\n\t  case HEADER_SUCCESS:\n\t    set_next_block_after (header);\n\t    break;\n\n\t  case HEADER_FAILURE:\n\t    break;\n\n\t  default:\n\t    WARN ((0, 0, _(\"This does not look like a tar archive\")));\n\t    return false;\n\t  }\n        break;\n      }\n\n    case GNUTYPE_VOLHDR:\n      if (!read_header0 (&dummy))\n        return false;\n      tar_stat_destroy (&dummy);\n      assign_string (&volume_label, current_header->header.name);\n      set_next_block_after (header);\n      header = find_next_block ();\n      if (header->header.typeflag != GNUTYPE_MULTIVOL)\n        break;\n      FALLTHROUGH;\n    case GNUTYPE_MULTIVOL:\n      if (!read_header0 (&dummy))\n        return false;\n      tar_stat_destroy (&dummy);\n      assign_string (&continued_file_name, current_header->header.name);\n      continued_file_size =\n        UINTMAX_FROM_HEADER (current_header->header.size);\n      continued_file_offset =\n        UINTMAX_FROM_HEADER (current_header->oldgnu_header.offset);\n      break;\n\n    default:\n      break;\n    }\n\n  if (bufmap_head)\n    {\n      uintmax_t s;\n      if (!continued_file_name)\n\t{\n\t  WARN ((0, 0, _(\"%s is not continued on this volume\"),\n\t\t quote (bufmap_head->file_name)));\n\t  return false;\n\t}\n\n      if (strcmp (continued_file_name, bufmap_head->file_name))\n        {\n          if ((archive_format == GNU_FORMAT || archive_format == OLDGNU_FORMAT)\n              && strlen (bufmap_head->file_name) >= NAME_FIELD_SIZE\n              && strncmp (continued_file_name, bufmap_head->file_name,\n                          NAME_FIELD_SIZE) == 0)\n            WARN ((0, 0,\n _(\"%s is possibly continued on this volume: header contains truncated name\"),\n                   quote (bufmap_head->file_name)));\n          else\n            {\n              WARN ((0, 0, _(\"%s is not continued on this volume\"),\n                     quote (bufmap_head->file_name)));\n              return false;\n            }\n        }\n\n      s = continued_file_size + continued_file_offset;\n\n      if (bufmap_head->sizetotal != s || s < continued_file_offset)\n        {\n          char totsizebuf[UINTMAX_STRSIZE_BOUND];\n          char s1buf[UINTMAX_STRSIZE_BOUND];\n          char s2buf[UINTMAX_STRSIZE_BOUND];\n\n          WARN ((0, 0, _(\"%s is the wrong size (%s != %s + %s)\"),\n                 quote (continued_file_name),\n                 STRINGIFY_BIGINT (bufmap_head->sizetotal, totsizebuf),\n                 STRINGIFY_BIGINT (continued_file_size, s1buf),\n                 STRINGIFY_BIGINT (continued_file_offset, s2buf)));\n          return false;\n        }\n\n      if (bufmap_head->sizetotal - bufmap_head->sizeleft !=\n\t  continued_file_offset)\n        {\n          char totsizebuf[UINTMAX_STRSIZE_BOUND];\n          char s1buf[UINTMAX_STRSIZE_BOUND];\n          char s2buf[UINTMAX_STRSIZE_BOUND];\n\n          WARN ((0, 0, _(\"This volume is out of sequence (%s - %s != %s)\"),\n                 STRINGIFY_BIGINT (bufmap_head->sizetotal, totsizebuf),\n                 STRINGIFY_BIGINT (bufmap_head->sizeleft, s1buf),\n                 STRINGIFY_BIGINT (continued_file_offset, s2buf)));\n\n          return false;\n        }\n    }\n\n  increase_volume_number ();\n  return true;\n}",
      "lines": 167,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "drop_volume_label_suffix": {
      "start_point": [
        1590,
        0
      ],
      "end_point": [
        1614,
        1
      ],
      "content": "char *\ndrop_volume_label_suffix (const char *label)\n{\n  const char *p;\n  size_t len = strlen (label);\n\n  if (len < 1)\n    return NULL;\n\n  for (p = label + len - 1; p > label && isdigit ((unsigned char) *p); p--)\n    ;\n  if (p > label && p - (VOLUME_TEXT_LEN - 1) > label)\n    {\n      p -= VOLUME_TEXT_LEN - 1;\n      if (memcmp (p, VOLUME_TEXT, VOLUME_TEXT_LEN) == 0)\n\t{\n\t  char *s = xmalloc ((len = p - label) + 1);\n\t  memcpy (s, label, len);\n\t  s[len] = 0;\n\t  return s;\n\t}\n    }\n\n  return NULL;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "char",
        "*\ndrop_volume_label_suffix (const char *label)",
        "*"
      ]
    },
    "check_label_pattern": {
      "start_point": [
        1620,
        0
      ],
      "end_point": [
        1639,
        1
      ],
      "content": "static bool\ncheck_label_pattern (const char *label)\n{\n  char *string;\n  bool result = false;\n\n  if (fnmatch (volume_label_option, label, 0) == 0)\n    return true;\n\n  if (!multi_volume_option)\n    return false;\n\n  string = drop_volume_label_suffix (label);\n  if (string)\n    {\n      result = fnmatch (string, volume_label_option, 0) == 0;\n      free (string);\n    }\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "match_volume_label": {
      "start_point": [
        1643,
        0
      ],
      "end_point": [
        1684,
        1
      ],
      "content": "static void\nmatch_volume_label (void)\n{\n  if (!volume_label)\n    {\n      union block *label = find_next_block ();\n\n      if (!label)\n\tFATAL_ERROR ((0, 0, _(\"Archive not labeled to match %s\"),\n\t\t      quote (volume_label_option)));\n      if (label->header.typeflag == GNUTYPE_VOLHDR)\n\t{\n\t  if (memchr (label->header.name, '\\0', sizeof label->header.name))\n\t    assign_string (&volume_label, label->header.name);\n\t  else\n\t    {\n\t      volume_label = xmalloc (sizeof (label->header.name) + 1);\n\t      memcpy (volume_label, label->header.name,\n\t\t      sizeof (label->header.name));\n\t      volume_label[sizeof (label->header.name)] = 0;\n\t    }\n\t}\n      else if (label->header.typeflag == XGLTYPE)\n\t{\n\t  struct tar_stat_info st;\n\t  tar_stat_init (&st);\n\t  xheader_read (&st.xhdr, label,\n\t\t\tOFF_FROM_HEADER (label->header.size));\n\t  xheader_decode (&st);\n\t  tar_stat_destroy (&st);\n\t}\n    }\n\n  if (!volume_label)\n    FATAL_ERROR ((0, 0, _(\"Archive not labeled to match %s\"),\n                  quote (volume_label_option)));\n\n  if (!check_label_pattern (volume_label))\n    FATAL_ERROR ((0, 0, _(\"Volume %s does not match %s\"),\n                  quote_n (0, volume_label),\n                  quote_n (1, volume_label_option)));\n}",
      "lines": 42,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_write_volume_label": {
      "start_point": [
        1687,
        0
      ],
      "end_point": [
        1709,
        1
      ],
      "content": "static void\n_write_volume_label (const char *str)\n{\n  if (archive_format == POSIX_FORMAT)\n    xheader_store (\"GNU.volume.label\", &dummy, str);\n  else\n    {\n      union block *label = find_next_block ();\n\n      memset (label, 0, BLOCKSIZE);\n\n      strcpy (label->header.name, str);\n      assign_string (&current_stat_info.file_name,\n                     label->header.name);\n      current_stat_info.had_trailing_slash =\n        strip_trailing_slashes (current_stat_info.file_name);\n\n      label->header.typeflag = GNUTYPE_VOLHDR;\n      TIME_TO_CHARS (start_time.tv_sec, label->header.mtime);\n      finish_header (&current_stat_info, label, -1);\n      set_next_block_after (label);\n    }\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_volume_label": {
      "start_point": [
        1714,
        0
      ],
      "end_point": [
        1724,
        1
      ],
      "content": "static void\nadd_volume_label (void)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  char *p = STRINGIFY_BIGINT (volno, buf);\n  char *s = xmalloc (strlen (volume_label_option) + sizeof VOL_SUFFIX\n                     + strlen (p) + 2);\n  sprintf (s, \"%s %s %s\", volume_label_option, VOL_SUFFIX, p);\n  _write_volume_label (s);\n  free (s);\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_chunk_header": {
      "start_point": [
        1726,
        0
      ],
      "end_point": [
        1751,
        1
      ],
      "content": "static void\nadd_chunk_header (struct bufmap *map)\n{\n  if (archive_format == POSIX_FORMAT)\n    {\n      union block *blk;\n      struct tar_stat_info st;\n\n      memset (&st, 0, sizeof st);\n      st.orig_file_name = st.file_name = map->file_name;\n      st.stat.st_mode = S_IFREG|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;\n      st.stat.st_uid = getuid ();\n      st.stat.st_gid = getgid ();\n      st.orig_file_name = xheader_format_name (&st,\n                                               \"%d/GNUFileParts.%p/%f.%n\",\n                                               volno);\n      st.file_name = st.orig_file_name;\n      st.archive_file_size = st.stat.st_size = map->sizeleft;\n\n      blk = start_header (&st);\n      if (!blk)\n        abort (); /* FIXME */\n      simple_finish_header (write_extended (false, &st, blk));\n      free (st.orig_file_name);\n    }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_volume_label": {
      "start_point": [
        1755,
        0
      ],
      "end_point": [
        1762,
        1
      ],
      "content": "static void\nwrite_volume_label (void)\n{\n  if (multi_volume_option)\n    add_volume_label ();\n  else\n    _write_volume_label (volume_label_option);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gnu_add_multi_volume_header": {
      "start_point": [
        1765,
        0
      ],
      "end_point": [
        1790,
        1
      ],
      "content": "static void\ngnu_add_multi_volume_header (struct bufmap *map)\n{\n  int tmp;\n  union block *block = find_next_block ();\n\n  if (strlen (map->file_name) > NAME_FIELD_SIZE)\n    WARN ((0, 0,\n           _(\"%s: file name too long to be stored in a GNU multivolume header, truncated\"),\n           quotearg_colon (map->file_name)));\n\n  memset (block, 0, BLOCKSIZE);\n\n  strncpy (block->header.name, map->file_name, NAME_FIELD_SIZE);\n  block->header.typeflag = GNUTYPE_MULTIVOL;\n\n  OFF_TO_CHARS (map->sizeleft, block->header.size);\n  OFF_TO_CHARS (map->sizetotal - map->sizeleft,\n                block->oldgnu_header.offset);\n\n  tmp = verbose_option;\n  verbose_option = 0;\n  finish_header (&current_stat_info, block, -1);\n  verbose_option = tmp;\n  set_next_block_after (block);\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_multi_volume_header": {
      "start_point": [
        1794,
        0
      ],
      "end_point": [
        1806,
        1
      ],
      "content": "static void\nadd_multi_volume_header (struct bufmap *map)\n{\n  if (archive_format == POSIX_FORMAT)\n    {\n      off_t d = map->sizetotal - map->sizeleft;\n      xheader_store (\"GNU.volume.filename\", &dummy, map->file_name);\n      xheader_store (\"GNU.volume.size\", &dummy, &map->sizeleft);\n      xheader_store (\"GNU.volume.offset\", &dummy, &d);\n    }\n  else\n    gnu_add_multi_volume_header (map);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "simple_flush_read": {
      "start_point": [
        1812,
        0
      ],
      "end_point": [
        1849,
        1
      ],
      "content": "static void\nsimple_flush_read (void)\n{\n  size_t status;                /* result from system call */\n\n  checkpoint_run (false);\n\n  /* Clear the count of errors.  This only applies to a single call to\n     flush_read.  */\n\n  read_error_count = 0;         /* clear error count */\n\n  if (write_archive_to_stdout && record_start_block != 0)\n    {\n      archive = STDOUT_FILENO;\n      status = sys_write_archive_buffer ();\n      archive = STDIN_FILENO;\n      if (status != record_size)\n        archive_write_error (status);\n    }\n\n  for (;;)\n    {\n      status = rmtread (archive, record_start->buffer, record_size);\n      if (status == record_size)\n        {\n          records_read++;\n          return;\n        }\n      if (status == SAFE_READ_ERROR)\n        {\n          archive_read_error ();\n          continue;             /* try again */\n        }\n      break;\n    }\n  short_read (status);\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "simple_flush_write": {
      "start_point": [
        1852,
        0
      ],
      "end_point": [
        1865,
        1
      ],
      "content": "static void\nsimple_flush_write (size_t level __attribute__((unused)))\n{\n  ssize_t status;\n\n  status = _flush_write ();\n  if (status != record_size)\n    archive_write_error (status);\n  else\n    {\n      records_written++;\n      bytes_written += status;\n    }\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_gnu_flush_read": {
      "start_point": [
        1871,
        0
      ],
      "end_point": [
        1925,
        1
      ],
      "content": "static void\n_gnu_flush_read (void)\n{\n  size_t status;                /* result from system call */\n\n  checkpoint_run (false);\n\n  /* Clear the count of errors.  This only applies to a single call to\n     flush_read.  */\n\n  read_error_count = 0;         /* clear error count */\n\n  if (write_archive_to_stdout && record_start_block != 0)\n    {\n      archive = STDOUT_FILENO;\n      status = sys_write_archive_buffer ();\n      archive = STDIN_FILENO;\n      if (status != record_size)\n        archive_write_error (status);\n    }\n\n  for (;;)\n    {\n      status = rmtread (archive, record_start->buffer, record_size);\n      if (status == record_size)\n        {\n          records_read++;\n          return;\n        }\n\n      /* The condition below used to include\n              || (status > 0 && !read_full_records)\n         This is incorrect since even if new_volume() succeeds, the\n         subsequent call to rmtread will overwrite the chunk of data\n         already read in the buffer, so the processing will fail */\n      if ((status == 0\n           || (status == SAFE_READ_ERROR && errno == ENOSPC))\n          && multi_volume_option)\n        {\n          while (!try_new_volume ())\n            ;\n\t  if (current_block == record_end)\n\t    /* Necessary for blocking_factor == 1 */\n\t    flush_archive();\n          return;\n        }\n      else if (status == SAFE_READ_ERROR)\n        {\n          archive_read_error ();\n          continue;\n        }\n      break;\n    }\n  short_read (status);\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gnu_flush_read": {
      "start_point": [
        1927,
        0
      ],
      "end_point": [
        1933,
        1
      ],
      "content": "static void\ngnu_flush_read (void)\n{\n  flush_read_ptr = simple_flush_read; /* Avoid recursion */\n  _gnu_flush_read ();\n  flush_read_ptr = gnu_flush_read;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_gnu_flush_write": {
      "start_point": [
        1935,
        0
      ],
      "end_point": [
        2019,
        1
      ],
      "content": "static void\n_gnu_flush_write (size_t buffer_level)\n{\n  ssize_t status;\n  union block *header;\n  char *copy_ptr;\n  size_t copy_size;\n  size_t bufsize;\n  struct bufmap *map;\n\n  status = _flush_write ();\n  if (status != record_size && !multi_volume_option)\n    archive_write_error (status);\n  else\n    {\n      if (status)\n        records_written++;\n      bytes_written += status;\n    }\n\n  if (status == record_size)\n    {\n      return;\n    }\n\n  map = bufmap_locate (status);\n\n  if (status % BLOCKSIZE)\n    {\n      ERROR ((0, 0, _(\"write did not end on a block boundary\")));\n      archive_write_error (status);\n    }\n\n  /* In multi-volume mode. */\n  /* ENXIO is for the UNIX PC.  */\n  if (status < 0 && errno != ENOSPC && errno != EIO && errno != ENXIO)\n    archive_write_error (status);\n\n  if (!new_volume (ACCESS_WRITE))\n    return;\n\n  tar_stat_destroy (&dummy);\n\n  increase_volume_number ();\n  prev_written += bytes_written;\n  bytes_written = 0;\n\n  copy_ptr = record_start->buffer + status;\n  copy_size = buffer_level - status;\n\n  /* Switch to the next buffer */\n  record_index = !record_index;\n  init_buffer ();\n\n  inhibit_map = 1;\n\n  if (volume_label_option)\n    add_volume_label ();\n\n  if (map)\n    add_multi_volume_header (map);\n\n  write_extended (true, &dummy, find_next_block ());\n  tar_stat_destroy (&dummy);\n\n  if (map)\n    add_chunk_header (map);\n  header = find_next_block ();\n  bufmap_reset (map, header - record_start);\n  bufsize = available_space_after (header);\n  inhibit_map = 0;\n  while (bufsize < copy_size)\n    {\n      memcpy (header->buffer, copy_ptr, bufsize);\n      copy_ptr += bufsize;\n      copy_size -= bufsize;\n      set_next_block_after (header + (bufsize - 1) / BLOCKSIZE);\n      header = find_next_block ();\n      bufsize = available_space_after (header);\n    }\n  memcpy (header->buffer, copy_ptr, copy_size);\n  memset (header->buffer + copy_size, 0, bufsize - copy_size);\n  set_next_block_after (header + (copy_size - 1) / BLOCKSIZE);\n  find_next_block ();\n}",
      "lines": 85,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gnu_flush_write": {
      "start_point": [
        2021,
        0
      ],
      "end_point": [
        2027,
        1
      ],
      "content": "static void\ngnu_flush_write (size_t buffer_level)\n{\n  flush_write_ptr = simple_flush_write; /* Avoid recursion */\n  _gnu_flush_write (buffer_level);\n  flush_write_ptr = gnu_flush_write;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "flush_read": {
      "start_point": [
        2029,
        0
      ],
      "end_point": [
        2033,
        1
      ],
      "content": "void\nflush_read (void)\n{\n  flush_read_ptr ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "flush_write": {
      "start_point": [
        2035,
        0
      ],
      "end_point": [
        2039,
        1
      ],
      "content": "void\nflush_write (void)\n{\n  flush_write_ptr (record_size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "open_archive": {
      "start_point": [
        2041,
        0
      ],
      "end_point": [
        2063,
        1
      ],
      "content": "void\nopen_archive (enum access_mode wanted_access)\n{\n  flush_read_ptr = gnu_flush_read;\n  flush_write_ptr = gnu_flush_write;\n\n  _open_archive (wanted_access);\n  switch (wanted_access)\n    {\n    case ACCESS_READ:\n    case ACCESS_UPDATE:\n      if (volume_label_option)\n        match_volume_label ();\n      break;\n\n    case ACCESS_WRITE:\n      records_written = 0;\n      if (volume_label_option)\n        write_volume_label ();\n      break;\n    }\n  set_volume_start_time ();\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/checkpoint.c": {
    "alloc_action": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static struct checkpoint_action *\nalloc_action (enum checkpoint_opcode opcode)\n{\n  struct checkpoint_action *p = xzalloc (sizeof *p);\n  if (checkpoint_action_tail)\n    checkpoint_action_tail->next = p;\n  else\n    checkpoint_action = p;\n  checkpoint_action_tail = p;\n  p->opcode = opcode;\n  return p;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct checkpoint_action",
        "struct",
        "checkpoint_action",
        "*\nalloc_action (enum checkpoint_opcode opcode)",
        "*"
      ]
    },
    "copy_string_unquote": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static char *\ncopy_string_unquote (const char *str)\n{\n  char *output = xstrdup (str);\n  size_t len = strlen (output);\n  if ((*output == '\"' || *output == '\\'')\n      && output[len-1] == *output)\n    {\n      memmove (output, output+1, len-2);\n      output[len-2] = 0;\n    }\n  unquote_string (output);\n  return output;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ncopy_string_unquote (const char *str)",
        "*"
      ]
    },
    "checkpoint_compile_action": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void\ncheckpoint_compile_action (const char *str)\n{\n  struct checkpoint_action *act;\n\n  if (strcmp (str, \".\") == 0 || strcmp (str, \"dot\") == 0)\n    alloc_action (cop_dot);\n  else if (strcmp (str, \"bell\") == 0)\n    alloc_action (cop_bell);\n  else if (strcmp (str, \"echo\") == 0)\n    alloc_action (cop_echo);\n  else if (strncmp (str, \"echo=\", 5) == 0)\n    {\n      act = alloc_action (cop_echo);\n      act->v.command = copy_string_unquote (str + 5);\n    }\n  else if (strncmp (str, \"exec=\", 5) == 0)\n    {\n      act = alloc_action (cop_exec);\n      act->v.command = copy_string_unquote (str + 5);\n    }\n  else if (strncmp (str, \"ttyout=\", 7) == 0)\n    {\n      act = alloc_action (cop_ttyout);\n      act->v.command = copy_string_unquote (str + 7);\n    }\n  else if (strncmp (str, \"sleep=\", 6) == 0)\n    {\n      char *p;\n      time_t n = strtoul (str+6, &p, 10);\n      if (*p)\n\tFATAL_ERROR ((0, 0, _(\"%s: not a valid timeout\"), str));\n      act = alloc_action (cop_sleep);\n      act->v.time = n;\n    }\n  else if (strcmp (str, \"totals\") == 0)\n    alloc_action (cop_totals);\n  else\n    FATAL_ERROR ((0, 0, _(\"%s: unknown checkpoint action\"), str));\n}",
      "lines": 40,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "checkpoint_finish_compile": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\ncheckpoint_finish_compile (void)\n{\n  if (checkpoint_option)\n    {\n      if (!checkpoint_action)\n\t/* Provide a historical default */\n\tcheckpoint_compile_action (\"echo\");\n    }\n  else if (checkpoint_action)\n    /* Otherwise, set default checkpoint rate */\n    checkpoint_option = DEFAULT_CHECKPOINT;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "getwidth": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static long\ngetwidth (FILE *fp)\n{\n  char const *columns;\n\n#ifdef TIOCGWINSZ\n  struct winsize ws;\n  if (ioctl (fileno (fp), TIOCGWINSZ, &ws) == 0 && 0 < ws.ws_col)\n    return ws.ws_col;\n#endif\n\n  columns = getenv (\"COLUMNS\");\n  if (columns)\n    {\n      long int col = strtol (columns, NULL, 10);\n      if (0 < col)\n\treturn col;\n    }\n\n  return 80;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "getarg": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "static char *\ngetarg (const char *input, const char ** endp, char **argbuf, size_t *arglen)\n{\n  if (input[0] == '{')\n    {\n      char *p = strchr (input + 1, '}');\n      if (p)\n\t{\n\t  size_t n = p - input;\n\t  if (n > *arglen)\n\t    {\n\t      *arglen = n;\n\t      *argbuf = xrealloc (*argbuf, *arglen);\n\t    }\n\t  n--;\n\t  memcpy (*argbuf, input + 1, n);\n\t  (*argbuf)[n] = 0;\n\t  *endp = p + 1;\n\t  return *argbuf;\n\t}\n    }\n\n  *endp = input;\n  return NULL;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ngetarg (const char *input, const char ** endp, char **argbuf, size_t *arglen)",
        "*"
      ]
    },
    "format_checkpoint_string": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static int\nformat_checkpoint_string (FILE *fp, size_t len,\n\t\t\t  const char *input, bool do_write,\n\t\t\t  unsigned cpn)\n{\n  const char *opstr = do_write ? gettext (\"write\") : gettext (\"read\");\n  char uintbuf[UINTMAX_STRSIZE_BOUND];\n  char *cps = STRINGIFY_BIGINT (cpn, uintbuf);\n  const char *ip;\n\n  static char *argbuf = NULL;\n  static size_t arglen = 0;\n  char *arg = NULL;\n\n  if (!input)\n    {\n      if (do_write)\n\t/* TRANSLATORS: This is a \"checkpoint of write operation\",\n\t *not* \"Writing a checkpoint\".\n\t E.g. in Spanish \"Punto de comprobaci@'on de escritura\",\n\t *not* \"Escribiendo un punto de comprobaci@'on\" */\n\tinput = gettext (\"Write checkpoint %u\");\n      else\n\t/* TRANSLATORS: This is a \"checkpoint of read operation\",\n\t *not* \"Reading a checkpoint\".\n\t E.g. in Spanish \"Punto de comprobaci@'on de lectura\",\n\t *not* \"Leyendo un punto de comprobaci@'on\" */\n\tinput = gettext (\"Read checkpoint %u\");\n    }\n\n  for (ip = input; *ip; ip++)\n    {\n      if (*ip == '%')\n\t{\n\t  if (*++ip == '{')\n\t    {\n\t      arg = getarg (ip, &ip, &argbuf, &arglen);\n\t      if (!arg)\n\t\t{\n\t\t  fputc ('%', fp);\n\t\t  fputc (*ip, fp);\n\t\t  len += 2;\n\t\t  continue;\n\t\t}\n\t    }\n\t  switch (*ip)\n\t    {\n\t    case 'c':\n\t      len += format_checkpoint_string (fp, len, def_format, do_write,\n\t\t\t\t\t       cpn);\n\t      break;\n\n\t    case 'u':\n\t      fputs (cps, fp);\n\t      len += strlen (cps);\n\t      break;\n\n\t    case 's':\n\t      fputs (opstr, fp);\n\t      len += strlen (opstr);\n\t      break;\n\n\t    case 'd':\n\t      len += fprintf (fp, \"%.0f\", compute_duration ());\n\t      break;\n\n\t    case 'T':\n\t      {\n\t\tconst char **fmt = checkpoint_total_format, *fmtbuf[3];\n\t\tstruct wordsplit ws;\n\t\tcompute_duration ();\n\n\t\tif (arg)\n\t\t  {\n\t\t    ws.ws_delim = \",\";\n\t\t    if (wordsplit (arg, &ws, WRDSF_NOVAR | WRDSF_NOCMD |\n\t\t\t\t           WRDSF_QUOTE | WRDSF_DELIM))\n\t\t      ERROR ((0, 0, _(\"cannot split string '%s': %s\"),\n\t\t\t      arg, wordsplit_strerror (&ws)));\n\t\t    else\n\t\t      {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < ws.ws_wordc; i++)\n\t\t\t  fmtbuf[i] = ws.ws_wordv[i];\n\t\t\tfor (; i < 3; i++)\n\t\t\t  fmtbuf[i] = NULL;\n\t\t\tfmt = fmtbuf;\n\t\t      }\n\t\t  }\n\t\tlen += format_total_stats (fp, fmt, ',', 0);\n\t\tif (arg)\n\t\t  wordsplit_free (&ws);\n\t      }\n\t      break;\n\n\t    case 't':\n\t      {\n\t\tstruct timeval tv;\n\t\tstruct tm *tm;\n\t\tconst char *fmt = arg ? arg : \"%c\";\n\n\t\tgettimeofday (&tv, NULL);\n\t\ttm = localtime (&tv.tv_sec);\n\t\tlen += fprintftime (fp, fmt, tm, 0, tv.tv_usec * 1000);\n\t      }\n\t      break;\n\n\t    case '*':\n\t      {\n\t\tlong w = arg ? strtol (arg, NULL, 10) : getwidth (fp);\n\t\tfor (; w > len; len++)\n\t\t  fputc (' ', fp);\n\t      }\n\t      break;\n\n\t    default:\n\t      fputc ('%', fp);\n\t      fputc (*ip, fp);\n\t      len += 2;\n\t      break;\n\t    }\n\t  arg = NULL;\n\t}\n      else\n\t{\n\t  fputc (*ip, fp);\n\t  if (*ip == '\\r')\n\t    {\n\t      len = 0;\n\t      tty_cleanup = 1;\n\t    }\n\t  else\n\t    len++;\n\t}\n    }\n  fflush (fp);\n  return len;\n}",
      "lines": 139,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "run_checkpoint_actions": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "static void\nrun_checkpoint_actions (bool do_write)\n{\n  struct checkpoint_action *p;\n\n  for (p = checkpoint_action; p; p = p->next)\n    {\n      switch (p->opcode)\n\t{\n\tcase cop_dot:\n\t  fputc ('.', stdlis);\n\t  fflush (stdlis);\n\t  break;\n\n\tcase cop_bell:\n\t  if (!tty)\n\t    tty = fopen (\"/dev/tty\", \"w\");\n\t  if (tty)\n\t    {\n\t      fputc ('\\a', tty);\n\t      fflush (tty);\n\t    }\n\t  break;\n\n\tcase cop_echo:\n\t  {\n\t    int n = fprintf (stderr, \"%s: \", program_name);\n\t    format_checkpoint_string (stderr, n, p->v.command, do_write,\n\t\t\t\t      checkpoint);\n\t    fputc ('\\n', stderr);\n\t  }\n\t  break;\n\n\tcase cop_ttyout:\n\t  if (!tty)\n\t    tty = fopen (\"/dev/tty\", \"w\");\n\t  if (tty)\n\t    format_checkpoint_string (tty, 0, p->v.command, do_write,\n\t\t\t\t      checkpoint);\n\t  break;\n\n\tcase cop_sleep:\n\t  sleep (p->v.time);\n\t  break;\n\n\tcase cop_exec:\n\t  sys_exec_checkpoint_script (p->v.command,\n\t\t\t\t      archive_name_cursor[0],\n\t\t\t\t      checkpoint);\n\t  break;\n\n\tcase cop_totals:\n\t  compute_duration ();\n\t  print_total_stats ();\n\t}\n    }\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "checkpoint_flush_actions": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "void\ncheckpoint_flush_actions (void)\n{\n  struct checkpoint_action *p;\n\n  for (p = checkpoint_action; p; p = p->next)\n    {\n      switch (p->opcode)\n\t{\n\tcase cop_ttyout:\n\t  if (tty && tty_cleanup)\n\t    {\n\t      long w = getwidth (tty);\n\t      while (w--)\n\t\tfputc (' ', tty);\n\t      fputc ('\\r', tty);\n\t      fflush (tty);\n\t    }\n\t  break;\n\tdefault:\n\t  /* nothing */;\n\t}\n    }\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "checkpoint_run": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "void\ncheckpoint_run (bool do_write)\n{\n  if (checkpoint_option && !(++checkpoint % checkpoint_option))\n    run_checkpoint_actions (do_write);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "checkpoint_finish": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "void\ncheckpoint_finish (void)\n{\n  if (checkpoint_option)\n    {\n      checkpoint_flush_actions ();\n      if (tty)\n\tfclose (tty);\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/common.h": {
    "represent_uintmax": {
      "start_point": [
        651,
        0
      ],
      "end_point": [
        662,
        1
      ],
      "content": "COMMON_INLINE intmax_t\nrepresent_uintmax (uintmax_t n)\n{\n  if (n <= INTMAX_MAX)\n    return n;\n  else\n    {\n      /* Avoid signed integer overflow on picky platforms.  */\n      intmax_t nd = n - INTMAX_MIN;\n      return nd + INTMAX_MIN;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "COMMON_INLINE",
        "intmax_t",
        "intmax_t"
      ]
    },
    "valid_timespec": {
      "start_point": [
        676,
        0
      ],
      "end_point": [
        680,
        1
      ],
      "content": "COMMON_INLINE bool\nvalid_timespec (struct timespec t)\n{\n  return 0 <= t.tv_nsec;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "COMMON_INLINE",
        "bool",
        "bool"
      ]
    }
  },
  "tar/tar-1.30/src/compare.c": {
    "diff_init": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\ndiff_init (void)\n{\n  void *ptr;\n  diff_buffer = page_aligned_alloc (&ptr, record_size);\n  if (listed_incremental_option)\n    read_directory_file ();\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "report_difference": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\nreport_difference (struct tar_stat_info *st, const char *fmt, ...)\n{\n  if (fmt)\n    {\n      va_list ap;\n\n      fprintf (stdlis, \"%s: \", quote_n_colon (QUOTE_NAME, st->file_name));\n      va_start (ap, fmt);\n      vfprintf (stdlis, fmt, ap);\n      va_end (ap);\n      fprintf (stdlis, \"\\n\");\n    }\n\n  set_exit_status (TAREXIT_DIFFERS);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "process_noop": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static int\nprocess_noop (size_t size __attribute__ ((unused)),\n\t      char *data __attribute__ ((unused)))\n{\n  return 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_rawdata": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static int\nprocess_rawdata (size_t bytes, char *buffer)\n{\n  size_t status = blocking_read (diff_handle, diff_buffer, bytes);\n\n  if (status != bytes)\n    {\n      if (status == SAFE_READ_ERROR)\n\t{\n\t  read_error (current_stat_info.file_name);\n\t  report_difference (&current_stat_info, NULL);\n\t}\n      else\n\t{\n\t  report_difference (&current_stat_info,\n\t\t\t     ngettext (\"Could only read %lu of %lu byte\",\n\t\t\t\t       \"Could only read %lu of %lu bytes\",\n\t\t\t\t       bytes),\n\t\t\t     (unsigned long) status, (unsigned long) bytes);\n\t}\n      return 0;\n    }\n\n  if (memcmp (buffer, diff_buffer, bytes))\n    {\n      report_difference (&current_stat_info, _(\"Contents differ\"));\n      return 0;\n    }\n\n  return 1;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_and_process": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static void\nread_and_process (struct tar_stat_info *st, int (*processor) (size_t, char *))\n{\n  union block *data_block;\n  size_t data_size;\n  off_t size = st->stat.st_size;\n\n  mv_begin_read (st);\n  while (size)\n    {\n      data_block = find_next_block ();\n      if (! data_block)\n\t{\n\t  ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t  return;\n\t}\n\n      data_size = available_space_after (data_block);\n      if (data_size > size)\n\tdata_size = size;\n      if (!(*processor) (data_size, data_block->buffer))\n\tprocessor = process_noop;\n      set_next_block_after ((union block *)\n\t\t\t    (data_block->buffer + data_size - 1));\n      size -= data_size;\n      mv_size_left (size);\n    }\n  mv_end ();\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_stat_data": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static int\nget_stat_data (char const *file_name, struct stat *stat_data)\n{\n  int status = deref_stat (file_name, stat_data);\n\n  if (status != 0)\n    {\n      if (errno == ENOENT)\n\tstat_warn (file_name);\n      else\n\tstat_error (file_name);\n      report_difference (&current_stat_info, NULL);\n      return 0;\n    }\n\n  return 1;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "diff_dir": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static void\ndiff_dir (void)\n{\n  struct stat stat_data;\n\n  if (!get_stat_data (current_stat_info.file_name, &stat_data))\n    return;\n\n  if (!S_ISDIR (stat_data.st_mode))\n    report_difference (&current_stat_info, _(\"File type differs\"));\n  else if ((current_stat_info.stat.st_mode & MODE_ALL) !=\n\t   (stat_data.st_mode & MODE_ALL))\n    report_difference (&current_stat_info, _(\"Mode differs\"));\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "diff_file": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static void\ndiff_file (void)\n{\n  char const *file_name = current_stat_info.file_name;\n  struct stat stat_data;\n\n  if (!get_stat_data (file_name, &stat_data))\n    skip_member ();\n  else if (!S_ISREG (stat_data.st_mode))\n    {\n      report_difference (&current_stat_info, _(\"File type differs\"));\n      skip_member ();\n    }\n  else\n    {\n      if ((current_stat_info.stat.st_mode & MODE_ALL) !=\n\t  (stat_data.st_mode & MODE_ALL))\n\treport_difference (&current_stat_info, _(\"Mode differs\"));\n\n      if (!sys_compare_uid (&stat_data, &current_stat_info.stat))\n\treport_difference (&current_stat_info, _(\"Uid differs\"));\n      if (!sys_compare_gid (&stat_data, &current_stat_info.stat))\n\treport_difference (&current_stat_info, _(\"Gid differs\"));\n\n      if (tar_timespec_cmp (get_stat_mtime (&stat_data),\n                            current_stat_info.mtime))\n\treport_difference (&current_stat_info, _(\"Mod time differs\"));\n      if (current_header->header.typeflag != GNUTYPE_SPARSE\n\t  && stat_data.st_size != current_stat_info.stat.st_size)\n\t{\n\t  report_difference (&current_stat_info, _(\"Size differs\"));\n\t  skip_member ();\n\t}\n      else\n\t{\n\t  diff_handle = openat (chdir_fd, file_name, open_read_flags);\n\n\t  if (diff_handle < 0)\n\t    {\n\t      open_error (file_name);\n\t      skip_member ();\n\t      report_difference (&current_stat_info, NULL);\n\t    }\n\t  else\n\t    {\n\t      int status;\n\n\t      if (current_stat_info.is_sparse)\n\t\tsparse_diff_file (diff_handle, &current_stat_info);\n\t      else\n\t\tread_and_process (&current_stat_info, process_rawdata);\n\n\t      if (atime_preserve_option == replace_atime_preserve\n\t\t  && stat_data.st_size != 0)\n\t\t{\n\t\t  struct timespec atime = get_stat_atime (&stat_data);\n\t\t  if (set_file_atime (diff_handle, chdir_fd, file_name, atime)\n\t\t      != 0)\n\t\t    utime_error (file_name);\n\t\t}\n\n\t      status = close (diff_handle);\n\t      if (status != 0)\n\t\tclose_error (file_name);\n\t    }\n\t}\n    }\n}",
      "lines": 68,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "diff_link": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static void\ndiff_link (void)\n{\n  struct stat file_data;\n  struct stat link_data;\n\n  if (get_stat_data (current_stat_info.file_name, &file_data)\n      && get_stat_data (current_stat_info.link_name, &link_data)\n      && !sys_compare_links (&file_data, &link_data))\n    report_difference (&current_stat_info,\n\t\t       _(\"Not linked to %s\"),\n\t\t       quote_n_colon (QUOTE_ARG,\n\t\t\t\t      current_stat_info.link_name));\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "diff_symlink": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static void\ndiff_symlink (void)\n{\n  char buf[1024];\n  size_t len = strlen (current_stat_info.link_name);\n  char *linkbuf = len < sizeof buf ? buf : xmalloc (len + 1);\n\n  ssize_t status = readlinkat (chdir_fd, current_stat_info.file_name,\n\t\t\t       linkbuf, len + 1);\n\n  if (status < 0)\n    {\n      if (errno == ENOENT)\n\treadlink_warn (current_stat_info.file_name);\n      else\n\treadlink_error (current_stat_info.file_name);\n      report_difference (&current_stat_info, NULL);\n    }\n  else if (status != len\n\t   || memcmp (current_stat_info.link_name, linkbuf, len) != 0)\n    report_difference (&current_stat_info, _(\"Symlink differs\"));\n\n  if (linkbuf != buf)\n    free (linkbuf);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "diff_special": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "static void\ndiff_special (void)\n{\n  struct stat stat_data;\n\n  /* FIXME: deal with umask.  */\n\n  if (!get_stat_data (current_stat_info.file_name, &stat_data))\n    return;\n\n  if (current_header->header.typeflag == CHRTYPE\n      ? !S_ISCHR (stat_data.st_mode)\n      : current_header->header.typeflag == BLKTYPE\n      ? !S_ISBLK (stat_data.st_mode)\n      : /* current_header->header.typeflag == FIFOTYPE */\n      !S_ISFIFO (stat_data.st_mode))\n    {\n      report_difference (&current_stat_info, _(\"File type differs\"));\n      return;\n    }\n\n  if ((current_header->header.typeflag == CHRTYPE\n       || current_header->header.typeflag == BLKTYPE)\n      && current_stat_info.stat.st_rdev != stat_data.st_rdev)\n    {\n      report_difference (&current_stat_info, _(\"Device number differs\"));\n      return;\n    }\n\n  if ((current_stat_info.stat.st_mode & MODE_ALL) !=\n      (stat_data.st_mode & MODE_ALL))\n    report_difference (&current_stat_info, _(\"Mode differs\"));\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dumpdir_cmp": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "static int\ndumpdir_cmp (const char *a, const char *b)\n{\n  size_t len;\n\n  while (*a)\n    switch (*a)\n      {\n      case 'Y':\n      case 'N':\n\tif (!strchr (\"YN\", *b))\n\t  return 1;\n\tif (strcmp(a + 1, b + 1))\n\t  return 1;\n\tlen = strlen (a) + 1;\n\ta += len;\n\tb += len;\n\tbreak;\n\n      case 'D':\n\tif (strcmp(a, b))\n\t  return 1;\n\tlen = strlen (a) + 1;\n\ta += len;\n\tb += len;\n\tbreak;\n\n      case 'R':\n      case 'T':\n      case 'X':\n\treturn *b;\n      }\n  return *b;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "diff_dumpdir": {
      "start_point": [
        368,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "static void\ndiff_dumpdir (struct tar_stat_info *dir)\n{\n  const char *dumpdir_buffer;\n\n  if (dir->fd == 0)\n    {\n      void (*diag) (char const *) = NULL;\n      int fd = subfile_open (dir->parent, dir->orig_file_name, open_read_flags);\n      if (fd < 0)\n\tdiag = open_diag;\n      else if (fstat (fd, &dir->stat))\n        {\n\t  diag = stat_diag;\n          close (fd);\n        }\n      else\n\tdir->fd = fd;\n      if (diag)\n\t{\n\t  file_removed_diag (dir->orig_file_name, false, diag);\n\t  return;\n\t}\n    }\n  dumpdir_buffer = directory_contents (scan_directory (dir));\n\n  if (dumpdir_buffer)\n    {\n      if (dumpdir_cmp (dir->dumpdir, dumpdir_buffer))\n\treport_difference (dir, _(\"Contents differ\"));\n    }\n  else\n    read_and_process (dir, process_noop);\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "diff_multivol": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "static void\ndiff_multivol (void)\n{\n  struct stat stat_data;\n  int fd, status;\n  off_t offset;\n\n  if (current_stat_info.had_trailing_slash)\n    {\n      diff_dir ();\n      return;\n    }\n\n  if (!get_stat_data (current_stat_info.file_name, &stat_data))\n    return;\n\n  if (!S_ISREG (stat_data.st_mode))\n    {\n      report_difference (&current_stat_info, _(\"File type differs\"));\n      skip_member ();\n      return;\n    }\n\n  offset = OFF_FROM_HEADER (current_header->oldgnu_header.offset);\n  if (offset < 0\n      || INT_ADD_OVERFLOW (current_stat_info.stat.st_size, offset)\n      || stat_data.st_size != current_stat_info.stat.st_size + offset)\n    {\n      report_difference (&current_stat_info, _(\"Size differs\"));\n      skip_member ();\n      return;\n    }\n\n\n  fd = openat (chdir_fd, current_stat_info.file_name, open_read_flags);\n\n  if (fd < 0)\n    {\n      open_error (current_stat_info.file_name);\n      report_difference (&current_stat_info, NULL);\n      skip_member ();\n      return;\n    }\n\n  if (lseek (fd, offset, SEEK_SET) < 0)\n    {\n      seek_error_details (current_stat_info.file_name, offset);\n      report_difference (&current_stat_info, NULL);\n    }\n  else\n    read_and_process (&current_stat_info, process_rawdata);\n\n  status = close (fd);\n  if (status != 0)\n    close_error (current_stat_info.file_name);\n}",
      "lines": 56,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "diff_archive": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "void\ndiff_archive (void)\n{\n\n  set_next_block_after (current_header);\n\n  /* Print the block from current_header and current_stat_info.  */\n\n  if (verbose_option)\n    {\n      if (now_verifying)\n\tfprintf (stdlis, _(\"Verify \"));\n      print_header (&current_stat_info, current_header, -1);\n    }\n\n  switch (current_header->header.typeflag)\n    {\n    default:\n      ERROR ((0, 0, _(\"%s: Unknown file type '%c', diffed as normal file\"),\n\t      quotearg_colon (current_stat_info.file_name),\n\t      current_header->header.typeflag));\n      FALLTHROUGH;\n    case AREGTYPE:\n    case REGTYPE:\n    case GNUTYPE_SPARSE:\n    case CONTTYPE:\n\n      /* Appears to be a file.  See if it's really a directory.  */\n\n      if (current_stat_info.had_trailing_slash)\n\tdiff_dir ();\n      else\n\tdiff_file ();\n      break;\n\n    case LNKTYPE:\n      diff_link ();\n      break;\n\n#ifdef HAVE_READLINK\n    case SYMTYPE:\n      diff_symlink ();\n      break;\n#endif\n\n    case CHRTYPE:\n    case BLKTYPE:\n    case FIFOTYPE:\n      diff_special ();\n      break;\n\n    case GNUTYPE_DUMPDIR:\n    case DIRTYPE:\n      if (is_dumpdir (&current_stat_info))\n\tdiff_dumpdir (&current_stat_info);\n      diff_dir ();\n      break;\n\n    case GNUTYPE_VOLHDR:\n      break;\n\n    case GNUTYPE_MULTIVOL:\n      diff_multivol ();\n    }\n}",
      "lines": 65,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "verify_volume": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        650,
        1
      ],
      "content": "void\nverify_volume (void)\n{\n  int may_fail = 0;\n  if (removed_prefixes_p ())\n    {\n      WARN((0, 0,\n\t    _(\"Archive contains file names with leading prefixes removed.\")));\n      may_fail = 1;\n    }\n  if (transform_program_p ())\n    {\n      WARN((0, 0,\n\t    _(\"Archive contains transformed file names.\")));\n      may_fail = 1;\n    }\n  if (may_fail)\n    WARN((0, 0,\n\t  _(\"Verification may fail to locate original files.\")));\n\n  clear_directory_table ();\n\n  if (!diff_buffer)\n    diff_init ();\n\n  /* Verifying an archive is meant to check if the physical media got it\n     correctly, so try to defeat clever in-memory buffering pertaining to\n     this particular media.  On Linux, for example, the floppy drive would\n     not even be accessed for the whole verification.\n\n     The code was using fsync only when the ioctl is unavailable, but\n     Marty Leisner says that the ioctl does not work when not preceded by\n     fsync.  So, until we know better, or maybe to please Marty, let's do it\n     the unbelievable way :-).  */\n\n#if HAVE_FSYNC\n  fsync (archive);\n#endif\n#ifdef FDFLUSH\n  ioctl (archive, FDFLUSH);\n#endif\n\n#ifdef MTIOCTOP\n  {\n    struct mtop operation;\n    int status;\n\n    operation.mt_op = MTBSF;\n    operation.mt_count = 1;\n    if (status = rmtioctl (archive, MTIOCTOP, (char *) &operation), status < 0)\n      {\n\tif (errno != EIO\n\t    || (status = rmtioctl (archive, MTIOCTOP, (char *) &operation),\n\t\tstatus < 0))\n\t  {\n#endif\n\t    if (rmtlseek (archive, (off_t) 0, SEEK_SET) != 0)\n\t      {\n\t\t/* Lseek failed.  Try a different method.  */\n\t\tseek_warn (archive_name_array[0]);\n\t\treturn;\n\t      }\n#ifdef MTIOCTOP\n\t  }\n      }\n  }\n#endif\n\n  access_mode = ACCESS_READ;\n  now_verifying = 1;\n\n  flush_read ();\n  while (1)\n    {\n      enum read_header status = read_header (&current_header,\n                                             &current_stat_info,\n                                             read_header_auto);\n\n      if (status == HEADER_FAILURE)\n\t{\n\t  int counter = 0;\n\n\t  do\n\t    {\n\t      counter++;\n\t      set_next_block_after (current_header);\n\t      status = read_header (&current_header, &current_stat_info,\n\t                            read_header_auto);\n\t    }\n\t  while (status == HEADER_FAILURE);\n\n\t  ERROR ((0, 0,\n\t\t  ngettext (\"VERIFY FAILURE: %d invalid header detected\",\n\t\t\t    \"VERIFY FAILURE: %d invalid headers detected\",\n\t\t\t    counter), counter));\n\t}\n      if (status == HEADER_END_OF_FILE)\n\tbreak;\n      if (status == HEADER_ZERO_BLOCK)\n\t{\n\t  set_next_block_after (current_header);\n          if (!ignore_zeros_option)\n            {\n\t      char buf[UINTMAX_STRSIZE_BOUND];\n\n\t      status = read_header (&current_header, &current_stat_info,\n\t                            read_header_auto);\n\t      if (status == HEADER_ZERO_BLOCK)\n\t        break;\n\t      WARNOPT (WARN_ALONE_ZERO_BLOCK,\n\t\t       (0, 0, _(\"A lone zero block at %s\"),\n\t\t\tSTRINGIFY_BIGINT (current_block_ordinal (), buf)));\n            }\n\t  continue;\n\t}\n\n      decode_header (current_header, &current_stat_info, &current_format, 1);\n      diff_archive ();\n      tar_stat_destroy (&current_stat_info);\n    }\n\n  access_mode = ACCESS_WRITE;\n  now_verifying = 0;\n}",
      "lines": 124,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/create.c": {
    "add_exclusion_tag": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\nadd_exclusion_tag (const char *name, enum exclusion_tag_type type,\n\t\t   bool (*predicate) (int fd))\n{\n  struct exclusion_tag *tag = xmalloc (sizeof tag[0]);\n  tag->next = exclusion_tags;\n  tag->name = name;\n  tag->type = type;\n  tag->predicate = predicate;\n  tag->length = strlen (name);\n  exclusion_tags = tag;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "exclusion_tag_warning": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\nexclusion_tag_warning (const char *dirname, const char *tagname,\n\t\t       const char *message)\n{\n  if (verbose_option)\n    WARNOPT (WARN_CACHEDIR,\n\t     (0, 0,\n\t      _(\"%s: contains a cache directory tag %s; %s\"),\n\t      quotearg_colon (dirname),\n\t      quotearg_n (1, tagname),\n\t      message));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "check_exclusion_tags": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "enum exclusion_tag_type\ncheck_exclusion_tags (struct tar_stat_info const *st, char const **tag_file_name)\n{\n  struct exclusion_tag *tag;\n\n  for (tag = exclusion_tags; tag; tag = tag->next)\n    {\n      int tagfd = subfile_open (st, tag->name, open_read_flags);\n      if (0 <= tagfd)\n\t{\n\t  bool satisfied = !tag->predicate || tag->predicate (tagfd);\n\t  close (tagfd);\n\t  if (satisfied)\n\t    {\n\t      if (tag_file_name)\n\t\t*tag_file_name = tag->name;\n\t      return tag->type;\n\t    }\n\t}\n    }\n\n  return exclusion_tag_none;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "enum exclusion_tag_type",
        "enum",
        "exclusion_tag_type"
      ]
    },
    "cachedir_file_p": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "bool\ncachedir_file_p (int fd)\n{\n  char tagbuf[CACHEDIR_SIGNATURE_SIZE];\n\n  return\n    (read (fd, tagbuf, CACHEDIR_SIGNATURE_SIZE) == CACHEDIR_SIGNATURE_SIZE\n     && memcmp (tagbuf, CACHEDIR_SIGNATURE, CACHEDIR_SIGNATURE_SIZE) == 0);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "to_octal": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static void\nto_octal (uintmax_t value, char *where, size_t size)\n{\n  uintmax_t v = value;\n  size_t i = size;\n\n  do\n    {\n      where[--i] = '0' + (v & ((1 << LG_8) - 1));\n      v >>= LG_8;\n    }\n  while (i);\n}",
      "lines": 13,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tar_copy_str": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static void\ntar_copy_str (char *dst, const char *src, size_t len)\n{\n  size_t i;\n  for (i = 0; i < len; i++)\n    if (! (dst[i] = src[i]))\n      break;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tar_name_copy_str": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static void\ntar_name_copy_str (char *dst, const char *src, size_t len)\n{\n  tar_copy_str (dst, src, len);\n  if (archive_format == OLDGNU_FORMAT)\n    dst[len-1] = 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "to_base256": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static void\nto_base256 (int negative, uintmax_t value, char *where, size_t size)\n{\n  uintmax_t v = value;\n  uintmax_t propagated_sign_bits =\n    ((uintmax_t) - negative << (CHAR_BIT * sizeof v - LG_256));\n  size_t i = size;\n\n  do\n    {\n      where[--i] = v & ((1 << LG_256) - 1);\n      v = propagated_sign_bits | (v >> LG_256);\n    }\n  while (i);\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "to_chars_subst": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static bool\nto_chars_subst (int negative, int gnu_format, uintmax_t value, size_t valsize,\n\t\tuintmax_t (*substitute) (int *),\n\t\tchar *where, size_t size, const char *type)\n{\n  uintmax_t maxval = (gnu_format\n\t\t      ? MAX_VAL_WITH_DIGITS (size - 1, LG_256)\n\t\t      : MAX_VAL_WITH_DIGITS (size - 1, LG_8));\n  char valbuf[UINTMAX_STRSIZE_BOUND + 1];\n  char maxbuf[UINTMAX_STRSIZE_BOUND];\n  char minbuf[UINTMAX_STRSIZE_BOUND + 1];\n  char const *minval_string;\n  char const *maxval_string = STRINGIFY_BIGINT (maxval, maxbuf);\n  char const *value_string;\n\n  if (gnu_format)\n    {\n      uintmax_t m = maxval + 1 ? maxval + 1 : maxval / 2 + 1;\n      char *p = STRINGIFY_BIGINT (m, minbuf + 1);\n      *--p = '-';\n      minval_string = p;\n    }\n  else\n    minval_string = \"0\";\n\n  if (negative)\n    {\n      char *p = STRINGIFY_BIGINT (- value, valbuf + 1);\n      *--p = '-';\n      value_string = p;\n    }\n  else\n    value_string = STRINGIFY_BIGINT (value, valbuf);\n\n  if (substitute)\n    {\n      int negsub;\n      uintmax_t sub = substitute (&negsub) & maxval;\n      /* NOTE: This is one of the few places where GNU_FORMAT differs from\n\t OLDGNU_FORMAT.  The actual differences are:\n\n\t 1. In OLDGNU_FORMAT all strings in a tar header end in \\0\n\t 2. Incremental archives use oldgnu_header.\n\n\t Apart from this they are completely identical. */\n      uintmax_t s = (negsub &= archive_format == GNU_FORMAT) ? - sub : sub;\n      char subbuf[UINTMAX_STRSIZE_BOUND + 1];\n      char *sub_string = STRINGIFY_BIGINT (s, subbuf + 1);\n      if (negsub)\n\t*--sub_string = '-';\n      WARN ((0, 0, _(\"value %s out of %s range %s..%s; substituting %s\"),\n\t     value_string, type, minval_string, maxval_string,\n\t     sub_string));\n      return to_chars (negsub, s, valsize, 0, where, size, type);\n    }\n  else\n    ERROR ((0, 0, _(\"value %s out of %s range %s..%s\"),\n\t    value_string, type, minval_string, maxval_string));\n  return false;\n}",
      "lines": 60,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "to_chars": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static bool\nto_chars (int negative, uintmax_t value, size_t valsize,\n\t  uintmax_t (*substitute) (int *),\n\t  char *where, size_t size, const char *type)\n{\n  int gnu_format = (archive_format == GNU_FORMAT\n\t\t    || archive_format == OLDGNU_FORMAT);\n\n  /* Generate the POSIX octal representation if the number fits.  */\n  if (! negative && value <= MAX_VAL_WITH_DIGITS (size - 1, LG_8))\n    {\n      where[size - 1] = '\\0';\n      to_octal (value, where, size - 1);\n      return true;\n    }\n  else if (gnu_format)\n    {\n      /* Try to cope with the number by using traditional GNU format\n\t methods */\n\n      /* Generate the base-256 representation if the number fits.  */\n      if (((negative ? -1 - value : value)\n\t   <= MAX_VAL_WITH_DIGITS (size - 1, LG_256)))\n\t{\n\t  where[0] = negative ? -1 : 1 << (LG_256 - 1);\n\t  to_base256 (negative, value, where + 1, size - 1);\n\t  return true;\n\t}\n\n      /* Otherwise, if the number is negative, and if it would not cause\n\t ambiguity on this host by confusing positive with negative\n\t values, then generate the POSIX octal representation of the value\n\t modulo 2**(field bits).  The resulting tar file is\n\t machine-dependent, since it depends on the host word size.  Yuck!\n\t But this is the traditional behavior.  */\n      else if (negative && valsize * CHAR_BIT <= (size - 1) * LG_8)\n\t{\n\t  static int warned_once;\n\t  if (! warned_once)\n\t    {\n\t      warned_once = 1;\n\t      WARN ((0, 0, _(\"Generating negative octal headers\")));\n\t    }\n\t  where[size - 1] = '\\0';\n\t  to_octal (value & MAX_VAL_WITH_DIGITS (valsize * CHAR_BIT, 1),\n\t\t    where, size - 1);\n\t  return true;\n\t}\n      /* Otherwise fall back to substitution, if possible: */\n    }\n  else\n    substitute = NULL; /* No substitution for formats, other than GNU */\n\n  return to_chars_subst (negative, gnu_format, value, valsize, substitute,\n\t\t\t where, size, type);\n}",
      "lines": 56,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "gid_substitute": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "static uintmax_t\ngid_substitute (int *negative)\n{\n  gid_t r;\n#ifdef GID_NOBODY\n  r = GID_NOBODY;\n#else\n  static gid_t gid_nobody;\n  if (!gid_nobody && !gname_to_gid (\"nobody\", &gid_nobody))\n    gid_nobody = -2;\n  r = gid_nobody;\n#endif\n  *negative = r < 0;\n  return r;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "uintmax_t"
      ]
    },
    "gid_to_chars": {
      "start_point": [
        360,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "static bool\ngid_to_chars (gid_t v, char *p, size_t s)\n{\n  return to_chars (v < 0, (uintmax_t) v, sizeof v, gid_substitute, p, s, \"gid_t\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "major_to_chars": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "static bool\nmajor_to_chars (major_t v, char *p, size_t s)\n{\n  return to_chars (v < 0, (uintmax_t) v, sizeof v, 0, p, s, \"major_t\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "minor_to_chars": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "static bool\nminor_to_chars (minor_t v, char *p, size_t s)\n{\n  return to_chars (v < 0, (uintmax_t) v, sizeof v, 0, p, s, \"minor_t\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "mode_to_chars": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        416,
        1
      ],
      "content": "static bool\nmode_to_chars (mode_t v, char *p, size_t s)\n{\n  /* In the common case where the internal and external mode bits are the same,\n     and we are not using POSIX or GNU format,\n     propagate all unknown bits to the external mode.\n     This matches historical practice.\n     Otherwise, just copy the bits we know about.  */\n  int negative;\n  uintmax_t u;\n  if (S_ISUID == TSUID && S_ISGID == TSGID && S_ISVTX == TSVTX\n      && S_IRUSR == TUREAD && S_IWUSR == TUWRITE && S_IXUSR == TUEXEC\n      && S_IRGRP == TGREAD && S_IWGRP == TGWRITE && S_IXGRP == TGEXEC\n      && S_IROTH == TOREAD && S_IWOTH == TOWRITE && S_IXOTH == TOEXEC\n      && archive_format != POSIX_FORMAT\n      && archive_format != USTAR_FORMAT\n      && archive_format != GNU_FORMAT)\n    {\n      negative = v < 0;\n      u = v;\n    }\n  else\n    {\n      negative = 0;\n      u = ((v & S_ISUID ? TSUID : 0)\n\t   | (v & S_ISGID ? TSGID : 0)\n\t   | (v & S_ISVTX ? TSVTX : 0)\n\t   | (v & S_IRUSR ? TUREAD : 0)\n\t   | (v & S_IWUSR ? TUWRITE : 0)\n\t   | (v & S_IXUSR ? TUEXEC : 0)\n\t   | (v & S_IRGRP ? TGREAD : 0)\n\t   | (v & S_IWGRP ? TGWRITE : 0)\n\t   | (v & S_IXGRP ? TGEXEC : 0)\n\t   | (v & S_IROTH ? TOREAD : 0)\n\t   | (v & S_IWOTH ? TOWRITE : 0)\n\t   | (v & S_IXOTH ? TOEXEC : 0));\n    }\n  return to_chars (negative, u, sizeof v, 0, p, s, \"mode_t\");\n}",
      "lines": 39,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "off_to_chars": {
      "start_point": [
        418,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "bool\noff_to_chars (off_t v, char *p, size_t s)\n{\n  return to_chars (v < 0, (uintmax_t) v, sizeof v, 0, p, s, \"off_t\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "time_to_chars": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "bool\ntime_to_chars (time_t v, char *p, size_t s)\n{\n  return to_chars (v < 0, (uintmax_t) v, sizeof v, 0, p, s, \"time_t\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "uid_substitute": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "static uintmax_t\nuid_substitute (int *negative)\n{\n  uid_t r;\n#ifdef UID_NOBODY\n  r = UID_NOBODY;\n#else\n  static uid_t uid_nobody;\n  if (!uid_nobody && !uname_to_uid (\"nobody\", &uid_nobody))\n    uid_nobody = -2;\n  r = uid_nobody;\n#endif\n  *negative = r < 0;\n  return r;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "uintmax_t"
      ]
    },
    "uid_to_chars": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "static bool\nuid_to_chars (uid_t v, char *p, size_t s)\n{\n  return to_chars (v < 0, (uintmax_t) v, sizeof v, uid_substitute, p, s, \"uid_t\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "uintmax_to_chars": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        456,
        1
      ],
      "content": "static bool\nuintmax_to_chars (uintmax_t v, char *p, size_t s)\n{\n  return to_chars (0, v, sizeof v, 0, p, s, \"uintmax_t\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "string_to_chars": {
      "start_point": [
        458,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "static void\nstring_to_chars (char const *str, char *p, size_t s)\n{\n  tar_copy_str (p, str, s);\n  p[s - 1] = '\\0';\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "file_dumpable_p": {
      "start_point": [
        475,
        0
      ],
      "end_point": [
        485,
        1
      ],
      "content": "static bool\nfile_dumpable_p (struct stat const *st)\n{\n  if (S_ISDIR (st->st_mode))\n    return true;\n  if (! (S_ISREG (st->st_mode) || S_ISCTG (st->st_mode)))\n    return false;\n  if (dev_null_output)\n    return totals_option && sparse_option && ST_IS_SPARSE (*st);\n  return ! (st->st_size == 0 && (st->st_mode & MODE_R) == MODE_R);\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "write_eot": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "void\nwrite_eot (void)\n{\n  union block *pointer = find_next_block ();\n  memset (pointer->buffer, 0, BLOCKSIZE);\n  set_next_block_after (pointer);\n  pointer = find_next_block ();\n  memset (pointer->buffer, 0, available_space_after (pointer));\n  set_next_block_after (pointer);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "start_private_header": {
      "start_point": [
        505,
        0
      ],
      "end_point": [
        523,
        1
      ],
      "content": "union block *\nstart_private_header (const char *name, size_t size, time_t t)\n{\n  union block *header = find_next_block ();\n\n  memset (header->buffer, 0, sizeof (union block));\n\n  tar_name_copy_str (header->header.name, name, NAME_FIELD_SIZE);\n  OFF_TO_CHARS (size, header->header.size);\n\n  TIME_TO_CHARS (t < 0 ? 0 : min (t, MAX_OCTAL_VAL (header->header.mtime)),\n\t\t header->header.mtime);\n  MODE_TO_CHARS (S_IFREG|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, header->header.mode);\n  UID_TO_CHARS (0, header->header.uid);\n  GID_TO_CHARS (0, header->header.gid);\n  strncpy (header->header.magic, TMAGIC, TMAGLEN);\n  strncpy (header->header.version, TVERSION, TVERSLEN);\n  return header;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "union block",
        "union",
        "block",
        "*\nstart_private_header (const char *name, size_t size, time_t t)",
        "*"
      ]
    },
    "write_short_name": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "static union block *\nwrite_short_name (struct tar_stat_info *st)\n{\n  union block *header = find_next_block ();\n  memset (header->buffer, 0, sizeof (union block));\n  tar_name_copy_str (header->header.name, st->file_name, NAME_FIELD_SIZE);\n  return header;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "union block",
        "union",
        "block",
        "*\nwrite_short_name (struct tar_stat_info *st)",
        "*"
      ]
    },
    "write_gnu_long_link": {
      "start_point": [
        538,
        0
      ],
      "end_point": [
        579,
        1
      ],
      "content": "static void\nwrite_gnu_long_link (struct tar_stat_info *st, const char *p, char type)\n{\n  size_t size = strlen (p) + 1;\n  size_t bufsize;\n  union block *header;\n\n  header = start_private_header (\"././@LongLink\", size, 0);\n  if (! numeric_owner_option)\n    {\n      static char *uname, *gname;\n      if (!uname)\n\t{\n\t  uid_to_uname (0, &uname);\n\t  gid_to_gname (0, &gname);\n\t}\n      UNAME_TO_CHARS (uname, header->header.uname);\n      GNAME_TO_CHARS (gname, header->header.gname);\n    }\n\n  strcpy (header->buffer + offsetof (struct posix_header, magic),\n\t  OLDGNU_MAGIC);\n  header->header.typeflag = type;\n  finish_header (st, header, -1);\n\n  header = find_next_block ();\n\n  bufsize = available_space_after (header);\n\n  while (bufsize < size)\n    {\n      memcpy (header->buffer, p, bufsize);\n      p += bufsize;\n      size -= bufsize;\n      set_next_block_after (header + (bufsize - 1) / BLOCKSIZE);\n      header = find_next_block ();\n      bufsize = available_space_after (header);\n    }\n  memcpy (header->buffer, p, size);\n  memset (header->buffer + size, 0, bufsize - size);\n  set_next_block_after (header + (size - 1) / BLOCKSIZE);\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "split_long_name": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        594,
        1
      ],
      "content": "static size_t\nsplit_long_name (const char *name, size_t length)\n{\n  size_t i;\n\n  if (length > PREFIX_FIELD_SIZE + 1)\n    length = PREFIX_FIELD_SIZE + 1;\n  else if (ISSLASH (name[length - 1]))\n    length--;\n  for (i = length - 1; i > 0; i--)\n    if (ISSLASH (name[i]))\n      break;\n  return i;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "write_ustar_long_name": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "static union block *\nwrite_ustar_long_name (const char *name)\n{\n  size_t length = strlen (name);\n  size_t i, nlen;\n  union block *header;\n\n  if (length > PREFIX_FIELD_SIZE + NAME_FIELD_SIZE + 1)\n    {\n      ERROR ((0, 0, _(\"%s: file name is too long (max %d); not dumped\"),\n\t      quotearg_colon (name),\n\t      PREFIX_FIELD_SIZE + NAME_FIELD_SIZE + 1));\n      return NULL;\n    }\n\n  i = split_long_name (name, length);\n  if (i == 0 || (nlen = length - i - 1) > NAME_FIELD_SIZE || nlen == 0)\n    {\n      ERROR ((0, 0,\n\t      _(\"%s: file name is too long (cannot be split); not dumped\"),\n\t      quotearg_colon (name)));\n      return NULL;\n    }\n\n  header = find_next_block ();\n  memset (header->buffer, 0, sizeof (header->buffer));\n  memcpy (header->header.prefix, name, i);\n  memcpy (header->header.name, name + i + 1, length - i - 1);\n\n  return header;\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "union block",
        "union",
        "block",
        "*\nwrite_ustar_long_name (const char *name)",
        "*"
      ]
    },
    "write_long_link": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "static void\nwrite_long_link (struct tar_stat_info *st)\n{\n  switch (archive_format)\n    {\n    case POSIX_FORMAT:\n      xheader_store (\"linkpath\", st, NULL);\n      break;\n\n    case V7_FORMAT:\t\t\t/* old V7 tar format */\n    case USTAR_FORMAT:\n    case STAR_FORMAT:\n      ERROR ((0, 0,\n\t      _(\"%s: link name is too long; not dumped\"),\n\t      quotearg_colon (st->link_name)));\n      break;\n\n    case OLDGNU_FORMAT:\n    case GNU_FORMAT:\n      write_gnu_long_link (st, st->link_name, GNUTYPE_LONGLINK);\n      break;\n\n    default:\n      abort(); /*FIXME*/\n    }\n}",
      "lines": 26,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_long_name": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "static union block *\nwrite_long_name (struct tar_stat_info *st)\n{\n  switch (archive_format)\n    {\n    case POSIX_FORMAT:\n      xheader_store (\"path\", st, NULL);\n      break;\n\n    case V7_FORMAT:\n      if (strlen (st->file_name) > NAME_FIELD_SIZE-1)\n\t{\n\t  ERROR ((0, 0, _(\"%s: file name is too long (max %d); not dumped\"),\n\t\t  quotearg_colon (st->file_name),\n\t\t  NAME_FIELD_SIZE - 1));\n\t  return NULL;\n\t}\n      break;\n\n    case USTAR_FORMAT:\n    case STAR_FORMAT:\n      return write_ustar_long_name (st->file_name);\n\n    case OLDGNU_FORMAT:\n    case GNU_FORMAT:\n      write_gnu_long_link (st, st->file_name, GNUTYPE_LONGNAME);\n      break;\n\n    default:\n      abort(); /*FIXME*/\n    }\n  return write_short_name (st);\n}",
      "lines": 33,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "union block",
        "union",
        "block",
        "*\nwrite_long_name (struct tar_stat_info *st)",
        "*"
      ]
    },
    "write_extended": {
      "start_point": [
        690,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "union block *\nwrite_extended (bool global, struct tar_stat_info *st, union block *old_header)\n{\n  union block *header, hp;\n  char *p;\n  int type;\n  time_t t;\n\n  if (st->xhdr.buffer || st->xhdr.stk == NULL)\n    return old_header;\n\n  xheader_finish (&st->xhdr);\n  memcpy (hp.buffer, old_header, sizeof (hp));\n  if (global)\n    {\n      type = XGLTYPE;\n      p = xheader_ghdr_name ();\n      t = start_time.tv_sec;\n    }\n  else\n    {\n      type = XHDTYPE;\n      p = xheader_xhdr_name (st);\n      t = set_mtime_option ? mtime_option.tv_sec : st->stat.st_mtime;\n    }\n  xheader_write (type, p, t, &st->xhdr);\n  free (p);\n  header = find_next_block ();\n  memcpy (header, &hp.buffer, sizeof (hp.buffer));\n  return header;\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "union block",
        "union",
        "block",
        "*\nwrite_extended (bool global, struct tar_stat_info *st, union block *old_header)",
        "*"
      ]
    },
    "write_header_name": {
      "start_point": [
        722,
        0
      ],
      "end_point": [
        735,
        1
      ],
      "content": "static union block *\nwrite_header_name (struct tar_stat_info *st)\n{\n  if (archive_format == POSIX_FORMAT && !string_ascii_p (st->file_name))\n    {\n      xheader_store (\"path\", st, NULL);\n      return write_short_name (st);\n    }\n  else if (NAME_FIELD_SIZE - (archive_format == OLDGNU_FORMAT)\n\t   < strlen (st->file_name))\n    return write_long_name (st);\n  else\n    return write_short_name (st);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "union block",
        "union",
        "block",
        "*\nwrite_header_name (struct tar_stat_info *st)",
        "*"
      ]
    },
    "start_header": {
      "start_point": [
        743,
        0
      ],
      "end_point": [
        981,
        1
      ],
      "content": "union block *\nstart_header (struct tar_stat_info *st)\n{\n  union block *header;\n  char const *uname = NULL;\n  char const *gname = NULL;\n\n  header = write_header_name (st);\n  if (!header)\n    return NULL;\n\n  /* Override some stat fields, if requested to do so.  */\n  owner_map_translate (st->stat.st_uid, &st->stat.st_uid, &uname);\n  group_map_translate (st->stat.st_gid, &st->stat.st_gid, &gname);\n\n  if (mode_option)\n    st->stat.st_mode =\n      ((st->stat.st_mode & ~MODE_ALL)\n       | mode_adjust (st->stat.st_mode, S_ISDIR (st->stat.st_mode) != 0,\n\t\t      initial_umask, mode_option, NULL));\n\n  /* Paul Eggert tried the trivial test ($WRITER cf a b; $READER tvf a)\n     for a few tars and came up with the following interoperability\n     matrix:\n\n\t      WRITER\n\t1 2 3 4 5 6 7 8 9   READER\n\t. . . . . . . . .   1 = SunOS 4.2 tar\n\t# . . # # . . # #   2 = NEC SVR4.0.2 tar\n\t. . . # # . . # .   3 = Solaris 2.1 tar\n\t. . . . . . . . .   4 = GNU tar 1.11.1\n\t. . . . . . . . .   5 = HP-UX 8.07 tar\n\t. . . . . . . . .   6 = Ultrix 4.1\n\t. . . . . . . . .   7 = AIX 3.2\n\t. . . . . . . . .   8 = Hitachi HI-UX 1.03\n\t. . . . . . . . .   9 = Omron UNIOS-B 4.3BSD 1.60Beta\n\n\t     . = works\n\t     # = \"impossible file type\"\n\n     The following mask for old archive removes the '#'s in column 4\n     above, thus making GNU tar both a universal donor and a universal\n     acceptor for Paul's test.  */\n\n  if (archive_format == V7_FORMAT || archive_format == USTAR_FORMAT)\n    MODE_TO_CHARS (st->stat.st_mode & MODE_ALL, header->header.mode);\n  else\n    MODE_TO_CHARS (st->stat.st_mode, header->header.mode);\n\n  {\n    uid_t uid = st->stat.st_uid;\n    if (archive_format == POSIX_FORMAT\n\t&& MAX_OCTAL_VAL (header->header.uid) < uid)\n      {\n\txheader_store (\"uid\", st, NULL);\n\tuid = 0;\n      }\n    if (!UID_TO_CHARS (uid, header->header.uid))\n      return NULL;\n  }\n\n  {\n    gid_t gid = st->stat.st_gid;\n    if (archive_format == POSIX_FORMAT\n\t&& MAX_OCTAL_VAL (header->header.gid) < gid)\n      {\n\txheader_store (\"gid\", st, NULL);\n\tgid = 0;\n      }\n    if (!GID_TO_CHARS (gid, header->header.gid))\n      return NULL;\n  }\n\n  {\n    off_t size = st->stat.st_size;\n    if (archive_format == POSIX_FORMAT\n\t&& MAX_OCTAL_VAL (header->header.size) < size)\n      {\n\txheader_store (\"size\", st, NULL);\n\tsize = 0;\n      }\n    if (!OFF_TO_CHARS (size, header->header.size))\n      return NULL;\n  }\n\n  {\n    struct timespec mtime;\n\n    switch (set_mtime_option)\n      {\n      case USE_FILE_MTIME:\n\tmtime = st->mtime;\n\tbreak;\n\n      case FORCE_MTIME:\n\tmtime = mtime_option;\n\tbreak;\n\n      case CLAMP_MTIME:\n\tmtime = timespec_cmp (st->mtime, mtime_option) > 0\n\t           ? mtime_option : st->mtime;\n\tbreak;\n      }\n\n    if (archive_format == POSIX_FORMAT)\n      {\n\tif (MAX_OCTAL_VAL (header->header.mtime) < mtime.tv_sec\n\t    || mtime.tv_nsec != 0)\n\t  xheader_store (\"mtime\", st, &mtime);\n\tif (MAX_OCTAL_VAL (header->header.mtime) < mtime.tv_sec)\n\t  mtime.tv_sec = 0;\n      }\n    if (!TIME_TO_CHARS (mtime.tv_sec, header->header.mtime))\n      return NULL;\n  }\n\n  /* FIXME */\n  if (S_ISCHR (st->stat.st_mode)\n      || S_ISBLK (st->stat.st_mode))\n    {\n      major_t devmajor = major (st->stat.st_rdev);\n      minor_t devminor = minor (st->stat.st_rdev);\n\n      if (archive_format == POSIX_FORMAT\n\t  && MAX_OCTAL_VAL (header->header.devmajor) < devmajor)\n\t{\n\t  xheader_store (\"devmajor\", st, NULL);\n\t  devmajor = 0;\n\t}\n      if (!MAJOR_TO_CHARS (devmajor, header->header.devmajor))\n\treturn NULL;\n\n      if (archive_format == POSIX_FORMAT\n\t  && MAX_OCTAL_VAL (header->header.devminor) < devminor)\n\t{\n\t  xheader_store (\"devminor\", st, NULL);\n\t  devminor = 0;\n\t}\n      if (!MINOR_TO_CHARS (devminor, header->header.devminor))\n\treturn NULL;\n    }\n  else if (archive_format != GNU_FORMAT && archive_format != OLDGNU_FORMAT)\n    {\n      if (!(MAJOR_TO_CHARS (0, header->header.devmajor)\n\t    && MINOR_TO_CHARS (0, header->header.devminor)))\n\treturn NULL;\n    }\n\n  if (archive_format == POSIX_FORMAT)\n    {\n      xheader_store (\"atime\", st, NULL);\n      xheader_store (\"ctime\", st, NULL);\n    }\n  else if (incremental_option)\n    if (archive_format == OLDGNU_FORMAT || archive_format == GNU_FORMAT)\n      {\n\tTIME_TO_CHARS (st->atime.tv_sec, header->oldgnu_header.atime);\n\tTIME_TO_CHARS (st->ctime.tv_sec, header->oldgnu_header.ctime);\n      }\n\n  header->header.typeflag = archive_format == V7_FORMAT ? AREGTYPE : REGTYPE;\n\n  switch (archive_format)\n    {\n    case V7_FORMAT:\n      break;\n\n    case OLDGNU_FORMAT:\n    case GNU_FORMAT:   /*FIXME?*/\n      /* Overwrite header->header.magic and header.version in one blow.  */\n      strcpy (header->buffer + offsetof (struct posix_header, magic),\n\t      OLDGNU_MAGIC);\n      break;\n\n    case POSIX_FORMAT:\n    case USTAR_FORMAT:\n      strncpy (header->header.magic, TMAGIC, TMAGLEN);\n      strncpy (header->header.version, TVERSION, TVERSLEN);\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (archive_format == V7_FORMAT || numeric_owner_option)\n    {\n      /* header->header.[ug]name are left as the empty string.  */\n    }\n  else\n    {\n      if (uname)\n\tst->uname = xstrdup (uname);\n      else\n\tuid_to_uname (st->stat.st_uid, &st->uname);\n\n      if (gname)\n\tst->gname = xstrdup (gname);\n      else\n\tgid_to_gname (st->stat.st_gid, &st->gname);\n\n      if (archive_format == POSIX_FORMAT\n\t  && (strlen (st->uname) > UNAME_FIELD_SIZE\n\t      || !string_ascii_p (st->uname)))\n\txheader_store (\"uname\", st, NULL);\n      UNAME_TO_CHARS (st->uname, header->header.uname);\n\n      if (archive_format == POSIX_FORMAT\n\t  && (strlen (st->gname) > GNAME_FIELD_SIZE\n\t      || !string_ascii_p (st->gname)))\n\txheader_store (\"gname\", st, NULL);\n      GNAME_TO_CHARS (st->gname, header->header.gname);\n    }\n\n  if (archive_format == POSIX_FORMAT)\n    {\n      if (acls_option > 0)\n        {\n          if (st->acls_a_ptr)\n            xheader_store (\"SCHILY.acl.access\", st, NULL);\n          if (st->acls_d_ptr)\n            xheader_store (\"SCHILY.acl.default\", st, NULL);\n        }\n      if ((selinux_context_option > 0) && st->cntx_name)\n        xheader_store (\"RHT.security.selinux\", st, NULL);\n      if (xattrs_option > 0)\n        {\n          size_t scan_xattr = 0;\n          struct xattr_array *xattr_map = st->xattr_map;\n\n          while (scan_xattr < st->xattr_map_size)\n            {\n              xheader_store (xattr_map[scan_xattr].xkey, st, &scan_xattr);\n              ++scan_xattr;\n            }\n        }\n    }\n\n  return header;\n}",
      "lines": 239,
      "depth": 15,
      "decorators": [
        "union block",
        "union",
        "block",
        "*\nstart_header (struct tar_stat_info *st)",
        "*"
      ]
    },
    "simple_finish_header": {
      "start_point": [
        983,
        0
      ],
      "end_point": [
        1011,
        1
      ],
      "content": "void\nsimple_finish_header (union block *header)\n{\n  size_t i;\n  int sum;\n  char *p;\n\n  memcpy (header->header.chksum, CHKBLANKS, sizeof header->header.chksum);\n\n  sum = 0;\n  p = header->buffer;\n  for (i = sizeof *header; i-- != 0; )\n    /* We can't use unsigned char here because of old compilers, e.g. V7.  */\n    sum += 0xFF & *p++;\n\n  /* Fill in the checksum field.  It's formatted differently from the\n     other fields: it has [6] digits, a null, then a space -- rather than\n     digits, then a null.  We use to_chars.\n     The final space is already there, from\n     checksumming, and to_chars doesn't modify it.\n\n     This is a fast way to do:\n\n     sprintf(header->header.chksum, \"%6o\", sum);  */\n\n  uintmax_to_chars ((uintmax_t) sum, header->header.chksum, 7);\n\n  set_next_block_after (header);\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "finish_header": {
      "start_point": [
        1017,
        0
      ],
      "end_point": [
        1036,
        1
      ],
      "content": "void\nfinish_header (struct tar_stat_info *st,\n\t       union block *header, off_t block_ordinal)\n{\n  /* Note: It is important to do this before the call to write_extended(),\n     so that the actual ustar header is printed */\n  if (verbose_option\n      && header->header.typeflag != GNUTYPE_LONGLINK\n      && header->header.typeflag != GNUTYPE_LONGNAME\n      && header->header.typeflag != XHDTYPE\n      && header->header.typeflag != XGLTYPE)\n    {\n      /* FIXME: This global is used in print_header, sigh.  */\n      current_format = archive_format;\n      print_header (st, header, block_ordinal);\n    }\n\n  header = write_extended (false, st, header);\n  simple_finish_header (header);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "pad_archive": {
      "start_point": [
        1039,
        0
      ],
      "end_point": [
        1050,
        1
      ],
      "content": "void\npad_archive (off_t size_left)\n{\n  union block *blk;\n  while (size_left > 0)\n    {\n      blk = find_next_block ();\n      memset (blk->buffer, 0, BLOCKSIZE);\n      set_next_block_after (blk);\n      size_left -= BLOCKSIZE;\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "dump_regular_file": {
      "start_point": [
        1052,
        0
      ],
      "end_point": [
        1117,
        1
      ],
      "content": "static enum dump_status\ndump_regular_file (int fd, struct tar_stat_info *st)\n{\n  off_t size_left = st->stat.st_size;\n  off_t block_ordinal;\n  union block *blk;\n\n  block_ordinal = current_block_ordinal ();\n  blk = start_header (st);\n  if (!blk)\n    return dump_status_fail;\n\n  /* Mark contiguous files, if we support them.  */\n  if (archive_format != V7_FORMAT && S_ISCTG (st->stat.st_mode))\n    blk->header.typeflag = CONTTYPE;\n\n  finish_header (st, blk, block_ordinal);\n\n  mv_begin_write (st->file_name, st->stat.st_size, st->stat.st_size);\n  while (size_left > 0)\n    {\n      size_t bufsize, count;\n\n      blk = find_next_block ();\n\n      bufsize = available_space_after (blk);\n\n      if (size_left < bufsize)\n\t{\n\t  /* Last read -- zero out area beyond.  */\n\t  bufsize = size_left;\n\t  count = bufsize % BLOCKSIZE;\n\t  if (count)\n\t    memset (blk->buffer + size_left, 0, BLOCKSIZE - count);\n\t}\n\n      count = (fd <= 0) ? bufsize : blocking_read (fd, blk->buffer, bufsize);\n      if (count == SAFE_READ_ERROR)\n\t{\n\t  read_diag_details (st->orig_file_name,\n\t                     st->stat.st_size - size_left, bufsize);\n\t  pad_archive (size_left);\n\t  return dump_status_short;\n\t}\n      size_left -= count;\n      set_next_block_after (blk + (bufsize - 1) / BLOCKSIZE);\n\n      if (count != bufsize)\n\t{\n\t  char buf[UINTMAX_STRSIZE_BOUND];\n\t  memset (blk->buffer + count, 0, bufsize - count);\n\t  WARNOPT (WARN_FILE_SHRANK,\n\t\t   (0, 0,\n\t\t    ngettext (\"%s: File shrank by %s byte; padding with zeros\",\n\t\t\t      \"%s: File shrank by %s bytes; padding with zeros\",\n\t\t\t      size_left),\n\t\t    quotearg_colon (st->orig_file_name),\n\t\t    STRINGIFY_BIGINT (size_left, buf)));\n\t  if (! ignore_failed_read_option)\n\t    set_exit_status (TAREXIT_DIFFERS);\n\t  pad_archive (size_left - (bufsize - count));\n\t  return dump_status_short;\n\t}\n    }\n  return dump_status_ok;\n}",
      "lines": 66,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "enum dump_status",
        "enum",
        "dump_status"
      ]
    },
    "dump_dir0": {
      "start_point": [
        1123,
        0
      ],
      "end_point": [
        1261,
        1
      ],
      "content": "static void\ndump_dir0 (struct tar_stat_info *st, char const *directory)\n{\n  bool top_level = ! st->parent;\n  const char *tag_file_name;\n  union block *blk = NULL;\n  off_t block_ordinal = current_block_ordinal ();\n\n  st->stat.st_size = 0;\t/* force 0 size on dir */\n\n  blk = start_header (st);\n  if (!blk)\n    return;\n\n  info_attach_exclist (st);\n\n  if (incremental_option && archive_format != POSIX_FORMAT)\n    blk->header.typeflag = GNUTYPE_DUMPDIR;\n  else /* if (standard_option) */\n    blk->header.typeflag = DIRTYPE;\n\n  /* If we're gnudumping, we aren't done yet so don't close it.  */\n\n  if (!incremental_option)\n    finish_header (st, blk, block_ordinal);\n  else if (gnu_list_name->directory)\n    {\n      if (archive_format == POSIX_FORMAT)\n\t{\n\t  xheader_store (\"GNU.dumpdir\", st,\n\t\t\t safe_directory_contents (gnu_list_name->directory));\n\t  finish_header (st, blk, block_ordinal);\n\t}\n      else\n\t{\n\t  off_t size_left;\n\t  off_t totsize;\n\t  size_t bufsize;\n\t  ssize_t count;\n\t  const char *buffer, *p_buffer;\n\n\t  block_ordinal = current_block_ordinal ();\n\t  buffer = safe_directory_contents (gnu_list_name->directory);\n\t  totsize = dumpdir_size (buffer);\n\t  OFF_TO_CHARS (totsize, blk->header.size);\n\t  finish_header (st, blk, block_ordinal);\n\t  p_buffer = buffer;\n\t  size_left = totsize;\n\n\t  mv_begin_write (st->file_name, totsize, totsize);\n\t  while (size_left > 0)\n\t    {\n\t      blk = find_next_block ();\n\t      bufsize = available_space_after (blk);\n\t      if (size_left < bufsize)\n\t\t{\n\t\t  bufsize = size_left;\n\t\t  count = bufsize % BLOCKSIZE;\n\t\t  if (count)\n\t\t    memset (blk->buffer + size_left, 0, BLOCKSIZE - count);\n\t\t}\n\t      memcpy (blk->buffer, p_buffer, bufsize);\n\t      size_left -= bufsize;\n\t      p_buffer += bufsize;\n\t      set_next_block_after (blk + (bufsize - 1) / BLOCKSIZE);\n\t    }\n\t}\n      return;\n    }\n\n  if (!recursion_option)\n    return;\n\n  if (one_file_system_option\n      && !top_level\n      && st->parent->stat.st_dev != st->stat.st_dev)\n    {\n      if (verbose_option)\n\tWARNOPT (WARN_XDEV,\n\t\t (0, 0,\n\t\t  _(\"%s: file is on a different filesystem; not dumped\"),\n\t\t  quotearg_colon (st->orig_file_name)));\n    }\n  else\n    {\n      char *name_buf;\n      size_t name_size;\n\n      switch (check_exclusion_tags (st, &tag_file_name))\n\t{\n\tcase exclusion_tag_all:\n\t  /* Handled in dump_file0 */\n\t  break;\n\n\tcase exclusion_tag_none:\n\t  {\n\t    char const *entry;\n\t    size_t entry_len;\n\t    size_t name_len;\n\n\t    name_buf = xstrdup (st->orig_file_name);\n\t    name_size = name_len = strlen (name_buf);\n\n\t    /* Now output all the files in the directory.  */\n\t    for (entry = directory; (entry_len = strlen (entry)) != 0;\n\t\t entry += entry_len + 1)\n\t      {\n\t\tif (name_size < name_len + entry_len)\n\t\t  {\n\t\t    name_size = name_len + entry_len;\n\t\t    name_buf = xrealloc (name_buf, name_size + 1);\n\t\t  }\n\t\tstrcpy (name_buf + name_len, entry);\n\t\tif (!excluded_name (name_buf, st))\n\t\t  dump_file (st, entry, name_buf);\n\t      }\n\n\t    free (name_buf);\n\t  }\n\t  break;\n\n\tcase exclusion_tag_contents:\n\t  exclusion_tag_warning (st->orig_file_name, tag_file_name,\n\t\t\t\t _(\"contents not dumped\"));\n\t  name_size = strlen (st->orig_file_name) + strlen (tag_file_name) + 1;\n\t  name_buf = xmalloc (name_size);\n\t  strcpy (name_buf, st->orig_file_name);\n\t  strcat (name_buf, tag_file_name);\n\t  dump_file (st, tag_file_name, name_buf);\n\t  free (name_buf);\n\t  break;\n\n\tcase exclusion_tag_under:\n\t  exclusion_tag_warning (st->orig_file_name, tag_file_name,\n\t\t\t\t _(\"contents not dumped\"));\n\t  break;\n\t}\n    }\n}",
      "lines": 139,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ensure_slash": {
      "start_point": [
        1264,
        0
      ],
      "end_point": [
        1274,
        1
      ],
      "content": "static void\nensure_slash (char **pstr)\n{\n  size_t len = strlen (*pstr);\n  while (len >= 1 && ISSLASH ((*pstr)[len - 1]))\n    len--;\n  if (!ISSLASH ((*pstr)[len]))\n    *pstr = xrealloc (*pstr, len + 2);\n  (*pstr)[len++] = '/';\n  (*pstr)[len] = '\\0';\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_failure_recover": {
      "start_point": [
        1287,
        0
      ],
      "end_point": [
        1303,
        1
      ],
      "content": "static bool\nopen_failure_recover (struct tar_stat_info const *dir)\n{\n  if (errno == EMFILE && dir && dir->parent)\n    {\n      struct tar_stat_info *p;\n      for (p = dir->parent->parent; p; p = p->parent)\n\tif (0 < p->fd && (! p->parent || p->parent->fd <= 0))\n\t  {\n\t    tar_stat_close (p);\n\t    return true;\n\t  }\n      errno = EMFILE;\n    }\n\n  return false;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_directory_entries": {
      "start_point": [
        1308,
        0
      ],
      "end_point": [
        1315,
        1
      ],
      "content": "char *\nget_directory_entries (struct tar_stat_info *st)\n{\n  while (! (st->dirstream = fdopendir (st->fd)))\n    if (! open_failure_recover (st))\n      return 0;\n  return streamsavedir (st->dirstream, savedir_sort_order);\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "char",
        "*\nget_directory_entries (struct tar_stat_info *st)",
        "*"
      ]
    },
    "dump_dir": {
      "start_point": [
        1320,
        0
      ],
      "end_point": [
        1335,
        1
      ],
      "content": "static bool\ndump_dir (struct tar_stat_info *st)\n{\n  char *directory = get_directory_entries (st);\n  if (! directory)\n    {\n      savedir_diag (st->orig_file_name);\n      return false;\n    }\n\n  dump_dir0 (st, directory);\n\n  restore_parent_fd (st);\n  free (directory);\n  return true;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "create_archive": {
      "start_point": [
        1346,
        0
      ],
      "end_point": [
        1438,
        1
      ],
      "content": "void\ncreate_archive (void)\n{\n  struct name const *p;\n\n  trivial_link_count = name_count <= 1 && ! dereference_option;\n\n  open_archive (ACCESS_WRITE);\n  buffer_write_global_xheader ();\n\n  if (incremental_option)\n    {\n      size_t buffer_size = 1000;\n      char *buffer = xmalloc (buffer_size);\n      const char *q;\n\n      collect_and_sort_names ();\n\n      while ((p = name_from_list ()) != NULL)\n\tif (!excluded_name (p->name, NULL))\n\t  dump_file (0, p->name, p->name);\n\n      blank_name_list ();\n      while ((p = name_from_list ()) != NULL)\n\tif (!excluded_name (p->name, NULL))\n\t  {\n\t    struct tar_stat_info st;\n\t    size_t plen = strlen (p->name);\n\t    if (buffer_size <= plen)\n\t      {\n\t\twhile ((buffer_size *= 2) <= plen)\n\t\t  continue;\n\t\tbuffer = xrealloc (buffer, buffer_size);\n\t      }\n\t    memcpy (buffer, p->name, plen);\n\t    if (! ISSLASH (buffer[plen - 1]))\n\t      buffer[plen++] = DIRECTORY_SEPARATOR;\n\t    tar_stat_init (&st);\n\t    q = directory_contents (p->directory);\n\t    if (q)\n\t      while (*q)\n\t\t{\n\t\t  size_t qlen = strlen (q);\n\t\t  if (*q == 'Y')\n\t\t    {\n\t\t      if (! st.orig_file_name)\n\t\t\t{\n\t\t\t  int fd = openat (chdir_fd, p->name,\n\t\t\t\t\t   open_searchdir_flags);\n\t\t\t  if (fd < 0)\n\t\t\t    {\n\t\t\t      file_removed_diag (p->name, !p->parent,\n\t\t\t\t\t\t open_diag);\n\t\t\t      break;\n\t\t\t    }\n\t\t\t  st.fd = fd;\n\t\t\t  if (fstat (fd, &st.stat) != 0)\n\t\t\t    {\n\t\t\t      file_removed_diag (p->name, !p->parent,\n\t\t\t\t\t\t stat_diag);\n\t\t\t      break;\n\t\t\t    }\n\t\t\t  st.orig_file_name = xstrdup (p->name);\n\t\t\t}\n\t\t      if (buffer_size < plen + qlen)\n\t\t\t{\n\t\t\t  while ((buffer_size *=2 ) < plen + qlen)\n\t\t\t    continue;\n\t\t\t  buffer = xrealloc (buffer, buffer_size);\n \t\t\t}\n\t\t      strcpy (buffer + plen, q + 1);\n\t\t      dump_file (&st, q + 1, buffer);\n\t\t    }\n\t\t  q += qlen + 1;\n\t\t}\n\t    tar_stat_destroy (&st);\n\t  }\n      free (buffer);\n    }\n  else\n    {\n      const char *name;\n      while ((name = name_next (1)) != NULL)\n\tif (!excluded_name (name, NULL))\n\t  dump_file (0, name, name);\n    }\n\n  write_eot ();\n  close_archive ();\n  finish_deferred_unlinks ();\n  if (listed_incremental_option)\n    write_directory_file ();\n}",
      "lines": 93,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "hash_link": {
      "start_point": [
        1442,
        0
      ],
      "end_point": [
        1448,
        1
      ],
      "content": "static size_t\nhash_link (void const *entry, size_t n_buckets)\n{\n  struct link const *l = entry;\n  uintmax_t num = l->dev ^ l->ino;\n  return num % n_buckets;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "compare_links": {
      "start_point": [
        1451,
        0
      ],
      "end_point": [
        1457,
        1
      ],
      "content": "static bool\ncompare_links (void const *entry1, void const *entry2)\n{\n  struct link const *link1 = entry1;\n  struct link const *link2 = entry2;\n  return ((link1->dev ^ link2->dev) | (link1->ino ^ link2->ino)) == 0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "unknown_file_error": {
      "start_point": [
        1459,
        0
      ],
      "end_point": [
        1467,
        1
      ],
      "content": "static void\nunknown_file_error (char const *p)\n{\n  WARNOPT (WARN_FILE_IGNORED,\n\t   (0, 0, _(\"%s: Unknown file type; file ignored\"),\n\t    quotearg_colon (p)));\n  if (!ignore_failed_read_option)\n    set_exit_status (TAREXIT_FAILURE);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_hard_link": {
      "start_point": [
        1479,
        0
      ],
      "end_point": [
        1523,
        1
      ],
      "content": "static bool\ndump_hard_link (struct tar_stat_info *st)\n{\n  if (link_table\n      && (trivial_link_count < st->stat.st_nlink || remove_files_option))\n    {\n      struct link lp;\n      struct link *duplicate;\n      off_t block_ordinal;\n      union block *blk;\n\n      lp.ino = st->stat.st_ino;\n      lp.dev = st->stat.st_dev;\n\n      if ((duplicate = hash_lookup (link_table, &lp)))\n\t{\n\t  /* We found a link.  */\n\t  char const *link_name = safer_name_suffix (duplicate->name, true,\n\t                                             absolute_names_option);\n\t  if (duplicate->nlink)\n\t    duplicate->nlink--;\n\n\t  block_ordinal = current_block_ordinal ();\n\t  assign_string (&st->link_name, link_name);\n\t  if (NAME_FIELD_SIZE - (archive_format == OLDGNU_FORMAT)\n\t      < strlen (link_name))\n\t    write_long_link (st);\n\n\t  st->stat.st_size = 0;\n\t  blk = start_header (st);\n\t  if (!blk)\n\t    return false;\n\t  tar_copy_str (blk->header.linkname, link_name, NAME_FIELD_SIZE);\n\n\t  blk->header.typeflag = LNKTYPE;\n\t  finish_header (st, blk, block_ordinal);\n\n\t  if (remove_files_option)\n\t    queue_deferred_unlink (st->orig_file_name, false);\n\n\t  return true;\n\t}\n    }\n  return false;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "file_count_links": {
      "start_point": [
        1525,
        0
      ],
      "end_point": [
        1558,
        1
      ],
      "content": "static void\nfile_count_links (struct tar_stat_info *st)\n{\n  if (hard_dereference_option)\n    return;\n  if (trivial_link_count < st->stat.st_nlink)\n    {\n      struct link *duplicate;\n      char *linkname = NULL;\n      struct link *lp;\n\n      assign_string (&linkname, safer_name_suffix (st->orig_file_name, true,\n\t\t\t\t\t\t   absolute_names_option));\n      transform_name (&linkname, XFORM_LINK);\n\n      lp = xmalloc (offsetof (struct link, name)\n\t\t\t\t + strlen (linkname) + 1);\n      lp->ino = st->stat.st_ino;\n      lp->dev = st->stat.st_dev;\n      lp->nlink = st->stat.st_nlink;\n      strcpy (lp->name, linkname);\n      free (linkname);\n\n      if (! ((link_table\n\t      || (link_table = hash_initialize (0, 0, hash_link,\n\t\t\t\t\t\tcompare_links, 0)))\n\t     && (duplicate = hash_insert (link_table, lp))))\n\txalloc_die ();\n\n      if (duplicate != lp)\n\tabort ();\n      lp->nlink--;\n    }\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_links": {
      "start_point": [
        1562,
        0
      ],
      "end_point": [
        1578,
        1
      ],
      "content": "void\ncheck_links (void)\n{\n  struct link *lp;\n\n  if (!link_table)\n    return;\n\n  for (lp = hash_get_first (link_table); lp;\n       lp = hash_get_next (link_table, lp))\n    {\n      if (lp->nlink)\n\t{\n\t  WARN ((0, 0, _(\"Missing links to %s.\"), quote (lp->name)));\n\t}\n    }\n}",
      "lines": 17,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "subfile_open": {
      "start_point": [
        1584,
        0
      ],
      "end_point": [
        1605,
        1
      ],
      "content": "int\nsubfile_open (struct tar_stat_info const *dir, char const *file, int flags)\n{\n  int fd;\n\n  static bool initialized;\n  if (! initialized)\n    {\n      /* Initialize any tables that might be needed when file\n\t descriptors are exhausted, and whose initialization might\n\t require a file descriptor.  This includes the system message\n\t catalog and tar's message catalog.  */\n      initialized = true;\n      strerror (ENOENT);\n      gettext (\"\");\n    }\n\n  while ((fd = openat (dir ? dir->fd : chdir_fd, file, flags)) < 0\n\t && open_failure_recover (dir))\n    continue;\n  return fd;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "restore_parent_fd": {
      "start_point": [
        1611,
        0
      ],
      "end_point": [
        1647,
        1
      ],
      "content": "void\nrestore_parent_fd (struct tar_stat_info const *st)\n{\n  struct tar_stat_info *parent = st->parent;\n  if (parent && ! parent->fd)\n    {\n      int parentfd = openat (st->fd, \"..\", open_searchdir_flags);\n      struct stat parentstat;\n\n      if (parentfd < 0)\n\tparentfd = - errno;\n      else if (! (fstat (parentfd, &parentstat) == 0\n\t\t  && parent->stat.st_ino == parentstat.st_ino\n\t\t  && parent->stat.st_dev == parentstat.st_dev))\n\t{\n\t  close (parentfd);\n\t  parentfd = IMPOSTOR_ERRNO;\n\t}\n\n      if (parentfd < 0)\n\t{\n\t  int origfd = openat (chdir_fd, parent->orig_file_name,\n\t\t\t       open_searchdir_flags);\n\t  if (0 <= origfd)\n\t    {\n\t      if (fstat (parentfd, &parentstat) == 0\n\t\t  && parent->stat.st_ino == parentstat.st_ino\n\t\t  && parent->stat.st_dev == parentstat.st_dev)\n\t\tparentfd = origfd;\n\t      else\n\t\tclose (origfd);\n\t    }\n\t}\n\n      parent->fd = parentfd;\n    }\n}",
      "lines": 37,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "dump_file0": {
      "start_point": [
        1656,
        0
      ],
      "end_point": [
        1934,
        5
      ],
      "content": "static void\ndump_file0 (struct tar_stat_info *st, char const *name, char const *p)\n{\n  union block *header;\n  char type;\n  off_t original_size;\n  struct timespec original_ctime;\n  off_t block_ordinal = -1;\n  int fd = 0;\n  bool is_dir;\n  struct tar_stat_info const *parent = st->parent;\n  bool top_level = ! parent;\n  int parentfd = top_level ? chdir_fd : parent->fd;\n  void (*diag) (char const *) = 0;\n\n  if (interactive_option && !confirm (\"add\", p))\n    return;\n\n  assign_string (&st->orig_file_name, p);\n  assign_string (&st->file_name,\n                 safer_name_suffix (p, false, absolute_names_option));\n\n  transform_name (&st->file_name, XFORM_REGFILE);\n\n  if (parentfd < 0 && ! top_level)\n    {\n      errno = - parentfd;\n      diag = open_diag;\n    }\n  else if (fstatat (parentfd, name, &st->stat, fstatat_flags) != 0)\n    diag = stat_diag;\n  else if (file_dumpable_p (&st->stat))\n    {\n      fd = subfile_open (parent, name, open_read_flags);\n      if (fd < 0)\n\tdiag = open_diag;\n      else\n\t{\n\t  st->fd = fd;\n\t  if (fstat (fd, &st->stat) != 0)\n\t    diag = stat_diag;\n\t}\n    }\n  if (diag)\n    {\n      file_removed_diag (p, top_level, diag);\n      return;\n    }\n\n  st->archive_file_size = original_size = st->stat.st_size;\n  st->atime = get_stat_atime (&st->stat);\n  st->mtime = get_stat_mtime (&st->stat);\n  st->ctime = original_ctime = get_stat_ctime (&st->stat);\n\n#ifdef S_ISHIDDEN\n  if (S_ISHIDDEN (st->stat.st_mode))\n    {\n      char *new = (char *) alloca (strlen (p) + 2);\n      if (new)\n\t{\n\t  strcpy (new, p);\n\t  strcat (new, \"@\");\n\t  p = new;\n\t}\n    }\n#endif\n\n  /* See if we want only new files, and check if this one is too old to\n     put in the archive.\n\n     This check is omitted if incremental_option is set *and* the\n     requested file is not explicitly listed in the command line.  */\n\n  if (! (incremental_option && ! top_level)\n      && !S_ISDIR (st->stat.st_mode)\n      && OLDER_TAR_STAT_TIME (*st, m)\n      && (!after_date_option || OLDER_TAR_STAT_TIME (*st, c)))\n    {\n      if (!incremental_option && verbose_option)\n\tWARNOPT (WARN_FILE_UNCHANGED,\n\t\t (0, 0, _(\"%s: file is unchanged; not dumped\"),\n\t\t  quotearg_colon (p)));\n      return;\n    }\n\n  /* See if we are trying to dump the archive.  */\n  if (sys_file_is_archive (st))\n    {\n      WARNOPT (WARN_IGNORE_ARCHIVE,\n\t       (0, 0, _(\"%s: file is the archive; not dumped\"),\n\t\tquotearg_colon (p)));\n      return;\n    }\n\n  is_dir = S_ISDIR (st->stat.st_mode) != 0;\n\n  if (!is_dir && dump_hard_link (st))\n    return;\n\n  if (is_dir || S_ISREG (st->stat.st_mode) || S_ISCTG (st->stat.st_mode))\n    {\n      bool ok;\n      struct stat final_stat;\n\n      xattrs_acls_get (parentfd, name, st, 0, !is_dir);\n      xattrs_selinux_get (parentfd, name, st, fd);\n      xattrs_xattrs_get (parentfd, name, st, fd);\n\n      if (is_dir)\n\t{\n\t  const char *tag_file_name;\n\t  ensure_slash (&st->orig_file_name);\n\t  ensure_slash (&st->file_name);\n\n\t  if (check_exclusion_tags (st, &tag_file_name) == exclusion_tag_all)\n\t    {\n\t      exclusion_tag_warning (st->orig_file_name, tag_file_name,\n\t\t\t\t     _(\"directory not dumped\"));\n\t      return;\n\t    }\n\n\t  ok = dump_dir (st);\n\n\t  fd = st->fd;\n\t  parentfd = top_level ? chdir_fd : parent->fd;\n\t}\n      else\n\t{\n\t  enum dump_status status;\n\n\t  if (fd && sparse_option && ST_IS_SPARSE (st->stat))\n\t    {\n\t      status = sparse_dump_file (fd, st);\n\t      if (status == dump_status_not_implemented)\n\t\tstatus = dump_regular_file (fd, st);\n\t    }\n\t  else\n\t    status = dump_regular_file (fd, st);\n\n\t  switch (status)\n\t    {\n\t    case dump_status_ok:\n\t    case dump_status_short:\n\t      file_count_links (st);\n\t      break;\n\n\t    case dump_status_fail:\n\t      break;\n\n\t    case dump_status_not_implemented:\n\t      abort ();\n\t    }\n\n\t  ok = status == dump_status_ok;\n\t}\n\n      if (ok)\n\t{\n\t  if (fd < 0)\n\t    {\n\t      errno = - fd;\n\t      ok = false;\n\t    }\n\t  else if (fd == 0)\n\t    {\n\t      if (parentfd < 0 && ! top_level)\n\t\t{\n\t\t  errno = - parentfd;\n\t\t  ok = false;\n\t\t}\n\t      else\n\t\tok = fstatat (parentfd, name, &final_stat, fstatat_flags) == 0;\n\t    }\n\t  else\n\t    ok = fstat (fd, &final_stat) == 0;\n\n\t  if (! ok)\n\t    file_removed_diag (p, top_level, stat_diag);\n\t}\n\n      if (ok)\n\t{\n\t  if ((timespec_cmp (get_stat_ctime (&final_stat), original_ctime) != 0\n\t       /* Original ctime will change if the file is a directory and\n\t\t  --remove-files is given */\n\t       && !(remove_files_option && is_dir))\n\t      || original_size < final_stat.st_size)\n\t    {\n\t      WARNOPT (WARN_FILE_CHANGED,\n\t\t       (0, 0, _(\"%s: file changed as we read it\"),\n\t\t\tquotearg_colon (p)));\n\t      set_exit_status (TAREXIT_DIFFERS);\n\t    }\n\t  else if (atime_preserve_option == replace_atime_preserve\n\t\t   && fd && (is_dir || original_size != 0)\n\t\t   && set_file_atime (fd, parentfd, name, st->atime) != 0)\n\t    utime_error (p);\n\t}\n\n      ok &= tar_stat_close (st);\n      if (ok && remove_files_option)\n\tqueue_deferred_unlink (p, is_dir);\n\n      return;\n    }\n#ifdef HAVE_READLINK\n  else if (S_ISLNK (st->stat.st_mode))\n    {\n      st->link_name = areadlinkat_with_size (parentfd, name, st->stat.st_size);\n      if (!st->link_name)\n\t{\n\t  if (errno == ENOMEM)\n\t    xalloc_die ();\n\t  file_removed_diag (p, top_level, readlink_diag);\n\t  return;\n\t}\n      transform_name (&st->link_name, XFORM_SYMLINK);\n      if (NAME_FIELD_SIZE - (archive_format == OLDGNU_FORMAT)\n\t  < strlen (st->link_name))\n\twrite_long_link (st);\n\n      xattrs_selinux_get (parentfd, name, st, 0);\n      xattrs_xattrs_get (parentfd, name, st, 0);\n\n      block_ordinal = current_block_ordinal ();\n      st->stat.st_size = 0;\t/* force 0 size on symlink */\n      header = start_header (st);\n      if (!header)\n\treturn;\n      tar_copy_str (header->header.linkname, st->link_name, NAME_FIELD_SIZE);\n      header->header.typeflag = SYMTYPE;\n      finish_header (st, header, block_ordinal);\n      /* nothing more to do to it */\n\n      if (remove_files_option)\n\tqueue_deferred_unlink (p, false);\n\n      file_count_links (st);\n      return;\n    }\n#endif\n  else if (S_ISCHR (st->stat.st_mode))\n    {\n      type = CHRTYPE;\n      xattrs_acls_get (parentfd, name, st, 0, true);\n      xattrs_selinux_get (parentfd, name, st, 0);\n      xattrs_xattrs_get (parentfd, name, st, 0);\n    }\n  else if (S_ISBLK (st->stat.st_mode))\n    {\n      type = BLKTYPE;\n      xattrs_acls_get (parentfd, name, st, 0, true);\n      xattrs_selinux_get (parentfd, name, st, 0);\n      xattrs_xattrs_get (parentfd, name, st, 0);\n    }\n  else if (S_ISFIFO (st->stat.st_mode))\n    {\n      type = FIFOTYPE;\n      xattrs_acls_get (parentfd, name, st, 0, true);\n      xattrs_selinux_get (parentfd, name, st, 0);\n      xattrs_xattrs_get (parentfd, name, st, 0);\n    }\n  else if (S_ISSOCK (st->stat.st_mode))\n    {\n      WARNOPT (WARN_FILE_IGNORED,\n\t       (0, 0, _(\"%s: socket ignored\"), quotearg_colon (p)));\n      return;\n    }\n  else if (S_ISDOOR (st->stat.st_mode))\n    {\n      WARNOPT (WARN_FILE_IGNORED,\n\t       (0, 0, _(\"%s: door ignored\"), quotearg_colon (p)));\n      return;\n    }\n  else\n    {\n      unknown_file_error (p);\n      return;\n    }",
      "lines": 279,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_file": {
      "start_point": [
        1967,
        0
      ],
      "end_point": [
        1978,
        1
      ],
      "content": "void\ndump_file (struct tar_stat_info *parent, char const *name,\n\t   char const *fullname)\n{\n  struct tar_stat_info st;\n  tar_stat_init (&st);\n  st.parent = parent;\n  dump_file0 (&st, name, fullname);\n  if (parent && listed_incremental_option)\n    update_parent_directory (parent);\n  tar_stat_destroy (&st);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/delete.c": {
    "move_archive": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static void\nmove_archive (off_t count)\n{\n  if (count == 0)\n    return;\n\n#ifdef MTIOCTOP\n  {\n    struct mtop operation;\n\n    if (count < 0\n\t? (operation.mt_op = MTBSR,\n\t   operation.mt_count = -count,\n\t   operation.mt_count == -count)\n\t: (operation.mt_op = MTFSR,\n\t   operation.mt_count = count,\n\t   operation.mt_count == count))\n      {\n\tif (0 <= rmtioctl (archive, MTIOCTOP, (char *) &operation))\n\t  return;\n\n\tif (errno == EIO\n\t    && 0 <= rmtioctl (archive, MTIOCTOP, (char *) &operation))\n\t  return;\n      }\n  }\n#endif /* MTIOCTOP */\n\n  {\n    off_t position0 = rmtlseek (archive, (off_t) 0, SEEK_CUR);\n    off_t increment = record_size * (off_t) count;\n    off_t position = position0 + increment;\n\n    if (increment / count != record_size\n\t|| (position < position0) != (increment < 0)\n\t|| (position = position < 0 ? 0 : position,\n\t    rmtlseek (archive, position, SEEK_SET) != position))\n      seek_error_details (archive_name_array[0], position);\n\n    return;\n  }\n}",
      "lines": 42,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_record": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static void\nwrite_record (int move_back_flag)\n{\n  union block *save_record = record_start;\n  record_start = new_record;\n\n  if (acting_as_filter)\n    {\n      archive = STDOUT_FILENO;\n      flush_write ();\n      archive = STDIN_FILENO;\n    }\n  else\n    {\n      move_archive ((records_written + records_skipped) - records_read);\n      flush_write ();\n    }\n\n  record_start = save_record;\n\n  if (move_back_flag)\n    {\n      /* Move the tape head back to where we were.  */\n\n      if (! acting_as_filter)\n\tmove_archive (records_read - (records_written + records_skipped));\n    }\n\n  new_blocks = 0;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_recent_blocks": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static void\nwrite_recent_blocks (union block *h, size_t blocks)\n{\n  size_t i;\n  for (i = 0; i < blocks; i++)\n    {\n      new_record[new_blocks++] = h[i];\n      if (new_blocks == blocking_factor)\n\twrite_record (1);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_recent_bytes": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static void\nwrite_recent_bytes (char *data, size_t bytes)\n{\n  size_t blocks = bytes / BLOCKSIZE;\n  size_t rest = bytes - blocks * BLOCKSIZE;\n\n  write_recent_blocks ((union block *)data, blocks);\n  memcpy (new_record[new_blocks].buffer, data + blocks * BLOCKSIZE, rest);\n  if (rest < BLOCKSIZE)\n    memset (new_record[new_blocks].buffer + rest, 0, BLOCKSIZE - rest);\n  new_blocks++;\n  if (new_blocks == blocking_factor)\n    write_record (1);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delete_archive_members": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "void\ndelete_archive_members (void)\n{\n  enum read_header logical_status = HEADER_STILL_UNREAD;\n  enum read_header previous_status = HEADER_STILL_UNREAD;\n\n  /* FIXME: Should clean the routine before cleaning these variables :-( */\n  struct name *name;\n  off_t blocks_to_skip = 0;\n  off_t blocks_to_keep = 0;\n  int kept_blocks_in_record;\n\n  name_gather ();\n  open_archive (ACCESS_UPDATE);\n  acting_as_filter = strcmp (archive_name_array[0], \"-\") == 0;\n\n  do\n    {\n      enum read_header status = read_header (&current_header,\n                                             &current_stat_info,\n                                             read_header_x_raw);\n\n      switch (status)\n\t{\n\tcase HEADER_STILL_UNREAD:\n\t  abort ();\n\n\tcase HEADER_SUCCESS:\n\t  if ((name = name_scan (current_stat_info.file_name)) == NULL)\n\t    {\n\t      skip_member ();\n\t      break;\n\t    }\n\t  name->found_count++;\n\t  if (!ISFOUND(name))\n\t    {\n\t      skip_member ();\n\t      break;\n\t    }\n\t  FALLTHROUGH;\n\tcase HEADER_SUCCESS_EXTENDED:\n\t  logical_status = status;\n\t  break;\n\n\tcase HEADER_ZERO_BLOCK:\n\t  if (ignore_zeros_option)\n\t    {\n\t      set_next_block_after (current_header);\n\t      break;\n\t    }\n\t  FALLTHROUGH;\n\tcase HEADER_END_OF_FILE:\n\t  logical_status = HEADER_END_OF_FILE;\n\t  break;\n\n\tcase HEADER_FAILURE:\n\t  set_next_block_after (current_header);\n\t  switch (previous_status)\n\t    {\n\t    case HEADER_STILL_UNREAD:\n\t      WARN ((0, 0, _(\"This does not look like a tar archive\")));\n\t      FALLTHROUGH;\n\t    case HEADER_SUCCESS:\n\t    case HEADER_SUCCESS_EXTENDED:\n\t    case HEADER_ZERO_BLOCK:\n\t      ERROR ((0, 0, _(\"Skipping to next header\")));\n\t      FALLTHROUGH;\n\t    case HEADER_FAILURE:\n\t      break;\n\n\t    case HEADER_END_OF_FILE:\n\t      abort ();\n\t    }\n\t  break;\n\t}\n\n      previous_status = status;\n    }\n  while (logical_status == HEADER_STILL_UNREAD);\n\n  records_skipped = records_read - 1;\n  new_record = xmalloc (record_size);\n\n  if (logical_status == HEADER_SUCCESS\n      || logical_status == HEADER_SUCCESS_EXTENDED)\n    {\n      write_archive_to_stdout = false;\n\n      /* Save away blocks before this one in this record.  */\n\n      new_blocks = current_block - record_start;\n      if (new_blocks)\n\tmemcpy (new_record, record_start, new_blocks * BLOCKSIZE);\n\n      if (logical_status == HEADER_SUCCESS)\n\t{\n\t  /* FIXME: Pheew!  This is crufty code!  */\n\t  logical_status = HEADER_STILL_UNREAD;\n\t  goto flush_file;\n\t}\n\n      /* FIXME: Solaris 2.4 Sun cc (the ANSI one, not the old K&R) says:\n\t \"delete.c\", line 223: warning: loop not entered at top\n\t Reported by Bruno Haible.  */\n      while (1)\n\t{\n\t  enum read_header status;\n\n\t  /* Fill in a record.  */\n\n\t  if (current_block == record_end)\n\t    flush_archive ();\n\t  status = read_header (&current_header, &current_stat_info,\n\t                        read_header_auto);\n\n\t  xheader_decode (&current_stat_info);\n\n\t  if (status == HEADER_ZERO_BLOCK && ignore_zeros_option)\n\t    {\n\t      set_next_block_after (current_header);\n\t      continue;\n\t    }\n\t  if (status == HEADER_END_OF_FILE || status == HEADER_ZERO_BLOCK)\n\t    {\n\t      logical_status = HEADER_END_OF_FILE;\n\t      break;\n\t    }\n\n\t  if (status == HEADER_FAILURE)\n\t    {\n\t      ERROR ((0, 0, _(\"Deleting non-header from archive\")));\n\t      set_next_block_after (current_header);\n\t      continue;\n\t    }\n\n\t  /* Found another header.  */\n\n\t  if ((name = name_scan (current_stat_info.file_name)) != NULL)\n\t    {\n\t      name->found_count++;\n\t      if (ISFOUND(name))\n\t\t{\n\t\tflush_file:\n\t\t  set_next_block_after (current_header);\n\t\t  blocks_to_skip = (current_stat_info.stat.st_size\n\t\t\t\t    + BLOCKSIZE - 1) / BLOCKSIZE;\n\n\t\t  while (record_end - current_block <= blocks_to_skip)\n\t\t    {\n\t\t      blocks_to_skip -= (record_end - current_block);\n\t\t      flush_archive ();\n\t\t    }\n\t\t  current_block += blocks_to_skip;\n\t\t  blocks_to_skip = 0;\n\t\t  continue;\n\t\t}\n\t    }\n\t  /* Copy header.  */\n\n\t  if (current_stat_info.xhdr.size)\n\t    {\n\t      write_recent_bytes (current_stat_info.xhdr.buffer,\n\t\t\t\t  current_stat_info.xhdr.size);\n\t    }\n\t  else\n\t    {\n\t      write_recent_blocks (recent_long_name, recent_long_name_blocks);\n\t      write_recent_blocks (recent_long_link, recent_long_link_blocks);\n\t    }\n\t  new_record[new_blocks] = *current_header;\n\t  new_blocks++;\n\t  blocks_to_keep\n\t    = (current_stat_info.stat.st_size + BLOCKSIZE - 1) / BLOCKSIZE;\n\t  set_next_block_after (current_header);\n\t  if (new_blocks == blocking_factor)\n\t    write_record (1);\n\n\t  /* Copy data.  */\n\n\t  kept_blocks_in_record = record_end - current_block;\n\t  if (kept_blocks_in_record > blocks_to_keep)\n\t    kept_blocks_in_record = blocks_to_keep;\n\n\t  while (blocks_to_keep)\n\t    {\n\t      int count;\n\n\t      if (current_block == record_end)\n\t\t{\n\t\t  flush_read ();\n\t\t  current_block = record_start;\n\t\t  kept_blocks_in_record = blocking_factor;\n\t\t  if (kept_blocks_in_record > blocks_to_keep)\n\t\t    kept_blocks_in_record = blocks_to_keep;\n\t\t}\n\t      count = kept_blocks_in_record;\n\t      if (blocking_factor - new_blocks < count)\n\t\tcount = blocking_factor - new_blocks;\n\n\t      if (! count)\n\t\tabort ();\n\n\t      memcpy (new_record + new_blocks, current_block, count * BLOCKSIZE);\n\t      new_blocks += count;\n\t      current_block += count;\n\t      blocks_to_keep -= count;\n\t      kept_blocks_in_record -= count;\n\n\t      if (new_blocks == blocking_factor)\n\t\twrite_record (1);\n\t    }\n\t}\n\n      if (logical_status == HEADER_END_OF_FILE)\n\t{\n\t  /* Write the end of tape.  FIXME: we can't use write_eot here,\n\t     as it gets confused when the input is at end of file.  */\n\n\t  int total_zero_blocks = 0;\n\n\t  do\n\t    {\n\t      int zero_blocks = blocking_factor - new_blocks;\n\t      memset (new_record + new_blocks, 0, BLOCKSIZE * zero_blocks);\n\t      total_zero_blocks += zero_blocks;\n\t      write_record (total_zero_blocks < 2);\n\t    }\n\t  while (total_zero_blocks < 2);\n\t}\n\n      if (! acting_as_filter && ! _isrmt (archive))\n\t{\n\t  if (sys_truncate (archive))\n\t    truncate_warn (archive_name_array[0]);\n\t}\n    }\n  free (new_record);\n\n  close_archive ();\n  names_notfound ();\n}",
      "lines": 241,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/exclist.c": {
    "excfile_add": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nexcfile_add (const char *name, int flags)\n{\n  struct excfile *p = xmalloc (sizeof (*p) + strlen (name));\n  p->next = NULL;\n  p->flags = flags;\n  strcpy (p->name, name);\n  if (excfile_tail)\n    excfile_tail->next = p;\n  else\n    excfile_head = p;\n  excfile_tail = p;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "info_attach_exclist": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\ninfo_attach_exclist (struct tar_stat_info *dir)\n{\n  struct excfile *file;\n  struct exclist *head = NULL, *tail = NULL, *ent;\n  struct vcs_ignore_file *vcsfile;\n\n  if (dir->exclude_list)\n    return;\n  for (file = excfile_head; file; file = file->next)\n    {\n      if (faccessat (dir ? dir->fd : chdir_fd, file->name, F_OK, 0) == 0)\n\t{\n\t  FILE *fp;\n\t  struct exclude *ex = NULL;\n\t  int fd = subfile_open (dir, file->name, O_RDONLY);\n\t  if (fd == -1)\n\t    {\n\t      open_error (file->name);\n\t      continue;\n\t    }\n\t  fp = fdopen (fd, \"r\");\n\t  if (!fp)\n\t    {\n\t      ERROR ((0, errno, _(\"%s: fdopen failed\"), file->name));\n\t      close (fd);\n\t      continue;\n\t    }\n\n\t  if (!ex)\n\t    ex = new_exclude ();\n\n\t  vcsfile = get_vcs_ignore_file (file->name);\n\n\t  if (vcsfile->initfn)\n\t    vcsfile->data = vcsfile->initfn (vcsfile->data);\n\n\t  if (add_exclude_fp (vcsfile->addfn, ex, fp,\n\t\t\t      EXCLUDE_WILDCARDS|EXCLUDE_ANCHORED, '\\n',\n\t\t\t      vcsfile->data))\n\t    {\n\t      int e = errno;\n\t      FATAL_ERROR ((0, e, \"%s\", quotearg_colon (file->name)));\n\t    }\n\t  fclose (fp);\n\n\t  ent = xmalloc (sizeof (*ent));\n\t  ent->excluded = ex;\n\t  ent->flags = file->flags == EXCL_DEFAULT\n\t               ? file->flags : vcsfile->flags;\n\t  ent->prev = tail;\n\t  ent->next = NULL;\n\n\t  if (tail)\n\t    tail->next = ent;\n\t  else\n\t    head = ent;\n\t  tail = ent;\n\t}\n    }\n  dir->exclude_list = head;\n}",
      "lines": 62,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "info_free_exclist": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\ninfo_free_exclist (struct tar_stat_info *dir)\n{\n  struct exclist *ep = dir->exclude_list;\n\n  while (ep)\n    {\n      struct exclist *next = ep->next;\n      free_exclude (ep->excluded);\n      free (ep);\n      ep = next;\n    }\n\n  dir->exclude_list = NULL;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "excluded_name": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "bool\nexcluded_name (char const *name, struct tar_stat_info *st)\n{\n  struct exclist *ep;\n  const char *rname = NULL;\n  char *bname = NULL;\n  bool result;\n  int nr = 0;\n\n  name += FILE_SYSTEM_PREFIX_LEN (name);\n\n  /* Try global exclusion list first */\n  if (excluded_file_name (excluded, name))\n    return true;\n\n  if (!st)\n    return false;\n\n  for (result = false; st && !result; st = st->parent, nr = EXCL_NON_RECURSIVE)\n    {\n      for (ep = st->exclude_list; ep; ep = ep->next)\n\t{\n\t  if (ep->flags & nr)\n\t    continue;\n\t  if ((result = excluded_file_name (ep->excluded, name)))\n\t    break;\n\n\t  if (!rname)\n\t    {\n\t      rname = name;\n\t      /* Skip leading ./ */\n\t      while (*rname == '.' && ISSLASH (rname[1]))\n\t\trname += 2;\n\t    }\n\t  if ((result = excluded_file_name (ep->excluded, rname)))\n\t    break;\n\n\t  if (!bname)\n\t    bname = base_name (name);\n\t  if ((result = excluded_file_name (ep->excluded, bname)))\n\t    break;\n\t}\n    }\n\n  free (bname);\n\n  return result;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "cvs_addfn": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static void\ncvs_addfn (struct exclude *ex, char const *pattern, int options, void *data)\n{\n  struct wordsplit ws;\n  size_t i;\n\n  if (wordsplit (pattern, &ws,\n\t\t WRDSF_NOVAR | WRDSF_NOCMD | WRDSF_SQUEEZE_DELIMS))\n    return;\n  for (i = 0; i < ws.ws_wordc; i++)\n    add_exclude (ex, ws.ws_wordv[i], options);\n  wordsplit_free (&ws);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "git_addfn": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "static void\ngit_addfn (struct exclude *ex, char const *pattern, int options, void *data)\n{\n  while (isspace (*pattern))\n    ++pattern;\n  if (*pattern == 0 || *pattern == '#')\n    return;\n  if (*pattern == '\\\\' && pattern[1] == '#')\n    ++pattern;\n  add_exclude (ex, pattern, options);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bzr_addfn": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "static void\nbzr_addfn (struct exclude *ex, char const *pattern, int options, void *data)\n{\n  while (isspace (*pattern))\n    ++pattern;\n  if (*pattern == 0 || *pattern == '#')\n    return;\n  if (*pattern == '!')\n    {\n      if (*++pattern == '!')\n\t++pattern;\n      else\n\toptions |= EXCLUDE_INCLUDE;\n    }\n  /* FIXME: According to the docs, globbing patterns are rsync-style,\n            and regexps are perl-style. */\n  if (strncmp (pattern, \"RE:\", 3) == 0)\n    {\n      pattern += 3;\n      options &= ~EXCLUDE_WILDCARDS;\n      options |= EXCLUDE_REGEX;\n    }\n  add_exclude (ex, pattern, options);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hg_initfn": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "static void *\nhg_initfn (void *data)\n{\n  static int hg_options;\n  int *hgopt = data ? data : &hg_options;\n  *hgopt = EXCLUDE_REGEX;\n  return hgopt;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nhg_initfn (void *data)",
        "*"
      ]
    },
    "hg_addfn": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "static void\nhg_addfn (struct exclude *ex, char const *pattern, int options, void *data)\n{\n  int *hgopt = data;\n  size_t len;\n\n  while (isspace (*pattern))\n    ++pattern;\n  if (*pattern == 0 || *pattern == '#')\n    return;\n  if (strncmp (pattern, \"syntax:\", 7) == 0)\n    {\n      for (pattern += 7; isspace (*pattern); ++pattern)\n\t;\n      if (strcmp (pattern, \"regexp\") == 0)\n\t/* FIXME: Regexps must be perl-style */\n\t*hgopt = EXCLUDE_REGEX;\n      else if (strcmp (pattern, \"glob\") == 0)\n\t*hgopt = EXCLUDE_WILDCARDS;\n      /* Ignore unknown syntax */\n      return;\n    }\n\n  len = strlen(pattern);\n  if (pattern[len-1] == '/')\n    {\n      char *p;\n\n      --len;\n      p = xmalloc (len+1);\n      memcpy (p, pattern, len);\n      p[len] = 0;\n      pattern = p;\n      exclude_add_pattern_buffer (ex, p);\n      options |= FNM_LEADING_DIR|EXCLUDE_ALLOC;\n    }\n\n  add_exclude (ex, pattern,\n\t       ((*hgopt == EXCLUDE_REGEX)\n\t\t? (options & ~EXCLUDE_WILDCARDS)\n\t\t: (options & ~EXCLUDE_REGEX)) | *hgopt);\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_vcs_ignore_file": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "static struct vcs_ignore_file *\nget_vcs_ignore_file (const char *name)\n{\n  struct vcs_ignore_file *p;\n\n  for (p = vcs_ignore_files; p->filename; p++)\n    if (strcmp (p->filename, name) == 0)\n      break;\n\n  return p;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct vcs_ignore_file",
        "struct",
        "vcs_ignore_file",
        "*\nget_vcs_ignore_file (const char *name)",
        "*"
      ]
    },
    "exclude_vcs_ignores": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "void\nexclude_vcs_ignores (void)\n{\n  struct vcs_ignore_file *p;\n\n  for (p = vcs_ignore_files; p->filename; p++)\n    excfile_add (p->filename, EXCL_DEFAULT);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/exit.c": {
    "fatal_exit": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "void\nfatal_exit (void)\n{\n  if (fatal_exit_hook)\n    fatal_exit_hook ();\n  error (TAREXIT_FAILURE, 0, _(\"Error is not recoverable: exiting now\"));\n  abort ();\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "xalloc_die": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (0, 0, \"%s\", _(\"memory exhausted\"));\n  fatal_exit ();\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/extract.c": {
    "implemented": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static bool\nimplemented (int err)\n{\n  return ! (err == ENOSYS\n\t    || err == ENOTSUP\n\t    || (EOPNOTSUPP != ENOTSUP && err == EOPNOTSUPP));\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "extr_init": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void\nextr_init (void)\n{\n  we_are_root = geteuid () == ROOT_UID;\n  same_permissions_option += we_are_root;\n  same_owner_option += we_are_root;\n\n  /* Option -p clears the kernel umask, so it does not affect proper\n     restoration of file permissions.  New intermediate directories will\n     comply with umask at start of program.  */\n\n  newdir_umask = umask (0);\n  if (0 < same_permissions_option)\n    current_umask = 0;\n  else\n    {\n      umask (newdir_umask);\t/* restore the kernel umask */\n      current_umask = newdir_umask;\n    }\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fd_chmod": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static int\nfd_chmod (int fd, char const *file, mode_t mode, int atflag)\n{\n  if (0 <= fd)\n    {\n      int result = fchmod (fd, mode);\n      if (result == 0 || implemented (errno))\n\treturn result;\n    }\n  return fchmodat (chdir_fd, file, mode, atflag);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fd_chown": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static int\nfd_chown (int fd, char const *file, uid_t uid, gid_t gid, int atflag)\n{\n  if (0 <= fd)\n    {\n      int result = fchown (fd, uid, gid);\n      if (result == 0 || implemented (errno))\n\treturn result;\n    }\n  return fchownat (chdir_fd, file, uid, gid, atflag);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fd_stat": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "static int\nfd_stat (int fd, char const *file, struct stat *st, int atflag)\n{\n  return (0 <= fd\n\t  ? fstat (fd, st)\n\t  : fstatat (chdir_fd, file, st, atflag));\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_mode": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "static void\nset_mode (char const *file_name,\n\t  mode_t mode, mode_t mode_mask, int fd,\n\t  mode_t current_mode, mode_t current_mode_mask,\n\t  char typeflag, int atflag)\n{\n  if (((current_mode ^ mode) | ~ current_mode_mask) & mode_mask)\n    {\n      if (MODE_ALL & ~ mode_mask & ~ current_mode_mask)\n\t{\n\t  struct stat st;\n\t  if (fd_stat (fd, file_name, &st, atflag) != 0)\n\t    {\n\t      stat_error (file_name);\n\t      return;\n\t    }\n\t  current_mode = st.st_mode;\n\t}\n\n      current_mode &= MODE_ALL;\n      mode = (current_mode & ~ mode_mask) | (mode & mode_mask);\n\n      if (current_mode != mode)\n\t{\n\t  int chmod_errno =\n\t    fd_chmod (fd, file_name, mode, atflag) == 0 ? 0 : errno;\n\n\t  /* On Solaris, chmod may fail if we don't have PRIV_ALL, because\n\t     setuid-root files would otherwise be a backdoor.  See\n\t     http://opensolaris.org/jive/thread.jspa?threadID=95826\n\t     (2009-09-03).  */\n\t  if (chmod_errno == EPERM && (mode & S_ISUID)\n\t      && priv_set_restore_linkdir () == 0)\n\t    {\n\t      chmod_errno =\n\t\tfd_chmod (fd, file_name, mode, atflag) == 0 ? 0 : errno;\n\t      priv_set_remove_linkdir ();\n\t    }\n\n\t  /* Linux fchmodat does not support AT_SYMLINK_NOFOLLOW, and\n\t     returns ENOTSUP even when operating on non-symlinks, try\n\t     again with the flag disabled if it does not appear to be\n\t     supported and if the file is not a symlink.  This\n\t     introduces a race, alas.  */\n\t  if (atflag && typeflag != SYMTYPE && ! implemented (chmod_errno))\n\t    chmod_errno = fd_chmod (fd, file_name, mode, 0) == 0 ? 0 : errno;\n\n\t  if (chmod_errno\n\t      && (typeflag != SYMTYPE || implemented (chmod_errno)))\n\t    {\n\t      errno = chmod_errno;\n\t      chmod_error_details (file_name, mode);\n\t    }\n\t}\n    }\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_time": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "static void\ncheck_time (char const *file_name, struct timespec t)\n{\n  if (t.tv_sec < 0)\n    WARNOPT (WARN_TIMESTAMP,\n\t     (0, 0, _(\"%s: implausibly old time stamp %s\"),\n\t      file_name, tartime (t, true)));\n  else if (timespec_cmp (volume_start_time, t) < 0)\n    {\n      struct timespec now;\n      gettime (&now);\n      if (timespec_cmp (now, t) < 0)\n\t{\n\t  char buf[TIMESPEC_STRSIZE_BOUND];\n\t  struct timespec diff;\n\t  diff.tv_sec = t.tv_sec - now.tv_sec;\n\t  diff.tv_nsec = t.tv_nsec - now.tv_nsec;\n\t  if (diff.tv_nsec < 0)\n\t    {\n\t      diff.tv_nsec += BILLION;\n\t      diff.tv_sec--;\n\t    }\n\t  WARNOPT (WARN_TIMESTAMP,\n\t\t   (0, 0, _(\"%s: time stamp %s is %s s in the future\"),\n\t\t    file_name, tartime (t, true), code_timespec (diff, buf)));\n\t}\n    }\n}",
      "lines": 28,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_stat": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "static void\nset_stat (char const *file_name,\n\t  struct tar_stat_info const *st,\n\t  int fd, mode_t current_mode, mode_t current_mode_mask,\n\t  char typeflag, bool interdir, int atflag)\n{\n  /* Do the utime before the chmod because some versions of utime are\n     broken and trash the modes of the file.  */\n\n  if (! touch_option && ! interdir)\n    {\n      struct timespec ts[2];\n      if (incremental_option)\n\tts[0] = st->atime;\n      else\n\tts[0].tv_nsec = UTIME_OMIT;\n      ts[1] = st->mtime;\n\n      if (fdutimensat (fd, chdir_fd, file_name, ts, atflag) == 0)\n\t{\n\t  if (incremental_option)\n\t    check_time (file_name, ts[0]);\n\t  check_time (file_name, ts[1]);\n\t}\n      else if (typeflag != SYMTYPE || implemented (errno))\n\tutime_error (file_name);\n    }\n\n  if (0 < same_owner_option && ! interdir)\n    {\n      /* Some systems allow non-root users to give files away.  Once this\n\t done, it is not possible anymore to change file permissions.\n\t However, setting file permissions now would be incorrect, since\n\t they would apply to the wrong user, and there would be a race\n\t condition.  So, don't use systems that allow non-root users to\n\t give files away.  */\n      uid_t uid = st->stat.st_uid;\n      gid_t gid = st->stat.st_gid;\n\n      if (fd_chown (fd, file_name, uid, gid, atflag) == 0)\n\t{\n\t  /* Changing the owner can clear st_mode bits in some cases.  */\n\t  if ((current_mode | ~ current_mode_mask) & S_IXUGO)\n\t    current_mode_mask &= ~ (current_mode & (S_ISUID | S_ISGID));\n\t}\n      else if (typeflag != SYMTYPE || implemented (errno))\n\tchown_error_details (file_name, uid, gid);\n    }\n\n  set_mode (file_name,\n\t    st->stat.st_mode & ~ current_umask,\n\t    0 < same_permissions_option && ! interdir ? MODE_ALL : MODE_RWX,\n\t    fd, current_mode, current_mode_mask, typeflag, atflag);\n\n  /* these three calls must be done *after* fd_chown() call because fd_chown\n     causes that linux capabilities becomes cleared. */\n  xattrs_xattrs_set (st, file_name, typeflag, 1);\n  xattrs_acls_set (st, file_name, typeflag);\n  xattrs_selinux_set (st, file_name, typeflag);\n}",
      "lines": 60,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_direct_ancestor": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "static struct delayed_set_stat *\nfind_direct_ancestor (char const *file_name)\n{\n  struct delayed_set_stat *h = delayed_set_stat_head;\n  while (h)\n    {\n      if (h && ! h->after_links\n\t  && strncmp (file_name, h->file_name, h->file_name_len) == 0\n\t  && ISSLASH (file_name[h->file_name_len])\n\t  && (last_component (file_name) == file_name + h->file_name_len + 1))\n\tbreak;\n      h = h->next;\n    }\n  return h;\n}",
      "lines": 15,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "struct delayed_set_stat",
        "struct",
        "delayed_set_stat",
        "*\nfind_direct_ancestor (char const *file_name)",
        "*"
      ]
    },
    "mark_after_links": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "static void\nmark_after_links (struct delayed_set_stat *head)\n{\n  struct delayed_set_stat *h = head;\n\n  do\n    {\n      struct stat st;\n      h->after_links = 1;\n\n      if (deref_stat (h->file_name, &st) != 0)\n\tstat_error (h->file_name);\n      else\n\t{\n\t  h->dev = st.st_dev;\n\t  h->ino = st.st_ino;\n\t}\n    }\n  while ((h = h->next) && ! h->after_links);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delay_set_stat": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "static void\ndelay_set_stat (char const *file_name, struct tar_stat_info const *st,\n\t\tmode_t current_mode, mode_t current_mode_mask,\n\t\tmode_t mode, int atflag)\n{\n  size_t file_name_len = strlen (file_name);\n  struct delayed_set_stat *data = xmalloc (sizeof (*data));\n  data->next = delayed_set_stat_head;\n  data->mode = mode;\n  if (st)\n    {\n      data->dev = st->stat.st_dev;\n      data->ino = st->stat.st_ino;\n      data->uid = st->stat.st_uid;\n      data->gid = st->stat.st_gid;\n      data->atime = st->atime;\n      data->mtime = st->mtime;\n    }\n  data->file_name_len = file_name_len;\n  data->file_name = xstrdup (file_name);\n  data->current_mode = current_mode;\n  data->current_mode_mask = current_mode_mask;\n  data->interdir = ! st;\n  data->atflag = atflag;\n  data->after_links = 0;\n  data->change_dir = chdir_current;\n  data->cntx_name = NULL;\n  if (st)\n    assign_string (&data->cntx_name, st->cntx_name);\n  if (st && st->acls_a_ptr)\n    {\n      data->acls_a_ptr = xmemdup (st->acls_a_ptr, st->acls_a_len + 1);\n      data->acls_a_len = st->acls_a_len;\n    }\n  else\n    {\n      data->acls_a_ptr = NULL;\n      data->acls_a_len = 0;\n    }\n  if (st && st->acls_d_ptr)\n    {\n      data->acls_d_ptr = xmemdup (st->acls_d_ptr, st->acls_d_len + 1);\n      data->acls_d_len = st->acls_d_len;\n    }\n  else\n    {\n      data->acls_d_ptr = NULL;\n      data->acls_d_len = 0;\n    }\n  if (st)\n    xheader_xattr_copy (st, &data->xattr_map, &data->xattr_map_size);\n  else\n    {\n      data->xattr_map = NULL;\n      data->xattr_map_size = 0;\n    }\n  strcpy (data->file_name, file_name);\n  delayed_set_stat_head = data;\n  if (must_be_dot_or_slash (file_name))\n    mark_after_links (data);\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "repair_delayed_set_stat": {
      "start_point": [
        521,
        0
      ],
      "end_point": [
        554,
        1
      ],
      "content": "static void\nrepair_delayed_set_stat (char const *dir,\n\t\t\t struct stat const *dir_stat_info)\n{\n  struct delayed_set_stat *data;\n  for (data = delayed_set_stat_head;  data;  data = data->next)\n    {\n      struct stat st;\n      if (fstatat (chdir_fd, data->file_name, &st, data->atflag) != 0)\n\t{\n\t  stat_error (data->file_name);\n\t  return;\n\t}\n\n      if (st.st_dev == dir_stat_info->st_dev\n\t  && st.st_ino == dir_stat_info->st_ino)\n\t{\n\t  data->dev = current_stat_info.stat.st_dev;\n\t  data->ino = current_stat_info.stat.st_ino;\n\t  data->mode = current_stat_info.stat.st_mode;\n\t  data->uid = current_stat_info.stat.st_uid;\n\t  data->gid = current_stat_info.stat.st_gid;\n\t  data->atime = current_stat_info.atime;\n\t  data->mtime = current_stat_info.mtime;\n\t  data->current_mode = st.st_mode;\n\t  data->current_mode_mask = ALL_MODE_BITS;\n\t  data->interdir = false;\n\t  return;\n\t}\n    }\n\n  ERROR ((0, 0, _(\"%s: Unexpected inconsistency when making directory\"),\n\t  quotearg_colon (dir)));\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_delayed_set_stat": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        565,
        1
      ],
      "content": "static void\nfree_delayed_set_stat (struct delayed_set_stat *data)\n{\n  free (data->file_name);\n  xheader_xattr_free (data->xattr_map, data->xattr_map_size);\n  free (data->cntx_name);\n  free (data->acls_a_ptr);\n  free (data->acls_d_ptr);\n  free (data);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "remove_delayed_set_stat": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        587,
        1
      ],
      "content": "void\nremove_delayed_set_stat (const char *fname)\n{\n  struct delayed_set_stat *data, *next, *prev = NULL;\n  for (data = delayed_set_stat_head; data; data = next)\n    {\n      next = data->next;\n      if (chdir_current == data->change_dir\n\t  && strcmp (data->file_name, fname) == 0)\n\t{\n\t  free_delayed_set_stat (data);\n\t  if (prev)\n\t    prev->next = next;\n\t  else\n\t    delayed_set_stat_head = next;\n\t  return;\n\t}\n      else\n\tprev = data;\n    }\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "fixup_delayed_set_stat": {
      "start_point": [
        589,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "static void\nfixup_delayed_set_stat (char const *src, char const *dst)\n{\n  struct delayed_set_stat *data;\n  for (data = delayed_set_stat_head; data; data = data->next)\n    {\n      if (chdir_current == data->change_dir\n\t  && strcmp (data->file_name, src) == 0)\n\t{\n\t  free (data->file_name);\n\t  data->file_name = xstrdup (dst);\n\t  data->file_name_len = strlen (dst);\n\t  return;\n\t}\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "make_directories": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        680,
        1
      ],
      "content": "static int\nmake_directories (char *file_name, bool *interdir_made)\n{\n  char *cursor0 = file_name + FILE_SYSTEM_PREFIX_LEN (file_name);\n  char *cursor;\t        \t/* points into the file name */\n\n  for (cursor = cursor0; *cursor; cursor++)\n    {\n      mode_t mode;\n      mode_t desired_mode;\n      int status;\n\n      if (! ISSLASH (*cursor))\n\tcontinue;\n\n      /* Avoid mkdir of empty string, if leading or double '/'.  */\n\n      if (cursor == cursor0 || ISSLASH (cursor[-1]))\n\tcontinue;\n\n      /* Avoid mkdir where last part of file name is \".\" or \"..\".  */\n\n      if (cursor[-1] == '.'\n\t  && (cursor == cursor0 + 1 || ISSLASH (cursor[-2])\n\t      || (cursor[-2] == '.'\n\t\t  && (cursor == cursor0 + 2 || ISSLASH (cursor[-3])))))\n\tcontinue;\n\n      *cursor = '\\0';\t\t/* truncate the name there */\n      desired_mode = MODE_RWX & ~ newdir_umask;\n      mode = desired_mode | (we_are_root ? 0 : MODE_WXUSR);\n      status = mkdirat (chdir_fd, file_name, mode);\n\n      if (status == 0)\n\t{\n\t  /* Create a struct delayed_set_stat even if\n\t     mode == desired_mode, because\n\t     repair_delayed_set_stat may need to update the struct.  */\n\t  delay_set_stat (file_name,\n\t\t\t  0, mode & ~ current_umask, MODE_RWX,\n\t\t\t  desired_mode, AT_SYMLINK_NOFOLLOW);\n\n\t  print_for_mkdir (file_name, cursor - file_name, desired_mode);\n\t  *interdir_made = true;\n\t}\n      else if (errno == EEXIST)\n\tstatus = 0;\n      else\n\t{\n\t  /* Check whether the desired file exists.  Even when the\n\t     file exists, mkdir can fail with some errno value E other\n\t     than EEXIST, so long as E describes an error condition\n\t     that also applies.  */\n\t  int e = errno;\n\t  struct stat st;\n\t  status = fstatat (chdir_fd, file_name, &st, 0);\n\t  if (status)\n\t    {\n\t      errno = e;\n\t      mkdir_error (file_name);\n\t    }\n\t}\n\n      *cursor = '/';\n      if (status)\n\treturn status;\n    }\n\n  return 0;\n}",
      "lines": 70,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "file_newer_p": {
      "start_point": [
        685,
        0
      ],
      "end_point": [
        708,
        1
      ],
      "content": "static bool\nfile_newer_p (const char *file_name, struct stat const *stp,\n\t      struct tar_stat_info *tar_stat)\n{\n  struct stat st;\n\n  if (!stp)\n    {\n      if (deref_stat (file_name, &st) != 0)\n\t{\n\t  if (errno != ENOENT)\n\t    {\n\t      stat_warn (file_name);\n\t      /* Be safer: if the file exists, assume it is newer.  */\n\t      return true;\n\t    }\n\t  return false;\n\t}\n      stp = &st;\n    }\n\n  return (! S_ISDIR (stp->st_mode)\n\t  && tar_timespec_cmp (tar_stat->mtime, get_stat_mtime (stp)) <= 0);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "maybe_recoverable": {
      "start_point": [
        726,
        0
      ],
      "end_point": [
        804,
        1
      ],
      "content": "static int\nmaybe_recoverable (char *file_name, bool regular, bool *interdir_made)\n{\n  int e = errno;\n  struct stat st;\n  struct stat const *stp = 0;\n\n  if (*interdir_made)\n    return RECOVER_NO;\n\n  switch (e)\n    {\n    case ELOOP:\n\n      /* With open (\"symlink\", O_NOFOLLOW|...), POSIX says errno == ELOOP,\n\t but some operating systems do not conform to the standard.  */\n#ifdef EFTYPE\n      /* NetBSD uses errno == EFTYPE; see <http://gnats.netbsd.org/43154>.  */\n    case EFTYPE:\n#endif\n      /* FreeBSD 8.1 uses errno == EMLINK.  */\n    case EMLINK:\n      /* Tru64 5.1B uses errno == ENOTSUP.  */\n    case ENOTSUP:\n\n      if (! regular\n\t  || old_files_option != OVERWRITE_OLD_FILES || dereference_option)\n\tbreak;\n      if (strchr (file_name, '/'))\n\t{\n\t  if (deref_stat (file_name, &st) != 0)\n\t    break;\n\t  stp = &st;\n\t}\n      /* The caller tried to open a symbolic link with O_NOFOLLOW.\n\t Fall through, treating it as an already-existing file.  */\n      FALLTHROUGH;\n    case EEXIST:\n      /* Remove an old file, if the options allow this.  */\n\n      switch (old_files_option)\n\t{\n\tcase SKIP_OLD_FILES:\n\t  WARNOPT (WARN_EXISTING_FILE,\n\t\t   (0, 0, _(\"%s: skipping existing file\"), file_name));\n\t  return RECOVER_SKIP;\n\n\tcase KEEP_OLD_FILES:\n\t  return RECOVER_NO;\n\n\tcase KEEP_NEWER_FILES:\n\t  if (file_newer_p (file_name, stp, &current_stat_info))\n\t    break;\n\t  FALLTHROUGH;\n\tcase DEFAULT_OLD_FILES:\n\tcase NO_OVERWRITE_DIR_OLD_FILES:\n\tcase OVERWRITE_OLD_FILES:\n\t  if (0 < remove_any_file (file_name, ORDINARY_REMOVE_OPTION))\n\t    return RECOVER_OK;\n\t  break;\n\n\tcase UNLINK_FIRST_OLD_FILES:\n\t  break;\n\t}\n\n    case ENOENT:\n      /* Attempt creating missing intermediate directories.  */\n      if (make_directories (file_name, interdir_made) == 0 && *interdir_made)\n\treturn RECOVER_OK;\n      break;\n\n    default:\n      /* Just say we can't do anything about it...  */\n      break;\n    }\n\n  errno = e;\n  return RECOVER_NO;\n}",
      "lines": 79,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_xattr": {
      "start_point": [
        816,
        0
      ],
      "end_point": [
        853,
        1
      ],
      "content": "static int\nset_xattr (char const *file_name, struct tar_stat_info const *st,\n           mode_t invert_permissions, char typeflag, int *file_created)\n{\n#ifdef HAVE_XATTRS\n  bool interdir_made = false;\n\n  if ((xattrs_option > 0) && st->xattr_map_size)\n    {\n      mode_t mode = current_stat_info.stat.st_mode & MODE_RWX & ~ current_umask;\n\n      for (;;)\n        {\n          if (!mknodat (chdir_fd, file_name, mode ^ invert_permissions, 0))\n            {\n              /* Successfully created file */\n              xattrs_xattrs_set (st, file_name, typeflag, 0);\n              *file_created = 1;\n              return 0;\n            }\n\n          switch (maybe_recoverable ((char *)file_name, false, &interdir_made))\n            {\n              case RECOVER_OK:\n                continue;\n              case RECOVER_NO:\n                skip_member ();\n                open_error (file_name);\n                return 1;\n              case RECOVER_SKIP:\n                return 0;\n            }\n        }\n    }\n#endif\n\n  return 0;\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "apply_nonancestor_delayed_set_stat": {
      "start_point": [
        860,
        0
      ],
      "end_point": [
        930,
        1
      ],
      "content": "static void\napply_nonancestor_delayed_set_stat (char const *file_name, bool after_links)\n{\n  size_t file_name_len = strlen (file_name);\n  bool check_for_renamed_directories = 0;\n\n  while (delayed_set_stat_head)\n    {\n      struct delayed_set_stat *data = delayed_set_stat_head;\n      bool skip_this_one = 0;\n      struct stat st;\n      mode_t current_mode = data->current_mode;\n      mode_t current_mode_mask = data->current_mode_mask;\n\n      check_for_renamed_directories |= data->after_links;\n\n      if (after_links < data->after_links\n\t  || (data->file_name_len < file_name_len\n\t      && file_name[data->file_name_len]\n\t      && (ISSLASH (file_name[data->file_name_len])\n\t\t  || ISSLASH (file_name[data->file_name_len - 1]))\n\t      && memcmp (file_name, data->file_name, data->file_name_len) == 0))\n\tbreak;\n\n      chdir_do (data->change_dir);\n\n      if (check_for_renamed_directories)\n\t{\n\t  if (fstatat (chdir_fd, data->file_name, &st, data->atflag) != 0)\n\t    {\n\t      stat_error (data->file_name);\n\t      skip_this_one = 1;\n\t    }\n\t  else\n\t    {\n\t      current_mode = st.st_mode;\n\t      current_mode_mask = ALL_MODE_BITS;\n\t      if (! (st.st_dev == data->dev && st.st_ino == data->ino))\n\t\t{\n\t\t  ERROR ((0, 0,\n\t\t\t  _(\"%s: Directory renamed before its status could be extracted\"),\n\t\t\t  quotearg_colon (data->file_name)));\n\t\t  skip_this_one = 1;\n\t\t}\n\t    }\n\t}\n\n      if (! skip_this_one)\n\t{\n\t  struct tar_stat_info sb;\n\t  sb.stat.st_mode = data->mode;\n\t  sb.stat.st_uid = data->uid;\n\t  sb.stat.st_gid = data->gid;\n\t  sb.atime = data->atime;\n\t  sb.mtime = data->mtime;\n\t  sb.cntx_name = data->cntx_name;\n\t  sb.acls_a_ptr = data->acls_a_ptr;\n\t  sb.acls_a_len = data->acls_a_len;\n\t  sb.acls_d_ptr = data->acls_d_ptr;\n\t  sb.acls_d_len = data->acls_d_len;\n\t  sb.xattr_map = data->xattr_map;\n\t  sb.xattr_map_size = data->xattr_map_size;\n\t  set_stat (data->file_name, &sb,\n\t\t    -1, current_mode, current_mode_mask,\n\t\t    DIRTYPE, data->interdir, data->atflag);\n\t}\n\n      delayed_set_stat_head = data->next;\n      free_delayed_set_stat (data);\n    }\n}",
      "lines": 71,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_directory_link": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        946,
        1
      ],
      "content": "static bool\nis_directory_link (const char *file_name)\n{\n  struct stat st;\n  int e = errno;\n  int res;\n\n  res = (fstatat (chdir_fd, file_name, &st, AT_SYMLINK_NOFOLLOW) == 0 &&\n\t S_ISLNK (st.st_mode) &&\n\t fstatat (chdir_fd, file_name, &st, 0) == 0 &&\n\t S_ISDIR (st.st_mode));\n  errno = e;\n  return res;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "extract_dir": {
      "start_point": [
        950,
        0
      ],
      "end_point": [
        1056,
        1
      ],
      "content": "static int\nextract_dir (char *file_name, int typeflag)\n{\n  int status;\n  mode_t mode;\n  mode_t current_mode = 0;\n  mode_t current_mode_mask = 0;\n  int atflag = 0;\n  bool interdir_made = false;\n\n  /* Save 'root device' to avoid purging mount points. */\n  if (one_file_system_option && root_device == 0)\n    {\n      struct stat st;\n\n      if (fstatat (chdir_fd, \".\", &st, 0) != 0)\n\tstat_diag (\".\");\n      else\n\troot_device = st.st_dev;\n    }\n\n  if (incremental_option)\n    /* Read the entry and delete files that aren't listed in the archive.  */\n    purge_directory (file_name);\n  else if (typeflag == GNUTYPE_DUMPDIR)\n    skip_member ();\n\n  /* If ownership or permissions will be restored later, create the\n     directory with restrictive permissions at first, so that in the\n     meantime processes owned by other users do not inadvertently\n     create files under this directory that inherit the wrong owner,\n     group, or permissions from the directory.  If not root, though,\n     make the directory writeable and searchable at first, so that\n     files can be created under it.  */\n  mode = ((current_stat_info.stat.st_mode\n\t   & (0 < same_owner_option || 0 < same_permissions_option\n\t      ? S_IRWXU\n\t      : MODE_RWX))\n\t  | (we_are_root ? 0 : MODE_WXUSR));\n\n  for (;;)\n    {\n      status = mkdirat (chdir_fd, file_name, mode);\n      if (status == 0)\n\t{\n\t  current_mode = mode & ~ current_umask;\n\t  current_mode_mask = MODE_RWX;\n\t  atflag = AT_SYMLINK_NOFOLLOW;\n\t  break;\n\t}\n\n      if (errno == EEXIST\n\t  && (interdir_made\n\t      || keep_directory_symlink_option\n\t      || old_files_option == DEFAULT_OLD_FILES\n\t      || old_files_option == OVERWRITE_OLD_FILES))\n\t{\n\t  struct stat st;\n\n\t  if (keep_directory_symlink_option && is_directory_link (file_name))\n\t    return 0;\n\n\t  if (deref_stat (file_name, &st) == 0)\n\t    {\n\t      current_mode = st.st_mode;\n\t      current_mode_mask = ALL_MODE_BITS;\n\n\t      if (S_ISDIR (current_mode))\n\t\t{\n\t\t  if (interdir_made)\n\t\t    {\n\t\t      repair_delayed_set_stat (file_name, &st);\n\t\t      return 0;\n\t\t    }\n\t\t  break;\n\t\t}\n\t    }\n\t  errno = EEXIST;\n\t}\n\n      switch (maybe_recoverable (file_name, false, &interdir_made))\n\t{\n\tcase RECOVER_OK:\n\t  continue;\n\n\tcase RECOVER_SKIP:\n\t  break;\n\n\tcase RECOVER_NO:\n\t  if (errno != EEXIST)\n\t    {\n\t      mkdir_error (file_name);\n\t      return 1;\n\t    }\n\t  break;\n\t}\n      break;\n    }\n\n  if (status == 0\n      || old_files_option == DEFAULT_OLD_FILES\n      || old_files_option == OVERWRITE_OLD_FILES)\n    delay_set_stat (file_name, &current_stat_info,\n\t\t    current_mode, current_mode_mask,\n\t\t    current_stat_info.stat.st_mode, atflag);\n  return status;\n}",
      "lines": 107,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open_output_file": {
      "start_point": [
        1060,
        0
      ],
      "end_point": [
        1134,
        1
      ],
      "content": "static int\nopen_output_file (char const *file_name, int typeflag, mode_t mode,\n                  int file_created, mode_t *current_mode,\n                  mode_t *current_mode_mask)\n{\n  int fd;\n  bool overwriting_old_files = old_files_option == OVERWRITE_OLD_FILES;\n  int openflag = (O_WRONLY | O_BINARY | O_CLOEXEC | O_NOCTTY | O_NONBLOCK\n\t\t  | O_CREAT\n\t\t  | (overwriting_old_files\n\t\t     ? O_TRUNC | (dereference_option ? 0 : O_NOFOLLOW)\n\t\t     : O_EXCL));\n\n  /* File might be created in set_xattr. So clear O_EXCL to avoid open() fail */\n  if (file_created)\n    openflag = openflag & ~O_EXCL;\n\n  if (typeflag == CONTTYPE)\n    {\n      static int conttype_diagnosed;\n\n      if (!conttype_diagnosed)\n\t{\n\t  conttype_diagnosed = 1;\n\t  WARNOPT (WARN_CONTIGUOUS_CAST,\n\t\t   (0, 0, _(\"Extracting contiguous files as regular files\")));\n\t}\n    }\n\n  /* If O_NOFOLLOW is needed but does not work, check for a symlink\n     separately.  There's a race condition, but that cannot be avoided\n     on hosts lacking O_NOFOLLOW.  */\n  if (! HAVE_WORKING_O_NOFOLLOW\n      && overwriting_old_files && ! dereference_option)\n    {\n      struct stat st;\n      if (fstatat (chdir_fd, file_name, &st, AT_SYMLINK_NOFOLLOW) == 0\n\t  && S_ISLNK (st.st_mode))\n\t{\n\t  errno = ELOOP;\n\t  return -1;\n\t}\n    }\n\n  fd = openat (chdir_fd, file_name, openflag, mode);\n  if (0 <= fd)\n    {\n      if (overwriting_old_files)\n\t{\n\t  struct stat st;\n\t  if (fstat (fd, &st) != 0)\n\t    {\n\t      int e = errno;\n\t      close (fd);\n\t      errno = e;\n\t      return -1;\n\t    }\n\t  if (! S_ISREG (st.st_mode))\n\t    {\n\t      close (fd);\n\t      errno = EEXIST;\n\t      return -1;\n\t    }\n\t  *current_mode = st.st_mode;\n\t  *current_mode_mask = ALL_MODE_BITS;\n\t}\n      else\n\t{\n\t  *current_mode = mode & ~ current_umask;\n\t  *current_mode_mask = MODE_RWX;\n\t}\n    }\n\n  return fd;\n}",
      "lines": 75,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extract_file": {
      "start_point": [
        1136,
        0
      ],
      "end_point": [
        1250,
        1
      ],
      "content": "static int\nextract_file (char *file_name, int typeflag)\n{\n  int fd;\n  off_t size;\n  union block *data_block;\n  int status;\n  size_t count;\n  size_t written;\n  bool interdir_made = false;\n  mode_t mode = (current_stat_info.stat.st_mode & MODE_RWX\n\t\t & ~ (0 < same_owner_option ? S_IRWXG | S_IRWXO : 0));\n  mode_t invert_permissions = 0 < same_owner_option ? mode & (S_IRWXG | S_IRWXO)\n                                                    : 0;\n  mode_t current_mode = 0;\n  mode_t current_mode_mask = 0;\n\n  if (to_stdout_option)\n    fd = STDOUT_FILENO;\n  else if (to_command_option)\n    {\n      fd = sys_exec_command (file_name, 'f', &current_stat_info);\n      if (fd < 0)\n\t{\n\t  skip_member ();\n\t  return 0;\n\t}\n    }\n  else\n    {\n      int file_created = 0;\n      if (set_xattr (file_name, &current_stat_info, invert_permissions,\n                     typeflag, &file_created))\n        return 1;\n\n      while ((fd = open_output_file (file_name, typeflag, mode,\n                                     file_created, &current_mode,\n                                     &current_mode_mask))\n\t     < 0)\n\t{\n\t  int recover = maybe_recoverable (file_name, true, &interdir_made);\n\t  if (recover != RECOVER_OK)\n\t    {\n\t      skip_member ();\n\t      if (recover == RECOVER_SKIP)\n\t\treturn 0;\n\t      open_error (file_name);\n\t      return 1;\n\t    }\n\t}\n    }\n\n  mv_begin_read (&current_stat_info);\n  if (current_stat_info.is_sparse)\n    sparse_extract_file (fd, &current_stat_info, &size);\n  else\n    for (size = current_stat_info.stat.st_size; size > 0; )\n      {\n\tmv_size_left (size);\n\n\t/* Locate data, determine max length writeable, write it,\n\t   block that we have used the data, then check if the write\n\t   worked.  */\n\n\tdata_block = find_next_block ();\n\tif (! data_block)\n\t  {\n\t    ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t    break;\t\t/* FIXME: What happens, then?  */\n\t  }\n\n\twritten = available_space_after (data_block);\n\n\tif (written > size)\n\t  written = size;\n\terrno = 0;\n\tcount = blocking_write (fd, data_block->buffer, written);\n\tsize -= written;\n\n\tset_next_block_after ((union block *)\n\t\t\t      (data_block->buffer + written - 1));\n\tif (count != written)\n\t  {\n\t    if (!to_command_option)\n\t      write_error_details (file_name, count, written);\n\t    /* FIXME: shouldn't we restore from backup? */\n\t    break;\n\t  }\n      }\n\n  skip_file (size);\n\n  mv_end ();\n\n  /* If writing to stdout, don't try to do anything to the filename;\n     it doesn't exist, or we don't want to touch it anyway.  */\n\n  if (to_stdout_option)\n    return 0;\n\n  if (! to_command_option)\n    set_stat (file_name, &current_stat_info, fd,\n\t      current_mode, current_mode_mask, typeflag, false,\n\t      (old_files_option == OVERWRITE_OLD_FILES\n\t       ? 0 : AT_SYMLINK_NOFOLLOW));\n\n  status = close (fd);\n  if (status < 0)\n    close_error (file_name);\n\n  if (to_command_option)\n    sys_wait_command ();\n\n  return status;\n}",
      "lines": 115,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "create_placeholder_file": {
      "start_point": [
        1258,
        0
      ],
      "end_point": [
        1329,
        1
      ],
      "content": "static int\ncreate_placeholder_file (char *file_name, bool is_symlink, bool *interdir_made)\n{\n  int fd;\n  struct stat st;\n\n  while ((fd = openat (chdir_fd, file_name, O_WRONLY | O_CREAT | O_EXCL, 0)) < 0)\n    {\n      switch (maybe_recoverable (file_name, false, interdir_made))\n\t{\n\tcase RECOVER_OK:\n\t  continue;\n\n\tcase RECOVER_SKIP:\n\t  return 0;\n\n\tcase RECOVER_NO:\n\t  open_error (file_name);\n\t  return -1;\n\t}\n      }\n\n  if (fstat (fd, &st) != 0)\n    {\n      stat_error (file_name);\n      close (fd);\n    }\n  else if (close (fd) != 0)\n    close_error (file_name);\n  else\n    {\n      struct delayed_set_stat *h;\n      struct delayed_link *p =\n\txmalloc (offsetof (struct delayed_link, target)\n\t\t + strlen (current_stat_info.link_name)\n\t\t + 1);\n      p->next = delayed_link_head;\n      delayed_link_head = p;\n      p->dev = st.st_dev;\n      p->ino = st.st_ino;\n      p->birthtime = get_stat_birthtime (&st);\n      p->is_symlink = is_symlink;\n      if (is_symlink)\n\t{\n\t  p->mode = current_stat_info.stat.st_mode;\n\t  p->uid = current_stat_info.stat.st_uid;\n\t  p->gid = current_stat_info.stat.st_gid;\n\t  p->atime = current_stat_info.atime;\n\t  p->mtime = current_stat_info.mtime;\n\t}\n      p->change_dir = chdir_current;\n      p->sources = xmalloc (offsetof (struct string_list, string)\n\t\t\t    + strlen (file_name) + 1);\n      p->sources->next = 0;\n      strcpy (p->sources->string, file_name);\n      p->cntx_name = NULL;\n      assign_string (&p->cntx_name, current_stat_info.cntx_name);\n      p->acls_a_ptr = NULL;\n      p->acls_a_len = 0;\n      p->acls_d_ptr = NULL;\n      p->acls_d_len = 0;\n      xheader_xattr_copy (&current_stat_info, &p->xattr_map, &p->xattr_map_size);\n      strcpy (p->target, current_stat_info.link_name);\n\n      if ((h = find_direct_ancestor (file_name)) != NULL)\n\tmark_after_links (h);\n\n      return 0;\n    }\n\n  return -1;\n}",
      "lines": 72,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extract_link": {
      "start_point": [
        1331,
        0
      ],
      "end_point": [
        1393,
        1
      ],
      "content": "static int\nextract_link (char *file_name, int typeflag)\n{\n  bool interdir_made = false;\n  char const *link_name;\n  int rc;\n\n  link_name = current_stat_info.link_name;\n\n  if (! absolute_names_option && contains_dot_dot (link_name))\n    return create_placeholder_file (file_name, false, &interdir_made);\n\n  do\n    {\n      struct stat st1, st2;\n      int e;\n      int status = linkat (chdir_fd, link_name, chdir_fd, file_name, 0);\n      e = errno;\n\n      if (status == 0)\n\t{\n\t  struct delayed_link *ds = delayed_link_head;\n\t  if (ds\n\t      && fstatat (chdir_fd, link_name, &st1, AT_SYMLINK_NOFOLLOW) == 0)\n\t    for (; ds; ds = ds->next)\n\t      if (ds->change_dir == chdir_current\n\t\t  && ds->dev == st1.st_dev\n\t\t  && ds->ino == st1.st_ino\n\t\t  && (timespec_cmp (ds->birthtime, get_stat_birthtime (&st1))\n\t\t      == 0))\n\t\t{\n\t\t  struct string_list *p =  xmalloc (offsetof (struct string_list, string)\n\t\t\t\t\t\t    + strlen (file_name) + 1);\n\t\t  strcpy (p->string, file_name);\n\t\t  p->next = ds->sources;\n\t\t  ds->sources = p;\n\t\t  break;\n\t\t}\n\t  return 0;\n\t}\n      else if ((e == EEXIST && strcmp (link_name, file_name) == 0)\n\t       || ((fstatat (chdir_fd, link_name, &st1, AT_SYMLINK_NOFOLLOW)\n\t\t    == 0)\n\t\t   && (fstatat (chdir_fd, file_name, &st2, AT_SYMLINK_NOFOLLOW)\n\t\t       == 0)\n\t\t   && st1.st_dev == st2.st_dev\n\t\t   && st1.st_ino == st2.st_ino))\n\treturn 0;\n\n      errno = e;\n    }\n  while ((rc = maybe_recoverable (file_name, false, &interdir_made))\n\t == RECOVER_OK);\n\n  if (rc == RECOVER_SKIP)\n    return 0;\n  if (!(incremental_option && errno == EEXIST))\n    {\n      link_error (link_name, file_name);\n      return 1;\n    }\n  return 0;\n}",
      "lines": 63,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extract_symlink": {
      "start_point": [
        1395,
        0
      ],
      "end_point": [
        1436,
        1
      ],
      "content": "static int\nextract_symlink (char *file_name, int typeflag)\n{\n#ifdef HAVE_SYMLINK\n  bool interdir_made = false;\n\n  if (! absolute_names_option\n      && (IS_ABSOLUTE_FILE_NAME (current_stat_info.link_name)\n\t  || contains_dot_dot (current_stat_info.link_name)))\n    return create_placeholder_file (file_name, true, &interdir_made);\n\n  while (symlinkat (current_stat_info.link_name, chdir_fd, file_name) != 0)\n    switch (maybe_recoverable (file_name, false, &interdir_made))\n      {\n      case RECOVER_OK:\n\tcontinue;\n\n      case RECOVER_SKIP:\n\treturn 0;\n\n      case RECOVER_NO:\n\tsymlink_error (current_stat_info.link_name, file_name);\n\treturn -1;\n      }\n\n  set_stat (file_name, &current_stat_info, -1, 0, 0,\n\t    SYMTYPE, false, AT_SYMLINK_NOFOLLOW);\n  return 0;\n\n#else\n  static int warned_once;\n\n  if (!warned_once)\n    {\n      warned_once = 1;\n      WARNOPT (WARN_SYMLINK_CAST,\n\t       (0, 0,\n\t\t_(\"Attempting extraction of symbolic links as hard links\")));\n    }\n  return extract_link (file_name, typeflag);\n#endif\n}",
      "lines": 42,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extract_node": {
      "start_point": [
        1439,
        0
      ],
      "end_point": [
        1465,
        1
      ],
      "content": "static int\nextract_node (char *file_name, int typeflag)\n{\n  bool interdir_made = false;\n  mode_t mode = (current_stat_info.stat.st_mode & (MODE_RWX | S_IFBLK | S_IFCHR)\n\t\t & ~ (0 < same_owner_option ? S_IRWXG | S_IRWXO : 0));\n\n  while (mknodat (chdir_fd, file_name, mode, current_stat_info.stat.st_rdev)\n\t != 0)\n    switch (maybe_recoverable (file_name, false, &interdir_made))\n      {\n      case RECOVER_OK:\n\tcontinue;\n\n      case RECOVER_SKIP:\n\treturn 0;\n\n      case RECOVER_NO:\n\tmknod_error (file_name);\n\treturn -1;\n      }\n\n  set_stat (file_name, &current_stat_info, -1,\n\t    mode & ~ current_umask, MODE_RWX,\n\t    typeflag, false, AT_SYMLINK_NOFOLLOW);\n  return 0;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extract_fifo": {
      "start_point": [
        1469,
        0
      ],
      "end_point": [
        1494,
        1
      ],
      "content": "static int\nextract_fifo (char *file_name, int typeflag)\n{\n  bool interdir_made = false;\n  mode_t mode = (current_stat_info.stat.st_mode & MODE_RWX\n\t\t & ~ (0 < same_owner_option ? S_IRWXG | S_IRWXO : 0));\n\n  while (mkfifoat (chdir_fd, file_name, mode) != 0)\n    switch (maybe_recoverable (file_name, false, &interdir_made))\n      {\n      case RECOVER_OK:\n\tcontinue;\n\n      case RECOVER_SKIP:\n\treturn 0;\n\n      case RECOVER_NO:\n\tmkfifo_error (file_name);\n\treturn -1;\n      }\n\n  set_stat (file_name, &current_stat_info, -1,\n\t    mode & ~ current_umask, MODE_RWX,\n\t    typeflag, false, AT_SYMLINK_NOFOLLOW);\n  return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extract_volhdr": {
      "start_point": [
        1497,
        0
      ],
      "end_point": [
        1502,
        1
      ],
      "content": "static int\nextract_volhdr (char *file_name, int typeflag)\n{\n  skip_member ();\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extract_failure": {
      "start_point": [
        1504,
        0
      ],
      "end_point": [
        1508,
        1
      ],
      "content": "static int\nextract_failure (char *file_name, int typeflag)\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extract_skip": {
      "start_point": [
        1510,
        0
      ],
      "end_point": [
        1515,
        1
      ],
      "content": "static int\nextract_skip (char *file_name, int typeflag)\n{\n  skip_member ();\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "prepare_to_extract": {
      "start_point": [
        1524,
        0
      ],
      "end_point": [
        1646,
        1
      ],
      "content": "static int\nprepare_to_extract (char const *file_name, int typeflag, tar_extractor_t *fun)\n{\n  int rc = 1;\n\n  if (EXTRACT_OVER_PIPE)\n    rc = 0;\n\n  /* Select the extractor */\n  switch (typeflag)\n    {\n    case GNUTYPE_SPARSE:\n      *fun = extract_file;\n      rc = 1;\n      break;\n\n    case AREGTYPE:\n    case REGTYPE:\n    case CONTTYPE:\n      /* Appears to be a file.  But BSD tar uses the convention that a slash\n\t suffix means a directory.  */\n      if (current_stat_info.had_trailing_slash)\n\t*fun = extract_dir;\n      else\n\t{\n\t  *fun = extract_file;\n\t  rc = 1;\n\t}\n      break;\n\n    case SYMTYPE:\n      *fun = extract_symlink;\n      break;\n\n    case LNKTYPE:\n      *fun = extract_link;\n      break;\n\n#if S_IFCHR\n    case CHRTYPE:\n      current_stat_info.stat.st_mode |= S_IFCHR;\n      *fun = extract_node;\n      break;\n#endif\n\n#if S_IFBLK\n    case BLKTYPE:\n      current_stat_info.stat.st_mode |= S_IFBLK;\n      *fun = extract_node;\n      break;\n#endif\n\n#if HAVE_MKFIFO || defined mkfifo\n    case FIFOTYPE:\n      *fun = extract_fifo;\n      break;\n#endif\n\n    case DIRTYPE:\n    case GNUTYPE_DUMPDIR:\n      *fun = extract_dir;\n      if (current_stat_info.is_dumpdir)\n\tdelay_directory_restore_option = true;\n      break;\n\n    case GNUTYPE_VOLHDR:\n      *fun = extract_volhdr;\n      break;\n\n    case GNUTYPE_MULTIVOL:\n      ERROR ((0, 0,\n\t      _(\"%s: Cannot extract -- file is continued from another volume\"),\n\t      quotearg_colon (current_stat_info.file_name)));\n      *fun = extract_skip;\n      break;\n\n    case GNUTYPE_LONGNAME:\n    case GNUTYPE_LONGLINK:\n      ERROR ((0, 0, _(\"Unexpected long name header\")));\n      *fun = extract_failure;\n      break;\n\n    default:\n      WARNOPT (WARN_UNKNOWN_CAST,\n\t       (0, 0,\n\t\t_(\"%s: Unknown file type '%c', extracted as normal file\"),\n\t\tquotearg_colon (file_name), typeflag));\n      *fun = extract_file;\n    }\n\n  /* Determine whether the extraction should proceed */\n  if (rc == 0)\n    return 0;\n\n  switch (old_files_option)\n    {\n    case UNLINK_FIRST_OLD_FILES:\n      if (!remove_any_file (file_name,\n                            recursive_unlink_option ? RECURSIVE_REMOVE_OPTION\n                                                      : ORDINARY_REMOVE_OPTION)\n\t  && errno && errno != ENOENT)\n\t{\n\t  unlink_error (file_name);\n\t  return 0;\n\t}\n      break;\n\n    case KEEP_NEWER_FILES:\n      if (file_newer_p (file_name, 0, &current_stat_info))\n\t{\n\t  WARNOPT (WARN_IGNORE_NEWER,\n\t\t   (0, 0, _(\"Current %s is newer or same age\"),\n\t\t    quote (file_name)));\n\t  return 0;\n\t}\n      break;\n\n    default:\n      break;\n    }\n\n  return 1;\n}",
      "lines": 123,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extract_archive": {
      "start_point": [
        1649,
        0
      ],
      "end_point": [
        1715,
        1
      ],
      "content": "void\nextract_archive (void)\n{\n  char typeflag;\n  tar_extractor_t fun;\n  bool skip_dotdot_name;\n\n  fatal_exit_hook = extract_finish;\n\n  set_next_block_after (current_header);\n\n  skip_dotdot_name = (!absolute_names_option\n\t\t      && contains_dot_dot (current_stat_info.orig_file_name));\n  if (skip_dotdot_name)\n    ERROR ((0, 0, _(\"%s: Member name contains '..'\"),\n\t    quotearg_colon (current_stat_info.orig_file_name)));\n\n  if (!current_stat_info.file_name[0]\n      || skip_dotdot_name\n      || (interactive_option\n\t  && !confirm (\"extract\", current_stat_info.file_name)))\n    {\n      skip_member ();\n      return;\n    }\n\n  /* Print the block from current_header and current_stat.  */\n  if (verbose_option)\n    print_header (&current_stat_info, current_header, -1);\n\n  /* Restore stats for all non-ancestor directories, unless\n     it is an incremental archive.\n     (see NOTICE in the comment to delay_set_stat above) */\n  if (!delay_directory_restore_option)\n    {\n      int dir = chdir_current;\n      apply_nonancestor_delayed_set_stat (current_stat_info.file_name, 0);\n      chdir_do (dir);\n    }\n\n  /* Take a safety backup of a previously existing file.  */\n\n  if (backup_option)\n    if (!maybe_backup_file (current_stat_info.file_name, 0))\n      {\n\tint e = errno;\n\tERROR ((0, e, _(\"%s: Was unable to backup this file\"),\n\t\tquotearg_colon (current_stat_info.file_name)));\n\tskip_member ();\n\treturn;\n      }\n\n  /* Extract the archive entry according to its type.  */\n  /* KLUDGE */\n  typeflag = sparse_member_p (&current_stat_info) ?\n                  GNUTYPE_SPARSE : current_header->header.typeflag;\n\n  if (prepare_to_extract (current_stat_info.file_name, typeflag, &fun))\n    {\n      if (fun && (*fun) (current_stat_info.file_name, typeflag)\n\t  && backup_option)\n\tundo_last_backup ();\n    }\n  else\n    skip_member ();\n\n}",
      "lines": 67,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "apply_delayed_links": {
      "start_point": [
        1718,
        0
      ],
      "end_point": [
        1798,
        1
      ],
      "content": "static void\napply_delayed_links (void)\n{\n  struct delayed_link *ds;\n\n  for (ds = delayed_link_head; ds; )\n    {\n      struct string_list *sources = ds->sources;\n      char const *valid_source = 0;\n\n      chdir_do (ds->change_dir);\n\n      for (sources = ds->sources; sources; sources = sources->next)\n\t{\n\t  char const *source = sources->string;\n\t  struct stat st;\n\n\t  /* Make sure the placeholder file is still there.  If not,\n\t     don't create a link, as the placeholder was probably\n\t     removed by a later extraction.  */\n\t  if (fstatat (chdir_fd, source, &st, AT_SYMLINK_NOFOLLOW) == 0\n\t      && st.st_dev == ds->dev\n\t      && st.st_ino == ds->ino\n\t      && timespec_cmp (get_stat_birthtime (&st), ds->birthtime) == 0)\n\t    {\n\t      /* Unlink the placeholder, then create a hard link if possible,\n\t\t a symbolic link otherwise.  */\n\t      if (unlinkat (chdir_fd, source, 0) != 0)\n\t\tunlink_error (source);\n\t      else if (valid_source\n\t\t       && (linkat (chdir_fd, valid_source, chdir_fd, source, 0)\n\t\t\t   == 0))\n\t\t;\n\t      else if (!ds->is_symlink)\n\t\t{\n\t\t  if (linkat (chdir_fd, ds->target, chdir_fd, source, 0) != 0)\n\t\t    link_error (ds->target, source);\n\t\t}\n\t      else if (symlinkat (ds->target, chdir_fd, source) != 0)\n\t\tsymlink_error (ds->target, source);\n\t      else\n\t\t{\n\t\t  struct tar_stat_info st1;\n\t\t  st1.stat.st_mode = ds->mode;\n\t\t  st1.stat.st_uid = ds->uid;\n\t\t  st1.stat.st_gid = ds->gid;\n\t\t  st1.atime = ds->atime;\n\t\t  st1.mtime = ds->mtime;\n                  st1.cntx_name = ds->cntx_name;\n                  st1.acls_a_ptr = ds->acls_a_ptr;\n                  st1.acls_a_len = ds->acls_a_len;\n                  st1.acls_d_ptr = ds->acls_d_ptr;\n                  st1.acls_d_len = ds->acls_d_len;\n                  st1.xattr_map = ds->xattr_map;\n                  st1.xattr_map_size = ds->xattr_map_size;\n\t\t  set_stat (source, &st1, -1, 0, 0, SYMTYPE,\n\t\t\t    false, AT_SYMLINK_NOFOLLOW);\n\t\t  valid_source = source;\n\t\t}\n\t    }\n\t}\n\n      for (sources = ds->sources; sources; )\n\t{\n\t  struct string_list *next = sources->next;\n\t  free (sources);\n\t  sources = next;\n\t}\n\n   xheader_xattr_free (ds->xattr_map, ds->xattr_map_size);\n   free (ds->cntx_name);\n\n      {\n\tstruct delayed_link *next = ds->next;\n\tfree (ds);\n\tds = next;\n      }\n    }\n\n  delayed_link_head = 0;\n}",
      "lines": 81,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "extract_finish": {
      "start_point": [
        1801,
        0
      ],
      "end_point": [
        1814,
        1
      ],
      "content": "void\nextract_finish (void)\n{\n  /* First, fix the status of ordinary directories that need fixing.  */\n  apply_nonancestor_delayed_set_stat (\"\", 0);\n\n  /* Then, apply delayed links, so that they don't affect delayed\n     directory status-setting for ordinary directories.  */\n  apply_delayed_links ();\n\n  /* Finally, fix the status of directories that are ancestors\n     of delayed links.  */\n  apply_nonancestor_delayed_set_stat (\"\", 1);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rename_directory": {
      "start_point": [
        1816,
        0
      ],
      "end_point": [
        1850,
        1
      ],
      "content": "bool\nrename_directory (char *src, char *dst)\n{\n  if (renameat (chdir_fd, src, chdir_fd, dst) == 0)\n    fixup_delayed_set_stat (src, dst);\n  else\n    {\n      int e = errno;\n      bool interdir_made;\n\n      switch (e)\n\t{\n\tcase ENOENT:\n\t  if (make_directories (dst, &interdir_made) == 0)\n\t    {\n\t      if (renameat (chdir_fd, src, chdir_fd, dst) == 0)\n\t\treturn true;\n\t      e = errno;\n\t    }\n\t  break;\n\n\tcase EXDEV:\n\t  /* FIXME: Fall back to recursive copying */\n\n\tdefault:\n\t  break;\n\t}\n\n      ERROR ((0, e, _(\"Cannot rename %s to %s\"),\n\t      quote_n (0, src),\n\t      quote_n (1, dst)));\n      return false;\n    }\n  return true;\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    }
  },
  "tar/tar-1.30/src/incremen.c": {
    "dumpdir_create0": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static struct dumpdir *\ndumpdir_create0 (const char *contents, const char *cmask)\n{\n  struct dumpdir *dump;\n  size_t i, total, ctsize, len;\n  char *p;\n  const char *q;\n\n  for (i = 0, total = 0, ctsize = 1, q = contents; *q; total++, q += len)\n    {\n      len = strlen (q) + 1;\n      ctsize += len;\n      if (!cmask || strchr (cmask, *q))\n\ti++;\n    }\n  dump = xmalloc (sizeof (*dump) + ctsize);\n  dump->contents = (char*)(dump + 1);\n  memcpy (dump->contents, contents, ctsize);\n  dump->total = total;\n  dump->elc = i;\n  dump->elv = xcalloc (i + 1, sizeof (dump->elv[0]));\n\n  for (i = 0, p = dump->contents; *p; p += strlen (p) + 1)\n    {\n      if (!cmask || strchr (cmask, *p))\n\tdump->elv[i++] = p + 1;\n    }\n  dump->elv[i] = NULL;\n  return dump;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct dumpdir",
        "struct",
        "dumpdir",
        "*\ndumpdir_create0 (const char *contents, const char *cmask)",
        "*"
      ]
    },
    "dumpdir_create": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static struct dumpdir *\ndumpdir_create (const char *contents)\n{\n  return dumpdir_create0 (contents, \"YND\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct dumpdir",
        "struct",
        "dumpdir",
        "*\ndumpdir_create (const char *contents)",
        "*"
      ]
    },
    "dumpdir_free": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static void\ndumpdir_free (struct dumpdir *dump)\n{\n  free (dump->elv);\n  free (dump);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compare_dirnames": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static int\ncompare_dirnames (const void *first, const void *second)\n{\n  char const *const *name1 = first;\n  char const *const *name2 = second;\n  return strcmp (*name1, *name2);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dumpdir_locate": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static char *\ndumpdir_locate (struct dumpdir *dump, const char *name)\n{\n  char **ptr;\n  if (!dump)\n    return NULL;\n\n  ptr = bsearch (&name, dump->elv, dump->elc, sizeof (dump->elv[0]),\n\t\t compare_dirnames);\n  return ptr ? *ptr - 1: NULL;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndumpdir_locate (struct dumpdir *dump, const char *name)",
        "*"
      ]
    },
    "dumpdir_next": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static char *\ndumpdir_next (struct dumpdir_iter *itr)\n{\n  size_t cur = itr->next;\n  char *ret = NULL;\n\n  if (itr->all)\n    {\n      ret = itr->dump->contents + cur;\n      if (*ret == 0)\n\treturn NULL;\n      itr->next += strlen (ret) + 1;\n    }\n  else if (cur < itr->dump->elc)\n    {\n      ret = itr->dump->elv[cur] - 1;\n      itr->next++;\n    }\n\n  return ret;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndumpdir_next (struct dumpdir_iter *itr)",
        "*"
      ]
    },
    "dumpdir_first": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static char *\ndumpdir_first (struct dumpdir *dump, int all, struct dumpdir_iter **pitr)\n{\n  struct dumpdir_iter *itr = xmalloc (sizeof (*itr));\n  itr->dump = dump;\n  itr->all = all;\n  itr->next = 0;\n  *pitr = itr;\n  return dumpdir_next (itr);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndumpdir_first (struct dumpdir *dump, int all, struct dumpdir_iter **pitr)",
        "*"
      ]
    },
    "dumpdir_size": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "size_t\ndumpdir_size (const char *p)\n{\n  size_t totsize = 0;\n\n  while (*p)\n    {\n      size_t size = strlen (p) + 1;\n      totsize += size;\n      p += size;\n    }\n  return totsize + 1;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    },
    "hash_directory_canonical_name": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static size_t\nhash_directory_canonical_name (void const *entry, size_t n_buckets)\n{\n  struct directory const *directory = entry;\n  return hash_string (directory->caname, n_buckets);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "compare_directory_canonical_names": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static bool\ncompare_directory_canonical_names (void const *entry1, void const *entry2)\n{\n  struct directory const *directory1 = entry1;\n  struct directory const *directory2 = entry2;\n  return strcmp (directory1->caname, directory2->caname) == 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "hash_directory_meta": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static size_t\nhash_directory_meta (void const *entry, size_t n_buckets)\n{\n  struct directory const *directory = entry;\n  /* FIXME: Work out a better algorytm */\n  return (directory->device_number + directory->inode_number) % n_buckets;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "compare_directory_meta": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "static bool\ncompare_directory_meta (void const *entry1, void const *entry2)\n{\n  struct directory const *directory1 = entry1;\n  struct directory const *directory2 = entry2;\n  return directory1->device_number == directory2->device_number\n            && directory1->inode_number == directory2->inode_number;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "make_directory": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static struct directory *\nmake_directory (const char *name, char *caname)\n{\n  size_t namelen = strlen (name);\n  struct directory *directory = xmalloc (sizeof (*directory));\n  directory->next = NULL;\n  directory->dump = directory->idump = NULL;\n  directory->orig = NULL;\n  directory->flags = false;\n  if (namelen > 1 && ISSLASH (name[namelen - 1]))\n    namelen--;\n  directory->name = xmalloc (namelen + 1);\n  memcpy (directory->name, name, namelen);\n  directory->name[namelen] = 0;\n  directory->caname = caname;\n  directory->tagfile = NULL;\n  return directory;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct directory",
        "struct",
        "directory",
        "*\nmake_directory (const char *name, char *caname)",
        "*"
      ]
    },
    "free_directory": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static void\nfree_directory (struct directory *dir)\n{\n  free (dir->caname);\n  free (dir->name);\n  free (dir);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "attach_directory": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "static struct directory *\nattach_directory (const char *name)\n{\n  char *cname = normalize_filename (chdir_current, name);\n  struct directory *dir = make_directory (name, cname);\n  if (dirtail)\n    dirtail->next = dir;\n  else\n    dirhead = dir;\n  dirtail = dir;\n  return dir;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct directory",
        "struct",
        "directory",
        "*\nattach_directory (const char *name)",
        "*"
      ]
    },
    "dirlist_replace_prefix": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "static void\ndirlist_replace_prefix (const char *pref, const char *repl)\n{\n  struct directory *dp;\n  size_t pref_len = strlen (pref);\n  size_t repl_len = strlen (repl);\n  for (dp = dirhead; dp; dp = dp->next)\n    replace_prefix (&dp->name, pref, pref_len, repl, repl_len);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clear_directory_table": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "void\nclear_directory_table (void)\n{\n  struct directory *dp;\n\n  if (directory_table)\n    hash_clear (directory_table);\n  if (directory_meta_table)\n    hash_clear (directory_meta_table);\n  for (dp = dirhead; dp; )\n    {\n      struct directory *next = dp->next;\n      free_directory (dp);\n      dp = next;\n    }\n  dirhead = dirtail = NULL;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "note_directory": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "static struct directory *\nnote_directory (char const *name, struct timespec mtime,\n\t\tdev_t dev, ino_t ino, bool nfs, bool found,\n\t\tconst char *contents)\n{\n  struct directory *directory = attach_directory (name);\n\n  directory->mtime = mtime;\n  directory->device_number = dev;\n  directory->inode_number = ino;\n  directory->children = CHANGED_CHILDREN;\n  if (nfs)\n    DIR_SET_FLAG (directory, DIRF_NFS);\n  if (found)\n    DIR_SET_FLAG (directory, DIRF_FOUND);\n  if (contents)\n    directory->dump = dumpdir_create (contents);\n  else\n    directory->dump = NULL;\n\n  if (! ((directory_table\n\t  || (directory_table = hash_initialize (0, 0,\n\t\t\t\t\t\t hash_directory_canonical_name,\n\t\t\t\t\t\t compare_directory_canonical_names,\n\t\t\t\t\t\t 0)))\n\t && hash_insert (directory_table, directory)))\n    xalloc_die ();\n\n  if (! ((directory_meta_table\n\t  || (directory_meta_table = hash_initialize (0, 0,\n\t\t\t\t\t\t      hash_directory_meta,\n\t\t\t\t\t\t      compare_directory_meta,\n\t\t\t\t\t\t      0)))\n\t && hash_insert (directory_meta_table, directory)))\n    xalloc_die ();\n\n  return directory;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "struct directory",
        "struct",
        "directory",
        "*\nnote_directory (char const *name, struct timespec mtime,\n\t\tdev_t dev, ino_t ino, bool nfs, bool found,\n\t\tconst char *contents)",
        "*"
      ]
    },
    "find_directory": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "static struct directory *\nfind_directory (const char *name)\n{\n  if (! directory_table)\n    return 0;\n  else\n    {\n      char *caname = normalize_filename (chdir_current, name);\n      struct directory *dir = make_directory (name, caname);\n      struct directory *ret = hash_lookup (directory_table, dir);\n      free_directory (dir);\n      return ret;\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct directory",
        "struct",
        "directory",
        "*\nfind_directory (const char *name)",
        "*"
      ]
    },
    "remove_directory": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "void\nremove_directory (const char *caname)\n{\n  struct directory *dir = make_directory (caname, xstrdup (caname));\n  struct directory *ret = hash_delete (directory_table, dir);\n  if (ret)\n    free_directory (ret);\n  free_directory (dir);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rebase_directory": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "void\nrebase_directory (struct directory *dir,\n\t\t  const char *old_prefix, size_t old_prefix_len,\n\t\t  const char *new_prefix, size_t new_prefix_len)\n{\n  replace_prefix (&dir->name, old_prefix, old_prefix_len,\n\t\t  new_prefix, new_prefix_len);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "find_directory_meta": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "static struct directory *\nfind_directory_meta (dev_t dev, ino_t ino)\n{\n  if (! directory_meta_table)\n    return 0;\n  else\n    {\n      struct directory *dir = make_directory (\"\", NULL);\n      struct directory *ret;\n      dir->device_number = dev;\n      dir->inode_number = ino;\n      ret = hash_lookup (directory_meta_table, dir);\n      free_directory (dir);\n      return ret;\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct directory",
        "struct",
        "directory",
        "*\nfind_directory_meta (dev_t dev, ino_t ino)",
        "*"
      ]
    },
    "update_parent_directory": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "void\nupdate_parent_directory (struct tar_stat_info *parent)\n{\n  struct directory *directory = find_directory (parent->orig_file_name);\n  if (directory)\n    {\n      struct stat st;\n      if (fstat (parent->fd, &st) != 0)\n\tstat_diag (directory->name);\n      else\n\tdirectory->mtime = get_stat_mtime (&st);\n    }\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "procdir": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "static struct directory *\nprocdir (const char *name_buffer, struct tar_stat_info *st,\n\t int flag,\n\t char *entry)\n{\n  struct directory *directory;\n  struct stat *stat_data = &st->stat;\n  bool nfs = NFS_FILE_STAT (*stat_data);\n  bool perhaps_renamed = false;\n\n  if ((directory = find_directory (name_buffer)) != NULL)\n    {\n      if (DIR_IS_INITED (directory))\n\t{\n\t  if (flag & PD_FORCE_INIT)\n\t    {\n\t      assign_string (&directory->name, name_buffer);\n\t    }\n\t  else\n\t    {\n\t      *entry = 'N'; /* Avoid duplicating this directory */\n\t      return directory;\n\t    }\n\t}\n\n      if (strcmp (directory->name, name_buffer))\n\t{\n\t  *entry = 'N';\n\t  return directory;\n\t}\n\n      /* With NFS, the same file can have two different devices\n\t if an NFS directory is mounted in multiple locations,\n\t which is relatively common when automounting.\n\t To avoid spurious incremental redumping of\n\t directories, consider all NFS devices as equal,\n\t relying on the i-node to establish differences.  */\n\n      if (! ((!check_device_option\n\t      || (DIR_IS_NFS (directory) && nfs)\n\t      || directory->device_number == stat_data->st_dev)\n\t     && directory->inode_number == stat_data->st_ino))\n\t{\n\t  /* FIXME: find_directory_meta ignores nfs */\n\t  struct directory *d = find_directory_meta (stat_data->st_dev,\n\t\t\t\t\t\t     stat_data->st_ino);\n\t  if (d)\n\t    {\n\t      if (strcmp (d->name, name_buffer))\n\t\t{\n\t\t  WARNOPT (WARN_RENAME_DIRECTORY,\n\t\t\t   (0, 0,\n\t\t\t    _(\"%s: Directory has been renamed from %s\"),\n\t\t\t    quotearg_colon (name_buffer),\n\t\t\t    quote_n (1, d->name)));\n\t\t  directory->orig = d;\n\t\t  DIR_SET_FLAG (directory, DIRF_RENAMED);\n\t\t  dirlist_replace_prefix (d->name, name_buffer);\n\t\t}\n\t      directory->children = CHANGED_CHILDREN;\n\t    }\n\t  else\n\t    {\n\t      perhaps_renamed = true;\n\t      directory->children = ALL_CHILDREN;\n\t      directory->device_number = stat_data->st_dev;\n\t      directory->inode_number = stat_data->st_ino;\n\t    }\n\t  if (nfs)\n\t    DIR_SET_FLAG (directory, DIRF_NFS);\n\t}\n      else\n\tdirectory->children = CHANGED_CHILDREN;\n\n      DIR_SET_FLAG (directory, DIRF_FOUND);\n    }\n  else\n    {\n      struct directory *d = find_directory_meta (stat_data->st_dev,\n\t\t\t\t\t\t stat_data->st_ino);\n\n      directory = note_directory (name_buffer,\n\t\t\t\t  get_stat_mtime (stat_data),\n\t\t\t\t  stat_data->st_dev,\n\t\t\t\t  stat_data->st_ino,\n\t\t\t\t  nfs,\n\t\t\t\t  true,\n\t\t\t\t  NULL);\n\n      if (d)\n\t{\n\t  if (strcmp (d->name, name_buffer))\n\t    {\n\t      WARNOPT (WARN_RENAME_DIRECTORY,\n\t\t       (0, 0, _(\"%s: Directory has been renamed from %s\"),\n\t\t\tquotearg_colon (name_buffer),\n\t\t\tquote_n (1, d->name)));\n\t      directory->orig = d;\n\t      DIR_SET_FLAG (directory, DIRF_RENAMED);\n\t      dirlist_replace_prefix (d->name, name_buffer);\n\t    }\n\t  directory->children = CHANGED_CHILDREN;\n\t}\n      else\n\t{\n\t  DIR_SET_FLAG (directory, DIRF_NEW);\n\t  WARNOPT (WARN_NEW_DIRECTORY,\n\t\t   (0, 0, _(\"%s: Directory is new\"),\n\t\t    quotearg_colon (name_buffer)));\n\t  directory->children =\n\t    (listed_incremental_option\n\t     || (OLDER_STAT_TIME (*stat_data, m)\n\t\t || (after_date_option\n\t\t     && OLDER_STAT_TIME (*stat_data, c))))\n\t    ? ALL_CHILDREN\n\t    : CHANGED_CHILDREN;\n\t}\n    }\n\n  if (one_file_system_option && st->parent\n      && stat_data->st_dev != st->parent->stat.st_dev)\n    {\n      WARNOPT (WARN_XDEV,\n\t       (0, 0,\n\t\t_(\"%s: directory is on a different filesystem; not dumped\"),\n\t\tquotearg_colon (directory->name)));\n      directory->children = NO_CHILDREN;\n      /* If there is any dumpdir info in that directory, remove it */\n      if (directory->dump)\n\t{\n\t  dumpdir_free (directory->dump);\n\t  directory->dump = NULL;\n\t}\n      perhaps_renamed = false;\n    }\n\n  else if (flag & PD_FORCE_CHILDREN)\n    {\n      directory->children = PD_CHILDREN(flag);\n      if (directory->children == NO_CHILDREN)\n\t*entry = 'N';\n    }\n\n  if (perhaps_renamed)\n    WARNOPT (WARN_RENAME_DIRECTORY,\n\t     (0, 0, _(\"%s: Directory has been renamed\"),\n\t      quotearg_colon (name_buffer)));\n\n  DIR_SET_FLAG (directory, DIRF_INIT);\n\n  if (directory->children != NO_CHILDREN)\n    {\n      const char *tag_file_name;\n\n      switch (check_exclusion_tags (st, &tag_file_name))\n\t{\n\tcase exclusion_tag_all:\n\t  /* This warning can be duplicated by code in dump_file0, but only\n\t     in case when the topmost directory being archived contains\n\t     an exclusion tag. */\n\t  exclusion_tag_warning (name_buffer, tag_file_name,\n\t\t\t\t _(\"directory not dumped\"));\n\t  *entry = 'N';\n\t  directory->children = NO_CHILDREN;\n\t  break;\n\n\tcase exclusion_tag_contents:\n\t  exclusion_tag_warning (name_buffer, tag_file_name,\n\t\t\t\t _(\"contents not dumped\"));\n\t  directory->children = NO_CHILDREN;\n\t  directory->tagfile = tag_file_name;\n\t  break;\n\n\tcase exclusion_tag_under:\n\t  exclusion_tag_warning (name_buffer, tag_file_name,\n\t\t\t\t _(\"contents not dumped\"));\n\t  directory->tagfile = tag_file_name;\n\t  break;\n\n\tcase exclusion_tag_none:\n\t  break;\n\t}\n    }\n\n  return directory;\n}",
      "lines": 186,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "struct directory",
        "struct",
        "directory",
        "*\nprocdir (const char *name_buffer, struct tar_stat_info *st,\n\t int flag,\n\t char *entry)",
        "*"
      ]
    },
    "makedumpdir": {
      "start_point": [
        639,
        0
      ],
      "end_point": [
        702,
        1
      ],
      "content": "static void\nmakedumpdir (struct directory *directory, const char *dir)\n{\n  size_t i,\n         dirsize,  /* Number of elements in DIR */\n         len;      /* Length of DIR, including terminating nul */\n  const char *p;\n  char const **array;\n  char *new_dump, *new_dump_ptr;\n  struct dumpdir *dump;\n\n  if (directory->children == ALL_CHILDREN)\n    dump = NULL;\n  else if (DIR_IS_RENAMED (directory))\n    dump = directory->orig->idump ?\n           directory->orig->idump : directory->orig->dump;\n  else\n    dump = directory->dump;\n\n  /* Count the size of DIR and the number of elements it contains */\n  dirsize = 0;\n  len = 0;\n  for (p = dir; *p; p += strlen (p) + 1, dirsize++)\n    len += strlen (p) + 2;\n  len++;\n\n  /* Create a sorted directory listing */\n  array = xcalloc (dirsize, sizeof array[0]);\n  for (i = 0, p = dir; *p; p += strlen (p) + 1, i++)\n    array[i] = p;\n\n  qsort (array, dirsize, sizeof (array[0]), compare_dirnames);\n\n  /* Prepare space for new dumpdir */\n  new_dump = xmalloc (len);\n  new_dump_ptr = new_dump;\n\n  /* Fill in the dumpdir template */\n  for (i = 0; i < dirsize; i++)\n    {\n      const char *loc = dumpdir_locate (dump, array[i]);\n      if (loc)\n\t{\n\t  if (directory->tagfile)\n\t    *new_dump_ptr = 'I';\n\t  else\n\t    *new_dump_ptr = ' ';\n\t  new_dump_ptr++;\n\t}\n      else if (directory->tagfile)\n\t*new_dump_ptr++ = 'I';\n      else\n\t*new_dump_ptr++ = 'Y'; /* New entry */\n\n      /* Copy the file name */\n      for (p = array[i]; (*new_dump_ptr++ = *p++); )\n\t;\n    }\n  *new_dump_ptr = 0;\n  directory->idump = directory->dump;\n  directory->dump = dumpdir_create0 (new_dump, NULL);\n  free (new_dump);\n  free (array);\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "maketagdumpdir": {
      "start_point": [
        706,
        0
      ],
      "end_point": [
        718,
        1
      ],
      "content": "static void\nmaketagdumpdir (struct directory *directory)\n{\n  size_t len = strlen (directory->tagfile) + 1;\n  char *new_dump = xmalloc (len + 2);\n  new_dump[0] = 'Y';\n  memcpy (new_dump + 1, directory->tagfile, len);\n  new_dump[len + 1] = 0;\n\n  directory->idump = directory->dump;\n  directory->dump = dumpdir_create0 (new_dump, NULL);\n  free (new_dump);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "scan_directory": {
      "start_point": [
        721,
        0
      ],
      "end_point": [
        842,
        1
      ],
      "content": "struct directory *\nscan_directory (struct tar_stat_info *st)\n{\n  char const *dir = st->orig_file_name;\n  char *dirp = get_directory_entries (st);\n  dev_t device = st->stat.st_dev;\n  bool cmdline = ! st->parent;\n  namebuf_t nbuf;\n  char *tmp;\n  struct directory *directory;\n  char ch;\n\n  if (! dirp)\n    savedir_error (dir);\n\n  info_attach_exclist (st);\n\n  tmp = xstrdup (dir);\n  zap_slashes (tmp);\n\n  directory = procdir (tmp, st,\n\t\t       (cmdline ? PD_FORCE_INIT : 0),\n\t\t       &ch);\n\n  free (tmp);\n\n  nbuf = namebuf_create (dir);\n\n  if (dirp)\n    {\n      if (directory->children != NO_CHILDREN)\n\t{\n\t  char *entry;\t/* directory entry being scanned */\n\t  struct dumpdir_iter *itr;\n\n\t  makedumpdir (directory, dirp);\n\n\t  for (entry = dumpdir_first (directory->dump, 1, &itr);\n\t       entry;\n\t       entry = dumpdir_next (itr))\n\t    {\n\t      char *full_name = namebuf_name (nbuf, entry + 1);\n\n\t      if (*entry == 'I') /* Ignored entry */\n\t\t*entry = 'N';\n\t      else if (excluded_name (full_name, st))\n\t\t*entry = 'N';\n\t      else\n\t\t{\n\t\t  int fd = st->fd;\n\t\t  void (*diag) (char const *) = 0;\n\t\t  struct tar_stat_info stsub;\n\t\t  tar_stat_init (&stsub);\n\n\t\t  if (fd < 0)\n\t\t    {\n\t\t      errno = - fd;\n\t\t      diag = open_diag;\n\t\t    }\n\t\t  else if (fstatat (fd, entry + 1, &stsub.stat,\n\t\t\t\t    fstatat_flags) != 0)\n\t\t    diag = stat_diag;\n\t\t  else if (S_ISDIR (stsub.stat.st_mode))\n\t\t    {\n\t\t      int subfd = subfile_open (st, entry + 1,\n\t\t\t\t\t\topen_read_flags);\n\t\t      if (subfd < 0)\n\t\t\tdiag = open_diag;\n\t\t      else\n\t\t\t{\n\t\t\t  stsub.fd = subfd;\n\t\t\t  if (fstat (subfd, &stsub.stat) != 0)\n\t\t\t    diag = stat_diag;\n\t\t\t}\n\t\t    }\n\n\t\t  if (diag)\n\t\t    {\n\t\t      file_removed_diag (full_name, false, diag);\n\t\t      *entry = 'N';\n\t\t    }\n\t\t  else if (S_ISDIR (stsub.stat.st_mode))\n\t\t    {\n\t\t      int pd_flag = 0;\n\t\t      if (!recursion_option)\n\t\t\tpd_flag |= PD_FORCE_CHILDREN | NO_CHILDREN;\n\t\t      else if (directory->children == ALL_CHILDREN)\n\t\t\tpd_flag |= PD_FORCE_CHILDREN | ALL_CHILDREN;\n\t\t      *entry = 'D';\n\n\t\t      stsub.parent = st;\n\t\t      procdir (full_name, &stsub, pd_flag, entry);\n\t\t      restore_parent_fd (&stsub);\n\t\t    }\n\t\t  else if (one_file_system_option &&\n\t\t\t   device != stsub.stat.st_dev)\n\t\t    *entry = 'N';\n\t\t  else if (*entry == 'Y')\n\t\t    /* New entry, skip further checks */;\n\t\t  /* FIXME: if (S_ISHIDDEN (stat_data.st_mode))?? */\n\t\t  else if (OLDER_STAT_TIME (stsub.stat, m)\n\t\t\t   && (!after_date_option\n\t\t\t       || OLDER_STAT_TIME (stsub.stat, c)))\n\t\t    *entry = 'N';\n\t\t  else\n\t\t    *entry = 'Y';\n\n\t\t  tar_stat_destroy (&stsub);\n\t\t}\n\t    }\n\t  free (itr);\n\t}\n      else if (directory->tagfile)\n\tmaketagdumpdir (directory);\n    }\n\n  namebuf_free (nbuf);\n\n  free (dirp);\n\n  return directory;\n}",
      "lines": 122,
      "depth": 25,
      "decorators": [
        "struct directory",
        "struct",
        "directory",
        "*\nscan_directory (struct tar_stat_info *st)",
        "*"
      ]
    },
    "directory_contents": {
      "start_point": [
        845,
        0
      ],
      "end_point": [
        851,
        1
      ],
      "content": "const char *\ndirectory_contents (struct directory *dir)\n{\n  if (!dir)\n    return NULL;\n  return dir->dump ? dir->dump->contents : NULL;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ndirectory_contents (struct directory *dir)",
        "*"
      ]
    },
    "safe_directory_contents": {
      "start_point": [
        854,
        0
      ],
      "end_point": [
        859,
        1
      ],
      "content": "const char *\nsafe_directory_contents (struct directory *dir)\n{\n  const char *ret = directory_contents (dir);\n  return ret ? ret : \"\\0\\0\\0\\0\";\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nsafe_directory_contents (struct directory *dir)",
        "*"
      ]
    },
    "obstack_code_rename": {
      "start_point": [
        862,
        0
      ],
      "end_point": [
        876,
        1
      ],
      "content": "static void\nobstack_code_rename (struct obstack *stk, char const *from, char const *to)\n{\n  char const *s;\n\n  s = from[0] == 0 ? from :\n                     safer_name_suffix (from, false, absolute_names_option);\n  obstack_1grow (stk, 'R');\n  obstack_grow (stk, s, strlen (s) + 1);\n\n  s = to[0] == 0 ? to:\n                   safer_name_suffix (to, false, absolute_names_option);\n  obstack_1grow (stk, 'T');\n  obstack_grow (stk, s, strlen (s) + 1);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "store_rename": {
      "start_point": [
        878,
        0
      ],
      "end_point": [
        919,
        1
      ],
      "content": "static void\nstore_rename (struct directory *dir, struct obstack *stk)\n{\n  if (DIR_IS_RENAMED (dir))\n    {\n      struct directory *prev, *p;\n\n      /* Detect eventual cycles and clear DIRF_RENAMED flag, so these entries\n\t are ignored when hit by this function next time.\n\t If the chain forms a cycle, prev points to the entry DIR is renamed\n\t from. In this case it still retains DIRF_RENAMED flag, which will be\n\t cleared in the 'else' branch below */\n      for (prev = dir; prev && prev->orig != dir; prev = prev->orig)\n\tDIR_CLEAR_FLAG (prev, DIRF_RENAMED);\n\n      if (prev == NULL)\n\t{\n\t  for (p = dir; p && p->orig; p = p->orig)\n\t    obstack_code_rename (stk, p->orig->name, p->name);\n\t}\n      else\n\t{\n\t  char *temp_name;\n\n\t  DIR_CLEAR_FLAG (prev, DIRF_RENAMED);\n\n\t  /* Break the cycle by using a temporary name for one of its\n\t     elements.\n\t     First, create a temp name stub entry. */\n\t  temp_name = dir_name (dir->name);\n\t  obstack_1grow (stk, 'X');\n\t  obstack_grow (stk, temp_name, strlen (temp_name) + 1);\n\n\t  obstack_code_rename (stk, dir->name, \"\");\n\n\t  for (p = dir; p != prev; p = p->orig)\n\t    obstack_code_rename (stk, p->orig->name, p->name);\n\n\t  obstack_code_rename (stk, \"\", prev->name);\n\t}\n    }\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "append_incremental_renames": {
      "start_point": [
        921,
        0
      ],
      "end_point": [
        953,
        1
      ],
      "content": "void\nappend_incremental_renames (struct directory *dir)\n{\n  struct obstack stk;\n  size_t size;\n  struct directory *dp;\n  const char *dump;\n\n  if (dirhead == NULL)\n    return;\n\n  obstack_init (&stk);\n  dump = directory_contents (dir);\n  if (dump)\n    {\n      size = dumpdir_size (dump) - 1;\n      obstack_grow (&stk, dump, size);\n    }\n  else\n    size = 0;\n\n  for (dp = dirhead; dp; dp = dp->next)\n    store_rename (dp, &stk);\n\n  /* FIXME: Is this the right thing to do when DIR is null?  */\n  if (dir && obstack_object_size (&stk) != size)\n    {\n      obstack_1grow (&stk, 0);\n      dumpdir_free (dir->dump);\n      dir->dump = dumpdir_create (obstack_finish (&stk));\n    }\n  obstack_free (&stk, NULL);\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "read_incr_db_01": {
      "start_point": [
        970,
        0
      ],
      "end_point": [
        1087,
        1
      ],
      "content": "static void\nread_incr_db_01 (int version, const char *initbuf)\n{\n  int n;\n  uintmax_t u;\n  char *buf = NULL;\n  size_t bufsize = 0;\n  char *ebuf;\n  long lineno = 1;\n\n  if (version == 1)\n    {\n      if (getline (&buf, &bufsize, listed_incremental_stream) <= 0)\n\t{\n\t  read_error (listed_incremental_option);\n\t  free (buf);\n\t  return;\n\t}\n      ++lineno;\n    }\n  else\n    {\n      buf = strdup (initbuf);\n      bufsize = strlen (buf) + 1;\n    }\n\n  newer_mtime_option = decode_timespec (buf, &ebuf, false);\n\n  if (! valid_timespec (newer_mtime_option))\n    ERROR ((0, errno, \"%s:%ld: %s\",\n\t    quotearg_colon (listed_incremental_option),\n\t    lineno,\n\t    _(\"Invalid time stamp\")));\n  else\n    {\n      if (version == 1 && *ebuf)\n\t{\n\t  char const *buf_ns = ebuf + 1;\n\t  errno = 0;\n\t  u = strtoumax (buf_ns, &ebuf, 10);\n\t  if (!errno && BILLION <= u)\n\t    errno = ERANGE;\n\t  if (errno || buf_ns == ebuf)\n\t    {\n\t      ERROR ((0, errno, \"%s:%ld: %s\",\n\t\t      quotearg_colon (listed_incremental_option),\n\t\t      lineno,\n\t\t      _(\"Invalid time stamp\")));\n\t      newer_mtime_option.tv_sec = TYPE_MINIMUM (time_t);\n\t      newer_mtime_option.tv_nsec = -1;\n\t    }\n\t  else\n\t    newer_mtime_option.tv_nsec = u;\n\t}\n    }\n\n  while (0 < (n = getline (&buf, &bufsize, listed_incremental_stream)))\n    {\n      dev_t dev;\n      ino_t ino;\n      bool nfs = buf[0] == '+';\n      char *strp = buf + nfs;\n      struct timespec mtime;\n\n      lineno++;\n\n      if (buf[n - 1] == '\\n')\n\tbuf[n - 1] = '\\0';\n\n      if (version == 1)\n\t{\n\t  mtime = decode_timespec (strp, &ebuf, false);\n\t  strp = ebuf;\n\t  if (!valid_timespec (mtime) || *strp != ' ')\n\t    ERROR ((0, errno, \"%s:%ld: %s\",\n\t\t    quotearg_colon (listed_incremental_option), lineno,\n\t\t    _(\"Invalid modification time\")));\n\n\t  errno = 0;\n\t  u = strtoumax (strp, &ebuf, 10);\n\t  if (!errno && BILLION <= u)\n\t    errno = ERANGE;\n\t  if (errno || strp == ebuf || *ebuf != ' ')\n\t    {\n\t      ERROR ((0, errno, \"%s:%ld: %s\",\n\t\t      quotearg_colon (listed_incremental_option), lineno,\n\t\t      _(\"Invalid modification time (nanoseconds)\")));\n\t      mtime.tv_nsec = -1;\n\t    }\n\t  else\n\t    mtime.tv_nsec = u;\n\t  strp = ebuf;\n\t}\n      else\n\tmtime.tv_sec = mtime.tv_nsec = 0;\n\n      dev = strtosysint (strp, &ebuf,\n\t\t\t TYPE_MINIMUM (dev_t), TYPE_MAXIMUM (dev_t));\n      strp = ebuf;\n      if (errno || *strp != ' ')\n\tERROR ((0, errno, \"%s:%ld: %s\",\n\t\tquotearg_colon (listed_incremental_option), lineno,\n\t\t_(\"Invalid device number\")));\n\n      ino = strtosysint (strp, &ebuf,\n\t\t\t TYPE_MINIMUM (ino_t), TYPE_MAXIMUM (ino_t));\n      strp = ebuf;\n      if (errno || *strp != ' ')\n\tERROR ((0, errno, \"%s:%ld: %s\",\n\t\tquotearg_colon (listed_incremental_option), lineno,\n\t\t_(\"Invalid inode number\")));\n\n      strp++;\n      unquote_string (strp);\n      note_directory (strp, mtime, dev, ino, nfs, false, NULL);\n    }\n  free (buf);\n}",
      "lines": 118,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_obstack": {
      "start_point": [
        1093,
        0
      ],
      "end_point": [
        1105,
        1
      ],
      "content": "static int\nread_obstack (FILE *fp, struct obstack *stk, size_t *pcount)\n{\n  int c;\n  size_t i;\n\n  for (i = 0, c = getc (fp); c != EOF && c != 0; c = getc (fp), i++)\n    obstack_1grow (stk, c);\n  obstack_1grow (stk, 0);\n\n  *pcount = i;\n  return c;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_num": {
      "start_point": [
        1118,
        0
      ],
      "end_point": [
        1188,
        1
      ],
      "content": "static bool\nread_num (FILE *fp, char const *fieldname,\n\t  intmax_t min_val, uintmax_t max_val, intmax_t *pval)\n{\n  int i;\n  char buf[INT_BUFSIZE_BOUND (intmax_t)];\n  char offbuf[INT_BUFSIZE_BOUND (off_t)];\n  char minbuf[INT_BUFSIZE_BOUND (intmax_t)];\n  char maxbuf[INT_BUFSIZE_BOUND (intmax_t)];\n  int conversion_errno;\n  int c = getc (fp);\n  bool negative = c == '-';\n\n  for (i = 0; (i == 0 && negative) || ISDIGIT (c); i++)\n    {\n      buf[i] = c;\n      if (i == sizeof buf - 1)\n\tFATAL_ERROR ((0, 0,\n\t\t      _(\"%s: byte %s: %s %.*s... too long\"),\n\t\t      quotearg_colon (listed_incremental_option),\n\t\t      offtostr (ftello (fp), offbuf),\n\t\t      fieldname, i + 1, buf));\n      c = getc (fp);\n    }\n\n  buf[i] = 0;\n\n  if (c < 0)\n    {\n      if (ferror (fp))\n\tread_fatal (listed_incremental_option);\n      if (i != 0)\n\tFATAL_ERROR ((0, 0, \"%s: %s\",\n\t\t      quotearg_colon (listed_incremental_option),\n\t\t      _(\"Unexpected EOF in snapshot file\")));\n      return false;\n    }\n\n  if (c)\n    {\n      unsigned uc = c;\n      FATAL_ERROR ((0, 0,\n\t\t    _(\"%s: byte %s: %s %s followed by invalid byte 0x%02x\"),\n\t\t    quotearg_colon (listed_incremental_option),\n\t\t    offtostr (ftello (fp), offbuf),\n\t\t    fieldname, buf, uc));\n    }\n\n  *pval = strtosysint (buf, NULL, min_val, max_val);\n  conversion_errno = errno;\n\n  switch (conversion_errno)\n    {\n    case ERANGE:\n      FATAL_ERROR ((0, conversion_errno,\n\t\t    _(\"%s: byte %s: (valid range %s..%s)\\n\\t%s %s\"),\n\t\t    quotearg_colon (listed_incremental_option),\n\t\t    offtostr (ftello (fp), offbuf),\n\t\t    imaxtostr (min_val, minbuf),\n\t\t    umaxtostr (max_val, maxbuf), fieldname, buf));\n    default:\n      FATAL_ERROR ((0, conversion_errno,\n\t\t    _(\"%s: byte %s: %s %s\"),\n\t\t    quotearg_colon (listed_incremental_option),\n\t\t    offtostr (ftello (fp), offbuf), fieldname, buf));\n    case 0:\n      break;\n    }\n\n  return true;\n}",
      "lines": 71,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "read_timespec": {
      "start_point": [
        1195,
        0
      ],
      "end_point": [
        1212,
        1
      ],
      "content": "static void\nread_timespec (FILE *fp, struct timespec *pval)\n{\n  intmax_t s, ns;\n\n  if (read_num (fp, \"sec\", TYPE_MINIMUM (time_t), TYPE_MAXIMUM (time_t), &s)\n      && read_num (fp, \"nsec\", 0, BILLION - 1, &ns))\n    {\n      pval->tv_sec = s;\n      pval->tv_nsec = ns;\n    }\n  else\n    {\n      FATAL_ERROR ((0, 0, \"%s: %s\",\n\t\t    quotearg_colon (listed_incremental_option),\n\t\t    _(\"Unexpected EOF in snapshot file\")));\n    }\n}",
      "lines": 18,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_incr_db_2": {
      "start_point": [
        1215,
        0
      ],
      "end_point": [
        1273,
        1
      ],
      "content": "static void\nread_incr_db_2 (void)\n{\n  struct obstack stk;\n  char offbuf[INT_BUFSIZE_BOUND (off_t)];\n\n  obstack_init (&stk);\n\n  read_timespec (listed_incremental_stream, &newer_mtime_option);\n\n  for (;;)\n    {\n      intmax_t i;\n      struct timespec mtime;\n      dev_t dev;\n      ino_t ino;\n      bool nfs;\n      char *name;\n      char *content;\n      size_t s;\n\n      if (! read_num (listed_incremental_stream, \"nfs\", 0, 1, &i))\n\treturn; /* Normal return */\n\n      nfs = i;\n\n      read_timespec (listed_incremental_stream, &mtime);\n\n      if (! read_num (listed_incremental_stream, \"dev\",\n\t\t      TYPE_MINIMUM (dev_t), TYPE_MAXIMUM (dev_t), &i))\n\tbreak;\n      dev = i;\n\n      if (! read_num (listed_incremental_stream, \"ino\",\n\t\t      TYPE_MINIMUM (ino_t), TYPE_MAXIMUM (ino_t), &i))\n\tbreak;\n      ino = i;\n\n      if (read_obstack (listed_incremental_stream, &stk, &s))\n\tbreak;\n\n      name = obstack_finish (&stk);\n\n      while (read_obstack (listed_incremental_stream, &stk, &s) == 0 && s > 1)\n\t;\n      if (getc (listed_incremental_stream) != 0)\n\tFATAL_ERROR ((0, 0, _(\"%s: byte %s: %s\"),\n\t\t      quotearg_colon (listed_incremental_option),\n\t\t      offtostr (ftello (listed_incremental_stream), offbuf),\n\t\t      _(\"Missing record terminator\")));\n\n      content = obstack_finish (&stk);\n      note_directory (name, mtime, dev, ino, nfs, false, content);\n      obstack_free (&stk, content);\n    }\n  FATAL_ERROR ((0, 0, \"%s: %s\",\n\t\tquotearg_colon (listed_incremental_option),\n\t\t_(\"Unexpected EOF in snapshot file\")));\n}",
      "lines": 59,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "show_snapshot_field_ranges": {
      "start_point": [
        1299,
        0
      ],
      "end_point": [
        1318,
        1
      ],
      "content": "void\nshow_snapshot_field_ranges (void)\n{\n  struct field_range const *p;\n  char minbuf[SYSINT_BUFSIZE];\n  char maxbuf[SYSINT_BUFSIZE];\n\n  printf(\"This tar's snapshot file field ranges are\\n\");\n  printf (\"   (%-15s => [ %s, %s ]):\\n\\n\", \"field name\", \"min\", \"max\");\n\n  for (p=field_ranges; p->fieldname != NULL; p++)\n    {\n      printf (\"    %-15s => [ %s, %s ],\\n\", p->fieldname,\n\t      sysinttostr (p->min_val, p->min_val, p->max_val, minbuf),\n\t      sysinttostr (p->max_val, p->min_val, p->max_val, maxbuf));\n\n    }\n\n  printf(\"\\n\");\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "read_directory_file": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1401,
        1
      ],
      "content": "void\nread_directory_file (void)\n{\n  int fd;\n  char *buf = NULL;\n  size_t bufsize = 0;\n  int flags = O_RDWR | O_CREAT;\n\n  if (incremental_level == 0)\n    flags |= O_TRUNC;\n  /* Open the file for both read and write.  That way, we can write\n     it later without having to reopen it, and don't have to worry if\n     we chdir in the meantime.  */\n  fd = open (listed_incremental_option, flags, MODE_RW);\n  if (fd < 0)\n    {\n      open_error (listed_incremental_option);\n      return;\n    }\n\n  listed_incremental_stream = fdopen (fd, \"r+\");\n  if (! listed_incremental_stream)\n    {\n      open_error (listed_incremental_option);\n      close (fd);\n      return;\n    }\n\n  /* Consume the first name from the name list and reset the\n     list afterwards.  This is done to change to the new\n     directory, if the first name is a chdir request (-C dir),\n     which is necessary to recreate absolute file names. */\n  name_from_list ();\n  blank_name_list ();\n\n  if (0 < getline (&buf, &bufsize, listed_incremental_stream))\n    {\n      char *ebuf;\n      uintmax_t incremental_version;\n\n      if (strncmp (buf, PACKAGE_NAME, sizeof PACKAGE_NAME - 1) == 0)\n\t{\n\t  ebuf = buf + sizeof PACKAGE_NAME - 1;\n\t  if (*ebuf++ != '-')\n\t    ERROR((1, 0, _(\"Bad incremental file format\")));\n\t  for (; *ebuf != '-'; ebuf++)\n\t    if (!*ebuf)\n\t      ERROR((1, 0, _(\"Bad incremental file format\")));\n\n\t  incremental_version = strtoumax (ebuf + 1, NULL, 10);\n\t}\n      else\n\tincremental_version = 0;\n\n      switch (incremental_version)\n\t{\n\tcase 0:\n\tcase 1:\n\t  read_incr_db_01 (incremental_version, buf);\n\t  break;\n\n\tcase TAR_INCREMENTAL_VERSION:\n\t  read_incr_db_2 ();\n\t  break;\n\n\tdefault:\n\t  ERROR ((1, 0, _(\"Unsupported incremental format version: %\"PRIuMAX),\n\t\t  incremental_version));\n\t}\n\n    }\n\n  if (ferror (listed_incremental_stream))\n    read_error (listed_incremental_option);\n  free (buf);\n}",
      "lines": 76,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "write_directory_file_entry": {
      "start_point": [
        1405,
        0
      ],
      "end_point": [
        1446,
        1
      ],
      "content": "static bool\nwrite_directory_file_entry (void *entry, void *data)\n{\n  struct directory const *directory = entry;\n  FILE *fp = data;\n\n  if (DIR_IS_FOUND (directory))\n    {\n      char buf[SYSINT_BUFSIZE];\n      char const *s;\n\n      s = DIR_IS_NFS (directory) ? \"1\" : \"0\";\n      fwrite (s, 2, 1, fp);\n      s = sysinttostr (directory->mtime.tv_sec, TYPE_MINIMUM (time_t),\n\t\t       TYPE_MAXIMUM (time_t), buf);\n      fwrite (s, strlen (s) + 1, 1, fp);\n      s = imaxtostr (directory->mtime.tv_nsec, buf);\n      fwrite (s, strlen (s) + 1, 1, fp);\n      s = sysinttostr (directory->device_number,\n\t\t       TYPE_MINIMUM (dev_t), TYPE_MAXIMUM (dev_t), buf);\n      fwrite (s, strlen (s) + 1, 1, fp);\n      s = sysinttostr (directory->inode_number,\n\t\t       TYPE_MINIMUM (ino_t), TYPE_MAXIMUM (ino_t), buf);\n      fwrite (s, strlen (s) + 1, 1, fp);\n\n      fwrite (directory->name, strlen (directory->name) + 1, 1, fp);\n      if (directory->dump)\n\t{\n\t  const char *p;\n\t  struct dumpdir_iter *itr;\n\n\t  for (p = dumpdir_first (directory->dump, 0, &itr);\n\t       p;\n\t       p = dumpdir_next (itr))\n\t    fwrite (p, strlen (p) + 1, 1, fp);\n\t  free (itr);\n\t}\n      fwrite (\"\\0\\0\", 2, 1, fp);\n    }\n\n  return ! ferror (fp);\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "write_directory_file": {
      "start_point": [
        1448,
        0
      ],
      "end_point": [
        1480,
        1
      ],
      "content": "void\nwrite_directory_file (void)\n{\n  FILE *fp = listed_incremental_stream;\n  char buf[UINTMAX_STRSIZE_BOUND];\n  char *s;\n\n  if (! fp)\n    return;\n\n  if (fseeko (fp, 0L, SEEK_SET) != 0)\n    seek_error (listed_incremental_option);\n  if (sys_truncate (fileno (fp)) != 0)\n    truncate_error (listed_incremental_option);\n\n  fprintf (fp, \"%s-%s-%d\\n\", PACKAGE_NAME, PACKAGE_VERSION,\n\t   TAR_INCREMENTAL_VERSION);\n\n  s = (TYPE_SIGNED (time_t)\n       ? imaxtostr (start_time.tv_sec, buf)\n       : umaxtostr (start_time.tv_sec, buf));\n  fwrite (s, strlen (s) + 1, 1, fp);\n  s = umaxtostr (start_time.tv_nsec, buf);\n  fwrite (s, strlen (s) + 1, 1, fp);\n\n  if (! ferror (fp) && directory_table)\n    hash_do_for_each (directory_table, write_directory_file_entry, fp);\n\n  if (ferror (fp))\n    write_error (listed_incremental_option);\n  if (fclose (fp) != 0)\n    close_error (listed_incremental_option);\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "get_gnu_dumpdir": {
      "start_point": [
        1485,
        0
      ],
      "end_point": [
        1522,
        1
      ],
      "content": "static void\nget_gnu_dumpdir (struct tar_stat_info *stat_info)\n{\n  size_t size;\n  size_t copied;\n  union block *data_block;\n  char *to;\n  char *archive_dir;\n\n  size = stat_info->stat.st_size;\n\n  archive_dir = xmalloc (size);\n  to = archive_dir;\n\n  set_next_block_after (current_header);\n  mv_begin_read (stat_info);\n\n  for (; size > 0; size -= copied)\n    {\n      mv_size_left (size);\n      data_block = find_next_block ();\n      if (!data_block)\n\tERROR ((1, 0, _(\"Unexpected EOF in archive\")));\n      copied = available_space_after (data_block);\n      if (copied > size)\n\tcopied = size;\n      memcpy (to, data_block->buffer, copied);\n      to += copied;\n      set_next_block_after ((union block *)\n\t\t\t    (data_block->buffer + copied - 1));\n    }\n\n  mv_end ();\n\n  stat_info->dumpdir = archive_dir;\n  stat_info->skipped = true; /* For skip_member() and friends\n\t\t\t\tto work correctly */\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_dumpdir": {
      "start_point": [
        1527,
        0
      ],
      "end_point": [
        1533,
        1
      ],
      "content": "bool\nis_dumpdir (struct tar_stat_info *stat_info)\n{\n  if (stat_info->is_dumpdir && !stat_info->dumpdir)\n    get_gnu_dumpdir (stat_info);\n  return stat_info->is_dumpdir;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "dumpdir_ok": {
      "start_point": [
        1535,
        0
      ],
      "end_point": [
        1620,
        1
      ],
      "content": "static bool\ndumpdir_ok (char *dumpdir)\n{\n  char *p;\n  int has_tempdir = 0;\n  int expect = 0;\n\n  for (p = dumpdir; *p; p += strlen (p) + 1)\n    {\n      if (expect && *p != expect)\n\t{\n\t  unsigned char uc = *p;\n\t  ERROR ((0, 0,\n\t\t  _(\"Malformed dumpdir: expected '%c' but found %#3o\"),\n\t\t  expect, uc));\n\t  return false;\n\t}\n      switch (*p)\n\t{\n\tcase 'X':\n\t  if (has_tempdir)\n\t    {\n\t      ERROR ((0, 0,\n\t\t      _(\"Malformed dumpdir: 'X' duplicated\")));\n\t      return false;\n\t    }\n\t  else\n\t    has_tempdir = 1;\n\t  break;\n\n\tcase 'R':\n\t  if (p[1] == 0)\n\t    {\n\t      if (!has_tempdir)\n\t\t{\n\t\t  ERROR ((0, 0,\n\t\t\t  _(\"Malformed dumpdir: empty name in 'R'\")));\n\t\t  return false;\n\t\t}\n\t      else\n\t\thas_tempdir = 0;\n\t    }\n\t  expect = 'T';\n\t  break;\n\n\tcase 'T':\n\t  if (expect != 'T')\n\t    {\n\t      ERROR ((0, 0,\n\t\t      _(\"Malformed dumpdir: 'T' not preceded by 'R'\")));\n\t      return false;\n\t    }\n\t  if (p[1] == 0 && !has_tempdir)\n\t    {\n\t      ERROR ((0, 0,\n\t\t      _(\"Malformed dumpdir: empty name in 'T'\")));\n\t      return false;\n\t    }\n\t  expect = 0;\n\t  break;\n\n\tcase 'N':\n\tcase 'Y':\n\tcase 'D':\n\t  break;\n\n\tdefault:\n\t  /* FIXME: bail out? */\n\t  break;\n\t}\n    }\n\n  if (expect)\n    {\n      ERROR ((0, 0,\n\t      _(\"Malformed dumpdir: expected '%c' but found end of data\"),\n\t      expect));\n      return false;\n    }\n\n  if (has_tempdir)\n    WARNOPT (WARN_BAD_DUMPDIR,\n\t     (0, 0, _(\"Malformed dumpdir: 'X' never used\")));\n\n  return true;\n}",
      "lines": 86,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "try_purge_directory": {
      "start_point": [
        1624,
        0
      ],
      "end_point": [
        1758,
        1
      ],
      "content": "static bool\ntry_purge_directory (char const *directory_name)\n{\n  char *current_dir;\n  char *cur, *arc, *p;\n  char *temp_stub = NULL;\n  struct dumpdir *dump;\n\n  if (!is_dumpdir (&current_stat_info))\n    return false;\n\n  current_dir = tar_savedir (directory_name, 0);\n\n  if (!current_dir)\n    /* The directory doesn't exist now.  It'll be created.  In any\n       case, we don't have to delete any files out of it.  */\n    return false;\n\n  /* Verify if dump directory is sane */\n  if (!dumpdir_ok (current_stat_info.dumpdir))\n    return false;\n\n  /* Process renames */\n  for (arc = current_stat_info.dumpdir; *arc; arc += strlen (arc) + 1)\n    {\n      if (*arc == 'X')\n\t{\n#define TEMP_DIR_TEMPLATE \"tar.XXXXXX\"\n\t  size_t len = strlen (arc + 1);\n\t  temp_stub = xrealloc (temp_stub, len + 1 + sizeof TEMP_DIR_TEMPLATE);\n\t  memcpy (temp_stub, arc + 1, len);\n\t  temp_stub[len] = '/';\n\t  memcpy (temp_stub + len + 1, TEMP_DIR_TEMPLATE,\n\t\t  sizeof TEMP_DIR_TEMPLATE);\n\t  if (!mkdtemp (temp_stub))\n\t    {\n\t      ERROR ((0, errno,\n\t\t      _(\"Cannot create temporary directory using template %s\"),\n\t\t      quote (temp_stub)));\n\t      free (temp_stub);\n\t      free (current_dir);\n\t      return false;\n\t    }\n\t}\n      else if (*arc == 'R')\n\t{\n\t  char *src, *dst;\n\t  src = arc + 1;\n\t  arc += strlen (arc) + 1;\n\t  dst = arc + 1;\n\n\t  /* Ensure that neither source nor destination are absolute file\n\t     names (unless permitted by -P option), and that they do not\n\t     contain dubious parts (e.g. ../).\n\n\t     This is an extra safety precaution. Besides, it might be\n\t     necessary to extract from archives created with tar versions\n\t     prior to 1.19. */\n\n\t  if (*src)\n\t    src = safer_name_suffix (src, false, absolute_names_option);\n\t  if (*dst)\n\t    dst = safer_name_suffix (dst, false, absolute_names_option);\n\n\t  if (*src == 0)\n\t    src = temp_stub;\n\t  else if (*dst == 0)\n\t    dst = temp_stub;\n\n\t  if (!rename_directory (src, dst))\n\t    {\n\t      free (temp_stub);\n\t      free (current_dir);\n\t      /* FIXME: Make sure purge_directory(dst) will return\n\t\t immediately */\n\t      return false;\n\t    }\n\t}\n    }\n\n  free (temp_stub);\n\n  /* Process deletes */\n  dump = dumpdir_create (current_stat_info.dumpdir);\n  p = NULL;\n  for (cur = current_dir; *cur; cur += strlen (cur) + 1)\n    {\n      const char *entry;\n      struct stat st;\n      free (p);\n      p = make_file_name (directory_name, cur);\n\n      if (deref_stat (p, &st) != 0)\n\t{\n\t  if (errno != ENOENT) /* FIXME: Maybe keep a list of renamed\n\t\t\t\t  dirs and check it here? */\n\t    {\n\t      stat_diag (p);\n\t      WARN ((0, 0, _(\"%s: Not purging directory: unable to stat\"),\n\t\t     quotearg_colon (p)));\n\t    }\n\t  continue;\n\t}\n\n      if (!(entry = dumpdir_locate (dump, cur))\n\t  || (*entry == 'D' && !S_ISDIR (st.st_mode))\n\t  || (*entry == 'Y' && S_ISDIR (st.st_mode)))\n\t{\n\t  if (one_file_system_option && st.st_dev != root_device)\n\t    {\n\t      WARN ((0, 0,\n\t\t     _(\"%s: directory is on a different device: not purging\"),\n\t\t     quotearg_colon (p)));\n\t      continue;\n\t    }\n\n\t  if (! interactive_option || confirm (\"delete\", p))\n\t    {\n\t      if (verbose_option)\n\t\tfprintf (stdlis, _(\"%s: Deleting %s\\n\"),\n\t\t\t program_name, quote (p));\n\t      if (! remove_any_file (p, RECURSIVE_REMOVE_OPTION))\n\t\t{\n\t\t  int e = errno;\n\t\t  ERROR ((0, e, _(\"%s: Cannot remove\"), quotearg_colon (p)));\n\t\t}\n\t    }\n\t}\n    }\n  free (p);\n  dumpdir_free (dump);\n\n  free (current_dir);\n  return true;\n}",
      "lines": 135,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "purge_directory": {
      "start_point": [
        1760,
        0
      ],
      "end_point": [
        1765,
        1
      ],
      "content": "void\npurge_directory (char const *directory_name)\n{\n  if (!try_purge_directory (directory_name))\n    skip_member ();\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "list_dumpdir": {
      "start_point": [
        1767,
        0
      ],
      "end_point": [
        1804,
        1
      ],
      "content": "void\nlist_dumpdir (char *buffer, size_t size)\n{\n  int state = 0;\n  while (size)\n    {\n      switch (*buffer)\n\t{\n\tcase 'Y':\n\tcase 'N':\n\tcase 'D':\n\tcase 'R':\n\tcase 'T':\n\tcase 'X':\n\t  fprintf (stdlis, \"%c\", *buffer);\n\t  if (state == 0)\n\t    {\n\t      fprintf (stdlis, \" \");\n\t      state = 1;\n\t    }\n\t  buffer++;\n\t  size--;\n\t  break;\n\n\tcase 0:\n\t  fputc ('\\n', stdlis);\n\t  buffer++;\n\t  size--;\n\t  state = 0;\n\t  break;\n\n\tdefault:\n\t  fputc (*buffer, stdlis);\n\t  buffer++;\n\t  size--;\n\t}\n    }\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/list.c": {
    "base64_init": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static void\nbase64_init (void)\n{\n  int i;\n  memset (base64_map, 64, sizeof base64_map);\n  for (i = 0; i < 64; i++)\n    base64_map[(int) base_64_digits[i]] = i;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "decode_xform": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static char *\ndecode_xform (char *file_name, void *data)\n{\n  int type = *(int*)data;\n\n  switch (type)\n    {\n    case XFORM_SYMLINK:\n      /* FIXME: It is not quite clear how and to which extent are the symbolic\n\t links subject to filename transformation.  In the absence of another\n\t solution, symbolic links are exempt from component stripping and\n\t name suffix normalization, but subject to filename transformation\n\t proper. */\n      return file_name;\n\n    case XFORM_LINK:\n      file_name = safer_name_suffix (file_name, true, absolute_names_option);\n      break;\n\n    case XFORM_REGFILE:\n      file_name = safer_name_suffix (file_name, false, absolute_names_option);\n      break;\n    }\n\n  if (strip_name_components)\n    {\n      size_t prefix_len = stripped_prefix_len (file_name,\n\t\t\t\t\t       strip_name_components);\n      if (prefix_len == (size_t) -1)\n\tprefix_len = strlen (file_name);\n      file_name += prefix_len;\n    }\n  return file_name;\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndecode_xform (char *file_name, void *data)",
        "*"
      ]
    },
    "transform_member_name": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static bool\ntransform_member_name (char **pinput, int type)\n{\n  return transform_name_fp (pinput, type, decode_xform, &type);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "enforce_one_top_level": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static void\nenforce_one_top_level (char **pfile_name)\n{\n  char *file_name = *pfile_name;\n  char *p;\n\n  for (p = file_name; *p && (ISSLASH (*p) || *p == '.'); p++)\n    ;\n\n  if (*p)\n    {\n      int pos = strlen (one_top_level_dir);\n      if (strncmp (p, one_top_level_dir, pos) == 0)\n\t{\n\t  if (ISSLASH (p[pos]) || p[pos] == 0)\n\t    return;\n\t}\n\n      *pfile_name = make_file_name (one_top_level_dir, file_name);\n      normalize_filename_x (*pfile_name);\n    }\n  else\n    *pfile_name = xstrdup (one_top_level_dir);\n  free (file_name);\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "transform_stat_info": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "void\ntransform_stat_info (int typeflag, struct tar_stat_info *stat_info)\n{\n  if (typeflag == GNUTYPE_VOLHDR)\n    /* Name transformations don't apply to volume headers. */\n    return;\n\n  transform_member_name (&stat_info->file_name, XFORM_REGFILE);\n  switch (typeflag)\n    {\n    case SYMTYPE:\n      transform_member_name (&stat_info->link_name, XFORM_SYMLINK);\n      break;\n\n    case LNKTYPE:\n      transform_member_name (&stat_info->link_name, XFORM_LINK);\n    }\n\n  if (one_top_level_option)\n    enforce_one_top_level (&current_stat_info.file_name);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "read_and": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "void\nread_and (void (*do_something) (void))\n{\n  enum read_header status = HEADER_STILL_UNREAD;\n  enum read_header prev_status;\n  struct timespec mtime;\n\n  base64_init ();\n  name_gather ();\n\n  open_archive (ACCESS_READ);\n  do\n    {\n      prev_status = status;\n      tar_stat_destroy (&current_stat_info);\n\n      status = read_header (&current_header, &current_stat_info,\n                            read_header_auto);\n      switch (status)\n\t{\n\tcase HEADER_STILL_UNREAD:\n\tcase HEADER_SUCCESS_EXTENDED:\n\t  abort ();\n\n\tcase HEADER_SUCCESS:\n\n\t  /* Valid header.  We should decode next field (mode) first.\n\t     Ensure incoming names are null terminated.  */\n\t  decode_header (current_header, &current_stat_info,\n\t\t\t &current_format, 1);\n\t  if (! name_match (current_stat_info.file_name)\n\t      || (TIME_OPTION_INITIALIZED (newer_mtime_option)\n\t\t  /* FIXME: We get mtime now, and again later; this causes\n\t\t     duplicate diagnostics if header.mtime is bogus.  */\n\t\t  && ((mtime.tv_sec\n\t\t       = TIME_FROM_HEADER (current_header->header.mtime)),\n\t\t      /* FIXME: Grab fractional time stamps from\n\t\t\t extended header.  */\n\t\t      mtime.tv_nsec = 0,\n\t\t      current_stat_info.mtime = mtime,\n\t\t      OLDER_TAR_STAT_TIME (current_stat_info, m)))\n\t      || excluded_name (current_stat_info.file_name,\n\t\t\t\tcurrent_stat_info.parent))\n\t    {\n\t      switch (current_header->header.typeflag)\n\t\t{\n\t\tcase GNUTYPE_VOLHDR:\n\t\tcase GNUTYPE_MULTIVOL:\n\t\t  break;\n\n\t\tcase DIRTYPE:\n\t\t  if (show_omitted_dirs_option)\n\t\t    WARN ((0, 0, _(\"%s: Omitting\"),\n\t\t\t   quotearg_colon (current_stat_info.file_name)));\n\t\t  FALLTHROUGH;\n\t\tdefault:\n\t\t  skip_member ();\n\t\t  continue;\n\t\t}\n\t    }\n\n\t  transform_stat_info (current_header->header.typeflag,\n\t\t\t       &current_stat_info);\n\t  (*do_something) ();\n\t  continue;\n\n\tcase HEADER_ZERO_BLOCK:\n\t  if (block_number_option)\n\t    {\n\t      char buf[UINTMAX_STRSIZE_BOUND];\n\t      fprintf (stdlis, _(\"block %s: ** Block of NULs **\\n\"),\n\t\t       STRINGIFY_BIGINT (current_block_ordinal (), buf));\n\t    }\n\n\t  set_next_block_after (current_header);\n\n\t  if (!ignore_zeros_option)\n\t    {\n\t      char buf[UINTMAX_STRSIZE_BOUND];\n\n\t      status = read_header (&current_header, &current_stat_info,\n\t                            read_header_auto);\n\t      if (status == HEADER_ZERO_BLOCK)\n\t\tbreak;\n\t      WARNOPT (WARN_ALONE_ZERO_BLOCK,\n\t\t       (0, 0, _(\"A lone zero block at %s\"),\n\t\t\tSTRINGIFY_BIGINT (current_block_ordinal (), buf)));\n\t      break;\n\t    }\n\t  status = prev_status;\n\t  continue;\n\n\tcase HEADER_END_OF_FILE:\n\t  if (block_number_option)\n\t    {\n\t      char buf[UINTMAX_STRSIZE_BOUND];\n\t      fprintf (stdlis, _(\"block %s: ** End of File **\\n\"),\n\t\t       STRINGIFY_BIGINT (current_block_ordinal (), buf));\n\t    }\n\t  break;\n\n\tcase HEADER_FAILURE:\n\t  /* If the previous header was good, tell them that we are\n\t     skipping bad ones.  */\n\t  set_next_block_after (current_header);\n\t  switch (prev_status)\n\t    {\n\t    case HEADER_STILL_UNREAD:\n\t      ERROR ((0, 0, _(\"This does not look like a tar archive\")));\n\t      FALLTHROUGH;\n\t    case HEADER_ZERO_BLOCK:\n\t    case HEADER_SUCCESS:\n\t      if (block_number_option)\n\t\t{\n\t\t  char buf[UINTMAX_STRSIZE_BOUND];\n\t\t  off_t block_ordinal = current_block_ordinal ();\n\t\t  block_ordinal -= recent_long_name_blocks;\n\t\t  block_ordinal -= recent_long_link_blocks;\n\t\t  fprintf (stdlis, _(\"block %s: \"),\n\t\t\t   STRINGIFY_BIGINT (block_ordinal, buf));\n\t\t}\n\t      ERROR ((0, 0, _(\"Skipping to next header\")));\n\t      break;\n\n\t    case HEADER_END_OF_FILE:\n\t    case HEADER_FAILURE:\n\t      /* We are in the middle of a cascade of errors.  */\n\t      break;\n\n\t    case HEADER_SUCCESS_EXTENDED:\n\t      abort ();\n\t    }\n\t  continue;\n\t}\n      break;\n    }\n  while (!all_names_found (&current_stat_info));\n\n  close_archive ();\n  names_notfound ();\t\t/* print names not found */\n}",
      "lines": 141,
      "depth": 24,
      "decorators": [
        "void"
      ]
    },
    "list_archive": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "void\nlist_archive (void)\n{\n  off_t block_ordinal = current_block_ordinal ();\n\n  /* Print the header block.  */\n  if (verbose_option)\n    print_header (&current_stat_info, current_header, block_ordinal);\n\n  if (incremental_option)\n    {\n      if (verbose_option > 2)\n\t{\n\t  if (is_dumpdir (&current_stat_info))\n\t    list_dumpdir (current_stat_info.dumpdir,\n\t\t\t  dumpdir_size (current_stat_info.dumpdir));\n\t}\n    }\n\n  skip_member ();\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "tar_checksum": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "enum read_header\ntar_checksum (union block *header, bool silent)\n{\n  size_t i;\n  int unsigned_sum = 0;\t\t/* the POSIX one :-) */\n  int signed_sum = 0;\t\t/* the Sun one :-( */\n  int recorded_sum;\n  int parsed_sum;\n  char *p;\n\n  p = header->buffer;\n  for (i = sizeof *header; i-- != 0;)\n    {\n      unsigned_sum += (unsigned char) *p;\n      signed_sum += (signed char) (*p++);\n    }\n\n  if (unsigned_sum == 0)\n    return HEADER_ZERO_BLOCK;\n\n  /* Adjust checksum to count the \"chksum\" field as blanks.  */\n\n  for (i = sizeof header->header.chksum; i-- != 0;)\n    {\n      unsigned_sum -= (unsigned char) header->header.chksum[i];\n      signed_sum -= (signed char) (header->header.chksum[i]);\n    }\n  unsigned_sum += ' ' * sizeof header->header.chksum;\n  signed_sum += ' ' * sizeof header->header.chksum;\n\n  parsed_sum = from_header (header->header.chksum,\n\t\t\t    sizeof header->header.chksum, 0,\n\t\t\t    0, INT_MAX, true, silent);\n  if (parsed_sum < 0)\n    return HEADER_FAILURE;\n\n  recorded_sum = parsed_sum;\n\n  if (unsigned_sum != recorded_sum && signed_sum != recorded_sum)\n    return HEADER_FAILURE;\n\n  return HEADER_SUCCESS;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "enum read_header",
        "enum",
        "read_header"
      ]
    },
    "read_header": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "enum read_header\nread_header (union block **return_block, struct tar_stat_info *info,\n\t     enum read_header_mode mode)\n{\n  union block *header;\n  union block *header_copy;\n  char *bp;\n  union block *data_block;\n  size_t size, written;\n  union block *next_long_name = 0;\n  union block *next_long_link = 0;\n  size_t next_long_name_blocks = 0;\n  size_t next_long_link_blocks = 0;\n\n  while (1)\n    {\n      enum read_header status;\n\n      header = find_next_block ();\n      *return_block = header;\n      if (!header)\n\treturn HEADER_END_OF_FILE;\n\n      if ((status = tar_checksum (header, false)) != HEADER_SUCCESS)\n\treturn status;\n\n      /* Good block.  Decode file size and return.  */\n\n      if (header->header.typeflag == LNKTYPE)\n\tinfo->stat.st_size = 0;\t/* links 0 size on tape */\n      else\n\t{\n\t  info->stat.st_size = OFF_FROM_HEADER (header->header.size);\n\t  if (info->stat.st_size < 0)\n\t    return HEADER_FAILURE;\n\t}\n\n      if (header->header.typeflag == GNUTYPE_LONGNAME\n\t  || header->header.typeflag == GNUTYPE_LONGLINK\n\t  || header->header.typeflag == XHDTYPE\n\t  || header->header.typeflag == XGLTYPE\n\t  || header->header.typeflag == SOLARIS_XHDTYPE)\n\t{\n\t  if (mode == read_header_x_raw)\n\t    return HEADER_SUCCESS_EXTENDED;\n\t  else if (header->header.typeflag == GNUTYPE_LONGNAME\n\t\t   || header->header.typeflag == GNUTYPE_LONGLINK)\n\t    {\n\t      size_t name_size = info->stat.st_size;\n\t      size_t n = name_size % BLOCKSIZE;\n\t      size = name_size + BLOCKSIZE;\n\t      if (n)\n\t\tsize += BLOCKSIZE - n;\n\n\t      if (name_size != info->stat.st_size || size < name_size)\n\t\txalloc_die ();\n\n\t      header_copy = xmalloc (size + 1);\n\n\t      if (header->header.typeflag == GNUTYPE_LONGNAME)\n\t\t{\n\t\t  free (next_long_name);\n\t\t  next_long_name = header_copy;\n\t\t  next_long_name_blocks = size / BLOCKSIZE;\n\t\t}\n\t      else\n\t\t{\n\t\t  free (next_long_link);\n\t\t  next_long_link = header_copy;\n\t\t  next_long_link_blocks = size / BLOCKSIZE;\n\t\t}\n\n\t      set_next_block_after (header);\n\t      *header_copy = *header;\n\t      bp = header_copy->buffer + BLOCKSIZE;\n\n\t      for (size -= BLOCKSIZE; size > 0; size -= written)\n\t\t{\n\t\t  data_block = find_next_block ();\n\t\t  if (! data_block)\n\t\t    {\n\t\t      ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t\t      break;\n\t\t    }\n\t\t  written = available_space_after (data_block);\n\t\t  if (written > size)\n\t\t    written = size;\n\n\t\t  memcpy (bp, data_block->buffer, written);\n\t\t  bp += written;\n\t\t  set_next_block_after ((union block *)\n\t\t\t\t\t(data_block->buffer + written - 1));\n\t\t}\n\n\t      *bp = '\\0';\n\t    }\n\t  else if (header->header.typeflag == XHDTYPE\n\t\t   || header->header.typeflag == SOLARIS_XHDTYPE)\n\t    xheader_read (&info->xhdr, header,\n\t\t\t  OFF_FROM_HEADER (header->header.size));\n\t  else if (header->header.typeflag == XGLTYPE)\n\t    {\n\t      struct xheader xhdr;\n\n\t      if (!recent_global_header)\n\t\trecent_global_header = xmalloc (sizeof *recent_global_header);\n\t      memcpy (recent_global_header, header,\n\t\t      sizeof *recent_global_header);\n\t      memset (&xhdr, 0, sizeof xhdr);\n\t      xheader_read (&xhdr, header,\n\t\t\t    OFF_FROM_HEADER (header->header.size));\n\t      xheader_decode_global (&xhdr);\n\t      xheader_destroy (&xhdr);\n\t      if (mode == read_header_x_global)\n\t\treturn HEADER_SUCCESS_EXTENDED;\n\t    }\n\n\t  /* Loop!  */\n\n\t}\n      else\n\t{\n\t  char const *name;\n\t  struct posix_header const *h = &header->header;\n\t  char namebuf[sizeof h->prefix + 1 + NAME_FIELD_SIZE + 1];\n\n\t  free (recent_long_name);\n\n\t  if (next_long_name)\n\t    {\n\t      name = next_long_name->buffer + BLOCKSIZE;\n\t      recent_long_name = next_long_name;\n\t      recent_long_name_blocks = next_long_name_blocks;\n\t    }\n\t  else\n\t    {\n\t      /* Accept file names as specified by POSIX.1-1996\n                 section 10.1.1.  */\n\t      char *np = namebuf;\n\n\t      if (h->prefix[0] && strcmp (h->magic, TMAGIC) == 0)\n\t\t{\n\t\t  memcpy (np, h->prefix, sizeof h->prefix);\n\t\t  np[sizeof h->prefix] = '\\0';\n\t\t  np += strlen (np);\n\t\t  *np++ = '/';\n\t\t}\n\t      memcpy (np, h->name, sizeof h->name);\n\t      np[sizeof h->name] = '\\0';\n\t      name = namebuf;\n\t      recent_long_name = 0;\n\t      recent_long_name_blocks = 0;\n\t    }\n\t  assign_string (&info->orig_file_name, name);\n\t  assign_string (&info->file_name, name);\n\t  info->had_trailing_slash = strip_trailing_slashes (info->file_name);\n\n\t  free (recent_long_link);\n\n\t  if (next_long_link)\n\t    {\n\t      name = next_long_link->buffer + BLOCKSIZE;\n\t      recent_long_link = next_long_link;\n\t      recent_long_link_blocks = next_long_link_blocks;\n\t    }\n\t  else\n\t    {\n\t      memcpy (namebuf, h->linkname, sizeof h->linkname);\n\t      namebuf[sizeof h->linkname] = '\\0';\n\t      name = namebuf;\n\t      recent_long_link = 0;\n\t      recent_long_link_blocks = 0;\n\t    }\n\t  assign_string (&info->link_name, name);\n\n\t  return HEADER_SUCCESS;\n\t}\n    }\n}",
      "lines": 179,
      "depth": 23,
      "decorators": [
        "enum read_header",
        "enum",
        "read_header"
      ]
    },
    "decode_header": {
      "start_point": [
        601,
        0
      ],
      "end_point": [
        708,
        1
      ],
      "content": "void\ndecode_header (union block *header, struct tar_stat_info *stat_info,\n\t       enum archive_format *format_pointer, int do_user_group)\n{\n  enum archive_format format;\n  bool hbits;\n  mode_t mode = MODE_FROM_HEADER (header->header.mode, &hbits);\n\n  if (strcmp (header->header.magic, TMAGIC) == 0)\n    {\n      if (header->star_header.prefix[130] == 0\n\t  && ISOCTAL (header->star_header.atime[0])\n\t  && header->star_header.atime[11] == ' '\n\t  && ISOCTAL (header->star_header.ctime[0])\n\t  && header->star_header.ctime[11] == ' ')\n\tformat = STAR_FORMAT;\n      else if (stat_info->xhdr.size)\n\tformat = POSIX_FORMAT;\n      else\n\tformat = USTAR_FORMAT;\n    }\n  else if (strcmp (header->buffer + offsetof (struct posix_header, magic),\n\t\t   OLDGNU_MAGIC)\n\t   == 0)\n    format = hbits ? OLDGNU_FORMAT : GNU_FORMAT;\n  else\n    format = V7_FORMAT;\n  *format_pointer = format;\n\n  stat_info->stat.st_mode = mode;\n  stat_info->mtime.tv_sec = TIME_FROM_HEADER (header->header.mtime);\n  stat_info->mtime.tv_nsec = 0;\n  assign_string (&stat_info->uname,\n\t\t header->header.uname[0] ? header->header.uname : NULL);\n  assign_string (&stat_info->gname,\n\t\t header->header.gname[0] ? header->header.gname : NULL);\n\n  xheader_xattr_init (stat_info);\n\n  if (format == OLDGNU_FORMAT && incremental_option)\n    {\n      stat_info->atime.tv_sec = TIME_FROM_HEADER (header->oldgnu_header.atime);\n      stat_info->ctime.tv_sec = TIME_FROM_HEADER (header->oldgnu_header.ctime);\n      stat_info->atime.tv_nsec = stat_info->ctime.tv_nsec = 0;\n    }\n  else if (format == STAR_FORMAT)\n    {\n      stat_info->atime.tv_sec = TIME_FROM_HEADER (header->star_header.atime);\n      stat_info->ctime.tv_sec = TIME_FROM_HEADER (header->star_header.ctime);\n      stat_info->atime.tv_nsec = stat_info->ctime.tv_nsec = 0;\n    }\n  else\n    stat_info->atime = stat_info->ctime = start_time;\n\n  if (format == V7_FORMAT)\n    {\n      stat_info->stat.st_uid = UID_FROM_HEADER (header->header.uid);\n      stat_info->stat.st_gid = GID_FROM_HEADER (header->header.gid);\n      stat_info->stat.st_rdev = 0;\n    }\n  else\n    {\n      if (do_user_group)\n\t{\n\t  /* FIXME: Decide if this should somewhat depend on -p.  */\n\n\t  if (numeric_owner_option\n\t      || !*header->header.uname\n\t      || !uname_to_uid (header->header.uname, &stat_info->stat.st_uid))\n\t    stat_info->stat.st_uid = UID_FROM_HEADER (header->header.uid);\n\n\t  if (numeric_owner_option\n\t      || !*header->header.gname\n\t      || !gname_to_gid (header->header.gname, &stat_info->stat.st_gid))\n\t    stat_info->stat.st_gid = GID_FROM_HEADER (header->header.gid);\n\t}\n\n      switch (header->header.typeflag)\n\t{\n\tcase BLKTYPE:\n\tcase CHRTYPE:\n\t  stat_info->stat.st_rdev =\n\t    makedev (MAJOR_FROM_HEADER (header->header.devmajor),\n\t\t     MINOR_FROM_HEADER (header->header.devminor));\n\t  break;\n\n\tdefault:\n\t  stat_info->stat.st_rdev = 0;\n\t}\n    }\n\n  xheader_decode (stat_info);\n\n  if (sparse_member_p (stat_info))\n    {\n      sparse_fixup_header (stat_info);\n      stat_info->is_sparse = true;\n    }\n  else\n    {\n      stat_info->is_sparse = false;\n      if (((current_format == GNU_FORMAT\n\t    || current_format == OLDGNU_FORMAT)\n\t   && current_header->header.typeflag == GNUTYPE_DUMPDIR)\n          || stat_info->dumpdir)\n\tstat_info->is_dumpdir = true;\n    }\n}",
      "lines": 108,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "from_header": {
      "start_point": [
        725,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "static intmax_t\nfrom_header (char const *where0, size_t digs, char const *type,\n\t     intmax_t minval, uintmax_t maxval,\n\t     bool octal_only, bool silent)\n{\n  uintmax_t value;\n  uintmax_t uminval = minval;\n  uintmax_t minus_minval = - uminval;\n  char const *where = where0;\n  char const *lim = where + digs;\n  bool negative = false;\n\n  /* Accommodate buggy tar of unknown vintage, which outputs leading\n     NUL if the previous field overflows.  */\n  where += !*where;\n\n  /* Accommodate older tars, which output leading spaces.  */\n  for (;;)\n    {\n      if (where == lim)\n\t{\n\t  if (type && !silent)\n\t    ERROR ((0, 0,\n\t\t    /* TRANSLATORS: %s is type of the value (gid_t, uid_t,\n\t\t       etc.) */\n\t\t    _(\"Blanks in header where numeric %s value expected\"),\n\t\t    type));\n\t  return -1;\n\t}\n      if (!isspace ((unsigned char) *where))\n\tbreak;\n      where++;\n    }\n\n  value = 0;\n  if (ISODIGIT (*where))\n    {\n      char const *where1 = where;\n      bool overflow = false;\n\n      for (;;)\n\t{\n\t  value += *where++ - '0';\n\t  if (where == lim || ! ISODIGIT (*where))\n\t    break;\n\t  overflow |= value != (value << LG_8 >> LG_8);\n\t  value <<= LG_8;\n\t}\n\n      /* Parse the output of older, unportable tars, which generate\n         negative values in two's complement octal.  If the leading\n         nonzero digit is 1, we can't recover the original value\n         reliably; so do this only if the digit is 2 or more.  This\n         catches the common case of 32-bit negative time stamps.  */\n      if ((overflow || maxval < value) && '2' <= *where1 && type)\n\t{\n\t  /* Compute the negative of the input value, assuming two's\n\t     complement.  */\n\t  int digit = (*where1 - '0') | 4;\n\t  overflow = 0;\n\t  value = 0;\n\t  where = where1;\n\t  for (;;)\n\t    {\n\t      value += 7 - digit;\n\t      where++;\n\t      if (where == lim || ! ISODIGIT (*where))\n\t\tbreak;\n\t      digit = *where - '0';\n\t      overflow |= value != (value << LG_8 >> LG_8);\n\t      value <<= LG_8;\n\t    }\n\t  value++;\n\t  overflow |= !value;\n\n\t  if (!overflow && value <= minus_minval)\n\t    {\n\t      if (!silent)\n\t\tWARN ((0, 0,\n\t\t       /* TRANSLATORS: Second %s is a type name (gid_t,uid_t,etc.) */\n\t\t       _(\"Archive octal value %.*s is out of %s range; assuming two's complement\"),\n\t\t       (int) (where - where1), where1, type));\n\t      negative = true;\n\t    }\n\t}\n\n      if (overflow)\n\t{\n\t  if (type && !silent)\n\t    ERROR ((0, 0,\n\t\t    /* TRANSLATORS: Second %s is a type name (gid_t,uid_t,etc.) */\n\t\t    _(\"Archive octal value %.*s is out of %s range\"),\n\t\t    (int) (where - where1), where1, type));\n\t  return -1;\n\t}\n    }\n  else if (octal_only)\n    {\n      /* Suppress the following extensions.  */\n    }\n  else if (*where == '-' || *where == '+')\n    {\n      /* Parse base-64 output produced only by tar test versions\n\t 1.13.6 (1999-08-11) through 1.13.11 (1999-08-23).\n\t Support for this will be withdrawn in future releases.  */\n      int dig;\n      if (!silent)\n\t{\n\t  static bool warned_once;\n\t  if (! warned_once)\n\t    {\n\t      warned_once = true;\n\t      WARN ((0, 0, _(\"Archive contains obsolescent base-64 headers\")));\n\t    }\n\t}\n      negative = *where++ == '-';\n      while (where != lim\n\t     && (dig = base64_map[(unsigned char) *where]) < 64)\n\t{\n\t  if (value << LG_64 >> LG_64 != value)\n\t    {\n\t      char *string = alloca (digs + 1);\n\t      memcpy (string, where0, digs);\n\t      string[digs] = '\\0';\n\t      if (type && !silent)\n\t\tERROR ((0, 0,\n\t\t\t_(\"Archive signed base-64 string %s is out of %s range\"),\n\t\t\tquote (string), type));\n\t      return -1;\n\t    }\n\t  value = (value << LG_64) | dig;\n\t  where++;\n\t}\n    }\n  else if (*where == '\\200' /* positive base-256 */\n\t   || *where == '\\377' /* negative base-256 */)\n    {\n      /* Parse base-256 output.  A nonnegative number N is\n\t represented as (256**DIGS)/2 + N; a negative number -N is\n\t represented as (256**DIGS) - N, i.e. as two's complement.\n\t The representation guarantees that the leading bit is\n\t always on, so that we don't confuse this format with the\n\t others (assuming ASCII bytes of 8 bits or more).  */\n      int signbit = *where & (1 << (LG_256 - 2));\n      uintmax_t topbits = (((uintmax_t) - signbit)\n\t\t\t   << (CHAR_BIT * sizeof (uintmax_t)\n\t\t\t       - LG_256 - (LG_256 - 2)));\n      value = (*where++ & ((1 << (LG_256 - 2)) - 1)) - signbit;\n      for (;;)\n\t{\n\t  value = (value << LG_256) + (unsigned char) *where++;\n\t  if (where == lim)\n\t    break;\n\t  if (((value << LG_256 >> LG_256) | topbits) != value)\n\t    {\n\t      if (type && !silent)\n\t\tERROR ((0, 0,\n\t\t\t_(\"Archive base-256 value is out of %s range\"),\n\t\t\ttype));\n\t      return -1;\n\t    }\n\t}\n      negative = signbit != 0;\n      if (negative)\n\tvalue = -value;\n    }\n\n  if (where != lim && *where && !isspace ((unsigned char) *where))\n    {\n      if (type)\n\t{\n\t  char buf[1000]; /* Big enough to represent any header.  */\n\t  static struct quoting_options *o;\n\n\t  if (!o)\n\t    {\n\t      o = clone_quoting_options (0);\n\t      set_quoting_style (o, locale_quoting_style);\n\t    }\n\n\t  while (where0 != lim && ! lim[-1])\n\t    lim--;\n\t  quotearg_buffer (buf, sizeof buf, where0, lim - where0, o);\n\t  if (!silent)\n\t    ERROR ((0, 0,\n\t\t    /* TRANSLATORS: Second %s is a type name (gid_t,uid_t,etc.) */\n\t\t    _(\"Archive contains %.*s where numeric %s value expected\"),\n\t\t    (int) sizeof buf, buf, type));\n\t}\n\n      return -1;\n    }\n\n  if (value <= (negative ? minus_minval : maxval))\n    return represent_uintmax (negative ? -value : value);\n\n  if (type && !silent)\n    {\n      char minval_buf[UINTMAX_STRSIZE_BOUND + 1];\n      char maxval_buf[UINTMAX_STRSIZE_BOUND];\n      char value_buf[UINTMAX_STRSIZE_BOUND + 1];\n      char *minval_string = STRINGIFY_BIGINT (minus_minval, minval_buf + 1);\n      char *value_string = STRINGIFY_BIGINT (value, value_buf + 1);\n      if (negative)\n\t*--value_string = '-';\n      if (minus_minval)\n\t*--minval_string = '-';\n      /* TRANSLATORS: Second %s is type name (gid_t,uid_t,etc.) */\n      ERROR ((0, 0, _(\"Archive value %s is out of %s range %s..%s\"),\n\t      value_string, type,\n\t      minval_string, STRINGIFY_BIGINT (maxval, maxval_buf)));\n    }\n\n  return -1;\n}",
      "lines": 215,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "intmax_t"
      ]
    },
    "gid_from_header": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "static gid_t\ngid_from_header (const char *p, size_t s)\n{\n  return from_header (p, s, \"gid_t\",\n\t\t      TYPE_MINIMUM (gid_t), TYPE_MAXIMUM (gid_t),\n\t\t      false, false);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "gid_t"
      ]
    },
    "major_from_header": {
      "start_point": [
        949,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "static major_t\nmajor_from_header (const char *p, size_t s)\n{\n  return from_header (p, s, \"major_t\",\n\t\t      TYPE_MINIMUM (major_t), TYPE_MAXIMUM (major_t),\n\t\t      false, false);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "major_t"
      ]
    },
    "minor_from_header": {
      "start_point": [
        957,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "static minor_t\nminor_from_header (const char *p, size_t s)\n{\n  return from_header (p, s, \"minor_t\",\n\t\t      TYPE_MINIMUM (minor_t), TYPE_MAXIMUM (minor_t),\n\t\t      false, false);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "minor_t"
      ]
    },
    "mode_from_header": {
      "start_point": [
        967,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "static mode_t\nmode_from_header (const char *p, size_t s, bool *hbits)\n{\n  intmax_t u = from_header (p, s, \"mode_t\",\n\t\t\t    INTMAX_MIN, UINTMAX_MAX,\n\t\t\t    false, false);\n  mode_t mode = ((u & TSUID ? S_ISUID : 0)\n\t\t | (u & TSGID ? S_ISGID : 0)\n\t\t | (u & TSVTX ? S_ISVTX : 0)\n\t\t | (u & TUREAD ? S_IRUSR : 0)\n\t\t | (u & TUWRITE ? S_IWUSR : 0)\n\t\t | (u & TUEXEC ? S_IXUSR : 0)\n\t\t | (u & TGREAD ? S_IRGRP : 0)\n\t\t | (u & TGWRITE ? S_IWGRP : 0)\n\t\t | (u & TGEXEC ? S_IXGRP : 0)\n\t\t | (u & TOREAD ? S_IROTH : 0)\n\t\t | (u & TOWRITE ? S_IWOTH : 0)\n\t\t | (u & TOEXEC ? S_IXOTH : 0));\n  *hbits = (u & ~07777) != 0;\n  return mode;\n}",
      "lines": 21,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "mode_t"
      ]
    },
    "off_from_header": {
      "start_point": [
        989,
        0
      ],
      "end_point": [
        997,
        1
      ],
      "content": "off_t\noff_from_header (const char *p, size_t s)\n{\n  /* Negative offsets are not allowed in tar files, so invoke\n     from_header with minimum value 0, not TYPE_MINIMUM (off_t).  */\n  return from_header (p, s, \"off_t\",\n\t\t      0, TYPE_MAXIMUM (off_t),\n\t\t      false, false);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "off_t"
      ]
    },
    "time_from_header": {
      "start_point": [
        999,
        0
      ],
      "end_point": [
        1005,
        1
      ],
      "content": "static time_t\ntime_from_header (const char *p, size_t s)\n{\n  return from_header (p, s, \"time_t\",\n\t\t      TYPE_MINIMUM (time_t), TYPE_MAXIMUM (time_t),\n\t\t      false, false);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "uid_from_header": {
      "start_point": [
        1007,
        0
      ],
      "end_point": [
        1013,
        1
      ],
      "content": "static uid_t\nuid_from_header (const char *p, size_t s)\n{\n  return from_header (p, s, \"uid_t\",\n\t\t      TYPE_MINIMUM (uid_t), TYPE_MAXIMUM (uid_t),\n\t\t      false, false);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "uid_t"
      ]
    },
    "uintmax_from_header": {
      "start_point": [
        1015,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "uintmax_t\nuintmax_from_header (const char *p, size_t s)\n{\n  return from_header (p, s, \"uintmax_t\", 0, UINTMAX_MAX, false, false);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "uintmax_t"
      ]
    },
    "tartime": {
      "start_point": [
        1027,
        0
      ],
      "end_point": [
        1078,
        1
      ],
      "content": "char const *\ntartime (struct timespec t, bool full_time)\n{\n  enum { fraclen = sizeof \".FFFFFFFFF\" - 1 };\n  static char buffer[max (UINTMAX_STRSIZE_BOUND + 1,\n\t\t\t  INT_STRLEN_BOUND (int) + 16)\n\t\t     + fraclen];\n  struct tm *tm;\n  time_t s = t.tv_sec;\n  int ns = t.tv_nsec;\n  bool negative = s < 0;\n  char *p;\n\n  if (negative && ns != 0)\n    {\n      s++;\n      ns = 1000000000 - ns;\n    }\n\n  tm = utc_option ? gmtime (&s) : localtime (&s);\n  if (tm)\n    {\n      if (full_time)\n\t{\n\t  sprintf (buffer, \"%04ld-%02d-%02d %02d:%02d:%02d\",\n\t\t   tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday,\n\t\t   tm->tm_hour, tm->tm_min, tm->tm_sec);\n\t  code_ns_fraction (ns, buffer + strlen (buffer));\n\t}\n      else\n\tsprintf (buffer, \"%04ld-%02d-%02d %02d:%02d\",\n\t\t tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday,\n\t\t tm->tm_hour, tm->tm_min);\n      return buffer;\n    }\n\n  /* The time stamp cannot be broken down, most likely because it\n     is out of range.  Convert it as an integer,\n     right-adjusted in a field with the same width as the usual\n     4-year ISO time format.  */\n  p = umaxtostr (negative ? - (uintmax_t) s : s,\n\t\t buffer + sizeof buffer - UINTMAX_STRSIZE_BOUND - fraclen);\n  if (negative)\n    *--p = '-';\n  while ((buffer + sizeof buffer - sizeof \"YYYY-MM-DD HH:MM\"\n\t  + (full_time ? sizeof \":SS.FFFFFFFFF\" - 1 : 0))\n\t < p)\n    *--p = ' ';\n  if (full_time)\n    code_ns_fraction (ns, buffer + sizeof buffer - 1 - fraclen);\n  return p;\n}",
      "lines": 52,
      "depth": 17,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ntartime (struct timespec t, bool full_time)",
        "*"
      ]
    },
    "simple_print_header": {
      "start_point": [
        1104,
        0
      ],
      "end_point": [
        1319,
        1
      ],
      "content": "static void\nsimple_print_header (struct tar_stat_info *st, union block *blk,\n\t\t     off_t block_ordinal)\n{\n  char modes[12];\n  char const *time_stamp;\n  int time_stamp_len;\n  char *temp_name;\n\n  /* These hold formatted ints.  */\n  char uform[max (INT_BUFSIZE_BOUND (intmax_t), UINTMAX_STRSIZE_BOUND)];\n  char gform[sizeof uform];\n  char *user, *group;\n  char size[2 * UINTMAX_STRSIZE_BOUND];\n  \t\t\t\t/* holds formatted size or major,minor */\n  char uintbuf[UINTMAX_STRSIZE_BOUND];\n  int pad;\n  int sizelen;\n\n  if (show_transformed_names_option)\n    temp_name = st->file_name ? st->file_name : st->orig_file_name;\n  else\n    temp_name = st->orig_file_name ? st->orig_file_name : st->file_name;\n\n  if (block_number_option)\n    {\n      char buf[UINTMAX_STRSIZE_BOUND];\n      if (block_ordinal < 0)\n\tblock_ordinal = current_block_ordinal ();\n      block_ordinal -= recent_long_name_blocks;\n      block_ordinal -= recent_long_link_blocks;\n      fprintf (stdlis, _(\"block %s: \"),\n\t       STRINGIFY_BIGINT (block_ordinal, buf));\n    }\n\n  if (verbose_option <= 1)\n    {\n      /* Just the fax, mam.  */\n      fputs (quotearg (temp_name), stdlis);\n      if (show_transformed_names_option && st->had_trailing_slash)\n\tfputc ('/', stdlis);\n      fputc ('\\n', stdlis);\n    }\n  else\n    {\n      /* File type and modes.  */\n\n      modes[0] = '?';\n      switch (blk->header.typeflag)\n\t{\n\tcase GNUTYPE_VOLHDR:\n\t  volume_label_printed = true;\n\t  modes[0] = 'V';\n\t  break;\n\n\tcase GNUTYPE_MULTIVOL:\n\t  modes[0] = 'M';\n\t  break;\n\n\tcase GNUTYPE_LONGNAME:\n\tcase GNUTYPE_LONGLINK:\n\t  modes[0] = 'L';\n\t  ERROR ((0, 0, _(\"Unexpected long name header\")));\n\t  break;\n\n\tcase GNUTYPE_SPARSE:\n\tcase REGTYPE:\n\tcase AREGTYPE:\n\t  modes[0] = st->had_trailing_slash ? 'd' : '-';\n\t  break;\n\tcase LNKTYPE:\n\t  modes[0] = 'h';\n\t  break;\n\tcase GNUTYPE_DUMPDIR:\n\t  modes[0] = 'd';\n\t  break;\n\tcase DIRTYPE:\n\t  modes[0] = 'd';\n\t  break;\n\tcase SYMTYPE:\n\t  modes[0] = 'l';\n\t  break;\n\tcase BLKTYPE:\n\t  modes[0] = 'b';\n\t  break;\n\tcase CHRTYPE:\n\t  modes[0] = 'c';\n\t  break;\n\tcase FIFOTYPE:\n\t  modes[0] = 'p';\n\t  break;\n\tcase CONTTYPE:\n\t  modes[0] = 'C';\n\t  break;\n\t}\n\n      pax_decode_mode (st->stat.st_mode, modes + 1);\n\n      /* extended attributes:  GNU `ls -l'-like preview */\n      xattrs_print_char (st, modes + 10);\n\n      /* Time stamp.  */\n\n      time_stamp = tartime (st->mtime, full_time_option);\n      time_stamp_len = strlen (time_stamp);\n      if (datewidth < time_stamp_len)\n\tdatewidth = time_stamp_len;\n\n      /* User and group names.  */\n\n      if (st->uname\n\t  && st->uname[0]\n\t  && current_format != V7_FORMAT\n\t  && !numeric_owner_option)\n\tuser = st->uname;\n      else\n\tuser = STRINGIFY_BIGINT (st->stat.st_uid, uform);\n\n      if (st->gname\n\t  && st->gname[0]\n\t  && current_format != V7_FORMAT\n\t  && !numeric_owner_option)\n\tgroup = st->gname;\n      else\n\tgroup = STRINGIFY_BIGINT (st->stat.st_gid, gform);\n\n      /* Format the file size or major/minor device numbers.  */\n\n      switch (blk->header.typeflag)\n\t{\n\tcase CHRTYPE:\n\tcase BLKTYPE:\n\t  strcpy (size,\n\t\t  STRINGIFY_BIGINT (major (st->stat.st_rdev), uintbuf));\n\t  strcat (size, \",\");\n\t  strcat (size,\n\t\t  STRINGIFY_BIGINT (minor (st->stat.st_rdev), uintbuf));\n\t  break;\n\n\tdefault:\n\t  /* st->stat.st_size keeps stored file size */\n\t  strcpy (size, STRINGIFY_BIGINT (st->stat.st_size, uintbuf));\n\t  break;\n\t}\n\n      /* Figure out padding and print the whole line.  */\n\n      sizelen = strlen (size);\n      pad = strlen (user) + 1 + strlen (group) + 1 + sizelen;\n      if (pad > ugswidth)\n\tugswidth = pad;\n\n      fprintf (stdlis, \"%s %s/%s %*s %-*s\",\n\t       modes, user, group, ugswidth - pad + sizelen, size,\n\t       datewidth, time_stamp);\n\n      fprintf (stdlis, \" %s\", quotearg (temp_name));\n      if (show_transformed_names_option && st->had_trailing_slash)\n\tfputc ('/', stdlis);\n\n      switch (blk->header.typeflag)\n\t{\n\tcase SYMTYPE:\n\t  fprintf (stdlis, \" -> %s\\n\", quotearg (st->link_name));\n\t  break;\n\n\tcase LNKTYPE:\n\t  fprintf (stdlis, _(\" link to %s\\n\"), quotearg (st->link_name));\n\t  break;\n\n\tdefault:\n\t  {\n\t    char type_string[2];\n\t    type_string[0] = blk->header.typeflag;\n\t    type_string[1] = '\\0';\n\t    fprintf (stdlis, _(\" unknown file type %s\\n\"),\n\t\t     quote (type_string));\n\t  }\n\t  break;\n\n\tcase AREGTYPE:\n\tcase REGTYPE:\n\tcase GNUTYPE_SPARSE:\n\tcase CHRTYPE:\n\tcase BLKTYPE:\n\tcase DIRTYPE:\n\tcase FIFOTYPE:\n\tcase CONTTYPE:\n\tcase GNUTYPE_DUMPDIR:\n\t  putc ('\\n', stdlis);\n\t  break;\n\n\tcase GNUTYPE_LONGLINK:\n\t  fprintf (stdlis, _(\"--Long Link--\\n\"));\n\t  break;\n\n\tcase GNUTYPE_LONGNAME:\n\t  fprintf (stdlis, _(\"--Long Name--\\n\"));\n\t  break;\n\n\tcase GNUTYPE_VOLHDR:\n\t  fprintf (stdlis, _(\"--Volume Header--\\n\"));\n\t  break;\n\n\tcase GNUTYPE_MULTIVOL:\n\t  strcpy (size,\n\t\t  STRINGIFY_BIGINT\n\t\t  (UINTMAX_FROM_HEADER (blk->oldgnu_header.offset),\n\t\t   uintbuf));\n\t  fprintf (stdlis, _(\"--Continued at byte %s--\\n\"), size);\n\t  break;\n\t}\n    }\n  fflush (stdlis);\n  xattrs_print (st);\n}",
      "lines": 216,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_volume_label": {
      "start_point": [
        1322,
        0
      ],
      "end_point": [
        1340,
        1
      ],
      "content": "static void\nprint_volume_label (void)\n{\n  struct tar_stat_info vstat;\n  union block vblk;\n  enum archive_format dummy;\n\n  memset (&vblk, 0, sizeof (vblk));\n  vblk.header.typeflag = GNUTYPE_VOLHDR;\n  if (recent_global_header)\n    memcpy (vblk.header.mtime, recent_global_header->header.mtime,\n\t    sizeof vblk.header.mtime);\n  tar_stat_init (&vstat);\n  assign_string (&vstat.file_name, \".\");\n  decode_header (&vblk, &vstat, &dummy, 0);\n  assign_string (&vstat.file_name, volume_label);\n  simple_print_header (&vstat, &vblk, 0);\n  tar_stat_destroy (&vstat);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_header": {
      "start_point": [
        1342,
        0
      ],
      "end_point": [
        1353,
        1
      ],
      "content": "void\nprint_header (struct tar_stat_info *st, union block *blk,\n\t      off_t block_ordinal)\n{\n  if (current_format == POSIX_FORMAT && !volume_label_printed && volume_label)\n    {\n      print_volume_label ();\n      volume_label_printed = true;\n    }\n\n  simple_print_header (st, blk, block_ordinal);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "print_for_mkdir": {
      "start_point": [
        1356,
        0
      ],
      "end_point": [
        1378,
        1
      ],
      "content": "void\nprint_for_mkdir (char *dirname, int length, mode_t mode)\n{\n  char modes[11];\n\n  if (verbose_option > 1)\n    {\n      /* File type and modes.  */\n\n      modes[0] = 'd';\n      pax_decode_mode (mode, modes + 1);\n\n      if (block_number_option)\n\t{\n\t  char buf[UINTMAX_STRSIZE_BOUND];\n\t  fprintf (stdlis, _(\"block %s: \"),\n\t\t   STRINGIFY_BIGINT (current_block_ordinal (), buf));\n\t}\n\n      fprintf (stdlis, \"%s %*s %s\\n\", modes, ugswidth + 1 + datewidth,\n\t       _(\"Creating directory:\"), quotearg (dirname));\n    }\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "skip_file": {
      "start_point": [
        1381,
        0
      ],
      "end_point": [
        1409,
        1
      ],
      "content": "void\nskip_file (off_t size)\n{\n  union block *x;\n\n  /* FIXME: Make sure mv_begin_read is always called before it */\n\n  if (seekable_archive)\n    {\n      off_t nblk = seek_archive (size);\n      if (nblk >= 0)\n\tsize -= nblk * BLOCKSIZE;\n      else\n\tseekable_archive = false;\n    }\n\n  mv_size_left (size);\n\n  while (size > 0)\n    {\n      x = find_next_block ();\n      if (! x)\n\tFATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\n      set_next_block_after (x);\n      size -= BLOCKSIZE;\n      mv_size_left (size);\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "skip_member": {
      "start_point": [
        1413,
        0
      ],
      "end_point": [
        1430,
        1
      ],
      "content": "void\nskip_member (void)\n{\n  if (!current_stat_info.skipped)\n    {\n      char save_typeflag = current_header->header.typeflag;\n      set_next_block_after (current_header);\n\n      mv_begin_read (&current_stat_info);\n\n      if (current_stat_info.is_sparse)\n\tsparse_skip_file (&current_stat_info);\n      else if (save_typeflag != DIRTYPE)\n\tskip_file (current_stat_info.stat.st_size);\n\n      mv_end ();\n    }\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "test_archive_label": {
      "start_point": [
        1432,
        0
      ],
      "end_point": [
        1461,
        1
      ],
      "content": "void\ntest_archive_label (void)\n{\n  base64_init ();\n  name_gather ();\n\n  open_archive (ACCESS_READ);\n  if (read_header (&current_header, &current_stat_info, read_header_auto)\n      == HEADER_SUCCESS)\n    {\n      decode_header (current_header,\n\t\t     &current_stat_info, &current_format, 0);\n      if (current_header->header.typeflag == GNUTYPE_VOLHDR)\n\tassign_string (&volume_label, current_header->header.name);\n\n      if (volume_label)\n\t{\n\t  if (verbose_option)\n\t    print_volume_label ();\n\t  if (!name_match (volume_label) && multi_volume_option)\n\t    {\n\t      char *s = drop_volume_label_suffix (volume_label);\n\t      name_match (s);\n\t      free (s);\n\t    }\n\t}\n    }\n  close_archive ();\n  label_notfound ();\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/map.c": {
    "map_hash": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static size_t\nmap_hash (void const *entry, size_t nbuckets)\n{\n  struct mapentry const *map = entry;\n  return map->orig_id % nbuckets;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "map_compare": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static bool\nmap_compare (void const *entry1, void const *entry2)\n{\n  struct mapentry const *map1 = entry1;\n  struct mapentry const *map2 = entry2;\n  return map1->orig_id == map2->orig_id;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_id": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static int\nparse_id (uintmax_t *retval,\n\t  char const *arg, char const *what, uintmax_t maxval,\n\t  char const *file, unsigned line)\n{\n  uintmax_t v;\n  char *p;\n  \n  errno = 0;\n  v = strtoumax (arg, &p, 10);\n  if (*p || errno)\n    {\n      error (0, 0, _(\"%s:%u: invalid %s: %s\"),  file, line, what, arg);\n      return -1;\n    }\n  if (v > maxval)\n    {\n      error (0, 0, _(\"%s:%u: %s out of range: %s\"), file, line, what, arg);\n      return -1;\n    }\n  *retval = v;\n  return 0;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "map_read": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void\nmap_read (Hash_table **ptab, char const *file,\n\t  uintmax_t (*name_to_id) (char const *), char const *what,\n\t  uintmax_t maxval)\n{\n  FILE *fp;\n  char *buf = NULL;\n  size_t bufsize = 0;\n  ssize_t n;\n  struct wordsplit ws;\n  int wsopt;\n  unsigned line;\n  int err = 0;\n  \n  fp = fopen (file, \"r\");\n  if (!fp)\n    open_fatal (file);\n\n  ws.ws_comment = \"#\";\n  wsopt = WRDSF_COMMENT | WRDSF_NOVAR | WRDSF_NOCMD | WRDSF_SQUEEZE_DELIMS\n          | WRDSF_QUOTE;\n  line = 0;\n  while ((n = getline (&buf, &bufsize, fp)) > 0)\n    {\n      struct mapentry *ent;\n      uintmax_t orig_id, new_id;\n      char *name = NULL;\n      char *colon;\n      \n      ++line;\n      if (wordsplit (buf, &ws, wsopt))\n\tFATAL_ERROR ((0, 0, _(\"%s:%u: cannot split line: %s\"),\n\t\t      file, line, wordsplit_strerror (&ws)));\n      wsopt |= WRDSF_REUSE;\n      if (ws.ws_wordc == 0)\n\tcontinue;\n      if (ws.ws_wordc != 2)\n\t{\n\t  error (0, 0, _(\"%s:%u: malformed line\"), file, line);\n\t  err = 1;\n\t  continue;\n\t}\n\n      if (ws.ws_wordv[0][0] == '+')\n\t{\n\t  if (parse_id (&orig_id, ws.ws_wordv[0]+1, what, maxval, file, line)) \n\t    {\n\t      err = 1;\n\t      continue;\n\t    }\n\t}\n      else if (name_to_id)\n\t{\n\t  orig_id = name_to_id (ws.ws_wordv[0]);\n\t  if (orig_id == UINTMAX_MAX)\n\t    {\n\t      error (0, 0, _(\"%s:%u: can't obtain %s of %s\"),\n\t\t     file, line, what, ws.ws_wordv[0]);\n\t      err = 1;\n\t      continue;\n\t    }\n\t}\n\n      colon = strchr (ws.ws_wordv[1], ':');\n      if (colon)\n\t{\n\t  if (colon > ws.ws_wordv[1])\n\t    name = ws.ws_wordv[1];\n\t  *colon++ = 0;\n\t  if (parse_id (&new_id, colon, what, maxval, file, line)) \n\t    {\n\t      err = 1;\n\t      continue;\n\t    }\n\t}\n      else if (ws.ws_wordv[1][0] == '+')\n\t{\n\t  if (parse_id (&new_id, ws.ws_wordv[1], what, maxval, file, line)) \n\t    {\n\t      err = 1;\n\t      continue;\n\t    }\n\t}\n      else\n\t{\n\t  name = ws.ws_wordv[1];\n\t  new_id = name_to_id (ws.ws_wordv[1]);\n\t  if (new_id == UINTMAX_MAX)\n\t    {\n\t      error (0, 0, _(\"%s:%u: can't obtain %s of %s\"),\n\t\t     file, line, what, ws.ws_wordv[1]);\n\t      err = 1;\n\t      continue;\n\t    }\n\t}\n\n      ent = xmalloc (sizeof (*ent));\n      ent->orig_id = orig_id;\n      ent->new_id = new_id;\n      ent->new_name = name ? xstrdup (name) : NULL;\n      \n      if (!((*ptab\n\t     || (*ptab = hash_initialize (0, 0, map_hash, map_compare, 0)))\n\t    && hash_insert (*ptab, ent)))\n\txalloc_die ();\n    }\n  if (wsopt & WRDSF_REUSE)\n    wordsplit_free (&ws);\n  fclose (fp);\n  if (err)\n    FATAL_ERROR ((0, 0, _(\"errors reading map file\")));\n}",
      "lines": 112,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "name_to_uid": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "static uintmax_t\nname_to_uid (char const *name)\n{\n  struct passwd *pw = getpwnam (name);\n  return pw ? pw->pw_uid : UINTMAX_MAX;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "uintmax_t"
      ]
    },
    "owner_map_read": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void\nowner_map_read (char const *file)\n{\n  map_read (&owner_map, file, name_to_uid, \"UID\", TYPE_MAXIMUM (uid_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "owner_map_translate": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "int\nowner_map_translate (uid_t uid, uid_t *new_uid, char const **new_name)\n{\n  int rc = 1;\n  \n  if (owner_map)\n    {\n      struct mapentry ent, *res;\n  \n      ent.orig_id = uid;\n      res = hash_lookup (owner_map, &ent);\n      if (res)\n\t{\n\t  *new_uid = res->new_id;\n\t  *new_name = res->new_name;\n\t  return 0;\n\t}\n    }\n\n  if (owner_option != (uid_t) -1)\n    {\n      *new_uid = owner_option;\n      rc = 0;\n    }\n  if (owner_name_option)\n    {\n      *new_name = owner_name_option;\n      rc = 0;\n    }\n\n  return rc;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "name_to_gid": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static uintmax_t\nname_to_gid (char const *name)\n{\n  struct group *gr = getgrnam (name);\n  return gr ? gr->gr_gid : UINTMAX_MAX;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "uintmax_t"
      ]
    },
    "group_map_read": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "void\ngroup_map_read (char const *file)\n{\n  map_read (&group_map, file, name_to_gid, \"GID\", TYPE_MAXIMUM (gid_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "group_map_translate": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "int\ngroup_map_translate (gid_t gid, gid_t *new_gid, char const **new_name)\n{\n  int rc = 1;\n  \n  if (group_map)\n    {\n      struct mapentry ent, *res;\n  \n      ent.orig_id = gid;\n      res = hash_lookup (group_map, &ent);\n      if (res)\n\t{\n\t  *new_gid = res->new_id;\n\t  *new_name = res->new_name;\n\t  return 0;\n\t}\n    }\n\n  if (group_option != (uid_t) -1)\n    {\n      *new_gid = group_option;\n      rc = 0;\n    }\n  if (group_name_option)\n    {\n      *new_name = group_name_option;\n      rc = 0;\n    }\n  \n  return rc;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/src/misc.c": {
    "quote_n_colon": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "char const *\nquote_n_colon (int n, char const *arg)\n{\n  return quotearg_n_style_colon (n, get_quoting_style (NULL), arg);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n_colon (int n, char const *arg)",
        "*"
      ]
    },
    "assign_string": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\nassign_string (char **string, const char *value)\n{\n  free (*string);\n  *string = value ? xstrdup (value) : 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "quote_copy_string": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static char *\nquote_copy_string (const char *string)\n{\n  const char *source = string;\n  char *destination = 0;\n  char *buffer = 0;\n  int copying = 0;\n\n  while (*source)\n    {\n      int character = *source++;\n\n      switch (character)\n\t{\n\tcase '\\n': case '\\\\':\n\t  if (!copying)\n\t    {\n\t      size_t length = (source - string) - 1;\n\n\t      copying = 1;\n\t      buffer = xmalloc (length + 2 + 2 * strlen (source) + 1);\n\t      memcpy (buffer, string, length);\n\t      destination = buffer + length;\n\t    }\n\t  *destination++ = '\\\\';\n\t  *destination++ = character == '\\\\' ? '\\\\' : 'n';\n\t  break;\n\n\tdefault:\n\t  if (copying)\n\t    *destination++ = character;\n\t  break;\n\t}\n    }\n  if (copying)\n    {\n      *destination = '\\0';\n      return buffer;\n    }\n  return 0;\n}",
      "lines": 41,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquote_copy_string (const char *string)",
        "*"
      ]
    },
    "unquote_string": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "int\nunquote_string (char *string)\n{\n  int result = 1;\n  char *source = string;\n  char *destination = string;\n\n  /* Escape sequences other than \\\\ and \\n are no longer generated by\n     quote_copy_string, but accept them for backwards compatibility,\n     and also because unquote_string is used for purposes other than\n     parsing the output of quote_copy_string.  */\n\n  while (*source)\n    if (*source == '\\\\')\n      switch (*++source)\n\t{\n\tcase '\\\\':\n\t  *destination++ = '\\\\';\n\t  source++;\n\t  break;\n\n\tcase 'a':\n\t  *destination++ = '\\a';\n\t  source++;\n\t  break;\n\n\tcase 'b':\n\t  *destination++ = '\\b';\n\t  source++;\n\t  break;\n\n\tcase 'f':\n\t  *destination++ = '\\f';\n\t  source++;\n\t  break;\n\n\tcase 'n':\n\t  *destination++ = '\\n';\n\t  source++;\n\t  break;\n\n\tcase 'r':\n\t  *destination++ = '\\r';\n\t  source++;\n\t  break;\n\n\tcase 't':\n\t  *destination++ = '\\t';\n\t  source++;\n\t  break;\n\n\tcase 'v':\n\t  *destination++ = '\\v';\n\t  source++;\n\t  break;\n\n\tcase '?':\n\t  *destination++ = 0177;\n\t  source++;\n\t  break;\n\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\t  {\n\t    int value = *source++ - '0';\n\n\t    if (*source < '0' || *source > '7')\n\t      {\n\t\t*destination++ = value;\n\t\tbreak;\n\t      }\n\t    value = value * 8 + *source++ - '0';\n\t    if (*source < '0' || *source > '7')\n\t      {\n\t\t*destination++ = value;\n\t\tbreak;\n\t      }\n\t    value = value * 8 + *source++ - '0';\n\t    *destination++ = value;\n\t    break;\n\t  }\n\n\tdefault:\n\t  result = 0;\n\t  *destination++ = '\\\\';\n\t  if (*source)\n\t    *destination++ = *source++;\n\t  break;\n\t}\n    else if (source != destination)\n      *destination++ = *source++;\n    else\n      source++, destination++;\n\n  if (source != destination)\n    *destination = '\\0';\n  return result;\n}",
      "lines": 104,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "zap_slashes": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "char *\nzap_slashes (char *name)\n{\n  char *q;\n\n  if (!name || *name == 0)\n    return name;\n  q = name + strlen (name) - 1;\n  while (q > name && ISSLASH (*q))\n    *q-- = '\\0';\n  return name;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "char",
        "*\nzap_slashes (char *name)",
        "*"
      ]
    },
    "normalize_filename_x": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "void\nnormalize_filename_x (char *file_name)\n{\n  char *name = file_name + FILE_SYSTEM_PREFIX_LEN (file_name);\n  char *p;\n  char const *q;\n  char c;\n\n  /* Don't squeeze leading \"//\" to \"/\", on hosts where they're distinct.  */\n  name += (DOUBLE_SLASH_IS_DISTINCT_ROOT\n\t   && ISSLASH (*name) && ISSLASH (name[1]) && ! ISSLASH (name[2]));\n\n  /* Omit redundant leading \".\" components.  */\n  for (q = p = name; (*p = *q) == '.' && ISSLASH (q[1]); p += !*q)\n    for (q += 2; ISSLASH (*q); q++)\n      continue;\n\n  /* Copy components from Q to P, omitting redundant slashes and\n     internal \".\"  components.  */\n  while ((*p++ = c = *q++) != '\\0')\n    if (ISSLASH (c))\n      while (ISSLASH (q[*q == '.']))\n\tq += (*q == '.') + 1;\n\n  /* Omit redundant trailing \".\" component and slash.  */\n  if (2 < p - name)\n    {\n      p -= p[-2] == '.' && ISSLASH (p[-3]);\n      p -= 2 < p - name && ISSLASH (p[-2]);\n      p[-1] = '\\0';\n    }\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "normalize_filename": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "char *\nnormalize_filename (int cdidx, const char *name)\n{\n  char *copy = NULL;\n\n  if (IS_RELATIVE_FILE_NAME (name))\n    {\n      /* Set COPY to the absolute path for this name.\n\n         FIXME: There should be no need to get the absolute file name.\n         tar_getcdpath does not return a true \"canonical\" path, so\n         this following approach may lead to situations where the same\n         file or directory is processed twice under different absolute\n         paths without that duplication being detected.  Perhaps we\n         should use dev+ino pairs instead of names?  (See listed03.at for\n         a related test case.) */\n      const char *cdpath = tar_getcdpath (cdidx);\n      size_t copylen;\n      bool need_separator;\n\n      if (!cdpath)\n\tcall_arg_fatal (\"getcwd\", \".\");\n      copylen = strlen (cdpath);\n      need_separator = ! (DOUBLE_SLASH_IS_DISTINCT_ROOT\n\t\t\t  && copylen == 2 && ISSLASH (cdpath[1]));\n      copy = xmalloc (copylen + need_separator + strlen (name) + 1);\n      strcpy (copy, cdpath);\n      copy[copylen] = DIRECTORY_SEPARATOR;\n      strcpy (copy + copylen + need_separator, name);\n    }\n\n  if (!copy)\n    copy = xstrdup (name);\n  normalize_filename_x (copy);\n  return copy;\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "char",
        "*\nnormalize_filename (int cdidx, const char *name)",
        "*"
      ]
    },
    "replace_prefix": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "void\nreplace_prefix (char **pname, const char *samp, size_t slen,\n\t\tconst char *repl, size_t rlen)\n{\n  char *name = *pname;\n  size_t nlen = strlen (name);\n  if (nlen > slen && memcmp (name, samp, slen) == 0 && ISSLASH (name[slen]))\n    {\n      if (rlen > slen)\n\t{\n\t  name = xrealloc (name, nlen - slen + rlen + 1);\n\t  *pname = name;\n\t}\n      memmove (name + rlen, name + slen, nlen - slen + 1);\n      memcpy (name, repl, rlen);\n    }\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "sysinttostr": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "char *\nsysinttostr (uintmax_t value, intmax_t minval, uintmax_t maxval,\n\t     char buf[SYSINT_BUFSIZE])\n{\n  if (value <= maxval)\n    return umaxtostr (value, buf);\n  else\n    {\n      intmax_t i = value - minval;\n      return imaxtostr (i + minval, buf);\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsysinttostr (uintmax_t value, intmax_t minval, uintmax_t maxval,\n\t     char buf[SYSINT_BUFSIZE])",
        "*"
      ]
    },
    "strtosysint": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "intmax_t\nstrtosysint (char const *arg, char **arglim, intmax_t minval, uintmax_t maxval)\n{\n  errno = 0;\n  if (maxval <= INTMAX_MAX)\n    {\n      if (ISDIGIT (arg[*arg == '-']))\n\t{\n\t  intmax_t i = strtoimax (arg, arglim, 10);\n\t  intmax_t imaxval = maxval;\n\t  if (minval <= i && i <= imaxval)\n\t    return i;\n\t  errno = ERANGE;\n\t  return i < minval ? minval : maxval;\n\t}\n    }\n  else\n    {\n      if (ISDIGIT (*arg))\n\t{\n\t  uintmax_t i = strtoumax (arg, arglim, 10);\n\t  if (i <= maxval)\n\t    return represent_uintmax (i);\n\t  errno = ERANGE;\n\t  return maxval;\n\t}\n    }\n\n  errno = EINVAL;\n  return 0;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "intmax_t"
      ]
    },
    "code_ns_fraction": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "void\ncode_ns_fraction (int ns, char *p)\n{\n  if (ns == 0)\n    *p = '\\0';\n  else\n    {\n      int i = 9;\n      *p++ = '.';\n\n      while (ns % 10 == 0)\n\t{\n\t  ns /= 10;\n\t  i--;\n\t}\n\n      p[i] = '\\0';\n\n      for (;;)\n\t{\n\t  p[--i] = '0' + ns % 10;\n\t  if (i == 0)\n\t    break;\n\t  ns /= 10;\n\t}\n    }\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "code_timespec": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        467,
        1
      ],
      "content": "char const *\ncode_timespec (struct timespec t, char sbuf[TIMESPEC_STRSIZE_BOUND])\n{\n  time_t s = t.tv_sec;\n  int ns = t.tv_nsec;\n  char *np;\n  bool negative = s < 0;\n\n  /* ignore invalid values of ns */\n  if (BILLION <= ns || ns < 0)\n    ns = 0;\n\n  if (negative && ns != 0)\n    {\n      s++;\n      ns = BILLION - ns;\n    }\n\n  np = umaxtostr (negative ? - (uintmax_t) s : (uintmax_t) s, sbuf + 1);\n  if (negative)\n    *--np = '-';\n  code_ns_fraction (ns, sbuf + UINTMAX_STRSIZE_BOUND);\n  return np;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ncode_timespec (struct timespec t, char sbuf[TIMESPEC_STRSIZE_BOUND])",
        "*"
      ]
    },
    "decode_timespec": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "struct timespec\ndecode_timespec (char const *arg, char **arg_lim, bool parse_fraction)\n{\n  time_t s = TYPE_MINIMUM (time_t);\n  int ns = -1;\n  char const *p = arg;\n  bool negative = *arg == '-';\n  struct timespec r;\n\n  if (! ISDIGIT (arg[negative]))\n    errno = EINVAL;\n  else\n    {\n      errno = 0;\n\n      if (negative)\n\t{\n\t  intmax_t i = strtoimax (arg, arg_lim, 10);\n\t  if (TYPE_SIGNED (time_t) ? TYPE_MINIMUM (time_t) <= i : 0 <= i)\n\t    s = i;\n\t  else\n\t    errno = ERANGE;\n\t}\n      else\n\t{\n\t  uintmax_t i = strtoumax (arg, arg_lim, 10);\n\t  if (i <= TYPE_MAXIMUM (time_t))\n\t    s = i;\n\t  else\n\t    errno = ERANGE;\n\t}\n\n      p = *arg_lim;\n      ns = 0;\n\n      if (parse_fraction && *p == '.')\n\t{\n\t  int digits = 0;\n\t  bool trailing_nonzero = false;\n\n\t  while (ISDIGIT (*++p))\n\t    if (digits < LOG10_BILLION)\n\t      digits++, ns = 10 * ns + (*p - '0');\n\t    else\n\t      trailing_nonzero |= *p != '0';\n\n\t  while (digits < LOG10_BILLION)\n\t    digits++, ns *= 10;\n\n\t  if (negative)\n\t    {\n\t      /* Convert \"-1.10000000000001\" to s == -2, ns == 89999999.\n\t\t I.e., truncate time stamps towards minus infinity while\n\t\t converting them to internal form.  */\n\t      ns += trailing_nonzero;\n\t      if (ns != 0)\n\t\t{\n\t\t  if (s == TYPE_MINIMUM (time_t))\n\t\t    ns = -1;\n\t\t  else\n\t\t    {\n\t\t      s--;\n\t\t      ns = BILLION - ns;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n      if (errno == ERANGE)\n\tns = -1;\n    }\n\n  *arg_lim = (char *) p;\n  r.tv_sec = s;\n  r.tv_nsec = ns;\n  return r;\n}",
      "lines": 77,
      "depth": 16,
      "decorators": [
        "struct timespec",
        "struct",
        "timespec"
      ]
    },
    "must_be_dot_or_slash": {
      "start_point": [
        554,
        0
      ],
      "end_point": [
        581,
        1
      ],
      "content": "bool\nmust_be_dot_or_slash (char const *file_name)\n{\n  file_name += FILE_SYSTEM_PREFIX_LEN (file_name);\n\n  if (ISSLASH (file_name[0]))\n    {\n      for (;;)\n\tif (ISSLASH (file_name[1]))\n\t  file_name++;\n\telse if (file_name[1] == '.'\n                 && ISSLASH (file_name[2 + (file_name[2] == '.')]))\n\t  file_name += 2 + (file_name[2] == '.');\n\telse\n\t  return ! file_name[1];\n    }\n  else\n    {\n      while (file_name[0] == '.' && ISSLASH (file_name[1]))\n\t{\n\t  file_name += 2;\n\t  while (ISSLASH (*file_name))\n\t    file_name++;\n\t}\n\n      return ! file_name[0] || (file_name[0] == '.' && ! file_name[1]);\n    }\n}",
      "lines": 28,
      "depth": 17,
      "decorators": [
        "bool"
      ]
    },
    "safer_rmdir": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        601,
        1
      ],
      "content": "static int\nsafer_rmdir (const char *file_name)\n{\n  if (must_be_dot_or_slash (file_name))\n    {\n      errno = 0;\n      return -1;\n    }\n\n  if (unlinkat (chdir_fd, file_name, AT_REMOVEDIR) == 0)\n    {\n      remove_delayed_set_stat (file_name);\n      return 0;\n    }\n  return -1;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "remove_any_file": {
      "start_point": [
        610,
        0
      ],
      "end_point": [
        686,
        1
      ],
      "content": "int\nremove_any_file (const char *file_name, enum remove_option option)\n{\n  /* Try unlink first if we cannot unlink directories, as this saves\n     us a system call in the common case where we're removing a\n     non-directory.  */\n  bool try_unlink_first = cannot_unlink_dir ();\n\n  if (try_unlink_first)\n    {\n      if (unlinkat (chdir_fd, file_name, 0) == 0)\n\treturn 1;\n\n      /* POSIX 1003.1-2001 requires EPERM when attempting to unlink a\n\t directory without appropriate privileges, but many Linux\n\t kernels return the more-sensible EISDIR.  */\n      if (errno != EPERM && errno != EISDIR)\n\treturn 0;\n    }\n\n  if (safer_rmdir (file_name) == 0)\n    return 1;\n\n  switch (errno)\n    {\n    case ENOTDIR:\n      return !try_unlink_first && unlinkat (chdir_fd, file_name, 0) == 0;\n\n    case 0:\n    case EEXIST:\n#if defined ENOTEMPTY && ENOTEMPTY != EEXIST\n    case ENOTEMPTY:\n#endif\n      switch (option)\n\t{\n\tcase ORDINARY_REMOVE_OPTION:\n\t  break;\n\n\tcase WANT_DIRECTORY_REMOVE_OPTION:\n\t  return -1;\n\n\tcase RECURSIVE_REMOVE_OPTION:\n\t  {\n\t    char *directory = tar_savedir (file_name, 0);\n\t    char const *entry;\n\t    size_t entrylen;\n\n\t    if (! directory)\n\t      return 0;\n\n\t    for (entry = directory;\n\t\t (entrylen = strlen (entry)) != 0;\n\t\t entry += entrylen + 1)\n\t      {\n\t\tchar *file_name_buffer = make_file_name (file_name, entry);\n\t\tint r = remove_any_file (file_name_buffer,\n                                         RECURSIVE_REMOVE_OPTION);\n\t\tint e = errno;\n\t\tfree (file_name_buffer);\n\n\t\tif (! r)\n\t\t  {\n\t\t    free (directory);\n\t\t    errno = e;\n\t\t    return 0;\n\t\t  }\n\t      }\n\n\t    free (directory);\n\t    return safer_rmdir (file_name) == 0;\n\t  }\n\t}\n      break;\n    }\n\n  return 0;\n}",
      "lines": 77,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "maybe_backup_file": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        752,
        1
      ],
      "content": "bool\nmaybe_backup_file (const char *file_name, bool this_is_the_archive)\n{\n  struct stat file_stat;\n\n  assign_string (&before_backup_name, file_name);\n\n  /* A run situation may exist between Emacs or other GNU programs trying to\n     make a backup for the same file simultaneously.  If theoretically\n     possible, real problems are unlikely.  Doing any better would require a\n     convention, GNU-wide, for all programs doing backups.  */\n\n  assign_string (&after_backup_name, 0);\n\n  /* Check if we really need to backup the file.  */\n\n  if (this_is_the_archive && _remdev (file_name))\n    return true;\n\n  if (deref_stat (file_name, &file_stat) != 0)\n    {\n      if (errno == ENOENT)\n\treturn true;\n\n      stat_error (file_name);\n      return false;\n    }\n\n  if (S_ISDIR (file_stat.st_mode))\n    return true;\n\n  if (this_is_the_archive\n      && (S_ISBLK (file_stat.st_mode) || S_ISCHR (file_stat.st_mode)))\n    return true;\n\n  after_backup_name = find_backup_file_name (file_name, backup_type);\n  if (! after_backup_name)\n    xalloc_die ();\n\n  if (renameat (chdir_fd, before_backup_name, chdir_fd, after_backup_name)\n      == 0)\n    {\n      if (verbose_option)\n\tfprintf (stdlis, _(\"Renaming %s to %s\\n\"),\n\t\t quote_n (0, before_backup_name),\n\t\t quote_n (1, after_backup_name));\n      return true;\n    }\n  else\n    {\n      /* The backup operation failed.  */\n      int e = errno;\n      ERROR ((0, e, _(\"%s: Cannot rename to %s\"),\n\t      quotearg_colon (before_backup_name),\n\t      quote_n (1, after_backup_name)));\n      assign_string (&after_backup_name, 0);\n      return false;\n    }\n}",
      "lines": 59,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "undo_last_backup": {
      "start_point": [
        756,
        0
      ],
      "end_point": [
        775,
        1
      ],
      "content": "void\nundo_last_backup (void)\n{\n  if (after_backup_name)\n    {\n      if (renameat (chdir_fd, after_backup_name, chdir_fd, before_backup_name)\n\t  != 0)\n\t{\n\t  int e = errno;\n\t  ERROR ((0, e, _(\"%s: Cannot rename to %s\"),\n\t\t  quotearg_colon (after_backup_name),\n\t\t  quote_n (1, before_backup_name)));\n\t}\n      if (verbose_option)\n\tfprintf (stdlis, _(\"Renaming %s back to %s\\n\"),\n\t\t quote_n (0, after_backup_name),\n\t\t quote_n (1, before_backup_name));\n      assign_string (&after_backup_name, 0);\n    }\n}",
      "lines": 20,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "deref_stat": {
      "start_point": [
        780,
        0
      ],
      "end_point": [
        784,
        1
      ],
      "content": "int\nderef_stat (char const *name, struct stat *buf)\n{\n  return fstatat (chdir_fd, name, buf, fstatat_flags);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "blocking_read": {
      "start_point": [
        792,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "size_t\nblocking_read (int fd, void *buf, size_t count)\n{\n  size_t bytes = safe_read (fd, buf, count);\n\n#if defined F_SETFL && O_NONBLOCK\n  if (bytes == SAFE_READ_ERROR && errno == EAGAIN)\n    {\n      int flags = fcntl (fd, F_GETFL);\n      if (0 <= flags && flags & O_NONBLOCK\n\t  && fcntl (fd, F_SETFL, flags & ~O_NONBLOCK) != -1)\n\tbytes = safe_read (fd, buf, count);\n    }\n#endif\n\n  return bytes;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "size_t"
      ]
    },
    "blocking_write": {
      "start_point": [
        816,
        0
      ],
      "end_point": [
        835,
        1
      ],
      "content": "size_t\nblocking_write (int fd, void const *buf, size_t count)\n{\n  size_t bytes = full_write (fd, buf, count);\n\n#if defined F_SETFL && O_NONBLOCK\n  if (bytes < count && errno == EAGAIN)\n    {\n      int flags = fcntl (fd, F_GETFL);\n      if (0 <= flags && flags & O_NONBLOCK\n\t  && fcntl (fd, F_SETFL, flags & ~O_NONBLOCK) != -1)\n\t{\n\t  char const *buffer = buf;\n\t  bytes += full_write (fd, buffer + bytes, count - bytes);\n\t}\n    }\n#endif\n\n  return bytes;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "size_t"
      ]
    },
    "set_file_atime": {
      "start_point": [
        839,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "int\nset_file_atime (int fd, int parentfd, char const *file, struct timespec atime)\n{\n  struct timespec ts[2];\n  ts[0] = atime;\n  ts[1].tv_nsec = UTIME_OMIT;\n  return fdutimensat (fd, parentfd, file, ts, fstatat_flags);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "chdir_count": {
      "start_point": [
        886,
        0
      ],
      "end_point": [
        892,
        1
      ],
      "content": "int\nchdir_count (void)\n{\n  if (wd_count == 0)\n    return wd_count;\n  return wd_count - 1;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "chdir_arg": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "int\nchdir_arg (char const *dir)\n{\n  char *absdir;\n\n  if (wd_count == wd_alloc)\n    {\n      if (wd_alloc == 0)\n\twd_alloc = 2;\n      wd = x2nrealloc (wd, &wd_alloc, sizeof *wd);\n\n      if (! wd_count)\n\t{\n\t  wd[wd_count].name = \".\";\n\t  wd[wd_count].abspath = xgetcwd ();\n\t  wd[wd_count].fd = AT_FDCWD;\n\t  wd_count++;\n\t}\n    }\n\n  /* Optimize the common special case of the working directory,\n     or the working directory as a prefix.  */\n  if (dir[0])\n    {\n      while (dir[0] == '.' && ISSLASH (dir[1]))\n\tfor (dir += 2;  ISSLASH (*dir);  dir++)\n\t  continue;\n      if (! dir[dir[0] == '.'])\n\treturn wd_count - 1;\n    }\n\n\n  /* If the given name is absolute, use it to represent this directory;\n     otherwise, construct a name based on the previous -C option.  */\n  if (IS_ABSOLUTE_FILE_NAME (dir))\n    absdir = xstrdup (dir);\n  else if (wd[wd_count - 1].abspath)\n    {\n      namebuf_t nbuf = namebuf_create (wd[wd_count - 1].abspath);\n      namebuf_add_dir (nbuf, dir);\n      absdir = namebuf_finish (nbuf);\n    }\n  else\n    absdir = 0;\n\n  wd[wd_count].name = dir;\n  wd[wd_count].abspath = absdir;\n  wd[wd_count].fd = 0;\n  return wd_count++;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "chdir_do": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        1014,
        1
      ],
      "content": "void\nchdir_do (int i)\n{\n  if (chdir_current != i)\n    {\n      struct wd *curr = &wd[i];\n      int fd = curr->fd;\n\n      if (! fd)\n\t{\n\t  if (! IS_ABSOLUTE_FILE_NAME (curr->name))\n\t    chdir_do (i - 1);\n\t  fd = openat (chdir_fd, curr->name,\n\t\t       open_searchdir_flags & ~ O_NOFOLLOW);\n\t  if (fd < 0)\n\t    open_fatal (curr->name);\n\n\t  curr->fd = fd;\n\n\t  /* Add I to the cache, tossing out the lowest-ranking entry if the\n\t     cache is full.  */\n\t  if (wdcache_count < CHDIR_CACHE_SIZE)\n\t    wdcache[wdcache_count++] = i;\n\t  else\n\t    {\n\t      struct wd *stale = &wd[wdcache[CHDIR_CACHE_SIZE - 1]];\n\t      if (close (stale->fd) != 0)\n\t\tclose_diag (stale->name);\n\t      stale->fd = 0;\n\t      wdcache[CHDIR_CACHE_SIZE - 1] = i;\n\t    }\n\t}\n\n      if (0 < fd)\n\t{\n\t  /* Move the i value to the front of the cache.  This is\n\t     O(CHDIR_CACHE_SIZE), but the cache is small.  */\n\t  size_t ci;\n\t  int prev = wdcache[0];\n\t  for (ci = 1; prev != i; ci++)\n\t    {\n\t      int cur = wdcache[ci];\n\t      wdcache[ci] = prev;\n\t      if (cur == i)\n\t\tbreak;\n\t      prev = cur;\n\t    }\n\t  wdcache[0] = i;\n\t}\n\n      chdir_current = i;\n      chdir_fd = fd;\n    }\n}",
      "lines": 54,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "tar_dirname": {
      "start_point": [
        1016,
        0
      ],
      "end_point": [
        1020,
        1
      ],
      "content": "const char *\ntar_dirname (void)\n{\n  return wd[chdir_current].name;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ntar_dirname (void)",
        "*"
      ]
    },
    "tar_getcdpath": {
      "start_point": [
        1029,
        0
      ],
      "end_point": [
        1040,
        1
      ],
      "content": "static const char *\ntar_getcdpath (int idx)\n{\n  if (!wd)\n    {\n      static char *cwd;\n      if (!cwd)\n\tcwd = xgetcwd ();\n      return cwd;\n    }\n  return wd[idx].abspath;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ntar_getcdpath (int idx)",
        "*"
      ]
    },
    "close_diag": {
      "start_point": [
        1042,
        0
      ],
      "end_point": [
        1052,
        1
      ],
      "content": "void\nclose_diag (char const *name)\n{\n  if (ignore_failed_read_option)\n    {\n      if (WARNING_ENABLED(WARN_FAILED_READ))\n\tclose_warn (name);\n    }\n  else\n    close_error (name);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "open_diag": {
      "start_point": [
        1054,
        0
      ],
      "end_point": [
        1064,
        1
      ],
      "content": "void\nopen_diag (char const *name)\n{\n  if (ignore_failed_read_option)\n    {\n      if (WARNING_ENABLED(WARN_FAILED_READ))\n\topen_warn (name);\n    }\n  else\n    open_error (name);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "read_diag_details": {
      "start_point": [
        1066,
        0
      ],
      "end_point": [
        1076,
        1
      ],
      "content": "void\nread_diag_details (char const *name, off_t offset, size_t size)\n{\n  if (ignore_failed_read_option)\n    {\n      if (WARNING_ENABLED(WARN_FAILED_READ))\n\tread_warn_details (name, offset, size);\n    }\n  else\n    read_error_details (name, offset, size);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "readlink_diag": {
      "start_point": [
        1078,
        0
      ],
      "end_point": [
        1088,
        1
      ],
      "content": "void\nreadlink_diag (char const *name)\n{\n  if (ignore_failed_read_option)\n    {\n      if (WARNING_ENABLED(WARN_FAILED_READ))\n\treadlink_warn (name);\n    }\n  else\n    readlink_error (name);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "savedir_diag": {
      "start_point": [
        1090,
        0
      ],
      "end_point": [
        1100,
        1
      ],
      "content": "void\nsavedir_diag (char const *name)\n{\n  if (ignore_failed_read_option)\n    {\n      if (WARNING_ENABLED(WARN_FAILED_READ))\n\tsavedir_warn (name);\n    }\n  else\n    savedir_error (name);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "seek_diag_details": {
      "start_point": [
        1102,
        0
      ],
      "end_point": [
        1112,
        1
      ],
      "content": "void\nseek_diag_details (char const *name, off_t offset)\n{\n  if (ignore_failed_read_option)\n    {\n      if (WARNING_ENABLED(WARN_FAILED_READ))\n\tseek_warn_details (name, offset);\n    }\n  else\n    seek_error_details (name, offset);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "stat_diag": {
      "start_point": [
        1114,
        0
      ],
      "end_point": [
        1124,
        1
      ],
      "content": "void\nstat_diag (char const *name)\n{\n  if (ignore_failed_read_option)\n    {\n      if (WARNING_ENABLED(WARN_FAILED_READ))\n\tstat_warn (name);\n    }\n  else\n    stat_error (name);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "file_removed_diag": {
      "start_point": [
        1126,
        0
      ],
      "end_point": [
        1139,
        1
      ],
      "content": "void\nfile_removed_diag (const char *name, bool top_level,\n\t\t   void (*diagfn) (char const *name))\n{\n  if (!top_level && errno == ENOENT)\n    {\n      WARNOPT (WARN_FILE_REMOVED,\n\t       (0, 0, _(\"%s: File removed before we read it\"),\n\t\tquotearg_colon (name)));\n      set_exit_status (TAREXIT_DIFFERS);\n    }\n  else\n    diagfn (name);\n}",
      "lines": 14,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "xfork": {
      "start_point": [
        1142,
        0
      ],
      "end_point": [
        1149,
        1
      ],
      "content": "pid_t\nxfork (void)\n{\n  pid_t p = fork ();\n  if (p == (pid_t) -1)\n    call_arg_fatal (\"fork\", _(\"child process\"));\n  return p;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "pid_t"
      ]
    },
    "xpipe": {
      "start_point": [
        1152,
        0
      ],
      "end_point": [
        1157,
        1
      ],
      "content": "void\nxpipe (int fd[2])\n{\n  if (pipe (fd) < 0)\n    call_arg_fatal (\"pipe\", _(\"interprocess channel\"));\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ptr_align": {
      "start_point": [
        1164,
        0
      ],
      "end_point": [
        1170,
        1
      ],
      "content": "static inline void *\nptr_align (void *ptr, size_t alignment)\n{\n  char *p0 = ptr;\n  char *p1 = p0 + alignment - 1;\n  return p1 - (size_t) p1 % alignment;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "*\nptr_align (void *ptr, size_t alignment)",
        "*"
      ]
    },
    "page_aligned_alloc": {
      "start_point": [
        1175,
        0
      ],
      "end_point": [
        1184,
        1
      ],
      "content": "void *\npage_aligned_alloc (void **ptr, size_t size)\n{\n  size_t alignment = getpagesize ();\n  size_t size1 = size + alignment;\n  if (size1 < size)\n    xalloc_die ();\n  *ptr = xmalloc (size1);\n  return ptr_align (*ptr, alignment);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void",
        "*\npage_aligned_alloc (void **ptr, size_t size)",
        "*"
      ]
    },
    "namebuf_create": {
      "start_point": [
        1195,
        0
      ],
      "end_point": [
        1206,
        1
      ],
      "content": "namebuf_t\nnamebuf_create (const char *dir)\n{\n  namebuf_t buf = xmalloc (sizeof (*buf));\n  buf->buffer_size = strlen (dir) + 2;\n  buf->buffer = xmalloc (buf->buffer_size);\n  strcpy (buf->buffer, dir);\n  buf->dir_length = strlen (buf->buffer);\n  if (!ISSLASH (buf->buffer[buf->dir_length - 1]))\n    buf->buffer[buf->dir_length++] = DIRECTORY_SEPARATOR;\n  return buf;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "namebuf_t"
      ]
    },
    "namebuf_free": {
      "start_point": [
        1208,
        0
      ],
      "end_point": [
        1213,
        1
      ],
      "content": "void\nnamebuf_free (namebuf_t buf)\n{\n  free (buf->buffer);\n  free (buf);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "namebuf_name": {
      "start_point": [
        1215,
        0
      ],
      "end_point": [
        1223,
        1
      ],
      "content": "char *\nnamebuf_name (namebuf_t buf, const char *name)\n{\n  size_t len = strlen (name);\n  while (buf->dir_length + len + 1 >= buf->buffer_size)\n    buf->buffer = x2realloc (buf->buffer, &buf->buffer_size);\n  strcpy (buf->buffer + buf->dir_length, name);\n  return buf->buffer;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "char",
        "*\nnamebuf_name (namebuf_t buf, const char *name)",
        "*"
      ]
    },
    "namebuf_add_dir": {
      "start_point": [
        1225,
        0
      ],
      "end_point": [
        1236,
        1
      ],
      "content": "static void\nnamebuf_add_dir (namebuf_t buf, const char *name)\n{\n  static char dirsep[] = { DIRECTORY_SEPARATOR, 0 };\n  if (!ISSLASH (buf->buffer[buf->dir_length - 1]))\n    {\n      namebuf_name (buf, dirsep);\n      buf->dir_length++;\n    }\n  namebuf_name (buf, name);\n  buf->dir_length += strlen (name);\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "namebuf_finish": {
      "start_point": [
        1238,
        0
      ],
      "end_point": [
        1247,
        1
      ],
      "content": "static char *\nnamebuf_finish (namebuf_t buf)\n{\n  char *res = buf->buffer;\n\n  if (ISSLASH (buf->buffer[buf->dir_length - 1]))\n    buf->buffer[buf->dir_length] = 0;\n  free (buf);\n  return res;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nnamebuf_finish (namebuf_t buf)",
        "*"
      ]
    },
    "tar_savedir": {
      "start_point": [
        1255,
        0
      ],
      "end_point": [
        1275,
        1
      ],
      "content": "char *\ntar_savedir (const char *name, int must_exist)\n{\n  char *ret = NULL;\n  DIR *dir = NULL;\n  int fd = openat (chdir_fd, name, open_read_flags | O_DIRECTORY);\n  if (fd < 0)\n    {\n      if (!must_exist && errno == ENOENT)\n\treturn NULL;\n      open_error (name);\n    }\n  else if (! ((dir = fdopendir (fd))\n\t      && (ret = streamsavedir (dir, savedir_sort_order))))\n    savedir_error (name);\n\n  if (dir ? closedir (dir) != 0 : 0 <= fd && close (fd) != 0)\n    savedir_error (name);\n\n  return ret;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "char",
        "*\ntar_savedir (const char *name, int must_exist)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/src/names.c": {
    "file_selection_option": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static struct argp_option const *\nfile_selection_option (int key)\n{\n  struct argp_option *p;\n\n  for (p = names_options;\n       !(p->name == NULL && p->key == 0 && p->doc == NULL); p++)\n    if (p->key == key)\n      return p;\n  return NULL;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct argp_option",
        "struct",
        "argp_option",
        "const",
        "const",
        "*\nfile_selection_option (int key)",
        "*"
      ]
    },
    "file_selection_option_name": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static char const *\nfile_selection_option_name (int key)\n{\n  struct argp_option const *opt = file_selection_option (key);\n  return opt ? opt->name : NULL;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nfile_selection_option_name (int key)",
        "*"
      ]
    },
    "is_file_selection_option": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "static bool\nis_file_selection_option (int key)\n{\n  return file_selection_option (key) != NULL;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "names_parse_opt": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static error_t\nnames_parse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case 'C':\n      name_add_dir (arg);\n      break;\n\n    case 'T':\n      name_add_file (arg);\n      break;\n\n    case ADD_FILE_OPTION:\n      name_add_name (arg);\n      break;\n\n    default:\n      if (is_file_selection_option (key))\n\tname_add_option (key, arg);\n      else\n\treturn ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "add_exclude_array": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static void\nadd_exclude_array (char const * const * fv, int opts)\n{\n  int i;\n\n  for (i = 0; fv[i]; i++)\n    add_exclude (excluded, fv[i], opts);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "handle_file_selection_option": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        420,
        1
      ],
      "content": "static void\nhandle_file_selection_option (int key, const char *arg)\n{\n  switch (key)\n    {\n    case EXCLUDE_BACKUPS_OPTION:\n      add_exclude_array (backup_file_table, EXCLUDE_WILDCARDS);\n      break;\n\n    case EXCLUDE_OPTION:\n      add_exclude (excluded, arg, EXCLUDE_OPTIONS);\n      break;\n\n    case EXCLUDE_CACHES_OPTION:\n      add_exclusion_tag (\"CACHEDIR.TAG\", exclusion_tag_contents,\n\t\t\t cachedir_file_p);\n      break;\n\n    case EXCLUDE_CACHES_UNDER_OPTION:\n      add_exclusion_tag (\"CACHEDIR.TAG\", exclusion_tag_under,\n\t\t\t cachedir_file_p);\n      break;\n\n    case EXCLUDE_CACHES_ALL_OPTION:\n      add_exclusion_tag (\"CACHEDIR.TAG\", exclusion_tag_all,\n\t\t\t cachedir_file_p);\n      break;\n\n    case EXCLUDE_IGNORE_OPTION:\n      excfile_add (arg, EXCL_NON_RECURSIVE);\n      break;\n\n    case EXCLUDE_IGNORE_RECURSIVE_OPTION:\n      excfile_add (arg, EXCL_RECURSIVE);\n      break;\n\n    case EXCLUDE_TAG_OPTION:\n      add_exclusion_tag (arg, exclusion_tag_contents, NULL);\n      break;\n\n    case EXCLUDE_TAG_UNDER_OPTION:\n      add_exclusion_tag (arg, exclusion_tag_under, NULL);\n      break;\n\n    case EXCLUDE_TAG_ALL_OPTION:\n      add_exclusion_tag (arg, exclusion_tag_all, NULL);\n      break;\n\n    case EXCLUDE_VCS_OPTION:\n      add_exclude_array (vcs_file_table, 0);\n      break;\n\n    case EXCLUDE_VCS_IGNORES_OPTION:\n      exclude_vcs_ignores ();\n      break;\n\n    case RECURSION_OPTION:\n      recursion_option = FNM_LEADING_DIR;\n      break;\n\n    case NO_RECURSION_OPTION:\n      recursion_option = 0;\n      break;\n\n    case UNQUOTE_OPTION:\n      unquote_option = true;\n      break;\n\n    case NO_UNQUOTE_OPTION:\n      unquote_option = false;\n      break;\n\n    case NULL_OPTION:\n      filename_terminator = '\\0';\n      verbatim_files_from_option = true;\n      break;\n\n    case NO_NULL_OPTION:\n      filename_terminator = '\\n';\n      verbatim_files_from_option = false;\n      break;\n\n    case 'X':\n      if (add_exclude_file (add_exclude, excluded, arg, EXCLUDE_OPTIONS, '\\n')\n\t  != 0)\n\t{\n\t  int e = errno;\n\t  FATAL_ERROR ((0, e, \"%s\", quotearg_colon (arg)));\n\t}\n      break;\n\n    case ANCHORED_OPTION:\n      matching_flags |= EXCLUDE_ANCHORED;\n      break;\n\n    case NO_ANCHORED_OPTION:\n      include_anchored = 0; /* Clear the default for comman line args */\n      matching_flags &= ~ EXCLUDE_ANCHORED;\n      break;\n\n    case IGNORE_CASE_OPTION:\n      matching_flags |= FNM_CASEFOLD;\n      break;\n\n    case NO_IGNORE_CASE_OPTION:\n      matching_flags &= ~ FNM_CASEFOLD;\n      break;\n\n    case WILDCARDS_OPTION:\n      wildcards = enable_wildcards;\n      break;\n\n    case NO_WILDCARDS_OPTION:\n      wildcards = disable_wildcards;\n      break;\n\n    case WILDCARDS_MATCH_SLASH_OPTION:\n      matching_flags &= ~ FNM_FILE_NAME;\n      break;\n\n    case NO_WILDCARDS_MATCH_SLASH_OPTION:\n      matching_flags |= FNM_FILE_NAME;\n      break;\n\n    case VERBATIM_FILES_FROM_OPTION:\n      verbatim_files_from_option = true;\n      break;\n\n    case NO_VERBATIM_FILES_FROM_OPTION:\n      verbatim_files_from_option = false;\n      break;\n\n    default:\n      FATAL_ERROR ((0, 0, \"unhandled positional option %d\", key));\n    }\n}",
      "lines": 136,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uid_to_uname": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "void\nuid_to_uname (uid_t uid, char **uname)\n{\n  struct passwd *passwd;\n\n  if (uid != 0 && uid == cached_no_such_uid)\n    {\n      *uname = xstrdup (\"\");\n      return;\n    }\n\n  if (!cached_uname || uid != cached_uid)\n    {\n      passwd = getpwuid (uid);\n      if (passwd)\n\t{\n\t  cached_uid = uid;\n\t  assign_string (&cached_uname, passwd->pw_name);\n\t}\n      else\n\t{\n\t  cached_no_such_uid = uid;\n\t  *uname = xstrdup (\"\");\n\t  return;\n\t}\n    }\n  *uname = xstrdup (cached_uname);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "gid_to_gname": {
      "start_point": [
        490,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "void\ngid_to_gname (gid_t gid, char **gname)\n{\n  struct group *group;\n\n  if (gid != 0 && gid == cached_no_such_gid)\n    {\n      *gname = xstrdup (\"\");\n      return;\n    }\n\n  if (!cached_gname || gid != cached_gid)\n    {\n      group = getgrgid (gid);\n      if (group)\n\t{\n\t  cached_gid = gid;\n\t  assign_string (&cached_gname, group->gr_name);\n\t}\n      else\n\t{\n\t  cached_no_such_gid = gid;\n\t  *gname = xstrdup (\"\");\n\t  return;\n\t}\n    }\n  *gname = xstrdup (cached_gname);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "uname_to_uid": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "int\nuname_to_uid (char const *uname, uid_t *uidp)\n{\n  struct passwd *passwd;\n\n  if (cached_no_such_uname\n      && strcmp (uname, cached_no_such_uname) == 0)\n    return 0;\n\n  if (!cached_uname\n      || uname[0] != cached_uname[0]\n      || strcmp (uname, cached_uname) != 0)\n    {\n      passwd = getpwnam (uname);\n      if (passwd)\n\t{\n\t  cached_uid = passwd->pw_uid;\n\t  assign_string (&cached_uname, passwd->pw_name);\n\t}\n      else\n\t{\n\t  assign_string (&cached_no_such_uname, uname);\n\t  return 0;\n\t}\n    }\n  *uidp = cached_uid;\n  return 1;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "gname_to_gid": {
      "start_point": [
        550,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "int\ngname_to_gid (char const *gname, gid_t *gidp)\n{\n  struct group *group;\n\n  if (cached_no_such_gname\n      && strcmp (gname, cached_no_such_gname) == 0)\n    return 0;\n\n  if (!cached_gname\n      || gname[0] != cached_gname[0]\n      || strcmp (gname, cached_gname) != 0)\n    {\n      group = getgrnam (gname);\n      if (group)\n\t{\n\t  cached_gid = group->gr_gid;\n\t  assign_string (&cached_gname, gname);\n\t}\n      else\n\t{\n\t  assign_string (&cached_no_such_gname, gname);\n\t  return 0;\n\t}\n    }\n  *gidp = cached_gid;\n  return 1;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "make_name": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        589,
        1
      ],
      "content": "static struct name *\nmake_name (const char *file_name)\n{\n  struct name *p = xzalloc (sizeof (*p));\n  if (!file_name)\n    file_name = \"\";\n  p->name = xstrdup (file_name);\n  p->length = strlen (p->name);\n  return p;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct name",
        "struct",
        "name",
        "*\nmake_name (const char *file_name)",
        "*"
      ]
    },
    "free_name": {
      "start_point": [
        591,
        0
      ],
      "end_point": [
        600,
        1
      ],
      "content": "static void\nfree_name (struct name *p)\n{\n  if (p)\n    {\n      free (p->name);\n      free (p->caname);\n      free (p);\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "name_elt_alloc": {
      "start_point": [
        657,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "static struct name_elt *\nname_elt_alloc (void)\n{\n  struct name_elt *elt;\n\n  elt = xmalloc (sizeof (*elt));\n  if (!name_head)\n    {\n      name_head = elt;\n      name_head->prev = name_head->next = NULL;\n      name_head->type = NELT_NOOP;\n      elt = xmalloc (sizeof (*elt));\n    }\n\n  elt->prev = name_head->prev;\n  if (name_head->prev)\n    name_head->prev->next = elt;\n  elt->next = name_head;\n  name_head->prev = elt;\n  return elt;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct name_elt",
        "struct",
        "name_elt",
        "*\nname_elt_alloc (void)",
        "*"
      ]
    },
    "name_list_adjust": {
      "start_point": [
        679,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "static void\nname_list_adjust (void)\n{\n  if (name_head)\n    while (name_head->prev)\n      name_head = name_head->prev;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unconsumed_option_push": {
      "start_point": [
        702,
        0
      ],
      "end_point": [
        710,
        1
      ],
      "content": "static void\nunconsumed_option_push (struct name_elt *elt)\n{\n  elt->next = NULL;\n  elt->prev = unconsumed_option_tail;\n  if (unconsumed_option_tail)\n    unconsumed_option_tail->next = elt;\n  unconsumed_option_tail = elt;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unconsumed_option_free": {
      "start_point": [
        713,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "static void\nunconsumed_option_free (void)\n{\n  while (unconsumed_option_tail)\n    {\n      struct name_elt *elt = unconsumed_option_tail;\n      unconsumed_option_tail = unconsumed_option_tail->prev;\n      free (elt);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unconsumed_option_report": {
      "start_point": [
        725,
        0
      ],
      "end_point": [
        764,
        1
      ],
      "content": "static void\nunconsumed_option_report (void)\n{\n  if (unconsumed_option_tail)\n    {\n      struct name_elt *elt;\n\n      ERROR ((0, 0, _(\"The following options were used after any non-optional arguments in archive create or update mode.  These options are positional and affect only arguments that follow them.  Please, rearrange them properly.\")));\n\n      elt = unconsumed_option_tail;\n      while (elt->prev)\n\telt = elt->prev;\n\n      while (elt)\n\t{\n\t  switch (elt->type)\n\t    {\n\t    case NELT_CHDIR:\n\t      ERROR ((0, 0, _(\"-C %s has no effect\"), quote (elt->v.name)));\n\t      break;\n\n\t    case NELT_OPTION:\n\t      if (elt->v.opt.arg)\n\t\tERROR ((0, 0, _(\"--%s %s has no effect\"),\n\t\t\tfile_selection_option_name (elt->v.opt.option),\n\t\t\tquote (elt->v.opt.arg)));\n\t      else\n\t\tERROR ((0, 0, _(\"--%s has no effect\"),\n\t\t\tfile_selection_option_name (elt->v.opt.option)));\n\t      break;\n\n\t    default:\n\t      break;\n\t    }\n\t  elt = elt->next;\n\t}\n\n      unconsumed_option_free ();\n    }\n}",
      "lines": 40,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "name_list_advance": {
      "start_point": [
        766,
        0
      ],
      "end_point": [
        785,
        1
      ],
      "content": "static void\nname_list_advance (void)\n{\n  struct name_elt *elt = name_head;\n  name_head = elt->next;\n  if (name_head)\n    name_head->prev = NULL;\n  if (elt->type == NELT_OPTION || elt->type == NELT_CHDIR)\n    {\n      if (subcommand_option == CREATE_SUBCOMMAND\n\t  || subcommand_option == UPDATE_SUBCOMMAND)\n\tunconsumed_option_push (elt);\n    }\n  else\n    {\n      if (elt->type != NELT_NOOP)\n\tunconsumed_option_free ();\n      free (elt);\n    }\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "name_more_files": {
      "start_point": [
        788,
        0
      ],
      "end_point": [
        792,
        1
      ],
      "content": "bool\nname_more_files (void)\n{\n  return name_count > 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "bool"
      ]
    },
    "name_add_name": {
      "start_point": [
        795,
        0
      ],
      "end_point": [
        803,
        1
      ],
      "content": "void\nname_add_name (const char *name)\n{\n  struct name_elt *ep = name_elt_alloc ();\n\n  ep->type = NELT_NAME;\n  ep->v.name = name;\n  name_count++;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "name_add_option": {
      "start_point": [
        805,
        0
      ],
      "end_point": [
        812,
        1
      ],
      "content": "static void\nname_add_option (int option, const char *arg)\n{\n  struct name_elt *elt = name_elt_alloc ();\n  elt->type = NELT_OPTION;\n  elt->v.opt.option = option;\n  elt->v.opt.arg = arg;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "name_add_dir": {
      "start_point": [
        815,
        0
      ],
      "end_point": [
        821,
        1
      ],
      "content": "static void\nname_add_dir (const char *name)\n{\n  struct name_elt *ep = name_elt_alloc ();\n  ep->type = NELT_CHDIR;\n  ep->v.name = name;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "name_add_file": {
      "start_point": [
        823,
        0
      ],
      "end_point": [
        833,
        1
      ],
      "content": "static void\nname_add_file (const char *name)\n{\n  struct name_elt *ep = name_elt_alloc ();\n\n  ep->type = NELT_FILE;\n  ep->v.file.name = name;\n  ep->v.file.line = 0;\n  ep->v.file.fp = NULL;\n  name_count++;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "name_init": {
      "start_point": [
        842,
        0
      ],
      "end_point": [
        848,
        1
      ],
      "content": "void\nname_init (void)\n{\n  name_buffer = xmalloc (NAME_FIELD_SIZE + 2);\n  name_buffer_length = NAME_FIELD_SIZE;\n  name_list_adjust ();\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "name_term": {
      "start_point": [
        850,
        0
      ],
      "end_point": [
        854,
        1
      ],
      "content": "void\nname_term (void)\n{\n  free (name_buffer);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "file_list_name": {
      "start_point": [
        870,
        0
      ],
      "end_point": [
        879,
        1
      ],
      "content": "static const char *\nfile_list_name (void)\n{\n  struct name_elt *elt;\n\n  for (elt = name_head; elt; elt = elt->next)\n    if (elt->type == NELT_FILE && elt->v.file.fp)\n      return elt->v.file.name;\n  return _(\"command line\");\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nfile_list_name (void)",
        "*"
      ]
    },
    "add_file_id": {
      "start_point": [
        881,
        0
      ],
      "end_point": [
        909,
        1
      ],
      "content": "static int\nadd_file_id (const char *filename)\n{\n  struct file_id_list *p;\n  struct stat st;\n  const char *reading_from;\n\n  if (stat (filename, &st))\n    stat_fatal (filename);\n  reading_from = file_list_name ();\n  for (p = file_id_list; p; p = p->next)\n    if (p->ino == st.st_ino && p->dev == st.st_dev)\n      {\n\tint oldc = set_char_quoting (NULL, ':', 1);\n\tERROR ((0, 0,\n\t\t_(\"%s: file list requested from %s already read from %s\"),\n\t\tquotearg_n (0, filename),\n\t\treading_from, p->from_file));\n\tset_char_quoting (NULL, ':', oldc);\n\treturn 1;\n      }\n  p = xmalloc (sizeof *p);\n  p->next = file_id_list;\n  p->ino = st.st_ino;\n  p->dev = st.st_dev;\n  p->from_file = reading_from;\n  file_id_list = p;\n  return 0;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "chopslash": {
      "start_point": [
        912,
        0
      ],
      "end_point": [
        918,
        1
      ],
      "content": "static void\nchopslash (char *str)\n{\n  char *p = str + strlen (str) - 1;\n  while (p > str && ISSLASH (*p))\n    *p-- = '\\0';\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_name_from_file": {
      "start_point": [
        931,
        0
      ],
      "end_point": [
        961,
        1
      ],
      "content": "static enum read_file_list_state\nread_name_from_file (struct name_elt *ent)\n{\n  int c;\n  size_t counter = 0;\n  FILE *fp = ent->v.file.fp;\n  int term = ent->v.file.term;\n\n  ++ent->v.file.line;\n  for (c = getc (fp); c != EOF && c != term; c = getc (fp))\n    {\n      if (counter == name_buffer_length)\n\tname_buffer = x2realloc (name_buffer, &name_buffer_length);\n      name_buffer[counter++] = c;\n      if (c == 0)\n\t{\n\t  /* We have read a zero separator. The file possibly is\n\t     zero-separated */\n\t  return file_list_zero;\n\t}\n    }\n\n  if (counter == 0 && c != EOF)\n    return file_list_skip;\n\n  if (counter == name_buffer_length)\n    name_buffer = x2realloc (name_buffer, &name_buffer_length);\n  name_buffer[counter] = 0;\n  chopslash (name_buffer);\n  return (counter == 0 && c == EOF) ? file_list_end : file_list_success;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "enum read_file_list_state",
        "enum",
        "read_file_list_state"
      ]
    },
    "handle_option": {
      "start_point": [
        963,
        0
      ],
      "end_point": [
        989,
        1
      ],
      "content": "static int\nhandle_option (const char *str, struct name_elt const *ent)\n{\n  struct wordsplit ws;\n  int i;\n  struct option_locus loc;\n\n  while (*str && isspace (*str))\n    ++str;\n  if (*str != '-')\n    return 1;\n\n  ws.ws_offs = 1;\n  if (wordsplit (str, &ws, WRDSF_DEFFLAGS|WRDSF_DOOFFS))\n    FATAL_ERROR ((0, 0, _(\"cannot split string '%s': %s\"),\n\t\t  str, wordsplit_strerror (&ws)));\n  ws.ws_wordv[0] = (char *) program_name;\n  loc.source = OPTS_FILE;\n  loc.name = ent->v.file.name;\n  loc.line = ent->v.file.line;\n  more_options (ws.ws_wordc+ws.ws_offs, ws.ws_wordv, &loc);\n  for (i = 0; i < ws.ws_wordc+ws.ws_offs; i++)\n    ws.ws_wordv[i] = NULL;\n\n  wordsplit_free (&ws);\n  return 0;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_next_name": {
      "start_point": [
        991,
        0
      ],
      "end_point": [
        1051,
        1
      ],
      "content": "static int\nread_next_name (struct name_elt *ent, struct name_elt *ret)\n{\n  if (!ent->v.file.fp)\n    {\n      if (!strcmp (ent->v.file.name, \"-\"))\n\t{\n\t  request_stdin (\"-T\");\n\t  ent->v.file.fp = stdin;\n\t}\n      else\n\t{\n\t  if (add_file_id (ent->v.file.name))\n\t    {\n\t      name_list_advance ();\n\t      return 1;\n\t    }\n\t  if ((ent->v.file.fp = fopen (ent->v.file.name, \"r\")) == NULL)\n\t    open_fatal (ent->v.file.name);\n\t}\n      ent->v.file.term = filename_terminator;\n      ent->v.file.verbatim = verbatim_files_from_option;\n    }\n\n  while (1)\n    {\n      switch (read_name_from_file (ent))\n\t{\n\tcase file_list_skip:\n\t  continue;\n\n\tcase file_list_zero:\n\t  WARNOPT (WARN_FILENAME_WITH_NULS,\n\t\t   (0, 0, N_(\"%s: file name read contains nul character\"),\n\t\t    quotearg_colon (ent->v.file.name)));\n\t  ent->v.file.term = 0;\n\t  FALLTHROUGH;\n\tcase file_list_success:\n\t  if (!ent->v.file.verbatim)\n\t    {\n\t      if (unquote_option)\n\t\tunquote_string (name_buffer);\n\t      if (handle_option (name_buffer, ent) == 0)\n\t\t{\n\t\t  name_list_adjust ();\n\t\t  return 1;\n\t\t}\n\t    }\n\t  ret->type = NELT_NAME;\n\t  ret->v.name = name_buffer;\n\t  return 0;\n\n\tcase file_list_end:\n\t  if (strcmp (ent->v.file.name, \"-\"))\n\t    fclose (ent->v.file.fp);\n\t  ent->v.file.fp = NULL;\n\t  name_list_advance ();\n\t  return 1;\n\t}\n    }\n}",
      "lines": 61,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "copy_name": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1076,
        1
      ],
      "content": "static void\ncopy_name (struct name_elt *ep)\n{\n  const char *source;\n  size_t source_len;\n\n  source = ep->v.name;\n  source_len = strlen (source);\n  if (name_buffer_length < source_len)\n    {\n      do\n\t{\n\t  name_buffer_length *= 2;\n\t  if (! name_buffer_length)\n\t    xalloc_die ();\n\t}\n      while (name_buffer_length < source_len);\n\n      free (name_buffer);\n      name_buffer = xmalloc(name_buffer_length + 2);\n    }\n  strcpy (name_buffer, source);\n  chopslash (name_buffer);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "name_next_elt": {
      "start_point": [
        1086,
        0
      ],
      "end_point": [
        1132,
        1
      ],
      "content": "static struct name_elt *\nname_next_elt (int change_dirs)\n{\n  static struct name_elt entry;\n  struct name_elt *ep;\n\n  while ((ep = name_head) != NULL)\n    {\n      switch (ep->type)\n\t{\n\tcase NELT_NOOP:\n\t  name_list_advance ();\n\t  break;\n\n\tcase NELT_FILE:\n\t  if (read_next_name (ep, &entry) == 0)\n\t    return &entry;\n\t  continue;\n\n\tcase NELT_CHDIR:\n\t  if (change_dirs)\n\t    {\n\t      chdir_do (chdir_arg (xstrdup (ep->v.name)));\n\t      name_list_advance ();\n\t      break;\n\t    }\n\t  FALLTHROUGH;\n\tcase NELT_NAME:\n\t  copy_name (ep);\n\t  if (unquote_option)\n\t    unquote_string (name_buffer);\n\t  entry.type = ep->type;\n\t  entry.v.name = name_buffer;\n\t  name_list_advance ();\n\t  return &entry;\n\n\tcase NELT_OPTION:\n\t  handle_file_selection_option (ep->v.opt.option, ep->v.opt.arg);\n\t  name_list_advance ();\n\t  continue;\n\t}\n    }\n\n  unconsumed_option_report ();\n\n  return NULL;\n}",
      "lines": 47,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "struct name_elt",
        "struct",
        "name_elt",
        "*\nname_next_elt (int change_dirs)",
        "*"
      ]
    },
    "name_next": {
      "start_point": [
        1134,
        0
      ],
      "end_point": [
        1139,
        1
      ],
      "content": "const char *\nname_next (int change_dirs)\n{\n  struct name_elt *nelt = name_next_elt (change_dirs);\n  return nelt ? nelt->v.name : NULL;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nname_next (int change_dirs)",
        "*"
      ]
    },
    "name_gather": {
      "start_point": [
        1151,
        0
      ],
      "end_point": [
        1204,
        1
      ],
      "content": "void\nname_gather (void)\n{\n  /* Buffer able to hold a single name.  */\n  static struct name *buffer = NULL;\n\n  struct name_elt *ep;\n\n  if (same_order_option)\n    {\n      static int change_dir;\n\n      while ((ep = name_next_elt (0)) && ep->type == NELT_CHDIR)\n\tchange_dir = chdir_arg (xstrdup (ep->v.name));\n\n      if (ep)\n\t{\n\t  free_name (buffer);\n\t  buffer = make_name (ep->v.name);\n\t  buffer->change_dir = change_dir;\n\t  buffer->next = 0;\n\t  buffer->found_count = 0;\n\t  buffer->matching_flags = INCLUDE_OPTIONS;\n\t  buffer->directory = NULL;\n\t  buffer->parent = NULL;\n\t  buffer->cmdline = true;\n\n\t  namelist = nametail = buffer;\n\t}\n      else if (change_dir)\n\taddname (0, change_dir, false, NULL);\n    }\n  else\n    {\n      /* Non sorted names -- read them all in.  */\n      int change_dir = 0;\n\n      for (;;)\n\t{\n\t  int change_dir0 = change_dir;\n\t  while ((ep = name_next_elt (0)) && ep->type == NELT_CHDIR)\n\t    change_dir = chdir_arg (xstrdup (ep->v.name));\n\n\t  if (ep)\n\t    addname (ep->v.name, change_dir, true, NULL);\n\t  else\n\t    {\n\t      if (change_dir != change_dir0)\n\t\taddname (NULL, change_dir, false, NULL);\n\t      break;\n\t    }\n\t}\n    }\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "addname": {
      "start_point": [
        1207,
        0
      ],
      "end_point": [
        1227,
        1
      ],
      "content": "struct name *\naddname (char const *string, int change_dir, bool cmdline, struct name *parent)\n{\n  struct name *name = make_name (string);\n\n  name->prev = nametail;\n  name->next = NULL;\n  name->found_count = 0;\n  name->matching_flags = INCLUDE_OPTIONS;\n  name->change_dir = change_dir;\n  name->directory = NULL;\n  name->parent = parent;\n  name->cmdline = cmdline;\n\n  if (nametail)\n    nametail->next = name;\n  else\n    namelist = name;\n  nametail = name;\n  return name;\n}",
      "lines": 21,
      "depth": 7,
      "decorators": [
        "struct name",
        "struct",
        "name",
        "*\naddname (char const *string, int change_dir, bool cmdline, struct name *parent)",
        "*"
      ]
    },
    "namelist_match": {
      "start_point": [
        1231,
        0
      ],
      "end_point": [
        1244,
        1
      ],
      "content": "static struct name *\nnamelist_match (char const *file_name, size_t length)\n{\n  struct name *p;\n\n  for (p = namelist; p; p = p->next)\n    {\n      if (p->name[0]\n\t  && exclude_fnmatch (p->name, file_name, p->matching_flags))\n\treturn p;\n    }\n\n  return NULL;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct name",
        "struct",
        "name",
        "*\nnamelist_match (char const *file_name, size_t length)",
        "*"
      ]
    },
    "remname": {
      "start_point": [
        1246,
        0
      ],
      "end_point": [
        1260,
        1
      ],
      "content": "void\nremname (struct name *name)\n{\n  struct name *p;\n\n  if ((p = name->prev) != NULL)\n    p->next = name->next;\n  else\n    namelist = name->next;\n\n  if ((p = name->next) != NULL)\n    p->prev = name->prev;\n  else\n    nametail = name->prev;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "name_match": {
      "start_point": [
        1264,
        0
      ],
      "end_point": [
        1316,
        1
      ],
      "content": "bool\nname_match (const char *file_name)\n{\n  size_t length = strlen (file_name);\n\n  while (1)\n    {\n      struct name *cursor = namelist;\n\n      if (!cursor)\n\treturn true;\n\n      if (cursor->name[0] == 0)\n\t{\n\t  chdir_do (cursor->change_dir);\n\t  namelist = NULL;\n\t  nametail = NULL;\n\t  return true;\n\t}\n\n      cursor = namelist_match (file_name, length);\n      if (cursor)\n\t{\n\t  if (!(ISSLASH (file_name[cursor->length]) && recursion_option)\n\t      || cursor->found_count == 0)\n\t    cursor->found_count++; /* remember it matched */\n\t  if (starting_file_option)\n\t    {\n\t      free (namelist);\n\t      namelist = NULL;\n\t      nametail = NULL;\n\t    }\n\t  chdir_do (cursor->change_dir);\n\n\t  /* We got a match.  */\n\t  return ISFOUND (cursor);\n\t}\n\n      /* Filename from archive not found in namelist.  If we have the whole\n\t namelist here, just return 0.  Otherwise, read the next name in and\n\t compare it.  If this was the last name, namelist->found_count will\n\t remain on.  If not, we loop to compare the newly read name.  */\n\n      if (same_order_option && namelist->found_count)\n\t{\n\t  name_gather ();\t/* read one more */\n\t  if (namelist->found_count)\n\t    return false;\n\t}\n      else\n\treturn false;\n    }\n}",
      "lines": 53,
      "depth": 17,
      "decorators": [
        "bool"
      ]
    },
    "all_names_found": {
      "start_point": [
        1327,
        0
      ],
      "end_point": [
        1343,
        1
      ],
      "content": "bool\nall_names_found (struct tar_stat_info *p)\n{\n  struct name const *cursor;\n  size_t len;\n\n  if (!p->file_name || occurrence_option == 0 || p->had_trailing_slash)\n    return false;\n  len = strlen (p->file_name);\n  for (cursor = namelist; cursor; cursor = cursor->next)\n    {\n      if ((cursor->name[0] && !WASFOUND (cursor))\n\t  || (len >= cursor->length && ISSLASH (p->file_name[cursor->length])))\n\treturn false;\n    }\n  return true;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "regex_usage_warning": {
      "start_point": [
        1345,
        0
      ],
      "end_point": [
        1363,
        1
      ],
      "content": "static int\nregex_usage_warning (const char *name)\n{\n  static int warned_once = 0;\n\n  /* Warn about implicit use of the wildcards in command line arguments.\n     (Default for tar prior to 1.15.91, but changed afterwards) */\n  if (wildcards == default_wildcards\n      && fnmatch_pattern_has_wildcards (name, 0))\n    {\n      warned_once = 1;\n      WARN ((0, 0,\n\t     _(\"Pattern matching characters used in file names\")));\n      WARN ((0, 0,\n\t     _(\"Use --wildcards to enable pattern matching,\"\n\t       \" or --no-wildcards to suppress this warning\")));\n    }\n  return warned_once;\n}",
      "lines": 19,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "names_notfound": {
      "start_point": [
        1366,
        0
      ],
      "end_point": [
        1397,
        1
      ],
      "content": "void\nnames_notfound (void)\n{\n  struct name const *cursor;\n\n  for (cursor = namelist; cursor; cursor = cursor->next)\n    if (!WASFOUND (cursor) && cursor->name[0])\n      {\n\tregex_usage_warning (cursor->name);\n\tERROR ((0, 0,\n\t\t(cursor->found_count == 0) ?\n\t\t     _(\"%s: Not found in archive\") :\n\t\t     _(\"%s: Required occurrence not found in archive\"),\n\t\tquotearg_colon (cursor->name)));\n      }\n\n  /* Don't bother freeing the name list; we're about to exit.  */\n  namelist = NULL;\n  nametail = NULL;\n\n  if (same_order_option)\n    {\n      const char *name;\n\n      while ((name = name_next (1)) != NULL)\n\t{\n\t  regex_usage_warning (name);\n\t  ERROR ((0, 0, _(\"%s: Not found in archive\"),\n\t\t  quotearg_colon (name)));\n\t}\n    }\n}",
      "lines": 32,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "label_notfound": {
      "start_point": [
        1399,
        0
      ],
      "end_point": [
        1433,
        1
      ],
      "content": "void\nlabel_notfound (void)\n{\n  struct name const *cursor;\n\n  if (!namelist)\n    return;\n\n  for (cursor = namelist; cursor; cursor = cursor->next)\n    if (WASFOUND (cursor))\n      return;\n\n  if (verbose_option)\n    error (0, 0, _(\"Archive label mismatch\"));\n  set_exit_status (TAREXIT_DIFFERS);\n\n  for (cursor = namelist; cursor; cursor = cursor->next)\n    {\n      if (regex_usage_warning (cursor->name))\n\tbreak;\n    }\n\n  /* Don't bother freeing the name list; we're about to exit.  */\n  namelist = NULL;\n  nametail = NULL;\n\n  if (same_order_option)\n    {\n      const char *name;\n\n      while ((name = name_next (1)) != NULL\n\t     && regex_usage_warning (name) == 0)\n\t;\n    }\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "merge_sort_sll": {
      "start_point": [
        1446,
        0
      ],
      "end_point": [
        1513,
        1
      ],
      "content": "static struct name *\nmerge_sort_sll (struct name *list, int length,\n\t\tint (*compare) (struct name const*, struct name const*))\n{\n  struct name *first_list;\n  struct name *second_list;\n  int first_length;\n  int second_length;\n  struct name *result;\n  struct name **merge_point;\n  struct name *cursor;\n  int counter;\n\n# define SUCCESSOR(name) ((name)->next)\n\n  if (length == 1)\n    return list;\n\n  if (length == 2)\n    {\n      if ((*compare) (list, SUCCESSOR (list)) > 0)\n\t{\n\t  result = SUCCESSOR (list);\n\t  SUCCESSOR (result) = list;\n\t  SUCCESSOR (list) = 0;\n\t  return result;\n\t}\n      return list;\n    }\n\n  first_list = list;\n  first_length = (length + 1) / 2;\n  second_length = length / 2;\n  for (cursor = list, counter = first_length - 1;\n       counter;\n       cursor = SUCCESSOR (cursor), counter--)\n    continue;\n  second_list = SUCCESSOR (cursor);\n  SUCCESSOR (cursor) = 0;\n\n  first_list = merge_sort_sll (first_list, first_length, compare);\n  second_list = merge_sort_sll (second_list, second_length, compare);\n\n  merge_point = &result;\n  while (first_list && second_list)\n    if ((*compare) (first_list, second_list) < 0)\n      {\n\tcursor = SUCCESSOR (first_list);\n\t*merge_point = first_list;\n\tmerge_point = &SUCCESSOR (first_list);\n\tfirst_list = cursor;\n      }\n    else\n      {\n\tcursor = SUCCESSOR (second_list);\n\t*merge_point = second_list;\n\tmerge_point = &SUCCESSOR (second_list);\n\tsecond_list = cursor;\n      }\n  if (first_list)\n    *merge_point = first_list;\n  else\n    *merge_point = second_list;\n\n  return result;\n\n#undef SUCCESSOR\n}",
      "lines": 68,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct name",
        "struct",
        "name",
        "*\nmerge_sort_sll (struct name *list, int length,\n\t\tint (*compare) (struct name const*, struct name const*))",
        "*"
      ]
    },
    "merge_sort": {
      "start_point": [
        1517,
        0
      ],
      "end_point": [
        1527,
        1
      ],
      "content": "static struct name *\nmerge_sort (struct name *list, int length,\n\t    int (*compare) (struct name const*, struct name const*))\n{\n  struct name *head, *p, *prev;\n  head = merge_sort_sll (list, length, compare);\n  /* Fixup prev pointers */\n  for (prev = NULL, p = head; p; prev = p, p = p->next)\n    p->prev = prev;\n  return head;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct name",
        "struct",
        "name",
        "*\nmerge_sort (struct name *list, int length,\n\t    int (*compare) (struct name const*, struct name const*))",
        "*"
      ]
    },
    "compare_names_found": {
      "start_point": [
        1532,
        0
      ],
      "end_point": [
        1537,
        1
      ],
      "content": "static int\ncompare_names_found (struct name const *n1, struct name const *n2)\n{\n  int found_diff = WASFOUND (n2) - WASFOUND (n1);\n  return found_diff ? found_diff : strcmp (n1->name, n2->name);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "compare_names": {
      "start_point": [
        1540,
        0
      ],
      "end_point": [
        1544,
        1
      ],
      "content": "static int\ncompare_names (struct name const *n1, struct name const *n2)\n{\n  return strcmp (n1->name, n2->name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "add_hierarchy_to_namelist": {
      "start_point": [
        1550,
        0
      ],
      "end_point": [
        1643,
        1
      ],
      "content": "static void\nadd_hierarchy_to_namelist (struct tar_stat_info *st, struct name *name)\n{\n  const char *buffer;\n\n  name->directory = scan_directory (st);\n  buffer = directory_contents (name->directory);\n  if (buffer)\n    {\n      struct name *child_head = NULL, *child_tail = NULL;\n      size_t name_length = name->length;\n      size_t allocated_length = (name_length >= NAME_FIELD_SIZE\n\t\t\t\t ? name_length + NAME_FIELD_SIZE\n\t\t\t\t : NAME_FIELD_SIZE);\n      char *namebuf = xmalloc (allocated_length + 1);\n\t\t\t\t/* FIXME: + 2 above?  */\n      const char *string;\n      size_t string_length;\n      int change_dir = name->change_dir;\n\n      strcpy (namebuf, name->name);\n      if (! ISSLASH (namebuf[name_length - 1]))\n\t{\n\t  namebuf[name_length++] = '/';\n\t  namebuf[name_length] = '\\0';\n\t}\n\n      for (string = buffer; *string; string += string_length + 1)\n\t{\n\t  string_length = strlen (string);\n\t  if (*string == 'D')\n\t    {\n\t      struct name *np;\n\t      struct tar_stat_info subdir;\n\t      int subfd;\n\n\t      if (allocated_length <= name_length + string_length)\n\t\t{\n\t\t  do\n\t\t    {\n\t\t      allocated_length *= 2;\n\t\t      if (! allocated_length)\n\t\t\txalloc_die ();\n\t\t    }\n\t\t  while (allocated_length <= name_length + string_length);\n\n\t\t  namebuf = xrealloc (namebuf, allocated_length + 1);\n\t\t}\n\t      strcpy (namebuf + name_length, string + 1);\n\t      np = addname (namebuf, change_dir, false, name);\n\t      if (!child_head)\n\t\tchild_head = np;\n\t      else\n\t\tchild_tail->sibling = np;\n\t      child_tail = np;\n\n\t      tar_stat_init (&subdir);\n\t      subdir.parent = st;\n\t      if (st->fd < 0)\n\t\t{\n\t\t  subfd = -1;\n\t\t  errno = - st->fd;\n\t\t}\n\t      else\n\t\tsubfd = subfile_open (st, string + 1,\n\t\t\t\t      open_read_flags | O_DIRECTORY);\n\t      if (subfd < 0)\n\t\topen_diag (namebuf);\n\t      else\n\t\t{\n\t\t  subdir.fd = subfd;\n\t\t  if (fstat (subfd, &subdir.stat) != 0)\n\t\t    stat_diag (namebuf);\n\t\t  else if (! (O_DIRECTORY || S_ISDIR (subdir.stat.st_mode)))\n\t\t    {\n\t\t      errno = ENOTDIR;\n\t\t      open_diag (namebuf);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      subdir.orig_file_name = xstrdup (namebuf);\n\t\t      add_hierarchy_to_namelist (&subdir, np);\n\t\t      restore_parent_fd (&subdir);\n\t\t    }\n\t\t}\n\n\t      tar_stat_destroy (&subdir);\n\t    }\n\t}\n\n      free (namebuf);\n      name->child = child_head;\n    }\n}",
      "lines": 94,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "name_hash": {
      "start_point": [
        1647,
        0
      ],
      "end_point": [
        1652,
        1
      ],
      "content": "static size_t\nname_hash (void const *entry, size_t n_buckets)\n{\n  struct name const *name = entry;\n  return hash_string (name->caname, n_buckets);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "name_compare": {
      "start_point": [
        1655,
        0
      ],
      "end_point": [
        1661,
        1
      ],
      "content": "static bool\nname_compare (void const *entry1, void const *entry2)\n{\n  struct name const *name1 = entry1;\n  struct name const *name2 = entry2;\n  return strcmp (name1->caname, name2->caname) == 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rebase_child_list": {
      "start_point": [
        1666,
        0
      ],
      "end_point": [
        1687,
        1
      ],
      "content": "static void\nrebase_child_list (struct name *child, struct name *parent)\n{\n  size_t old_prefix_len = child->parent->length;\n  size_t new_prefix_len = parent->length;\n  char *new_prefix = parent->name;\n\n  for (; child; child = child->sibling)\n    {\n      size_t size = child->length - old_prefix_len + new_prefix_len;\n      char *newp = xmalloc (size + 1);\n      strcpy (newp, new_prefix);\n      strcat (newp, child->name + old_prefix_len);\n      free (child->name);\n      child->name = newp;\n      child->length = size;\n\n      rebase_directory (child->directory,\n\t\t\tchild->parent->name, old_prefix_len,\n\t\t\tnew_prefix, new_prefix_len);\n    }\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "collect_and_sort_names": {
      "start_point": [
        1693,
        0
      ],
      "end_point": [
        1828,
        1
      ],
      "content": "void\ncollect_and_sort_names (void)\n{\n  struct name *name;\n  struct name *next_name, *prev_name = NULL;\n  int num_names;\n  Hash_table *nametab;\n\n  name_gather ();\n\n  if (!namelist)\n    addname (\".\", 0, false, NULL);\n\n  if (listed_incremental_option)\n    {\n      switch (chdir_count ())\n\t{\n\tcase 0:\n\t  break;\n\n\tcase 1:\n\t  if (namelist->change_dir == 0)\n\t    USAGE_ERROR ((0, 0,\n\t\t\t  _(\"Using -C option inside file list is not \"\n\t\t\t    \"allowed with --listed-incremental\")));\n\t  break;\n\n\tdefault:\n\t  USAGE_ERROR ((0, 0,\n\t\t\t_(\"Only one -C option is allowed with \"\n\t\t\t  \"--listed-incremental\")));\n\t}\n\n      read_directory_file ();\n    }\n\n  num_names = 0;\n  for (name = namelist; name; name = name->next, num_names++)\n    {\n      struct tar_stat_info st;\n\n      if (name->found_count || name->directory)\n\tcontinue;\n      if (name->matching_flags & EXCLUDE_WILDCARDS)\n\t/* NOTE: EXCLUDE_ANCHORED is not relevant here */\n\t/* FIXME: just skip regexps for now */\n\tcontinue;\n      chdir_do (name->change_dir);\n\n      if (name->name[0] == 0)\n\tcontinue;\n\n      tar_stat_init (&st);\n\n      if (deref_stat (name->name, &st.stat) != 0)\n\t{\n\t  stat_diag (name->name);\n\t  continue;\n\t}\n      if (S_ISDIR (st.stat.st_mode))\n\t{\n\t  int dir_fd = openat (chdir_fd, name->name,\n\t\t\t       open_read_flags | O_DIRECTORY);\n\t  if (dir_fd < 0)\n\t    open_diag (name->name);\n\t  else\n\t    {\n\t      st.fd = dir_fd;\n\t      if (fstat (dir_fd, &st.stat) != 0)\n\t\tstat_diag (name->name);\n\t      else if (O_DIRECTORY || S_ISDIR (st.stat.st_mode))\n\t\t{\n\t\t  st.orig_file_name = xstrdup (name->name);\n\t\t  name->found_count++;\n\t\t  add_hierarchy_to_namelist (&st, name);\n\t\t}\n\t    }\n\t}\n\n      tar_stat_destroy (&st);\n    }\n\n  namelist = merge_sort (namelist, num_names, compare_names);\n\n  num_names = 0;\n  nametab = hash_initialize (0, 0, name_hash, name_compare, NULL);\n  for (name = namelist; name; name = next_name)\n    {\n      next_name = name->next;\n      name->caname = normalize_filename (name->change_dir, name->name);\n      if (prev_name)\n\t{\n\t  struct name *p = hash_lookup (nametab, name);\n\t  if (p)\n\t    {\n\t      /* Keep the one listed in the command line */\n\t      if (!name->parent)\n\t\t{\n\t\t  if (p->child)\n\t\t    rebase_child_list (p->child, name);\n\t\t  hash_delete (nametab, name);\n\t\t  /* FIXME: remove_directory (p->caname); ? */\n\t\t  remname (p);\n\t\t  free_name (p);\n\t\t  num_names--;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (name->child)\n\t\t    rebase_child_list (name->child, p);\n\t\t  /* FIXME: remove_directory (name->caname); ? */\n\t\t  remname (name);\n\t\t  free_name (name);\n\t\t  continue;\n\t\t}\n\t    }\n\t}\n      name->found_count = 0;\n      if (!hash_insert (nametab, name))\n\txalloc_die ();\n      prev_name = name;\n      num_names++;\n    }\n  nametail = prev_name;\n  hash_free (nametab);\n\n  namelist = merge_sort (namelist, num_names, compare_names_found);\n\n  if (listed_incremental_option)\n    {\n      for (name = namelist; name && name->name[0] == 0; name++)\n\t;\n      if (name)\n\tappend_incremental_renames (name->directory);\n    }\n}",
      "lines": 136,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "name_scan": {
      "start_point": [
        1835,
        0
      ],
      "end_point": [
        1860,
        1
      ],
      "content": "struct name *\nname_scan (const char *file_name)\n{\n  size_t length = strlen (file_name);\n\n  while (1)\n    {\n      struct name *cursor = namelist_match (file_name, length);\n      if (cursor)\n\treturn cursor;\n\n      /* Filename from archive not found in namelist.  If we have the whole\n\t namelist here, just return 0.  Otherwise, read the next name in and\n\t compare it.  If this was the last name, namelist->found_count will\n\t remain on.  If not, we loop to compare the newly read name.  */\n\n      if (same_order_option && namelist && namelist->found_count)\n\t{\n\t  name_gather ();\t/* read one more */\n\t  if (namelist->found_count)\n\t    return 0;\n\t}\n      else\n\treturn 0;\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "struct name",
        "struct",
        "name",
        "*\nname_scan (const char *file_name)",
        "*"
      ]
    },
    "name_from_list": {
      "start_point": [
        1867,
        0
      ],
      "end_point": [
        1882,
        1
      ],
      "content": "struct name const *\nname_from_list (void)\n{\n  if (!gnu_list_name)\n    gnu_list_name = namelist;\n  while (gnu_list_name\n\t && (gnu_list_name->found_count || gnu_list_name->name[0] == 0))\n    gnu_list_name = gnu_list_name->next;\n  if (gnu_list_name)\n    {\n      gnu_list_name->found_count++;\n      chdir_do (gnu_list_name->change_dir);\n      return gnu_list_name;\n    }\n  return NULL;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "struct name",
        "struct",
        "name",
        "const",
        "const",
        "*\nname_from_list (void)",
        "*"
      ]
    },
    "blank_name_list": {
      "start_point": [
        1884,
        0
      ],
      "end_point": [
        1892,
        1
      ],
      "content": "void\nblank_name_list (void)\n{\n  struct name *name;\n\n  gnu_list_name = 0;\n  for (name = namelist; name; name = name->next)\n    name->found_count = 0;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "make_file_name": {
      "start_point": [
        1896,
        0
      ],
      "end_point": [
        1907,
        1
      ],
      "content": "char *\nmake_file_name (const char *directory_name, const char *name)\n{\n  size_t dirlen = strlen (directory_name);\n  size_t namelen = strlen (name) + 1;\n  int slash = dirlen && ! ISSLASH (directory_name[dirlen - 1]);\n  char *buffer = xmalloc (dirlen + slash + namelen);\n  memcpy (buffer, directory_name, dirlen);\n  buffer[dirlen] = '/';\n  memcpy (buffer + dirlen + slash, name, namelen);\n  return buffer;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "char",
        "*\nmake_file_name (const char *directory_name, const char *name)",
        "*"
      ]
    },
    "stripped_prefix_len": {
      "start_point": [
        1915,
        0
      ],
      "end_point": [
        1934,
        1
      ],
      "content": "size_t\nstripped_prefix_len (char const *file_name, size_t num)\n{\n  char const *p = file_name + FILE_SYSTEM_PREFIX_LEN (file_name);\n  while (ISSLASH (*p))\n    p++;\n  while (*p)\n    {\n      bool slash = ISSLASH (*p);\n      p++;\n      if (slash)\n\t{\n\t  if (--num == 0)\n\t    return p - file_name;\n\t  while (ISSLASH (*p))\n\t    p++;\n\t}\n    }\n  return -1;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "contains_dot_dot": {
      "start_point": [
        1937,
        0
      ],
      "end_point": [
        1953,
        1
      ],
      "content": "bool\ncontains_dot_dot (char const *name)\n{\n  char const *p = name + FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (;; p++)\n    {\n      if (p[0] == '.' && p[1] == '.' && (ISSLASH (p[2]) || !p[2]))\n\treturn 1;\n\n      while (! ISSLASH (*p))\n\t{\n\t  if (! *p++)\n\t    return 0;\n\t}\n    }\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    }
  },
  "tar/tar-1.30/src/sparse.c": {
    "dump_zeros": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static bool\ndump_zeros (struct tar_sparse_file *file, off_t offset)\n{\n  static char const zero_buf[BLOCKSIZE];\n\n  if (offset < file->offset)\n    {\n      errno = EINVAL;\n      return false;\n    }\n\n  while (file->offset < offset)\n    {\n      size_t size = (BLOCKSIZE < offset - file->offset\n\t\t     ? BLOCKSIZE\n\t\t     : offset - file->offset);\n      ssize_t wrbytes;\n\n      wrbytes = write (file->fd, zero_buf, size);\n      if (wrbytes <= 0)\n\t{\n\t  if (wrbytes == 0)\n\t    errno = EINVAL;\n\t  return false;\n\t}\n      file->offset += wrbytes;\n    }\n\n  return true;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tar_sparse_member_p": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static bool\ntar_sparse_member_p (struct tar_sparse_file *file)\n{\n  if (file->optab->sparse_member_p)\n    return file->optab->sparse_member_p (file);\n  return false;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tar_sparse_init": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static bool\ntar_sparse_init (struct tar_sparse_file *file)\n{\n  memset (file, 0, sizeof *file);\n\n  if (!sparse_select_optab (file))\n    return false;\n\n  if (file->optab->init)\n    return file->optab->init (file);\n\n  return true;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tar_sparse_done": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static bool\ntar_sparse_done (struct tar_sparse_file *file)\n{\n  if (file->optab->done)\n    return file->optab->done (file);\n  return true;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tar_sparse_scan": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static bool\ntar_sparse_scan (struct tar_sparse_file *file, enum sparse_scan_state state,\n\t\t void *block)\n{\n  if (file->optab->scan_block)\n    return file->optab->scan_block (file, state, block);\n  return true;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tar_sparse_dump_region": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static bool\ntar_sparse_dump_region (struct tar_sparse_file *file, size_t i)\n{\n  if (file->optab->dump_region)\n    return file->optab->dump_region (file, i);\n  return false;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tar_sparse_extract_region": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static bool\ntar_sparse_extract_region (struct tar_sparse_file *file, size_t i)\n{\n  if (file->optab->extract_region)\n    return file->optab->extract_region (file, i);\n  return false;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tar_sparse_dump_header": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static bool\ntar_sparse_dump_header (struct tar_sparse_file *file)\n{\n  if (file->optab->dump_header)\n    return file->optab->dump_header (file);\n  return false;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tar_sparse_decode_header": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static bool\ntar_sparse_decode_header (struct tar_sparse_file *file)\n{\n  if (file->optab->decode_header)\n    return file->optab->decode_header (file);\n  return true;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tar_sparse_fixup_header": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static bool\ntar_sparse_fixup_header (struct tar_sparse_file *file)\n{\n  if (file->optab->fixup_header)\n    return file->optab->fixup_header (file);\n  return true;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "lseek_or_error": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static bool\nlseek_or_error (struct tar_sparse_file *file, off_t offset)\n{\n  if (file->seekable\n      ? lseek (file->fd, offset, SEEK_SET) < 0\n      : ! dump_zeros (file, offset))\n    {\n      seek_diag_details (file->stat_info->orig_file_name, offset);\n      return false;\n    }\n  return true;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "zero_block_p": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static bool\nzero_block_p (char const *buffer, size_t size)\n{\n  while (size--)\n    if (*buffer++)\n      return false;\n  return true;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "sparse_add_map": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static void\nsparse_add_map (struct tar_stat_info *st, struct sp_array const *sp)\n{\n  struct sp_array *sparse_map = st->sparse_map;\n  size_t avail = st->sparse_map_avail;\n  if (avail == st->sparse_map_size)\n    st->sparse_map = sparse_map =\n      x2nrealloc (sparse_map, &st->sparse_map_size, sizeof *sparse_map);\n  sparse_map[avail] = *sp;\n  st->sparse_map_avail = avail + 1;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_scan_file_raw": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "static bool\nsparse_scan_file_raw (struct tar_sparse_file *file)\n{\n  struct tar_stat_info *st = file->stat_info;\n  int fd = file->fd;\n  char buffer[BLOCKSIZE];\n  size_t count = 0;\n  off_t offset = 0;\n  struct sp_array sp = {0, 0};\n\n  st->archive_file_size = 0;\n\n  if (!tar_sparse_scan (file, scan_begin, NULL))\n    return false;\n\n  while ((count = blocking_read (fd, buffer, sizeof buffer)) != 0\n         && count != SAFE_READ_ERROR)\n    {\n      /* Analyze the block.  */\n      if (zero_block_p (buffer, count))\n        {\n          if (sp.numbytes)\n            {\n              sparse_add_map (st, &sp);\n              sp.numbytes = 0;\n              if (!tar_sparse_scan (file, scan_block, NULL))\n                return false;\n            }\n        }\n      else\n        {\n          if (sp.numbytes == 0)\n            sp.offset = offset;\n          sp.numbytes += count;\n          st->archive_file_size += count;\n          if (!tar_sparse_scan (file, scan_block, buffer))\n            return false;\n        }\n\n      offset += count;\n    }\n\n  /* save one more sparse segment of length 0 to indicate that\n     the file ends with a hole */\n  if (sp.numbytes == 0)\n    sp.offset = offset;\n\n  sparse_add_map (st, &sp);\n  st->archive_file_size += count;\n  return tar_sparse_scan (file, scan_end, NULL);\n}",
      "lines": 51,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "sparse_scan_file_wholesparse": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "static bool\nsparse_scan_file_wholesparse (struct tar_sparse_file *file)\n{\n  struct tar_stat_info *st = file->stat_info;\n  struct sp_array sp = {0, 0};\n\n  /* Note that this function is called only for truly sparse files of size >= 1\n     block size (checked via ST_IS_SPARSE before).  See the thread\n     http://www.mail-archive.com/bug-tar@gnu.org/msg04209.html for more info */\n  if (ST_NBLOCKS (st->stat) == 0)\n    {\n      st->archive_file_size = 0;\n      sp.offset = st->stat.st_size;\n      sparse_add_map (st, &sp);\n      return true;\n    }\n\n  return false;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "sparse_scan_file_seek": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "static bool\nsparse_scan_file_seek (struct tar_sparse_file *file)\n{\n  struct tar_stat_info *st = file->stat_info;\n  int fd = file->fd;\n  struct sp_array sp = {0, 0};\n  off_t offset = 0;\n  off_t data_offset;\n  off_t hole_offset;\n\n  st->archive_file_size = 0;\n\n  for (;;)\n    {\n      /* locate first chunk of data */\n      data_offset = lseek (fd, offset, SEEK_DATA);\n\n      if (data_offset == (off_t)-1)\n        /* ENXIO == EOF; error otherwise */\n        {\n          if (errno == ENXIO)\n            {\n              /* file ends with hole, add one more empty chunk of data */\n              sp.numbytes = 0;\n              sp.offset = st->stat.st_size;\n              sparse_add_map (st, &sp);\n              return true;\n            }\n          return false;\n        }\n\n      hole_offset = lseek (fd, data_offset, SEEK_HOLE);\n\n      /* according to specs, if FS does not fully support\n\t SEEK_DATA/SEEK_HOLE it may just implement kind of \"wrapper\" around\n\t classic lseek() call.  We must detect it here and try to use other\n\t hole-detection methods. */\n      if (offset == 0 /* first loop */\n          && data_offset == 0\n          && hole_offset == st->stat.st_size)\n        {\n          lseek (fd, 0, SEEK_SET);\n          return false;\n        }\n\n      sp.offset = data_offset;\n      sp.numbytes = hole_offset - data_offset;\n      sparse_add_map (st, &sp);\n\n      st->archive_file_size += sp.numbytes;\n      offset = hole_offset;\n    }\n\n  return true;\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "sparse_scan_file": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "static bool\nsparse_scan_file (struct tar_sparse_file *file)\n{\n  /* always check for completely sparse files */\n  if (sparse_scan_file_wholesparse (file))\n    return true;\n\n  switch (hole_detection)\n    {\n    case HOLE_DETECTION_DEFAULT:\n    case HOLE_DETECTION_SEEK:\n#ifdef SEEK_HOLE\n      if (sparse_scan_file_seek (file))\n        return true;\n#else\n      if (hole_detection == HOLE_DETECTION_SEEK)\n\tWARN((0, 0,\n\t      _(\"\\\"seek\\\" hole detection is not supported, using \\\"raw\\\".\")));\n      /* fall back to \"raw\" for this and all other files */\n      hole_detection = HOLE_DETECTION_RAW;\n#endif\n      FALLTHROUGH;\n    case HOLE_DETECTION_RAW:\n      if (sparse_scan_file_raw (file))\n\treturn true;\n    }\n\n  return false;\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "sparse_select_optab": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "static bool\nsparse_select_optab (struct tar_sparse_file *file)\n{\n  switch (current_format == DEFAULT_FORMAT ? archive_format : current_format)\n    {\n    case V7_FORMAT:\n    case USTAR_FORMAT:\n      return false;\n\n    case OLDGNU_FORMAT:\n    case GNU_FORMAT: /*FIXME: This one should disappear? */\n      file->optab = &oldgnu_optab;\n      break;\n\n    case POSIX_FORMAT:\n      file->optab = &pax_optab;\n      break;\n\n    case STAR_FORMAT:\n      file->optab = &star_optab;\n      break;\n\n    default:\n      return false;\n    }\n  return true;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "sparse_dump_region": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "static bool\nsparse_dump_region (struct tar_sparse_file *file, size_t i)\n{\n  union block *blk;\n  off_t bytes_left = file->stat_info->sparse_map[i].numbytes;\n\n  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))\n    return false;\n\n  while (bytes_left > 0)\n    {\n      size_t bufsize = (bytes_left > BLOCKSIZE) ? BLOCKSIZE : bytes_left;\n      size_t bytes_read;\n\n      blk = find_next_block ();\n      bytes_read = safe_read (file->fd, blk->buffer, bufsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t                     (file->stat_info->sparse_map[i].offset\n\t\t\t      + file->stat_info->sparse_map[i].numbytes\n\t\t\t      - bytes_left),\n\t\t\t     bufsize);\n\t  return false;\n\t}\n\n      memset (blk->buffer + bytes_read, 0, BLOCKSIZE - bytes_read);\n      bytes_left -= bytes_read;\n      file->dumped_size += bytes_read;\n      set_next_block_after (blk);\n    }\n\n  return true;\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "sparse_extract_region": {
      "start_point": [
        439,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "static bool\nsparse_extract_region (struct tar_sparse_file *file, size_t i)\n{\n  off_t write_size;\n\n  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))\n    return false;\n\n  write_size = file->stat_info->sparse_map[i].numbytes;\n\n  if (write_size == 0)\n    {\n      /* Last block of the file is a hole */\n      if (file->seekable && sys_truncate (file->fd))\n\ttruncate_warn (file->stat_info->orig_file_name);\n    }\n  else while (write_size > 0)\n    {\n      size_t count;\n      size_t wrbytes = (write_size > BLOCKSIZE) ? BLOCKSIZE : write_size;\n      union block *blk = find_next_block ();\n      if (!blk)\n\t{\n\t  ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t  return false;\n\t}\n      set_next_block_after (blk);\n      count = blocking_write (file->fd, blk->buffer, wrbytes);\n      write_size -= count;\n      file->dumped_size += count;\n      mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n      file->offset += count;\n      if (count != wrbytes)\n\t{\n\t  write_error_details (file->stat_info->orig_file_name,\n\t\t\t       count, wrbytes);\n\t  return false;\n\t}\n    }\n  return true;\n}",
      "lines": 41,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "sparse_dump_file": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "enum dump_status\nsparse_dump_file (int fd, struct tar_stat_info *st)\n{\n  bool rc;\n  struct tar_sparse_file file;\n\n  if (!tar_sparse_init (&file))\n    return dump_status_not_implemented;\n\n  file.stat_info = st;\n  file.fd = fd;\n  file.seekable = true; /* File *must* be seekable for dump to work */\n\n  rc = sparse_scan_file (&file);\n  if (rc && file.optab->dump_region)\n    {\n      tar_sparse_dump_header (&file);\n\n      if (fd >= 0)\n\t{\n\t  size_t i;\n\n\t  mv_begin_write (file.stat_info->file_name,\n\t\t          file.stat_info->stat.st_size,\n\t\t          file.stat_info->archive_file_size - file.dumped_size);\n\t  for (i = 0; rc && i < file.stat_info->sparse_map_avail; i++)\n\t    rc = tar_sparse_dump_region (&file, i);\n\t}\n    }\n\n  pad_archive (file.stat_info->archive_file_size - file.dumped_size);\n  return (tar_sparse_done (&file) && rc) ? dump_status_ok : dump_status_short;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "enum dump_status",
        "enum",
        "dump_status"
      ]
    },
    "sparse_member_p": {
      "start_point": [
        518,
        0
      ],
      "end_point": [
        527,
        1
      ],
      "content": "bool\nsparse_member_p (struct tar_stat_info *st)\n{\n  struct tar_sparse_file file;\n\n  if (!tar_sparse_init (&file))\n    return false;\n  file.stat_info = st;\n  return tar_sparse_member_p (&file);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "sparse_fixup_header": {
      "start_point": [
        529,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "bool\nsparse_fixup_header (struct tar_stat_info *st)\n{\n  struct tar_sparse_file file;\n\n  if (!tar_sparse_init (&file))\n    return false;\n  file.stat_info = st;\n  return tar_sparse_fixup_header (&file);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "sparse_extract_file": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        560,
        1
      ],
      "content": "enum dump_status\nsparse_extract_file (int fd, struct tar_stat_info *st, off_t *size)\n{\n  bool rc = true;\n  struct tar_sparse_file file;\n  size_t i;\n\n  if (!tar_sparse_init (&file))\n    return dump_status_not_implemented;\n\n  file.stat_info = st;\n  file.fd = fd;\n  file.seekable = lseek (fd, 0, SEEK_SET) == 0;\n  file.offset = 0;\n\n  rc = tar_sparse_decode_header (&file);\n  for (i = 0; rc && i < file.stat_info->sparse_map_avail; i++)\n    rc = tar_sparse_extract_region (&file, i);\n  *size = file.stat_info->archive_file_size - file.dumped_size;\n  return (tar_sparse_done (&file) && rc) ? dump_status_ok : dump_status_short;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "enum dump_status",
        "enum",
        "dump_status"
      ]
    },
    "sparse_skip_file": {
      "start_point": [
        562,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "enum dump_status\nsparse_skip_file (struct tar_stat_info *st)\n{\n  bool rc = true;\n  struct tar_sparse_file file;\n\n  if (!tar_sparse_init (&file))\n    return dump_status_not_implemented;\n\n  file.stat_info = st;\n  file.fd = -1;\n\n  rc = tar_sparse_decode_header (&file);\n  skip_file (file.stat_info->archive_file_size - file.dumped_size);\n  return (tar_sparse_done (&file) && rc) ? dump_status_ok : dump_status_short;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "enum dump_status",
        "enum",
        "dump_status"
      ]
    },
    "check_sparse_region": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "static bool\ncheck_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)\n{\n  if (!lseek_or_error (file, beg))\n    return false;\n\n  while (beg < end)\n    {\n      size_t bytes_read;\n      size_t rdsize = BLOCKSIZE < end - beg ? BLOCKSIZE : end - beg;\n      char diff_buffer[BLOCKSIZE];\n\n      bytes_read = safe_read (file->fd, diff_buffer, rdsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t                     beg,\n\t\t\t     rdsize);\n\t  return false;\n\t}\n      if (!zero_block_p (diff_buffer, bytes_read))\n\t{\n\t  char begbuf[INT_BUFSIZE_BOUND (off_t)];\n \t  report_difference (file->stat_info,\n\t\t\t     _(\"File fragment at %s is not a hole\"),\n\t\t\t     offtostr (beg, begbuf));\n\t  return false;\n\t}\n\n      beg += bytes_read;\n    }\n  return true;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_data_region": {
      "start_point": [
        614,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "static bool\ncheck_data_region (struct tar_sparse_file *file, size_t i)\n{\n  off_t size_left;\n\n  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))\n    return false;\n  size_left = file->stat_info->sparse_map[i].numbytes;\n  mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n\n  while (size_left > 0)\n    {\n      size_t bytes_read;\n      size_t rdsize = (size_left > BLOCKSIZE) ? BLOCKSIZE : size_left;\n      char diff_buffer[BLOCKSIZE];\n\n      union block *blk = find_next_block ();\n      if (!blk)\n\t{\n\t  ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t  return false;\n\t}\n      set_next_block_after (blk);\n      bytes_read = safe_read (file->fd, diff_buffer, rdsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t\t\t     (file->stat_info->sparse_map[i].offset\n\t\t\t      + file->stat_info->sparse_map[i].numbytes\n\t\t\t      - size_left),\n\t\t\t     rdsize);\n\t  return false;\n\t}\n      file->dumped_size += bytes_read;\n      size_left -= bytes_read;\n      mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n      if (memcmp (blk->buffer, diff_buffer, rdsize))\n\t{\n\t  report_difference (file->stat_info, _(\"Contents differ\"));\n\t  return false;\n\t}\n    }\n  return true;\n}",
      "lines": 44,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "sparse_diff_file": {
      "start_point": [
        659,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "bool\nsparse_diff_file (int fd, struct tar_stat_info *st)\n{\n  bool rc = true;\n  struct tar_sparse_file file;\n  size_t i;\n  off_t offset = 0;\n\n  if (!tar_sparse_init (&file))\n    return dump_status_not_implemented;\n\n  file.stat_info = st;\n  file.fd = fd;\n  file.seekable = true; /* File *must* be seekable for compare to work */\n\n  rc = tar_sparse_decode_header (&file);\n  mv_begin_read (st);\n  for (i = 0; rc && i < file.stat_info->sparse_map_avail; i++)\n    {\n      rc = check_sparse_region (&file,\n\t\t\t\toffset, file.stat_info->sparse_map[i].offset)\n\t    && check_data_region (&file, i);\n      offset = file.stat_info->sparse_map[i].offset\n\t        + file.stat_info->sparse_map[i].numbytes;\n    }\n\n  if (!rc)\n    skip_file (file.stat_info->archive_file_size - file.dumped_size);\n  mv_end ();\n\n  tar_sparse_done (&file);\n  return rc;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "oldgnu_sparse_member_p": {
      "start_point": [
        719,
        0
      ],
      "end_point": [
        723,
        1
      ],
      "content": "static bool\noldgnu_sparse_member_p (struct tar_sparse_file *file __attribute__ ((unused)))\n{\n  return current_header->header.typeflag == GNUTYPE_SPARSE;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "oldgnu_add_sparse": {
      "start_point": [
        726,
        0
      ],
      "end_point": [
        743,
        1
      ],
      "content": "static enum oldgnu_add_status\noldgnu_add_sparse (struct tar_sparse_file *file, struct sparse *s)\n{\n  struct sp_array sp;\n\n  if (s->numbytes[0] == '\\0')\n    return add_finish;\n  sp.offset = OFF_FROM_HEADER (s->offset);\n  sp.numbytes = OFF_FROM_HEADER (s->numbytes);\n  if (sp.offset < 0 || sp.numbytes < 0\n      || INT_ADD_OVERFLOW (sp.offset, sp.numbytes)\n      || file->stat_info->stat.st_size < sp.offset + sp.numbytes\n      || file->stat_info->archive_file_size < 0)\n    return add_fail;\n\n  sparse_add_map (file->stat_info, &sp);\n  return add_ok;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "enum oldgnu_add_status",
        "enum",
        "oldgnu_add_status"
      ]
    },
    "oldgnu_fixup_header": {
      "start_point": [
        745,
        0
      ],
      "end_point": [
        754,
        1
      ],
      "content": "static bool\noldgnu_fixup_header (struct tar_sparse_file *file)\n{\n  /* NOTE! st_size was initialized from the header\n     which actually contains archived size. The following fixes it */\n  off_t realsize = OFF_FROM_HEADER (current_header->oldgnu_header.realsize);\n  file->stat_info->archive_file_size = file->stat_info->stat.st_size;\n  file->stat_info->stat.st_size = max (0, realsize);\n  return 0 <= realsize;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "oldgnu_get_sparse_info": {
      "start_point": [
        757,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "static bool\noldgnu_get_sparse_info (struct tar_sparse_file *file)\n{\n  size_t i;\n  union block *h = current_header;\n  int ext_p;\n  enum oldgnu_add_status rc;\n\n  file->stat_info->sparse_map_avail = 0;\n  for (i = 0; i < SPARSES_IN_OLDGNU_HEADER; i++)\n    {\n      rc = oldgnu_add_sparse (file, &h->oldgnu_header.sp[i]);\n      if (rc != add_ok)\n\tbreak;\n    }\n\n  for (ext_p = h->oldgnu_header.isextended;\n       rc == add_ok && ext_p; ext_p = h->sparse_header.isextended)\n    {\n      h = find_next_block ();\n      if (!h)\n\t{\n\t  ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t  return false;\n\t}\n      set_next_block_after (h);\n      for (i = 0; i < SPARSES_IN_SPARSE_HEADER && rc == add_ok; i++)\n\trc = oldgnu_add_sparse (file, &h->sparse_header.sp[i]);\n    }\n\n  if (rc == add_fail)\n    {\n      ERROR ((0, 0, _(\"%s: invalid sparse archive member\"),\n\t      file->stat_info->orig_file_name));\n      return false;\n    }\n  return true;\n}",
      "lines": 38,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "oldgnu_store_sparse_info": {
      "start_point": [
        796,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "static void\noldgnu_store_sparse_info (struct tar_sparse_file *file, size_t *pindex,\n\t\t\t  struct sparse *sp, size_t sparse_size)\n{\n  for (; *pindex < file->stat_info->sparse_map_avail\n\t && sparse_size > 0; sparse_size--, sp++, ++*pindex)\n    {\n      OFF_TO_CHARS (file->stat_info->sparse_map[*pindex].offset,\n\t\t    sp->offset);\n      OFF_TO_CHARS (file->stat_info->sparse_map[*pindex].numbytes,\n\t\t    sp->numbytes);\n    }\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "oldgnu_dump_header": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "static bool\noldgnu_dump_header (struct tar_sparse_file *file)\n{\n  off_t block_ordinal = current_block_ordinal ();\n  union block *blk;\n  size_t i;\n\n  blk = start_header (file->stat_info);\n  blk->header.typeflag = GNUTYPE_SPARSE;\n  if (file->stat_info->sparse_map_avail > SPARSES_IN_OLDGNU_HEADER)\n    blk->oldgnu_header.isextended = 1;\n\n  /* Store the real file size */\n  OFF_TO_CHARS (file->stat_info->stat.st_size, blk->oldgnu_header.realsize);\n  /* Store the effective (shrunken) file size */\n  OFF_TO_CHARS (file->stat_info->archive_file_size, blk->header.size);\n\n  i = 0;\n  oldgnu_store_sparse_info (file, &i,\n\t\t\t    blk->oldgnu_header.sp,\n\t\t\t    SPARSES_IN_OLDGNU_HEADER);\n  blk->oldgnu_header.isextended = i < file->stat_info->sparse_map_avail;\n  finish_header (file->stat_info, blk, block_ordinal);\n\n  while (i < file->stat_info->sparse_map_avail)\n    {\n      blk = find_next_block ();\n      memset (blk->buffer, 0, BLOCKSIZE);\n      oldgnu_store_sparse_info (file, &i,\n\t\t\t\tblk->sparse_header.sp,\n\t\t\t\tSPARSES_IN_SPARSE_HEADER);\n      if (i < file->stat_info->sparse_map_avail)\n\tblk->sparse_header.isextended = 1;\n      set_next_block_after (blk);\n    }\n  return true;\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "star_sparse_member_p": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        867,
        1
      ],
      "content": "static bool\nstar_sparse_member_p (struct tar_sparse_file *file __attribute__ ((unused)))\n{\n  return current_header->header.typeflag == GNUTYPE_SPARSE;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "star_fixup_header": {
      "start_point": [
        869,
        0
      ],
      "end_point": [
        878,
        1
      ],
      "content": "static bool\nstar_fixup_header (struct tar_sparse_file *file)\n{\n  /* NOTE! st_size was initialized from the header\n     which actually contains archived size. The following fixes it */\n  off_t realsize = OFF_FROM_HEADER (current_header->star_in_header.realsize);\n  file->stat_info->archive_file_size = file->stat_info->stat.st_size;\n  file->stat_info->stat.st_size = max (0, realsize);\n  return 0 <= realsize;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "star_get_sparse_info": {
      "start_point": [
        881,
        0
      ],
      "end_point": [
        927,
        1
      ],
      "content": "static bool\nstar_get_sparse_info (struct tar_sparse_file *file)\n{\n  size_t i;\n  union block *h = current_header;\n  int ext_p;\n  enum oldgnu_add_status rc = add_ok;\n\n  file->stat_info->sparse_map_avail = 0;\n\n  if (h->star_in_header.prefix[0] == '\\0'\n      && h->star_in_header.sp[0].offset[10] != '\\0')\n    {\n      /* Old star format */\n      for (i = 0; i < SPARSES_IN_STAR_HEADER; i++)\n\t{\n\t  rc = oldgnu_add_sparse (file, &h->star_in_header.sp[i]);\n\t  if (rc != add_ok)\n\t    break;\n\t}\n      ext_p = h->star_in_header.isextended;\n    }\n  else\n    ext_p = 1;\n\n  for (; rc == add_ok && ext_p; ext_p = h->star_ext_header.isextended)\n    {\n      h = find_next_block ();\n      if (!h)\n\t{\n\t  ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t  return false;\n\t}\n      set_next_block_after (h);\n      for (i = 0; i < SPARSES_IN_STAR_EXT_HEADER && rc == add_ok; i++)\n\trc = oldgnu_add_sparse (file, &h->star_ext_header.sp[i]);\n      file->dumped_size += BLOCKSIZE;\n    }\n\n  if (rc == add_fail)\n    {\n      ERROR ((0, 0, _(\"%s: invalid sparse archive member\"),\n\t      file->stat_info->orig_file_name));\n      return false;\n    }\n  return true;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pax_sparse_member_p": {
      "start_point": [
        1019,
        0
      ],
      "end_point": [
        1024,
        1
      ],
      "content": "static bool\npax_sparse_member_p (struct tar_sparse_file *file)\n{\n  return file->stat_info->sparse_map_avail > 0\n          || file->stat_info->sparse_major > 0;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pax_start_header": {
      "start_point": [
        1027,
        0
      ],
      "end_point": [
        1036,
        1
      ],
      "content": "static union block *\npax_start_header (struct tar_stat_info *st)\n{\n  off_t realsize = st->stat.st_size;\n  union block *blk;\n  st->stat.st_size = st->archive_file_size;\n  blk = start_header (st);\n  st->stat.st_size = realsize;\n  return blk;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "union block",
        "union",
        "block",
        "*\npax_start_header (struct tar_stat_info *st)",
        "*"
      ]
    },
    "pax_dump_header_0": {
      "start_point": [
        1038,
        0
      ],
      "end_point": [
        1095,
        1
      ],
      "content": "static bool\npax_dump_header_0 (struct tar_sparse_file *file)\n{\n  off_t block_ordinal = current_block_ordinal ();\n  union block *blk;\n  size_t i;\n  char nbuf[UINTMAX_STRSIZE_BOUND];\n  struct sp_array *map = file->stat_info->sparse_map;\n  char *save_file_name = NULL;\n\n  /* Store the real file size */\n  xheader_store (\"GNU.sparse.size\", file->stat_info, NULL);\n  xheader_store (\"GNU.sparse.numblocks\", file->stat_info, NULL);\n\n  if (xheader_keyword_deleted_p (\"GNU.sparse.map\")\n      || tar_sparse_minor == 0)\n    {\n      for (i = 0; i < file->stat_info->sparse_map_avail; i++)\n\t{\n\t  xheader_store (\"GNU.sparse.offset\", file->stat_info, &i);\n\t  xheader_store (\"GNU.sparse.numbytes\", file->stat_info, &i);\n\t}\n    }\n  else\n    {\n      xheader_store (\"GNU.sparse.name\", file->stat_info, NULL);\n      save_file_name = file->stat_info->file_name;\n      file->stat_info->file_name = xheader_format_name (file->stat_info,\n\t\t\t\t\t       \"%d/GNUSparseFile.%p/%f\", 0);\n\n      xheader_string_begin (&file->stat_info->xhdr);\n      for (i = 0; i < file->stat_info->sparse_map_avail; i++)\n\t{\n\t  if (i)\n\t    xheader_string_add (&file->stat_info->xhdr, \",\");\n\t  xheader_string_add (&file->stat_info->xhdr,\n\t\t\t      umaxtostr (map[i].offset, nbuf));\n\t  xheader_string_add (&file->stat_info->xhdr, \",\");\n\t  xheader_string_add (&file->stat_info->xhdr,\n\t\t\t      umaxtostr (map[i].numbytes, nbuf));\n\t}\n      if (!xheader_string_end (&file->stat_info->xhdr,\n\t\t\t       \"GNU.sparse.map\"))\n\t{\n\t  free (file->stat_info->file_name);\n\t  file->stat_info->file_name = save_file_name;\n\t  return false;\n\t}\n    }\n  blk = pax_start_header (file->stat_info);\n  finish_header (file->stat_info, blk, block_ordinal);\n  if (save_file_name)\n    {\n      free (file->stat_info->file_name);\n      file->stat_info->file_name = save_file_name;\n    }\n  return true;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pax_dump_header_1": {
      "start_point": [
        1097,
        0
      ],
      "end_point": [
        1174,
        1
      ],
      "content": "static bool\npax_dump_header_1 (struct tar_sparse_file *file)\n{\n  off_t block_ordinal = current_block_ordinal ();\n  union block *blk;\n  char *p, *q;\n  size_t i;\n  char nbuf[UINTMAX_STRSIZE_BOUND];\n  off_t size = 0;\n  struct sp_array *map = file->stat_info->sparse_map;\n  char *save_file_name = file->stat_info->file_name;\n\n#define COPY_STRING(b,dst,src) do                \\\n {                                               \\\n   char *endp = b->buffer + BLOCKSIZE;           \\\n   char const *srcp = src;                       \\\n   while (*srcp)                                 \\\n     {                                           \\\n       if (dst == endp)                          \\\n\t {                                       \\\n\t   set_next_block_after (b);             \\\n\t   b = find_next_block ();               \\\n           dst = b->buffer;                      \\\n\t   endp = b->buffer + BLOCKSIZE;         \\\n\t }                                       \\\n       *dst++ = *srcp++;                         \\\n     }                                           \\\n   } while (0)\n\n  /* Compute stored file size */\n  p = umaxtostr (file->stat_info->sparse_map_avail, nbuf);\n  size += strlen (p) + 1;\n  for (i = 0; i < file->stat_info->sparse_map_avail; i++)\n    {\n      p = umaxtostr (map[i].offset, nbuf);\n      size += strlen (p) + 1;\n      p = umaxtostr (map[i].numbytes, nbuf);\n      size += strlen (p) + 1;\n    }\n  size = (size + BLOCKSIZE - 1) / BLOCKSIZE;\n  file->stat_info->archive_file_size += size * BLOCKSIZE;\n  file->dumped_size += size * BLOCKSIZE;\n\n  /* Store sparse file identification */\n  xheader_store (\"GNU.sparse.major\", file->stat_info, NULL);\n  xheader_store (\"GNU.sparse.minor\", file->stat_info, NULL);\n  xheader_store (\"GNU.sparse.name\", file->stat_info, NULL);\n  xheader_store (\"GNU.sparse.realsize\", file->stat_info, NULL);\n\n  file->stat_info->file_name =\n    xheader_format_name (file->stat_info, \"%d/GNUSparseFile.%p/%f\", 0);\n  /* Make sure the created header name is shorter than NAME_FIELD_SIZE: */\n  if (strlen (file->stat_info->file_name) > NAME_FIELD_SIZE)\n    file->stat_info->file_name[NAME_FIELD_SIZE] = 0;\n\n  blk = pax_start_header (file->stat_info);\n  finish_header (file->stat_info, blk, block_ordinal);\n  free (file->stat_info->file_name);\n  file->stat_info->file_name = save_file_name;\n\n  blk = find_next_block ();\n  q = blk->buffer;\n  p = umaxtostr (file->stat_info->sparse_map_avail, nbuf);\n  COPY_STRING (blk, q, p);\n  COPY_STRING (blk, q, \"\\n\");\n  for (i = 0; i < file->stat_info->sparse_map_avail; i++)\n    {\n      p = umaxtostr (map[i].offset, nbuf);\n      COPY_STRING (blk, q, p);\n      COPY_STRING (blk, q, \"\\n\");\n      p = umaxtostr (map[i].numbytes, nbuf);\n      COPY_STRING (blk, q, p);\n      COPY_STRING (blk, q, \"\\n\");\n    }\n  memset (q, 0, BLOCKSIZE - (q - blk->buffer));\n  set_next_block_after (blk);\n  return true;\n}",
      "lines": 78,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pax_dump_header": {
      "start_point": [
        1176,
        0
      ],
      "end_point": [
        1184,
        1
      ],
      "content": "static bool\npax_dump_header (struct tar_sparse_file *file)\n{\n  file->stat_info->sparse_major = tar_sparse_major;\n  file->stat_info->sparse_minor = tar_sparse_minor;\n\n  return (file->stat_info->sparse_major == 0) ?\n           pax_dump_header_0 (file) : pax_dump_header_1 (file);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "decode_num": {
      "start_point": [
        1186,
        0
      ],
      "end_point": [
        1203,
        1
      ],
      "content": "static bool\ndecode_num (uintmax_t *num, char const *arg, uintmax_t maxval)\n{\n  uintmax_t u;\n  char *arg_lim;\n\n  if (!ISDIGIT (*arg))\n    return false;\n\n  errno = 0;\n  u = strtoumax (arg, &arg_lim, 10);\n\n  if (! (u <= maxval && errno != ERANGE) || *arg_lim)\n    return false;\n\n  *num = u;\n  return true;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pax_decode_header": {
      "start_point": [
        1205,
        0
      ],
      "end_point": [
        1283,
        1
      ],
      "content": "static bool\npax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n\n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           file->dumped_size += BLOCKSIZE;                         \\\n           b = find_next_block ();                                 \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      set_next_block_after (current_header);\n      file->dumped_size += BLOCKSIZE;\n      blk = find_next_block ();\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n    }\n\n  return true;\n}",
      "lines": 79,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "tar/tar-1.30/src/suffix.c": {
    "find_compression_suffix": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static struct compression_suffix const *\nfind_compression_suffix (const char *name, size_t *ret_len)\n{\n  char *suf = strrchr (name, '.');\n\n  if (suf)\n    {\n      size_t len;\n      struct compression_suffix *p;\n      \n      suf++;\n      len = strlen (suf);\n\n      for (p = compression_suffixes; p->suffix; p++)\n\t{\n\t  if (p->length == len && memcmp (p->suffix, suf, len) == 0)\n\t    {\n\t      if (ret_len)\n\t\t*ret_len = strlen (name) - len - 1;\n\t      return p;\n\t    }\n\t}\n    }\n  return NULL;\n}",
      "lines": 25,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "struct compression_suffix",
        "struct",
        "compression_suffix",
        "const",
        "const",
        "*\nfind_compression_suffix (const char *name, size_t *ret_len)",
        "*"
      ]
    },
    "find_compression_program": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static const char *\nfind_compression_program (const char *name, const char *defprog)\n{\n  struct compression_suffix const *p = find_compression_suffix (name, NULL);\n  if (p)\n    return p->program;\n  return defprog;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nfind_compression_program (const char *name, const char *defprog)",
        "*"
      ]
    },
    "set_compression_program_by_suffix": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nset_compression_program_by_suffix (const char *name, const char *defprog)\n{\n  const char *program = find_compression_program (name, defprog);\n  if (program)\n    use_compress_program_option = program;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "strip_compression_suffix": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "char *\nstrip_compression_suffix (const char *name)\n{\n  char *s = NULL;\n  size_t len;\n\n  if (find_compression_suffix (name, &len))\n    {\n      if (strncmp (name + len - 4, \".tar\", 4) == 0)\n\tlen -= 4;\n      if (len == 0)\n\treturn NULL;\n      s = xmalloc (len + 1);\n      memcpy (s, name, len);\n      s[len] = 0;\n    }\n  return s;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "char",
        "*\nstrip_compression_suffix (const char *name)",
        "*"
      ]
    }
  },
  "tar/tar-1.30/src/system.c": {
    "xexec": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static _Noreturn void\nxexec (const char *cmd)\n{\n  char *argv[4];\n\n  argv[0] = (char *) \"/bin/sh\";\n  argv[1] = (char *) \"-c\";\n  argv[2] = (char *) cmd;\n  argv[3] = NULL;\n\n  execv (\"/bin/sh\", argv);\n  exec_fatal (cmd);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "sys_get_archive_stat": [
      {
        "start_point": [
          42,
          0
        ],
        "end_point": [
          46,
          1
        ],
        "content": "bool\nsys_get_archive_stat (void)\n{\n  return 0;\n}",
        "lines": 5,
        "depth": 5,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          133,
          0
        ],
        "end_point": [
          137,
          1
        ],
        "content": "bool\nsys_get_archive_stat (void)\n{\n  return fstat (archive, &archive_stat) == 0;\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ],
    "sys_file_is_archive": [
      {
        "start_point": [
          48,
          0
        ],
        "end_point": [
          52,
          1
        ],
        "content": "bool\nsys_file_is_archive (struct tar_stat_info *p)\n{\n  return false;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          139,
          0
        ],
        "end_point": [
          143,
          1
        ],
        "content": "bool\nsys_file_is_archive (struct tar_stat_info *p)\n{\n  return (ar_dev && p->stat.st_dev == ar_dev && p->stat.st_ino == ar_ino);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "bool"
        ]
      }
    ],
    "sys_save_archive_dev_ino": [
      {
        "start_point": [
          54,
          0
        ],
        "end_point": [
          57,
          1
        ],
        "content": "void\nsys_save_archive_dev_ino (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          146,
          0
        ],
        "end_point": [
          156,
          1
        ],
        "content": "void\nsys_save_archive_dev_ino (void)\n{\n  if (!_isrmt (archive) && S_ISREG (archive_stat.st_mode))\n    {\n      ar_dev = archive_stat.st_dev;\n      ar_ino = archive_stat.st_ino;\n    }\n  else\n    ar_dev = 0;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "void"
        ]
      }
    ],
    "sys_detect_dev_null_output": [
      {
        "start_point": [
          59,
          0
        ],
        "end_point": [
          66,
          1
        ],
        "content": "void\nsys_detect_dev_null_output (void)\n{\n  static char const dev_null[] = \"nul\";\n\n  dev_null_output = (strcmp (archive_name_array[0], dev_null) == 0\n\t\t     || (! _isrmt (archive)));\n}",
        "lines": 8,
        "depth": 11,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          159,
          0
        ],
        "end_point": [
          171,
          1
        ],
        "content": "void\nsys_detect_dev_null_output (void)\n{\n  static char const dev_null[] = \"/dev/null\";\n  struct stat dev_null_stat;\n\n  dev_null_output = (strcmp (archive_name_array[0], dev_null) == 0\n\t\t     || (! _isrmt (archive)\n\t\t\t && S_ISCHR (archive_stat.st_mode)\n\t\t\t && stat (dev_null, &dev_null_stat) == 0\n\t\t\t && archive_stat.st_dev == dev_null_stat.st_dev\n\t\t\t && archive_stat.st_ino == dev_null_stat.st_ino));\n}",
        "lines": 13,
        "depth": 15,
        "decorators": [
          "void"
        ]
      }
    ],
    "sys_wait_for_child": [
      {
        "start_point": [
          68,
          0
        ],
        "end_point": [
          71,
          1
        ],
        "content": "void\nsys_wait_for_child (pid_t child_pid, bool eof)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          173,
          0
        ],
        "end_point": [
          197,
          1
        ],
        "content": "void\nsys_wait_for_child (pid_t child_pid, bool eof)\n{\n  if (child_pid)\n    {\n      int wait_status;\n\n      while (waitpid (child_pid, &wait_status, 0) == -1)\n\tif (errno != EINTR)\n\t  {\n\t    waitpid_error (use_compress_program_option);\n\t    break;\n\t  }\n\n      if (WIFSIGNALED (wait_status))\n\t{\n\t  int sig = WTERMSIG (wait_status);\n\t  if (!(!eof && sig == SIGPIPE))\n\t    FATAL_ERROR ((0, 0, _(\"Child died with signal %d\"), sig));\n\t}\n      else if (WEXITSTATUS (wait_status) != 0)\n\tFATAL_ERROR ((0, 0, _(\"Child returned status %d\"),\n\t\t      WEXITSTATUS (wait_status)));\n    }\n}",
        "lines": 25,
        "depth": 18,
        "decorators": [
          "void"
        ]
      }
    ],
    "sys_spawn_shell": [
      {
        "start_point": [
          73,
          0
        ],
        "end_point": [
          77,
          1
        ],
        "content": "void\nsys_spawn_shell (void)\n{\n  spawnl (P_WAIT, getenv (\"COMSPEC\"), \"-\", 0);\n}",
        "lines": 5,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          199,
          0
        ],
        "end_point": [
          223,
          1
        ],
        "content": "void\nsys_spawn_shell (void)\n{\n  pid_t child;\n  const char *shell = getenv (\"SHELL\");\n  if (! shell)\n    shell = \"/bin/sh\";\n  child = xfork ();\n  if (child == 0)\n    {\n      priv_set_restore_linkdir ();\n      execlp (shell, \"-sh\", \"-i\", NULL);\n      exec_fatal (shell);\n    }\n  else\n    {\n      int wait_status;\n      while (waitpid (child, &wait_status, 0) == -1)\n\tif (errno != EINTR)\n\t  {\n\t    waitpid_error (shell);\n\t    break;\n\t  }\n    }\n}",
        "lines": 25,
        "depth": 11,
        "decorators": [
          "void"
        ]
      }
    ],
    "sys_compare_uid": [
      {
        "start_point": [
          83,
          0
        ],
        "end_point": [
          87,
          1
        ],
        "content": "bool\nsys_compare_uid (struct stat *a, struct stat *b)\n{\n  return true;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          225,
          0
        ],
        "end_point": [
          229,
          1
        ],
        "content": "bool\nsys_compare_uid (struct stat *a, struct stat *b)\n{\n  return a->st_uid == b->st_uid;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ],
    "sys_compare_gid": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          93,
          1
        ],
        "content": "bool\nsys_compare_gid (struct stat *a, struct stat *b)\n{\n  return true;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          231,
          0
        ],
        "end_point": [
          235,
          1
        ],
        "content": "bool\nsys_compare_gid (struct stat *a, struct stat *b)\n{\n  return a->st_gid == b->st_gid;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ],
    "sys_compare_links": [
      {
        "start_point": [
          95,
          0
        ],
        "end_point": [
          99,
          1
        ],
        "content": "void\nsys_compare_links (struct stat *link_data, struct stat *stat_data)\n{\n  return true;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          237,
          0
        ],
        "end_point": [
          242,
          1
        ],
        "content": "bool\nsys_compare_links (struct stat *link_data, struct stat *stat_data)\n{\n  return stat_data->st_dev == link_data->st_dev\n         && stat_data->st_ino == link_data->st_ino;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      }
    ],
    "sys_truncate": [
      {
        "start_point": [
          101,
          0
        ],
        "end_point": [
          105,
          1
        ],
        "content": "int\nsys_truncate (int fd)\n{\n  return write (fd, \"\", 0);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          244,
          0
        ],
        "end_point": [
          249,
          1
        ],
        "content": "int\nsys_truncate (int fd)\n{\n  off_t pos = lseek (fd, (off_t) 0, SEEK_CUR);\n  return pos < 0 ? -1 : ftruncate (fd, pos);\n}",
        "lines": 6,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "sys_write_archive_buffer": [
      {
        "start_point": [
          107,
          0
        ],
        "end_point": [
          111,
          1
        ],
        "content": "size_t\nsys_write_archive_buffer (void)\n{\n  return full_write (archive, record_start->buffer, record_size);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "size_t"
        ]
      },
      {
        "start_point": [
          264,
          0
        ],
        "end_point": [
          268,
          1
        ],
        "content": "size_t\nsys_write_archive_buffer (void)\n{\n  return rmtwrite (archive, record_start->buffer, record_size);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "size_t"
        ]
      }
    ],
    "sys_child_open_for_compress": [
      {
        "start_point": [
          114,
          0
        ],
        "end_point": [
          118,
          1
        ],
        "content": "void\nsys_child_open_for_compress (void)\n{\n  FATAL_ERROR ((0, 0, _(\"Cannot use compressed or remote archives\")));\n}",
        "lines": 5,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          326,
          0
        ],
        "end_point": [
          467,
          1
        ],
        "content": "pid_t\nsys_child_open_for_compress (void)\n{\n  int parent_pipe[2];\n  int child_pipe[2];\n  pid_t grandchild_pid;\n  pid_t child_pid;\n\n  signal (SIGPIPE, SIG_IGN);\n  xpipe (parent_pipe);\n  child_pid = xfork ();\n\n  if (child_pid > 0)\n    {\n      /* The parent tar is still here!  Just clean up.  */\n\n      archive = parent_pipe[PWRITE];\n      xclose (parent_pipe[PREAD]);\n      return child_pid;\n    }\n\n  /* The new born child tar is here!  */\n\n  set_program_name (_(\"tar (child)\"));\n  signal (SIGPIPE, SIG_DFL);\n\n  xdup2 (parent_pipe[PREAD], STDIN_FILENO);\n  xclose (parent_pipe[PWRITE]);\n\n  /* Check if we need a grandchild tar.  This happens only if either:\n     a) the file is to be accessed by rmt: compressor doesn't know how;\n     b) the file is not a plain file.  */\n\n  if (!_remdev (archive_name_array[0])\n      && is_regular_file (archive_name_array[0]))\n    {\n      if (backup_option)\n\tmaybe_backup_file (archive_name_array[0], 1);\n\n      /* We don't need a grandchild tar.  Open the archive and launch the\n\t compressor.  */\n      if (strcmp (archive_name_array[0], \"-\"))\n\t{\n\t  archive = creat (archive_name_array[0], MODE_RW);\n\t  if (archive < 0)\n\t    {\n\t      int saved_errno = errno;\n\n\t      if (backup_option)\n\t\tundo_last_backup ();\n\t      errno = saved_errno;\n\t      open_fatal (archive_name_array[0]);\n\t    }\n\t  xdup2 (archive, STDOUT_FILENO);\n\t}\n      priv_set_restore_linkdir ();\n      xexec (use_compress_program_option);\n    }\n\n  /* We do need a grandchild tar.  */\n\n  xpipe (child_pipe);\n  grandchild_pid = xfork ();\n\n  if (grandchild_pid == 0)\n    {\n      /* The newborn grandchild tar is here!  Launch the compressor.  */\n\n      set_program_name (_(\"tar (grandchild)\"));\n\n      xdup2 (child_pipe[PWRITE], STDOUT_FILENO);\n      xclose (child_pipe[PREAD]);\n      priv_set_restore_linkdir ();\n      xexec (use_compress_program_option);\n    }\n\n  /* The child tar is still here!  */\n\n  /* Prepare for reblocking the data from the compressor into the archive.  */\n\n  xdup2 (child_pipe[PREAD], STDIN_FILENO);\n  xclose (child_pipe[PWRITE]);\n\n  if (strcmp (archive_name_array[0], \"-\") == 0)\n    archive = STDOUT_FILENO;\n  else\n    {\n      archive = rmtcreat (archive_name_array[0], MODE_RW, rsh_command_option);\n      if (archive < 0)\n\topen_fatal (archive_name_array[0]);\n    }\n\n  /* Let's read out of the stdin pipe and write an archive.  */\n\n  while (1)\n    {\n      size_t status = 0;\n      char *cursor;\n      size_t length;\n\n      /* Assemble a record.  */\n\n      for (length = 0, cursor = record_start->buffer;\n\t   length < record_size;\n\t   length += status, cursor += status)\n\t{\n\t  size_t size = record_size - length;\n\n\t  status = safe_read (STDIN_FILENO, cursor, size);\n\t  if (status == SAFE_READ_ERROR)\n\t    read_fatal (use_compress_program_option);\n\t  if (status == 0)\n\t    break;\n\t}\n\n      /* Copy the record.  */\n\n      if (status == 0)\n\t{\n\t  /* We hit the end of the file.  Write last record at\n\t     full length, as the only role of the grandchild is\n\t     doing proper reblocking.  */\n\n\t  if (length > 0)\n\t    {\n\t      memset (record_start->buffer + length, 0, record_size - length);\n\t      status = sys_write_archive_buffer ();\n\t      if (status != record_size)\n\t\tarchive_write_error (status);\n\t    }\n\n\t  /* There is nothing else to read, break out.  */\n\t  break;\n\t}\n\n      status = sys_write_archive_buffer ();\n      if (status != record_size)\n\tarchive_write_error (status);\n    }\n\n  wait_for_grandchild (grandchild_pid);\n}",
        "lines": 142,
        "depth": 14,
        "decorators": [
          "pid_t"
        ]
      }
    ],
    "sys_child_open_for_uncompress": [
      {
        "start_point": [
          121,
          0
        ],
        "end_point": [
          125,
          1
        ],
        "content": "void\nsys_child_open_for_uncompress (void)\n{\n  FATAL_ERROR ((0, 0, _(\"Cannot use compressed or remote archives\")));\n}",
        "lines": 5,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          506,
          0
        ],
        "end_point": [
          622,
          1
        ],
        "content": "pid_t\nsys_child_open_for_uncompress (void)\n{\n  int parent_pipe[2];\n  int child_pipe[2];\n  pid_t grandchild_pid;\n  pid_t child_pid;\n\n  xpipe (parent_pipe);\n  child_pid = xfork ();\n\n  if (child_pid > 0)\n    {\n      /* The parent tar is still here!  Just clean up.  */\n\n      archive = parent_pipe[PREAD];\n      xclose (parent_pipe[PWRITE]);\n      return child_pid;\n    }\n\n  /* The newborn child tar is here!  */\n\n  set_program_name (_(\"tar (child)\"));\n  signal (SIGPIPE, SIG_DFL);\n\n  xdup2 (parent_pipe[PWRITE], STDOUT_FILENO);\n  xclose (parent_pipe[PREAD]);\n\n  /* Check if we need a grandchild tar.  This happens only if either:\n     a) we're reading stdin: to force unblocking;\n     b) the file is to be accessed by rmt: compressor doesn't know how;\n     c) the file is not a plain file.  */\n\n  if (strcmp (archive_name_array[0], \"-\") != 0\n      && !_remdev (archive_name_array[0])\n      && is_regular_file (archive_name_array[0]))\n    {\n      /* We don't need a grandchild tar.  Open the archive and lauch the\n\t uncompressor.  */\n\n      archive = open (archive_name_array[0], O_RDONLY | O_BINARY, MODE_RW);\n      if (archive < 0)\n\topen_fatal (archive_name_array[0]);\n      xdup2 (archive, STDIN_FILENO);\n      priv_set_restore_linkdir ();\n      run_decompress_program ();\n    }\n\n  /* We do need a grandchild tar.  */\n\n  xpipe (child_pipe);\n  grandchild_pid = xfork ();\n\n  if (grandchild_pid == 0)\n    {\n      /* The newborn grandchild tar is here!  Launch the uncompressor.  */\n\n      set_program_name (_(\"tar (grandchild)\"));\n\n      xdup2 (child_pipe[PREAD], STDIN_FILENO);\n      xclose (child_pipe[PWRITE]);\n      priv_set_restore_linkdir ();\n      run_decompress_program ();\n    }\n\n  /* The child tar is still here!  */\n\n  /* Prepare for unblocking the data from the archive into the\n     uncompressor.  */\n\n  xdup2 (child_pipe[PWRITE], STDOUT_FILENO);\n  xclose (child_pipe[PREAD]);\n\n  if (strcmp (archive_name_array[0], \"-\") == 0)\n    archive = STDIN_FILENO;\n  else\n    archive = rmtopen (archive_name_array[0], O_RDONLY | O_BINARY,\n\t\t       MODE_RW, rsh_command_option);\n  if (archive < 0)\n    open_fatal (archive_name_array[0]);\n\n  /* Let's read the archive and pipe it into stdout.  */\n\n  while (1)\n    {\n      char *cursor;\n      size_t maximum;\n      size_t count;\n      size_t status;\n\n      clear_read_error_count ();\n\n    error_loop:\n      status = rmtread (archive, record_start->buffer, record_size);\n      if (status == SAFE_READ_ERROR)\n\t{\n\t  archive_read_error ();\n\t  goto error_loop;\n\t}\n      if (status == 0)\n\tbreak;\n      cursor = record_start->buffer;\n      maximum = status;\n      while (maximum)\n\t{\n\t  count = maximum < BLOCKSIZE ? maximum : BLOCKSIZE;\n\t  if (full_write (STDOUT_FILENO, cursor, count) != count)\n\t    write_error (use_compress_program_option);\n\t  cursor += count;\n\t  maximum -= count;\n\t}\n    }\n\n  xclose (STDOUT_FILENO);\n\n  wait_for_grandchild (grandchild_pid);\n}",
        "lines": 117,
        "depth": 12,
        "decorators": [
          "pid_t"
        ]
      }
    ],
    "is_regular_file": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static int\nis_regular_file (const char *name)\n{\n  struct stat stbuf;\n\n  if (stat (name, &stbuf) == 0)\n    return S_ISREG (stbuf.st_mode);\n  else\n    return errno == ENOENT;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "xdup2": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "static void\nxdup2 (int from, int into)\n{\n  if (from != into)\n    {\n      int status = close (into);\n\n      if (status != 0 && errno != EBADF)\n\t{\n\t  int e = errno;\n\t  FATAL_ERROR ((0, e, _(\"Cannot close\")));\n\t}\n      status = dup (from);\n      if (status != into)\n\t{\n\t  if (status < 0)\n\t    {\n\t      int e = errno;\n\t      FATAL_ERROR ((0, e, _(\"Cannot dup\")));\n\t    }\n\t  abort ();\n\t}\n      xclose (from);\n    }\n}",
      "lines": 25,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wait_for_grandchild": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "static void\nwait_for_grandchild (pid_t pid)\n{\n  int wait_status;\n  int exit_code = 0;\n\n  while (waitpid (pid, &wait_status, 0) == -1)\n    if (errno != EINTR)\n      {\n\twaitpid_error (use_compress_program_option);\n\tbreak;\n      }\n\n  if (WIFSIGNALED (wait_status))\n    raise (WTERMSIG (wait_status));\n  else if (WEXITSTATUS (wait_status) != 0)\n    exit_code = WEXITSTATUS (wait_status);\n\n  exit (exit_code);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "run_decompress_program": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "static void\nrun_decompress_program (void)\n{\n  int i;\n  const char *p, *prog = NULL;\n  struct wordsplit ws;\n  int wsflags = (WRDSF_DEFFLAGS | WRDSF_ENV | WRDSF_DOOFFS) & ~WRDSF_NOVAR;\n\n  ws.ws_env = (const char **) environ;\n  ws.ws_offs = 1;\n\n  for (p = first_decompress_program (&i); p; p = next_decompress_program (&i))\n    {\n      if (prog)\n\t{\n\t  WARNOPT (WARN_DECOMPRESS_PROGRAM,\n\t\t   (0, errno, _(\"cannot run %s\"), prog));\n\t  WARNOPT (WARN_DECOMPRESS_PROGRAM,\n\t\t   (0, 0, _(\"trying %s\"), p));\n\t}\n      if (wordsplit (p, &ws, wsflags))\n\tFATAL_ERROR ((0, 0, _(\"cannot split string '%s': %s\"),\n\t\t      p, wordsplit_strerror (&ws)));\n      wsflags |= WRDSF_REUSE;\n      memmove(ws.ws_wordv, ws.ws_wordv + ws.ws_offs,\n\t      sizeof(ws.ws_wordv[0])*ws.ws_wordc);\n      ws.ws_wordv[ws.ws_wordc] = (char *) \"-d\";\n      prog = p;\n      execvp (ws.ws_wordv[0], ws.ws_wordv);\n      ws.ws_wordv[ws.ws_wordc] = NULL;\n    }\n  if (!prog)\n    FATAL_ERROR ((0, 0, _(\"unable to run decompression program\")));\n  exec_fatal (prog);\n}",
      "lines": 35,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dec_to_env": {
      "start_point": [
        626,
        0
      ],
      "end_point": [
        635,
        1
      ],
      "content": "static void\ndec_to_env (char const *envar, uintmax_t num)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  char *numstr;\n\n  numstr = STRINGIFY_BIGINT (num, buf);\n  if (setenv (envar, numstr, 1) != 0)\n    xalloc_die ();\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "time_to_env": {
      "start_point": [
        637,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "static void\ntime_to_env (char const *envar, struct timespec t)\n{\n  char buf[TIMESPEC_STRSIZE_BOUND];\n  if (setenv (envar, code_timespec (t, buf), 1) != 0)\n    xalloc_die ();\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "oct_to_env": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        653,
        1
      ],
      "content": "static void\noct_to_env (char const *envar, unsigned long num)\n{\n  char buf[1+1+(sizeof(unsigned long)*CHAR_BIT+2)/3];\n\n  snprintf (buf, sizeof buf, \"0%lo\", num);\n  if (setenv (envar, buf, 1) != 0)\n    xalloc_die ();\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "str_to_env": {
      "start_point": [
        655,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "static void\nstr_to_env (char const *envar, char const *str)\n{\n  if (str)\n    {\n      if (setenv (envar, str, 1) != 0)\n\txalloc_die ();\n    }\n  else\n    unsetenv (envar);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "chr_to_env": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        675,
        1
      ],
      "content": "static void\nchr_to_env (char const *envar, char c)\n{\n  char buf[2];\n  buf[0] = c;\n  buf[1] = 0;\n  if (setenv (envar, buf, 1) != 0)\n    xalloc_die ();\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "stat_to_env": {
      "start_point": [
        677,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "static void\nstat_to_env (char *name, char type, struct tar_stat_info *st)\n{\n  str_to_env (\"TAR_VERSION\", PACKAGE_VERSION);\n  str_to_env (\"TAR_ARCHIVE\", *archive_name_cursor);\n  dec_to_env (\"TAR_VOLUME\", archive_name_cursor - archive_name_array + 1);\n  dec_to_env (\"TAR_BLOCKING_FACTOR\", blocking_factor);\n  str_to_env (\"TAR_FORMAT\",\n\t      archive_format_string (current_format == DEFAULT_FORMAT ?\n\t\t\t\t     archive_format : current_format));\n  chr_to_env (\"TAR_FILETYPE\", type);\n  oct_to_env (\"TAR_MODE\", st->stat.st_mode);\n  str_to_env (\"TAR_FILENAME\", name);\n  str_to_env (\"TAR_REALNAME\", st->file_name);\n  str_to_env (\"TAR_UNAME\", st->uname);\n  str_to_env (\"TAR_GNAME\", st->gname);\n  time_to_env (\"TAR_ATIME\", st->atime);\n  time_to_env (\"TAR_MTIME\", st->mtime);\n  time_to_env (\"TAR_CTIME\", st->ctime);\n  dec_to_env (\"TAR_SIZE\", st->stat.st_size);\n  dec_to_env (\"TAR_UID\", st->stat.st_uid);\n  dec_to_env (\"TAR_GID\", st->stat.st_gid);\n\n  switch (type)\n    {\n    case 'b':\n    case 'c':\n      dec_to_env (\"TAR_MINOR\", minor (st->stat.st_rdev));\n      dec_to_env (\"TAR_MAJOR\", major (st->stat.st_rdev));\n      unsetenv (\"TAR_LINKNAME\");\n      break;\n\n    case 'l':\n    case 'h':\n      unsetenv (\"TAR_MINOR\");\n      unsetenv (\"TAR_MAJOR\");\n      str_to_env (\"TAR_LINKNAME\", st->link_name);\n      break;\n\n    default:\n      unsetenv (\"TAR_MINOR\");\n      unsetenv (\"TAR_MAJOR\");\n      unsetenv (\"TAR_LINKNAME\");\n      break;\n    }\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sys_exec_command": {
      "start_point": [
        727,
        0
      ],
      "end_point": [
        750,
        1
      ],
      "content": "int\nsys_exec_command (char *file_name, int typechar, struct tar_stat_info *st)\n{\n  int p[2];\n\n  xpipe (p);\n  pipe_handler = signal (SIGPIPE, SIG_IGN);\n  global_pid = xfork ();\n\n  if (global_pid != 0)\n    {\n      xclose (p[PREAD]);\n      return p[PWRITE];\n    }\n\n  /* Child */\n  xdup2 (p[PREAD], STDIN_FILENO);\n  xclose (p[PWRITE]);\n\n  stat_to_env (file_name, typechar, st);\n\n  priv_set_restore_linkdir ();\n  xexec (to_command_option);\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sys_wait_command": {
      "start_point": [
        752,
        0
      ],
      "end_point": [
        785,
        1
      ],
      "content": "void\nsys_wait_command (void)\n{\n  int status;\n\n  if (global_pid < 0)\n    return;\n\n  signal (SIGPIPE, pipe_handler);\n  while (waitpid (global_pid, &status, 0) == -1)\n    if (errno != EINTR)\n      {\n        global_pid = -1;\n        waitpid_error (to_command_option);\n        return;\n      }\n\n  if (WIFEXITED (status))\n    {\n      if (!ignore_command_error_option && WEXITSTATUS (status))\n\tERROR ((0, 0, _(\"%lu: Child returned status %d\"),\n\t\t(unsigned long) global_pid, WEXITSTATUS (status)));\n    }\n  else if (WIFSIGNALED (status))\n    {\n      WARN ((0, 0, _(\"%lu: Child terminated on signal %d\"),\n\t     (unsigned long) global_pid, WTERMSIG (status)));\n    }\n  else\n    ERROR ((0, 0, _(\"%lu: Child terminated on unknown reason\"),\n\t    (unsigned long) global_pid));\n\n  global_pid = -1;\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "sys_exec_info_script": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        857,
        1
      ],
      "content": "int\nsys_exec_info_script (const char **archive_name, int volume_number)\n{\n  pid_t pid;\n  char uintbuf[UINTMAX_STRSIZE_BOUND];\n  int p[2];\n  static void (*saved_handler) (int sig);\n\n  xpipe (p);\n  saved_handler = signal (SIGPIPE, SIG_IGN);\n\n  pid = xfork ();\n\n  if (pid != 0)\n    {\n      /* Master */\n\n      int rc;\n      int status;\n      char *buf = NULL;\n      size_t size = 0;\n      FILE *fp;\n\n      xclose (p[PWRITE]);\n      fp = fdopen (p[PREAD], \"r\");\n      rc = getline (&buf, &size, fp);\n      fclose (fp);\n\n      if (rc > 0 && buf[rc-1] == '\\n')\n\tbuf[--rc] = 0;\n\n      while (waitpid (pid, &status, 0) == -1)\n\tif (errno != EINTR)\n\t  {\n\t    signal (SIGPIPE, saved_handler);\n\t    waitpid_error (info_script_option);\n\t    return -1;\n\t  }\n\n      signal (SIGPIPE, saved_handler);\n\n      if (WIFEXITED (status))\n\t{\n\t  if (WEXITSTATUS (status) == 0 && rc > 0)\n\t    *archive_name = buf;\n\t  else\n\t    free (buf);\n\t  return WEXITSTATUS (status);\n\t}\n\n      free (buf);\n      return -1;\n    }\n\n  /* Child */\n  setenv (\"TAR_VERSION\", PACKAGE_VERSION, 1);\n  setenv (\"TAR_ARCHIVE\", *archive_name, 1);\n  setenv (\"TAR_VOLUME\", STRINGIFY_BIGINT (volume_number, uintbuf), 1);\n  setenv (\"TAR_BLOCKING_FACTOR\",\n\t  STRINGIFY_BIGINT (blocking_factor, uintbuf), 1);\n  setenv (\"TAR_SUBCOMMAND\", subcommand_string (subcommand_option), 1);\n  setenv (\"TAR_FORMAT\",\n\t  archive_format_string (current_format == DEFAULT_FORMAT ?\n\t\t\t\t archive_format : current_format), 1);\n  setenv (\"TAR_FD\", STRINGIFY_BIGINT (p[PWRITE], uintbuf), 1);\n\n  xclose (p[PREAD]);\n\n  priv_set_restore_linkdir ();\n  xexec (info_script_option);\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "sys_exec_checkpoint_script": {
      "start_point": [
        859,
        0
      ],
      "end_point": [
        897,
        1
      ],
      "content": "void\nsys_exec_checkpoint_script (const char *script_name,\n\t\t\t    const char *archive_name,\n\t\t\t    int checkpoint_number)\n{\n  pid_t pid;\n  char uintbuf[UINTMAX_STRSIZE_BOUND];\n\n  pid = xfork ();\n\n  if (pid != 0)\n    {\n      /* Master */\n\n      int status;\n\n      while (waitpid (pid, &status, 0) == -1)\n\tif (errno != EINTR)\n\t  {\n\t    waitpid_error (script_name);\n\t    break;\n\t  }\n\n      return;\n    }\n\n  /* Child */\n  setenv (\"TAR_VERSION\", PACKAGE_VERSION, 1);\n  setenv (\"TAR_ARCHIVE\", archive_name, 1);\n  setenv (\"TAR_CHECKPOINT\", STRINGIFY_BIGINT (checkpoint_number, uintbuf), 1);\n  setenv (\"TAR_BLOCKING_FACTOR\",\n\t  STRINGIFY_BIGINT (blocking_factor, uintbuf), 1);\n  setenv (\"TAR_SUBCOMMAND\", subcommand_string (subcommand_option), 1);\n  setenv (\"TAR_FORMAT\",\n\t  archive_format_string (current_format == DEFAULT_FORMAT ?\n\t\t\t\t archive_format : current_format), 1);\n  priv_set_restore_linkdir ();\n  xexec (script_name);\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/tar.c": {
    "request_stdin": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nrequest_stdin (const char *option)\n{\n  if (stdin_used_by)\n    USAGE_ERROR ((0, 0, _(\"Options '%s' and '%s' both want standard input\"),\n\t\t  stdin_used_by, option));\n\n  stdin_used_by = option;\n}",
      "lines": 9,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "confirm": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\nconfirm (const char *message_action, const char *message_name)\n{\n  static FILE *confirm_file;\n  static int confirm_file_EOF;\n  bool status = false;\n\n  if (!confirm_file)\n    {\n      if (archive == 0 || stdin_used_by)\n\t{\n\t  confirm_file = fopen (TTY_NAME, \"r\");\n\t  if (! confirm_file)\n\t    open_fatal (TTY_NAME);\n\t}\n      else\n\t{\n\t  request_stdin (\"-w\");\n\t  confirm_file = stdin;\n\t}\n    }\n\n  fprintf (stdlis, \"%s %s?\", message_action, quote (message_name));\n  fflush (stdlis);\n\n  if (!confirm_file_EOF)\n    {\n      char *response = NULL;\n      size_t response_size = 0;\n      if (getline (&response, &response_size, confirm_file) < 0)\n\tconfirm_file_EOF = 1;\n      else\n\tstatus = rpmatch (response) > 0;\n      free (response);\n    }\n\n  if (confirm_file_EOF)\n    {\n      fputc ('\\n', stdlis);\n      fflush (stdlis);\n    }\n\n  return status;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "set_archive_format": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "static void\nset_archive_format (char const *name)\n{\n  struct fmttab const *p;\n\n  for (p = fmttab; strcmp (p->name, name) != 0; )\n    if (! (++p)->name)\n      USAGE_ERROR ((0, 0, _(\"%s: Invalid archive format\"),\n\t\t    quotearg_colon (name)));\n\n  archive_format = p->fmt;\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_xattr_option": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static void\nset_xattr_option (int value)\n{\n  if (value == 1)\n    set_archive_format (\"posix\");\n  xattrs_option = value;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "archive_format_string": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "const char *\narchive_format_string (enum archive_format fmt)\n{\n  struct fmttab const *p;\n\n  for (p = fmttab; p->name; p++)\n    if (p->fmt == fmt)\n      return p->name;\n  return \"unknown?\";\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\narchive_format_string (enum archive_format fmt)",
        "*"
      ]
    },
    "assert_format": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static void\nassert_format(unsigned fmt_mask)\n{\n  if ((FORMAT_MASK (archive_format) & fmt_mask) == 0)\n    USAGE_ERROR ((0, 0,\n\t\t  _(\"GNU features wanted on incompatible archive format\")));\n}",
      "lines": 7,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "subcommand_string": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "const char *\nsubcommand_string (enum subcommand c)\n{\n  switch (c)\n    {\n    case UNKNOWN_SUBCOMMAND:\n      return \"unknown?\";\n\n    case APPEND_SUBCOMMAND:\n      return \"-r\";\n\n    case CAT_SUBCOMMAND:\n      return \"-A\";\n\n    case CREATE_SUBCOMMAND:\n      return \"-c\";\n\n    case DELETE_SUBCOMMAND:\n      return \"-D\";\n\n    case DIFF_SUBCOMMAND:\n      return \"-d\";\n\n    case EXTRACT_SUBCOMMAND:\n      return \"-x\";\n\n    case LIST_SUBCOMMAND:\n      return \"-t\";\n\n    case UPDATE_SUBCOMMAND:\n      return \"-u\";\n\n    case TEST_LABEL_SUBCOMMAND:\n      return \"--test-label\";\n    }\n  abort ();\n}",
      "lines": 37,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nsubcommand_string (enum subcommand c)",
        "*"
      ]
    },
    "tar_list_quoting_styles": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "static void\ntar_list_quoting_styles (struct obstack *stk, char const *prefix)\n{\n  int i;\n  size_t prefixlen = strlen (prefix);\n\n  for (i = 0; quoting_style_args[i]; i++)\n    {\n      obstack_grow (stk, prefix, prefixlen);\n      obstack_grow (stk, quoting_style_args[i],\n\t\t    strlen (quoting_style_args[i]));\n      obstack_1grow (stk, '\\n');\n    }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tar_set_quoting_style": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "static void\ntar_set_quoting_style (char *arg)\n{\n  int i;\n\n  for (i = 0; quoting_style_args[i]; i++)\n    if (strcmp (arg, quoting_style_args[i]) == 0)\n      {\n\tset_quoting_style (NULL, i);\n\treturn;\n      }\n  FATAL_ERROR ((0, 0,\n\t\t_(\"Unknown quoting style '%s'. Try '%s --quoting-style=help' to get a list.\"), arg, program_name));\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "format_default_settings": {
      "start_point": [
        820,
        0
      ],
      "end_point": [
        837,
        1
      ],
      "content": "static char *\nformat_default_settings (void)\n{\n  return xasprintf (\n\t    \"--format=%s -f%s -b%d --quoting-style=%s --rmt-command=%s\"\n#ifdef REMOTE_SHELL\n\t    \" --rsh-command=%s\"\n#endif\n\t    ,\n\t    archive_format_string (DEFAULT_ARCHIVE_FORMAT),\n\t    DEFAULT_ARCHIVE, DEFAULT_BLOCKING,\n\t    quoting_style_args[DEFAULT_QUOTING_STYLE],\n\t    DEFAULT_RMT_COMMAND\n#ifdef REMOTE_SHELL\n\t    , REMOTE_SHELL\n#endif\n\t    );\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nformat_default_settings (void)",
        "*"
      ]
    },
    "option_conflict_error": {
      "start_point": [
        839,
        0
      ],
      "end_point": [
        845,
        1
      ],
      "content": "static void\noption_conflict_error (const char *a, const char *b)\n{\n  /* TRANSLATORS: Both %s in this statement are replaced with\n     option names. */\n  USAGE_ERROR ((0, 0, _(\"'%s' cannot be used with '%s'\"), a, b));\n}",
      "lines": 7,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "optloc_save": {
      "start_point": [
        870,
        0
      ],
      "end_point": [
        896,
        1
      ],
      "content": "static struct option_locus *\noptloc_save (unsigned int id, struct option_locus *loc)\n{\n  struct option_locus *optloc;\n  char *p;\n  size_t s;\n\n  if (id >= sizeof (option_class) / sizeof (option_class[0]))\n    abort ();\n  s = sizeof (*loc);\n  if (loc->name)\n    s += strlen (loc->name) + 1;\n  optloc = xmalloc (s);\n  if (loc->name)\n    {\n      p = (char*) optloc + sizeof (*loc);\n      strcpy (p, loc->name);\n      optloc->name = p;\n    }\n  else\n    optloc->name = NULL;\n  optloc->source = loc->source;\n  optloc->line = loc->line;\n  optloc->prev = option_class[id];\n  option_class[id] = optloc;\n  return optloc->prev;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct option_locus",
        "struct",
        "option_locus",
        "*\noptloc_save (unsigned int id, struct option_locus *loc)",
        "*"
      ]
    },
    "optloc_lookup": {
      "start_point": [
        899,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "static struct option_locus *\noptloc_lookup (int id)\n{\n  return option_class[id];\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "struct option_locus",
        "struct",
        "option_locus",
        "*\noptloc_lookup (int id)",
        "*"
      ]
    },
    "option_set_in_cl": {
      "start_point": [
        906,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "static int\noption_set_in_cl (int id)\n{\n  struct option_locus *loc = optloc_lookup (id);\n  if (!loc)\n    return 0;\n  return loc->source == OPTS_COMMAND_LINE;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "optloc_eq": {
      "start_point": [
        916,
        0
      ],
      "end_point": [
        924,
        1
      ],
      "content": "static int\noptloc_eq (struct option_locus *a, struct option_locus *b)\n{\n  if (a->source != b->source)\n    return 0;\n  if (a->source == OPTS_COMMAND_LINE)\n    return 1;\n  return strcmp (a->name, b->name) == 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_subcommand_option": {
      "start_point": [
        926,
        0
      ],
      "end_point": [
        935,
        1
      ],
      "content": "static void\nset_subcommand_option (enum subcommand subcommand)\n{\n  if (subcommand_option != UNKNOWN_SUBCOMMAND\n      && subcommand_option != subcommand)\n    USAGE_ERROR ((0, 0,\n\t\t  _(\"You may not specify more than one '-Acdtrux', '--delete' or  '--test-label' option\")));\n\n  subcommand_option = subcommand;\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_use_compress_program_option": {
      "start_point": [
        937,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "static void\nset_use_compress_program_option (const char *string, struct option_locus *loc)\n{\n  struct option_locus *p = optloc_save (OC_COMPRESS, loc);\n  if (use_compress_program_option\n      && strcmp (use_compress_program_option, string) != 0\n      && p->source == OPTS_COMMAND_LINE)\n    USAGE_ERROR ((0, 0, _(\"Conflicting compression options\")));\n\n  use_compress_program_option = string;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigstat": {
      "start_point": [
        949,
        0
      ],
      "end_point": [
        957,
        1
      ],
      "content": "static void\nsigstat (int signo)\n{\n  compute_duration ();\n  print_total_stats ();\n#ifndef HAVE_SIGACTION\n  signal (signo, sigstat);\n#endif\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "stat_on_signal": {
      "start_point": [
        959,
        0
      ],
      "end_point": [
        974,
        1
      ],
      "content": "static void\nstat_on_signal (int signo)\n{\n#ifdef HAVE_SIGACTION\n# ifndef SA_RESTART\n#  define SA_RESTART 0\n# endif\n  struct sigaction act;\n  act.sa_handler = sigstat;\n  sigemptyset (&act.sa_mask);\n  act.sa_flags = SA_RESTART;\n  sigaction (signo, &act, NULL);\n#else\n  signal (signo, sigstat);\n#endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_stat_signal": {
      "start_point": [
        976,
        0
      ],
      "end_point": [
        1004,
        1
      ],
      "content": "static void\nset_stat_signal (const char *name)\n{\n  static struct sigtab\n  {\n    char const *name;\n    int signo;\n  } const sigtab[] = {\n    { \"SIGUSR1\", SIGUSR1 },\n    { \"USR1\", SIGUSR1 },\n    { \"SIGUSR2\", SIGUSR2 },\n    { \"USR2\", SIGUSR2 },\n    { \"SIGHUP\", SIGHUP },\n    { \"HUP\", SIGHUP },\n    { \"SIGINT\", SIGINT },\n    { \"INT\", SIGINT },\n    { \"SIGQUIT\", SIGQUIT },\n    { \"QUIT\", SIGQUIT }\n  };\n  struct sigtab const *p;\n\n  for (p = sigtab; p < sigtab + sizeof (sigtab) / sizeof (sigtab[0]); p++)\n    if (strcmp (p->name, name) == 0)\n      {\n\tstat_on_signal (p->signo);\n\treturn;\n      }\n  FATAL_ERROR ((0, 0, _(\"Unknown signal name: %s\"), name));\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_date_or_file": {
      "start_point": [
        1015,
        0
      ],
      "end_point": [
        1051,
        1
      ],
      "content": "static int\nget_date_or_file (struct tar_args *args, const char *option,\n\t\t  const char *str, struct timespec *ts)\n{\n  if (FILE_SYSTEM_PREFIX_LEN (str) != 0\n      || ISSLASH (*str)\n      || *str == '.')\n    {\n      struct stat st;\n      if (stat (str, &st) != 0)\n\t{\n\t  stat_error (str);\n\t  USAGE_ERROR ((0, 0, _(\"Date sample file not found\")));\n\t}\n      *ts = get_stat_mtime (&st);\n    }\n  else\n    {\n      if (! parse_datetime (ts, str, NULL))\n\t{\n\t  WARN ((0, 0, _(\"Substituting %s for unknown date format %s\"),\n\t\t tartime (*ts, false), quote (str)));\n\t  ts->tv_nsec = 0;\n\t  return 1;\n\t}\n      else\n\t{\n\t  struct textual_date *p = xmalloc (sizeof (*p));\n\t  p->ts = *ts;\n\t  p->option = option;\n\t  p->date = xstrdup (str);\n\t  p->next = args->textual_date;\n\t  args->textual_date = p;\n\t}\n    }\n  return 0;\n}",
      "lines": 37,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "report_textual_dates": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1071,
        1
      ],
      "content": "static void\nreport_textual_dates (struct tar_args *args)\n{\n  struct textual_date *p;\n  for (p = args->textual_date; p; )\n    {\n      struct textual_date *next = p->next;\n      if (verbose_option)\n\t{\n\t  char const *treated_as = tartime (p->ts, true);\n\t  if (strcmp (p->date, treated_as) != 0)\n\t    WARN ((0, 0, _(\"Option %s: Treating date '%s' as %s\"),\n\t\t   p->option, p->date, treated_as));\n\t}\n      free (p->date);\n      free (p);\n      p = next;\n    }\n}",
      "lines": 19,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tar_help_filter": {
      "start_point": [
        1091,
        0
      ],
      "end_point": [
        1151,
        1
      ],
      "content": "static char *\ntar_help_filter (int key, const char *text, void *input)\n{\n  struct obstack stk;\n  char *s;\n\n  switch (key)\n    {\n    default:\n      s = (char*) text;\n      break;\n\n    case 'j':\n      s = xasprintf (_(\"filter the archive through %s\"), BZIP2_PROGRAM);\n      break;\n\n    case 'z':\n      s = xasprintf (_(\"filter the archive through %s\"), GZIP_PROGRAM);\n      break;\n\n    case 'Z':\n      s = xasprintf (_(\"filter the archive through %s\"), COMPRESS_PROGRAM);\n      break;\n\n    case LZIP_OPTION:\n      s = xasprintf (_(\"filter the archive through %s\"), LZIP_PROGRAM);\n      break;\n\n    case LZMA_OPTION:\n      s = xasprintf (_(\"filter the archive through %s\"), LZMA_PROGRAM);\n      break;\n\n    case LZOP_OPTION:\n      s = xasprintf (_(\"filter the archive through %s\"), LZOP_PROGRAM);\n      break;\n\n    case 'J':\n      s = xasprintf (_(\"filter the archive through %s\"), XZ_PROGRAM);\n      break;\n\n    case ARGP_KEY_HELP_EXTRA:\n      {\n\tconst char *tstr;\n\n\tobstack_init (&stk);\n\ttstr = _(\"Valid arguments for the --quoting-style option are:\");\n\tobstack_grow (&stk, tstr, strlen (tstr));\n\tobstack_grow (&stk, \"\\n\\n\", 2);\n\ttar_list_quoting_styles (&stk, \"  \");\n\ttstr = _(\"\\n*This* tar defaults to:\\n\");\n\tobstack_grow (&stk, tstr, strlen (tstr));\n\ts = format_default_settings ();\n\tobstack_grow (&stk, s, strlen (s));\n\tobstack_1grow (&stk, '\\n');\n\tobstack_1grow (&stk, 0);\n\ts = xstrdup (obstack_finish (&stk));\n\tobstack_free (&stk, NULL);\n      }\n    }\n  return s;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ntar_help_filter (int key, const char *text, void *input)",
        "*"
      ]
    },
    "expand_pax_option": {
      "start_point": [
        1153,
        0
      ],
      "end_point": [
        1204,
        1
      ],
      "content": "static char *\nexpand_pax_option (struct tar_args *targs, const char *arg)\n{\n  struct obstack stk;\n  char *res;\n\n  obstack_init (&stk);\n  while (*arg)\n    {\n      size_t seglen = strcspn (arg, \",\");\n      char *p = memchr (arg, '=', seglen);\n      if (p)\n\t{\n\t  size_t len = p - arg + 1;\n\t  obstack_grow (&stk, arg, len);\n\t  len = seglen - len;\n\t  for (++p; *p && isspace ((unsigned char) *p); p++)\n\t    len--;\n\t  if (*p == '{' && p[len-1] == '}')\n\t    {\n\t      struct timespec ts;\n\t      char *tmp = xmalloc (len);\n\t      memcpy (tmp, p + 1, len-2);\n\t      tmp[len-2] = 0;\n\t      if (get_date_or_file (targs, \"--pax-option\", tmp, &ts) == 0)\n\t\t{\n\t\t  char buf[TIMESPEC_STRSIZE_BOUND];\n\t\t  char const *s = code_timespec (ts, buf);\n\t\t  obstack_grow (&stk, s, strlen (s));\n\t\t}\n\t      else\n\t\tobstack_grow (&stk, p, len);\n\t      free (tmp);\n\t    }\n\t  else\n\t    obstack_grow (&stk, p, len);\n\t}\n      else\n\tobstack_grow (&stk, arg, seglen);\n\n      arg += seglen;\n      if (*arg)\n\t{\n\t  obstack_1grow (&stk, *arg);\n\t  arg++;\n\t}\n    }\n  obstack_1grow (&stk, 0);\n  res = xstrdup (obstack_finish (&stk));\n  obstack_free (&stk, NULL);\n  return res;\n}",
      "lines": 52,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nexpand_pax_option (struct tar_args *targs, const char *arg)",
        "*"
      ]
    },
    "parse_owner_group": {
      "start_point": [
        1207,
        0
      ],
      "end_point": [
        1256,
        1
      ],
      "content": "static uintmax_t\nparse_owner_group (char *arg, uintmax_t field_max, char const **name_option)\n{\n  uintmax_t u = UINTMAX_MAX;\n  char *end;\n  char const *name = 0;\n  char const *invalid_num = 0;\n  char *colon = strchr (arg, ':');\n\n  if (colon)\n    {\n      char const *num = colon + 1;\n      *colon = '\\0';\n      if (*arg)\n\tname = arg;\n      if (num && (! (xstrtoumax (num, &end, 10, &u, \"\") == LONGINT_OK\n\t\t     && u <= field_max)))\n\tinvalid_num = num;\n    }\n  else\n    {\n      uintmax_t u1;\n      switch ('0' <= *arg && *arg <= '9'\n\t      ? xstrtoumax (arg, &end, 10, &u1, \"\")\n\t      : LONGINT_INVALID)\n\t{\n\tdefault:\n\t  name = arg;\n\t  break;\n\n\tcase LONGINT_OK:\n\t  if (u1 <= field_max)\n\t    {\n\t      u = u1;\n\t      break;\n\t    }\n\t  FALLTHROUGH;\n\tcase LONGINT_OVERFLOW:\n\t  invalid_num = arg;\n\t  break;\n\t}\n    }\n\n  if (invalid_num)\n    FATAL_ERROR ((0, 0, \"%s: %s\", quotearg_colon (invalid_num),\n\t\t  _(\"Invalid owner or group ID\")));\n  if (name)\n    *name_option = name;\n  return u;\n}",
      "lines": 50,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "uintmax_t"
      ]
    },
    "set_old_files_option": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1311,
        1
      ],
      "content": "static void\nset_old_files_option (int code, struct option_locus *loc)\n{\n  struct option_locus *prev;\n  static char const *const code_to_opt[] = {\n    \"--overwrite-dir\",\n    \"--no-overwrite-dir\",\n    \"--overwrite\",\n    \"--unlink-first\",\n    \"--keep-old-files\",\n    \"--skip-old-files\",\n    \"--keep-newer-files\"\n  };\n\n  prev = optloc_save (OC_OLD_FILES, loc);\n  if (prev && optloc_eq (loc, prev) && code != old_files_option)\n    option_conflict_error (code_to_opt[code], code_to_opt[old_files_option]);\n\n  old_files_option = code;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_opt": {
      "start_point": [
        1314,
        0
      ],
      "end_point": [
        2082,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  struct tar_args *args = state->input;\n\n  switch (key)\n    {\n    case ARGP_KEY_ARG:\n      /* File name or non-parsed option, because of ARGP_IN_ORDER */\n      name_add_name (arg);\n      break;\n\n    case 'A':\n      set_subcommand_option (CAT_SUBCOMMAND);\n      break;\n\n    case 'a':\n      args->compress_autodetect = true;\n      break;\n\n    case NO_AUTO_COMPRESS_OPTION:\n      args->compress_autodetect = false;\n      break;\n\n    case 'b':\n      {\n\tuintmax_t u;\n\tif (! (xstrtoumax (arg, 0, 10, &u, \"\") == LONGINT_OK\n\t       && u == (blocking_factor = u)\n\t       && 0 < blocking_factor\n\t       && u == (record_size = u * BLOCKSIZE) / BLOCKSIZE))\n\t  USAGE_ERROR ((0, 0, \"%s: %s\", quotearg_colon (arg),\n\t\t\t_(\"Invalid blocking factor\")));\n      }\n      break;\n\n    case 'B':\n      /* Try to reblock input records.  For reading 4.2BSD pipes.  */\n\n      /* It would surely make sense to exchange -B and -R, but it seems\n\t that -B has been used for a long while in Sun tar and most\n\t BSD-derived systems.  This is a consequence of the block/record\n\t terminology confusion.  */\n\n      read_full_records_option = true;\n      break;\n\n    case 'c':\n      set_subcommand_option (CREATE_SUBCOMMAND);\n      break;\n\n    case CLAMP_MTIME_OPTION:\n      set_mtime_option = CLAMP_MTIME;\n      break;\n\n    case 'd':\n      set_subcommand_option (DIFF_SUBCOMMAND);\n      break;\n\n    case 'f':\n      if (archive_names == allocated_archive_names)\n\tarchive_name_array = x2nrealloc (archive_name_array,\n\t\t\t\t\t &allocated_archive_names,\n\t\t\t\t\t sizeof (archive_name_array[0]));\n\n      archive_name_array[archive_names++] = arg;\n      break;\n\n    case 'F':\n      /* Since -F is only useful with -M, make it implied.  Run this\n\t script at the end of each tape.  */\n\n      info_script_option = arg;\n      multi_volume_option = true;\n      break;\n\n    case FULL_TIME_OPTION:\n      full_time_option = true;\n      break;\n\n    case 'g':\n      optloc_save (OC_LISTED_INCREMENTAL, args->loc);\n      listed_incremental_option = arg;\n      after_date_option = true;\n      FALLTHROUGH;\n    case 'G':\n      /* We are making an incremental dump (FIXME: are we?); save\n\t directories at the beginning of the archive, and include in each\n\t directory its contents.  */\n\n      incremental_option = true;\n      break;\n\n    case 'h':\n      /* Follow symbolic links.  */\n      dereference_option = true;\n      break;\n\n    case HARD_DEREFERENCE_OPTION:\n      hard_dereference_option = true;\n      break;\n\n    case 'i':\n      /* Ignore zero blocks (eofs).  This can't be the default,\n\t because Unix tar writes two blocks of zeros, then pads out\n\t the record with garbage.  */\n\n      ignore_zeros_option = true;\n      break;\n\n    case 'j':\n      set_use_compress_program_option (BZIP2_PROGRAM, args->loc);\n      break;\n\n    case 'J':\n      set_use_compress_program_option (XZ_PROGRAM, args->loc);\n      break;\n\n    case 'k':\n      /* Don't replace existing files.  */\n      set_old_files_option (KEEP_OLD_FILES, args->loc);\n      break;\n\n    case 'K':\n      optloc_save (OC_STARTING_FILE, args->loc);\n      starting_file_option = true;\n      addname (arg, 0, true, NULL);\n      break;\n\n    case ONE_FILE_SYSTEM_OPTION:\n      /* When dumping directories, don't dump files/subdirectories\n\t that are on other filesystems. */\n      one_file_system_option = true;\n      break;\n\n    case ONE_TOP_LEVEL_OPTION:\n      optloc_save (OC_ONE_TOP_LEVEL, args->loc);\n      one_top_level_option = true;\n      one_top_level_dir = arg;\n      break;\n\n    case 'l':\n      check_links_option = 1;\n      break;\n\n    case 'L':\n      {\n\tuintmax_t u;\n\tchar *p;\n\n\tif (xstrtoumax (arg, &p, 10, &u, TAR_SIZE_SUFFIXES) != LONGINT_OK)\n\t  USAGE_ERROR ((0, 0, \"%s: %s\", quotearg_colon (arg),\n\t\t\t_(\"Invalid tape length\")));\n\tif (p > arg && !strchr (TAR_SIZE_SUFFIXES, p[-1]))\n\t  tape_length_option = 1024 * (tarlong) u;\n\telse\n\t  tape_length_option = (tarlong) u;\n\tmulti_volume_option = true;\n      }\n      break;\n\n    case LEVEL_OPTION:\n      {\n\tchar *p;\n\tincremental_level = strtoul (arg, &p, 10);\n\tif (*p)\n\t  USAGE_ERROR ((0, 0, _(\"Invalid incremental level value\")));\n      }\n      break;\n\n    case LZIP_OPTION:\n      set_use_compress_program_option (LZIP_PROGRAM, args->loc);\n      break;\n\n    case LZMA_OPTION:\n      set_use_compress_program_option (LZMA_PROGRAM, args->loc);\n      break;\n\n    case LZOP_OPTION:\n      set_use_compress_program_option (LZOP_PROGRAM, args->loc);\n      break;\n\n    case 'm':\n      touch_option = true;\n      break;\n\n    case 'M':\n      /* Make multivolume archive: when we can't write any more into\n\t the archive, re-open it, and continue writing.  */\n\n      multi_volume_option = true;\n      break;\n\n    case MTIME_OPTION:\n      get_date_or_file (args, \"--mtime\", arg, &mtime_option);\n      if (set_mtime_option == USE_FILE_MTIME)\n        set_mtime_option = FORCE_MTIME;\n      break;\n\n    case 'n':\n      seek_option = 1;\n      break;\n\n    case NO_SEEK_OPTION:\n      seek_option = 0;\n      break;\n\n    case 'N':\n      after_date_option = true;\n      FALLTHROUGH;\n    case NEWER_MTIME_OPTION:\n      if (TIME_OPTION_INITIALIZED (newer_mtime_option))\n\tUSAGE_ERROR ((0, 0, _(\"More than one threshold date\")));\n      get_date_or_file (args,\n\t\t\tkey == NEWER_MTIME_OPTION ? \"--newer-mtime\"\n\t\t\t: \"--after-date\", arg, &newer_mtime_option);\n      optloc_save (OC_NEWER, args->loc);\n      break;\n\n    case 'o':\n      args->o_option = true;\n      break;\n\n    case 'O':\n      to_stdout_option = true;\n      break;\n\n    case 'p':\n      same_permissions_option = true;\n      break;\n\n    case 'P':\n      optloc_save (OC_ABSOLUTE_NAMES, args->loc);\n      absolute_names_option = true;\n      break;\n\n    case 'r':\n      set_subcommand_option (APPEND_SUBCOMMAND);\n      break;\n\n    case 'R':\n      /* Print block numbers for debugging bad tar archives.  */\n\n      /* It would surely make sense to exchange -B and -R, but it seems\n\t that -B has been used for a long while in Sun tar and most\n\t BSD-derived systems.  This is a consequence of the block/record\n\t terminology confusion.  */\n\n      block_number_option = true;\n      break;\n\n    case 's':\n      /* Names to extract are sorted.  */\n      optloc_save (OC_SAME_ORDER, args->loc);\n      same_order_option = true;\n      break;\n\n    case 'S':\n      sparse_option = true;\n      break;\n\n    case SKIP_OLD_FILES_OPTION:\n      set_old_files_option (SKIP_OLD_FILES, args->loc);\n      break;\n\n    case HOLE_DETECTION_OPTION:\n      hole_detection = XARGMATCH (\"--hole-detection\", arg,\n\t\t\t\t  hole_detection_args, hole_detection_types);\n      sparse_option = true;\n      break;\n\n    case SPARSE_VERSION_OPTION:\n      sparse_option = true;\n      {\n\tchar *p;\n\ttar_sparse_major = strtoul (arg, &p, 10);\n\tif (*p)\n\t  {\n\t    if (*p != '.')\n\t      USAGE_ERROR ((0, 0, _(\"Invalid sparse version value\")));\n\t    tar_sparse_minor = strtoul (p + 1, &p, 10);\n\t    if (*p)\n\t      USAGE_ERROR ((0, 0, _(\"Invalid sparse version value\")));\n\t  }\n      }\n      break;\n\n    case 't':\n      set_subcommand_option (LIST_SUBCOMMAND);\n      verbose_option++;\n      break;\n\n    case TEST_LABEL_OPTION:\n      set_subcommand_option (TEST_LABEL_SUBCOMMAND);\n      break;\n\n    case 'u':\n      set_subcommand_option (UPDATE_SUBCOMMAND);\n      break;\n\n    case 'U':\n      set_old_files_option (UNLINK_FIRST_OLD_FILES, args->loc);\n      break;\n\n    case UTC_OPTION:\n      utc_option = true;\n      break;\n\n    case 'v':\n      verbose_option++;\n      warning_option |= WARN_VERBOSE_WARNINGS;\n      break;\n\n    case 'V':\n      volume_label_option = arg;\n      break;\n\n    case 'w':\n      interactive_option = true;\n      break;\n\n    case 'W':\n      optloc_save (OC_VERIFY, args->loc);\n      verify_option = true;\n      break;\n\n    case 'x':\n      set_subcommand_option (EXTRACT_SUBCOMMAND);\n      break;\n\n    case 'z':\n      set_use_compress_program_option (GZIP_PROGRAM, args->loc);\n      break;\n\n    case 'Z':\n      set_use_compress_program_option (COMPRESS_PROGRAM, args->loc);\n      break;\n\n    case ATIME_PRESERVE_OPTION:\n      atime_preserve_option =\n\t(arg\n\t ? XARGMATCH (\"--atime-preserve\", arg,\n\t\t      atime_preserve_args, atime_preserve_types)\n\t : replace_atime_preserve);\n      if (! O_NOATIME && atime_preserve_option == system_atime_preserve)\n\tFATAL_ERROR ((0, 0,\n\t\t      _(\"--atime-preserve='system' is not supported\"\n\t\t\t\" on this platform\")));\n      break;\n\n    case CHECK_DEVICE_OPTION:\n      check_device_option = true;\n      break;\n\n    case NO_CHECK_DEVICE_OPTION:\n      check_device_option = false;\n      break;\n\n    case CHECKPOINT_OPTION:\n      if (arg)\n\t{\n\t  char *p;\n\n\t  if (*arg == '.')\n\t    {\n\t      checkpoint_compile_action (\".\");\n\t      arg++;\n\t    }\n\t  checkpoint_option = strtoul (arg, &p, 0);\n\t  if (*p)\n\t    FATAL_ERROR ((0, 0,\n\t\t\t  _(\"--checkpoint value is not an integer\")));\n\t}\n      else\n\tcheckpoint_option = DEFAULT_CHECKPOINT;\n      break;\n\n    case CHECKPOINT_ACTION_OPTION:\n      checkpoint_compile_action (arg);\n      break;\n\n    case BACKUP_OPTION:\n      backup_option = true;\n      if (arg)\n\targs->version_control_string = arg;\n      break;\n\n    case DELAY_DIRECTORY_RESTORE_OPTION:\n      delay_directory_restore_option = true;\n      break;\n\n    case NO_DELAY_DIRECTORY_RESTORE_OPTION:\n      delay_directory_restore_option = false;\n      break;\n\n    case DELETE_OPTION:\n      set_subcommand_option (DELETE_SUBCOMMAND);\n      break;\n\n    case FORCE_LOCAL_OPTION:\n      force_local_option = true;\n      break;\n\n    case 'H':\n      set_archive_format (arg);\n      break;\n\n    case INDEX_FILE_OPTION:\n      index_file_name = arg;\n      break;\n\n    case IGNORE_COMMAND_ERROR_OPTION:\n      ignore_command_error_option = true;\n      break;\n\n    case IGNORE_FAILED_READ_OPTION:\n      ignore_failed_read_option = true;\n      break;\n\n    case KEEP_DIRECTORY_SYMLINK_OPTION:\n      keep_directory_symlink_option = true;\n      break;\n\n    case KEEP_NEWER_FILES_OPTION:\n      set_old_files_option (KEEP_NEWER_FILES, args->loc);\n      break;\n\n    case GROUP_OPTION:\n      {\n\tuintmax_t u = parse_owner_group (arg, TYPE_MAXIMUM (gid_t),\n\t\t\t\t\t &group_name_option);\n\tif (u == UINTMAX_MAX)\n\t  {\n\t    group_option = -1;\n\t    if (group_name_option)\n\t      gname_to_gid (group_name_option, &group_option);\n\t  }\n\telse\n\t  group_option = u;\n      }\n      break;\n\n    case GROUP_MAP_OPTION:\n      group_map_read (arg);\n      break;\n\n    case MODE_OPTION:\n      mode_option = mode_compile (arg);\n      if (!mode_option)\n\tFATAL_ERROR ((0, 0, _(\"Invalid mode given on option\")));\n      initial_umask = umask (0);\n      umask (initial_umask);\n      break;\n\n    case NO_IGNORE_COMMAND_ERROR_OPTION:\n      ignore_command_error_option = false;\n      break;\n\n    case NO_OVERWRITE_DIR_OPTION:\n      set_old_files_option (NO_OVERWRITE_DIR_OLD_FILES, args->loc);\n      break;\n\n    case NO_QUOTE_CHARS_OPTION:\n      for (;*arg; arg++)\n\tset_char_quoting (NULL, *arg, 0);\n      break;\n\n    case NUMERIC_OWNER_OPTION:\n      numeric_owner_option = true;\n      break;\n\n    case OCCURRENCE_OPTION:\n      optloc_save (OC_OCCURRENCE, args->loc);\n      if (!arg)\n\toccurrence_option = 1;\n      else\n\t{\n\t  uintmax_t u;\n\t  if (xstrtoumax (arg, 0, 10, &u, \"\") == LONGINT_OK)\n\t    occurrence_option = u;\n\t  else\n\t    FATAL_ERROR ((0, 0, \"%s: %s\", quotearg_colon (arg),\n\t\t\t  _(\"Invalid number\")));\n\t}\n      break;\n\n    case OLD_ARCHIVE_OPTION:\n      set_archive_format (\"v7\");\n      break;\n\n    case OVERWRITE_DIR_OPTION:\n      set_old_files_option (DEFAULT_OLD_FILES, args->loc);\n      break;\n\n    case OVERWRITE_OPTION:\n      set_old_files_option (OVERWRITE_OLD_FILES, args->loc);\n      break;\n\n    case OWNER_OPTION:\n      {\n\tuintmax_t u = parse_owner_group (arg, TYPE_MAXIMUM (uid_t),\n\t\t\t\t\t &owner_name_option);\n\tif (u == UINTMAX_MAX)\n\t  {\n\t    owner_option = -1;\n\t    if (owner_name_option)\n\t      uname_to_uid (owner_name_option, &owner_option);\n\t  }\n\telse\n\t  owner_option = u;\n      }\n      break;\n\n    case OWNER_MAP_OPTION:\n      owner_map_read (arg);\n      break;\n\n    case QUOTE_CHARS_OPTION:\n      for (;*arg; arg++)\n\tset_char_quoting (NULL, *arg, 1);\n      break;\n\n    case QUOTING_STYLE_OPTION:\n      tar_set_quoting_style (arg);\n      break;\n\n    case PAX_OPTION:\n      {\n\tchar *tmp = expand_pax_option (args, arg);\n\targs->pax_option = true;\n\txheader_set_option (tmp);\n\tfree (tmp);\n      }\n      break;\n\n    case POSIX_OPTION:\n      set_archive_format (\"posix\");\n      break;\n\n    case RECORD_SIZE_OPTION:\n      {\n\tuintmax_t u;\n\n\tif (! (xstrtoumax (arg, NULL, 10, &u, TAR_SIZE_SUFFIXES) == LONGINT_OK\n\t       && u == (size_t) u))\n\t  USAGE_ERROR ((0, 0, \"%s: %s\", quotearg_colon (arg),\n\t\t\t_(\"Invalid record size\")));\n\trecord_size = u;\n\tif (record_size % BLOCKSIZE != 0)\n\t  USAGE_ERROR ((0, 0, _(\"Record size must be a multiple of %d.\"),\n\t\t\tBLOCKSIZE));\n\tblocking_factor = record_size / BLOCKSIZE;\n      }\n      break;\n\n    case RECURSIVE_UNLINK_OPTION:\n      recursive_unlink_option = true;\n      break;\n\n    case REMOVE_FILES_OPTION:\n      remove_files_option = true;\n      break;\n\n    case RESTRICT_OPTION:\n      restrict_option = true;\n      break;\n\n    case RMT_COMMAND_OPTION:\n      rmt_command = arg;\n      break;\n\n    case RSH_COMMAND_OPTION:\n      rsh_command_option = arg;\n      break;\n\n    case SHOW_DEFAULTS_OPTION:\n      {\n\tchar *s = format_default_settings ();\n\tprintf (\"%s\\n\", s);\n\tclose_stdout ();\n\tfree (s);\n\texit (0);\n      }\n\n    case SHOW_SNAPSHOT_FIELD_RANGES_OPTION:\n      show_snapshot_field_ranges ();\n      close_stdout ();\n      exit (0);\n\n    case STRIP_COMPONENTS_OPTION:\n      {\n\tuintmax_t u;\n\tif (! (xstrtoumax (arg, 0, 10, &u, \"\") == LONGINT_OK\n\t       && u == (size_t) u))\n\t  USAGE_ERROR ((0, 0, \"%s: %s\", quotearg_colon (arg),\n\t\t\t_(\"Invalid number of elements\")));\n\tstrip_name_components = u;\n      }\n      break;\n\n    case SHOW_OMITTED_DIRS_OPTION:\n      show_omitted_dirs_option = true;\n      break;\n\n    case SHOW_TRANSFORMED_NAMES_OPTION:\n      show_transformed_names_option = true;\n      break;\n\n    case SORT_OPTION:\n      savedir_sort_order = XARGMATCH (\"--sort\", arg,\n\t\t\t\t      sort_mode_arg, sort_mode_flag);\n      break;\n\n    case SUFFIX_OPTION:\n      backup_option = true;\n      args->backup_suffix_string = arg;\n      break;\n\n    case TO_COMMAND_OPTION:\n      if (to_command_option)\n        USAGE_ERROR ((0, 0, _(\"Only one --to-command option allowed\")));\n      to_command_option = arg;\n      break;\n\n    case TOTALS_OPTION:\n      if (arg)\n\tset_stat_signal (arg);\n      else\n\ttotals_option = true;\n      break;\n\n    case TRANSFORM_OPTION:\n      set_transform_expr (arg);\n      break;\n\n    case 'I':\n      set_use_compress_program_option (arg, args->loc);\n      break;\n\n    case VOLNO_FILE_OPTION:\n      volno_file_option = arg;\n      break;\n\n    case NO_SAME_OWNER_OPTION:\n      same_owner_option = -1;\n      break;\n\n    case NO_SAME_PERMISSIONS_OPTION:\n      same_permissions_option = -1;\n      break;\n\n    case ACLS_OPTION:\n      set_archive_format (\"posix\");\n      acls_option = 1;\n      break;\n\n    case NO_ACLS_OPTION:\n      acls_option = -1;\n      break;\n\n    case SELINUX_CONTEXT_OPTION:\n      set_archive_format (\"posix\");\n      selinux_context_option = 1;\n      break;\n\n    case NO_SELINUX_CONTEXT_OPTION:\n      selinux_context_option = -1;\n      break;\n\n    case XATTR_OPTION:\n      set_xattr_option (1);\n      break;\n\n    case NO_XATTR_OPTION:\n      set_xattr_option (-1);\n      break;\n\n    case XATTR_INCLUDE:\n    case XATTR_EXCLUDE:\n      set_xattr_option (1);\n      xattrs_mask_add (arg, (key == XATTR_INCLUDE));\n      break;\n\n    case SAME_OWNER_OPTION:\n      same_owner_option = 1;\n      break;\n\n    case WARNING_OPTION:\n      set_warning_option (arg);\n      break;\n\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n\n#ifdef DEVICE_PREFIX\n      {\n\tint device = key - '0';\n\tint density;\n\tstatic char buf[sizeof DEVICE_PREFIX + 10];\n\tchar *cursor;\n\n\tif (arg[1])\n\t  argp_error (state, _(\"Malformed density argument: %s\"), quote (arg));\n\n\tstrcpy (buf, DEVICE_PREFIX);\n\tcursor = buf + strlen (buf);\n\n#ifdef DENSITY_LETTER\n\n\tsprintf (cursor, \"%d%c\", device, arg[0]);\n\n#else /* not DENSITY_LETTER */\n\n\tswitch (arg[0])\n\t  {\n\t  case 'l':\n\t    device += LOW_DENSITY_NUM;\n\t    break;\n\n\t  case 'm':\n\t    device += MID_DENSITY_NUM;\n\t    break;\n\n\t  case 'h':\n\t    device += HIGH_DENSITY_NUM;\n\t    break;\n\n\t  default:\n\t    argp_error (state, _(\"Unknown density: '%c'\"), arg[0]);\n\t  }\n\tsprintf (cursor, \"%d\", device);\n\n#endif /* not DENSITY_LETTER */\n\n\tif (archive_names == allocated_archive_names)\n\t  archive_name_array = x2nrealloc (archive_name_array,\n\t\t\t\t\t   &allocated_archive_names,\n\t\t\t\t\t   sizeof (archive_name_array[0]));\n\tarchive_name_array[archive_names++] = xstrdup (buf);\n      }\n      break;\n\n#else /* not DEVICE_PREFIX */\n\n      argp_error (state,\n\t\t  _(\"Options '-[0-7][lmh]' not supported by *this* tar\"));\n      exit (EX_USAGE);\n\n#endif /* not DEVICE_PREFIX */\n\n    case ARGP_KEY_ERROR:\n      if (args->loc->source == OPTS_FILE)\n\terror (0, 0, _(\"%s:%lu: location of the error\"), args->loc->name,\n\t       (unsigned long) args->loc->line);\n      else if (args->loc->source == OPTS_ENVIRON)\n\terror (0, 0, _(\"error parsing %s\"), args->loc->name);\n      exit (EX_USAGE);\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 769,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "usage": {
      "start_point": [
        2096,
        0
      ],
      "end_point": [
        2102,
        1
      ],
      "content": "void\nusage (int status)\n{\n  argp_help (&argp, stderr, ARGP_HELP_SEE, (char*) program_name);\n  close_stdout ();\n  exit (status);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "find_argp_option_key": {
      "start_point": [
        2106,
        0
      ],
      "end_point": [
        2118,
        1
      ],
      "content": "static struct argp_option const *\nfind_argp_option_key (struct argp_option const *o, int key)\n{\n  for (;\n       !(o->name == NULL\n\t && o->key == 0\n\t && o->arg == 0\n\t && o->flags == 0\n\t && o->doc == NULL); o++)\n    if (o->key == key)\n      return o;\n  return NULL;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct argp_option",
        "struct",
        "argp_option",
        "const",
        "const",
        "*\nfind_argp_option_key (struct argp_option const *o, int key)",
        "*"
      ]
    },
    "find_argp_option": {
      "start_point": [
        2120,
        0
      ],
      "end_point": [
        2137,
        1
      ],
      "content": "static struct argp_option const *\nfind_argp_option (struct argp *ap, int key)\n{\n  struct argp_option const *p = NULL;\n  struct argp_child const *child;\n\n  p = find_argp_option_key (ap->options, key);\n  if (!p && ap->children)\n    {\n      for (child = ap->children; child->argp; child++)\n\t{\n\t  p = find_argp_option_key (child->argp->options, key);\n\t  if (p)\n\t    break;\n\t}\n    }\n  return p;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct argp_option",
        "struct",
        "argp_option",
        "const",
        "const",
        "*\nfind_argp_option (struct argp *ap, int key)",
        "*"
      ]
    },
    "more_options": {
      "start_point": [
        2171,
        0
      ],
      "end_point": [
        2181,
        1
      ],
      "content": "void\nmore_options (int argc, char **argv, struct option_locus *loc)\n{\n  int idx;\n\n  args.loc = loc;\n  if (argp_parse (&argp, argc, argv, ARGP_IN_ORDER|ARGP_NO_EXIT, &idx, &args))\n    abort (); /* shouldn't happen */\n  if (loc->source == OPTS_ENVIRON && name_more_files ())\n    USAGE_ERROR ((0, 0, _(\"non-option arguments in %s\"), loc->name));\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "parse_default_options": {
      "start_point": [
        2183,
        0
      ],
      "end_point": [
        2205,
        1
      ],
      "content": "static void\nparse_default_options (void)\n{\n  char *opts = getenv (\"TAR_OPTIONS\");\n  struct wordsplit ws;\n  struct option_locus loc = { OPTS_ENVIRON, \"TAR_OPTIONS\", 0, 0 };\n\n  if (!opts)\n    return;\n\n  ws.ws_offs = 1;\n  if (wordsplit (opts, &ws, WRDSF_DEFFLAGS|WRDSF_DOOFFS))\n    FATAL_ERROR ((0, 0, _(\"cannot split TAR_OPTIONS: %s\"),\n\t\t  wordsplit_strerror (&ws)));\n  if (ws.ws_wordc)\n    {\n      ws.ws_wordv[0] = (char*) program_name;\n      more_options (ws.ws_offs + ws.ws_wordc, ws.ws_wordv, &loc);\n      /* Don't free consumed words */\n      ws.ws_wordc = 0;\n    }\n  wordsplit_free (&ws);\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "decode_options": {
      "start_point": [
        2207,
        0
      ],
      "end_point": [
        2657,
        1
      ],
      "content": "static void\ndecode_options (int argc, char **argv)\n{\n  int idx;\n  struct option_locus loc = { OPTS_COMMAND_LINE, 0, 0, 0 };\n\n  argp_version_setup (\"tar\", tar_authors);\n\n  /* Set some default option values.  */\n  args.textual_date = NULL;\n  args.o_option = false;\n  args.pax_option = false;\n  args.backup_suffix_string = getenv (\"SIMPLE_BACKUP_SUFFIX\");\n  args.version_control_string = 0;\n  args.compress_autodetect = false;\n\n  subcommand_option = UNKNOWN_SUBCOMMAND;\n  archive_format = DEFAULT_FORMAT;\n  blocking_factor = DEFAULT_BLOCKING;\n  record_size = DEFAULT_BLOCKING * BLOCKSIZE;\n  excluded = new_exclude ();\n  hole_detection = HOLE_DETECTION_DEFAULT;\n\n  newer_mtime_option.tv_sec = TYPE_MINIMUM (time_t);\n  newer_mtime_option.tv_nsec = -1;\n  mtime_option.tv_sec = TYPE_MINIMUM (time_t);\n  mtime_option.tv_nsec = -1;\n  recursion_option = FNM_LEADING_DIR;\n  unquote_option = true;\n  tar_sparse_major = 1;\n  tar_sparse_minor = 0;\n\n  savedir_sort_order = SAVEDIR_SORT_NONE;\n\n  owner_option = -1; owner_name_option = NULL;\n  group_option = -1; group_name_option = NULL;\n\n  check_device_option = true;\n\n  incremental_level = -1;\n\n  seek_option = -1;\n\n  /* Convert old-style tar call by exploding option element and rearranging\n     options accordingly.  */\n\n  if (argc > 1 && argv[1][0] != '-')\n    {\n      int new_argc;\t\t/* argc value for rearranged arguments */\n      char **new_argv;\t\t/* argv value for rearranged arguments */\n      char *const *in;\t\t/* cursor into original argv */\n      char **out;\t\t/* cursor into rearranged argv */\n      const char *letter;\t/* cursor into old option letters */\n      char buffer[3];\t\t/* constructed option buffer */\n\n      /* Initialize a constructed option.  */\n\n      buffer[0] = '-';\n      buffer[2] = '\\0';\n\n      /* Allocate a new argument array, and copy program name in it.  */\n\n      new_argc = argc - 1 + strlen (argv[1]);\n      new_argv = xmalloc ((new_argc + 1) * sizeof (char *));\n      in = argv;\n      out = new_argv;\n      *out++ = *in++;\n\n      /* Copy each old letter option as a separate option, and have the\n\t corresponding argument moved next to it.  */\n\n      for (letter = *in++; *letter; letter++)\n\t{\n\t  struct argp_option const *opt;\n\n\t  buffer[1] = *letter;\n\t  *out++ = xstrdup (buffer);\n\t  opt = find_argp_option (&argp, *letter);\n\t  if (opt && opt->arg)\n\t    {\n\t      if (in < argv + argc)\n\t\t*out++ = *in++;\n\t      else\n\t\tUSAGE_ERROR ((0, 0, _(\"Old option '%c' requires an argument.\"),\n\t\t\t      *letter));\n\t    }\n\t}\n\n      /* Copy all remaining options.  */\n\n      while (in < argv + argc)\n\t*out++ = *in++;\n      *out = 0;\n\n      /* Replace the old option list by the new one.  */\n\n      argc = new_argc;\n      argv = new_argv;\n    }\n\n  /* Parse all options and non-options as they appear.  */\n  parse_default_options ();\n\n  args.loc = &loc;\n  if (argp_parse (&argp, argc, argv, ARGP_IN_ORDER, &idx, &args))\n    exit (TAREXIT_FAILURE);\n\n  /* Special handling for 'o' option:\n\n     GNU tar used to say \"output old format\".\n     UNIX98 tar says don't chown files after extracting (we use\n     \"--no-same-owner\" for this).\n\n     The old GNU tar semantics is retained when used with --create\n     option, otherwise UNIX98 semantics is assumed */\n\n  if (args.o_option)\n    {\n      if (subcommand_option == CREATE_SUBCOMMAND)\n\t{\n\t  /* GNU Tar <= 1.13 compatibility */\n\t  set_archive_format (\"v7\");\n\t}\n      else\n\t{\n\t  /* UNIX98 compatibility */\n\t  same_owner_option = -1;\n\t}\n    }\n\n  /* Handle operands after any \"--\" argument.  */\n  for (; idx < argc; idx++)\n    name_add_name (argv[idx]);\n\n  /* Derive option values and check option consistency.  */\n\n  if (archive_format == DEFAULT_FORMAT)\n    {\n      if (args.pax_option)\n\tarchive_format = POSIX_FORMAT;\n      else\n\tarchive_format = DEFAULT_ARCHIVE_FORMAT;\n    }\n\n  if ((volume_label_option && subcommand_option == CREATE_SUBCOMMAND)\n      || incremental_option\n      || multi_volume_option\n      || sparse_option)\n    assert_format (FORMAT_MASK (OLDGNU_FORMAT)\n\t\t   | FORMAT_MASK (GNU_FORMAT)\n\t\t   | FORMAT_MASK (POSIX_FORMAT));\n\n  if (occurrence_option)\n    {\n      if (!name_more_files ())\n\tUSAGE_ERROR ((0, 0,\n\t\t      _(\"--occurrence is meaningless without a file list\")));\n      if (!IS_SUBCOMMAND_CLASS (SUBCL_OCCUR))\n\t{\n\t  if (option_set_in_cl (OC_OCCURRENCE))\n\t    option_conflict_error (\"--occurrence\",\n\t\t\t\t   subcommand_string (subcommand_option));\n\t  else\n\t    occurrence_option = 0;\n\t}\n    }\n\n  if (archive_names == 0)\n    {\n      /* If no archive file name given, try TAPE from the environment, or\n\t else, DEFAULT_ARCHIVE from the configuration process.  */\n\n      archive_names = 1;\n      archive_name_array[0] = getenv (\"TAPE\");\n      if (! archive_name_array[0])\n\tarchive_name_array[0] = DEFAULT_ARCHIVE;\n    }\n\n  /* Allow multiple archives only with '-M'.  */\n\n  if (archive_names > 1 && !multi_volume_option)\n    USAGE_ERROR ((0, 0,\n\t\t  _(\"Multiple archive files require '-M' option\")));\n\n  if (listed_incremental_option\n      && TIME_OPTION_INITIALIZED (newer_mtime_option))\n    {\n      struct option_locus *listed_loc = optloc_lookup (OC_LISTED_INCREMENTAL);\n      struct option_locus *newer_loc = optloc_lookup (OC_NEWER);\n      if (optloc_eq (listed_loc, newer_loc))\n\toption_conflict_error (\"--listed-incremental\", \"--newer\");\n      else if (listed_loc->source == OPTS_COMMAND_LINE)\n\tlisted_incremental_option = NULL;\n      else\n\tmemset (&newer_mtime_option, 0, sizeof (newer_mtime_option));\n    }\n\n  if (incremental_level != -1 && !listed_incremental_option)\n    WARN ((0, 0,\n\t   _(\"--level is meaningless without --listed-incremental\")));\n\n  if (volume_label_option)\n    {\n      if (archive_format == GNU_FORMAT || archive_format == OLDGNU_FORMAT)\n\t{\n\t  size_t volume_label_max_len =\n\t    (sizeof current_header->header.name\n\t     - 1 /* for trailing '\\0' */\n\t     - (multi_volume_option\n\t\t? (sizeof \" Volume \"\n\t\t   - 1 /* for null at end of \" Volume \" */\n\t\t   + INT_STRLEN_BOUND (int) /* for volume number */\n\t\t   - 1 /* for sign, as 0 <= volno */)\n\t\t: 0));\n\t  if (volume_label_max_len < strlen (volume_label_option))\n\t    USAGE_ERROR ((0, 0,\n\t\t\t  ngettext (\"%s: Volume label is too long (limit is %lu byte)\",\n\t\t\t\t    \"%s: Volume label is too long (limit is %lu bytes)\",\n\t\t\t\t    volume_label_max_len),\n\t\t\t  quotearg_colon (volume_label_option),\n\t\t\t  (unsigned long) volume_label_max_len));\n\t}\n      /* else FIXME\n\t Label length in PAX format is limited by the volume size. */\n    }\n\n  if (verify_option)\n    {\n      if (multi_volume_option)\n\tUSAGE_ERROR ((0, 0, _(\"Cannot verify multi-volume archives\")));\n      if (use_compress_program_option)\n\tUSAGE_ERROR ((0, 0, _(\"Cannot verify compressed archives\")));\n      if (!IS_SUBCOMMAND_CLASS (SUBCL_WRITE))\n\t{\n\t  if (option_set_in_cl (OC_VERIFY))\n\t    option_conflict_error (\"--verify\",\n\t\t\t\t   subcommand_string (subcommand_option));\n\t  else\n\t    verify_option = false;\n\t}\n    }\n\n  if (use_compress_program_option)\n    {\n      if (multi_volume_option)\n\tUSAGE_ERROR ((0, 0, _(\"Cannot use multi-volume compressed archives\")));\n      if (IS_SUBCOMMAND_CLASS (SUBCL_UPDATE))\n\tUSAGE_ERROR ((0, 0, _(\"Cannot update compressed archives\")));\n      if (subcommand_option == CAT_SUBCOMMAND)\n\tUSAGE_ERROR ((0, 0, _(\"Cannot concatenate compressed archives\")));\n    }\n\n  if (set_mtime_option == CLAMP_MTIME)\n    {\n      if (!TIME_OPTION_INITIALIZED (mtime_option))\n\tUSAGE_ERROR ((0, 0,\n\t\t      _(\"--clamp-mtime needs a date specified using --mtime\")));\n    }\n\n  /* It is no harm to use --pax-option on non-pax archives in archive\n     reading mode. It may even be useful, since it allows to override\n     file attributes from tar headers. Therefore I allow such usage.\n     --gray */\n  if (args.pax_option\n      && archive_format != POSIX_FORMAT\n      && !IS_SUBCOMMAND_CLASS (SUBCL_READ))\n    USAGE_ERROR ((0, 0, _(\"--pax-option can be used only on POSIX archives\")));\n\n  /* star creates non-POSIX typed archives with xattr support, so allow the\n     extra headers when reading */\n  if ((acls_option > 0)\n      && archive_format != POSIX_FORMAT\n      && !IS_SUBCOMMAND_CLASS (SUBCL_READ))\n    USAGE_ERROR ((0, 0, _(\"--acls can be used only on POSIX archives\")));\n\n  if ((selinux_context_option > 0)\n      && archive_format != POSIX_FORMAT\n      && !IS_SUBCOMMAND_CLASS (SUBCL_READ))\n    USAGE_ERROR ((0, 0, _(\"--selinux can be used only on POSIX archives\")));\n\n  if ((xattrs_option > 0)\n      && archive_format != POSIX_FORMAT\n      && !IS_SUBCOMMAND_CLASS (SUBCL_READ))\n    USAGE_ERROR ((0, 0, _(\"--xattrs can be used only on POSIX archives\")));\n\n  if (starting_file_option && !IS_SUBCOMMAND_CLASS (SUBCL_READ))\n    {\n      if (option_set_in_cl (OC_STARTING_FILE))\n\toption_conflict_error (\"--starting-file\",\n\t\t\t       subcommand_string (subcommand_option));\n      else\n\tstarting_file_option = false;\n    }\n\n  if (same_order_option && !IS_SUBCOMMAND_CLASS (SUBCL_READ))\n    {\n      if (option_set_in_cl (OC_SAME_ORDER))\n\toption_conflict_error (\"--same-order\",\n\t\t\t       subcommand_string (subcommand_option));\n      else\n\tsame_order_option = false;\n    }\n\n  if (one_top_level_option)\n    {\n      char *base;\n\n      if (absolute_names_option)\n\t{\n\t  struct option_locus *one_top_level_loc =\n\t    optloc_lookup (OC_ONE_TOP_LEVEL);\n\t  struct option_locus *absolute_names_loc =\n\t    optloc_lookup (OC_ABSOLUTE_NAMES);\n\n\t  if (optloc_eq (one_top_level_loc, absolute_names_loc))\n\t    option_conflict_error (\"--one-top-level\", \"--absolute-names\");\n\t  else if (one_top_level_loc->source == OPTS_COMMAND_LINE)\n\t    absolute_names_option = false;\n\t  else\n\t    one_top_level_option = false;\n\t}\n\n      if (one_top_level_option && !one_top_level_dir)\n\t{\n\t  /* If the user wants to guarantee that everything is under one\n\t     directory, determine its name now and let it be created later.  */\n\t  base = base_name (archive_name_array[0]);\n\t  one_top_level_dir = strip_compression_suffix (base);\n\t  free (base);\n\n\t  if (!one_top_level_dir)\n\t    USAGE_ERROR ((0, 0,\n\t\t\t  _(\"Cannot deduce top-level directory name; \"\n\t\t\t    \"please set it explicitly with --one-top-level=DIR\")));\n\t}\n    }\n\n  /* If ready to unlink hierarchies, so we are for simpler files.  */\n  if (recursive_unlink_option)\n    old_files_option = UNLINK_FIRST_OLD_FILES;\n\n  /* Flags for accessing files to be read from or copied into.  POSIX says\n     O_NONBLOCK has unspecified effect on most types of files, but in\n     practice it never harms and sometimes helps.  */\n  {\n    int base_open_flags =\n      (O_BINARY | O_CLOEXEC | O_NOCTTY | O_NONBLOCK\n       | (dereference_option ? 0 : O_NOFOLLOW)\n       | (atime_preserve_option == system_atime_preserve ? O_NOATIME : 0));\n    open_read_flags = O_RDONLY | base_open_flags;\n    open_searchdir_flags = O_SEARCH | O_DIRECTORY | base_open_flags;\n  }\n  fstatat_flags = dereference_option ? 0 : AT_SYMLINK_NOFOLLOW;\n\n  if (subcommand_option == TEST_LABEL_SUBCOMMAND)\n    {\n      /* --test-label is silent if the user has specified the label name to\n\t compare against. */\n      if (!name_more_files ())\n\tverbose_option++;\n    }\n  else if (utc_option)\n    verbose_option = 2;\n\n  if (tape_length_option && tape_length_option < record_size)\n    USAGE_ERROR ((0, 0, _(\"Volume length cannot be less than record size\")));\n\n  if (same_order_option && listed_incremental_option)\n    {\n      struct option_locus *preserve_order_loc = optloc_lookup (OC_SAME_ORDER);\n      struct option_locus *listed_incremental_loc =\n\toptloc_lookup (OC_LISTED_INCREMENTAL);\n\n      if (optloc_eq (preserve_order_loc, listed_incremental_loc))\n\toption_conflict_error (\"--preserve-order\", \"--listed-incremental\");\n      else if (preserve_order_loc->source == OPTS_COMMAND_LINE)\n\tlisted_incremental_option = false;\n      else\n\tsame_order_option = false;\n    }\n\n  /* Forbid using -c with no input files whatsoever.  Check that '-f -',\n     explicit or implied, is used correctly.  */\n\n  switch (subcommand_option)\n    {\n    case CREATE_SUBCOMMAND:\n      if (!name_more_files ())\n\tUSAGE_ERROR ((0, 0,\n\t\t      _(\"Cowardly refusing to create an empty archive\")));\n      if (args.compress_autodetect && archive_names\n\t  && strcmp (archive_name_array[0], \"-\"))\n\tset_compression_program_by_suffix (archive_name_array[0],\n\t\t\t\t\t   use_compress_program_option);\n      break;\n\n    case EXTRACT_SUBCOMMAND:\n    case LIST_SUBCOMMAND:\n    case DIFF_SUBCOMMAND:\n    case TEST_LABEL_SUBCOMMAND:\n      for (archive_name_cursor = archive_name_array;\n\t   archive_name_cursor < archive_name_array + archive_names;\n\t   archive_name_cursor++)\n\tif (!strcmp (*archive_name_cursor, \"-\"))\n\t  request_stdin (\"-f\");\n      break;\n\n    case CAT_SUBCOMMAND:\n    case UPDATE_SUBCOMMAND:\n    case APPEND_SUBCOMMAND:\n      for (archive_name_cursor = archive_name_array;\n\t   archive_name_cursor < archive_name_array + archive_names;\n\t   archive_name_cursor++)\n\tif (!strcmp (*archive_name_cursor, \"-\"))\n\t  USAGE_ERROR ((0, 0,\n\t\t\t_(\"Options '-Aru' are incompatible with '-f -'\")));\n\n    default:\n      break;\n    }\n\n  /* Initialize stdlis */\n  if (index_file_name)\n    {\n      stdlis = fopen (index_file_name, \"w\");\n      if (! stdlis)\n\topen_fatal (index_file_name);\n    }\n  else\n    stdlis = to_stdout_option ? stderr : stdout;\n\n  archive_name_cursor = archive_name_array;\n\n  /* Prepare for generating backup names.  */\n\n  if (args.backup_suffix_string)\n    simple_backup_suffix = xstrdup (args.backup_suffix_string);\n\n  if (backup_option)\n    {\n      backup_type = xget_version (\"--backup\", args.version_control_string);\n      /* No backup is needed either if explicitely disabled or if\n\t the extracted files are not being written to disk. */\n      if (backup_type == no_backups || EXTRACT_OVER_PIPE)\n\tbackup_option = false;\n    }\n\n  checkpoint_finish_compile ();\n\n  report_textual_dates (&args);\n}",
      "lines": 451,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        2663,
        0
      ],
      "end_point": [
        2775,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  set_start_time ();\n  set_program_name (argv[0]);\n\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  exit_failure = TAREXIT_FAILURE;\n  exit_status = TAREXIT_SUCCESS;\n  error_hook = checkpoint_flush_actions;\n\n  set_quoting_style (0, DEFAULT_QUOTING_STYLE);\n\n  /* Make sure we have first three descriptors available */\n  stdopen ();\n\n  /* Pre-allocate a few structures.  */\n\n  allocated_archive_names = 10;\n  archive_name_array =\n    xmalloc (sizeof (const char *) * allocated_archive_names);\n  archive_names = 0;\n\n  /* System V fork+wait does not work if SIGCHLD is ignored.  */\n  signal (SIGCHLD, SIG_DFL);\n\n  /* Try to disable the ability to unlink a directory.  */\n  priv_set_remove_linkdir ();\n\n  /* Decode options.  */\n\n  decode_options (argc, argv);\n\n  name_init ();\n\n  /* Main command execution.  */\n\n  if (volno_file_option)\n    init_volume_number ();\n\n  switch (subcommand_option)\n    {\n    case UNKNOWN_SUBCOMMAND:\n      USAGE_ERROR ((0, 0,\n\t\t    _(\"You must specify one of the '-Acdtrux', '--delete' or '--test-label' options\")));\n\n    case CAT_SUBCOMMAND:\n    case UPDATE_SUBCOMMAND:\n    case APPEND_SUBCOMMAND:\n      update_archive ();\n      break;\n\n    case DELETE_SUBCOMMAND:\n      delete_archive_members ();\n      break;\n\n    case CREATE_SUBCOMMAND:\n      create_archive ();\n      break;\n\n    case EXTRACT_SUBCOMMAND:\n      extr_init ();\n      read_and (extract_archive);\n\n      /* FIXME: should extract_finish () even if an ordinary signal is\n\t received.  */\n      extract_finish ();\n\n      break;\n\n    case LIST_SUBCOMMAND:\n      read_and (list_archive);\n      break;\n\n    case DIFF_SUBCOMMAND:\n      diff_init ();\n      read_and (diff_archive);\n      break;\n\n    case TEST_LABEL_SUBCOMMAND:\n      test_archive_label ();\n    }\n\n  checkpoint_finish ();\n\n  if (totals_option)\n    print_total_stats ();\n\n  if (check_links_option)\n    check_links ();\n\n  if (volno_file_option)\n    closeout_volume_number ();\n\n  /* Dispose of allocated memory, and return.  */\n\n  free (archive_name_array);\n  xattrs_clear_setup ();\n  name_term ();\n\n  if (exit_status == TAREXIT_FAILURE)\n    error (0, 0, _(\"Exiting with failure status due to previous errors\"));\n\n  if (stdlis == stdout)\n    close_stdout ();\n  else if (ferror (stderr) || fclose (stderr) != 0)\n    set_exit_status (TAREXIT_FAILURE);\n\n  return exit_status;\n}",
      "lines": 113,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "tar_stat_init": {
      "start_point": [
        2777,
        0
      ],
      "end_point": [
        2781,
        1
      ],
      "content": "void\ntar_stat_init (struct tar_stat_info *st)\n{\n  memset (st, 0, sizeof (*st));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "tar_stat_close": {
      "start_point": [
        2786,
        0
      ],
      "end_point": [
        2802,
        1
      ],
      "content": "bool\ntar_stat_close (struct tar_stat_info *st)\n{\n  int status = (st->dirstream ? closedir (st->dirstream)\n\t\t: 0 < st->fd ? close (st->fd)\n\t\t: 0);\n  st->dirstream = 0;\n  st->fd = 0;\n\n  if (status == 0)\n    return true;\n  else\n    {\n      close_diag (st->orig_file_name);\n      return false;\n    }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "tar_stat_destroy": {
      "start_point": [
        2804,
        0
      ],
      "end_point": [
        2822,
        1
      ],
      "content": "void\ntar_stat_destroy (struct tar_stat_info *st)\n{\n  tar_stat_close (st);\n  xheader_xattr_free (st->xattr_map, st->xattr_map_size);\n  free (st->orig_file_name);\n  free (st->file_name);\n  free (st->link_name);\n  free (st->uname);\n  free (st->gname);\n  free (st->cntx_name);\n  free (st->acls_a_ptr);\n  free (st->acls_d_ptr);\n  free (st->sparse_map);\n  free (st->dumpdir);\n  xheader_destroy (&st->xhdr);\n  info_free_exclist (st);\n  memset (st, 0, sizeof (*st));\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "tar_timespec_cmp": {
      "start_point": [
        2830,
        0
      ],
      "end_point": [
        2836,
        1
      ],
      "content": "int\ntar_timespec_cmp (struct timespec a, struct timespec b)\n{\n  if (!(FORMAT_MASK (current_format) & NS_PRECISION_FORMAT_MASK))\n    a.tv_nsec = b.tv_nsec = 0;\n  return timespec_cmp (a, b);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_exit_status": {
      "start_point": [
        2841,
        0
      ],
      "end_point": [
        2846,
        1
      ],
      "content": "void\nset_exit_status (int val)\n{\n  if (val > exit_status)\n    exit_status = val;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/tar.h": {},
  "tar/tar-1.30/src/transform.c": {
    "new_transform": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static struct transform *\nnew_transform (void)\n{\n  struct transform *p = xzalloc (sizeof *p);\n  if (transform_tail)\n    transform_tail->next = p;\n  else\n    transform_head = p;\n  transform_tail = p;\n  return p;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct transform",
        "struct",
        "transform",
        "*\nnew_transform (void)",
        "*"
      ]
    },
    "add_segment": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static struct replace_segm *\nadd_segment (struct transform *tf)\n{\n  struct replace_segm *segm = xmalloc (sizeof *segm);\n  segm->next = NULL;\n  if (tf->repl_tail)\n    tf->repl_tail->next = segm;\n  else\n    tf->repl_head = segm;\n  tf->repl_tail = segm;\n  tf->segm_count++;\n  return segm;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct replace_segm",
        "struct",
        "replace_segm",
        "*\nadd_segment (struct transform *tf)",
        "*"
      ]
    },
    "add_literal_segment": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static void\nadd_literal_segment (struct transform *tf, char *str, char *end)\n{\n  size_t len = end - str;\n  if (len)\n    {\n      struct replace_segm *segm = add_segment (tf);\n      segm->type = segm_literal;\n      segm->v.literal.ptr = xmalloc (len + 1);\n      memcpy (segm->v.literal.ptr, str, len);\n      segm->v.literal.ptr[len] = 0;\n      segm->v.literal.size = len;\n    }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_char_segment": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static void\nadd_char_segment (struct transform *tf, int chr)\n{\n  struct replace_segm *segm = add_segment (tf);\n  segm->type = segm_literal;\n  segm->v.literal.ptr = xmalloc (2);\n  segm->v.literal.ptr[0] = chr;\n  segm->v.literal.ptr[1] = 0;\n  segm->v.literal.size = 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_backref_segment": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static void\nadd_backref_segment (struct transform *tf, size_t ref)\n{\n  struct replace_segm *segm = add_segment (tf);\n  segm->type = segm_backref;\n  segm->v.ref = ref;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_xform_flags": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static int\nparse_xform_flags (int *pflags, int c)\n{\n  switch (c)\n    {\n    case 'r':\n      *pflags |= XFORM_REGFILE;\n      break;\n\n    case 'R':\n      *pflags &= ~XFORM_REGFILE;\n      break;\n\n    case 'h':\n      *pflags |= XFORM_LINK;\n      break;\n\n    case 'H':\n      *pflags &= ~XFORM_LINK;\n      break;\n\n    case 's':\n      *pflags |= XFORM_SYMLINK;\n      break;\n\n    case 'S':\n      *pflags &= ~XFORM_SYMLINK;\n      break;\n\n    default:\n      return 1;\n    }\n  return 0;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "add_case_ctl_segment": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static void\nadd_case_ctl_segment (struct transform *tf, enum case_ctl_type ctl)\n{\n  struct replace_segm *segm = add_segment (tf);\n  segm->type = segm_case_ctl;\n  segm->v.ctl = ctl;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_transform_expr": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        407,
        1
      ],
      "content": "static const char *\nparse_transform_expr (const char *expr)\n{\n  int delim;\n  int i, j, rc;\n  char *str, *beg, *cur;\n  const char *p;\n  int cflags = 0;\n  struct transform *tf = new_transform ();\n\n  if (expr[0] != 's')\n    {\n      if (strncmp (expr, \"flags=\", 6) == 0)\n\t{\n\t  transform_flags = 0;\n\t  for (expr += 6; *expr; expr++)\n\t    {\n\t      if (*expr == ';')\n\t\t{\n\t\t  expr++;\n\t\t  break;\n\t\t}\n\t      if (parse_xform_flags (&transform_flags, *expr))\n\t\tUSAGE_ERROR ((0, 0, _(\"Unknown transform flag: %c\"),\n\t\t\t      *expr));\n\t    }\n\t  return expr;\n\t}\n      USAGE_ERROR ((0, 0, _(\"Invalid transform expression\")));\n    }\n\n  delim = expr[1];\n\n  /* Scan regular expression */\n  for (i = 2; expr[i] && expr[i] != delim; i++)\n    if (expr[i] == '\\\\' && expr[i+1])\n      i++;\n\n  if (expr[i] != delim)\n    USAGE_ERROR ((0, 0, _(\"Invalid transform expression\")));\n\n  /* Scan replacement expression */\n  for (j = i + 1; expr[j] && expr[j] != delim; j++)\n    if (expr[j] == '\\\\' && expr[j+1])\n      j++;\n\n  if (expr[j] != delim)\n    USAGE_ERROR ((0, 0, _(\"Invalid transform expression\")));\n\n  /* Check flags */\n  tf->transform_type = transform_first;\n  tf->flags = transform_flags;\n  for (p = expr + j + 1; *p && *p != ';'; p++)\n    switch (*p)\n      {\n      case 'g':\n\ttf->transform_type = transform_global;\n\tbreak;\n\n      case 'i':\n\tcflags |= REG_ICASE;\n\tbreak;\n\n      case 'x':\n\tcflags |= REG_EXTENDED;\n\tbreak;\n\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n\ttf->match_number = strtoul (p, (char**) &p, 0);\n\tp--;\n\tbreak;\n\n      default:\n\tif (parse_xform_flags (&tf->flags, *p))\n\t  USAGE_ERROR ((0, 0, _(\"Unknown flag in transform expression: %c\"),\n\t\t\t*p));\n      }\n\n  if (*p == ';')\n    p++;\n\n  /* Extract and compile regex */\n  str = xmalloc (i - 1);\n  memcpy (str, expr + 2, i - 2);\n  str[i - 2] = 0;\n\n  rc = regcomp (&tf->regex, str, cflags);\n\n  if (rc)\n    {\n      char errbuf[512];\n      regerror (rc, &tf->regex, errbuf, sizeof (errbuf));\n      USAGE_ERROR ((0, 0, _(\"Invalid transform expression: %s\"), errbuf));\n    }\n\n  if (str[0] == '^' || str[strlen (str) - 1] == '$')\n    tf->transform_type = transform_first;\n\n  free (str);\n\n  /* Extract and compile replacement expr */\n  i++;\n  str = xmalloc (j - i + 1);\n  memcpy (str, expr + i, j - i);\n  str[j - i] = 0;\n\n  for (cur = beg = str; *cur;)\n    {\n      if (*cur == '\\\\')\n\t{\n\t  size_t n;\n\n\t  add_literal_segment (tf, beg, cur);\n\t  switch (*++cur)\n\t    {\n\t    case '0': case '1': case '2': case '3': case '4':\n\t    case '5': case '6': case '7': case '8': case '9':\n\t      n = strtoul (cur, &cur, 10);\n\t      if (n > tf->regex.re_nsub)\n\t\tUSAGE_ERROR ((0, 0, _(\"Invalid transform replacement: back reference out of range\")));\n\t      add_backref_segment (tf, n);\n\t      break;\n\n\t    case '\\\\':\n\t      add_char_segment (tf, '\\\\');\n\t      cur++;\n\t      break;\n\n\t    case 'a':\n\t      add_char_segment (tf, '\\a');\n\t      cur++;\n\t      break;\n\n\t    case 'b':\n\t      add_char_segment (tf, '\\b');\n\t      cur++;\n\t      break;\n\n\t    case 'f':\n\t      add_char_segment (tf, '\\f');\n\t      cur++;\n\t      break;\n\n\t    case 'n':\n\t      add_char_segment (tf, '\\n');\n\t      cur++;\n\t      break;\n\n\t    case 'r':\n\t      add_char_segment (tf, '\\r');\n\t      cur++;\n\t      break;\n\n\t    case 't':\n\t      add_char_segment (tf, '\\t');\n\t      cur++;\n\t      break;\n\n\t    case 'v':\n\t      add_char_segment (tf, '\\v');\n\t      cur++;\n\t      break;\n\n\t    case '&':\n\t      add_char_segment (tf, '&');\n\t      cur++;\n\t      break;\n\n\t    case 'L':\n\t      /* Turn the replacement to lowercase until a '\\U' or '\\E'\n\t\t is found, */\n\t      add_case_ctl_segment (tf, ctl_locase);\n\t      cur++;\n\t      break;\n\n\t    case 'l':\n\t      /* Turn the next character to lowercase, */\n\t      add_case_ctl_segment (tf, ctl_locase_next);\n\t      cur++;\n\t      break;\n\n\t    case 'U':\n\t      /* Turn the replacement to uppercase until a '\\L' or '\\E'\n\t\t is found, */\n\t      add_case_ctl_segment (tf, ctl_upcase);\n\t      cur++;\n\t      break;\n\n\t    case 'u':\n\t      /* Turn the next character to uppercase, */\n\t      add_case_ctl_segment (tf, ctl_upcase_next);\n\t      cur++;\n\t      break;\n\n\t    case 'E':\n\t      /* Stop case conversion started by '\\L' or '\\U'. */\n\t      add_case_ctl_segment (tf, ctl_stop);\n\t      cur++;\n\t      break;\n\n\t    default:\n\t      if (*cur == delim)\n\t\tadd_char_segment (tf, delim);\n\t      else\n\t\t{\n\t\t  char buf[2];\n\t\t  buf[0] = '\\\\';\n\t\t  buf[1] = *cur;\n\t\t  add_literal_segment (tf, buf, buf + 2);\n\t\t}\n\t      cur++;\n\t      break;\n\t    }\n\t  beg = cur;\n\t}\n      else if (*cur == '&')\n\t{\n\t  add_literal_segment (tf, beg, cur);\n\t  add_backref_segment (tf, 0);\n\t  beg = ++cur;\n\t}\n      else\n\tcur++;\n    }\n  add_literal_segment (tf, beg, cur);\n\n  return p;\n}",
      "lines": 229,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nparse_transform_expr (const char *expr)",
        "*"
      ]
    },
    "set_transform_expr": {
      "start_point": [
        409,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "void\nset_transform_expr (const char *expr)\n{\n  while (*expr)\n    expr = parse_transform_expr (expr);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "run_case_conv": {
      "start_point": [
        418,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "static char *\nrun_case_conv (enum case_ctl_type case_ctl, char *ptr, size_t size)\n{\n  static char *case_ctl_buffer;\n  static size_t case_ctl_bufsize;\n  char *p;\n\n  if (case_ctl_bufsize < size)\n    {\n      case_ctl_bufsize = size;\n      case_ctl_buffer = xrealloc (case_ctl_buffer, case_ctl_bufsize);\n    }\n  memcpy (case_ctl_buffer, ptr, size);\n  switch (case_ctl)\n    {\n    case ctl_upcase_next:\n      case_ctl_buffer[0] = toupper ((unsigned char) case_ctl_buffer[0]);\n      break;\n\n    case ctl_locase_next:\n      case_ctl_buffer[0] = tolower ((unsigned char) case_ctl_buffer[0]);\n      break;\n\n    case ctl_upcase:\n      for (p = case_ctl_buffer; p < case_ctl_buffer + size; p++)\n\t*p = toupper ((unsigned char) *p);\n      break;\n\n    case ctl_locase:\n      for (p = case_ctl_buffer; p < case_ctl_buffer + size; p++)\n\t*p = tolower ((unsigned char) *p);\n      break;\n\n    case ctl_stop:\n      break;\n    }\n  return case_ctl_buffer;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nrun_case_conv (enum case_ctl_type case_ctl, char *ptr, size_t size)",
        "*"
      ]
    },
    "_single_transform_name_to_obstack": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        579,
        1
      ],
      "content": "static void\n_single_transform_name_to_obstack (struct transform *tf, char *input)\n{\n  regmatch_t *rmp;\n  int rc;\n  size_t nmatches = 0;\n  enum case_ctl_type case_ctl = ctl_stop,  /* Current case conversion op */\n                     save_ctl = ctl_stop;  /* Saved case_ctl for \\u and \\l */\n\n  /* Reset case conversion after a single-char operation */\n#define CASE_CTL_RESET()  if (case_ctl == ctl_upcase_next     \\\n\t\t\t      || case_ctl == ctl_locase_next) \\\n                            {                                 \\\n                              case_ctl = save_ctl;            \\\n                              save_ctl = ctl_stop;            \\\n\t\t\t    }\n\n  rmp = xmalloc ((tf->regex.re_nsub + 1) * sizeof (*rmp));\n\n  while (*input)\n    {\n      size_t disp;\n      char *ptr;\n\n      rc = regexec (&tf->regex, input, tf->regex.re_nsub + 1, rmp, 0);\n\n      if (rc == 0)\n\t{\n\t  struct replace_segm *segm;\n\n\t  disp = rmp[0].rm_eo;\n\n\t  if (rmp[0].rm_so)\n\t    obstack_grow (&stk, input, rmp[0].rm_so);\n\n\t  nmatches++;\n\t  if (tf->match_number && nmatches < tf->match_number)\n\t    {\n\t      obstack_grow (&stk, input, disp);\n\t      input += disp;\n\t      continue;\n\t    }\n\n\t  for (segm = tf->repl_head; segm; segm = segm->next)\n\t    {\n\t      switch (segm->type)\n\t\t{\n\t\tcase segm_literal:    /* Literal segment */\n\t\t  if (case_ctl == ctl_stop)\n\t\t    ptr = segm->v.literal.ptr;\n\t\t  else\n\t\t    {\n\t\t      ptr = run_case_conv (case_ctl,\n\t\t\t\t\t   segm->v.literal.ptr,\n\t\t\t\t\t   segm->v.literal.size);\n\t\t      CASE_CTL_RESET();\n\t\t    }\n\t\t  obstack_grow (&stk, ptr, segm->v.literal.size);\n\t\t  break;\n\n\t\tcase segm_backref:    /* Back-reference segment */\n\t\t  if (rmp[segm->v.ref].rm_so != -1\n\t\t      && rmp[segm->v.ref].rm_eo != -1)\n\t\t    {\n\t\t      size_t size = rmp[segm->v.ref].rm_eo\n\t\t\t              - rmp[segm->v.ref].rm_so;\n\t\t      ptr = input + rmp[segm->v.ref].rm_so;\n\t\t      if (case_ctl != ctl_stop)\n\t\t\t{\n\t\t\t  ptr = run_case_conv (case_ctl, ptr, size);\n\t\t\t  CASE_CTL_RESET();\n\t\t\t}\n\n\t\t      obstack_grow (&stk, ptr, size);\n\t\t    }\n\t\t  break;\n\n\t\tcase segm_case_ctl:\n\t\t  switch (segm->v.ctl)\n\t\t    {\n\t\t    case ctl_upcase_next:\n\t\t    case ctl_locase_next:\n\t\t      switch (save_ctl)\n\t\t\t{\n\t\t\tcase ctl_stop:\n\t\t\tcase ctl_upcase:\n\t\t\tcase ctl_locase:\n\t\t\t  save_ctl = case_ctl;\n\t\t\tdefault:\n\t\t\t  break;\n\t\t\t}\n\t\t      /*FALL THROUGH*/\n\n\t\t    case ctl_upcase:\n\t\t    case ctl_locase:\n\t\t    case ctl_stop:\n\t\t      case_ctl = segm->v.ctl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  disp = strlen (input);\n\t  obstack_grow (&stk, input, disp);\n\t}\n\n      input += disp;\n\n      if (tf->transform_type == transform_first)\n\t{\n\t  obstack_grow (&stk, input, strlen (input));\n\t  break;\n\t}\n    }\n\n  obstack_1grow (&stk, 0);\n  free (rmp);\n}",
      "lines": 119,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_transform_name_to_obstack": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "static bool\n_transform_name_to_obstack (int flags, char *input, char **output)\n{\n  struct transform *tf;\n  bool alloced = false;\n\n  if (!stk_init)\n    {\n      obstack_init (&stk);\n      stk_init = true;\n    }\n\n  for (tf = transform_head; tf; tf = tf->next)\n    {\n      if (tf->flags & flags)\n\t{\n\t  _single_transform_name_to_obstack (tf, input);\n\t  input = obstack_finish (&stk);\n\t  alloced = true;\n\t}\n    }\n  *output = input;\n  return alloced;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "transform_name_fp": {
      "start_point": [
        606,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "bool\ntransform_name_fp (char **pinput, int flags,\n\t\t   char *(*fun)(char *, void *), void *dat)\n{\n    char *str;\n    bool ret = _transform_name_to_obstack (flags, *pinput, &str);\n    if (ret)\n      {\n\tassign_string (pinput, fun ? fun (str, dat) : str);\n\tobstack_free (&stk, str);\n      }\n    else if (fun)\n      {\n\t*pinput = NULL;\n\tassign_string (pinput, fun (str, dat));\n\tfree (str);\n\tret = true;\n      }\n    return ret;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "transform_name": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "bool\ntransform_name (char **pinput, int type)\n{\n  return transform_name_fp (pinput, type, NULL, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "transform_program_p": {
      "start_point": [
        633,
        0
      ],
      "end_point": [
        637,
        1
      ],
      "content": "bool\ntransform_program_p (void)\n{\n  return transform_head != NULL;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "bool"
      ]
    }
  },
  "tar/tar-1.30/src/unlink.c": {
    "dunlink_alloc": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static struct deferred_unlink *\ndunlink_alloc (void)\n{\n  struct deferred_unlink *p;\n  if (dunlink_avail)\n    {\n      p = dunlink_avail;\n      dunlink_avail = p->next;\n      p->next  = NULL;\n    }\n  else\n    p = xmalloc (sizeof (*p));\n  return p;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct deferred_unlink",
        "struct",
        "deferred_unlink",
        "*\ndunlink_alloc (void)",
        "*"
      ]
    },
    "dunlink_insert": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static void\ndunlink_insert (struct deferred_unlink *anchor, struct deferred_unlink *p)\n{\n  if (anchor)\n    {\n      p->next = anchor->next;\n      anchor->next = p;\n    }\n  else \n    {\n      p->next = dunlink_head;\n      dunlink_head = p;\n    }\n  if (!p->next)\n    dunlink_tail = p;\n  dunlink_count++;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dunlink_reclaim": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static void\ndunlink_reclaim (struct deferred_unlink *p)\n{\n  free (p->file_name);\n  p->next = dunlink_avail;\n  dunlink_avail = p;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "flush_deferred_unlinks": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static void\nflush_deferred_unlinks (bool force)\n{\n  struct deferred_unlink *p, *prev = NULL;\n  int saved_chdir = chdir_current;\n  \n  for (p = dunlink_head; p; )\n    {\n      struct deferred_unlink *next = p->next;\n\n      if (force\n\t  || records_written > p->records_written + deferred_unlink_delay)\n\t{\n\t  chdir_do (p->dir_idx);\n\t  if (p->is_dir)\n\t    {\n\t      const char *fname;\n\n\t      if (p->dir_idx && IS_CWD (p))\n\t\t{\n\t\t  prev = p;\n\t\t  p = next;\n\t\t  continue;\n\t\t}\n\t      else\n\t\tfname = p->file_name;\n\n\t      if (unlinkat (chdir_fd, fname, AT_REMOVEDIR) != 0)\n\t\t{\n\t\t  switch (errno)\n\t\t    {\n\t\t    case ENOENT:\n\t\t      /* nothing to worry about */\n\t\t      break;\n\t\t    case EEXIST:\n\t\t      /* OpenSolaris >=10 sets EEXIST instead of ENOTEMPTY\n\t\t\t if trying to remove a non-empty directory */\n\t\t    case ENOTEMPTY:\n\t\t      /* Keep the record in list, in the hope we'll\n\t\t\t be able to remove it later */\n\t\t      prev = p;\n\t\t      p = next;\n\t\t      continue;\n\n\t\t    default:\n\t\t      rmdir_error (fname);\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if (unlinkat (chdir_fd, p->file_name, 0) != 0 && errno != ENOENT)\n\t\tunlink_error (p->file_name);\n\t    }\n\t  dunlink_reclaim (p);\n\t  dunlink_count--;\n\t  p = next;\n\t  if (prev)\n\t    prev->next = p;\n\t  else\n\t    dunlink_head = p;\n\t}\n      else\n\t{\n\t  prev = p;\n\t  p = next;\n\t}\n    }\n  if (!dunlink_head)\n    dunlink_tail = NULL;\n  else if (force)\n    {\n      for (p = dunlink_head; p; )\n\t{\n\t  struct deferred_unlink *next = p->next;\n\t  const char *fname;\n\n\t  chdir_do (p->dir_idx);\n\t  if (p->dir_idx && IS_CWD (p))\n\t    {\n\t      fname = tar_dirname ();\n\t      chdir_do (p->dir_idx - 1);\n\t    }\n\t  else\n\t    fname = p->file_name;\n\n\t  if (unlinkat (chdir_fd, fname, AT_REMOVEDIR) != 0)\n\t    {\n\t      if (errno != ENOENT)\n\t\trmdir_error (fname);\n\t    }\n\t  dunlink_reclaim (p);\n\t  dunlink_count--;\n\t  p = next;\n\t}\n      dunlink_head = dunlink_tail = NULL;\n    }\t  \n\t    \n  chdir_do (saved_chdir);\n}",
      "lines": 100,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "finish_deferred_unlinks": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "void\nfinish_deferred_unlinks (void)\n{\n  flush_deferred_unlinks (true);\n  \n  while (dunlink_avail)\n    {\n      struct deferred_unlink *next = dunlink_avail->next;\n      free (dunlink_avail);\n      dunlink_avail = next;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "queue_deferred_unlink": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "void\nqueue_deferred_unlink (const char *name, bool is_dir)\n{\n  struct deferred_unlink *p;\n\n  if (dunlink_head\n      && records_written > dunlink_head->records_written + deferred_unlink_delay)\n    flush_deferred_unlinks (false);\n\n  p = dunlink_alloc ();\n  p->next = NULL;\n  p->dir_idx = chdir_current;\n  p->file_name = xstrdup (name);\n  normalize_filename_x (p->file_name);\n  p->is_dir = is_dir;\n  p->records_written = records_written;\n\n  if (IS_CWD (p))\n    {\n      struct deferred_unlink *q, *prev;\n      for (q = dunlink_head, prev = NULL; q; prev = q, q = q->next)\n\tif (IS_CWD (q) && q->dir_idx < p->dir_idx)\n\t  break;\n      if (q)\n\tdunlink_insert (prev, p);\n      else\n\tdunlink_insert (dunlink_tail, p);\n    }\n  else\n    dunlink_insert (dunlink_tail, p);\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/update.c": {
    "append_file": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static void\nappend_file (char *file_name)\n{\n  int handle = openat (chdir_fd, file_name, O_RDONLY | O_BINARY);\n  struct stat stat_data;\n\n  if (handle < 0)\n    {\n      open_error (file_name);\n      return;\n    }\n\n  if (fstat (handle, &stat_data) != 0)\n    stat_error (file_name);\n  else\n    {\n      off_t bytes_left = stat_data.st_size;\n\n      while (bytes_left > 0)\n\t{\n\t  union block *start = find_next_block ();\n\t  size_t buffer_size = available_space_after (start);\n\t  size_t status;\n\t  char buf[UINTMAX_STRSIZE_BOUND];\n\n\t  if (bytes_left < buffer_size)\n\t    {\n\t      buffer_size = bytes_left;\n\t      status = buffer_size % BLOCKSIZE;\n\t      if (status)\n\t\tmemset (start->buffer + bytes_left, 0, BLOCKSIZE - status);\n\t    }\n\n\t  status = safe_read (handle, start->buffer, buffer_size);\n\t  if (status == SAFE_READ_ERROR)\n\t    read_fatal_details (file_name, stat_data.st_size - bytes_left,\n\t\t\t\tbuffer_size);\n\t  if (status == 0)\n\t    FATAL_ERROR ((0, 0,\n\t\t\t  ngettext (\"%s: File shrank by %s byte\",\n\t\t\t\t    \"%s: File shrank by %s bytes\",\n\t\t\t\t    bytes_left),\n\t\t\t  quotearg_colon (file_name),\n\t\t\t  STRINGIFY_BIGINT (bytes_left, buf)));\n\n\t  bytes_left -= status;\n\n\t  set_next_block_after (start + (status - 1) / BLOCKSIZE);\n\t}\n    }\n\n  if (close (handle) != 0)\n    close_error (file_name);\n}",
      "lines": 54,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "update_archive": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "void\nupdate_archive (void)\n{\n  enum read_header previous_status = HEADER_STILL_UNREAD;\n  bool found_end = false;\n\n  name_gather ();\n  open_archive (ACCESS_UPDATE);\n  buffer_write_global_xheader ();\n\n  while (!found_end)\n    {\n      enum read_header status = read_header (&current_header,\n                                             &current_stat_info,\n                                             read_header_auto);\n\n      switch (status)\n\t{\n\tcase HEADER_STILL_UNREAD:\n\tcase HEADER_SUCCESS_EXTENDED:\n\t  abort ();\n\n\tcase HEADER_SUCCESS:\n\t  {\n\t    struct name *name;\n\n\t    decode_header (current_header, &current_stat_info,\n\t\t\t   &current_format, 0);\n\t    transform_stat_info (current_header->header.typeflag,\n\t\t\t\t &current_stat_info);\n\t    archive_format = current_format;\n\n\t    if (subcommand_option == UPDATE_SUBCOMMAND\n\t\t&& (name = name_scan (current_stat_info.file_name)) != NULL)\n\t      {\n\t\tstruct stat s;\n\n\t\tchdir_do (name->change_dir);\n\t\tif (deref_stat (current_stat_info.file_name, &s) == 0)\n\t\t  {\n\t\t    if (S_ISDIR (s.st_mode))\n\t\t      {\n\t\t\tchar *p, *dirp = tar_savedir (name->name, 1);\n\t\t\tif (dirp)\n\t\t\t  {\n\t\t\t    namebuf_t nbuf = namebuf_create (name->name);\n\n\t\t\t    for (p = dirp; *p; p += strlen (p) + 1)\n\t\t\t      addname (namebuf_name (nbuf, p),\n\t\t\t\t       name->change_dir, false, NULL);\n\n\t\t\t    namebuf_free (nbuf);\n\t\t\t    free (dirp);\n\n\t\t\t    remname (name);\n\t\t\t  }\n\t\t      }\n\t\t    else if (tar_timespec_cmp (get_stat_mtime (&s),\n\t\t\t\t\t       current_stat_info.mtime)\n\t\t\t     <= 0)\n\t\t      remname (name);\n\t\t  }\n\t      }\n\n\t    skip_member ();\n\t    break;\n\t  }\n\n\tcase HEADER_ZERO_BLOCK:\n\t  current_block = current_header;\n\t  found_end = true;\n\t  break;\n\n\tcase HEADER_END_OF_FILE:\n\t  found_end = true;\n\t  break;\n\n\tcase HEADER_FAILURE:\n\t  set_next_block_after (current_header);\n\t  switch (previous_status)\n\t    {\n\t    case HEADER_STILL_UNREAD:\n\t      WARN ((0, 0, _(\"This does not look like a tar archive\")));\n\t      FALLTHROUGH;\n\t    case HEADER_SUCCESS:\n\t    case HEADER_ZERO_BLOCK:\n\t      ERROR ((0, 0, _(\"Skipping to next header\")));\n\t      FALLTHROUGH;\n\t    case HEADER_FAILURE:\n\t      break;\n\n\t    case HEADER_END_OF_FILE:\n\t    case HEADER_SUCCESS_EXTENDED:\n\t      abort ();\n\t    }\n\t  break;\n\t}\n\n      tar_stat_destroy (&current_stat_info);\n      previous_status = status;\n    }\n\n  reset_eof ();\n  time_to_start_writing = true;\n  output_start = current_block->buffer;\n\n  {\n    struct name const *p;\n    while ((p = name_from_list ()) != NULL)\n      {\n\tchar *file_name = p->name;\n\tif (excluded_name (file_name, NULL))\n\t  continue;\n\tif (interactive_option && !confirm (\"add\", file_name))\n\t  continue;\n\tif (subcommand_option == CAT_SUBCOMMAND)\n\t  append_file (file_name);\n\telse\n\t  dump_file (0, file_name, file_name);\n      }\n  }\n\n  write_eot ();\n  close_archive ();\n  finish_deferred_unlinks ();\n  names_notfound ();\n}",
      "lines": 127,
      "depth": 23,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/utf8.c": {
    "utf8_init": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static iconv_t\nutf8_init (bool to_utf)\n{\n  if (conv_desc[(int) to_utf] == (iconv_t) -1)\n    {\n      if (to_utf)\n\tconv_desc[(int) to_utf] = iconv_open (\"UTF-8\", locale_charset ());\n      else\n\tconv_desc[(int) to_utf] = iconv_open (locale_charset (), \"UTF-8\");\n    }\n  return conv_desc[(int) to_utf];\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "iconv_t"
      ]
    },
    "utf8_convert": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "bool\nutf8_convert (bool to_utf, char const *input, char **output)\n{\n  char ICONV_CONST *ib;\n  char *ob;\n  size_t inlen;\n  size_t outlen;\n  size_t rc;\n  iconv_t cd = utf8_init (to_utf);\n\n  if (cd == 0)\n    {\n      *output = xstrdup (input);\n      return true;\n    }\n  else if (cd == (iconv_t)-1)\n    return false;\n\n  inlen = strlen (input) + 1;\n  outlen = inlen * MB_LEN_MAX + 1;\n  ob = *output = xmalloc (outlen);\n  ib = (char ICONV_CONST *) input;\n  rc = iconv (cd, &ib, &inlen, &ob, &outlen);\n  *ob = 0;\n  return rc != -1;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "string_ascii_p": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "bool\nstring_ascii_p (char const *p)\n{\n  for (; *p; p++)\n    if (*p & ~0x7f)\n      return false;\n  return true;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "tar/tar-1.30/src/warning.c": {
    "set_warning_option": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "void\nset_warning_option (const char *arg)\n{\n  int negate = 0;\n  int option;\n\n  if (strcmp (arg, \"none\") == 0)\n    {\n      warning_option = 0;\n      return;\n    }\n  if (strlen (arg) > 2 && memcmp (arg, \"no-\", 3) == 0)\n    {\n      negate = 1;\n      arg += 3;\n    }\n\n  option = XARGMATCH (\"--warning\", arg,\n\t\t      warning_args, warning_types);\n  if (negate)\n    warning_option &= ~option;\n  else\n    warning_option |= option;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/xattrs.c": {
    "perms2acl": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static acl_t\nperms2acl (int perms)\n{\n  char val[] = \"user::---,group::---,other::---\";\n  /*            0123456789 123456789 123456789 123456789 */\n\n  /* user */\n  if (perms & 0400)\n    val[6] = 'r';\n  if (perms & 0200)\n    val[7] = 'w';\n  if (perms & 0100)\n    val[8] = 'x';\n\n  /* group */\n  if (perms & 0040)\n    val[17] = 'r';\n  if (perms & 0020)\n    val[18] = 'w';\n  if (perms & 0010)\n    val[19] = 'x';\n\n  /* other */\n  if (perms & 0004)\n    val[28] = 'r';\n  if (perms & 0002)\n    val[29] = 'w';\n  if (perms & 0001)\n    val[30] = 'x';\n\n  return acl_from_text (val);\n}",
      "lines": 32,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "acl_t"
      ]
    },
    "skip_to_ext_fields": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static char *\nskip_to_ext_fields (char *ptr)\n{\n  /* skip tag name (user/group/default/mask) */\n  ptr += strcspn (ptr, \":,\\n\");\n\n  if (*ptr != ':')\n    return ptr;\n  ++ptr;\n\n  ptr += strcspn (ptr, \":,\\n\"); /* skip user/group name */\n\n  if (*ptr != ':')\n    return ptr;\n  ++ptr;\n\n  ptr += strcspn (ptr, \":,\\n\"); /* skip perms */\n\n  return ptr;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nskip_to_ext_fields (char *ptr)",
        "*"
      ]
    },
    "fixup_extra_acl_fields": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static char *\nfixup_extra_acl_fields (char *ptr)\n{\n  char *src = ptr;\n  char *dst = ptr;\n\n  while (*src)\n    {\n      const char *old = src;\n      size_t len = 0;\n\n      src = skip_to_ext_fields (src);\n      len = src - old;\n      if (old != dst)\n        memmove (dst, old, len);\n      dst += len;\n\n      if (*src == ':')          /* We have extra fields, skip them all */\n        src += strcspn (src, \"\\n,\");\n\n      if ((*src == '\\n') || (*src == ','))\n        *dst++ = *src++;        /* also done when dst == src, but that's ok */\n    }\n  if (src != dst)\n    *dst = 0;\n\n  return ptr;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nfixup_extra_acl_fields (char *ptr)",
        "*"
      ]
    },
    "xattrs__acls_set": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "static void\nxattrs__acls_set (struct tar_stat_info const *st,\n                  char const *file_name, int type,\n                  char *ptr, size_t len, bool def)\n{\n  acl_t acl;\n\n  if (ptr)\n    {\n      /* assert (strlen (ptr) == len); */\n      ptr = fixup_extra_acl_fields (ptr);\n      acl = acl_from_text (ptr);\n    }\n  else if (def)\n    {\n      /* No \"default\" IEEE 1003.1e ACL set for directory.  At this moment,\n         FILE_NAME may already have inherited default acls from parent\n         directory;  clean them up. */\n      if (acl_delete_def_file_at (chdir_fd, file_name))\n        WARNOPT (WARN_XATTR_WRITE,\n                (0, errno,\n                 _(\"acl_delete_def_file_at: Cannot drop default POSIX ACLs \"\n                   \"for file '%s'\"),\n                 file_name));\n      return;\n    }\n  else\n    acl = perms2acl (st->stat.st_mode);\n\n  if (!acl)\n    {\n      call_arg_warn (\"acl_from_text\", file_name);\n      return;\n    }\n\n  if (acl_set_file_at (chdir_fd, file_name, type, acl) == -1)\n    /* warn even if filesystem does not support acls */\n    WARNOPT (WARN_XATTR_WRITE,\n\t     (0, errno,\n\t      _ (\"acl_set_file_at: Cannot set POSIX ACLs for file '%s'\"),\n\t      file_name));\n\n  acl_free (acl);\n}",
      "lines": 44,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattrs__acls_get_a": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static void\nxattrs__acls_get_a (int parentfd, const char *file_name,\n                    struct tar_stat_info *st,\n                    char **ret_ptr, size_t * ret_len)\n{\n  char *val = NULL;\n  ssize_t len;\n  acl_t acl;\n\n  if (!(acl = acl_get_file_at (parentfd, file_name, ACL_TYPE_ACCESS)))\n    {\n      if (errno != ENOTSUP)\n        call_arg_warn (\"acl_get_file_at\", file_name);\n      return;\n    }\n\n  val = acl_to_text (acl, &len);\n  acl_free (acl);\n\n  if (!val)\n    {\n      call_arg_warn (\"acl_to_text\", file_name);\n      return;\n    }\n\n  *ret_ptr = xstrdup (val);\n  *ret_len = len;\n\n  acl_free (val);\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattrs__acls_get_d": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "static void\nxattrs__acls_get_d (int parentfd, char const *file_name,\n                    struct tar_stat_info *st,\n                    char **ret_ptr, size_t * ret_len)\n{\n  char *val = NULL;\n  ssize_t len;\n  acl_t acl;\n\n  if (!(acl = acl_get_file_at (parentfd, file_name, ACL_TYPE_DEFAULT)))\n    {\n      if (errno != ENOTSUP)\n        call_arg_warn (\"acl_get_file_at\", file_name);\n      return;\n    }\n\n  val = acl_to_text (acl, &len);\n  acl_free (acl);\n\n  if (!val)\n    {\n      call_arg_warn (\"acl_to_text\", file_name);\n      return;\n    }\n\n  *ret_ptr = xstrdup (val);\n  *ret_len = len;\n\n  acl_free (val);\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "acls_one_line": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "static void\nacls_one_line (const char *prefix, char delim,\n               const char *aclstring, size_t len)\n{\n  /* support both long and short text representation of posix acls */\n  struct obstack stk;\n  int pref_len = strlen (prefix);\n  const char *oldstring = aclstring;\n  int pos = 0;\n\n  if (!aclstring || !len)\n    return;\n\n  obstack_init (&stk);\n  while (pos <= len)\n    {\n      int move = strcspn (aclstring, \",\\n\");\n      if (!move)\n        break;\n\n      if (oldstring != aclstring)\n        obstack_1grow (&stk, delim);\n\n      obstack_grow (&stk, prefix, pref_len);\n      obstack_grow (&stk, aclstring, move);\n\n      aclstring += move + 1;\n    }\n\n  obstack_1grow (&stk, '\\0');\n\n  fprintf (stdlis, \"%s\", (char *) obstack_finish (&stk));\n\n  obstack_free (&stk, NULL);\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattrs_acls_get": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "void\nxattrs_acls_get (int parentfd, char const *file_name,\n                 struct tar_stat_info *st, int fd, int xisfile)\n{\n  if (acls_option > 0)\n    {\n#ifndef HAVE_POSIX_ACLS\n      static int done = 0;\n      if (!done)\n        WARN ((0, 0, _(\"POSIX ACL support is not available\")));\n      done = 1;\n#else\n      int err = file_has_acl_at (parentfd, file_name, &st->stat);\n      if (err == 0)\n        return;\n      if (err == -1)\n        {\n          call_arg_warn (\"file_has_acl_at\", file_name);\n          return;\n        }\n\n      xattrs__acls_get_a (parentfd, file_name, st,\n                          &st->acls_a_ptr, &st->acls_a_len);\n      if (!xisfile)\n        xattrs__acls_get_d (parentfd, file_name, st,\n                            &st->acls_d_ptr, &st->acls_d_len);\n#endif\n    }\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "xattrs_acls_set": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\nxattrs_acls_set (struct tar_stat_info const *st,\n                 char const *file_name, char typeflag)\n{\n  if (acls_option > 0 && typeflag != SYMTYPE)\n    {\n#ifndef HAVE_POSIX_ACLS\n      static int done = 0;\n      if (!done)\n        WARN ((0, 0, _(\"POSIX ACL support is not available\")));\n      done = 1;\n#else\n      xattrs__acls_set (st, file_name, ACL_TYPE_ACCESS,\n                        st->acls_a_ptr, st->acls_a_len, false);\n      if (typeflag == DIRTYPE || typeflag == GNUTYPE_DUMPDIR)\n        xattrs__acls_set (st, file_name, ACL_TYPE_DEFAULT,\n                          st->acls_d_ptr, st->acls_d_len, true);\n#endif\n    }\n}",
      "lines": 20,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "mask_map_realloc": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "static void\nmask_map_realloc (struct xattrs_mask_map *map)\n{\n  if (map->used == map->size)\n    {\n      if (map->size == 0)\n\tmap->size = 4;\n      map->masks = x2nrealloc (map->masks, &map->size, sizeof (map->masks[0]));\n    }\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattrs_mask_add": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        420,
        1
      ],
      "content": "void\nxattrs_mask_add (const char *mask, bool incl)\n{\n  struct xattrs_mask_map *mask_map =\n    incl ? &xattrs_setup.incl : &xattrs_setup.excl;\n  /* ensure there is enough space */\n  mask_map_realloc (mask_map);\n  /* just assign pointers -- we silently expect that pointer \"mask\" is valid\n     through the whole program (pointer to argv array) */\n  mask_map->masks[mask_map->used++] = mask;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "clear_mask_map": {
      "start_point": [
        422,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "static void\nclear_mask_map (struct xattrs_mask_map *mask_map)\n{\n  if (mask_map->size)\n    free (mask_map->masks);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattrs_clear_setup": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        434,
        1
      ],
      "content": "void\nxattrs_clear_setup (void)\n{\n  clear_mask_map (&xattrs_setup.incl);\n  clear_mask_map (&xattrs_setup.excl);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "xattrs_xattrs_get": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "void\nxattrs_xattrs_get (int parentfd, char const *file_name,\n                   struct tar_stat_info *st, int fd)\n{\n  if (xattrs_option > 0)\n    {\n#ifndef HAVE_XATTRS\n      static int done = 0;\n      if (!done)\n        WARN ((0, 0, _(\"XATTR support is not available\")));\n      done = 1;\n#else\n      static size_t xsz = 1024;\n      static char *xatrs = NULL;\n      ssize_t xret = -1;\n\n      if (!xatrs)\n\txatrs = x2nrealloc (xatrs, &xsz, 1);\n\n      while (((fd == 0) ?\n              ((xret =\n                llistxattrat (parentfd, file_name, xatrs, xsz)) == -1) :\n\t      ((xret = flistxattr (fd, xatrs, xsz)) == -1))\n             && (errno == ERANGE))\n        {\n\t  xatrs = x2nrealloc (xatrs, &xsz, 1);\n        }\n\n      if (xret == -1)\n        call_arg_warn ((fd == 0) ? \"llistxattrat\" : \"flistxattr\", file_name);\n      else\n        {\n          const char *attr = xatrs;\n          static size_t asz = 1024;\n          static char *val = NULL;\n\n          if (!val)\n            val = x2nrealloc (val, &asz, 1);\n\n          while (xret > 0)\n            {\n              size_t len = strlen (attr);\n              ssize_t aret = 0;\n\n              while (((fd == 0)\n                      ? ((aret = lgetxattrat (parentfd, file_name, attr,\n                                              val, asz)) == -1)\n                      : ((aret = fgetxattr (fd, attr, val, asz)) == -1))\n                     && (errno == ERANGE))\n                {\n\t\t  val = x2nrealloc (val, &asz, 1);\n                }\n\n              if (aret != -1)\n                {\n                  if (!xattrs_masked_out (attr, true))\n                    xheader_xattr_add (st, attr, val, aret);\n                }\n              else if (errno != ENOATTR)\n                call_arg_warn ((fd == 0) ? \"lgetxattrat\"\n                               : \"fgetxattr\", file_name);\n\n              attr += len + 1;\n              xret -= len + 1;\n            }\n        }\n#endif\n    }\n}",
      "lines": 69,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "xattrs__fd_set": {
      "start_point": [
        513,
        0
      ],
      "end_point": [
        537,
        1
      ],
      "content": "static void\nxattrs__fd_set (struct tar_stat_info const *st,\n                char const *file_name, char typeflag,\n                const char *attr, const char *ptr, size_t len)\n{\n  if (ptr)\n    {\n      const char *sysname = \"setxattrat\";\n      int ret = -1;\n\n      if (typeflag != SYMTYPE)\n        ret = setxattrat (chdir_fd, file_name, attr, ptr, len, 0);\n      else\n        {\n          sysname = \"lsetxattr\";\n          ret = lsetxattrat (chdir_fd, file_name, attr, ptr, len, 0);\n        }\n\n      if (ret == -1)\n        WARNOPT (WARN_XATTR_WRITE,\n\t\t (0, errno,\n\t\t  _(\"%s: Cannot set '%s' extended attribute for file '%s'\"),\n\t\t  sysname, attr, file_name));\n    }\n}",
      "lines": 25,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattrs_selinux_get": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        562,
        1
      ],
      "content": "void\nxattrs_selinux_get (int parentfd, char const *file_name,\n                    struct tar_stat_info *st, int fd)\n{\n  if (selinux_context_option > 0)\n    {\n#if HAVE_SELINUX_SELINUX_H != 1\n      static int done = 0;\n      if (!done)\n        WARN ((0, 0, _(\"SELinux support is not available\")));\n      done = 1;\n#else\n      int result = fd ?\n\t            fgetfilecon (fd, &st->cntx_name)\n                    : lgetfileconat (parentfd, file_name, &st->cntx_name);\n\n      if (result == -1 && errno != ENODATA && errno != ENOTSUP)\n        call_arg_warn (fd ? \"fgetfilecon\" : \"lgetfileconat\", file_name);\n#endif\n    }\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "xattrs_selinux_set": {
      "start_point": [
        564,
        0
      ],
      "end_point": [
        600,
        1
      ],
      "content": "void\nxattrs_selinux_set (struct tar_stat_info const *st,\n                    char const *file_name, char typeflag)\n{\n  if (selinux_context_option > 0)\n    {\n#if HAVE_SELINUX_SELINUX_H != 1\n      static int done = 0;\n      if (!done)\n        WARN ((0, 0, _(\"SELinux support is not available\")));\n      done = 1;\n#else\n      const char *sysname = \"setfilecon\";\n      int ret;\n\n      if (!st->cntx_name)\n        return;\n\n      if (typeflag != SYMTYPE)\n        {\n          ret = setfileconat (chdir_fd, file_name, st->cntx_name);\n          sysname = \"setfileconat\";\n        }\n      else\n        {\n          ret = lsetfileconat (chdir_fd, file_name, st->cntx_name);\n          sysname = \"lsetfileconat\";\n        }\n\n      if (ret == -1)\n        WARNOPT (WARN_XATTR_WRITE,\n\t\t (0, errno,\n\t\t  _(\"%s: Cannot set SELinux context for file '%s'\"),\n\t\t  sysname, file_name));\n#endif\n    }\n}",
      "lines": 37,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "xattrs_matches_mask": {
      "start_point": [
        602,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "static bool\nxattrs_matches_mask (const char *kw, struct xattrs_mask_map *mm)\n{\n  int i;\n\n  if (!mm->size)\n    return false;\n\n  for (i = 0; i < mm->used; i++)\n    if (fnmatch (mm->masks[i], kw, 0) == 0)\n      return true;\n\n  return false;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "xattrs_kw_included": {
      "start_point": [
        619,
        0
      ],
      "end_point": [
        628,
        1
      ],
      "content": "static bool\nxattrs_kw_included (const char *kw, bool archiving)\n{\n  if (xattrs_setup.incl.size)\n    return xattrs_matches_mask (kw, &xattrs_setup.incl);\n  else if (archiving)\n    return true;\n  else\n    return strncmp (kw, USER_DOT_PFX, sizeof (USER_DOT_PFX) - 1) == 0;\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "xattrs_kw_excluded": {
      "start_point": [
        630,
        0
      ],
      "end_point": [
        635,
        1
      ],
      "content": "static bool\nxattrs_kw_excluded (const char *kw, bool archiving)\n{\n  return xattrs_setup.excl.size ?\n    xattrs_matches_mask (kw, &xattrs_setup.excl) : false;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "xattrs_masked_out": {
      "start_point": [
        640,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "static bool\nxattrs_masked_out (const char *kw, bool archiving)\n{\n  return xattrs_kw_included (kw, archiving) ?\n    xattrs_kw_excluded (kw, archiving) : true;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "xattrs_xattrs_set": {
      "start_point": [
        647,
        0
      ],
      "end_point": [
        689,
        1
      ],
      "content": "void\nxattrs_xattrs_set (struct tar_stat_info const *st,\n                   char const *file_name, char typeflag, int later_run)\n{\n  if (xattrs_option > 0)\n    {\n#ifndef HAVE_XATTRS\n      static int done = 0;\n      if (!done)\n        WARN ((0, 0, _(\"XATTR support is not available\")));\n      done = 1;\n#else\n      size_t scan = 0;\n\n      if (!st->xattr_map_size)\n        return;\n\n      for (; scan < st->xattr_map_size; ++scan)\n        {\n          char *keyword = st->xattr_map[scan].xkey;\n          keyword += strlen (\"SCHILY.xattr.\");\n\n          /* TODO: this 'later_run' workaround is temporary solution -> once\n             capabilities should become fully supported by it's API and there\n             should exist something like xattrs_capabilities_set() call.\n             For a regular files: all extended attributes are restored during\n             the first run except 'security.capability' which is restored in\n             'later_run == 1'.  */\n          if (typeflag == REGTYPE\n              && later_run == !!strcmp (keyword, \"security.capability\"))\n            continue;\n\n          if (xattrs_masked_out (keyword, false /* extracting */ ))\n            /* we don't want to restore this keyword */\n            continue;\n\n          xattrs__fd_set (st, file_name, typeflag, keyword,\n                          st->xattr_map[scan].xval_ptr,\n                          st->xattr_map[scan].xval_len);\n        }\n#endif\n    }\n}",
      "lines": 43,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "xattrs_print_char": {
      "start_point": [
        691,
        0
      ],
      "end_point": [
        725,
        1
      ],
      "content": "void\nxattrs_print_char (struct tar_stat_info const *st, char *output)\n{\n  int i;\n\n  if (verbose_option < 2)\n    {\n      *output = 0;\n      return;\n    }\n\n  if (xattrs_option > 0 || selinux_context_option > 0 || acls_option > 0)\n    {\n      /* placeholders */\n      *output = ' ';\n      output[1] = 0;\n    }\n\n  if (xattrs_option > 0 && st->xattr_map_size)\n    for (i = 0; i < st->xattr_map_size; ++i)\n      {\n        char *keyword = st->xattr_map[i].xkey + strlen (\"SCHILY.xattr.\");\n        if (!xattrs_masked_out (keyword, false /* like extracting */ ))\n\t  {\n\t    *output = '*';\n\t    break;\n\t  }\n      }\n\n  if (selinux_context_option > 0 && st->cntx_name)\n    *output = '.';\n\n  if (acls_option > 0 && (st->acls_a_len || st->acls_d_len))\n    *output = '+';\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "xattrs_print": {
      "start_point": [
        727,
        0
      ],
      "end_point": [
        759,
        1
      ],
      "content": "void\nxattrs_print (struct tar_stat_info const *st)\n{\n  if (verbose_option < 3)\n    return;\n\n  /* selinux */\n  if (selinux_context_option > 0 && st->cntx_name)\n    fprintf (stdlis, \"  s: %s\\n\", st->cntx_name);\n\n  /* acls */\n  if (acls_option > 0 && (st->acls_a_len || st->acls_d_len))\n    {\n      fprintf (stdlis, \"  a: \");\n      acls_one_line (\"\", ',', st->acls_a_ptr, st->acls_a_len);\n      acls_one_line (\"default:\", ',', st->acls_d_ptr, st->acls_d_len);\n      fprintf (stdlis, \"\\n\");\n    }\n\n  /* xattrs */\n  if (xattrs_option > 0 && st->xattr_map_size)\n    {\n      int i;\n\n      for (i = 0; i < st->xattr_map_size; ++i)\n        {\n          char *keyword = st->xattr_map[i].xkey + strlen (\"SCHILY.xattr.\");\n          if (!xattrs_masked_out (keyword, false /* like extracting */ ))\n\t    fprintf (stdlis, \"  x: %lu %s\\n\",\n\t\t     (unsigned long) st->xattr_map[i].xval_len, keyword);\n        }\n    }\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "tar/tar-1.30/src/xattrs.h": {},
  "tar/tar-1.30/src/xheader.c": {
    "x_obstack_grow": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\nx_obstack_grow (struct xheader *xhdr, const char *ptr, size_t length)\n{\n  obstack_grow (xhdr->stk, ptr, length);\n  xhdr->size += length;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "x_obstack_1grow": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\nx_obstack_1grow (struct xheader *xhdr, char c)\n{\n  obstack_1grow (xhdr->stk, c);\n  xhdr->size++;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "x_obstack_blank": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static void\nx_obstack_blank (struct xheader *xhdr, size_t length)\n{\n  obstack_blank (xhdr->stk, length);\n  xhdr->size += length;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xheader_keyword_deleted_p": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "bool\nxheader_keyword_deleted_p (const char *kw)\n{\n  struct keyword_list *kp;\n\n  for (kp = keyword_pattern_list; kp; kp = kp->next)\n    if (fnmatch (kp->pattern, kw, 0) == 0)\n      return true;\n  return false;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "xheader_keyword_override_p": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static bool\nxheader_keyword_override_p (const char *keyword)\n{\n  struct keyword_list *kp;\n\n  for (kp = keyword_override_list; kp; kp = kp->next)\n    if (strcmp (kp->pattern, keyword) == 0)\n      return true;\n  return false;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "xheader_list_append": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static void\nxheader_list_append (struct keyword_list **root, char const *kw,\n\t\t     char const *value)\n{\n  struct keyword_list *kp = xmalloc (sizeof *kp);\n  kp->pattern = xstrdup (kw);\n  kp->value = value ? xstrdup (value) : NULL;\n  kp->next = *root;\n  *root = kp;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xheader_list_destroy": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static void\nxheader_list_destroy (struct keyword_list **root)\n{\n  if (root)\n    {\n      struct keyword_list *kw = *root;\n      while (kw)\n\t{\n\t  struct keyword_list *next = kw->next;\n\t  free (kw->pattern);\n\t  free (kw->value);\n\t  free (kw);\n\t  kw = next;\n\t}\n      *root = NULL;\n    }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xheader_set_single_keyword": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static void\nxheader_set_single_keyword (char *kw)\n{\n  USAGE_ERROR ((0, 0, _(\"Keyword %s is unknown or not yet implemented\"), kw));\n}",
      "lines": 5,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "assign_time_option": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static void\nassign_time_option (char **sval, time_t *tval, const char *input)\n{\n  char *p;\n  struct timespec t = decode_timespec (input, &p, false);\n  if (! valid_timespec (t) || *p)\n    ERROR ((0, 0, _(\"Time stamp is out of allowed range\")));\n  else\n    {\n      *tval = t.tv_sec;\n      assign_string (sval, input);\n    }\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xheader_set_keyword_equal": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "static void\nxheader_set_keyword_equal (char *kw, char *eq)\n{\n  bool global = true;\n  char *p = eq;\n\n  if (eq[-1] == ':')\n    {\n      p--;\n      global = false;\n    }\n\n  while (p > kw && isspace ((unsigned char) *p))\n    p--;\n\n  *p = 0;\n\n  for (p = eq + 1; *p && isspace ((unsigned char) *p); p++)\n    ;\n\n  if (strcmp (kw, \"delete\") == 0)\n    {\n      if (xheader_protected_pattern_p (p))\n\tUSAGE_ERROR ((0, 0, _(\"Pattern %s cannot be used\"), quote (p)));\n      xheader_list_append (&keyword_pattern_list, p, NULL);\n    }\n  else if (strcmp (kw, \"exthdr.name\") == 0)\n    assign_string (&exthdr_name, p);\n  else if (strcmp (kw, \"globexthdr.name\") == 0)\n    assign_string (&globexthdr_name, p);\n  else if (strcmp (kw, \"exthdr.mtime\") == 0)\n    assign_time_option (&exthdr_mtime_option, &exthdr_mtime, p);\n  else if (strcmp (kw, \"globexthdr.mtime\") == 0)\n    assign_time_option (&globexthdr_mtime_option, &globexthdr_mtime, p);\n  else\n    {\n      if (xheader_protected_keyword_p (kw))\n\tUSAGE_ERROR ((0, 0, _(\"Keyword %s cannot be overridden\"), kw));\n      if (global)\n\txheader_list_append (&keyword_global_override_list, kw, p);\n      else\n\txheader_list_append (&keyword_override_list, kw, p);\n    }\n}",
      "lines": 44,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xheader_set_option": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\nxheader_set_option (char *string)\n{\n  char *token;\n  for (token = strtok (string, \",\"); token; token = strtok (NULL, \",\"))\n    {\n      char *p = strchr (token, '=');\n      if (!p)\n\txheader_set_single_keyword (token);\n      else\n\txheader_set_keyword_equal (token, p);\n    }\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "xheader_format_name": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "char *\nxheader_format_name (struct tar_stat_info *st, const char *fmt, size_t n)\n{\n  char *buf;\n  size_t len = strlen (fmt);\n  char *q;\n  const char *p;\n  char *dirp = NULL;\n  char *dir = NULL;\n  char *base = NULL;\n  char pidbuf[UINTMAX_STRSIZE_BOUND];\n  char const *pptr = NULL;\n  char nbuf[UINTMAX_STRSIZE_BOUND];\n  char const *nptr = NULL;\n\n  for (p = fmt; *p && (p = strchr (p, '%')); )\n    {\n      switch (p[1])\n\t{\n\tcase '%':\n\t  len--;\n\t  break;\n\n\tcase 'd':\n\t  if (st)\n\t    {\n\t      if (!dirp)\n\t\tdirp = dir_name (st->orig_file_name);\n\t      dir = safer_name_suffix (dirp, false, absolute_names_option);\n\t      len += strlen (dir) - 2;\n\t    }\n\t  break;\n\n\tcase 'f':\n\t  if (st)\n\t    {\n\t      base = last_component (st->orig_file_name);\n\t      len += strlen (base) - 2;\n\t    }\n\t  break;\n\n\tcase 'p':\n\t  pptr = umaxtostr (getpid (), pidbuf);\n\t  len += pidbuf + sizeof pidbuf - 1 - pptr - 2;\n\t  break;\n\n\tcase 'n':\n\t  nptr = umaxtostr (n, nbuf);\n\t  len += nbuf + sizeof nbuf - 1 - nptr - 2;\n\t  break;\n\t}\n      p++;\n    }\n\n  buf = xmalloc (len + 1);\n  for (q = buf, p = fmt; *p; )\n    {\n      if (*p == '%')\n\t{\n\t  switch (p[1])\n\t    {\n\t    case '%':\n\t      *q++ = *p++;\n\t      p++;\n\t      break;\n\n\t    case 'd':\n\t      if (dir)\n\t\tq = stpcpy (q, dir);\n\t      p += 2;\n\t      break;\n\n\t    case 'f':\n\t      if (base)\n\t\tq = stpcpy (q, base);\n\t      p += 2;\n\t      break;\n\n\t    case 'p':\n\t      q = stpcpy (q, pptr);\n\t      p += 2;\n\t      break;\n\n\t    case 'n':\n\t      q = stpcpy (q, nptr);\n\t      p += 2;\n\t      break;\n\n\n\t    default:\n\t      *q++ = *p++;\n\t      if (*p)\n\t\t*q++ = *p++;\n\t    }\n\t}\n      else\n\t*q++ = *p++;\n    }\n\n  free (dirp);\n\n  /* Do not allow it to end in a slash */\n  while (q > buf && ISSLASH (q[-1]))\n    q--;\n  *q = 0;\n  return buf;\n}",
      "lines": 107,
      "depth": 16,
      "decorators": [
        "char",
        "*\nxheader_format_name (struct tar_stat_info *st, const char *fmt, size_t n)",
        "*"
      ]
    },
    "xheader_xhdr_name": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "char *\nxheader_xhdr_name (struct tar_stat_info *st)\n{\n  if (!exthdr_name)\n    assign_string (&exthdr_name, \"%d/PaxHeaders.%p/%f\");\n  return xheader_format_name (st, exthdr_name, 0);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "char",
        "*\nxheader_xhdr_name (struct tar_stat_info *st)",
        "*"
      ]
    },
    "xheader_ghdr_name": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "char *\nxheader_ghdr_name (void)\n{\n  if (!globexthdr_name)\n    {\n      size_t len;\n      const char *tmp = getenv (\"TMPDIR\");\n      if (!tmp)\n\ttmp = \"/tmp\";\n      len = strlen (tmp) + sizeof (GLOBAL_HEADER_TEMPLATE); /* Includes nul */\n      globexthdr_name = xmalloc (len);\n      strcpy(globexthdr_name, tmp);\n      strcat(globexthdr_name, GLOBAL_HEADER_TEMPLATE);\n    }\n\n  return xheader_format_name (NULL, globexthdr_name, global_header_count + 1);\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "char",
        "*\nxheader_ghdr_name (void)",
        "*"
      ]
    },
    "xheader_write": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "void\nxheader_write (char type, char *name, time_t t, struct xheader *xhdr)\n{\n  union block *header;\n  size_t size;\n  char *p;\n\n  size = xhdr->size;\n  switch (type)\n    {\n    case XGLTYPE:\n      if (globexthdr_mtime_option)\n\tt = globexthdr_mtime;\n      break;\n\n    case XHDTYPE:\n      if (exthdr_mtime_option)\n\tt = exthdr_mtime;\n      break;\n    }\n  header = start_private_header (name, size, t);\n  header->header.typeflag = type;\n\n  simple_finish_header (header);\n\n  p = xhdr->buffer;\n\n  do\n    {\n      size_t len;\n\n      header = find_next_block ();\n      len = BLOCKSIZE;\n      if (len > size)\n\tlen = size;\n      memcpy (header->buffer, p, len);\n      if (len < BLOCKSIZE)\n\tmemset (header->buffer + len, 0, BLOCKSIZE - len);\n      p += len;\n      size -= len;\n      set_next_block_after (header);\n    }\n  while (size > 0);\n  xheader_destroy (xhdr);\n\n  if (type == XGLTYPE)\n    global_header_count++;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "xheader_write_global": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "void\nxheader_write_global (struct xheader *xhdr)\n{\n  if (keyword_global_override_list)\n    {\n      struct keyword_list *kp;\n\n      xheader_init (xhdr);\n      for (kp = keyword_global_override_list; kp; kp = kp->next)\n\tcode_string (kp->value, kp->pattern, xhdr);\n    }\n  if (xhdr->stk)\n    {\n      char *name;\n\n      xheader_finish (xhdr);\n      name = xheader_ghdr_name ();\n      xheader_write (XGLTYPE, name, start_time.tv_sec, xhdr);\n      free (name);\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "xheader_xattr_init": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        471,
        1
      ],
      "content": "void\nxheader_xattr_init (struct tar_stat_info *st)\n{\n  st->xattr_map = NULL;\n  st->xattr_map_size = 0;\n\n  st->acls_a_ptr = NULL;\n  st->acls_a_len = 0;\n  st->acls_d_ptr = NULL;\n  st->acls_d_len = 0;\n  st->cntx_name = NULL;\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "xheader_xattr_free": {
      "start_point": [
        473,
        0
      ],
      "end_point": [
        486,
        1
      ],
      "content": "void\nxheader_xattr_free (struct xattr_array *xattr_map, size_t xattr_map_size)\n{\n  size_t scan = 0;\n\n  while (scan < xattr_map_size)\n    {\n      free (xattr_map[scan].xkey);\n      free (xattr_map[scan].xval_ptr);\n\n      ++scan;\n    }\n  free (xattr_map);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "xheader_xattr__add": {
      "start_point": [
        488,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "static void\nxheader_xattr__add (struct xattr_array **xattr_map,\n\t\t    size_t *xattr_map_size,\n\t\t    const char *key, const char *val, size_t len)\n{\n  size_t pos = (*xattr_map_size)++;\n\n  *xattr_map = xrealloc (*xattr_map,\n                         *xattr_map_size * sizeof(struct xattr_array));\n  (*xattr_map)[pos].xkey = xstrdup (key);\n  (*xattr_map)[pos].xval_ptr = xmemdup (val, len + 1);\n  (*xattr_map)[pos].xval_len = len;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattr_decode_keyword": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "static void\nxattr_decode_keyword (char *keyword)\n{\n  char *kpr, *kpl; /* keyword pointer left/right */\n  kpr = kpl = keyword;\n\n  for (;;)\n    {\n      if (*kpr == '%')\n        {\n          if (kpr[1] == '3' && kpr[2] == 'D')\n            {\n              *kpl = '=';\n              kpr += 3;\n              kpl ++;\n              continue;\n            }\n          else if (kpr[1] == '2' && kpr[2] == '5')\n            {\n              *kpl = '%';\n              kpr += 3;\n              kpl ++;\n              continue;\n            }\n        }\n\n      *kpl = *kpr;\n\n      if (*kpr == 0)\n        break;\n\n      kpr++;\n      kpl++;\n    }\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xheader_xattr_add": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        554,
        1
      ],
      "content": "void\nxheader_xattr_add (struct tar_stat_info *st,\n\t\t   const char *key, const char *val, size_t len)\n{\n  size_t klen = strlen (key);\n  char *xkey = xmalloc (strlen(\"SCHILY.xattr.\") + klen + 1);\n  char *tmp = xkey;\n\n  tmp = stpcpy (tmp, \"SCHILY.xattr.\");\n  stpcpy (tmp, key);\n\n  xheader_xattr__add (&st->xattr_map, &st->xattr_map_size, xkey, val, len);\n\n  free (xkey);\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "xheader_xattr_copy": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        575,
        1
      ],
      "content": "void\nxheader_xattr_copy (const struct tar_stat_info *st,\n\t\t    struct xattr_array **xattr_map, size_t *xattr_map_size)\n{\n  size_t scan = 0;\n\n  *xattr_map = NULL;\n  *xattr_map_size = 0;\n\n  while (scan < st->xattr_map_size)\n    {\n      char  *key = st->xattr_map[scan].xkey;\n      char  *val = st->xattr_map[scan].xval_ptr;\n      size_t len = st->xattr_map[scan].xval_len;\n\n      xheader_xattr__add(xattr_map, xattr_map_size, key, val, len);\n\n      ++scan;\n    }\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "locate_handler": {
      "start_point": [
        601,
        0
      ],
      "end_point": [
        619,
        1
      ],
      "content": "static struct xhdr_tab const *\nlocate_handler (char const *keyword)\n{\n  struct xhdr_tab const *p;\n\n  for (p = xhdr_tab; p->keyword; p++)\n    if (p->prefix)\n      {\n        if (strncmp (p->keyword, keyword, strlen(p->keyword)) == 0)\n          return p;\n      }\n    else\n      {\n        if (strcmp (p->keyword, keyword) == 0)\n          return p;\n      }\n\n  return NULL;\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "struct xhdr_tab",
        "struct",
        "xhdr_tab",
        "const",
        "const",
        "*\nlocate_handler (char const *keyword)",
        "*"
      ]
    },
    "xheader_protected_pattern_p": {
      "start_point": [
        621,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "static bool\nxheader_protected_pattern_p (const char *pattern)\n{\n  struct xhdr_tab const *p;\n\n  for (p = xhdr_tab; p->keyword; p++)\n    if (!p->prefix && (p->flags & XHDR_PROTECTED)\n        && fnmatch (pattern, p->keyword, 0) == 0)\n      return true;\n  return false;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "xheader_protected_keyword_p": {
      "start_point": [
        633,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "static bool\nxheader_protected_keyword_p (const char *keyword)\n{\n  struct xhdr_tab const *p;\n\n  for (p = xhdr_tab; p->keyword; p++)\n    if (!p->prefix && (p->flags & XHDR_PROTECTED)\n        && strcmp (p->keyword, keyword) == 0)\n      return true;\n  return false;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "decode_record": {
      "start_point": [
        647,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "static bool\ndecode_record (struct xheader *xhdr,\n\t       char **ptr,\n\t       void (*handler) (void *, char const *, char const *, size_t),\n\t       void *data)\n{\n  char *start = *ptr;\n  char *p = start;\n  size_t len;\n  char *len_lim;\n  char const *keyword;\n  char *nextp;\n  size_t len_max = xhdr->buffer + xhdr->size - start;\n\n  while (*p == ' ' || *p == '\\t')\n    p++;\n\n  if (! ISDIGIT (*p))\n    {\n      if (*p)\n\tERROR ((0, 0, _(\"Malformed extended header: missing length\")));\n      return false;\n    }\n\n  len = strtoumax (p, &len_lim, 10);\n\n  if (len_max < len)\n    {\n      int len_len = len_lim - p;\n      ERROR ((0, 0, _(\"Extended header length %*s is out of range\"),\n\t      len_len, p));\n      return false;\n    }\n\n  nextp = start + len;\n\n  for (p = len_lim; *p == ' ' || *p == '\\t'; p++)\n    continue;\n  if (p == len_lim)\n    {\n      ERROR ((0, 0,\n\t      _(\"Malformed extended header: missing blank after length\")));\n      return false;\n    }\n\n  keyword = p;\n  p = strchr (p, '=');\n  if (! (p && p < nextp))\n    {\n      ERROR ((0, 0, _(\"Malformed extended header: missing equal sign\")));\n      return false;\n    }\n\n  if (nextp[-1] != '\\n')\n    {\n      ERROR ((0, 0, _(\"Malformed extended header: missing newline\")));\n      return false;\n    }\n\n  *p = nextp[-1] = '\\0';\n  handler (data, keyword, p + 1, nextp - p - 2); /* '=' + trailing '\\n' */\n  *p = '=';\n  nextp[-1] = '\\n';\n  *ptr = nextp;\n  return true;\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "run_override_list": {
      "start_point": [
        714,
        0
      ],
      "end_point": [
        723,
        1
      ],
      "content": "static void\nrun_override_list (struct keyword_list *kp, struct tar_stat_info *st)\n{\n  for (; kp; kp = kp->next)\n    {\n      struct xhdr_tab const *t = locate_handler (kp->pattern);\n      if (t)\n\tt->decoder (st, t->keyword, kp->value, strlen (kp->value));\n    }\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "decx": {
      "start_point": [
        725,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "static void\ndecx (void *data, char const *keyword, char const *value, size_t size)\n{\n  struct xhdr_tab const *t;\n  struct tar_stat_info *st = data;\n\n  if (xheader_keyword_deleted_p (keyword)\n      || xheader_keyword_override_p (keyword))\n    return;\n\n  t = locate_handler (keyword);\n  if (t)\n    t->decoder (st, keyword, value, size);\n  else\n    WARNOPT (WARN_UNKNOWN_KEYWORD,\n\t     (0, 0, _(\"Ignoring unknown extended header keyword '%s'\"),\n\t      keyword));\n}",
      "lines": 18,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xheader_decode": {
      "start_point": [
        744,
        0
      ],
      "end_point": [
        767,
        1
      ],
      "content": "void\nxheader_decode (struct tar_stat_info *st)\n{\n  run_override_list (keyword_global_override_list, st);\n  run_override_list (global_header_override_list, st);\n\n  if (st->xhdr.size)\n    {\n      char *p = st->xhdr.buffer + BLOCKSIZE;\n      while (decode_record (&st->xhdr, &p, decx, st))\n\tcontinue;\n    }\n  run_override_list (keyword_override_list, st);\n\n  /* The archived (effective) file size is always set directly in tar header\n     field, possibly overridden by \"size\" extended header - in both cases,\n     result is now decoded in st->stat.st_size */\n  st->archive_file_size = st->stat.st_size;\n\n  /* The real file size (given by stat()) may be redefined for sparse\n     files in \"GNU.sparse.realsize\" extended header */\n  if (st->real_size_set)\n    st->stat.st_size = st->real_size;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "decg": {
      "start_point": [
        769,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "static void\ndecg (void *data, char const *keyword, char const *value,\n      size_t size __attribute__((unused)))\n{\n  struct keyword_list **kwl = data;\n  struct xhdr_tab const *tab = locate_handler (keyword);\n  if (tab && (tab->flags & XHDR_GLOBAL))\n    tab->decoder (data, keyword, value, size);\n  else\n    xheader_list_append (kwl, keyword, value);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xheader_decode_global": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        792,
        1
      ],
      "content": "void\nxheader_decode_global (struct xheader *xhdr)\n{\n  if (xhdr->size)\n    {\n      char *p = xhdr->buffer + BLOCKSIZE;\n\n      xheader_list_destroy (&global_header_override_list);\n      while (decode_record (xhdr, &p, decg, &global_header_override_list))\n\tcontinue;\n    }\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "xheader_init": {
      "start_point": [
        794,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "static void\nxheader_init (struct xheader *xhdr)\n{\n  if (!xhdr->stk)\n    {\n      xhdr->stk = xmalloc (sizeof *xhdr->stk);\n      obstack_init (xhdr->stk);\n    }\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xheader_store": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "void\nxheader_store (char const *keyword, struct tar_stat_info *st,\n\t       void const *data)\n{\n  struct xhdr_tab const *t;\n\n  if (st->xhdr.buffer)\n    return;\n  t = locate_handler (keyword);\n  if (!t || !t->coder)\n    return;\n  if (xheader_keyword_deleted_p (keyword))\n    return;\n  xheader_init (&st->xhdr);\n  if (!xheader_keyword_override_p (keyword))\n    t->coder (st, keyword, &st->xhdr, data);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "xheader_read": {
      "start_point": [
        822,
        0
      ],
      "end_point": [
        857,
        1
      ],
      "content": "void\nxheader_read (struct xheader *xhdr, union block *p, off_t size)\n{\n  size_t j = 0;\n\n  if (size < 0)\n    size = 0; /* Already diagnosed.  */\n\n  if (SIZE_MAX - BLOCKSIZE <= size)\n    xalloc_die ();\n\n  size += BLOCKSIZE;\n  xhdr->size = size;\n  xhdr->buffer = xmalloc (size + 1);\n  xhdr->buffer[size] = '\\0';\n\n  do\n    {\n      size_t len = size;\n\n      if (len > BLOCKSIZE)\n\tlen = BLOCKSIZE;\n\n      if (!p)\n\tFATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\n      memcpy (&xhdr->buffer[j], p->buffer, len);\n      set_next_block_after (p);\n\n      p = find_next_block ();\n\n      j += len;\n      size -= len;\n    }\n  while (size > 0);\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "xattr_encode_keyword": {
      "start_point": [
        868,
        0
      ],
      "end_point": [
        909,
        1
      ],
      "content": "static char *\nxattr_encode_keyword(const char *keyword)\n{\n  static char *encode_buffer = NULL;\n  static size_t encode_buffer_size = 0;\n  size_t bp; /* keyword/buffer pointers */\n\n  if (!encode_buffer)\n    {\n      encode_buffer_size = 256;\n      encode_buffer = xmalloc (encode_buffer_size);\n    }\n  else\n    *encode_buffer = 0;\n\n  for (bp = 0; *keyword != 0; ++bp, ++keyword)\n    {\n      char c = *keyword;\n\n      if (bp + 2 /* enough for URL encoding also.. */ >= encode_buffer_size)\n        {\n          encode_buffer = x2realloc (encode_buffer, &encode_buffer_size);\n        }\n\n      if (c == '%')\n        {\n          strcpy (encode_buffer + bp, \"%25\");\n          bp += 2;\n        }\n      else if (c == '=')\n        {\n          strcpy (encode_buffer + bp, \"%3D\");\n          bp += 2;\n        }\n      else\n        encode_buffer[bp] = c;\n    }\n\n  encode_buffer[bp] = 0;\n\n  return encode_buffer;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nxattr_encode_keyword(const char *keyword)",
        "*"
      ]
    },
    "xheader_print_n": {
      "start_point": [
        911,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "static void\nxheader_print_n (struct xheader *xhdr, char const *keyword,\n\t\t char const *value, size_t vsize)\n{\n  size_t p;\n  size_t n = 0;\n  char nbuf[UINTMAX_STRSIZE_BOUND];\n  char const *np;\n  size_t len, klen;\n\n  keyword = xattr_encode_keyword (keyword);\n  klen = strlen (keyword);\n  len = klen + vsize + 3; /* ' ' + '=' + '\\n' */\n\n  do\n    {\n      p = n;\n      np = umaxtostr (len + p, nbuf);\n      n = nbuf + sizeof nbuf - 1 - np;\n    }\n  while (n != p);\n\n  x_obstack_grow (xhdr, np, n);\n  x_obstack_1grow (xhdr, ' ');\n  x_obstack_grow (xhdr, keyword, klen);\n  x_obstack_1grow (xhdr, '=');\n  x_obstack_grow (xhdr, value, vsize);\n  x_obstack_1grow (xhdr, '\\n');\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xheader_print": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "static void\nxheader_print (struct xheader *xhdr, char const *keyword, char const *value)\n{\n  xheader_print_n (xhdr, keyword, value, strlen (value));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xheader_finish": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        956,
        1
      ],
      "content": "void\nxheader_finish (struct xheader *xhdr)\n{\n  struct keyword_list *kp;\n\n  for (kp = keyword_override_list; kp; kp = kp->next)\n    code_string (kp->value, kp->pattern, xhdr);\n\n  xhdr->buffer = obstack_finish (xhdr->stk);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "xheader_destroy": {
      "start_point": [
        958,
        0
      ],
      "end_point": [
        971,
        1
      ],
      "content": "void\nxheader_destroy (struct xheader *xhdr)\n{\n  if (xhdr->stk)\n    {\n      obstack_free (xhdr->stk, NULL);\n      free (xhdr->stk);\n      xhdr->stk = NULL;\n    }\n  else\n    free (xhdr->buffer);\n  xhdr->buffer = 0;\n  xhdr->size = 0;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "xheader_string_begin": {
      "start_point": [
        976,
        0
      ],
      "end_point": [
        980,
        1
      ],
      "content": "void\nxheader_string_begin (struct xheader *xhdr)\n{\n  xhdr->string_length = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "xheader_string_add": {
      "start_point": [
        982,
        0
      ],
      "end_point": [
        990,
        1
      ],
      "content": "void\nxheader_string_add (struct xheader *xhdr, char const *s)\n{\n  if (xhdr->buffer)\n    return;\n  xheader_init (xhdr);\n  xhdr->string_length += strlen (s);\n  x_obstack_grow (xhdr, s, strlen (s));\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "xheader_string_end": {
      "start_point": [
        992,
        0
      ],
      "end_point": [
        1036,
        1
      ],
      "content": "bool\nxheader_string_end (struct xheader *xhdr, char const *keyword)\n{\n  uintmax_t len;\n  uintmax_t p;\n  uintmax_t n = 0;\n  size_t size;\n  char nbuf[UINTMAX_STRSIZE_BOUND];\n  char const *np;\n  char *cp;\n\n  if (xhdr->buffer)\n    return false;\n  xheader_init (xhdr);\n\n  len = strlen (keyword) + xhdr->string_length + 3; /* ' ' + '=' + '\\n' */\n\n  do\n    {\n      p = n;\n      np = umaxtostr (len + p, nbuf);\n      n = nbuf + sizeof nbuf - 1 - np;\n    }\n  while (n != p);\n\n  p = strlen (keyword) + n + 2;\n  size = p;\n  if (size != p)\n    {\n      ERROR ((0, 0,\n        _(\"Generated keyword/value pair is too long (keyword=%s, length=%s)\"),\n\t      keyword, nbuf));\n      obstack_free (xhdr->stk, obstack_finish (xhdr->stk));\n      return false;\n    }\n  x_obstack_blank (xhdr, p);\n  x_obstack_1grow (xhdr, '\\n');\n  cp = (char*) obstack_next_free (xhdr->stk) - xhdr->string_length - p - 1;\n  memmove (cp + p, cp, xhdr->string_length);\n  cp = stpcpy (cp, np);\n  *cp++ = ' ';\n  cp = stpcpy (cp, keyword);\n  *cp++ = '=';\n  return true;\n}",
      "lines": 45,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "out_of_range_header": {
      "start_point": [
        1041,
        0
      ],
      "end_point": [
        1054,
        1
      ],
      "content": "static void\nout_of_range_header (char const *keyword, char const *value,\n\t\t     intmax_t minval, uintmax_t maxval)\n{\n  char minval_buf[INT_BUFSIZE_BOUND (intmax_t)];\n  char maxval_buf[UINTMAX_STRSIZE_BOUND];\n  char *minval_string = imaxtostr (minval, minval_buf);\n  char *maxval_string = umaxtostr (maxval, maxval_buf);\n\n  /* TRANSLATORS: The first %s is the pax extended header keyword\n     (atime, gid, etc.).  */\n  ERROR ((0, 0, _(\"Extended header %s=%s is out of range %s..%s\"),\n\t  keyword, value, minval_string, maxval_string));\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "code_string": {
      "start_point": [
        1056,
        0
      ],
      "end_point": [
        1067,
        1
      ],
      "content": "static void\ncode_string (char const *string, char const *keyword, struct xheader *xhdr)\n{\n  char *outstr;\n  if (!utf8_convert (true, string, &outstr))\n    {\n      /* FIXME: report error */\n      outstr = xstrdup (string);\n    }\n  xheader_print (xhdr, keyword, outstr);\n  free (outstr);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "decode_string": {
      "start_point": [
        1069,
        0
      ],
      "end_point": [
        1082,
        1
      ],
      "content": "static void\ndecode_string (char **string, char const *arg)\n{\n  if (*string)\n    {\n      free (*string);\n      *string = NULL;\n    }\n  if (!utf8_convert (false, arg, string))\n    {\n      /* FIXME: report error and act accordingly to --pax invalid=UTF-8 */\n      assign_string (string, arg);\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "code_time": {
      "start_point": [
        1084,
        0
      ],
      "end_point": [
        1089,
        1
      ],
      "content": "static void\ncode_time (struct timespec t, char const *keyword, struct xheader *xhdr)\n{\n  char buf[TIMESPEC_STRSIZE_BOUND];\n  xheader_print (xhdr, keyword, code_timespec (t, buf));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "decode_time": {
      "start_point": [
        1091,
        0
      ],
      "end_point": [
        1110,
        1
      ],
      "content": "static bool\ndecode_time (struct timespec *ts, char const *arg, char const *keyword)\n{\n  char *arg_lim;\n  struct timespec t = decode_timespec (arg, &arg_lim, true);\n\n  if (! valid_timespec (t))\n    {\n      if (arg < arg_lim && !*arg_lim)\n\tout_of_range_header (keyword, arg, TYPE_MINIMUM (time_t),\n\t\t\t     TYPE_MAXIMUM (time_t));\n      else\n\tERROR ((0, 0, _(\"Malformed extended header: invalid %s=%s\"),\n\t\tkeyword, arg));\n      return false;\n    }\n\n  *ts = t;\n  return true;\n}",
      "lines": 20,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "code_signed_num": {
      "start_point": [
        1112,
        0
      ],
      "end_point": [
        1118,
        1
      ],
      "content": "static void\ncode_signed_num (uintmax_t value, char const *keyword,\n\t\t intmax_t minval, uintmax_t maxval, struct xheader *xhdr)\n{\n  char sbuf[SYSINT_BUFSIZE];\n  xheader_print (xhdr, keyword, sysinttostr (value, minval, maxval, sbuf));\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "code_num": {
      "start_point": [
        1120,
        0
      ],
      "end_point": [
        1124,
        1
      ],
      "content": "static void\ncode_num (uintmax_t value, char const *keyword, struct xheader *xhdr)\n{\n  code_signed_num (value, keyword, 0, UINTMAX_MAX, xhdr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "decode_signed_num": {
      "start_point": [
        1126,
        0
      ],
      "end_point": [
        1149,
        1
      ],
      "content": "static bool\ndecode_signed_num (intmax_t *num, char const *arg,\n\t\t   intmax_t minval, uintmax_t maxval,\n\t\t   char const *keyword)\n{\n  char *arg_lim;\n  intmax_t u = strtosysint (arg, &arg_lim, minval, maxval);\n\n  if (errno == EINVAL || *arg_lim)\n    {\n      ERROR ((0, 0, _(\"Malformed extended header: invalid %s=%s\"),\n\t      keyword, arg));\n      return false;\n    }\n\n  if (errno == ERANGE)\n    {\n      out_of_range_header (keyword, arg, minval, maxval);\n      return false;\n    }\n\n  *num = u;\n  return true;\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "decode_num": {
      "start_point": [
        1151,
        0
      ],
      "end_point": [
        1160,
        1
      ],
      "content": "static bool\ndecode_num (uintmax_t *num, char const *arg, uintmax_t maxval,\n\t    char const *keyword)\n{\n  intmax_t i;\n  if (! decode_signed_num (&i, arg, 0, maxval, keyword))\n    return false;\n  *num = i;\n  return true;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "dummy_coder": {
      "start_point": [
        1162,
        0
      ],
      "end_point": [
        1168,
        1
      ],
      "content": "static void\ndummy_coder (struct tar_stat_info const *st __attribute__ ((unused)),\n\t     char const *keyword __attribute__ ((unused)),\n\t     struct xheader *xhdr __attribute__ ((unused)),\n\t     void const *data __attribute__ ((unused)))\n{\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dummy_decoder": {
      "start_point": [
        1170,
        0
      ],
      "end_point": [
        1176,
        1
      ],
      "content": "static void\ndummy_decoder (struct tar_stat_info *st __attribute__ ((unused)),\n\t       char const *keyword __attribute__ ((unused)),\n\t       char const *arg __attribute__ ((unused)),\n\t       size_t size __attribute__((unused)))\n{\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "atime_coder": {
      "start_point": [
        1178,
        0
      ],
      "end_point": [
        1183,
        1
      ],
      "content": "static void\natime_coder (struct tar_stat_info const *st, char const *keyword,\n\t     struct xheader *xhdr, void const *data __attribute__ ((unused)))\n{\n  code_time (st->atime, keyword, xhdr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "atime_decoder": {
      "start_point": [
        1185,
        0
      ],
      "end_point": [
        1194,
        1
      ],
      "content": "static void\natime_decoder (struct tar_stat_info *st,\n\t       char const *keyword,\n\t       char const *arg,\n\t       size_t size __attribute__((unused)))\n{\n  struct timespec ts;\n  if (decode_time (&ts, arg, keyword))\n    st->atime = ts;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gid_coder": {
      "start_point": [
        1196,
        0
      ],
      "end_point": [
        1202,
        1
      ],
      "content": "static void\ngid_coder (struct tar_stat_info const *st, char const *keyword,\n\t   struct xheader *xhdr, void const *data __attribute__ ((unused)))\n{\n  code_signed_num (st->stat.st_gid, keyword,\n\t\t   TYPE_MINIMUM (gid_t), TYPE_MAXIMUM (gid_t), xhdr);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gid_decoder": {
      "start_point": [
        1204,
        0
      ],
      "end_point": [
        1214,
        1
      ],
      "content": "static void\ngid_decoder (struct tar_stat_info *st,\n\t     char const *keyword,\n\t     char const *arg,\n\t     size_t size __attribute__((unused)))\n{\n  intmax_t u;\n  if (decode_signed_num (&u, arg, TYPE_MINIMUM (gid_t),\n\t\t\t TYPE_MAXIMUM (gid_t), keyword))\n    st->stat.st_gid = u;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gname_coder": {
      "start_point": [
        1216,
        0
      ],
      "end_point": [
        1221,
        1
      ],
      "content": "static void\ngname_coder (struct tar_stat_info const *st, char const *keyword,\n\t     struct xheader *xhdr, void const *data __attribute__ ((unused)))\n{\n  code_string (st->gname, keyword, xhdr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gname_decoder": {
      "start_point": [
        1223,
        0
      ],
      "end_point": [
        1230,
        1
      ],
      "content": "static void\ngname_decoder (struct tar_stat_info *st,\n\t       char const *keyword __attribute__((unused)),\n\t       char const *arg,\n\t       size_t size __attribute__((unused)))\n{\n  decode_string (&st->gname, arg);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "linkpath_coder": {
      "start_point": [
        1232,
        0
      ],
      "end_point": [
        1237,
        1
      ],
      "content": "static void\nlinkpath_coder (struct tar_stat_info const *st, char const *keyword,\n\t\tstruct xheader *xhdr, void const *data __attribute__ ((unused)))\n{\n  code_string (st->link_name, keyword, xhdr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "linkpath_decoder": {
      "start_point": [
        1239,
        0
      ],
      "end_point": [
        1246,
        1
      ],
      "content": "static void\nlinkpath_decoder (struct tar_stat_info *st,\n\t\t  char const *keyword __attribute__((unused)),\n\t\t  char const *arg,\n\t\t  size_t size __attribute__((unused)))\n{\n  decode_string (&st->link_name, arg);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ctime_coder": {
      "start_point": [
        1248,
        0
      ],
      "end_point": [
        1253,
        1
      ],
      "content": "static void\nctime_coder (struct tar_stat_info const *st, char const *keyword,\n\t     struct xheader *xhdr, void const *data __attribute__ ((unused)))\n{\n  code_time (st->ctime, keyword, xhdr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ctime_decoder": {
      "start_point": [
        1255,
        0
      ],
      "end_point": [
        1264,
        1
      ],
      "content": "static void\nctime_decoder (struct tar_stat_info *st,\n\t       char const *keyword,\n\t       char const *arg,\n\t       size_t size __attribute__((unused)))\n{\n  struct timespec ts;\n  if (decode_time (&ts, arg, keyword))\n    st->ctime = ts;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mtime_coder": {
      "start_point": [
        1266,
        0
      ],
      "end_point": [
        1272,
        1
      ],
      "content": "static void\nmtime_coder (struct tar_stat_info const *st, char const *keyword,\n\t     struct xheader *xhdr, void const *data)\n{\n  struct timespec const *mtime = data;\n  code_time (mtime ? *mtime : st->mtime, keyword, xhdr);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mtime_decoder": {
      "start_point": [
        1274,
        0
      ],
      "end_point": [
        1283,
        1
      ],
      "content": "static void\nmtime_decoder (struct tar_stat_info *st,\n\t       char const *keyword,\n\t       char const *arg,\n\t       size_t size __attribute__((unused)))\n{\n  struct timespec ts;\n  if (decode_time (&ts, arg, keyword))\n    st->mtime = ts;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "path_coder": {
      "start_point": [
        1285,
        0
      ],
      "end_point": [
        1290,
        1
      ],
      "content": "static void\npath_coder (struct tar_stat_info const *st, char const *keyword,\n\t    struct xheader *xhdr, void const *data __attribute__ ((unused)))\n{\n  code_string (st->file_name, keyword, xhdr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "raw_path_decoder": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1298,
        1
      ],
      "content": "static void\nraw_path_decoder (struct tar_stat_info *st, char const *arg)\n{\n  decode_string (&st->orig_file_name, arg);\n  decode_string (&st->file_name, arg);\n  st->had_trailing_slash = strip_trailing_slashes (st->file_name);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "path_decoder": {
      "start_point": [
        1301,
        0
      ],
      "end_point": [
        1309,
        1
      ],
      "content": "static void\npath_decoder (struct tar_stat_info *st,\n\t      char const *keyword __attribute__((unused)),\n\t      char const *arg,\n\t      size_t size __attribute__((unused)))\n{\n  if (! st->sparse_name_done)\n    raw_path_decoder (st, arg);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_path_decoder": {
      "start_point": [
        1311,
        0
      ],
      "end_point": [
        1319,
        1
      ],
      "content": "static void\nsparse_path_decoder (struct tar_stat_info *st,\n                     char const *keyword __attribute__((unused)),\n                     char const *arg,\n                     size_t size __attribute__((unused)))\n{\n  st->sparse_name_done = true;\n  raw_path_decoder (st, arg);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "size_coder": {
      "start_point": [
        1321,
        0
      ],
      "end_point": [
        1326,
        1
      ],
      "content": "static void\nsize_coder (struct tar_stat_info const *st, char const *keyword,\n\t    struct xheader *xhdr, void const *data __attribute__ ((unused)))\n{\n  code_num (st->stat.st_size, keyword, xhdr);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "size_decoder": {
      "start_point": [
        1328,
        0
      ],
      "end_point": [
        1337,
        1
      ],
      "content": "static void\nsize_decoder (struct tar_stat_info *st,\n\t      char const *keyword,\n\t      char const *arg,\n\t      size_t size __attribute__((unused)))\n{\n  uintmax_t u;\n  if (decode_num (&u, arg, TYPE_MAXIMUM (off_t), keyword))\n    st->stat.st_size = u;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uid_coder": {
      "start_point": [
        1339,
        0
      ],
      "end_point": [
        1345,
        1
      ],
      "content": "static void\nuid_coder (struct tar_stat_info const *st, char const *keyword,\n\t   struct xheader *xhdr, void const *data __attribute__ ((unused)))\n{\n  code_signed_num (st->stat.st_uid, keyword,\n\t\t   TYPE_MINIMUM (uid_t), TYPE_MAXIMUM (uid_t), xhdr);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uid_decoder": {
      "start_point": [
        1347,
        0
      ],
      "end_point": [
        1357,
        1
      ],
      "content": "static void\nuid_decoder (struct tar_stat_info *st,\n\t     char const *keyword,\n\t     char const *arg,\n\t     size_t size __attribute__((unused)))\n{\n  intmax_t u;\n  if (decode_signed_num (&u, arg, TYPE_MINIMUM (uid_t),\n\t\t\t TYPE_MAXIMUM (uid_t), keyword))\n    st->stat.st_uid = u;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uname_coder": {
      "start_point": [
        1359,
        0
      ],
      "end_point": [
        1364,
        1
      ],
      "content": "static void\nuname_coder (struct tar_stat_info const *st, char const *keyword,\n\t     struct xheader *xhdr, void const *data __attribute__ ((unused)))\n{\n  code_string (st->uname, keyword, xhdr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uname_decoder": {
      "start_point": [
        1366,
        0
      ],
      "end_point": [
        1373,
        1
      ],
      "content": "static void\nuname_decoder (struct tar_stat_info *st,\n\t       char const *keyword __attribute__((unused)),\n\t       char const *arg,\n\t       size_t size __attribute__((unused)))\n{\n  decode_string (&st->uname, arg);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_size_coder": {
      "start_point": [
        1375,
        0
      ],
      "end_point": [
        1380,
        1
      ],
      "content": "static void\nsparse_size_coder (struct tar_stat_info const *st, char const *keyword,\n\t     struct xheader *xhdr, void const *data)\n{\n  size_coder (st, keyword, xhdr, data);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_size_decoder": {
      "start_point": [
        1382,
        0
      ],
      "end_point": [
        1394,
        1
      ],
      "content": "static void\nsparse_size_decoder (struct tar_stat_info *st,\n\t\t     char const *keyword,\n\t\t     char const *arg,\n\t\t     size_t size __attribute__((unused)))\n{\n  uintmax_t u;\n  if (decode_num (&u, arg, TYPE_MAXIMUM (off_t), keyword))\n    {\n      st->real_size_set = true;\n      st->real_size = u;\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_numblocks_coder": {
      "start_point": [
        1396,
        0
      ],
      "end_point": [
        1402,
        1
      ],
      "content": "static void\nsparse_numblocks_coder (struct tar_stat_info const *st, char const *keyword,\n\t\t\tstruct xheader *xhdr,\n\t\t\tvoid const *data __attribute__ ((unused)))\n{\n  code_num (st->sparse_map_avail, keyword, xhdr);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_numblocks_decoder": {
      "start_point": [
        1404,
        0
      ],
      "end_point": [
        1417,
        1
      ],
      "content": "static void\nsparse_numblocks_decoder (struct tar_stat_info *st,\n\t\t\t  char const *keyword,\n\t\t\t  char const *arg,\n\t\t\t  size_t size __attribute__((unused)))\n{\n  uintmax_t u;\n  if (decode_num (&u, arg, SIZE_MAX, keyword))\n    {\n      st->sparse_map_size = u;\n      st->sparse_map = xcalloc (u, sizeof st->sparse_map[0]);\n      st->sparse_map_avail = 0;\n    }\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_offset_coder": {
      "start_point": [
        1419,
        0
      ],
      "end_point": [
        1425,
        1
      ],
      "content": "static void\nsparse_offset_coder (struct tar_stat_info const *st, char const *keyword,\n\t\t     struct xheader *xhdr, void const *data)\n{\n  size_t const *pi = data;\n  code_num (st->sparse_map[*pi].offset, keyword, xhdr);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_offset_decoder": {
      "start_point": [
        1427,
        0
      ],
      "end_point": [
        1442,
        1
      ],
      "content": "static void\nsparse_offset_decoder (struct tar_stat_info *st,\n\t\t       char const *keyword,\n\t\t       char const *arg,\n\t\t       size_t size __attribute__((unused)))\n{\n  uintmax_t u;\n  if (decode_num (&u, arg, TYPE_MAXIMUM (off_t), keyword))\n    {\n      if (st->sparse_map_avail < st->sparse_map_size)\n\tst->sparse_map[st->sparse_map_avail].offset = u;\n      else\n\tERROR ((0, 0, _(\"Malformed extended header: excess %s=%s\"),\n\t\t\"GNU.sparse.offset\", arg));\n    }\n}",
      "lines": 16,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_numbytes_coder": {
      "start_point": [
        1444,
        0
      ],
      "end_point": [
        1450,
        1
      ],
      "content": "static void\nsparse_numbytes_coder (struct tar_stat_info const *st, char const *keyword,\n\t\t       struct xheader *xhdr, void const *data)\n{\n  size_t const *pi = data;\n  code_num (st->sparse_map[*pi].numbytes, keyword, xhdr);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_numbytes_decoder": {
      "start_point": [
        1452,
        0
      ],
      "end_point": [
        1467,
        1
      ],
      "content": "static void\nsparse_numbytes_decoder (struct tar_stat_info *st,\n\t\t\t char const *keyword,\n\t\t\t char const *arg,\n\t\t\t size_t size __attribute__((unused)))\n{\n  uintmax_t u;\n  if (decode_num (&u, arg, TYPE_MAXIMUM (off_t), keyword))\n    {\n      if (st->sparse_map_avail < st->sparse_map_size)\n\tst->sparse_map[st->sparse_map_avail++].numbytes = u;\n      else\n\tERROR ((0, 0, _(\"Malformed extended header: excess %s=%s\"),\n\t\tkeyword, arg));\n    }\n}",
      "lines": 16,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_map_decoder": {
      "start_point": [
        1469,
        0
      ],
      "end_point": [
        1544,
        1
      ],
      "content": "static void\nsparse_map_decoder (struct tar_stat_info *st,\n\t\t    char const *keyword,\n\t\t    char const *arg,\n\t\t    size_t size __attribute__((unused)))\n{\n  int offset = 1;\n  struct sp_array e;\n\n  st->sparse_map_avail = 0;\n  while (1)\n    {\n      intmax_t u;\n      char *delim;\n\n      if (!ISDIGIT (*arg))\n\t{\n\t  ERROR ((0, 0, _(\"Malformed extended header: invalid %s=%s\"),\n\t\t  keyword, arg));\n\t  return;\n\t}\n\n      errno = 0;\n      u = strtoimax (arg, &delim, 10);\n      if (TYPE_MAXIMUM (off_t) < u)\n\t{\n\t  u = TYPE_MAXIMUM (off_t);\n\t  errno = ERANGE;\n\t}\n      if (offset)\n\t{\n\t  e.offset = u;\n\t  if (errno == ERANGE)\n\t    {\n\t      out_of_range_header (keyword, arg, 0, TYPE_MAXIMUM (off_t));\n\t      return;\n\t    }\n\t}\n      else\n\t{\n\t  e.numbytes = u;\n\t  if (errno == ERANGE)\n\t    {\n\t      out_of_range_header (keyword, arg, 0, TYPE_MAXIMUM (off_t));\n\t      return;\n\t    }\n\t  if (st->sparse_map_avail < st->sparse_map_size)\n\t    st->sparse_map[st->sparse_map_avail++] = e;\n\t  else\n\t    {\n\t      ERROR ((0, 0, _(\"Malformed extended header: excess %s=%s\"),\n\t\t      keyword, arg));\n\t      return;\n\t    }\n\t}\n\n      offset = !offset;\n\n      if (*delim == 0)\n\tbreak;\n      else if (*delim != ',')\n\t{\n\t  ERROR ((0, 0,\n\t\t  _(\"Malformed extended header: invalid %s: unexpected delimiter %c\"),\n\t\t  keyword, *delim));\n\t  return;\n\t}\n\n      arg = delim + 1;\n    }\n\n  if (!offset)\n    ERROR ((0, 0,\n\t    _(\"Malformed extended header: invalid %s: odd number of values\"),\n\t    keyword));\n}",
      "lines": 76,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dumpdir_coder": {
      "start_point": [
        1546,
        0
      ],
      "end_point": [
        1551,
        1
      ],
      "content": "static void\ndumpdir_coder (struct tar_stat_info const *st, char const *keyword,\n\t       struct xheader *xhdr, void const *data)\n{\n  xheader_print_n (xhdr, keyword, data, dumpdir_size (data));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dumpdir_decoder": {
      "start_point": [
        1553,
        0
      ],
      "end_point": [
        1561,
        1
      ],
      "content": "static void\ndumpdir_decoder (struct tar_stat_info *st,\n\t\t char const *keyword __attribute__((unused)),\n\t\t char const *arg,\n\t\t size_t size)\n{\n  st->dumpdir = xmalloc (size);\n  memcpy (st->dumpdir, arg, size);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "volume_label_coder": {
      "start_point": [
        1563,
        0
      ],
      "end_point": [
        1568,
        1
      ],
      "content": "static void\nvolume_label_coder (struct tar_stat_info const *st, char const *keyword,\n\t\t    struct xheader *xhdr, void const *data)\n{\n  code_string (data, keyword, xhdr);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "volume_label_decoder": {
      "start_point": [
        1570,
        0
      ],
      "end_point": [
        1577,
        1
      ],
      "content": "static void\nvolume_label_decoder (struct tar_stat_info *st,\n\t\t      char const *keyword __attribute__((unused)),\n\t\t      char const *arg,\n\t\t      size_t size __attribute__((unused)))\n{\n  decode_string (&volume_label, arg);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "volume_size_coder": {
      "start_point": [
        1579,
        0
      ],
      "end_point": [
        1585,
        1
      ],
      "content": "static void\nvolume_size_coder (struct tar_stat_info const *st, char const *keyword,\n\t\t   struct xheader *xhdr, void const *data)\n{\n  off_t const *v = data;\n  code_num (*v, keyword, xhdr);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "volume_size_decoder": {
      "start_point": [
        1587,
        0
      ],
      "end_point": [
        1595,
        1
      ],
      "content": "static void\nvolume_size_decoder (struct tar_stat_info *st,\n\t\t     char const *keyword,\n\t\t     char const *arg, size_t size)\n{\n  uintmax_t u;\n  if (decode_num (&u, arg, TYPE_MAXIMUM (uintmax_t), keyword))\n    continued_file_size = u;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "volume_offset_coder": {
      "start_point": [
        1598,
        0
      ],
      "end_point": [
        1604,
        1
      ],
      "content": "static void\nvolume_offset_coder (struct tar_stat_info const *st, char const *keyword,\n\t\t     struct xheader *xhdr, void const *data)\n{\n  off_t const *v = data;\n  code_num (*v, keyword, xhdr);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "volume_offset_decoder": {
      "start_point": [
        1606,
        0
      ],
      "end_point": [
        1614,
        1
      ],
      "content": "static void\nvolume_offset_decoder (struct tar_stat_info *st,\n\t\t       char const *keyword,\n\t\t       char const *arg, size_t size)\n{\n  uintmax_t u;\n  if (decode_num (&u, arg, TYPE_MAXIMUM (uintmax_t), keyword))\n    continued_file_offset = u;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "volume_filename_decoder": {
      "start_point": [
        1616,
        0
      ],
      "end_point": [
        1623,
        1
      ],
      "content": "static void\nvolume_filename_decoder (struct tar_stat_info *st,\n\t\t\t char const *keyword __attribute__((unused)),\n\t\t\t char const *arg,\n\t\t\t size_t size __attribute__((unused)))\n{\n  decode_string (&continued_file_name, arg);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattr_selinux_coder": {
      "start_point": [
        1625,
        0
      ],
      "end_point": [
        1630,
        1
      ],
      "content": "static void\nxattr_selinux_coder (struct tar_stat_info const *st, char const *keyword,\n                     struct xheader *xhdr, void const *data)\n{\n  code_string (st->cntx_name, keyword, xhdr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattr_selinux_decoder": {
      "start_point": [
        1632,
        0
      ],
      "end_point": [
        1637,
        1
      ],
      "content": "static void\nxattr_selinux_decoder (struct tar_stat_info *st,\n                       char const *keyword, char const *arg, size_t size)\n{\n  decode_string (&st->cntx_name, arg);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattr_acls_a_coder": {
      "start_point": [
        1639,
        0
      ],
      "end_point": [
        1644,
        1
      ],
      "content": "static void\nxattr_acls_a_coder (struct tar_stat_info const *st , char const *keyword,\n                    struct xheader *xhdr, void const *data)\n{\n  xheader_print_n (xhdr, keyword, st->acls_a_ptr, st->acls_a_len);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattr_acls_a_decoder": {
      "start_point": [
        1646,
        0
      ],
      "end_point": [
        1652,
        1
      ],
      "content": "static void\nxattr_acls_a_decoder (struct tar_stat_info *st,\n                      char const *keyword, char const *arg, size_t size)\n{\n  st->acls_a_ptr = xmemdup (arg, size + 1);\n  st->acls_a_len = size;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattr_acls_d_coder": {
      "start_point": [
        1654,
        0
      ],
      "end_point": [
        1659,
        1
      ],
      "content": "static void\nxattr_acls_d_coder (struct tar_stat_info const *st , char const *keyword,\n                    struct xheader *xhdr, void const *data)\n{\n  xheader_print_n (xhdr, keyword, st->acls_d_ptr, st->acls_d_len);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattr_acls_d_decoder": {
      "start_point": [
        1661,
        0
      ],
      "end_point": [
        1667,
        1
      ],
      "content": "static void\nxattr_acls_d_decoder (struct tar_stat_info *st,\n                      char const *keyword, char const *arg, size_t size)\n{\n  st->acls_d_ptr = xmemdup (arg, size + 1);\n  st->acls_d_len = size;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattr_coder": {
      "start_point": [
        1669,
        0
      ],
      "end_point": [
        1677,
        1
      ],
      "content": "static void\nxattr_coder (struct tar_stat_info const *st, char const *keyword,\n             struct xheader *xhdr, void const *data)\n{\n  struct xattr_array *xattr_map = st->xattr_map;\n  const size_t *off = data;\n  xheader_print_n (xhdr, keyword,\n                   xattr_map[*off].xval_ptr, xattr_map[*off].xval_len);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xattr_decoder": {
      "start_point": [
        1679,
        0
      ],
      "end_point": [
        1697,
        1
      ],
      "content": "static void\nxattr_decoder (struct tar_stat_info *st,\n               char const *keyword, char const *arg, size_t size)\n{\n  char *xstr, *xkey;\n\n  /* copy keyword */\n  size_t klen_raw = strlen (keyword);\n  xkey = alloca (klen_raw + 1);\n  memcpy (xkey, keyword, klen_raw + 1) /* including null-terminating */;\n\n  /* copy value */\n  xstr = alloca (size + 1);\n  memcpy (xstr, arg, size + 1); /* separator included, for GNU tar '\\n' */;\n\n  xattr_decode_keyword (xkey);\n\n  xheader_xattr_add (st, xkey + strlen(\"SCHILY.xattr.\"), xstr, size);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_major_coder": {
      "start_point": [
        1699,
        0
      ],
      "end_point": [
        1704,
        1
      ],
      "content": "static void\nsparse_major_coder (struct tar_stat_info const *st, char const *keyword,\n\t\t    struct xheader *xhdr, void const *data)\n{\n  code_num (st->sparse_major, keyword, xhdr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_major_decoder": {
      "start_point": [
        1706,
        0
      ],
      "end_point": [
        1715,
        1
      ],
      "content": "static void\nsparse_major_decoder (struct tar_stat_info *st,\n\t\t      char const *keyword,\n\t\t      char const *arg,\n\t\t      size_t size)\n{\n  uintmax_t u;\n  if (decode_num (&u, arg, TYPE_MAXIMUM (unsigned), keyword))\n    st->sparse_major = u;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_minor_coder": {
      "start_point": [
        1717,
        0
      ],
      "end_point": [
        1722,
        1
      ],
      "content": "static void\nsparse_minor_coder (struct tar_stat_info const *st, char const *keyword,\n\t\t      struct xheader *xhdr, void const *data)\n{\n  code_num (st->sparse_minor, keyword, xhdr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sparse_minor_decoder": {
      "start_point": [
        1724,
        0
      ],
      "end_point": [
        1733,
        1
      ],
      "content": "static void\nsparse_minor_decoder (struct tar_stat_info *st,\n\t\t      char const *keyword,\n\t\t      char const *arg,\n\t\t      size_t size)\n{\n  uintmax_t u;\n  if (decode_num (&u, arg, TYPE_MAXIMUM (unsigned), keyword))\n    st->sparse_minor = u;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "tar/tar-1.30/tests/argcv.c": {
    "argcv_scan": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int\nargcv_scan (int len, const char *command, const char *delim, const char* cmnt,\n\t    int *start, int *end, int *save)\n{\n  int i = 0;\n\n  for (;;)\n    {\n      i = *save;\n\n      if (i >= len)\n\treturn i + 1;\n\n      /* Skip initial whitespace */\n      while (i < len && isws (command[i]))\n\ti++;\n      *start = i;\n\n      switch (command[i])\n\t{\n\tcase '\"':\n\tcase '\\'':\n\t  while (++i < len\n\t\t && (command[i] != command[*start]\n\t\t     || command[i-1] == '\\\\'))\n\t    ;\n\t  if (i < len)\t\t/* found matching quote */\n\t    break;\n\t /*FALLTHRU*/ default:\n\t  if (isdelim (command[i], delim))\n\t    break;\n\t  /* Skip until next whitespace character or end of line. Honor\n\t     escaped whitespace. */\n\t  while (++i < len &&\n\t\t !((isws (command[i]) && command[i-1] != '\\\\')\n\t\t   || isdelim (command[i], delim)));\n\t  i--;\n\t  break;\n\t}\n\n      *end = i;\n      *save = i + 1;\n\n      /* If we have a token, and it starts with a comment character, skip\n         to the newline and restart the token search. */\n      if (*save <= len)\n\t{\n\t  if (cmnt && strchr (cmnt, command[*start]) != NULL)\n\t    {\n\t      i = *save;\n\t      while (i < len && command[i] != '\\n')\n\t\ti++;\n\n\t      *save = i;\n\t      continue;\n\t    }\n\t}\n      break;\n    }\n  return *save;\n}",
      "lines": 61,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "argcv_unescape_char": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "int\nargcv_unescape_char (int c)\n{\n  char *p;\n\n  for (p = escape_transtab; *p; p += 2)\n    {\n      if (*p == c)\n\treturn p[1];\n    }\n  return c;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "argcv_escape_char": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\nargcv_escape_char (int c)\n{\n  char *p;\n  \n  for (p = escape_transtab + sizeof(escape_transtab) - 2;\n       p > escape_transtab; p -= 2)\n    {\n      if (*p == c)\n\treturn p[-1];\n    }\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "xtonum": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static int\nxtonum (const char *src, int base, size_t cnt)\n{\n  int val;\n  char *p;\n  char tmp[4]; /* At most three characters + zero */\n  \n  /* Notice: No use to check `cnt'. It should be either 2 or 3 */\n  memcpy (tmp, src, cnt);\n  tmp[cnt] = 0;\n  val = strtoul (tmp, &p, base);\n  return (*p == 0) ? val : -1;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "escaped_length": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static size_t\nescaped_length (const char *str, int *quote)\n{\n  size_t len = 0;\n\n  for (; *str; str++)\n    {\n      if (*str == ' ')\n\t{\n\t  len++;\n\t  *quote = 1;\n\t}\n      else if (*str == '\"')\n\t{\n\t  len += 2;\n\t  *quote = 1;\n\t}\n      else if (isprint ((unsigned char) *str))\n\tlen++;\n      else if (argcv_escape_char (*str) != -1)\n\tlen += 2;\n      else\n\tlen += 4;\n    }\n  return len;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "unescape_copy": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static void\nunescape_copy (char *dst, const char *src, size_t n)\n{\n  int c;\n  \n  while (n > 0)\n    {\n      n--;\n      if (*src == '\\\\')\n\t{\n\t  switch (*++src)\n\t    {\n\t    case 'x':\n\t    case 'X':\n\t      ++src;\n\t      --n;\n\t      if (n == 0)\n\t\t{\n\t\t  *dst++ = '\\\\';\n\t\t  *dst++ = src[-1];\n\t\t}\n\t      else\n\t\t{\n\t\t  c = xtonum(src, 16, 2);\n\t\t  if (c == -1)\n\t\t    {\n\t\t      *dst++ = '\\\\';\n\t\t      *dst++ = src[-1];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst++ = c;\n\t\t      src += 2;\n\t\t      n -= 2;\n\t\t    }\n\t\t}\n\t      break;\n\t      \n\t    case '0':\n\t      ++src;\n\t      --n;\n\t      if (n == 0)\n\t\t{\n\t\t  *dst++ = '\\\\';\n\t\t  *dst++ = src[-1];\n\t\t}\n\t      else\n\t\t{\n\t\t  c = xtonum(src, 8, 3);\n\t\t  if (c == -1)\n\t\t    {\n\t\t      *dst++ = '\\\\';\n\t\t      *dst++ = src[-1];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst++ = c;\n\t\t      src += 3;\n\t\t      n -= 3;\n\t\t    }\n\t\t}\n\t      break;\n\t      \n\t    default:\n\t      *dst++ = argcv_unescape_char (*src++);\n\t      n--;\n\t    }\n\t}\n      else\n\t{\n\t  *dst++ = *src++;\n\t}\n    }\n  *dst = 0;\n}",
      "lines": 75,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "escape_copy": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static void\nescape_copy (char *dst, const char *src)\n{\n  for (; *src; src++)\n    {\n      if (*src == '\"')\n\t{\n\t  *dst++ = '\\\\';\n\t  *dst++ = '\"';\n\t}\n      else if (*src != '\\t' && isprint ((unsigned char) *src))\n\t*dst++ = *src;      \n      else\n\t{\n\t  int c = argcv_escape_char (*src);\n\t  *dst++ = '\\\\';\n\t  if (c != -1)\n\t    *dst++ = c;\n\t  else\n\t    {\n\t      char tmp[4];\n\t      snprintf (tmp, sizeof tmp, \"%03o\", *(unsigned char*)src);\n\t      memcpy (dst, tmp, 3);\n\t      dst += 3;\n\t    }\n\t}\n    }\n}",
      "lines": 28,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argcv_get": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "int\nargcv_get (const char *command, const char *delim, const char* cmnt,\n\t   int *argc, char ***argv)\n{\n  int len = strlen (command);\n  int i = 0;\n  int start, end, save;\n\n  *argv = NULL;\n\n  /* Count number of arguments */\n  *argc = 0;\n  save = 0;\n\n  while (argcv_scan (len, command, delim, cmnt, &start, &end, &save) <= len)\n      (*argc)++;\n\n  *argv = calloc ((*argc + 1), sizeof (char *));\n\n  i = 0;\n  save = 0;\n  for (i = 0; i < *argc; i++)\n    {\n      int n;\n      argcv_scan (len, command, delim, cmnt, &start, &end, &save);\n\n      if ((command[start] == '\"' || command[end] == '\\'')\n\t  && command[end] == command[start])\n\t{\n\t  start++;\n\t  end--;\n\t}\n      n = end - start + 1;\n      (*argv)[i] = calloc (n+1,  sizeof (char));\n      if ((*argv)[i] == NULL)\n\treturn 1;\n      unescape_copy ((*argv)[i], &command[start], n);\n      (*argv)[i][n] = 0;\n    }\n  (*argv)[i] = NULL;\n  return 0;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "argcv_free": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "int\nargcv_free (int argc, char **argv)\n{\n  while (--argc >= 0)\n    if (argv[argc])\n      free (argv[argc]);\n  free (argv);\n  return 1;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "argcv_string": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "int\nargcv_string (int argc, char **argv, char **pstring)\n{\n  size_t i, j, len;\n  char *buffer;\n\n  /* No need.  */\n  if (pstring == NULL)\n    return 1;\n\n  buffer = malloc (1);\n  if (buffer == NULL)\n    return 1;\n  *buffer = '\\0';\n\n  for (len = i = j = 0; i < argc; i++)\n    {\n      int quote = 0;\n      int toklen;\n\n      toklen = escaped_length (argv[i], &quote);\n      \n      len += toklen + 2;\n      if (quote)\n\tlen += 2;\n      \n      buffer = realloc (buffer, len);\n      if (buffer == NULL)\n        return 1;\n\n      if (i != 0)\n\tbuffer[j++] = ' ';\n      if (quote)\n\tbuffer[j++] = '\"';\n      escape_copy (buffer + j, argv[i]);\n      j += toklen;\n      if (quote)\n\tbuffer[j++] = '\"';\n    }\n\n  for (; j > 0 && isspace ((unsigned char) buffer[j - 1]); j--)\n    ;\n  buffer[j] = 0;\n  if (pstring)\n    *pstring = buffer;\n  return 0;\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "command": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "main(int xargc, char **xargv)\n{\n  int i, argc;\n  char **argv;\n  char *s;\n  \n  argcv_get (xargv[1] ? xargv[1]:command, \"=\", \"#\", &argc, &argv);\n  printf (\"%d args:\\n\", argc);\n  for (i = 0; i < argc; i++)\n    printf (\"%s\\n\", argv[i]);\n  printf (\"===\\n\");\n  argcv_string (argc, argv, &s);\n  printf (\"%s\\n\", s);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": null
    }
  },
  "tar/tar-1.30/tests/argcv.h": {},
  "tar/tar-1.30/tests/checkseekhole.c": {
    "check_seek_hole": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\ncheck_seek_hole (int fd)\n{\n#ifdef SEEK_HOLE\n  struct stat stat;\n  off_t offset;\n\n  /* hole of 100MB */\n  if (lseek (fd, 100*1024*1024, SEEK_END) < 0)\n    return EX_BAD;\n\n  /* piece of data */\n  if (write (fd, \"data\\n\", 5) != 5)\n    return EX_BAD;\n\n  /* another hole */\n  if (lseek (fd, 100*1024*1024, SEEK_END) < 0)\n    return EX_BAD;\n\n  /* piece of data */\n  if (write (fd, \"data\\n\", 5) != 5)\n    return EX_BAD;\n\n  if (fstat (fd, &stat))\n    return EX_BAD;\n\n  offset = lseek (fd, 0, SEEK_DATA);\n  if (offset == (off_t)-1)\n    return EX_FAIL;\n\n  offset = lseek (fd, offset, SEEK_HOLE);\n  if (offset == (off_t)-1 || offset == stat.st_size)\n    return EX_FAIL;\n\n  return EX_OK;\n#else\n  return EX_BAD;\n#endif\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain ()\n{\n#ifdef SEEK_HOLE\n  int rc;\n  char template[] = \"testseekhole-XXXXXX\";\n  int fd = mkstemp (template);\n  if (fd == -1)\n    return EX_BAD;\n  rc = check_seek_hole (fd);\n  close (fd);\n  unlink (template);\n\n  return rc;\n#else\n  return EX_FAIL;\n#endif\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/tests/ckmtime.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int fd;\n  char name[sizeof(TEMPLATE)];\n  struct stat st;\n  struct timespec ts, td;\n  double diff;\n  \n  gettime (&ts);\n  \n  strcpy (name, TEMPLATE);\n  umask (077);\n  fd = mkstemp (name);\n  assert (fd != -1);\n  unlink (name);\n  assert (fstat (fd, &st) == 0);\n  close (fd);\n\n  td = timespec_sub (get_stat_mtime (&st), ts);\n  diff = td.tv_sec * BILLION + td.tv_nsec;\n  if (diff < 0)\n    diff = - diff;\n  if (diff / BILLION >= 1)\n    {\n      fprintf (stderr, \"file timestamp unreliable\\n\");\n      return 1;\n    }\n  return 0;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "tar/tar-1.30/tests/genfile.c": {
    "xlat_suffix": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static int\nxlat_suffix (off_t *vp, const char *p)\n{\n  off_t val = *vp;\n\n  if (p[1])\n    return 1;\n  switch (p[0])\n    {\n    case 'g':\n    case 'G':\n      *vp *= 1024;\n\n    case 'm':\n    case 'M':\n      *vp *= 1024;\n\n    case 'k':\n    case 'K':\n      *vp *= 1024;\n      break;\n\n    default:\n      return 1;\n    }\n  return *vp <= val;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_size": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "static off_t\nget_size (const char *str, int allow_zero)\n{\n  const char *p;\n  off_t v = 0;\n\n  for (p = str; *p; p++)\n    {\n      int digit = *p - '0';\n      off_t x = v * 10;\n      if (9 < (unsigned) digit)\n\t{\n\t  if (xlat_suffix (&v, p))\n\t    error (EXIT_FAILURE, 0, _(\"Invalid size: %s\"), str);\n\t  else\n\t    break;\n\t}\n      else if (x / 10 != v)\n\terror (EXIT_FAILURE, 0, _(\"Number out of allowed range: %s\"), str);\n      v = x + digit;\n      if (v < 0)\n\terror (EXIT_FAILURE, 0, _(\"Negative size: %s\"), str);\n    }\n  return v;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "off_t"
      ]
    },
    "verify_file": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "void\nverify_file (char *file_name)\n{\n  if (file_name)\n    {\n      struct stat st;\n\n      if (stat (file_name, &st))\n\terror (0, errno, _(\"stat(%s) failed\"), file_name);\n\n      if (st.st_size != file_length + seek_offset)\n\terror (EXIT_FAILURE, 0, _(\"requested file length %lu, actual %lu\"),\n\t       (unsigned long)st.st_size, (unsigned long)file_length);\n\n      if (!quiet && mode == mode_sparse && !ST_IS_SPARSE (st))\n\terror (EXIT_FAILURE, 0, _(\"created file is not sparse\"));\n    }\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "reg_action": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "void\nreg_action (int action, char *arg)\n{\n  struct action *act = xmalloc (sizeof (*act));\n  act->checkpoint = checkpoint;\n  act->action = action;\n  act->pattern = pattern;\n  act->ts = touch_time;\n  act->size = file_length;\n  act->name = arg;\n  act->next = NULL;\n  if (action_tail)\n    action_tail->next = act;\n  else\n    action_head = act;\n  action_tail = act;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "parse_opt": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case '0':\n      filename_terminator = 0;\n      break;\n\n    case 'f':\n      file_name = arg;\n      break;\n\n    case 'l':\n      file_length = get_size (arg, 1);\n      break;\n\n    case 'p':\n      pattern = XARGMATCH (\"--pattern\", arg, pattern_args, pattern_types);\n      break;\n\n    case 'b':\n      block_size = get_size (arg, 0);\n      break;\n\n    case 'q':\n      quiet = 1;\n      break;\n      \n    case 's':\n      mode = mode_sparse;\n      break;\n\n    case 'S':\n      mode = mode_stat;\n      if (arg)\n\tstat_format = arg;\n      break;\n\n    case 'r':\n      mode = mode_exec;\n      if (arg)\n\t{\n\t  argcv_get (arg, \"\", NULL, &exec_argc, &exec_argv);\n\t  checkpoint_option = \"--checkpoint\";\n\t}\n      break;\n\n    case 'T':\n      files_from = arg;\n      break;\n\n    case OPT_SEEK:\n      seek_offset = get_size (arg, 0);\n      break;\n\n    case OPT_CHECKPOINT:\n      {\n\tchar *p;\n\n\tcheckpoint = strtoul (arg, &p, 0);\n\tif (*p)\n\t  argp_error (state, _(\"Error parsing number near `%s'\"), p);\n      }\n      break;\n\n    case OPT_DATE:\n      if (! parse_datetime (&touch_time, arg, NULL))\n\targp_error (state, _(\"Unknown date format\"));\n      break;\n\n    case OPT_APPEND:\n    case OPT_TRUNCATE:\n    case OPT_TOUCH:\n    case OPT_EXEC:\n    case OPT_DELETE:\n      reg_action (key, arg);\n      break;\n\n    case OPT_VERBOSE:\n      verbose++;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 88,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "fill": {
      "start_point": [
        412,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "void\nfill (FILE *fp, off_t length, enum pattern pattern)\n{\n  off_t i;\n\n  switch (pattern)\n    {\n    case DEFAULT_PATTERN:\n      for (i = 0; i < length; i++)\n\tfputc (i & 255, fp);\n      break;\n\n    case ZEROS_PATTERN:\n      for (i = 0; i < length; i++)\n\tfputc (0, fp);\n      break;\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "generate_simple_file": {
      "start_point": [
        432,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "static void\ngenerate_simple_file (char *filename)\n{\n  FILE *fp;\n\n  if (filename)\n    {\n      fp = fopen (filename, seek_offset ? \"rb+\" : \"wb\");\n      if (!fp)\n\terror (EXIT_FAILURE, errno, _(\"cannot open `%s'\"), filename);\n    }\n  else\n    fp = stdout;\n\n  if (fseeko (fp, seek_offset, 0))\n    error (EXIT_FAILURE, errno, \"%s\", _(\"cannot seek\"));\n\n  fill (fp, file_length, pattern);\n\n  fclose (fp);\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_name_from_file": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "int\nread_name_from_file (FILE *fp, struct obstack *stk)\n{\n  int c;\n  size_t counter = 0;\n\n  for (c = getc (fp); c != EOF && c != filename_terminator; c = getc (fp))\n    {\n      if (c == 0)\n\terror (EXIT_FAILURE, 0, _(\"file name contains null character\"));\n      obstack_1grow (stk, c);\n      counter++;\n    }\n\n  obstack_1grow (stk, 0);\n\n  return (counter == 0 && c == EOF);\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "generate_files_from_list": {
      "start_point": [
        474,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "void\ngenerate_files_from_list ()\n{\n  FILE *fp = strcmp (files_from, \"-\") ? fopen (files_from, \"rb\") : stdin;\n  struct obstack stk;\n\n  if (!fp)\n    error (EXIT_FAILURE, errno, _(\"cannot open `%s'\"), files_from);\n\n  obstack_init (&stk);\n  while (!read_name_from_file (fp, &stk))\n    {\n      char *name = obstack_finish (&stk);\n      generate_simple_file (name);\n      verify_file (name);\n      obstack_free (&stk, name);\n    }\n  fclose (fp);\n  obstack_free (&stk, NULL);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mkhole": {
      "start_point": [
        498,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "static void\nmkhole (int fd, off_t displ)\n{\n  off_t offset = lseek (fd, displ, SEEK_CUR);\n  if (offset < 0)\n    error (EXIT_FAILURE, errno, \"lseek\");\n  if (ftruncate (fd, offset) != 0)\n    error (EXIT_FAILURE, errno, \"ftruncate\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mksparse": {
      "start_point": [
        508,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "static void\nmksparse (int fd, off_t displ, char *marks)\n{\n  if (lseek (fd, displ, SEEK_CUR) == -1)\n    error (EXIT_FAILURE, errno, \"lseek\");\n\n  for (; *marks; marks++)\n    {\n      memset (buffer, *marks, block_size);\n      if (write (fd, buffer, block_size) != block_size)\n\terror (EXIT_FAILURE, errno, \"write\");\n    }\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "make_fragment": {
      "start_point": [
        522,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "static int\nmake_fragment (int fd, char *offstr, char *mapstr)\n{\n  int i;\n  off_t displ = get_size (offstr, 1);\n\n  file_length += displ;\n\n  if (!mapstr || !*mapstr)\n    {\n      mkhole (fd, displ);\n      return 1;\n    }\n  else if (*mapstr == '=')\n    {\n      off_t n = get_size (mapstr + 1, 1);\n\n      switch (pattern)\n\t{\n\tcase DEFAULT_PATTERN:\n\t  for (i = 0; i < block_size; i++)\n\t    buffer[i] = i & 255;\n\t  break;\n\t  \n\tcase ZEROS_PATTERN:\n\t  memset (buffer, 0, block_size);\n\t  break;\n\t}\n\n      if (lseek (fd, displ, SEEK_CUR) == -1)\n\terror (EXIT_FAILURE, errno, \"lseek\");\n      \n      for (; n; n--)\n\t{\n\t  if (write (fd, buffer, block_size) != block_size)\n\t    error (EXIT_FAILURE, errno, \"write\");\n\t  file_length += block_size;\n\t}\n    }\n  else\n    {\n      file_length += block_size * strlen (mapstr);\n      mksparse (fd, displ, mapstr);\n    }\n  return 0;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "generate_sparse_file": {
      "start_point": [
        569,
        0
      ],
      "end_point": [
        619,
        1
      ],
      "content": "static void\ngenerate_sparse_file (int argc, char **argv)\n{\n  int fd;\n  int flags = O_CREAT | O_RDWR | O_BINARY;\n\n  if (!file_name)\n    error (EXIT_FAILURE, 0,\n\t   _(\"cannot generate sparse files on standard output, use --file option\"));\n  if (!seek_offset)\n    flags |= O_TRUNC;\n  fd = open (file_name, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n  if (fd < 0)\n    error (EXIT_FAILURE, errno, _(\"cannot open `%s'\"), file_name);\n\n  buffer = xmalloc (block_size);\n\n  file_length = 0;\n\n  while (argc)\n    {\n      if (argv[0][0] == '-' && argv[0][1] == 0)\n\t{\n\t  char buf[256];\n\t  while (fgets (buf, sizeof (buf), stdin))\n\t    {\n\t      size_t n = strlen (buf);\n\n\t      while (n > 0 && c_isspace (buf[n-1]))\n\t\tbuf[--n] = 0;\n\t      \n\t      n = strcspn (buf, \" \\t\");\n\t      buf[n++] = 0;\n\t      while (buf[n] && c_isblank (buf[n]))\n\t\t++n;\n\t      make_fragment (fd, buf, buf + n);\n\t    }\n\t  ++argv;\n\t  --argc;\n\t}\n      else\n\t{\n\t  if (make_fragment (fd, argv[0], argv[1]))\n\t    break;\n\t  argc -= 2;\n\t  argv += 2;\n\t}\n    }\n\n  close (fd);\n}",
      "lines": 51,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_time": {
      "start_point": [
        624,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "void\nprint_time (time_t t)\n{\n  char buf[20]; /* ccyy-mm-dd HH:MM:SS\\0 */\n  strftime (buf, sizeof buf, \"%Y-%m-%d %H:%M:%S\", gmtime (&t));\n  printf (\"%s \", buf);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "print_stat": {
      "start_point": [
        632,
        0
      ],
      "end_point": [
        715,
        1
      ],
      "content": "void\nprint_stat (const char *name)\n{\n  char *fmt, *p;\n  struct stat st;\n  char buf[UINTMAX_STRSIZE_BOUND];\n\n  if (stat (name, &st))\n    {\n      error (0, errno, _(\"stat(%s) failed\"), name);\n      return;\n    }\n\n  fmt = strdup (stat_format);\n  for (p = strtok (fmt, \",\"); p; )\n    {\n      if (memcmp (p, \"st_\", 3) == 0)\n\tp += 3;\n      if (strcmp (p, \"name\") == 0)\n\tprintf (\"%s\", name);\n      else if (strcmp (p, \"dev\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_dev);\n      else if (strcmp (p, \"ino\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_ino);\n      else if (strncmp (p, \"mode\", 4) == 0)\n\t{\n\t  unsigned val = st.st_mode;\n\n\t  if (ispunct ((unsigned char) p[4]))\n\t    {\n\t      char *q;\n\n\t      val &= strtoul (p + 5, &q, 8);\n\t      if (*q)\n\t\t{\n\t\t  printf (\"\\n\");\n\t\t  error (EXIT_FAILURE, 0, _(\"incorrect mask (near `%s')\"), q);\n\t\t}\n\t    }\n\t  else if (p[4])\n\t    {\n\t      printf (\"\\n\");\n\t      error (EXIT_FAILURE, 0, _(\"Unknown field `%s'\"), p);\n\t    }\n\t  printf (\"%0o\", val);\n\t}\n      else if (strcmp (p, \"nlink\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_nlink);\n      else if (strcmp (p, \"uid\") == 0)\n\tprintf (\"%ld\", (long unsigned) st.st_uid);\n      else if (strcmp (p, \"gid\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_gid);\n      else if (strcmp (p, \"size\") == 0)\n\tprintf (\"%s\", umaxtostr (st.st_size, buf));\n      else if (strcmp (p, \"blksize\") == 0)\n\tprintf (\"%s\", umaxtostr (st.st_blksize, buf));\n      else if (strcmp (p, \"blocks\") == 0)\n\tprintf (\"%s\", umaxtostr (st.st_blocks, buf));\n      else if (strcmp (p, \"atime\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_atime);\n      else if (strcmp (p, \"atimeH\") == 0)\n\tprint_time (st.st_atime);\n      else if (strcmp (p, \"mtime\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_mtime);\n      else if (strcmp (p, \"mtimeH\") == 0)\n\tprint_time (st.st_mtime);\n      else if (strcmp (p, \"ctime\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_ctime);\n      else if (strcmp (p, \"ctimeH\") == 0)\n\tprint_time (st.st_ctime);\n      else if (strcmp (p, \"sparse\") == 0)\n\tprintf (\"%d\", ST_IS_SPARSE (st));\n      else\n\t{\n\t  printf (\"\\n\");\n\t  error (EXIT_FAILURE, 0, _(\"Unknown field `%s'\"), p);\n\t}\n      p = strtok (NULL, \",\");\n      if (p)\n\tprintf (\" \");\n    }\n  printf (\"\\n\");\n  free (fmt);\n}",
      "lines": 84,
      "depth": 29,
      "decorators": [
        "void"
      ]
    },
    "exec_checkpoint": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "void\nexec_checkpoint (struct action *p)\n{\n  if (verbose)\n    printf (\"processing checkpoint %lu\\n\", (unsigned long) p->checkpoint);\n  switch (p->action)\n    {\n    case OPT_TOUCH:\n      {\n\tstruct timespec ts[2];\n\n\tts[0] = ts[1] = p->ts;\n\tif (utimensat (AT_FDCWD, p->name, ts, 0) != 0)\n\t  {\n\t    error (0, errno, _(\"cannot set time on `%s'\"), p->name);\n\t    break;\n\t  }\n      }\n      break;\n\n    case OPT_APPEND:\n      {\n\tFILE *fp = fopen (p->name, \"ab\");\n\tif (!fp)\n\t  {\n\t    error (0, errno, _(\"cannot open `%s'\"), p->name);\n\t    break;\n\t  }\n\n\tfill (fp, p->size, p->pattern);\n\tfclose (fp);\n      }\n      break;\n\n    case OPT_TRUNCATE:\n      {\n\tint fd = open (p->name, O_RDWR | O_BINARY);\n\tif (fd == -1)\n\t  {\n\t    error (0, errno, _(\"cannot open `%s'\"), p->name);\n\t    break;\n\t  }\n\tif (ftruncate (fd, p->size) != 0)\n\t  {\n\t    error (0, errno, _(\"cannot truncate `%s'\"), p->name);\n\t    break;\n\t  }\n\tclose (fd);\n      }\n      break;\n\n    case OPT_EXEC:\n      if (system (p->name) != 0)\n\terror (0, 0, _(\"command failed: %s\"), p->name);\n      break;\n\n    case OPT_DELETE:\n      {\n\tstruct stat st;\n\tif (stat (p->name, &st))\n\t  error (0, errno, _(\"cannot stat `%s'\"), p->name);\n\telse if (S_ISDIR (st.st_mode))\n\t  {\n\t    if (rmdir (p->name))\n\t      error (0, errno, _(\"cannot remove directory `%s'\"), p->name);\n\t  }\n\telse if (unlink (p->name))\n\t  error (0, errno, _(\"cannot unlink `%s'\"), p->name);\n      }\n      break;\n\n    default:\n      abort ();\n    }\n}",
      "lines": 75,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "process_checkpoint": {
      "start_point": [
        796,
        0
      ],
      "end_point": [
        822,
        1
      ],
      "content": "void\nprocess_checkpoint (size_t n)\n{\n  struct action *p, *prev = NULL;\n\n  for (p = action_head; p; )\n    {\n      struct action *next = p->next;\n\n      if (p->checkpoint <= n)\n\t{\n\t  exec_checkpoint (p);\n\t  /* Remove the item from the list */\n\t  if (prev)\n\t    prev->next = next;\n\t  else\n\t    action_head = next;\n\t  if (next == NULL)\n\t    action_tail = prev;\n\t  free (p);\n\t}\n      else\n\tprev = p;\n\n      p = next;\n    }\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "exec_command": {
      "start_point": [
        826,
        0
      ],
      "end_point": [
        937,
        1
      ],
      "content": "void\nexec_command (void)\n{\n  int status;\n  pid_t pid;\n  int fd[2];\n  char *p;\n  FILE *fp;\n  char buf[128];\n\n  /* Insert --checkpoint option.\n     FIXME: This assumes that exec_argv does not use traditional tar options\n     (without dash).\n     FIXME: There is no way to set checkpoint argument (granularity).\n  */\n  if (checkpoint_option)\n    {\n      exec_argc++;\n      exec_argv = xrealloc (exec_argv, (exec_argc + 1) * sizeof (*exec_argv));\n      memmove (exec_argv+2, exec_argv+1,\n\t       (exec_argc - 1) * sizeof (*exec_argv));\n      exec_argv[1] = checkpoint_option;\n    }\n\n#ifdef SIGCHLD\n  /* System V fork+wait does not work if SIGCHLD is ignored.  */\n  signal (SIGCHLD, SIG_DFL);\n#endif\n\n  if (pipe (fd) != 0)\n    error (EXIT_FAILURE, errno, \"pipe\");\n\n  pid = fork ();\n  if (pid == -1)\n    error (EXIT_FAILURE, errno, \"fork\");\n\n  if (pid == 0)\n    {\n      /* Child */\n\n      /* Pipe stderr */\n      if (fd[1] != 2)\n\tdup2 (fd[1], 2);\n      close (fd[0]);\n\n      /* Make sure POSIX locale is used */\n      setenv (\"LC_ALL\", \"POSIX\", 1);\n\n      execvp (exec_argv[0], exec_argv);\n      error (EXIT_FAILURE, errno, \"execvp %s\", exec_argv[0]);\n    }\n\n  /* Master */\n  close (fd[1]);\n  fp = fdopen (fd[0], \"rb\");\n  if (fp == NULL)\n    error (EXIT_FAILURE, errno, \"fdopen\");\n\n  while ((p = fgets (buf, sizeof buf, fp)))\n    {\n      while (*p && !isspace ((unsigned char) *p) && *p != ':')\n\tp++;\n\n      if (*p == ':')\n\t{\n\t  for (p++; *p && isspace ((unsigned char) *p); p++)\n\t    ;\n\n\t  if (*p\n\t      && memcmp (p, CHECKPOINT_TEXT, sizeof CHECKPOINT_TEXT - 1) == 0)\n\t    {\n\t      char *end;\n\t      size_t n = strtoul (p + sizeof CHECKPOINT_TEXT - 1, &end, 10);\n\t      if (!(*end && !isspace ((unsigned char) *end)))\n\t\t{\n\t\t  process_checkpoint (n);\n\t\t  continue;\n\t\t}\n\t    }\n\t}\n      fprintf (stderr, \"%s\", buf);\n    }\n\n  /* Collect exit status */\n  waitpid (pid, &status, 0);\n\n  if (verbose)\n    {\n      if (WIFEXITED (status))\n\t{\n\t  if (WEXITSTATUS (status) == 0)\n\t    printf (_(\"Command exited successfully\\n\"));\n\t  else\n\t    printf (_(\"Command failed with status %d\\n\"),\n\t\t    WEXITSTATUS (status));\n\t}\n      else if (WIFSIGNALED (status))\n\tprintf (_(\"Command terminated on signal %d\\n\"), WTERMSIG (status));\n      else if (WIFSTOPPED (status))\n\tprintf (_(\"Command stopped on signal %d\\n\"), WSTOPSIG (status));\n#ifdef WCOREDUMP\n      else if (WCOREDUMP (status))\n\tprintf (_(\"Command dumped core\\n\"));\n#endif\n      else\n\tprintf(_(\"Command terminated\\n\"));\n    }\n\n  if (WIFEXITED (status))\n    exit (WEXITSTATUS (status));\n  exit (EXIT_FAILURE);\n}",
      "lines": 112,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        1002,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int index;\n\n  program_name = argv[0];\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  parse_datetime (&touch_time, \"now\", NULL);\n\n  /* Decode command options.  */\n\n  if (argp_parse (&argp, argc, argv, 0, &index, NULL))\n    exit (EXIT_FAILURE);\n\n  argc -= index;\n  argv += index;\n\n  switch (mode)\n    {\n    case mode_stat:\n      if (argc == 0)\n\terror (EXIT_FAILURE, 0, _(\"--stat requires file names\"));\n\n      while (argc--)\n\tprint_stat (*argv++);\n      break;\n\n    case mode_sparse:\n      generate_sparse_file (argc, argv);\n      verify_file (file_name);\n      break;\n\n    case mode_generate:\n      if (argc)\n\terror (EXIT_FAILURE, 0, _(\"too many arguments\"));\n      if (files_from)\n\tgenerate_files_from_list ();\n      else\n\t{\n\t  generate_simple_file (file_name);\n\t  verify_file (file_name);\n\t}\n      break;\n\n    case mode_exec:\n      if (!checkpoint_option)\n\t{\n\t  exec_argc = argc;\n\t  exec_argv = argv;\n\t}\n      else if (argc)\n\terror (EXIT_FAILURE, 0, _(\"too many arguments\"));\n      exec_command ();\n      break;\n\n    default:\n      /* Just in case */\n      abort ();\n    }\n  exit (EXIT_SUCCESS);\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  }
}